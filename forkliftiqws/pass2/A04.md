# A04 - Pass 2: Test Coverage
**Date:** 2026-02-27
**Agent:** A04
**Scope:** ManufacturerDAO.java, ManufacturerDAOImpl.java, UserDAO.java

---

## Reading Evidence

### File 1: ManufacturerDAO.java
**Path:** `src/main/java/com/journaldev/spring/jdbc/DAO/ManufacturerDAO.java`

- **Type:** Interface
- **Class/Interface:** `ManufacturerDAO` (line 7)
- **Methods:**
  - `getManufacturersForUser(String username)` — line 8, returns `List<Manufacturer>`
- **Imports / referenced types:** `com.journaldev.spring.jdbc.model.Manufacturer`, `java.util.List`
- **Constants / errors:** none declared

---

### File 2: ManufacturerDAOImpl.java
**Path:** `src/main/java/com/journaldev/spring/jdbc/DAO/ManufacturerDAOImpl.java`

- **Type:** `@Component("manufacturerDAO")` class implementing `ManufacturerDAO`, extends `JdbcDaoSupport`
- **Class:** `ManufacturerDAOImpl` (line 16)
- **Fields:**
  - `private static final Logger logger` — line 17 (SLF4J)
- **Methods:**
  - `setDbDataSource(DataSource dataSource)` — line 21, `@Autowired @Qualifier("dataSource")`, delegates to `super.setDataSource(dataSource)`
  - `getManufacturersForUser(String username)` — line 26, `@Override`, executes a 3-branch SQL query
- **SQL query (lines 29-33):**
  - Returns manufacturers where `company_id` is in driver-permission subquery OR company-email subquery OR `company_id IS NULL`, ordered by name
  - Two bind parameters: `username` (used for both driver email lookup and company email lookup)
  - Uses `BeanPropertyRowMapper<>(Manufacturer.class)`
- **Referenced types:** `Manufacturer`, `Logger`, `DataSource`, `JdbcDaoSupport`, `BeanPropertyRowMapper`
- **Error paths declared:** none (no try/catch; delegates exception propagation to Spring JDBC)

---

### File 3: UserDAO.java
**Path:** `src/main/java/com/journaldev/spring/jdbc/DAO/UserDAO.java`

- **Type:** `@Component @Transactional` class, extends `JdbcDaoSupport`
- **Class:** `UserDAO` (line 22)
- **Fields / Constants:**
  - `private static final Logger logger` — line 23 (SLF4J, declared but never called in any method body)
  - `QUERY_USER_BY_NAME` — line 31, private static final String, queries `v_apiusers` view filtering `active = true`, matching by `name` OR `md5(name)`, ordered by email
  - `QUERY_ROLE_BY_AUTHORITY` — line 60, private static final String, queries `roles` table by `authority`
- **Methods:**
  - `setDbDataSource(DataSource dataSource)` — line 27, `@Autowired @Qualifier("dataSource")`, delegates to `super.setDataSource(dataSource)`
  - `findByName(final String name)` — line 33, returns `Optional<User>`
    - Uses `getJdbcTemplate().query(...)` with `ResultSetExtractor` lambda
    - Iterates ResultSet, builds `User` object from first row (name, email, password, active)
    - Accumulates `Roles` objects across all rows via `user.addRoles(...)`
    - Returns `Optional.empty()` if result is null, else `Optional.of(result)`
  - `findByAuthority(final String authority)` — line 61, returns `Optional<Roles>`
    - Uses `getJdbcTemplate().queryForObject(...)` with `BeanPropertyRowMapper.newInstance(Roles.class)`
    - Returns `Optional.empty()` if result is null, else `Optional.of(result)`
- **Referenced types:** `User`, `Roles`, `DataSource`, `JdbcDaoSupport`, `BeanPropertyRowMapper`, `Optional`
- **Error paths declared:** none (no try/catch)

---

## Test Coverage Summary

### Test files found under `src/test/java/`:
1. `PackageEntryTest.java` — tests `PackageEntry.compareTo()`
2. `APKUpdaterServiceTest.java` — all test methods are commented out; contains zero active tests
3. `DateUtilTest.java` — tests `DateUtil.parseDateIso()` and `DateUtil.parseDateTimeIso()`

### Grep result for DAO class names in test tree:
- `ManufacturerDAO` — **0 matches**
- `ManufacturerDAOImpl` — **0 matches**
- `UserDAO` — **0 matches**

### Grep result for method names in test tree:
- `getManufacturersForUser` — **0 matches**
- `findByName` — **0 matches**
- `findByAuthority` — **0 matches**

**Conclusion: Zero direct or indirect test coverage exists for any of the three source files under audit.**

---

## Findings

---

### A04-1
**Severity:** CRITICAL
**File:** `ManufacturerDAOImpl.java` / `ManufacturerDAO.java`
**Method:** `getManufacturersForUser(String username)` — line 26
**Finding:** No unit tests or integration tests exist for this method. The method is the sole implementation of the only interface method in `ManufacturerDAO`. Zero tests verify that the SQL query returns correct results for any input, that the `BeanPropertyRowMapper` correctly maps `id` and `name` columns to `Manufacturer` fields, or that the method produces any output at all. The method is called at runtime in `EquipmentController.getManufactureList()` (line 81 of `EquipmentController.java`) and is entirely untested.

---

### A04-2
**Severity:** CRITICAL
**File:** `UserDAO.java`
**Method:** `findByName(final String name)` — line 33
**Finding:** No unit tests or integration tests exist for this method. The method is called in two production paths: `UserDetailsServiceImpl.loadUserByUsername()` (line 29) — the Spring Security authentication entry point — and `UserController.getUserByEmail()` (line 25). No test verifies that the `ResultSetExtractor` lambda correctly builds a `User` object, that multiple rows correctly accumulate into a single `User` with multiple `Roles`, or that the `Optional.empty()` return is triggered when the query returns no rows.

---

### A04-3
**Severity:** CRITICAL
**File:** `UserDAO.java`
**Method:** `findByAuthority(final String authority)` — line 61
**Finding:** No unit tests or integration tests exist for this method. The method is called in `DriverService.registerDriver()` (line 74) as part of the driver registration flow, where the result is consumed with `.orElseThrow(IllegalStateException::new)`. No test verifies correct mapping via `BeanPropertyRowMapper`, the behavior when the authority does not exist, or the `Optional.empty()` branch.

---

### A04-4
**Severity:** HIGH
**File:** `UserDAO.java`
**Method:** `findByAuthority(final String authority)` — line 61-64
**Finding:** `queryForObject` throws `EmptyResultDataAccessException` (a `DataAccessException` subclass) when the query returns zero rows. This exception is not caught anywhere in `findByAuthority`. The null-check on line 63 (`roles == null`) is therefore unreachable in practice: `queryForObject` never returns `null` for a zero-row result — it throws. The `Optional.empty()` return path (line 64) can never be exercised, making the method contract misleading. No test exists to expose this defect.

---

### A04-5
**Severity:** HIGH
**File:** `UserDAO.java`
**Method:** `findByAuthority(final String authority)` — line 61
**Finding:** `queryForObject` also throws `IncorrectResultSizeDataAccessException` if the query returns more than one row (i.e., if the `roles` table contains duplicate `authority` values). There is no unique-constraint validation in the DAO, no guard clause, and no test to verify behavior when the `authority` column is not unique in the database.

---

### A04-6
**Severity:** HIGH
**File:** `ManufacturerDAOImpl.java`
**Method:** `getManufacturersForUser(String username)` — lines 29-33
**Finding:** The SQL query passes `username` as both the first and second bind parameter (driver email lookup and company email lookup). No test verifies the correct ordering of bind parameters, nor that substituting a null or empty string for `username` does not produce a SQL error or an unintended full-table scan. The `new Object[]{username, username}` construction is entirely untested.

---

### A04-7
**Severity:** HIGH
**File:** `ManufacturerDAOImpl.java`
**Method:** `getManufacturersForUser(String username)` — lines 29-33
**Finding:** The SQL query contains a formatting defect: the string concatenation on lines 31 and 32 does not include a space before `or company_id in`. The concatenated SQL reads `...permission where driver_id in (select id from driver where email = ?))or company_id in...`. While some SQL parsers may accept this, no test catches this edge, and the absence of tests means neither the defect nor any future regression can be detected automatically.

---

### A04-8
**Severity:** MEDIUM
**File:** `UserDAO.java`
**Method:** `findByName(final String name)` — lines 33-58
**Finding:** The `QUERY_USER_BY_NAME` matches on both `u.name = ?` and `md5(u.name) = ?` (line 31). The md5 branch is designed to support hashed-name lookups. No test verifies that passing an md5-formatted string correctly resolves a user, that passing a plain name does not accidentally match an md5 column value, or that the ordering `ORDER BY email` returns rows in the expected sequence for the multi-role accumulation loop.

---

### A04-9
**Severity:** MEDIUM
**File:** `UserDAO.java`
**Method:** `findByName(final String name)` — lines 36-55
**Finding:** The `ResultSetExtractor` lambda initialises `user` to null and populates it only from the first row, then accumulates roles from all subsequent rows. No test verifies the multi-role accumulation path: specifically, that a user with zero roles, one role, or multiple roles returns an `Optional<User>` with the correct `Set<Roles>` contents. The `addRoles` method on `User` uses a `HashSet`, so duplicate roles are silently deduplicated; this behaviour is also untested.

---

### A04-10
**Severity:** MEDIUM
**File:** `UserDAO.java`
**Field:** `private static final Logger logger` — line 23
**Finding:** A `Logger` field is declared but never invoked in any method of `UserDAO`. The `ManufacturerDAOImpl` counterpart logs at INFO level on entry (line 27); `UserDAO` does not log entry, parameters, or any diagnostic information for either `findByName` or `findByAuthority`. While not a correctness defect, the absence of logging in security-critical authentication lookup paths (`findByName` is called by Spring Security) makes diagnosis of authentication failures impossible without a test to confirm query execution. The logger field is dead code.

---

### A04-11
**Severity:** MEDIUM
**File:** `ManufacturerDAOImpl.java`
**Method:** `getManufacturersForUser(String username)` — line 27
**Finding:** The method logs `username` at INFO level unconditionally. In a multi-tenant system where `username` is an email address used for authentication decisions, logging PII at INFO level to a potentially persistent log sink is a data handling concern. No test verifies what is logged, and no scrubbing or truncation is applied.

---

### A04-12
**Severity:** LOW
**File:** `ManufacturerDAO.java`
**Finding:** The interface declares a single method. There is no Javadoc on the interface or its method. The contract for null inputs (e.g., `username = null`) is undefined. No test exercises the null-username edge case, and no guard exists in the implementation.

---

### A04-13
**Severity:** LOW
**File:** `UserDAO.java`
**Method:** `setDbDataSource(DataSource dataSource)` — line 27
**Method:** `ManufacturerDAOImpl.setDbDataSource(DataSource dataSource)` — line 21
**Finding:** Both `@Autowired` datasource-injection methods are completely untested. If the `"dataSource"` bean is unavailable or misconfigured at startup, the failure mode is a runtime `BeanCreationException`. No test covers wiring validation for either DAO, meaning datasource misconfiguration is only discovered at application startup rather than at build time.

---

### A04-14
**Severity:** INFO
**File:** All three source files
**Finding:** The entire test suite (`src/test/java/`) contains only three test files, none of which test any DAO class. The `APKUpdaterServiceTest` has all tests commented out and effectively contributes zero test cases. There is no test infrastructure for database-layer testing: no in-memory database configuration (H2, HSQLDB), no `@JdbcTest` or `@DataJpaTest` slices, and no test doubles (mocks) for `JdbcTemplate` or `DataSource` in any test file. The DAO layer has 0% test coverage by all measures.
