# Pass 2 — Agent A01: Test Coverage

## Reading Evidence

### APIDAO.java
- **Class/Interface:** `APIDAO` (interface)
- **Methods:** `checkKey(String APIkey)` (line 10), `findByName(String username)` (line 11)
- **Types/Errors/Constants:** Returns `boolean`; returns `Driver` model

### APIDAOImpl.java
- **Class/Interface:** `APIDAOImpl` (concrete class, `@Component("apiDao")`, `@Transactional(readOnly = true)`, extends `JdbcDaoSupport`, implements `APIDAO`)
- **Methods:**
  - `setDbDataSource(DataSource dataSource)` (line 24) — `@Autowired` / `@Qualifier("dataSource")` wiring method
  - `checkKey(String key)` (line 28) — always returns `true`
  - `findByName(String username)` (line 36) — executes SQL `select * from tblusers where md5(email) = ?`, calls `queryForObject` with raw `Driver.class`
- **Types/Errors/Constants:**
  - Logger: `org.slf4j.Logger` via `LoggerFactory`
  - Throws implicitly: `org.springframework.dao.EmptyResultDataAccessException` (if no row found), `org.springframework.dao.IncorrectResultSizeDataAccessException` (if multiple rows found) — both uncaught
  - SQL: hardcoded `"select * from tblusers where md5(email) = ?"`
  - Annotation: `@Transactional(readOnly = true)` at class level

### CompanyDAO.java
- **Class/Interface:** `CompanyDAO` (concrete class, `@Repository`, extends `JdbcDaoSupport`)
- **Methods:**
  - `setDbDataSource(DataSource dataSource)` (line 32) — `@Autowired` / `@Qualifier("dataSource")` wiring method
  - `save(Company company, int driverId, String email, String password)` (line 36) — returns `int` (new company id)
  - `findById(Long comp_id)` (line 62) — returns `Optional<Company>`
  - `findAllByDriverId(Long driverId)` (line 74) — returns `List<Company>`
  - `findAllByKeyword(String keyword)` (line 87) — returns `List<Company>`
  - `CompaniesResultResetExtractor.extractData(ResultSet rs)` (line 100) — inner static class, implements `ResultSetExtractor<List<Company>>`
  - `CompanyResultResetExtractor.extractData(ResultSet rs)` (line 139) — inner static class, implements `ResultSetExtractor<Company>`
  - `mapCompany(ResultSet rs)` (line 160) — private static helper
- **Types/Errors/Constants:**
  - Static constant: `BASE_QUERY_COMPANY` (line 52) — multi-table join SQL string
  - Inner classes: `CompaniesResultResetExtractor`, `CompanyResultResetExtractor`
  - Models used: `Company`, `Driver`, `Permissions`, `Roles`, `Configuration`
  - Imports: `DataAccessException`, `BeanPropertyRowMapper` (imported but unused), `ResultSetExtractor`, `JdbcTemplate` (imported but unused as field)
  - `@Transactional` absent — class has no transaction annotation despite performing multi-statement writes in `save()`

---

## Findings

### A01-1 [CRITICAL] No tests exist for APIDAO, APIDAOImpl, or CompanyDAO
**File:** All three source files
**Description:** The entire test suite contains only three test classes: `PackageEntryTest`, `APKUpdaterServiceTest`, and `DateUtilTest`. A grep of `src/test/java` for every class name, method name, and bean qualifier from these three files (`APIDAO`, `APIDAOImpl`, `CompanyDAO`, `checkKey`, `findByName`, `findById`, `findAllByDriverId`, `findAllByKeyword`, `companyDAO`, `apiDao`) returns zero matches. There is zero unit or integration test coverage for these DAO classes.

---

### A01-2 [CRITICAL] `APIDAOImpl.checkKey` is a stub that always returns `true`
**File:** `APIDAOImpl.java`, line 28–34
**Description:** The method `checkKey(String key)` unconditionally returns `true` regardless of the input key value. The SQL query that should implement the check is commented out (line 30: `//String sql = "INSERT INTO CUSTOMER..."`). Any caller receiving `true` assumes the API key is valid when no actual validation occurs. No test exists to detect this regression. The method name and interface contract imply real validation logic.

---

### A01-3 [CRITICAL] `APIDAOImpl.findByName` uses `queryForObject` with `Driver.class` as a RowMapper — incorrect API usage
**File:** `APIDAOImpl.java`, line 40
**Description:** The call `getJdbcTemplate().queryForObject(sql, Driver.class, username)` passes `Driver.class` as the second argument to `queryForObject`. Spring's `queryForObject(String, Class<T>, Object...)` overload is intended for simple scalar types (e.g., `String.class`, `Integer.class`) and will throw `IncorrectResultSetColumnCountException` at runtime when the result set contains more than one column. `Driver` is a multi-field POJO, not a scalar. The correct overload requires a `RowMapper` (e.g., `BeanPropertyRowMapper<Driver>`). No test exists to catch this runtime failure.

---

### A01-4 [HIGH] `APIDAOImpl.findByName` propagates uncaught `EmptyResultDataAccessException` when no user is found
**File:** `APIDAOImpl.java`, line 36–42
**Description:** `queryForObject` throws `EmptyResultDataAccessException` when the query returns no rows. The method has no try/catch and no null-return fallback. Callers (e.g., authentication pipelines) will receive an unhandled Spring DAO exception rather than a controlled `null` or `Optional.empty()` result. No test verifies the not-found path.

---

### A01-5 [HIGH] `APIDAOImpl.findByName` propagates uncaught `IncorrectResultSizeDataAccessException` when multiple users match
**File:** `APIDAOImpl.java`, line 36–42
**Description:** The SQL `select * from tblusers where md5(email) = ?` could theoretically match more than one row in the event of an MD5 collision or a data anomaly. `queryForObject` throws `IncorrectResultSizeDataAccessException` in this case. This is unhandled and untested.

---

### A01-6 [HIGH] `CompanyDAO.findByName` (via `CompanyResultResetExtractor`) throws `NullPointerException` when the result set is empty
**File:** `CompanyDAO.java`, line 154
**Description:** In `CompanyResultResetExtractor.extractData`, the variable `cie` is initialized to `null` (line 140). If the query returns no rows the `while` loop body never executes, so `cie` remains `null`. Line 154 calls `cie.setArrRoles(roles)` unconditionally, which throws `NullPointerException`. The calling method `findById` wraps the result in `Optional.ofNullable`, but the NPE is thrown before that wrapping occurs. No test exercises the empty-result path.

---

### A01-7 [HIGH] `CompanyDAO.save` is not `@Transactional` despite performing multiple non-atomic write operations
**File:** `CompanyDAO.java`, line 36–50
**Description:** `save()` executes four separate SQL statements: a sequence fetch, an insert into `company`, one or more inserts into `compnay_role_rel` (via `forEach`), and an insert into `permission`. If any statement after the first succeeds but a later one fails, the database is left in a partially written state with no rollback. The class carries no `@Transactional` annotation at the class or method level. No test verifies atomicity or failure rollback.

---

### A01-8 [MEDIUM] `CompanyDAO.findAllByKeyword` is vulnerable to implicit wildcard injection via keyword concatenation
**File:** `CompanyDAO.java`, line 92
**Description:** The keyword is concatenated directly into the LIKE pattern: `"%"+keyword+"%"`. While this is passed as a prepared statement parameter (not string-concatenated into the SQL itself, so SQL injection is not the risk), an input containing `%` or `_` characters acts as additional wildcards, potentially returning far more rows than intended. There is no escaping of LIKE metacharacters before binding. No test covers wildcard-containing inputs.

---

### A01-9 [MEDIUM] `CompanyDAO.findAllByKeyword` returns an empty list when `keyword` is null, with no null guard
**File:** `CompanyDAO.java`, line 87–96
**Description:** If `keyword` is `null`, the expression `"%"+null+"%"` evaluates to `"%null%"`, performing a literal string search for the text "null" rather than failing or returning all records. The behavior is silently incorrect. No null guard or validation exists, and no test covers null or empty string inputs.

---

### A01-10 [MEDIUM] `CompaniesResultResetExtractor` uses reference equality (`!=`) to compare `Long` objects
**File:** `CompanyDAO.java`, line 110
**Description:** The expression `if (companyId != previousCompanyId)` compares two `Long` objects using reference equality (`!=`) rather than `!companyId.equals(previousCompanyId)`. For `Long` values outside the JVM cached range (-128 to 127), two distinct `Long` objects representing the same numeric ID will not be `==`, causing duplicate `Company` entries to be added to the result list instead of being merged. No test covers company IDs above 127.

---

### A01-11 [MEDIUM] `CompaniesResultResetExtractor` fails to attach roles to the final company when roles list is empty
**File:** `CompanyDAO.java`, lines 111–113 and 128–130
**Description:** In `CompaniesResultResetExtractor.extractData`, roles are only applied to a company when the next company group is encountered (`if (company != null && !roles.isEmpty())`, line 111) or at the end of the loop (line 128). If a company has no associated roles, the roles list is empty and `setArrRoles` is never called for that company, leaving `arrRoles` as whatever the model default is (likely `null`). Callers iterating `arrRoles` without a null check would throw NPE. No test covers companies without roles.

---

### A01-12 [MEDIUM] `APIDAOImpl.findByName` logs the username at INFO level before authentication completes
**File:** `APIDAOImpl.java`, line 37
**Description:** The log message `"Start checkKey for : {}"` (note: mismatched method name in log) logs the raw `username` (which is an MD5-hashed email passed from callers) at INFO level. If the logging configuration ever ships at DEBUG and the caller logs the raw email, correlation is possible. More critically, the log message label says "checkKey" when the method is `findByName`, indicating copy-paste error and misleading log tracing. No test verifies logging behavior or detects the mislabeled log statement.

---

### A01-13 [LOW] `APIDAO` interface declares `checkKey` but the implementation is a permanent stub with no interface-level contract documentation
**File:** `APIDAO.java`, lines 10–11; `APIDAOImpl.java`, lines 28–34
**Description:** The interface provides no Javadoc to describe expected behavior, error conditions, or return value semantics for either method. The implementation of `checkKey` is permanently broken (always returns `true`). Without documentation or tests, there is no executable or readable specification of intended behavior.

---

### A01-14 [LOW] `APKUpdaterServiceTest` has its only meaningful tests commented out
**File:** `src/test/java/com/journaldev/spring/jdbc/service/APKUpdaterServiceTest.java`, lines 17–44
**Description:** The two test methods `getAvailablePackage` and `getAvailablePackageWhenAlreadyHaveLatest` are wrapped in a block comment, leaving the test class with no active test methods. The test class compiles and runs but contributes no assertions. This is noted as context: it reflects a pattern of test neglect consistent with the complete absence of DAO tests.
