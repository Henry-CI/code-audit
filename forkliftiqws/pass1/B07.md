# Pass 1 Security Review — Agent B07
**Date:** 2026-02-27
**Repo:** forkliftiqws (branch: master)
**Assigned files:**
- `src/main/java/com/journaldev/spring/jdbc/controller/DriverController.java`
- `src/main/java/com/journaldev/spring/jdbc/controller/EquipmentController.java`

**Supporting files read for context:**
- `controller/ConfigurationController.java`
- `controller/RestURIConstants.java`
- `controller/RuntimeConfig.java`
- `service/DriverService.java`
- `DAO/DriverDAOImpl.java`
- `DAO/EquipmentDAOImpl.java`
- `model/Driver.java`
- `model/Equipment.java`
- `model/DriverEmails.java`
- `service/LocalFileStorageService.java`
- `service/AbstractFileStorageService.java`
- `util/Configuration.java`
- `WEB-INF/spring/spring-security.xml`
- `WEB-INF/web.xml`
- `WEB-INF/spring/appServlet/servlet-context.xml`
- `src/main/resources/fleetiq360ws.properties`
- `environment.dev.properties`
- `environment.uat.properties`
- `environment.prod.properties`
- `pom.xml`

---

## STEP 3 — Reading Evidence

### File 1: DriverController.java

**Fully qualified class name:** `com.journaldev.spring.jdbc.controller.DriverController`

**Extends:** `com.journaldev.spring.jdbc.controller.ConfigurationController`

**Implements:** (none beyond superclass)

**Class-level annotations:**
- `@Controller`
- `@Slf4j`

**Fields:**
- `private FileStorageService fileStorageService` — `@Autowired @Qualifier("localFileStorage")`
- `private DriverService driverService` — `@Autowired`
- `private DriverDAO driverDAO` — `@Autowired`
- `Gson gson` — package-private, instantiated inline (`= new Gson()`)

**Inherited fields (from ConfigurationController):**
- `protected Configuration configuration` — `@Autowired`
- `protected DataSource dataSource` — `@Autowired @Qualifier("dataSource")`

**Public methods:**

| Line | Return type | Method name | Parameters | Annotations |
|------|-------------|-------------|------------|-------------|
| 57–73 | `ResponseEntity<List<Driver>>` | `getLoginAuth` | `@RequestBody Driver driverExample` | `@RequestMapping(value=VALIDATE_USR, method=POST)`, `@ResponseBody`, `@Deprecated` |
| 75–87 | `ResponseEntity<Driver>` | `registerDrivers` | `@RequestBody Driver driver` | `@RequestMapping(value=CREATE_APPUSR, method=POST)`, `@ResponseBody` |
| 89–104 | `ResponseEntity<Results>` | `resetPassword` | `@RequestBody Driver driver` | `@RequestMapping(value=RESET_PASSWORD, method=POST)`, `@ResponseBody` |
| 106–116 | `int` | `acceptDrivers` | `@PathVariable("pids") int[] perIds` | `@RequestMapping(value=ACCEPT_USRS, method=PUT)`, `@ResponseBody` |
| 118–128 | `int` | `declineDriver` | `@PathVariable("pids") int[] perIds` | `@RequestMapping(value=DECLINE_USRS, method=DELETE)`, `@ResponseBody` |
| 130–159 | `ResponseEntity<Results>` | `uploadProfile` | `@PathVariable("uid") int uid`, `@RequestParam("file") MultipartFile file`, `@RequestParam("image_file") String cropImage` | `@RequestMapping(value=UPLOAD_PROFILE, method=POST, consumes=multipart/form-data)`, `@ResponseBody` |
| 161–183 | `ResponseEntity<Results>` | `uploadProfileAPP` | `@PathVariable("uid") int uid`, `@RequestParam("file") MultipartFile file` | `@RequestMapping(value=UPLOAD_PROFILE_APP, method=POST, consumes=multipart/form-data)`, `@ResponseBody` |
| 185–205 | `ResponseEntity<Results>` | `saveEmails` | `@RequestBody DriverEmails driverEmails` | `@RequestMapping(value=SAVE_EMAILS, method=POST)`, `@ResponseBody` |
| 207–224 | `ResponseEntity<DriverEmails>` | `getEmails` | `@PathVariable("uid") int uid` | `@RequestMapping(value=GET_EMAILS, method=GET)`, `@ResponseBody` |
| 226–231 | `List<Driver>` | `getDriver` | `@PathVariable("uid") int uid` | `@RequestMapping(value=GET_USR, method=GET)`, `@ResponseBody` |
| 233–249 | `ResponseEntity<Driver>` | `saveLicence` | `@RequestBody Driver user` | `@RequestMapping(value=SAVE_LICENCE, method=POST)`, `@ResponseBody` |
| 251–265 | `ResponseEntity<Results>` | `updateDrivers` | `@RequestBody Driver driver` | `@RequestMapping(value=UPDATE_USERS, method=POST)`, `@ResponseBody` |

**URI constants resolved:**
- `VALIDATE_USR` = `/rest/appuser/validate`
- `CREATE_APPUSR` = `/rest/appuser/register`
- `RESET_PASSWORD` = `/rest/appuser/reset`
- `ACCEPT_USRS` = `/rest/users/permission/acceptall/{pids}`
- `DECLINE_USRS` = `/rest/users/permission/deleteall/{pids}`
- `UPLOAD_PROFILE` = `/rest/appuser/photo/{uid}`
- `UPLOAD_PROFILE_APP` = `/rest/appuser/photo/app/{uid}`
- `SAVE_EMAILS` = `/rest/appuser/emails`
- `GET_EMAILS` = `/rest/appuser/emails/get/{uid}`
- `GET_USR` = `/rest/appuser/get/{uid}`
- `SAVE_LICENCE` = `/rest/licence/save`
- `UPDATE_USERS` = `/rest/appuser/update/{uid}`

---

### File 2: EquipmentController.java

**Fully qualified class name:** `com.journaldev.spring.jdbc.controller.EquipmentController`

**Extends:** `com.journaldev.spring.jdbc.controller.ConfigurationController`

**Implements:** (none beyond superclass)

**Class-level annotations:**
- `@Controller`

**Fields:**
- `private static final Logger logger` — `LoggerFactory.getLogger(EquipmentController.class)`
- `private EquipmentDAO equipmentDAO` — `@Autowired`
- `private ManufacturerDAO manufacturerDAO` — `@Autowired`
- `Gson gson` — package-private, instantiated inline (`= new Gson()`)

**Inherited fields (from ConfigurationController):**
- `protected Configuration configuration` — `@Autowired`
- `protected DataSource dataSource` — `@Autowired @Qualifier("dataSource")`

**Public methods:**

| Line | Return type | Method name | Parameters | Annotations |
|------|-------------|-------------|------------|-------------|
| 34–40 | `ResponseEntity<List<DriverEquipment>>` | `getEquipmentByUser` | `@PathVariable("uid") int uid` | `@RequestMapping(value=GET_EQUIPMENT, method=GET)`, `@ResponseBody` |
| 42–74 | `ResponseEntity<Results>` | `addEquipment` | `@RequestBody Equipment equipment` | `@RequestMapping(value=ADD_EQUIPMENT, method=POST)`, `@ResponseBody` |
| 76–82 | `List<Manufacturer>` | `getManufactureList` | `Authentication authentication` | `@RequestMapping(value=GET_MANUFACTURER, method=GET)`, `@ResponseBody` |
| 84–101 | `List<Types>` | `getTypeList` | `@PathVariable("mid") int mid` | `@RequestMapping(value=GET_TYPE, method=GET)`, `@ResponseBody` |
| 103–119 | `List<FuelType>` | `getFuelTypeList` | `@PathVariable("mid") int manuId`, `@PathVariable("tid") int typeID` | `@RequestMapping(value=GET_FUELTYPE, method=GET)`, `@ResponseBody` |
| 121–138 | `List<Services>` | `getService` | `@PathVariable("uid") int uid` | `@RequestMapping(value=GET_SERVICE, method=GET)`, `@ResponseBody` |
| 140–180 | `ResponseEntity<Results>` | `SaveService` | `@RequestBody Services services` | `@RequestMapping(value=SAVE_SERVICE, method=POST)`, `@ResponseBody` |

**URI constants resolved:**
- `GET_EQUIPMENT` = `/rest/equipment/get/{uid}`
- `ADD_EQUIPMENT` = `/rest/equip/add`
- `GET_MANUFACTURER` = `/rest/manu/get`
- `GET_TYPE` = `/rest/type/get/{mid}`
- `GET_FUELTYPE` = `/rest/fuletype/get/manuid/{mid}/typeid/{tid}`
- `GET_SERVICE` = `/rest/service/get/{uid}`
- `SAVE_SERVICE` = `/rest/service/save`

---

## STEP 4 — Checklist Review

### Section 1: Secrets and Configuration

**RuntimeConfig.java** contains multiple hardcoded credentials and API keys committed to the repository.

**environment.dev.properties, environment.uat.properties, environment.prod.properties** contain plaintext credentials committed to the repository.

**pom.xml** contains database credentials in the `<local>` and `<uat>` Maven profiles.

**CLEAR for DriverController.java and EquipmentController.java themselves** — no hardcoded DB connection strings within these two controller files. However, related supporting artifacts (RuntimeConfig, environment properties, pom.xml) contain secrets material to the overall application. These are flagged as B07-1 through B07-4.

---

### Section 2: Authentication and Authorization

The `spring-security.xml` filter chain applies `ROLE_DRIVER,ROLE_COMPANY_GROUP,ROLE_SYS_ADMIN,ROLE_CLIENT` to all `/rest/**` routes. Authentication is enforced at the filter level. However, **no endpoint in either controller uses `@PreAuthorize`, `@Secured`, or any in-method check to verify that the authenticated principal owns or has permission to access the resource identified by the `{uid}` or `{pids}` path variable.** This is a systemic IDOR pattern.

Specific IDOR findings:

- **`getDriver` (GET /rest/appuser/get/{uid})** — fetches complete driver record (name, phone, email, licno, security number, address, expiry date, photo URL, company membership) using only the integer `uid`. Any authenticated user can retrieve any other driver's PII by guessing or enumerating the ID.
- **`getEmails` (GET /rest/appuser/emails/get/{uid})** — fetches all notification email addresses for any driver by `uid`. No ownership check.
- **`uploadProfile` (POST /rest/appuser/photo/{uid})** — any authenticated user can overwrite any driver's profile photo by supplying an arbitrary `uid`. Updates `driver` table unconditionally.
- **`uploadProfileAPP` (POST /rest/appuser/photo/app/{uid})** — same issue as uploadProfile.
- **`saveLicence` (POST /rest/licence/save)** — uses `user.getId()` from the request body (fully attacker-controlled) to update licence fields (`licno`, `expirydt`, `addr`, `securityno`) for any driver record. No ownership check.
- **`updateDrivers` (POST /rest/appuser/update/{uid})** — uses `driver.getId()` from the request body (not from the path variable, and not validated against the authenticated principal) to update `first_name`, `last_name`, `compliance_date` for any driver.
- **`saveEmails` (POST /rest/appuser/emails)** — uses `driverEmails.getDriver_id()` from the request body to insert or update notification emails for any driver ID.
- **`acceptDrivers` (PUT /rest/users/permission/acceptall/{pids})** — accepts permission records identified by caller-supplied IDs with no check that they belong to the authenticated user's company.
- **`declineDriver` (DELETE /rest/users/permission/deleteall/{pids})** — deletes permission records identified by caller-supplied IDs with no ownership check.
- **`getEquipmentByUser` (GET /rest/equipment/get/{uid})** — retrieves all equipment linked to a `uid` with no verification that the requesting user is `uid` or belongs to the same company.
- **`getService` (GET /rest/service/get/{uid})** — retrieves service schedule data for all equipment at companies linked to the driver `uid`, with no ownership check.
- **`SaveService` (POST /rest/service/save)** — uses `services.getUnit_id()` and `services.getDriver_id()` from the request body to update service records for any unit and log the maintenance under any driver ID.

---

### Section 3: Input Validation and Injection

- **No `@Valid` annotation** is present on any `@RequestBody` parameter in either controller. No JSR-303/JSR-380 constraint annotations (`@NotNull`, `@Size`, `@Pattern`) are present on `Driver`, `Equipment`, `DriverEmails`, or `Services` model classes.
- **`e.printStackTrace()` in `uploadProfile` (line 154)** — stack traces are printed to `System.err`. Depending on Tomcat error page configuration this could be surfaced to clients; regardless it is improper error handling.
- **SQL injection via `ilike`** — `EquipmentController.addEquipment` passes `equipment.getSerial_no()` and `equipment.getName()` (string fields from the request body) as parameters to a query using `ilike`. The values are bound as prepared statement parameters (positional `?`), so SQL injection is mitigated at the JDBC level. **CLEAR** for SQL injection in these specific queries.
- **All JdbcTemplate calls in both controllers use parameterised `?` placeholders**, not string concatenation. No raw SQL injection vector found in these files. **CLEAR** for SQL injection in direct DB calls.
- **`updateDrivers` URL constant** is `UPDATE_USERS = "/rest/appuser/update/{uid}"` but the handler ignores `{uid}` and uses `driver.getId()` from the request body instead. While not itself an injection issue, this discrepancy reinforces the IDOR finding.
- **No `Runtime.getRuntime().exec()` or `ProcessBuilder`** found in these files. **N/A** for command injection.
- **No XML parsing** in these files. **N/A** for XXE.
- **No `new File(userInput)`** in these files. `AbstractFileStorageService.saveImage` generates a random filename; the upload path is server-controlled. **CLEAR** for path traversal in these files.
- **No `ObjectInputStream.readObject()`** in these files. `Driver` implements `Serializable` but is not deserialised from untrusted sources in these controllers. **CLEAR** for insecure deserialisation in these files.
- **`getLoginAuth` logs the full serialised `driverExample` object** (`gson.toJson(driverExample)`) including the plaintext `password` field. This is addressed under Section 5.
- **`registerDrivers` logs the full serialised `driver` object** including the plaintext `password` field. This is addressed under Section 5.

---

### Section 4: Session and CSRF

- **CSRF:** Spring Security 3.1 does not enable CSRF protection by default in XML configuration. The `spring-security.xml` does not add a `<csrf/>` element. The resource server filter chain (`/rest/**`) is stateless (`create-session="never"`), and the application uses OAuth2 bearer tokens rather than cookies for authentication, which is a valid architectural mitigation. **CLEAR** — stateless OAuth2 bearer-token approach eliminates the traditional CSRF attack vector.
- **CORS:** Neither `DriverController` nor `EquipmentController` carries a `@CrossOrigin` annotation. No `CorsRegistry` or CORS filter is configured in `servlet-context.xml` or `spring-security.xml`. The absence of explicit CORS configuration means the browser's same-origin policy applies by default. **CLEAR** for CORS permissiveness in these files. Note: this means the API may not function from web-browser clients on different origins, which may be intentional for a mobile-app backend.
- **Security headers (`X-Frame-Options`, `X-Content-Type-Options`, `Strict-Transport-Security`):** Not configured in either controller, `web.xml`, or `spring-security.xml`. Spring Security 3.1 does not add these headers automatically. **ISSUE** — flagged as B07-9.
- **Cookie/session:** Application is stateless (`create-session="never"`); no session cookies are issued by the resource server. **CLEAR** for session fixation in these controllers.

---

### Section 5: Data Exposure

- **`getLoginAuth`** returns a `Driver` object that includes the `password` field. The `Driver` model class has no `@JsonIgnore` on the `password` field. A successful authentication response will include the stored password hash (MD5) in the JSON body.
- **`getDriver`** returns a `Driver` object that includes `licno`, `securityno`, `addr`, `expirydt`, `photo_url`, and `email`. Given the IDOR (Section 2), this exposes full operator PII cross-tenant.
- **`getLoginAuth` and `registerDrivers` log full JSON-serialised `Driver` including plaintext `password`** at INFO level — this will appear in production logs.
- **`e.printStackTrace()` in `uploadProfile` (line 154)** — stack traces go to `System.err`. Depending on deployment, this may be captured in Tomcat logs or exposed via error responses.
- **`resetPassword` in `DriverService`** logs the reset password in plaintext at INFO level: `log.info("Start Sending Email to " + email)` — the password itself is in the `msg` variable which is not logged, but the plaintext temporary password is constructed and passed to `SendEmail.sendMail`. This is acceptable at the service level, but the `DriverService.resetPassword` exception handler in `DriverService` throws `DriverServiceException` with the email address embedded in the message: `"Unable to reset password for given driver email " + driver.getEmail()` — this message propagates to the controller which returns `HttpStatus.BAD_GATEWAY` with no stack trace. **Partial CLEAR** for stack trace exposure in resetPassword.
- **Error responses in `registerDrivers`** return the `Driver` object (with password hash) in the error body on `BAD_GATEWAY`.

---

### Section 6: Dependencies

- **Spring Framework 3.2.14.RELEASE** — released 2015, well past end-of-life. Multiple CVEs exist for Spring 3.x including expression language injection (CVE-2011-2730 class), web MVC vulnerabilities. No security patches have been released for this version since 2016.
- **Spring Security 3.1.1.RELEASE** — released 2012, well past end-of-life. Predates CSRF protection defaults and many later hardening features.
- **Spring Security OAuth 1.0.0.RELEASE** — extremely old OAuth2 server implementation; superseded by Spring Authorization Server. Multiple CVEs in the 1.x line.
- **jackson-databind 2.6.7** — CVE-2017-7525, CVE-2018-5968, CVE-2018-7489, CVE-2019-12086 and many others. Version 2.6.x reached end-of-life. Polymorphic deserialization gadget chains are a known risk.
- **commons-fileupload 1.3.1** — CVE-2016-3092 (DDoS via multipart), CVE-2014-0050. Significantly out of date.
- **commons-io 1.3.2** — `org.apache.commons:commons-io` groupId should be used from version 2.x; 1.3.2 is a very old release and uses the `org.apache.commons` groupId incorrectly.
- **aws-java-sdk 1.11.163** — significantly outdated; security patches released through 1.12.x series.
- **tika-core 1.18** — CVE-2018-1339 and others. Out of date.
- **Splunk repository over plain HTTP** — `http://splunk.jfrog.io/...` (line 88 pom.xml). Dependency fetched over an unencrypted connection is susceptible to MITM/supply-chain substitution.
- **No SNAPSHOT dependencies** found. **CLEAR** for SNAPSHOT risk.

---

### Section 7: Build and CI

- **No `bitbucket-pipelines.yml` found** in the repository. Build/deploy automation is not present in the repo. Cannot assess whether tests are skipped in CI deployment.
- **`-Xlint:all` is enabled** in `maven-compiler-plugin` configuration — this is positive. However it cannot be verified that the build is clean without running it.
- **`-DskipTests`**: not found in any Maven configuration. **CLEAR** for deliberate test skipping in config, but the absence of a pipeline means there is no CI enforcement of test execution.
- **Tomcat manager credentials** are referenced via `<server>TomcatServerAzure</server>` and `<server>TomcatServerUat</server>`. These resolve to Maven `settings.xml` entries on the developer's machine, so Tomcat manager credentials are not directly visible in the pom.xml. **CLEAR** for Tomcat credentials in pom.xml itself.

---

## STEP 5 — Findings

---

**B07-1** — CRITICAL
**Section:** 1 — Secrets and Configuration
**File:** `src/main/java/com/journaldev/spring/jdbc/controller/RuntimeConfig.java:14–21`
**Description:** Multiple hardcoded credentials, API keys, and third-party service credentials committed to source control. This file is tracked in git and will appear in all branches and the full commit history. Includes a Google Cloud Messaging server key, a Clickatell SMS API password, and internal service coordinates.
**Evidence:**
```java
public static String GCMKEY = "key=AIzaSyDDuQUYLcXkutyIxRToLAeBPHBQNLfayzs";
public static String USERNAME = "ciclickatell";
public static String PASSWORD = "OVLOaICXccaNUS";
public static String SMSFROM = "13234862361";
public static String API_ID = "3629505";
```

---

**B07-2** — CRITICAL
**Section:** 1 — Secrets and Configuration
**File:** `environment.uat.properties:16`, `environment.dev.properties:16`, `environment.prod.properties:16` (all tracked in git)
**Description:** Cognito API credentials committed in plaintext across all environment property files. These files are tracked in version control and exposed to all repository contributors. The UAT and prod files share identical credentials (`ciiadmin`/`ciiadmin`), suggesting the same weak credential is reused across environments.
**Evidence:**
```properties
cognitoAPIUsername=ciiadmin
cognitoAPIPassword=ciiadmin
```

---

**B07-3** — HIGH
**Section:** 1 — Secrets and Configuration
**File:** `pom.xml:29–30`, `pom.xml:76–77`
**Description:** Database credentials committed in plaintext in Maven profile definitions. The `local` profile contains a PostgreSQL password. The `uat` profile contains the RDS database admin password. These will appear in all git history for the file.
**Evidence:**
```xml
<!-- local profile -->
<flyway.password>gmtp-postgres</flyway.password>
...
<flyway.password>fleetiq360</flyway.password>

<!-- uat profile -->
<flyway.user>dev_admin</flyway.user>
<flyway.password>C!1admin</flyway.password>
```

---

**B07-4** — HIGH
**Section:** 1 — Secrets and Configuration
**File:** `pom.xml:88`
**Description:** A third-party Maven repository (Splunk JFrog) is configured using a plain HTTP URL. Dependencies fetched over HTTP are susceptible to man-in-the-middle substitution attacks (supply chain risk). A malicious artifact could be silently injected.
**Evidence:**
```xml
<url>http://splunk.jfrog.io/splunk/ext-releases-local</url>
```

---

**B07-5** — CRITICAL
**Section:** 2 — Authentication and Authorization (IDOR)
**File:** `src/main/java/com/journaldev/spring/jdbc/controller/DriverController.java:226–231`
**Description:** `GET /rest/appuser/get/{uid}` fetches a complete driver record — including name, phone, email, licence number, security number, address, expiry date, and photo URL — using only the integer `uid` path variable. There is no check that the authenticated principal is the requested driver or belongs to the same organisation. Any authenticated user can retrieve full PII for any other driver by incrementing the ID.
**Evidence:**
```java
@RequestMapping(value = RestURIConstants.GET_USR, method = RequestMethod.GET)
public @ResponseBody
List<Driver> getDriver(@PathVariable("uid") int uid) {
    log.info("Start getDriver for " + uid);
    return Collections.singletonList(driverDAO.findByID(uid));
}
```

---

**B07-6** — CRITICAL
**Section:** 2 — Authentication and Authorization (IDOR)
**File:** `src/main/java/com/journaldev/spring/jdbc/controller/DriverController.java:130–159`, `161–183`
**Description:** `POST /rest/appuser/photo/{uid}` and `POST /rest/appuser/photo/app/{uid}` accept a file upload and update the `photo_url` column for any driver identified by `uid`. No check is made that the authenticated user is the owner of `uid`. Any authenticated user can overwrite another operator's profile image. The `uploadProfile` variant also processes a base64 crop string from the request without type or size validation.
**Evidence:**
```java
@RequestMapping(value = RestURIConstants.UPLOAD_PROFILE, method = RequestMethod.POST, consumes = {"multipart/form-data"})
public @ResponseBody
ResponseEntity<Results> uploadProfile(@PathVariable("uid") int uid, @RequestParam("file") MultipartFile file, @RequestParam("image_file") String cropImage) {
    ...
    String query = "update driver set photo_url = ? where id = ? ";
    jdbcTemplate.update(query, imageFilename, uid);
    ...
}
```

---

**B07-7** — CRITICAL
**Section:** 2 — Authentication and Authorization (IDOR)
**File:** `src/main/java/com/journaldev/spring/jdbc/controller/DriverController.java:251–265`
**Description:** `POST /rest/appuser/update/{uid}` (URL contains `{uid}`) updates `first_name`, `last_name`, and `compliance_date` for any driver. Critically, the driver ID used in the SQL `WHERE` clause is taken from `driver.getId()` (the request body), not from the path variable. The path variable `{uid}` is declared in the URI constant but is not bound as a method parameter at all — meaning the URL segment is completely ignored. An attacker can update any driver's name and compliance date by sending any integer as the `id` field in the JSON body.
**Evidence:**
```java
// URI: /rest/appuser/update/{uid}  -- {uid} is never bound
@RequestMapping(value = RestURIConstants.UPDATE_USERS, method = RequestMethod.POST)
public @ResponseBody
ResponseEntity<Results> updateDrivers(@RequestBody Driver driver) {
    ...
    String query = "update driver set first_name = ?, last_name = ?, compliance_date = ?, updatedat = now() where id = ? ";
    jdbcTemplate.update(query, driver.getFirst_name(), driver.getLast_name(), complianceDate, driver.getId());
    ...
}
```

---

**B07-8** — CRITICAL
**Section:** 2 — Authentication and Authorization (IDOR)
**File:** `src/main/java/com/journaldev/spring/jdbc/controller/DriverController.java:233–249`
**Description:** `POST /rest/licence/save` upserts licence data (`licno`, `expirydt`, `addr`, `securityno`) for any driver. When `user.getId() != 0`, the update targets any driver row with that ID. The driver ID comes entirely from the attacker-controlled request body. A threat actor can overwrite the licence number, security number, and address of any driver in the system — data relevant to regulatory compliance and safety certification.
**Evidence:**
```java
@RequestMapping(value = RestURIConstants.SAVE_LICENCE, method = RequestMethod.POST)
public @ResponseBody
ResponseEntity<Driver> saveLicence(@RequestBody Driver user) {
    ...
    } else {
        String query = "update driver set licno = ?, expirydt = ?, addr= ?, securityno = ? where id = ?";
        jdbcTemplate.update(query, user.getLicno(), expDate, user.getAddr(), user.getSecurityno(), user.getId());
        ...
    }
}
```

---

**B07-9** — HIGH
**Section:** 2 — Authentication and Authorization (IDOR)
**File:** `src/main/java/com/journaldev/spring/jdbc/controller/DriverController.java:185–205`
**Description:** `POST /rest/appuser/emails` inserts or updates notification email addresses for any driver. The `driver_id` is taken entirely from the request body (`driverEmails.getDriver_id()`). No check is made that the authenticated user owns the specified `driver_id`. An attacker can redirect impact-event notification emails for any operator to an address they control.
**Evidence:**
```java
@RequestMapping(value = RestURIConstants.SAVE_EMAILS, method = RequestMethod.POST)
public @ResponseBody
ResponseEntity<Results> saveEmails(@RequestBody DriverEmails driverEmails) {
    ...
    String sql = "select count(*) from driver_emails where driver_id = ?";
    int count = jdbcTemplate.queryForObject(sql, Integer.class, driverEmails.getDriver_id());
    if (count == 0) {
        String query = "insert into driver_emails (driver_id, email_addr1,...) values (?,?,?,?,?)";
        jdbcTemplate.update(query, driverEmails.getDriver_id(), ...);
    } else {
        String query = "update driver_emails set email_addr1 = ?,... where driver_id = ?";
        jdbcTemplate.update(query, ..., driverEmails.getDriver_id());
    }
    ...
}
```

---

**B07-10** — HIGH
**Section:** 2 — Authentication and Authorization (IDOR)
**File:** `src/main/java/com/journaldev/spring/jdbc/controller/DriverController.java:207–224`
**Description:** `GET /rest/appuser/emails/get/{uid}` returns all notification email addresses configured for any driver by `uid`. No ownership check. Combined with B07-5 (getDriver IDOR), this exposes both PII and email configuration for arbitrary drivers.
**Evidence:**
```java
@RequestMapping(value = RestURIConstants.GET_EMAILS, method = RequestMethod.GET)
public @ResponseBody
ResponseEntity<DriverEmails> getEmails(@PathVariable("uid") int uid) {
    ...
    String query = "select email_addr1,email_addr2,email_addr3,email_addr4 from driver_emails where driver_id = ?";
    List<DriverEmails> emailList = jdbcTemplate.query(query, new Object[]{uid}, new BeanPropertyRowMapper<>(DriverEmails.class));
    ...
}
```

---

**B07-11** — HIGH
**Section:** 2 — Authentication and Authorization (IDOR)
**File:** `src/main/java/com/journaldev/spring/jdbc/controller/DriverController.java:106–116`, `118–128`
**Description:** `PUT /rest/users/permission/acceptall/{pids}` and `DELETE /rest/users/permission/deleteall/{pids}` operate on permission records by caller-supplied IDs. There is no verification that the referenced permission records belong to the authenticated user's company. A threat actor can accept or revoke any driver's company membership by enumerating or guessing permission IDs. Although these endpoints are commented "unused" in `RestURIConstants.java`, they are still mapped and reachable.
**Evidence:**
```java
@RequestMapping(value = RestURIConstants.ACCEPT_USRS, method = RequestMethod.PUT)
public @ResponseBody
int acceptDrivers(@PathVariable("pids") int[] perIds) {
    ...
    for (int perId : perIds)
        jdbcTemplate.update("update tblpermission set acceptedbyuser = true, ... where idpermission = ? ", perId);
    ...
}

@RequestMapping(value = RestURIConstants.DECLINE_USRS, method = RequestMethod.DELETE)
public @ResponseBody
int declineDriver(@PathVariable("pids") int[] perIds) {
    ...
    for (int perId : perIds)
        jdbcTemplate.update("delete from tblpermission where idpermission = ? and acceptedbyuser is false", perId);
    ...
}
```

---

**B07-12** — HIGH
**Section:** 2 — Authentication and Authorization (IDOR)
**File:** `src/main/java/com/journaldev/spring/jdbc/controller/EquipmentController.java:34–40`
**Description:** `GET /rest/equipment/get/{uid}` returns all forklift equipment associated with the driver identified by `uid`. No verification that the requesting user is `uid` or is in the same organisation. An authenticated user can retrieve the full equipment inventory of any other operator.
**Evidence:**
```java
@RequestMapping(value = RestURIConstants.GET_EQUIPMENT, method = RequestMethod.GET)
public @ResponseBody
ResponseEntity<List<DriverEquipment>> getEquipmentByUser(@PathVariable("uid") int uid) {
    logger.info("Start getEquipmentByUser. uid=" + uid);
    List<DriverEquipment> arrEquipment = equipmentDAO.getEquipmentByUser(uid);
    return new ResponseEntity<>(arrEquipment, arrEquipment.size() > 0 ? HttpStatus.OK : HttpStatus.BAD_REQUEST);
}
```

---

**B07-13** — HIGH
**Section:** 2 — Authentication and Authorization (IDOR)
**File:** `src/main/java/com/journaldev/spring/jdbc/controller/EquipmentController.java:121–138`
**Description:** `GET /rest/service/get/{uid}` retrieves the service schedule for all equipment at all companies linked to the driver identified by `uid`. No check that the requesting principal is `uid`. An attacker can view maintenance records and service-hour data for equipment at organisations they do not belong to.
**Evidence:**
```java
@RequestMapping(value = RestURIConstants.GET_SERVICE, method = RequestMethod.GET)
public @ResponseBody
List<Services> getService(@PathVariable("uid") int uid) {
    ...
    String query = "... where comp_id in (select comp_id from permission where driver_id = ? and enabled is true) and active is true ...";
    return jdbcTemplate.query(query, new Object[]{uid}, new BeanPropertyRowMapper<>(Services.class));
}
```

---

**B07-14** — HIGH
**Section:** 2 — Authentication and Authorization (IDOR)
**File:** `src/main/java/com/journaldev/spring/jdbc/controller/EquipmentController.java:140–180`
**Description:** `POST /rest/service/save` updates service records for any `unit_id` and creates a service history entry attributed to any `driver_id`, both taken directly from the request body. No ownership check ensures the requesting user has authority over the specified equipment or is the driver being credited. An attacker can falsify maintenance history for any forklift or attribute service actions to any driver.
**Evidence:**
```java
@RequestMapping(value = RestURIConstants.SAVE_SERVICE, method = RequestMethod.POST)
public @ResponseBody
ResponseEntity<Results> SaveService(@RequestBody Services services) {
    ...
    String query = "select count(*) from unit_service where unit_id = ?";
    int count = jdbcTemplate.queryForObject(query, Integer.class, services.getUnit_id());
    // updates unit_service using services.getUnit_id() with no ownership check
    ...
    query = "insert into unit_service_history (unit_id,serivce_time,service_hours,driver_id) values (?,now(),?,?)";
    jdbcTemplate.update(query, services.getUnit_id(), services.getLast_serv(), services.getDriver_id());
    ...
}
```

---

**B07-15** — HIGH
**Section:** 2 — Authentication and Authorization (IDOR)
**File:** `src/main/java/com/journaldev/spring/jdbc/controller/EquipmentController.java:42–74`
**Description:** `POST /rest/equip/add` accepts an `Equipment` object from the request body. When `equipment.getId() > 0`, it updates the MAC address for any unit identified by that ID — with no check that the unit belongs to the authenticated user's company. When `equipment.getId() == 0`, it inserts a new unit into the company identified by `equipment.getComp_id()` — also supplied by the caller, allowing a user to register equipment under any company ID.
**Evidence:**
```java
@RequestMapping(value = RestURIConstants.ADD_EQUIPMENT, method = RequestMethod.POST)
public @ResponseBody
ResponseEntity<Results> addEquipment(@RequestBody Equipment equipment) {
    ...
    if (equipment.getId() > 0) {
        query = "update unit set mac_address = ? where id = ?";
        jdbcTemplate.update(query, equipment.getMac_address(), equipment.getId());
        ...
    } else {
        ...
        query = "insert into unit (name,manu_id,type_id,fuel_type_id, serial_no,mac_address,comp_id) values (?,?,?,?,?,?,?)";
        jdbcTemplate.update(query, ..., equipment.getComp_id());
        ...
    }
}
```

---

**B07-16** — HIGH
**Section:** 3 — Input Validation and Injection
**File:** `src/main/java/com/journaldev/spring/jdbc/controller/DriverController.java:57–73`
**Description:** The `getLoginAuth` endpoint (`POST /rest/appuser/validate`) is annotated `@Deprecated` but is still mapped and reachable. It accepts email and password in the request body, authenticates via `driverService.authenticate()`, and on success returns the full `Driver` object including the `password` field (MD5 hash). The endpoint's continued availability represents an unnecessary attack surface and exposes credential hashes in successful responses. No `@Valid` or null checks on the request body.
**Evidence:**
```java
@RequestMapping(value = RestURIConstants.VALIDATE_USR, method = RequestMethod.POST)
public @ResponseBody
@Deprecated
ResponseEntity<List<Driver>> getLoginAuth(@RequestBody Driver driverExample) {
    log.info("Start getLoginAuth." + " : " + gson.toJson(driverExample) );
    Optional<Driver> optDriver = driverService.authenticate(driverExample.getEmail(), driverExample.getPassword());
    if (optDriver.isPresent()) {
        Driver driver = optDriver.get();
        ...
        return new ResponseEntity<>(Collections.singletonList(driver), HttpStatus.OK);
    }
    ...
}
```

---

**B07-17** — HIGH
**Section:** 3 — Input Validation and Injection
**File:** `src/main/java/com/journaldev/spring/jdbc/controller/DriverController.java:75–87`
**Description:** `POST /rest/appuser/register` has no input validation (`@Valid` is absent; `Driver` has no constraint annotations). A caller can register a driver with an empty email, an arbitrarily long name, or no password. On error the handler returns `HttpStatus.BAD_GATEWAY` with the full `driver` object in the response body, which may include the plaintext password that was submitted (before hashing occurs in the DAO).
**Evidence:**
```java
ResponseEntity<Driver> registerDrivers(@RequestBody Driver driver) {
    ...
    try {
        driver = driverService.registerDriver(driver);
    } catch (DriverServiceException e) {
        return new ResponseEntity<>(driver, HttpStatus.BAD_GATEWAY);
        // driver object may contain plaintext password in the response body
    }
    ...
}
```

---

**B07-18** — MEDIUM
**Section:** 3 — Input Validation and Injection
**File:** `src/main/java/com/journaldev/spring/jdbc/controller/DriverController.java` (all `@RequestBody` methods)
**Description:** No `@Valid` annotation is present on any `@RequestBody` parameter across the entire `DriverController`. No `@NotNull`, `@Size`, or `@Pattern` constraints are defined on the `Driver`, `DriverEmails` model classes. Inputs such as `compliance_date`, `expirydt`, `licno`, `securityno`, `email_addr1`–`email_addr4` are accepted without format or length validation and passed directly to SQL via `DateUtil.parseDateIso()` or JdbcTemplate. A malformed date string in `saveLicence` or `updateDrivers` will cause a runtime exception rather than a validated rejection. Similarly, there is no validation on `EquipmentController`'s `@RequestBody` parameters.
**Evidence:**
```java
// No @Valid on any of these:
ResponseEntity<Driver> registerDrivers(@RequestBody Driver driver)
ResponseEntity<Results> resetPassword(@RequestBody Driver driver)
ResponseEntity<Driver> saveLicence(@RequestBody Driver user)
ResponseEntity<Results> updateDrivers(@RequestBody Driver driver)
ResponseEntity<Results> saveEmails(@RequestBody DriverEmails driverEmails)
ResponseEntity<Results> addEquipment(@RequestBody Equipment equipment)
ResponseEntity<Results> SaveService(@RequestBody Services services)
```

---

**B07-19** — MEDIUM
**Section:** 5 — Data Exposure
**File:** `src/main/java/com/journaldev/spring/jdbc/controller/DriverController.java:60`, `78`
**Description:** The `getLoginAuth` and `registerDrivers` methods log the full JSON-serialised `Driver` object at INFO level, including the plaintext `password` field as submitted by the client. This means raw user passwords appear in application logs in plaintext. Depending on log level configuration, these entries will be present in production Splunk and/or logback outputs.
**Evidence:**
```java
// getLoginAuth, line 60:
log.info("Start getLoginAuth." + " : " + gson.toJson(driverExample) );

// registerDrivers, line 78:
log.info("Start registerDrivers."  + " : " + gson.toJson(driver));

// Driver model includes:
private String password;
// No @JsonIgnore or exclusion in Gson serialisation
```

---

**B07-20** — MEDIUM
**Section:** 5 — Data Exposure
**File:** `src/main/java/com/journaldev/spring/jdbc/controller/DriverController.java:154`
**Description:** `e.printStackTrace()` is called in the `uploadProfile` exception handler. Stack traces are written to `System.err` rather than through the application's logging framework. Depending on Tomcat configuration, `System.err` output may be included in `catalina.out` or other server logs that are less controlled than the application's Splunk-forwarded logs. This is also inconsistent with the `uploadProfileAPP` handler immediately below (line 178–182) which correctly omits the stack trace print.
**Evidence:**
```java
} catch (IOException e) {
    e.printStackTrace();   // line 154 — stack trace to System.err
    results.setMessage_id(RuntimeConfig.MSGID_CODEERRORR);
    results.setError(RuntimeConfig.ERRORMSG_CODEERRORR);
    return new ResponseEntity<>(results, HttpStatus.BAD_GATEWAY);
}
```

---

**B07-21** — MEDIUM
**Section:** 5 — Data Exposure
**File:** `src/main/java/com/journaldev/spring/jdbc/controller/DriverController.java:57–73`
**Description:** The `getLoginAuth` response on success returns the full `Driver` object. The `Driver` model class includes a `password` field (which will contain the MD5 hash of the user's password as stored in the database). There is no `@JsonIgnore` or response-specific DTO that would suppress the password hash from the serialised JSON response. MD5 hashes are trivially reversible for common passwords via rainbow tables and are not a safe credential representation to return to clients.
**Evidence:**
```java
// Driver model, Driver.java:
private String password;  // no @JsonIgnore

// getLoginAuth returns:
return new ResponseEntity<>(Collections.singletonList(driver), HttpStatus.OK);
// The serialised driver includes the password hash
```

---

**B07-22** — MEDIUM
**Section:** 4 — Session and CSRF
**File:** `WEB-INF/spring/spring-security.xml` (context), relevant to both controllers
**Description:** No security response headers (`X-Frame-Options`, `X-Content-Type-Options`, `Strict-Transport-Security`) are configured. Spring Security 3.1 does not add these headers automatically (the `<headers>` element was introduced in Spring Security 3.2). Although the API is primarily consumed by mobile clients, responses served to browser clients (e.g., via the admin web app or any web integration) would lack standard defensive headers.
**Evidence:**
```xml
<!-- spring-security.xml: no <headers> element present -->
<http pattern="/rest/**" create-session="never" entry-point-ref="oauthAuthenticationEntryPoint" ...>
    <anonymous enabled="false" />
    <intercept-url ... />
    <custom-filter ... />
    <access-denied-handler ... />
    <!-- No <headers> block -->
</http>
```

---

**B07-23** — HIGH
**Section:** 6 — Dependencies
**File:** `pom.xml:231–242`
**Description:** Spring Framework 3.2.14, Spring Security 3.1.1, and Spring Security OAuth 1.0.0 are all end-of-life with no active security maintenance. Spring Security OAuth 1.x in particular has multiple known CVEs. Jackson-databind 2.6.7 is many major fix versions behind the current 2.x line and contains known polymorphic deserialization vulnerabilities (CVE-2017-7525 and subsequent). Commons-fileupload 1.3.1 is vulnerable to CVE-2016-3092. These library versions represent accumulated technical debt that exposes the application to known, publicly documented attack techniques.
**Evidence:**
```xml
<org.springframework-version>3.2.14.RELEASE</org.springframework-version>
<jackson.databind-version>2.6.7</jackson.databind-version>

<dependency>
    <groupId>org.springframework.security</groupId>
    <artifactId>spring-security-web</artifactId>
    <version>3.1.1.RELEASE</version>
</dependency>
<dependency>
    <groupId>org.springframework.security.oauth</groupId>
    <artifactId>spring-security-oauth2</artifactId>
    <version>1.0.0.RELEASE</version>
</dependency>
<dependency>
    <groupId>commons-fileupload</groupId>
    <artifactId>commons-fileupload</artifactId>
    <version>1.3.1</version>
</dependency>
```

---

**B07-24** — LOW
**Section:** 2 — Authentication and Authorization
**File:** `WEB-INF/spring/spring-security.xml:13–14`
**Description:** Two OAuth cache approval endpoints are explicitly marked `security="none"`, meaning they are unauthenticated. The comment acknowledges these are "just for testing." These should not be present in a production deployment.
**Evidence:**
```xml
<!-- Just for testing... -->
<http pattern="/oauth/cache_approvals" security="none" xmlns="..." />
<http pattern="/oauth/uncache_approvals" security="none" xmlns="..." />
```

---

**B07-25** — LOW
**Section:** 1 — Secrets and Configuration
**File:** `WEB-INF/spring/spring-security.xml:111–118`
**Description:** OAuth2 client credentials (client IDs and secrets) for the `fleetiq360` client and `987654321` client are hardcoded in the Spring Security XML configuration file tracked in git. If these are production credentials, rotating them requires a code change and redeployment. The secret `rihah8eey4faibuengaixo6leiL1awii` should be treated as compromised.
**Evidence:**
```xml
<oauth:client client-id="987654321" ... secret="8752361E593A573E86CA558FFD39E" ... />
<oauth:client client-id="fleetiq360" ... secret="rihah8eey4faibuengaixo6leiL1awii" ... />
```

---

**B07-26** — LOW
**Section:** 1 — Secrets and Configuration
**File:** `src/main/java/com/journaldev/spring/jdbc/controller/RuntimeConfig.java:30`
**Description:** An internal API URL (AWS EC2 instance) is hardcoded in a static public field. While not a credential, it discloses internal infrastructure topology and is not suitable for version control.
**Evidence:**
```java
public static String APIURL = "http://ec2-52-5-205-104.compute-1.amazonaws.com/api/export/pdf/";
```

---

**B07-27** — INFO
**Section:** 2 — Authentication and Authorization
**File:** `src/main/java/com/journaldev/spring/jdbc/controller/DriverController.java:56–73`
**Description:** The `getLoginAuth` endpoint is annotated `@Deprecated`, indicating the development team intends to remove it. However it remains mapped and reachable. It uses MD5 for password hashing (via the DAO `md5(?)` SQL function), which is cryptographically broken. This endpoint should be removed from the codebase, not merely annotated deprecated. Its continued presence exposes MD5-hashed passwords in successful responses (see B07-21).
**Evidence:**
```java
@RequestMapping(value = RestURIConstants.VALIDATE_USR, method = RequestMethod.POST)
@Deprecated
ResponseEntity<List<Driver>> getLoginAuth(@RequestBody Driver driverExample) { ... }
```

---

**B07-28** — INFO
**Section:** 1 — Secrets and Configuration / 7 — Build and CI
**File:** (repo root — no file present)
**Description:** No `bitbucket-pipelines.yml` or equivalent CI/CD pipeline configuration is present in the repository. There is no automated enforcement of build, test, or static analysis steps. Deployment relies on manual Maven plugin invocations. This means there is no pipeline-level gate preventing untested or unapproved changes from reaching production.
**Evidence:** `bitbucket-pipelines.yml` not found in repository root or subdirectories.

---

## Summary Table

| ID | Severity | Section | Short description |
|----|----------|---------|-------------------|
| B07-1 | CRITICAL | 1 | GCM API key, Clickatell credentials hardcoded in RuntimeConfig.java |
| B07-2 | CRITICAL | 1 | Cognito credentials in plaintext environment property files (all envs) |
| B07-3 | HIGH | 1 | Database passwords in pom.xml Maven profiles |
| B07-4 | HIGH | 1 | Splunk Maven repository fetched over plain HTTP |
| B07-5 | CRITICAL | 2 | IDOR: getDriver exposes full operator PII by integer ID |
| B07-6 | CRITICAL | 2 | IDOR: uploadProfile/uploadProfileAPP overwrites any driver's photo |
| B07-7 | CRITICAL | 2 | IDOR: updateDrivers uses body ID not path variable; any driver writable |
| B07-8 | CRITICAL | 2 | IDOR: saveLicence overwrites licence/security number for any driver |
| B07-9 | HIGH | 2 | IDOR: saveEmails redirects impact notifications for any driver |
| B07-10 | HIGH | 2 | IDOR: getEmails exposes notification emails for any driver |
| B07-11 | HIGH | 2 | IDOR: acceptDrivers/declineDriver manipulate any permission record |
| B07-12 | HIGH | 2 | IDOR: getEquipmentByUser exposes equipment inventory cross-tenant |
| B07-13 | HIGH | 2 | IDOR: getService exposes service schedules cross-tenant |
| B07-14 | HIGH | 2 | IDOR: SaveService falsifies maintenance history for any unit/driver |
| B07-15 | HIGH | 2 | IDOR: addEquipment modifies any unit MAC or registers under any company |
| B07-16 | HIGH | 3 | Deprecated getLoginAuth still reachable; returns MD5 password hash |
| B07-17 | HIGH | 3 | registerDrivers returns plaintext password in error response body |
| B07-18 | MEDIUM | 3 | No @Valid on any @RequestBody in either controller |
| B07-19 | MEDIUM | 5 | Plaintext passwords logged at INFO level in getLoginAuth and registerDrivers |
| B07-20 | MEDIUM | 5 | e.printStackTrace() in uploadProfile — stack trace to System.err |
| B07-21 | MEDIUM | 5 | getLoginAuth response body includes MD5 password hash |
| B07-22 | MEDIUM | 4 | No X-Frame-Options / X-Content-Type-Options / HSTS headers |
| B07-23 | HIGH | 6 | EOL Spring 3.2, Spring Security 3.1, Spring OAuth 1.0, Jackson 2.6.7 |
| B07-24 | LOW | 2 | Test-only OAuth approval endpoints left open (security="none") |
| B07-25 | LOW | 1 | OAuth2 client secrets hardcoded in spring-security.xml |
| B07-26 | LOW | 1 | Internal AWS EC2 URL hardcoded in RuntimeConfig.java |
| B07-27 | INFO | 2 | Deprecated endpoint not removed; MD5 password hashing in legacy flow |
| B07-28 | INFO | 7 | No CI/CD pipeline configuration present in repository |
