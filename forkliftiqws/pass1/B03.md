# Pass 1 Security Review — Agent B03
**Date:** 2026-02-27
**Branch:** master
**Auditor:** B03 (automated)
**Files assigned:**
- `src/main/java/com/journaldev/spring/jdbc/DAO/EquipmentDAO.java`
- `src/main/java/com/journaldev/spring/jdbc/DAO/EquipmentDAOImpl.java`
- `src/main/java/com/journaldev/spring/jdbc/DAO/ImpactDAO.java`

Additional files read for context (not assigned, read only to inform findings):
- `controller/EquipmentController.java`
- `controller/ImpactController.java`
- `controller/ConfigurationController.java`
- `controller/RestURIConstants.java`
- `controller/RuntimeConfig.java`
- `model/Equipment.java`, `model/Impact.java`, `model/DriverEquipment.java`, `model/ImpactNotification.java`
- `service/UserDetailsServiceImpl.java`
- `util/Configuration.java`, `util/SendEmail.java`, `util/SendMessage.java`
- `DAO/UserDAO.java`
- `WEB-INF/spring/spring-security.xml`
- `WEB-INF/web.xml`
- `WEB-INF/spring/appServlet/servlet-context.xml`
- `src/main/resources/fleetiq360ws.properties`
- `environment.dev.properties`, `environment.prod.properties`, `environment.uat.properties`
- `pom.xml`

---

## Step 3 — Reading Evidence

### `com.journaldev.spring.jdbc.DAO.EquipmentDAO`

**Fully qualified class name:** `com.journaldev.spring.jdbc.DAO.EquipmentDAO`

**Type:** Interface (not a class; no `extends`, no `implements`)

**Public methods:**

| Return type | Method | Parameters | Line |
|---|---|---|---|
| `List<DriverEquipment>` | `getEquipmentByUser` | `int userId` | 9 |
| `Long` | `getEquipmentIdByMacAddress` | `String macAddress` | 10 |
| `Equipment` | `getEquipmentByMacAddress` | `String macAddress` | 11 |

**Annotations:** none (interface, no class-level annotations)

**Fields:** none

**Imports:** `com.journaldev.spring.jdbc.model.DriverEquipment`, `com.journaldev.spring.jdbc.model.Equipment`, `java.util.List`

---

### `com.journaldev.spring.jdbc.DAO.EquipmentDAOImpl`

**Fully qualified class name:** `com.journaldev.spring.jdbc.DAO.EquipmentDAOImpl`

**Type:** Class

**Extends:** `org.springframework.jdbc.core.support.JdbcDaoSupport`

**Implements:** `com.journaldev.spring.jdbc.DAO.EquipmentDAO`

**Class-level annotations:**
- `@Component("equipmentDAO")` (line 18)

**Fields:**

| Access | Type | Name | Notes |
|---|---|---|---|
| `private static final` | `Logger` | `logger` | SLF4J logger (line 20) |
| `private static final` | `String` | `QUERY_DRIVER_EQUIPMENT` | SQL constant (lines 22–32) |
| `private static final` | `String` | `QUERY_EQUIPMENT_ID_BY_MAC_ADDRESS` | SQL constant (line 34) |
| `private static final` | `String` | `QUERY_EQUIPMENT_BY_MAC_ADDRESS` | SQL constant (line 36) |
| `private` | `Configuration` | `configuration` | `@Autowired` (line 38–39) |

**Public methods:**

| Annotations | Return type | Method | Parameters | Line |
|---|---|---|---|---|
| _(none)_ | `void` | `setDbDataSource` | `DataSource dataSource` | 43 — `@Autowired @Qualifier("dataSource")` |
| _(none)_ | `List<DriverEquipment>` | `getEquipmentByUser` | `int uid` | 47 |
| `@Override` | `Long` | `getEquipmentIdByMacAddress` | `String macAddress` | 53 |
| `@Override` | `Equipment` | `getEquipmentByMacAddress` | `String macAddress` | 58 |

**SQL statements (all use `?` placeholders — no string concatenation):**

- `QUERY_DRIVER_EQUIPMENT`: `SELECT du.*, ... FROM v_driver_units du WHERE du.driver_id = ? AND assigned IS TRUE ORDER BY du.name` — parameterised via `configuration.getSystemImageURL()` (first `?`) and `uid` (second `?`).
- `QUERY_EQUIPMENT_ID_BY_MAC_ADDRESS`: `select id from unit u where u.active is true and u.mac_address = ?`
- `QUERY_EQUIPMENT_BY_MAC_ADDRESS`: `select * from unit u where u.active is true and u.mac_address = ?`

---

### `com.journaldev.spring.jdbc.DAO.ImpactDAO`

**Fully qualified class name:** `com.journaldev.spring.jdbc.DAO.ImpactDAO`

**Type:** Class (concrete — does NOT implement a separate DAO interface)

**Extends:** `org.springframework.jdbc.core.support.JdbcDaoSupport`

**Implements:** none

**Class-level annotations:**
- `@Repository` (line 23)

**Fields:**

| Access | Type | Name | Annotation |
|---|---|---|---|
| `private` | `Configuration` | `configuration` | `@Autowired` (lines 25–26) |
| `private` | `CognitoService` | `cognitoService` | `@Autowired` (lines 34–35) |
| `private static final` | `String` | `QUERY_FOR_EXISTING_IMPACT` | SQL constant (line 52) |
| `private static final` | `String` | `QUERY_FOR_IMPACT_NOTIFICATIONS` | SQL constant (lines 57–63) |

**Public methods:**

| Annotations | Return type | Method | Parameters | Line |
|---|---|---|---|---|
| `@Autowired @Qualifier("dataSource")` | `void` | `setDbDataSource` | `DataSource dataSource` | 30 |
| _(none)_ | `void` | `save` | `Long equipmentId, Impact impact` | 37 — throws `SQLException` |
| _(none)_ | `boolean` | `isImpactRecorded` | `Impact impact` | 53 |
| _(none)_ | `void` | `sendImpactNotification` | `Equipment equipment, Impact impact` | 64 — throws `SQLException` |

**SQL statements (all use `?` placeholders — no string concatenation):**

- `save`: `insert into impacts (unit_id,impact_time,impact_value) values(?,?,?)` — all parameterised.
- `QUERY_FOR_EXISTING_IMPACT`: `select count(i.id) from impacts i inner join unit u on i.unit_id = u.id where u.active = true and u.mac_address = ? and i.impact_time = ?`
- `QUERY_FOR_IMPACT_NOTIFICATIONS`: multi-table join on `v_impacts` filtered by `vi.unit_id = ? AND impact_time= ?`
- `save` error message (line 47): `"Unable to save impact event for " + impact.getMac_address() + " at time " + impact.getImpact_time()` — MAC address and time concatenated **into the exception message string** (not into SQL).

**Inherited logger field from `JdbcDaoSupport`:** `ImpactDAO` calls `logger.info(...)` at lines 75 and 77 — `logger` must be the one inherited or declared; checking: no explicit `logger` field declared in `ImpactDAO`. The reference at lines 75/77 would use the one from `JdbcDaoSupport` superclass (which declares a protected logger) — or this may be a compilation error. This is flagged as an observation.

---

## Step 4 — Checklist Review

### Section 1 — Secrets and Configuration

**Finding B03-1 (CRITICAL): Hardcoded credentials in `RuntimeConfig.java`**

`RuntimeConfig.java` contains hardcoded production credentials stored as `public static` fields directly in source code:

```java
public static String USERNAME = "ciclickatell";
public static String PASSWORD = "OVLOaICXccaNUS";
public static String API_ID = "3629505";
public static String GCMKEY = "key=AIzaSyDDuQUYLcXkutyIxRToLAeBPHBQNLfayzs";
```

These are the Clickatell SMS gateway credentials (username, password, API ID) and a Google Cloud Messaging (Firebase Cloud Messaging) server key — all committed to the repository in plain text.

**Finding B03-2 (HIGH): Hardcoded credentials in `pom.xml` — Flyway database passwords**

The `pom.xml` local and dev Maven profiles embed database credentials in plaintext:

```xml
<!-- local profile -->
<flyway.password>gmtp-postgres</flyway.password>
...
<flyway.password>fleetiq360</flyway.password>

<!-- uat profile -->
<flyway.user>dev_admin</flyway.user>
<flyway.password>C!1admin</flyway.password>
```

The UAT profile also hard-codes the RDS hostname: `forkliftiq360.cmjwsurtk4tn.us-east-1.rds.amazonaws.com`.

**Finding B03-3 (HIGH): Hardcoded credentials in committed environment property files**

All three environment property files are tracked in git and contain hardcoded credentials and service account details:

- `environment.dev.properties` lines 15–16: `cognitoAPIUsername=ciiadmin` / `cognitoAPIPassword=ciiadmin`
- `environment.prod.properties` lines 15–16: same credentials
- `environment.uat.properties` lines 15–16: same credentials

These files should not be committed to source control. They expose Cognito API service account credentials across all environments.

**Finding B03-4 (HIGH): Hardcoded OAuth2 client secrets in `spring-security.xml`**

The OAuth2 in-memory client details service contains hardcoded client secrets committed to the repository:

```xml
<oauth:client client-id="987654321"
    secret="8752361E593A573E86CA558FFD39E" ... />

<oauth:client client-id="fleetiq360"
    secret="rihah8eey4faibuengaixo6leiL1awii" ... />
```

These OAuth2 client secrets are committed in plaintext in a VCS-tracked configuration file.

**Finding B03-5 (MEDIUM): Infrastructure topology disclosed in committed files**

The following internal hostnames and AWS identifiers are committed to the repository:

- `pom.xml` line 44: `forklift360.canadaeast.cloudapp.azure.com`
- `pom.xml` line 47: `http://forklift360.canadaeast.cloudapp.azure.com:8080/manager/text`
- `pom.xml` line 73: `forkliftiq360.cmjwsurtk4tn.us-east-1.rds.amazonaws.com:5432`
- `pom.xml` line 77: `http://ec2-54-86-82-22.compute-1.amazonaws.com:8080/manager/text`
- `RuntimeConfig.java` line 30: `http://ec2-52-5-205-104.compute-1.amazonaws.com/api/export/pdf/`
- `environment.dev.properties` line 1: `https://forklift360.canadaeast.cloudapp.azure.com:8443/...`
- `environment.prod.properties` line 1: `https://ec2-54-86-82-22.compute-1.amazonaws.com:8443/...`

Exposing AWS EC2 instance DNS names, RDS endpoint hostnames, and Azure VM FQDNs in source control reveals infrastructure topology to anyone with repository access.

**Finding B03-6 (INFO): No Bitbucket Pipelines file found**

No `bitbucket-pipelines.yml` was found in the repository. CI/CD pipeline security cannot be assessed.

---

### Section 2 — Authentication and Authorization

**Finding B03-7 (CRITICAL): `getEquipmentByUser` endpoint accepts caller-supplied `uid` with no ownership check — IDOR**

`EquipmentController.getEquipmentByUser` (line 36) accepts a `{uid}` path variable and passes it directly to `equipmentDAO.getEquipmentByUser(uid)`:

```java
// EquipmentController.java line 36-39
public @ResponseBody ResponseEntity<List<DriverEquipment>> getEquipmentByUser(@PathVariable("uid") int uid) {
    logger.info("Start getEquipmentByUser. uid=" + uid);
    List<DriverEquipment> arrEquipment = equipmentDAO.getEquipmentByUser(uid);
    return new ResponseEntity<>(arrEquipment, ...);
}
```

The method never retrieves the authenticated principal and never verifies that the authenticated user's identity matches the requested `uid`. Any authenticated user can substitute any integer `uid` to retrieve the equipment list of any other driver on any other company/site. The underlying DAO query (`QUERY_DRIVER_EQUIPMENT`) filters only on `du.driver_id = ?` with the caller-supplied value — there is no company or site scoping applied in the query either. This is a direct object reference vulnerability (IDOR) allowing cross-tenant data access.

**Finding B03-8 (HIGH): `getService` endpoint accepts caller-supplied `{uid}` with no ownership check — IDOR**

`EquipmentController.getService` (line 123) accepts a `{uid}` path variable:

```java
// EquipmentController.java lines 122-138
public @ResponseBody List<Services> getService(@PathVariable("uid") int uid) {
    ...
    String query = "... where comp_id in (select comp_id from permission where driver_id = ? and enabled is true) ...";
    return jdbcTemplate.query(query, new Object[]{uid}, ...);
}
```

The query scopes by company via the `permission` table for the given `driver_id`, but the `uid` itself is never validated against the authenticated session. Any authenticated user can request service data for any driver ID.

**Finding B03-9 (HIGH): `saveImpactIMAGE` and `saveImpactIMAGEAPP` accept caller-supplied `impid` with no ownership check — IDOR**

Both `ImpactController.saveImpactIMAGE` (line 83) and `saveImpactIMAGEAPP` (line 117) take `@PathVariable("impid") int impId` and use it directly in UPDATE statements:

```java
// ImpactController.java lines 98-99
String query = "update incidents set image = ?,signature = ? where id = ? ";
jdbcTemplate.update(query, new Object[] {impactImageFilename, sigImageFilename, impId});
```

```java
// ImpactController.java lines 129-134
String query = "update incidents set image = ?  where id = ? ";
jdbcTemplate.update(query, new Object[] {imageFilename, impId});
// or
String query = "update incidents set signature = ? where id = ? ";
jdbcTemplate.update(query, new Object[] {imageFilename, impId});
```

Neither endpoint verifies that the incident record identified by `impId` belongs to a company/site accessible by the authenticated caller. An attacker can overwrite the image or signature of any incident record in the system by iterating `impId` values.

**Finding B03-10 (HIGH): `saveIncident` does not verify the caller owns the `driver_id` or `unit_id` in the request body — IDOR**

`ImpactController.saveIncident` (line 59) accepts a `@RequestBody Incidents incident` and inserts it directly:

```java
query = "insert into incidents (..., driver_id, unit_id) values (?, ..., ?, ?)";
jdbcTemplate.update(query, ... incident.getDriver_id(), incident.getUnit_id());
```

No check is performed to confirm that `incident.getDriver_id()` or `incident.getUnit_id()` belong to the authenticated user's company. A malicious caller can create incident records attributed to any driver or forklift in the system.

**Finding B03-11 (HIGH): `addEquipment` (`UPDATE` branch) does not verify that equipment `id` belongs to the authenticated user's company**

`EquipmentController.addEquipment` (line 49):

```java
if (equipment.getId() > 0) {
    query = "update unit set mac_address = ? where id = ?";
    jdbcTemplate.update(query, equipment.getMac_address(), equipment.getId());
    ...
}
```

The update is scoped only by `id` — no company scoping. A caller who knows any equipment ID can reassign its MAC address, potentially redirecting telemetry and impact data from another company's forklift.

**Finding B03-12 (MEDIUM): `saveService` / `SaveService` does not verify that `unit_id` belongs to the authenticated user's company**

`EquipmentController.SaveService` (line 142) accepts a `@RequestBody Services services` containing a `unit_id` and performs unconditional INSERT/UPDATE to `unit_service` and `unit_service_history` for that unit. No company membership check is performed.

**Finding B03-13 (MEDIUM): Weak password hashing — MD5 used for authentication**

`spring-security.xml` line 74 configures:

```xml
<password-encoder hash="md5"/>
```

MD5 is a cryptographically broken hash algorithm for passwords. It is vulnerable to precomputation attacks (rainbow tables) and brute force. Bcrypt, Argon2, or PBKDF2 should be used instead. This affects all user accounts authenticated via the standard `authenticationManager`.

**Finding B03-14 (MEDIUM): OAuth2 token validity of 0 on one client — indefinite token lifetime**

`spring-security.xml` line 113:

```xml
<oauth:client client-id="987654321" ... access-token-validity="0"/>
```

A value of `0` in Spring OAuth2 typically means the token does not expire (or uses a system default of no expiry). An access token with no expiry that is compromised cannot be invalidated without revoking the client entirely.

**Finding B03-15 (MEDIUM): Refresh token validity equals access token validity — no separation of concerns**

`spring-security.xml` line 116:

```xml
<oauth:client client-id="fleetiq360" ... access-token-validity="300" refresh-token-validity="300"/>
```

The refresh token validity (300 seconds) equals the access token validity. Refresh tokens should have a significantly longer lifetime than access tokens so that clients can renew access without re-authentication. If both expire simultaneously there is no functional benefit to having a refresh token, but more importantly this pattern suggests the token model has not been designed carefully.

**Finding B03-16 (INFO): No `@PreAuthorize` or `@Secured` annotations used on any method**

The `spring-security.xml` global method security enables `pre-post-annotations` (`<sec:global-method-security pre-post-annotations="enabled"/>`), but no controller or DAO method in the assigned files uses `@PreAuthorize` or `@Secured`. All authorization is enforced only at the URL pattern level (`ROLE_DRIVER,ROLE_COMPANY_GROUP,ROLE_SYS_ADMIN,ROLE_CLIENT` for `/rest/**`), with no per-operation role granularity. There is no distinction between a `ROLE_DRIVER` calling company-admin endpoints and a legitimate company administrator.

**Finding B03-17 (INFO): Two test-only OAuth endpoints left with `security="none"`**

`spring-security.xml` lines 13–14:

```xml
<http pattern="/oauth/cache_approvals" security="none" />
<http pattern="/oauth/uncache_approvals" security="none" />
```

Both patterns are marked with a comment `<!-- Just for testing... -->` but remain active in production configuration. These endpoints are completely unauthenticated. Their actual effect depends on the registered handlers, but their presence in a production security config is a risk.

---

### Section 3 — Input Validation and Injection

**Finding B03-18 (CLEAR): SQL injection in assigned DAO files**

All SQL in `EquipmentDAOImpl` and `ImpactDAO` uses `?` bind parameters with `JdbcTemplate`. No string concatenation was observed within any SQL query string. No injection risk in the three assigned DAO files themselves.

**Finding B03-19 (MEDIUM): No `@Valid` or constraint annotations on any `@RequestBody` parameter in `ImpactController` or `EquipmentController`**

All `@RequestBody` parameters (`Equipment`, `ImpactList`, `Incidents`, `Services`) are deserialized directly with no bean validation (`@Valid`, `@NotNull`, `@Size`, `@Pattern`, etc.):

```java
// EquipmentController.java line 44
public @ResponseBody ResponseEntity<Results> addEquipment(@RequestBody Equipment equipment)

// ImpactController.java line 59
public @ResponseBody ResponseEntity<Incidents> saveIncident(@RequestBody Incidents incident)

// ImpactController.java line 152
public @ResponseBody ResponseEntity<Results> saveImpactData(@RequestBody ImpactList impactList)
```

No validation framework is applied. Malformed or out-of-range field values are passed directly into database operations.

**Finding B03-20 (LOW): `ImpactController.saveImpactIMAGEAPP` uses caller-supplied `type` path variable in business logic with only case-insensitive string equality checks**

Line 117:

```java
public @ResponseBody ResponseEntity<Results> saveImpactIMAGEAPP(@PathVariable("impid") int impId, @PathVariable("type") String type, ...)
```

Lines 127–135: the `type` value is compared with `equalsIgnoreCase("image")` and `equalsIgnoreCase("signature")`. If neither matches, the file is uploaded to S3 (via `awsFileStorageService.saveImage(imagfis)`) but the database is not updated, and HTTP 200 is returned. This means arbitrary values of `type` will still upload a file to S3 without being recorded — silently wasting S3 storage and potentially being used for unauthorized file storage.

**Finding B03-21 (LOW): `signatureFile` in `saveImpactIMAGE` is decoded from Base64 with no size validation**

Line 90:

```java
String imageDataBytes = signatureFile.substring(signatureFile.indexOf(",") + 1);
InputStream stream = new ByteArrayInputStream(Base64.decode(imageDataBytes.getBytes()));
```

The `signatureFile` `@RequestParam` is a base64-encoded data URL with no size limit enforced before decoding. A very large value could cause heap exhaustion. The multipart file upload has a 20 MB limit set for the image part, but the Base64 `signatureFile` is a regular `@RequestParam String` with no enforced size cap.

**Finding B03-22 (INFO): SMS URL constructed by string concatenation of system constants — not user input**

`SendMessage.send_sms_message` (lines 112–127) constructs Clickatell API URLs using `RuntimeConfig` constants and `URLEncoder.encode(msg, "UTF-8")`. The `msg` content comes from the impact notification (driver name, unit name) retrieved from the database — not directly from untrusted user HTTP input. This is low risk for SSRF, but is flagged informally because the URL scheme (`RuntimeConfig.LOCATION`) is a hardcoded string and is not validated as a whitelist.

---

### Section 4 — Session and CSRF

**Finding B03-23 (MEDIUM): CSRF protection status cannot be confirmed — no explicit CSRF configuration found**

The Spring Security configuration (`spring-security.xml`) does not explicitly reference CSRF tokens. This project uses Spring Security 3.1.1 (an old version that does not enable CSRF protection by default). CSRF protection was only added as a default-on feature in Spring Security 3.2. With version 3.1.1, CSRF is **off by default** and there is no evidence it has been enabled. State-changing endpoints (`POST /rest/equip/add`, `POST /rest/impact/save`, `POST /rest/service/save`, etc.) are potentially vulnerable to CSRF if a victim's browser session is used.

Note: the use of OAuth2 bearer tokens (not cookies) mitigates CSRF for the primary API flow, but the legacy `authenticationManager` with form/HTTP-basic is also configured, which could be exploited.

**Finding B03-24 (MEDIUM): No `X-Frame-Options`, `X-Content-Type-Options`, or `Strict-Transport-Security` headers configured**

No security response header configuration was found in `spring-security.xml`, `web.xml`, or `servlet-context.xml`. Spring Security 3.1 does not add these headers automatically. Clients may be vulnerable to clickjacking (missing `X-Frame-Options`), MIME-sniffing (`X-Content-Type-Options`), and protocol downgrade (`Strict-Transport-Security`). Note: `web.xml` does configure `CONFIDENTIAL` transport guarantee, enforcing HTTPS at the container level, but HTTP Strict-Transport-Security is not set in HTTP responses.

**Finding B03-25 (INFO): No CORS configuration found**

No `@CrossOrigin` annotations and no `CorsRegistry` configuration were found in the assigned files or in `servlet-context.xml`. CORS may be handled at the reverse proxy layer or may be absent, meaning the API relies entirely on the browser's same-origin policy.

---

### Section 5 — Data Exposure

**Finding B03-26 (HIGH): `QUERY_EQUIPMENT_BY_MAC_ADDRESS` returns full equipment record including `impact_threshold`, `alert_enabled`, company data — no field filtering**

```java
private static final String QUERY_EQUIPMENT_BY_MAC_ADDRESS =
    "select * from unit u where u.active is true and u.mac_address = ?";
```

The `select *` returns all columns from `unit`, which is mapped into the `Equipment` model. This includes `comp_id`, `impact_threshold`, `alert_enabled`, `driver_based`, and `mac_address`. In `ImpactController.saveImpactData`, the retrieved `Equipment` object is serialized into `logger.debug(...)` and included in error messages returned to the caller:

```java
// ImpactController.java line 161
throw new IllegalArgumentException("Unable to retrieve equipment for given " + impact.getMac_address());
// ImpactController.java line 172
throw new IllegalArgumentException("Unable to save impact event " + impact.getMac_address() + " for " + impact.getImpact_time());
// ImpactController.java line 183 — returned in HTTP response body
results.setError("Found more than 1 active vehicle with same mac address");
```

While the current error messages limit what is returned to the client, `select *` is a latent risk: any future field added to the `unit` table (e.g., a secret, key, or sensitive identifier) would automatically be included in query results and potentially logged or serialised.

**Finding B03-27 (HIGH): Impact notification sends full driver PII (name, phone number) to logs**

`ImpactDAO.sendImpactNotification` (lines 75–77):

```java
logger.info("Start Sending Email to " + userResponse.getEmail());
// ... sends email ...
logger.info("Finish Sending Email to " + userResponse.getEmail());
```

And in `SendMessage.init` (line 48):

```java
logger.info("Start sending short messages to " + mobile_no + "; msg: " + msg);
```

The `msg` content (line 81–84 in `ImpactDAO`) includes the driver's full name, machine name, and timestamp:

```java
String content = "[ALERT] Impact Alert has been triggered on "
    + "Machine: " + notification.getUnit_name() + " - "
    + "Driver Name: " + userResponse.getName() + " " + userResponse.getLastname() + " - "
    + "Time of occurrence: " + DateUtil.parseDateTimeIso(notification.getImpact_time()) + ". ";
sendMessage.init(content, userResponse.getPhoneNumber());
```

This means the operator's full name and occurrence time, and the user's email address, are written to application logs at `INFO` level — a level that will appear in production log outputs (Splunk is configured). Operator PII in production logs is a data-protection risk.

**Finding B03-28 (MEDIUM): `e.printStackTrace()` in `ImpactController` and `SendEmail` — stack traces written to standard error**

`ImpactController.saveImpactIMAGE` line 108: `e.printStackTrace()`
`SendEmail.sendMail` line 48 and 53: `e.printStackTrace()` / `mex.printStackTrace()`
`SendMessage.init` line 53: `e.printStackTrace()`

`printStackTrace()` writes to `System.err`. In a Tomcat environment this is often captured in `catalina.out` and may be exposed via log shipping to Splunk. The stack trace contains internal class names, package paths, and SQL/JNDI error details that aid attackers in fingerprinting the system. Additionally, the `IOException` in `saveImpactIMAGE` is caught and the exception message is set in `results.setError(RuntimeConfig.ERRORMSG_CODEERRORR)` — this specific case uses a generic string — but the pattern is inconsistently applied.

**Finding B03-29 (MEDIUM): `logger.info` in `EquipmentController` logs entire `@RequestBody` serialized as JSON**

`EquipmentController.addEquipment` line 45:

```java
logger.info("Start addEquipment." + " : " + gson.toJson(equipment));
```

`EquipmentController.SaveService` line 143:

```java
logger.info("Start addEquipment."  + " : " + gson.toJson(services));
```

`ImpactController.saveIncident` line 60:

```java
logger.info("Start saveIncident."  + " : " + gson.toJson(incident));
```

`ImpactController.saveImpactData` line 153:

```java
logger.info("Start saveImpactData."  + " : " + gson.toJson(impactList));
```

These log statements serialise the entire request body — including MAC addresses, serial numbers, driver IDs, and impact values — to `INFO` level logs. For `saveImpactData` in particular, the full list of impact events with MAC addresses and timestamps is logged. MAC addresses are hardware identifiers for the forklift fleet and are security-sensitive asset identifiers.

**Finding B03-30 (LOW): `EquipmentController.getEquipmentByUser` logs the `uid` path variable via string concatenation**

Line 37:

```java
logger.info("Start getEquipmentByUser. uid=" + uid);
```

The `uid` is an internal driver/user ID. Logging it at INFO enables enumeration of the internal user ID space in production logs.

---

### Section 6 — Dependencies

**Finding B03-31 (CRITICAL): Spring Framework 3.2.14.RELEASE — end of life, multiple critical CVEs**

`pom.xml` line 13: `<org.springframework-version>3.2.14.RELEASE</org.springframework-version>`

Spring 3.x reached end of life in December 2016. Spring 3.2.14 is vulnerable to numerous CVEs including:
- CVE-2018-1270 (STOMP WebSocket messaging, CVSS 9.8)
- CVE-2018-1275 (Spring Data Commons, affects Spring ecosystem)
- CVE-2022-22965 "Spring4Shell" (remote code execution via data binding, CVSS 9.8) — Spring 3.x is in the affected range for some configurations

The framework version should be upgraded to a current, supported release.

**Finding B03-32 (CRITICAL): Spring Security 3.1.1.RELEASE — end of life, multiple critical CVEs**

`pom.xml` line 231: `<version>3.1.1.RELEASE</version>`

Spring Security 3.1.1 is severely outdated (circa 2012). It lacks CSRF protection by default, lacks Content Security Policy headers, and has known security vulnerabilities. It should be upgraded to 5.x or 6.x.

**Finding B03-33 (CRITICAL): spring-security-oauth2 1.0.0.RELEASE — end of life, known CVEs**

`pom.xml` line 241: `<version>1.0.0.RELEASE</version>`

Spring Security OAuth 1.0.0.RELEASE (circa 2011) is severely outdated. The Spring Security OAuth project itself reached end of life in 2022. Version 1.0.0 predates numerous security patches. Notable CVEs affecting Spring Security OAuth include CVE-2018-15758 (open redirector in authorization endpoint) and CVE-2019-3778. Upgrade to Spring Authorization Server or a current OAuth2 library.

**Finding B03-34 (HIGH): Jackson Databind 2.6.7 — multiple known CVEs**

`pom.xml` line 15: `<jackson.databind-version>2.6.7</jackson.databind-version>`

Jackson Databind 2.6.7 is affected by numerous deserialization vulnerabilities:
- CVE-2017-7525, CVE-2017-15095, CVE-2018-5968, CVE-2019-12384, CVE-2019-14379, CVE-2019-14439, CVE-2019-14540, CVE-2019-16335, CVE-2019-16942, CVE-2019-16943, CVE-2019-17267, CVE-2019-20330, and many more.
Most are polymorphic deserialization gadget-chain vulnerabilities. While default typing being disabled (no global `enableDefaultTyping`) reduces risk, the version itself is severely out of date.

**Finding B03-35 (HIGH): commons-fileupload 1.3.1 — CVE-2016-3092 (Denial of Service)**

`pom.xml` line 199: `<version>1.3.1</version>`

commons-fileupload 1.3.1 is vulnerable to CVE-2016-3092 (DiskFileItem deserialization leading to denial of service / arbitrary file write) and CVE-2014-0050 (DoS via multipart requests). Upgrade to 1.5 or later.

**Finding B03-36 (MEDIUM): AWS Java SDK 1.11.163 — severely outdated**

`pom.xml` line 271: `<version>1.11.163</version>`

AWS SDK for Java v1 version 1.11.163 (circa 2017) is outdated. AWS SDK v1 reached maintenance-only status; v2 is recommended. Outdated SDK versions may lack security patches for credential handling, TLS configuration, and request signing.

**Finding B03-37 (MEDIUM): Splunk library fetched from non-Maven-Central repository over HTTP**

`pom.xml` lines 86–90:

```xml
<repository>
    <id>splunk-artifactory</id>
    <name>Splunk Releases</name>
    <url>http://splunk.jfrog.io/splunk/ext-releases-local</url>
</repository>
```

The Splunk logging library is fetched over plain HTTP, not HTTPS. This exposes the build to a man-in-the-middle attack that could substitute a malicious JAR for the legitimate dependency. All Maven repository URLs should use HTTPS.

**Finding B03-38 (LOW): `commons-io` 1.3.2 used — artifact ID mismatch with version**

`pom.xml` line 168–170: `org.apache.commons:commons-io:1.3.2`. Note that `commons-io` under `org.apache.commons` group did not exist at version 1.3.2; the `commons-io` artifact at this group ID starts from 2.x. The older 1.x series was under groupId `commons-io:commons-io`. This may resolve incorrectly or to an unexpected artifact. In any case, commons-io 1.3.2 is severely out of date.

---

### Section 7 — Build and CI

**Finding B03-39 (INFO): No CI/CD pipeline file found**

No `bitbucket-pipelines.yml` was found. Build pipeline security (test skipping, deployment credentials) cannot be assessed.

**Finding B03-40 (INFO): Maven compiler configured with `-Xlint:all` and `showWarnings=true`**

`pom.xml` lines 305–309:

```xml
<compilerArgument>-Xlint:all</compilerArgument>
<showWarnings>true</showWarnings>
<showDeprecation>true</showDeprecation>
```

Lint warnings are enabled, which is positive for code quality. However, given the use of deprecated APIs (e.g., `spring-security-crypto.codec.Base64`, deprecated Spring Security OAuth 1.0, `queryForObject(String, Object[], Class)` deprecated form), the build will produce many warnings. Whether these are reviewed is unknown.

---

## Summary of Findings

| ID | Severity | Section | Short description |
|---|---|---|---|
| B03-1 | CRITICAL | 1 | Hardcoded Clickatell + GCM credentials in `RuntimeConfig.java` |
| B03-2 | CRITICAL | 6 | Spring Framework 3.2.14 — end of life, Spring4Shell in range |
| B03-3 | CRITICAL | 6 | Spring Security 3.1.1 — end of life |
| B03-4 | CRITICAL | 6 | Spring Security OAuth2 1.0.0 — end of life |
| B03-5 | HIGH | 1 | Flyway DB passwords hardcoded in `pom.xml` profiles |
| B03-6 | HIGH | 1 | Cognito API credentials committed in environment property files |
| B03-7 | HIGH | 1 | OAuth2 client secrets hardcoded in `spring-security.xml` |
| B03-8 | HIGH | 2 | IDOR: `getEquipmentByUser` — no auth principal vs uid check |
| B03-9 | HIGH | 2 | IDOR: `getService` — uid not validated against session |
| B03-10 | HIGH | 2 | IDOR: `saveImpactIMAGE`/`saveImpactIMAGEAPP` — impid not validated |
| B03-11 | HIGH | 2 | IDOR: `saveIncident` — driver_id / unit_id not validated |
| B03-12 | HIGH | 2 | IDOR: `addEquipment` (UPDATE) — equipment id not ownership-checked |
| B03-13 | HIGH | 5 | PII (driver name, phone, email) written to INFO-level logs |
| B03-14 | HIGH | 6 | Jackson Databind 2.6.7 — multiple deserialization CVEs |
| B03-15 | HIGH | 6 | commons-fileupload 1.3.1 — CVE-2016-3092 |
| B03-16 | MEDIUM | 1 | Infrastructure topology (AWS/Azure hostnames) committed to repo |
| B03-17 | MEDIUM | 2 | `saveService` — unit_id not ownership-checked |
| B03-18 | MEDIUM | 2 | MD5 password hashing configured in `spring-security.xml` |
| B03-19 | MEDIUM | 2 | `access-token-validity="0"` on client 987654321 — indefinite token |
| B03-20 | MEDIUM | 3 | No `@Valid` / bean validation on any `@RequestBody` |
| B03-21 | MEDIUM | 4 | CSRF not enabled — Spring Security 3.1.1 default is off |
| B03-22 | MEDIUM | 4 | No security response headers (X-Frame-Options, HSTS, etc.) |
| B03-23 | MEDIUM | 5 | `e.printStackTrace()` — stack traces to stderr / logs |
| B03-24 | MEDIUM | 5 | Full request body (MAC addresses, PII) logged at INFO |
| B03-25 | MEDIUM | 6 | AWS SDK 1.11.163 — severely outdated |
| B03-26 | MEDIUM | 7 | Splunk Maven repo fetched over HTTP (MITM risk) |
| B03-27 | LOW | 2 | No per-operation role differentiation (all ROLE_DRIVER can call admin ops) |
| B03-28 | LOW | 3 | `type` path variable uploaded to S3 with no validation — silent accept |
| B03-29 | LOW | 3 | `signatureFile` Base64 decoded without size cap — heap exhaustion risk |
| B03-30 | LOW | 5 | `uid` logged at INFO — internal ID space exposure |
| B03-31 | INFO | 2 | Test OAuth endpoints (`cache_approvals`, `uncache_approvals`) left `security="none"` in prod config |
| B03-32 | INFO | 2 | No `@PreAuthorize` / `@Secured` used anywhere in assigned files |
| B03-33 | INFO | 3 | SMS URL uses system constants — low SSRF risk but no whitelist enforcement |
| B03-34 | INFO | 4 | No CORS configuration found |
| B03-35 | INFO | 7 | No CI/CD pipeline file found — pipeline security not assessable |

---

## Detailed Finding Entries

**B03-1** — CRITICAL
**Section:** 1 — Secrets and Configuration
**File:** `src/main/java/com/journaldev/spring/jdbc/controller/RuntimeConfig.java:14-21`
**Description:** Third-party API credentials (Clickatell SMS gateway username, password, API ID) and a Google Cloud Messaging server API key are hardcoded as `public static` string fields and committed to source control. Anyone with repository read access has full access to these credentials.
**Evidence:**
```java
public static String USERNAME = "ciclickatell";
public static String PASSWORD = "OVLOaICXccaNUS";
public static String API_ID = "3629505";
public static String GCMKEY = "key=AIzaSyDDuQUYLcXkutyIxRToLAeBPHBQNLfayzs";
```

---

**B03-2** — HIGH
**Section:** 1 — Secrets and Configuration
**File:** `pom.xml:27-31, 74-76`
**Description:** Flyway database credentials are hardcoded in Maven profiles and committed to source control. The UAT profile exposes a production-adjacent RDS hostname and credentials.
**Evidence:**
```xml
<!-- local profile -->
<flyway.password>gmtp-postgres</flyway.password>
<flyway.password>fleetiq360</flyway.password>
<!-- uat profile -->
<flyway.user>dev_admin</flyway.user>
<flyway.password>C!1admin</flyway.password>
<flyway.url>jdbc:postgresql://forkliftiq360.cmjwsurtk4tn.us-east-1.rds.amazonaws.com:5432/postgres</flyway.url>
```

---

**B03-3** — HIGH
**Section:** 1 — Secrets and Configuration
**File:** `environment.dev.properties:15-16`, `environment.prod.properties:15-16`, `environment.uat.properties:15-16`
**Description:** Cognito API service account credentials are committed in plaintext in all three environment property files. These files are tracked by git and should not be committed to source control.
**Evidence:**
```
cognitoAPIUsername=ciiadmin
cognitoAPIPassword=ciiadmin
```

---

**B03-4** — HIGH
**Section:** 1 — Secrets and Configuration
**File:** `src/main/webapp/WEB-INF/spring/spring-security.xml:113-117`
**Description:** OAuth2 in-memory client secrets are hardcoded in a committed configuration file.
**Evidence:**
```xml
<oauth:client client-id="987654321"
    secret="8752361E593A573E86CA558FFD39E" ... />
<oauth:client client-id="fleetiq360"
    secret="rihah8eey4faibuengaixo6leiL1awii" ... />
```

---

**B03-5** — MEDIUM
**Section:** 1 — Secrets and Configuration
**File:** `pom.xml:44,47,73,77`, `src/main/java/com/journaldev/spring/jdbc/controller/RuntimeConfig.java:30`, `environment.dev.properties:1`, `environment.prod.properties:1`
**Description:** Azure VM FQDNs, AWS EC2 instance DNS names, and the production AWS RDS endpoint are hardcoded and committed. This exposes infrastructure topology.
**Evidence:**
```
forklift360.canadaeast.cloudapp.azure.com
forkliftiq360.cmjwsurtk4tn.us-east-1.rds.amazonaws.com
ec2-54-86-82-22.compute-1.amazonaws.com
ec2-52-5-205-104.compute-1.amazonaws.com
```

---

**B03-6** — INFO
**Section:** 1 — Secrets and Configuration / 7 — Build and CI
**File:** _(repository root — no file)_
**Description:** No `bitbucket-pipelines.yml` found. CI/CD pipeline configuration and any pipeline-level secrets management cannot be assessed.
**Evidence:** N/A — file absent.

---

**B03-7** — CRITICAL
**Section:** 2 — Authentication and Authorization
**File:** `src/main/java/com/journaldev/spring/jdbc/controller/EquipmentController.java:34-40`
**Description:** `GET /rest/equipment/get/{uid}` accepts an integer `uid` path variable and queries equipment for that driver without verifying that the authenticated caller is the same user or has access to that user's data. Any authenticated client can retrieve any driver's equipment list by varying the `uid`. This is a cross-tenant IDOR vulnerability.
**Evidence:**
```java
@RequestMapping(value = RestURIConstants.GET_EQUIPMENT, method = RequestMethod.GET)
public @ResponseBody ResponseEntity<List<DriverEquipment>> getEquipmentByUser(@PathVariable("uid") int uid) {
    logger.info("Start getEquipmentByUser. uid=" + uid);
    List<DriverEquipment> arrEquipment = equipmentDAO.getEquipmentByUser(uid);
    return new ResponseEntity<>(arrEquipment, ...);
}
// EquipmentDAOImpl QUERY_DRIVER_EQUIPMENT:
// WHERE du.driver_id = ? AND assigned IS TRUE
// -- no company or site filter applied
```

---

**B03-8** — HIGH
**Section:** 2 — Authentication and Authorization
**File:** `src/main/java/com/journaldev/spring/jdbc/controller/EquipmentController.java:122-138`
**Description:** `GET /rest/service/get/{uid}` passes the caller-supplied `uid` as `driver_id` into a permission subquery but does not verify that the authenticated session belongs to that `uid`.
**Evidence:**
```java
public @ResponseBody List<Services> getService(@PathVariable("uid") int uid) {
    String query = "... where comp_id in (select comp_id from permission where driver_id = ? and enabled is true) ...";
    return jdbcTemplate.query(query, new Object[]{uid}, ...);
}
```

---

**B03-9** — HIGH
**Section:** 2 — Authentication and Authorization
**File:** `src/main/java/com/journaldev/spring/jdbc/controller/ImpactController.java:83-113, 116-148`
**Description:** `POST /rest/impactimage/{impid}` and `POST /rest/impactimage/impid/{impid}/type/{type}` accept `impId` from the URL path and use it in unconditional UPDATE statements. No ownership check is performed. An attacker can overwrite the image or signature of any incident in the system.
**Evidence:**
```java
// saveImpactIMAGE
String query = "update incidents set image = ?,signature = ? where id = ? ";
jdbcTemplate.update(query, new Object[] {impactImageFilename, sigImageFilename, impId});

// saveImpactIMAGEAPP
String query = "update incidents set image = ?  where id = ? ";
jdbcTemplate.update(query, new Object[] {imageFilename, impId});
```

---

**B03-10** — HIGH
**Section:** 2 — Authentication and Authorization
**File:** `src/main/java/com/journaldev/spring/jdbc/controller/ImpactController.java:59-71`
**Description:** `POST /rest/impact/save` inserts an incident record with `driver_id` and `unit_id` taken directly from the request body without verifying that these IDs belong to the authenticated caller's company.
**Evidence:**
```java
query = "insert into incidents (..., driver_id, unit_id) values (?, ..., ?, ?)";
jdbcTemplate.update(query, new Object[]{id, ..., incident.getDriver_id(), incident.getUnit_id()});
```

---

**B03-11** — HIGH
**Section:** 2 — Authentication and Authorization
**File:** `src/main/java/com/journaldev/spring/jdbc/controller/EquipmentController.java:49-54`
**Description:** The UPDATE branch of `addEquipment` modifies any equipment record by `id` from the request body with no company ownership check.
**Evidence:**
```java
if (equipment.getId() > 0) {
    query = "update unit set mac_address = ? where id = ?";
    jdbcTemplate.update(query, equipment.getMac_address(), equipment.getId());
}
```

---

**B03-12** — MEDIUM
**Section:** 2 — Authentication and Authorization
**File:** `src/main/java/com/journaldev/spring/jdbc/controller/EquipmentController.java:142-180`
**Description:** `SaveService` accepts `unit_id` from the request body and performs INSERT/UPDATE to service records without verifying the unit belongs to the authenticated user's company.
**Evidence:**
```java
public @ResponseBody ResponseEntity<Results> SaveService(@RequestBody Services services) {
    // unit_id taken directly from request body, no ownership check
    String query = "select count(*) from unit_service where unit_id = ?";
    int count = jdbcTemplate.queryForObject(query, Integer.class, services.getUnit_id());
    // ... then unconditional insert or update
}
```

---

**B03-13** — MEDIUM
**Section:** 2 — Authentication and Authorization
**File:** `src/main/webapp/WEB-INF/spring/spring-security.xml:74`
**Description:** MD5 is used as the password hashing algorithm. MD5 is cryptographically broken for password storage — it is fast, unsalted by default in this configuration, and vulnerable to rainbow table attacks.
**Evidence:**
```xml
<authentication-provider user-service-ref="userDetailsService">
    <password-encoder hash="md5"/>
</authentication-provider>
```

---

**B03-14** — MEDIUM
**Section:** 2 — Authentication and Authorization
**File:** `src/main/webapp/WEB-INF/spring/spring-security.xml:113`
**Description:** OAuth2 client `987654321` is configured with `access-token-validity="0"`, which in Spring OAuth2 means the token never expires. A compromised token cannot be naturally invalidated.
**Evidence:**
```xml
<oauth:client client-id="987654321"
    authorized-grant-types="password,authorization_code,implicit"
    secret="8752361E593A573E86CA558FFD39E"
    authorities="ROLE_CLIENT"
    scope="read,write"
    access-token-validity="0"/>
```

---

**B03-15** — MEDIUM
**Section:** 3 — Input Validation and Injection
**File:** `src/main/java/com/journaldev/spring/jdbc/controller/ImpactController.java:44-113` (all `@RequestBody` methods)
**Description:** No `@Valid` annotation or JSR-303/JSR-380 constraint annotations are applied to any `@RequestBody` parameters in `ImpactController` or `EquipmentController`. Input is accepted and persisted without structural validation.
**Evidence:**
```java
// All request body parameters lack @Valid:
public @ResponseBody ResponseEntity<Results> addEquipment(@RequestBody Equipment equipment)
public @ResponseBody ResponseEntity<Incidents> saveIncident(@RequestBody Incidents incident)
public @ResponseBody ResponseEntity<Results> saveImpactData(@RequestBody ImpactList impactList)
public @ResponseBody ResponseEntity<Results> SaveService(@RequestBody Services services)
```

---

**B03-16** — MEDIUM
**Section:** 4 — Session and CSRF
**File:** `src/main/webapp/WEB-INF/spring/spring-security.xml` (entire file)
**Description:** Spring Security 3.1.1 does not enable CSRF protection by default. No explicit CSRF token filter or configuration was found. State-changing endpoints are potentially vulnerable to cross-site request forgery if the legacy form-based authentication path is used.
**Evidence:** No `<csrf>` element or `CsrfFilter` reference in `spring-security.xml`. Spring Security 3.1 CSRF is off by default.

---

**B03-17** — MEDIUM
**Section:** 4 — Session and CSRF
**File:** `src/main/webapp/WEB-INF/spring/spring-security.xml`, `src/main/webapp/WEB-INF/web.xml`
**Description:** No `X-Frame-Options`, `X-Content-Type-Options`, or `Strict-Transport-Security` HTTP response headers are configured. Spring Security 3.1 does not add these automatically.
**Evidence:** No `<headers>` element in `spring-security.xml`; no filter for security headers in `web.xml`.

---

**B03-18** — HIGH
**Section:** 5 — Data Exposure
**File:** `src/main/java/com/journaldev/spring/jdbc/DAO/ImpactDAO.java:75-77`; `src/main/java/com/journaldev/spring/jdbc/util/SendMessage.java:48`
**Description:** Operator PII (full name, email address, phone number) and forklift identifiers (unit name) are written to application logs at `INFO` level. Splunk is configured as a log sink, meaning these records will be retained in production log storage.
**Evidence:**
```java
// ImpactDAO.java
logger.info("Start Sending Email to " + userResponse.getEmail());
logger.info("Finish Sending Email to " + userResponse.getEmail());

// SendMessage.java
logger.info("Start sending short messages to " + mobile_no + "; msg: " + msg);
// msg contains: "Driver Name: [firstName] [lastName] - Machine: [unit_name] - Time: [timestamp]"
```

---

**B03-19** — MEDIUM
**Section:** 5 — Data Exposure
**File:** `src/main/java/com/journaldev/spring/jdbc/controller/ImpactController.java:107-111`; `src/main/java/com/journaldev/spring/jdbc/util/SendEmail.java:48,52-53`
**Description:** `e.printStackTrace()` is called in multiple catch blocks, writing full stack traces to `System.err`. In a Tomcat deployment this appears in `catalina.out` and may be shipped to Splunk. Stack traces reveal internal class names, package structure, and potentially JNDI/SQL error details.
**Evidence:**
```java
// ImpactController.java
} catch (IOException e) {
    e.printStackTrace();
    ...
}
// SendEmail.java
} catch (Exception e) {
    System.out.println("Message Recipents Exception :" + e);
}
// Transport.send exception
} catch (Exception e) {
    e.printStackTrace();
}
} catch (MessagingException mex) {
    mex.printStackTrace();
} catch (Throwable t) {
    t.printStackTrace();
}
```

---

**B03-20** — MEDIUM
**Section:** 5 — Data Exposure
**File:** `src/main/java/com/journaldev/spring/jdbc/controller/EquipmentController.java:45,143`; `src/main/java/com/journaldev/spring/jdbc/controller/ImpactController.java:60,153`
**Description:** Full request body content including MAC addresses, driver IDs, serial numbers, and impact values is serialised to JSON and logged at `INFO` level on every request.
**Evidence:**
```java
logger.info("Start addEquipment." + " : " + gson.toJson(equipment));
logger.info("Start addEquipment."  + " : " + gson.toJson(services));
logger.info("Start saveIncident."  + " : " + gson.toJson(incident));
logger.info("Start saveImpactData."  + " : " + gson.toJson(impactList));
```

---

**B03-21** — CRITICAL
**Section:** 6 — Dependencies
**File:** `pom.xml:13`
**Description:** Spring Framework 3.2.14.RELEASE is end-of-life (EOL December 2016) and falls within the affected range for CVE-2022-22965 ("Spring4Shell") — a remote code execution vulnerability exploitable via DataBinder with a Servlet-based deployment on JDK 9+. Additional critical and high CVEs affect 3.2.x.
**Evidence:**
```xml
<org.springframework-version>3.2.14.RELEASE</org.springframework-version>
```

---

**B03-22** — CRITICAL
**Section:** 6 — Dependencies
**File:** `pom.xml:230-237`
**Description:** Spring Security 3.1.1.RELEASE is severely outdated (circa 2012) and EOL. It lacks numerous security controls introduced in later versions (CSRF protection, security headers, modern password encoding).
**Evidence:**
```xml
<groupId>org.springframework.security</groupId>
<artifactId>spring-security-web</artifactId>
<version>3.1.1.RELEASE</version>
```

---

**B03-23** — CRITICAL
**Section:** 6 — Dependencies
**File:** `pom.xml:239-242`
**Description:** Spring Security OAuth2 1.0.0.RELEASE is severely outdated and EOL. The Spring Security OAuth project itself was end-of-lifed in 2022. Version 1.0.0 predates all subsequent security patches.
**Evidence:**
```xml
<groupId>org.springframework.security.oauth</groupId>
<artifactId>spring-security-oauth2</artifactId>
<version>1.0.0.RELEASE</version>
```

---

**B03-24** — HIGH
**Section:** 6 — Dependencies
**File:** `pom.xml:98-101`
**Description:** Jackson Databind 2.6.7 has numerous known deserialization CVEs. While polymorphic deserialization may not be globally enabled, the version is severely outdated and should be upgraded.
**Evidence:**
```xml
<artifactId>jackson-databind</artifactId>
<version>2.6.7</version>
```

---

**B03-25** — HIGH
**Section:** 6 — Dependencies
**File:** `pom.xml:197-201`
**Description:** commons-fileupload 1.3.1 is vulnerable to CVE-2016-3092 (denial of service) and CVE-2014-0050 (multipart request DoS). This library is used directly by `CommonsMultipartResolver` for file upload handling in `ImpactController`.
**Evidence:**
```xml
<artifactId>commons-fileupload</artifactId>
<version>1.3.1</version>
```

---

**B03-26** — MEDIUM
**Section:** 6 — Dependencies
**File:** `pom.xml:269-272`
**Description:** AWS Java SDK 1.11.163 is from 2017 and is severely outdated. AWS SDK v1 is in maintenance mode; v2 is recommended for security patches.
**Evidence:**
```xml
<artifactId>aws-java-sdk</artifactId>
<version>1.11.163</version>
```

---

**B03-27** — MEDIUM
**Section:** 6 — Dependencies / 7 — Build and CI
**File:** `pom.xml:86-90`
**Description:** The Splunk logging library is fetched from a third-party JFrog Artifactory instance over plain HTTP, not HTTPS. This allows a man-in-the-middle attacker on the build network to substitute a malicious JAR.
**Evidence:**
```xml
<repository>
    <id>splunk-artifactory</id>
    <name>Splunk Releases</name>
    <url>http://splunk.jfrog.io/splunk/ext-releases-local</url>
</repository>
```

---

**B03-28** — LOW
**Section:** 3 — Input Validation and Injection
**File:** `src/main/java/com/journaldev/spring/jdbc/controller/ImpactController.java:117-148`
**Description:** The `type` path variable in `saveImpactIMAGEAPP` is not validated against an allowlist before use. If `type` is neither `"image"` nor `"signature"`, the file is uploaded to S3 but the HTTP 200 response is returned with no database record and no error. This permits unauthorized file uploads to the S3 bucket.
**Evidence:**
```java
public @ResponseBody ResponseEntity<Results> saveImpactIMAGEAPP(
    @PathVariable("impid") int impId,
    @PathVariable("type") String type,
    @RequestParam("file") MultipartFile imageFile) {
    ...
    String imageFilename = awsFileStorageService.saveImage(imagfis);
    if(type.equalsIgnoreCase("image")) { ... }
    else if(type.equalsIgnoreCase("signature")) { ... }
    // else: file is uploaded to S3, HTTP 200 returned, no DB write
    results.setMessage_id(RuntimeConfig.MSGID_SUCCESS);
    return new ResponseEntity<Results>(results, HttpStatus.OK);
}
```

---

**B03-29** — LOW
**Section:** 3 — Input Validation and Injection
**File:** `src/main/java/com/journaldev/spring/jdbc/controller/ImpactController.java:90-93`
**Description:** The `signatureFile` request parameter is decoded from Base64 into a `byte[]` without enforcing a maximum length. A very large Base64 string passed as a `@RequestParam` could cause excessive heap allocation before any size check occurs.
**Evidence:**
```java
String imageDataBytes = signatureFile.substring(signatureFile.indexOf(",") + 1);
InputStream stream = new ByteArrayInputStream(Base64.decode(imageDataBytes.getBytes()));
```

---

**B03-30** — INFO
**Section:** 2 — Authentication and Authorization
**File:** `src/main/webapp/WEB-INF/spring/spring-security.xml:13-14`
**Description:** Two test-only OAuth endpoints are left with `security="none"` in the production security configuration file with a comment acknowledging they are for testing only.
**Evidence:**
```xml
<!-- Just for testing... -->
<http pattern="/oauth/cache_approvals" security="none" />
<http pattern="/oauth/uncache_approvals" security="none" />
```
