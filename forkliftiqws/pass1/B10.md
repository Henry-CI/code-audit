# Pass 1 Security Review — Agent B10
**Repo:** forkliftiqws
**Branch:** master
**Date:** 2026-02-27
**Auditor:** B10
**Files reviewed:**
- `src/main/java/com/journaldev/spring/jdbc/controller/RuntimeConfig.java`
- `src/main/java/com/journaldev/spring/jdbc/controller/SessionController.java`
- `src/main/java/com/journaldev/spring/jdbc/controller/UserController.java`

**Supporting files read (for context):**
- `src/main/java/com/journaldev/spring/jdbc/controller/ConfigurationController.java`
- `src/main/java/com/journaldev/spring/jdbc/controller/RestURIConstants.java`
- `src/main/java/com/journaldev/spring/jdbc/DAO/UserDAO.java`
- `src/main/java/com/journaldev/spring/jdbc/model/User.java`
- `src/main/webapp/WEB-INF/web.xml`
- `src/main/webapp/WEB-INF/spring/spring-security.xml`
- `src/main/webapp/WEB-INF/spring/appServlet/servlet-context.xml`
- `src/main/resources/fleetiq360ws.properties`
- `environment.dev.properties`
- `environment.prod.properties`
- `environment.uat.properties`
- `pom.xml`

---

## STEP 3 — Reading Evidence

### File 1: `RuntimeConfig.java`

**Fully qualified class name:** `com.journaldev.spring.jdbc.controller.RuntimeConfig`

**Class-level annotations:** none

**Interfaces implemented / classes extended:** none

**Fields (all `public static`):**

| Access | Type | Name | Value |
|--------|------|------|-------|
| public static | String | host | "localhost" |
| public static | String | port | "25" |
| public static | String | sfport | "25" |
| public static | String | sfclass | "javax.net.ssl.SSLSocketFactory" |
| public static | String | mailFrom | "info@forkliftiq360.com" |
| public static | String | emailContent | "" |
| public static | String | GCMSERVER | "https://gcm-http.googleapis.com/gcm/send" |
| public static | String | GCMKEY | "key=AIzaSyDDuQUYLcXkutyIxRToLAeBPHBQNLfayzs" |
| public static | String | production_database | "jdbc/PreStartDB" |
| public static | String | LOCATION | "https://api.clickatell.com" |
| public static | String | USERNAME | "ciclickatell" |
| public static | String | PASSWORD | "OVLOaICXccaNUS" |
| public static | String | SMSFROM | "13234862361" |
| public static | String | API_ID | "3629505" |
| public static | String | MSGID_SUCCESS | "1" |
| public static | String | MSGID_CODEERRORR | "2" |
| public static | String | MSGID_CODEE_DUPLICATE_VEHICLE | "3" |
| public static | String | ERRORMSG_CODEERRORR | "Code throws exceptions" |
| public static | String | MSGID_LOGICERRORR | "3" |
| public static | String | ERRORMSG_LOGICERRORR | "Result already exists." |
| public static | String | APIURL | "http://ec2-52-5-205-104.compute-1.amazonaws.com/api/export/pdf/" |
| public static | String | file_type | ".pdf" |
| public static | String | PDF_FOLDER | "temp/" |

**Public methods:** none (plain data class, no methods)

---

### File 2: `SessionController.java`

**Fully qualified class name:** `com.journaldev.spring.jdbc.controller.SessionController`

**Class-level annotations:** `@Controller`

**Classes extended:** `ConfigurationController` (which provides `protected DataSource dataSource` and `protected Configuration configuration`)

**Interfaces implemented:** none

**Fields:**

| Access | Type | Name |
|--------|------|------|
| private static final | Logger | logger |
| private | FileStorageService | fileStorageService |
| (package) | Gson | gson |

**Field annotations:**
- `fileStorageService`: `@Autowired`, `@Qualifier("localFileStorage")`

**Public methods:**

| Return type | Method name | Parameters | Line | Annotations |
|-------------|-------------|------------|------|-------------|
| `ResponseEntity<Driver>` | `driverAccess` | `@PathVariable("sid") int sid`, `@PathVariable("imageno") int imageno`, `@RequestParam("file") MultipartFile file` | 62 | `@RequestMapping(value=DRIVRR_ACCESS, method=POST, consumes={"multipart/form-data"})`, `@ResponseBody` |
| `ResponseEntity<List<Questions>>` | `getQuestion` | `@PathVariable("eid") int eid` | 97 | `@RequestMapping(value=GET_QUESTION, method=GET)`, `@ResponseBody` |
| `List<FormDtl>` | `getForm` | `@PathVariable("qid") int qid`, `@PathVariable("type") String type` | 138 | `@RequestMapping(value=GET_FORMS, method=GET)`, `@ResponseBody` |
| `List<FormDtl>` | `searchForm` | `@PathVariable("uid") int uid`, `@PathVariable("type") String type`, `@PathVariable("keyword") String keyword` | 154 | `@RequestMapping(value=SEARCH_FORMS, method=GET)`, `@ResponseBody` |
| `ResponseEntity<Results>` | `saveResults` | `@RequestBody Result result` | 172 | `@RequestMapping(value=SAVE_RESULT, method=POST)`, `@ResponseBody` |
| `ResponseEntity<Sessions>` | `startSessions` | `@RequestBody Sessions session` | 229 | `@RequestMapping(value=START_SESSION, method=POST)`, `@ResponseBody` |
| `ResponseEntity<Results>` | `endSessions` | `@RequestBody Sessions session` | 299 | `@RequestMapping(value=END_SESSION, method=POST)`, `@ResponseBody` |
| `ResponseEntity<Results>` | `abortSessions` | `@PathVariable("sid") int sid` | 353 | `@RequestMapping(value=ABORT_SESSION, method=PUT)`, `@ResponseBody` |
| `ResponseEntity<Sessions>` | `saveOffline` | `@RequestBody OfflineSessions offlineSession` | 379 | `@RequestMapping(value=SAVE_OFFLINE, method=POST)`, `@ResponseBody` |

**Private methods:**

| Return type | Method name | Parameters | Line |
|-------------|-------------|------------|------|
| `String` | `toString` | `Serializable o` | 289 |
| `int` | `createSession` | `Sessions session`, `JdbcTemplate jdbcTemplate` | 366 |

---

### File 3: `UserController.java`

**Fully qualified class name:** `com.journaldev.spring.jdbc.controller.UserController`

**Class-level annotations:** `@Controller`

**Classes extended:** none (does NOT extend `ConfigurationController`)

**Interfaces implemented:** none

**Fields:**

| Access | Type | Name |
|--------|------|------|
| private | UserDAO | userDao |

**Field annotations:**
- `userDao`: `@Autowired`

**Public methods:**

| Return type | Method name | Parameters | Line | Annotations |
|-------------|-------------|------------|------|-------------|
| `ResponseEntity<User>` | `getUserByEmail` | `@RequestParam("email") String email` | 23 | `@RequestMapping(value="/rest/admin/user", method=GET)`, `@ResponseBody` |

---

## STEP 4 — Security Review Findings

---

### Section 1 — Secrets and Configuration

**1.1 — RuntimeConfig.java: hardcoded third-party API credentials**

**B10-1** — CRITICAL
**Section:** 1. Secrets and Configuration
**File:** `src/main/java/com/journaldev/spring/jdbc/controller/RuntimeConfig.java:13-21`
**Description:** A GCM (Google Cloud Messaging) server API key, a Clickatell SMS API username and plaintext password, and a Clickatell API ID are hardcoded as public static fields in source code committed to the repository. Anyone with read access to the repo has access to these credentials. The GCM key and Clickatell password are live third-party credentials that could be used to send push notifications or SMS messages at the organisation's expense.
**Evidence:**
```java
public static String GCMKEY = "key=AIzaSyDDuQUYLcXkutyIxRToLAeBPHBQNLfayzs";
public static String USERNAME = "ciclickatell";
public static String PASSWORD = "OVLOaICXccaNUS";
public static String API_ID = "3629505";
```

---

**B10-2** — HIGH
**Section:** 1. Secrets and Configuration
**File:** `pom.xml:28-35` (local profile), `pom.xml:76-77` (uat profile)
**Description:** Database credentials for the local development profile (`postgres`/`gmtp-postgres` and `fleetiq360`/`fleetiq360`) and the UAT RDS instance (`dev_admin`/`C!1admin`) are hardcoded directly in `pom.xml` in plaintext. `pom.xml` is committed to source control. The UAT RDS endpoint (`forkliftiq360.cmjwsurtk4tn.us-east-1.rds.amazonaws.com`) is also exposed, revealing cloud infrastructure topology.
**Evidence:**
```xml
<!-- local profile -->
<flyway.password>gmtp-postgres</flyway.password>
<flyway.password>fleetiq360</flyway.password>
<!-- uat profile -->
<flyway.url>jdbc:postgresql://forkliftiq360.cmjwsurtk4tn.us-east-1.rds.amazonaws.com:5432/postgres</flyway.url>
<flyway.user>dev_admin</flyway.user>
<flyway.password>C!1admin</flyway.password>
```

---

**B10-3** — HIGH
**Section:** 1. Secrets and Configuration
**File:** `environment.dev.properties:15-16`, `environment.prod.properties:15-16`, `environment.uat.properties:15-16`
**Description:** All three environment properties files (dev, prod, uat) are committed to the repository and contain a hardcoded Cognito API username and password (`ciiadmin`/`ciiadmin`). These are live credentials for the Cognito integration API. The prod file in particular contains the credential for the production environment.
**Evidence:**
```properties
cognitoAPIUsername=ciiadmin
cognitoAPIPassword=ciiadmin
```

---

**B10-4** — MEDIUM
**Section:** 1. Secrets and Configuration
**File:** `src/main/java/com/journaldev/spring/jdbc/controller/RuntimeConfig.java:30`
**Description:** A plain HTTP URL referencing an AWS EC2 instance by public DNS name is hardcoded. This exposes EC2 infrastructure topology and uses an unencrypted transport for PDF API calls. If the endpoint is still active, requests are sent without TLS.
**Evidence:**
```java
public static String APIURL = "http://ec2-52-5-205-104.compute-1.amazonaws.com/api/export/pdf/";
```

---

**B10-5** — MEDIUM
**Section:** 1. Secrets and Configuration
**File:** `src/main/webapp/WEB-INF/spring/spring-security.xml:111-118`
**Description:** OAuth2 client secrets are hardcoded in the Spring Security XML configuration file that is committed to the repository. Two clients are configured with embedded plaintext secrets: `8752361E593A573E86CA558FFD39E` (client `987654321`) and `rihah8eey4faibuengaixo6leiL1awii` (client `fleetiq360`). Any developer or CI system with repo access can read these secrets.
**Evidence:**
```xml
<oauth:client client-id="987654321" ... secret="8752361E593A573E86CA558FFD39E" .../>
<oauth:client client-id="fleetiq360" ... secret="rihah8eey4faibuengaixo6leiL1awii" .../>
```

---

**B10-6** — INFO
**Section:** 1. Secrets and Configuration
**File:** `pom.xml:84-90`
**Description:** The Splunk dependency is fetched from a third-party JFrog Artifactory repository (`http://splunk.jfrog.io/splunk/ext-releases-local`) over plain HTTP rather than HTTPS. This allows a man-in-the-middle to substitute a malicious JAR during build. This repository is not Maven Central or a controlled private registry.
**Evidence:**
```xml
<url>http://splunk.jfrog.io/splunk/ext-releases-local</url>
```

---

### Section 2 — Authentication and Authorization

**B10-7** — CRITICAL
**Section:** 2. Authentication and Authorization
**File:** `src/main/java/com/journaldev/spring/jdbc/controller/UserController.java:22-23`
**Description:** The `/rest/admin/user` endpoint is mapped under the `/rest/admin/` path, but the Spring Security configuration (`spring-security.xml`) contains no specific rule for `/rest/admin/**`. The only rules covering `/rest/**` are: (1) `/rest/db/**` requires `ROLE_SYS_ADMIN`; (2) `/rest/apk/**` requires `ROLE_CLIENT`; (3) the fallback `/rest/**` permits any of `ROLE_DRIVER`, `ROLE_COMPANY_GROUP`, `ROLE_SYS_ADMIN`, or `ROLE_CLIENT`. Therefore any authenticated OAuth2 user — including a forklift operator with `ROLE_DRIVER` — can call `GET /rest/admin/user?email=...` and retrieve the user record (including the password hash) for any email address in the system. There is no admin-role check protecting this endpoint.
**Evidence:**
```java
// UserController.java line 22
@RequestMapping(value = "/rest/admin/user", method = RequestMethod.GET)
public @ResponseBody ResponseEntity<User> getUserByEmail(@RequestParam("email") String email) {

// spring-security.xml lines 30-32
<intercept-url pattern="/rest/db/**" access="ROLE_SYS_ADMIN" />
<intercept-url pattern="/rest/apk/**" access="ROLE_CLIENT" />
<intercept-url pattern="/rest/**" access="ROLE_DRIVER,ROLE_COMPANY_GROUP,ROLE_SYS_ADMIN,ROLE_CLIENT" />
```

---

**B10-8** — CRITICAL
**Section:** 2. Authentication and Authorization (IDOR)
**File:** `src/main/java/com/journaldev/spring/jdbc/controller/SessionController.java:353-363`
**Description:** `abortSessions()` accepts a session ID (`sid`) from the URL path and immediately deletes the session row with no verification that the session belongs to the calling user, the calling user's company, or even that the session exists before deletion. Any authenticated driver can abort any other driver's active session by guessing or enumerating the integer session ID.
**Evidence:**
```java
@RequestMapping(value = RestURIConstants.ABORT_SESSION, method = RequestMethod.PUT)
public @ResponseBody
ResponseEntity<Results> abortSessions(@PathVariable("sid") int sid) {
    ...
    String query = "delete from session where id = ?";
    jdbcTemplate.update(query, new Object[]{sid});
    results.setMessage_id(RuntimeConfig.MSGID_SUCCESS);
    return new ResponseEntity<Results>(results, HttpStatus.OK);
}
```

---

**B10-9** — HIGH
**Section:** 2. Authentication and Authorization (IDOR)
**File:** `src/main/java/com/journaldev/spring/jdbc/controller/SessionController.java:229-287`
**Description:** `startSessions()` accepts a `Sessions` request body that includes `driver_id` and `unit_id`. There is no check that the authenticated caller is the driver identified by `driver_id`, or that `unit_id` belongs to the same company as the authenticated user. A malicious authenticated user can start a session on behalf of any driver ID and any unit ID in the database.
**Evidence:**
```java
@RequestMapping(value = RestURIConstants.START_SESSION, method = RequestMethod.POST)
public @ResponseBody
ResponseEntity<Sessions> startSessions(@RequestBody Sessions session) {
    ...
    String sql = "select count(*) from session where driver_id = ? and unit_id = ? ...";
    int count = jdbcTemplate.queryForObject(sql, Integer.class,
        new Object[]{session.getDriver_id(), session.getUnit_id(), startTime});
    // No check that session.getDriver_id() == authenticated user ID
    // No check that session.getUnit_id() belongs to the caller's company
```

---

**B10-10** — HIGH
**Section:** 2. Authentication and Authorization (IDOR)
**File:** `src/main/java/com/journaldev/spring/jdbc/controller/SessionController.java:299-348`
**Description:** `endSessions()` accepts a `Sessions` request body with an `id` field (the session ID). It unconditionally updates and finalises that session with no check that the session belongs to the authenticated caller or the caller's company. Any authenticated user can close any other user's session by providing the target session ID.
**Evidence:**
```java
@RequestMapping(value = RestURIConstants.END_SESSION, method = RequestMethod.POST)
public @ResponseBody
ResponseEntity<Results> endSessions(@RequestBody Sessions session) throws IOException {
    ...
    query = "select unit_id from session where id = ?";
    int uid = jdbcTemplate.queryForObject(query, Integer.class, new Object[]{session.getId()});
    query = "update session set finish_time = ? , finish_servertime = now(), prestart_required = ? where id = ?";
    jdbcTemplate.update(query, new Object[]{..., session.getId()});
    // No ownership check: session.getId() can be any session in the database
```

---

**B10-11** — HIGH
**Section:** 2. Authentication and Authorization (IDOR)
**File:** `src/main/java/com/journaldev/spring/jdbc/controller/SessionController.java:62-93`
**Description:** `driverAccess()` stores uploaded images against a session identified by the `sid` path variable. There is no check that the authenticated caller owns or has authority over session `sid`. Any authenticated user can upload and overwrite driver photographs associated with any session in the database.
**Evidence:**
```java
@RequestMapping(value = RestURIConstants.DRIVRR_ACCESS, method = RequestMethod.POST, consumes = {"multipart/form-data"})
public @ResponseBody
ResponseEntity<Driver> driverAccess(@PathVariable("sid") int sid, @PathVariable("imageno") int imageno,
        @RequestParam("file") MultipartFile file) {
    ...
    query = "update session set photo_front_url  = ? where id = ? ";
    jdbcTemplate.update(query, new Object[]{imageFileName, sid});
    // No verification that sid belongs to the authenticated driver or company
```

---

**B10-12** — HIGH
**Section:** 2. Authentication and Authorization
**File:** `src/main/webapp/WEB-INF/spring/spring-security.xml:113-118`
**Description:** The OAuth2 token (`access-token-validity`) for client `987654321` is set to `0`, which in Spring Security OAuth2 means the token never expires. A compromised or leaked access token for this client would grant indefinite access to any endpoint the `ROLE_CLIENT` authority permits.
**Evidence:**
```xml
<oauth:client client-id="987654321" authorized-grant-types="password,authorization_code,implicit"
              secret="8752361E593A573E86CA558FFD39E" authorities="ROLE_CLIENT" scope="read,write"
              access-token-validity="0"/>
```

---

**B10-13** — HIGH
**Section:** 2. Authentication and Authorization
**File:** `src/main/webapp/WEB-INF/spring/spring-security.xml:116-117`
**Description:** The `fleetiq360` OAuth2 client has `access-token-validity="300"` (5 minutes) but `refresh-token-validity="300"` (also only 5 minutes). With a refresh token that expires in the same window as the access token, refresh tokens cannot be used to obtain new access tokens after 5 minutes, which may lead client applications to store and reuse access tokens or use the `password` grant type repeatedly — both of which are poor security practices. More importantly, the `password` grant type is enabled, which exposes user credentials directly to the client application.
**Evidence:**
```xml
<oauth:client client-id="fleetiq360" authorized-grant-types="password,authorization_code,refresh_token,implicit"
              secret="rihah8eey4faibuengaixo6leiL1awii" ... access-token-validity="300" refresh-token-validity="300"/>
```

---

**B10-14** — MEDIUM
**Section:** 2. Authentication and Authorization
**File:** `src/main/java/com/journaldev/spring/jdbc/controller/SessionController.java:97-134`
**Description:** `getQuestion()` returns the checklist questions for a given equipment ID (`eid`). The equipment ID is not validated against the authenticated caller's company. A driver can query questions for equipment belonging to a different company by supplying a foreign `eid`.
**Evidence:**
```java
@RequestMapping(value = RestURIConstants.GET_QUESTION, method = RequestMethod.GET)
public @ResponseBody
ResponseEntity<List<Questions>> getQuestion(@PathVariable("eid") int eid) {
    ...
    String query = "select type_id, manu_id, fuel_type_id, comp_id from unit where id = ?";
    List<Equipment> arrEquipment = jdbcTemplate.query(query, new Object[]{eid}, ...);
    // comp_id is fetched but never compared to the authenticated user's company
```

---

**B10-15** — MEDIUM
**Section:** 2. Authentication and Authorization
**File:** `src/main/webapp/WEB-INF/spring/spring-security.xml:12-14`
**Description:** Two OAuth endpoints are explicitly marked `security="none"` with a comment stating "Just for testing...". These endpoints (`/oauth/cache_approvals` and `/oauth/uncache_approvals`) are completely unauthenticated. If they are still functional in the production deployment, they bypass all security controls.
**Evidence:**
```xml
<!-- Just for testing... -->
<http pattern="/oauth/cache_approvals" security="none" xmlns="http://www.springframework.org/schema/security" />
<http pattern="/oauth/uncache_approvals" security="none" xmlns="http://www.springframework.org/schema/security" />
```

---

**B10-16** — MEDIUM
**Section:** 2. Authentication and Authorization
**File:** `src/main/webapp/WEB-INF/spring/spring-security.xml:74`
**Description:** Passwords are hashed using MD5 (`<password-encoder hash="md5"/>`). MD5 is a broken cryptographic hash function — it is not a password hashing algorithm. It has no salt by default in this configuration and is trivially reversible using rainbow tables or brute force. Any database compromise would result in near-immediate credential recovery for all users.
**Evidence:**
```xml
<authentication-provider user-service-ref="userDetailsService">
    <password-encoder hash="md5"/>
</authentication-provider>
```

---

### Section 3 — Input Validation and Injection

**B10-17** — HIGH
**Section:** 3. Input Validation and Injection
**File:** `src/main/java/com/journaldev/spring/jdbc/controller/SessionController.java:170-223`
**Description:** `saveResults()` accepts a `@RequestBody Result result` with no `@Valid` annotation and no JSR-303 constraints on the `Result` model. The `result.getStart_time()` and `result.getFinish_time()` values are passed directly to `DateUtil.parseDateTimeIso()`. If this method does not rigorously validate the date format and the `Result` POJO has no constraints, malformed date strings could cause unhandled exceptions that may expose stack traces. The `result.getComment()` field is stored directly in the database with no length or content validation.
**Evidence:**
```java
@RequestMapping(value = RestURIConstants.SAVE_RESULT, method = RequestMethod.POST)
public @ResponseBody
ResponseEntity<Results> saveResults(@RequestBody Result result) {
    // No @Valid annotation on parameter
    // result fields are used without validation
    jdbcTemplate.update(query, new Object[]{id,
        DateUtil.parseDateTimeIso(result.getStart_time()),
        DateUtil.parseDateTimeIso(result.getFinish_time()),
        result.getSession_id(), result.getComment()});
```

---

**B10-18** — HIGH
**Section:** 3. Input Validation and Injection
**File:** `src/main/java/com/journaldev/spring/jdbc/controller/SessionController.java:229-287`
**Description:** `startSessions()` accepts a `@RequestBody Sessions session` with no `@Valid` annotation. `session.getStart_time()` is passed directly to `DateUtil.parseDateTimeIso()` and used in multiple SQL queries. The `session.getDriver_id()` and `session.getUnit_id()` integer fields are used in SQL queries without range validation. No constraints are enforced on the incoming JSON body.
**Evidence:**
```java
public @ResponseBody
ResponseEntity<Sessions> startSessions(@RequestBody Sessions session) {
    // No @Valid annotation
    Date startTime = DateUtil.parseDateTimeIso(session.getStart_time());
    String sql = "select count(*) from session where driver_id = ? and unit_id = ? and start_time < ?...";
    int count = jdbcTemplate.queryForObject(sql, Integer.class,
        new Object[]{session.getDriver_id(), session.getUnit_id(), startTime});
```

---

**B10-19** — MEDIUM
**Section:** 3. Input Validation and Injection
**File:** `src/main/java/com/journaldev/spring/jdbc/controller/UserController.java:23`
**Description:** The `email` request parameter passed to `getUserByEmail()` is not validated for format, length, or content before being passed to the DAO. There is no `@Valid`, `@Size`, or `@Pattern` constraint applied. The `UserDAO.findByName()` call passes the raw `email` value (and its MD5 hash) into a parameterised query — the SQL injection risk is low due to parameterisation, but there is no input length or format check that would prevent, for example, excessively long strings being passed to the database.
**Evidence:**
```java
@RequestMapping(value = "/rest/admin/user", method = RequestMethod.GET)
public @ResponseBody ResponseEntity<User> getUserByEmail(@RequestParam("email") String email) {
    Optional<User> user = userDao.findByName(email);
    // email is not validated for format or length
```

---

**B10-20** — LOW
**Section:** 3. Input Validation and Injection
**File:** `src/main/java/com/journaldev/spring/jdbc/controller/SessionController.java:136-168`
**Description:** The `searchForm()` method (line 152) contains a broken SQL query with a syntax error at line 163 (`where u. l.question_id = question_id = ?`). While this means the endpoint likely throws a SQL exception at runtime rather than executing, the `keyword` path variable (line 154) is incorporated in the surrounding query logic but the SQL is too malformed to assess injection risk definitively. The broken query is a dead code path that has never been tested. The `type` path variable is used in an `ilike` query via parameterisation (line 165), which is safe.
**Evidence:**
```java
String query = "select id,input_type,input_label,input_value,"
    + "  case when input_image is null then '' else ?||input_image end as input_image,input_order from formdtl "
    + " where form_id in "
    + "( select id from form_library as l,question as q, unit as u   "
    + " where u. l.question_id = question_id = ? and type ilike ?) "   // broken SQL syntax
    + " order by input_order";
```

---

### Section 4 — Session and CSRF

**B10-21** — HIGH
**Section:** 4. Session and CSRF
**File:** `src/main/webapp/WEB-INF/spring/spring-security.xml:28`
**Description:** The Spring Security HTTP block protecting `/rest/**` is configured with `create-session="never"`, which is appropriate for a stateless API. However, the Spring Security configuration contains no CSRF protection configuration, and there is no evidence of CSRF token validation anywhere in the filter chain or controllers. While OAuth2 bearer token APIs are typically exempt from CSRF (because the token is not a cookie), the password grant flow and any session-carrying flow would be at risk. The configuration should explicitly address CSRF posture.
**Evidence:**
```xml
<http pattern="/rest/**" create-session="never" entry-point-ref="oauthAuthenticationEntryPoint"
    xmlns="http://www.springframework.org/schema/security">
    <!-- No csrf element present -->
```

---

**B10-22** — MEDIUM
**Section:** 4. Session and CSRF
**File:** `src/main/webapp/WEB-INF/spring/servlet-context.xml` / `src/main/webapp/WEB-INF/spring/spring-security.xml`
**Description:** There is no configuration of security response headers anywhere in the Spring Security XML or servlet context: `X-Frame-Options`, `X-Content-Type-Options`, `Strict-Transport-Security`, and `Content-Security-Policy` are all absent. While `web.xml` declares `CONFIDENTIAL` transport (requiring HTTPS at the Tomcat level), there is no `Strict-Transport-Security` header to enforce HTTPS for browser clients.
**Evidence:** No `<headers>` element in `spring-security.xml`; no header-setting filter in `servlet-context.xml` or `web.xml`.

---

### Section 5 — Data Exposure

**B10-23** — CRITICAL
**Section:** 5. Data Exposure
**File:** `src/main/java/com/journaldev/spring/jdbc/controller/UserController.java:23-32`
**Description:** `getUserByEmail()` returns a `User` object directly as the HTTP response body. The `User` model (`User.java`) contains a `password` field. The `UserDAO.findByName()` method explicitly fetches the `password` column from the database view (`v_apiusers`) and sets it on the returned `User` object. The JSON serialiser (Jackson) will include this field in the HTTP response because `User` uses Lombok `@Data` with no `@JsonIgnore` on the password field. The password hash of any user in the system is therefore returned in the API response body to any authenticated caller.
**Evidence:**
```java
// UserDAO.java line 39-44
user = User.builder()
    .name(rs.getString("name"))
    .email(rs.getString("email"))
    .password(rs.getString("password"))   // password fetched and set
    .active(rs.getBoolean("active"))
    .build();

// User.java line 25
private String password;  // No @JsonIgnore annotation

// UserController.java line 27-31
if (user.isPresent()) {
    return new ResponseEntity<>(user.get(), HttpStatus.OK);  // Full User object returned
}
```

---

**B10-24** — HIGH
**Section:** 5. Data Exposure
**File:** `src/main/java/com/journaldev/spring/jdbc/controller/SessionController.java:170-223`
**Description:** `saveResults()` logs the full `Result` request body as JSON at the INFO level on entry: `logger.info("Start saveResults." + " : " + gson.toJson(result))`. The `Result` object may contain operator-submitted answers including safety inspection responses and comments. Logging the complete body at INFO level means this data appears in production logs, exposing operator PII and session data to anyone with log access.
**Evidence:**
```java
logger.info("Start saveResults."  + " : " + gson.toJson(result));
```

---

**B10-25** — HIGH
**Section:** 5. Data Exposure
**File:** `src/main/java/com/journaldev/spring/jdbc/controller/SessionController.java:229-230`
**Description:** `startSessions()` logs the full session request body (including `driver_id`, `unit_id`, and start time) at INFO level. Similarly, `endSessions()` (line 299-300) and `saveOffline()` (line 384) do the same for their respective request bodies. This persistently logs operator identity (driver ID) and forklift (unit ID) combinations in production logs at the INFO level.
**Evidence:**
```java
logger.info("Start startSessions."  + " : " + gson.toJson(session));
logger.info("Start endSessions."  + " : " + gson.toJson(session));
logger.info("Start saveOffline."  + " : " + gson.toJson(offlineSession));
```

---

**B10-26** — MEDIUM
**Section:** 5. Data Exposure
**File:** `src/main/java/com/journaldev/spring/jdbc/controller/SessionController.java:88-90`
**Description:** When an `IOException` occurs in `driverAccess()`, `e.printStackTrace()` is called before returning the error response. Stack traces written to `System.err` may appear in Tomcat logs and can expose internal class names, file paths, and method names to operators with log access. This is in addition to the general concern about stack trace exposure.
**Evidence:**
```java
} catch (IOException e) {
    e.printStackTrace();
    return new ResponseEntity<>(new Driver(), HttpStatus.BAD_GATEWAY);
}
```

---

**B10-27** — MEDIUM
**Section:** 5. Data Exposure
**File:** `src/main/java/com/journaldev/spring/jdbc/controller/SessionController.java:342-344`
**Description:** When `endSessions()` catches an `EmptyResultDataAccessException`, it serialises the full `Sessions` object (using the `toString(Serializable)` helper that produces a Base64-encoded Java serialised representation) and logs it at ERROR level. This logs the complete session object — including driver ID, unit ID, timestamps, and prestart status — in the server error log.
**Evidence:**
```java
} catch (EmptyResultDataAccessException e) {
    logger.error("Trying to end a session that cannot be found. Session : " + this.toString(session));
}
```

---

### Section 6 — Dependencies

**B10-28** — CRITICAL
**Section:** 6. Dependencies
**File:** `pom.xml:230-237`
**Description:** Spring Security is pinned at version `3.1.1.RELEASE`. This version is over 10 years old and has numerous known CVEs, including authentication bypass and privilege escalation vulnerabilities. It is well past end-of-life with no security patches available from Spring.
**Evidence:**
```xml
<groupId>org.springframework.security</groupId>
<artifactId>spring-security-web</artifactId>
<version>3.1.1.RELEASE</version>
...
<groupId>org.springframework.security</groupId>
<artifactId>spring-security-config</artifactId>
<version>3.1.1.RELEASE</version>
```

---

**B10-29** — CRITICAL
**Section:** 6. Dependencies
**File:** `pom.xml:238-242`
**Description:** The Spring Security OAuth2 library is pinned at `1.0.0.RELEASE`. This is the initial 1.0 release of Spring Security OAuth2, which is extremely old and has known vulnerabilities. The Spring Security OAuth project has been deprecated in favour of Spring Authorization Server. Version 1.0.0.RELEASE predates numerous security fixes.
**Evidence:**
```xml
<groupId>org.springframework.security.oauth</groupId>
<artifactId>spring-security-oauth2</artifactId>
<version>1.0.0.RELEASE</version>
```

---

**B10-30** — HIGH
**Section:** 6. Dependencies
**File:** `pom.xml:10-18`
**Description:** The Spring Framework version is `3.2.14.RELEASE`. Spring 3.x reached end of life in December 2016. This version has numerous known CVEs, including CVEs related to expression language injection and MVC path handling. It has not received security patches in many years.
**Evidence:**
```xml
<org.springframework-version>3.2.14.RELEASE</org.springframework-version>
```

---

**B10-31** — HIGH
**Section:** 6. Dependencies
**File:** `pom.xml:98-101`
**Description:** Jackson Databind is pinned at `2.6.7`. This version has numerous known deserialization CVEs (e.g., CVE-2017-7525, CVE-2018-7489, and many others in the `2.6.x` series). Without the polymorphic deserialization protections present in later versions, if `@JsonTypeInfo` or `enableDefaultTyping` is used anywhere in the application, arbitrary code execution via gadget chains is possible.
**Evidence:**
```xml
<groupId>com.fasterxml.jackson.core</groupId>
<artifactId>jackson-databind</artifactId>
<version>2.6.7</version>
```

---

**B10-32** — HIGH
**Section:** 6. Dependencies
**File:** `pom.xml:198-201`
**Description:** `commons-fileupload` is pinned at version `1.3.1`. This version is vulnerable to CVE-2016-1000031 (arbitrary file write via `DiskFileItem` deserialization) among other issues. Version `1.3.1` was released in 2014 and is significantly outdated.
**Evidence:**
```xml
<groupId>commons-fileupload</groupId>
<artifactId>commons-fileupload</artifactId>
<version>1.3.1</version>
```

---

**B10-33** — MEDIUM
**Section:** 6. Dependencies
**File:** `pom.xml:336-340`
**Description:** The Flyway plugin uses the `postgresql` JDBC driver at version `9.1-901.jdbc3`, which is an extremely old PostgreSQL JDBC driver from circa 2011. The driver identifier uses the legacy `jdbc3` API. This version likely has bugs and may have security issues.
**Evidence:**
```xml
<groupId>postgresql</groupId>
<artifactId>postgresql</artifactId>
<version>9.1-901.jdbc3</version>
```

---

### Section 7 — Build and CI

**B10-34** — MEDIUM
**Section:** 7. Build and CI
**File:** `pom.xml` (no bitbucket-pipelines.yml present)
**Description:** No `bitbucket-pipelines.yml` was found in the repository. There is no automated CI/CD pipeline configuration present. This means there are no automated build, test, or security gate stages, and deployment is a manual process. Without a pipeline, tests may be skipped and builds may not be reproducible.
**Evidence:** `bitbucket-pipelines.yml` does not exist in the repository root.

---

**B10-35** — INFO
**Section:** 7. Build and CI
**File:** `pom.xml:44-50` (dev profile)
**Description:** The dev profile specifies a Tomcat Manager URL (`http://forklift360.canadaeast.cloudapp.azure.com:8080/manager/text`) over plain HTTP. Deploying to Tomcat Manager over HTTP means the WAR file and any credentials used by the deployment process are transmitted unencrypted. The Tomcat credentials are stored in Maven's `settings.xml` (server reference `TomcatServerAzure`), which is outside this repo; however, the plain HTTP deployment endpoint itself is a risk.
**Evidence:**
```xml
<tomcat.url>http://forklift360.canadaeast.cloudapp.azure.com:8080/manager/text</tomcat.url>
```

---

## Finding Summary

| ID | Severity | Section | Subject |
|----|----------|---------|---------|
| B10-1 | CRITICAL | Secrets | GCM key and Clickatell credentials hardcoded in RuntimeConfig.java |
| B10-2 | HIGH | Secrets | Database credentials hardcoded in pom.xml (local and UAT profiles) |
| B10-3 | HIGH | Secrets | Cognito API credentials committed in all environment.*.properties files |
| B10-4 | MEDIUM | Secrets | Plaintext HTTP EC2 PDF API URL hardcoded |
| B10-5 | MEDIUM | Secrets | OAuth2 client secrets hardcoded in spring-security.xml |
| B10-6 | INFO | Secrets | Splunk dependency fetched over HTTP from third-party Artifactory |
| B10-7 | CRITICAL | AuthZ | /rest/admin/user accessible to ROLE_DRIVER — no admin-role guard |
| B10-8 | CRITICAL | IDOR | abortSessions deletes any session by ID with no ownership check |
| B10-9 | HIGH | IDOR | startSessions accepts arbitrary driver_id/unit_id with no ownership check |
| B10-10 | HIGH | IDOR | endSessions closes any session by ID with no ownership check |
| B10-11 | HIGH | IDOR | driverAccess uploads images to any session ID with no ownership check |
| B10-12 | HIGH | AuthZ | OAuth2 client 987654321 has non-expiring access token (validity=0) |
| B10-13 | HIGH | AuthZ | Password grant type enabled; refresh token validity equals access token validity |
| B10-14 | MEDIUM | IDOR | getQuestion returns questions for any equipment ID without company scope check |
| B10-15 | MEDIUM | AuthZ | /oauth/cache_approvals and /oauth/uncache_approvals are unauthenticated |
| B10-16 | MEDIUM | AuthZ | MD5 used as password hashing algorithm — broken and unsalted |
| B10-17 | HIGH | Injection | saveResults @RequestBody has no @Valid and fields are unvalidated |
| B10-18 | HIGH | Injection | startSessions @RequestBody has no @Valid and fields are unvalidated |
| B10-19 | MEDIUM | Injection | getUserByEmail email parameter has no format/length validation |
| B10-20 | LOW | Injection | searchForm contains broken SQL syntax; keyword path variable not used safely |
| B10-21 | HIGH | CSRF | No CSRF protection configuration present in Spring Security XML |
| B10-22 | MEDIUM | Headers | No security response headers configured (X-Frame-Options, HSTS, etc.) |
| B10-23 | CRITICAL | Data Exposure | getUserByEmail returns password hash in JSON response body |
| B10-24 | HIGH | Data Exposure | saveResults logs full Result JSON body at INFO including operator answers |
| B10-25 | HIGH | Data Exposure | startSessions/endSessions/saveOffline log full request body at INFO |
| B10-26 | MEDIUM | Data Exposure | driverAccess uses e.printStackTrace() on IOException |
| B10-27 | MEDIUM | Data Exposure | endSessions logs serialised Session object at ERROR level |
| B10-28 | CRITICAL | Dependencies | Spring Security 3.1.1.RELEASE — end of life, multiple CVEs |
| B10-29 | CRITICAL | Dependencies | Spring Security OAuth2 1.0.0.RELEASE — end of life, multiple CVEs |
| B10-30 | HIGH | Dependencies | Spring Framework 3.2.14.RELEASE — end of life since 2016 |
| B10-31 | HIGH | Dependencies | Jackson Databind 2.6.7 — multiple deserialization CVEs |
| B10-32 | HIGH | Dependencies | commons-fileupload 1.3.1 — CVE-2016-1000031 and others |
| B10-33 | MEDIUM | Dependencies | PostgreSQL JDBC driver 9.1-901.jdbc3 — extremely outdated |
| B10-34 | MEDIUM | CI/Build | No bitbucket-pipelines.yml present; no automated CI pipeline |
| B10-35 | INFO | CI/Build | Tomcat Manager deployment over plain HTTP in dev profile |
