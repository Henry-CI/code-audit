# Security Audit — Pass 1 — Agent B01
**Date:** 2026-02-27
**Branch:** master
**Repo:** forkliftiqws
**Auditor:** B01

---

## Section 1 — Reading Evidence

### 1.1 `com.journaldev.spring.jdbc.DAO.APIDAO`
**File:** `src/main/java/com/journaldev/spring/jdbc/DAO/APIDAO.java`

**Class type:** Interface

**Interfaces implemented / classes extended:** None

**Fields:** None

**Public methods:**

| Line | Return Type | Method | Parameters |
|------|-------------|--------|------------|
| 10 | `boolean` | `checkKey` | `String APIkey` |
| 11 | `Driver` | `findByName` | `String username` |

**Annotations on class:** None

**Annotations on methods:** None

---

### 1.2 `com.journaldev.spring.jdbc.DAO.APIDAOImpl`
**File:** `src/main/java/com/journaldev/spring/jdbc/DAO/APIDAOImpl.java`

**Class type:** Concrete class

**Classes extended:** `org.springframework.jdbc.core.support.JdbcDaoSupport`

**Interfaces implemented:** `APIDAO`

**Annotations on class:**
- `@Component("apiDao")` (line 16)
- `@Transactional(readOnly = true)` (line 17)

**Fields:**

| Modifier | Type | Name | Line |
|----------|------|------|------|
| `private static final` | `Logger` | `logger` | 20 |

**Public methods:**

| Line | Return Type | Method | Parameters | Annotations |
|------|-------------|--------|------------|-------------|
| 24 | `void` | `setDbDataSource` | `DataSource dataSource` | `@Autowired`, `@Qualifier("dataSource")` |
| 28 | `boolean` | `checkKey` | `String key` | None |
| 36 | `Driver` | `findByName` | `String username` | None |

---

### 1.3 `com.journaldev.spring.jdbc.CompanyDAO`
**File:** `src/main/java/com/journaldev/spring/jdbc/DAO/CompanyDAO.java`

**Class type:** Concrete class

**Classes extended:** `org.springframework.jdbc.core.support.JdbcDaoSupport`

**Interfaces implemented:** None

**Annotations on class:**
- `@Repository` (line 24)

**Fields:**

| Modifier | Type | Name | Line |
|----------|------|------|------|
| `private` | `Configuration` | `configuration` | 28 (`@Autowired`) |
| `private static final` | `String` | `BASE_QUERY_COMPANY` | 52 |

**Public methods:**

| Line | Return Type | Method | Parameters | Annotations |
|------|-------------|--------|------------|-------------|
| 32 | `void` | `setDbDataSource` | `DataSource dataSource` | `@Autowired`, `@Qualifier("dataSource")` |
| 36 | `int` | `save` | `Company company, int driverId, String email, String password` | None |
| 62 | `Optional<Company>` | `findById` | `Long comp_id` | None |
| 74 | `List<Company>` | `findAllByDriverId` | `Long driverId` | None |
| 87 | `List<Company>` | `findAllByKeyword` | `String keyword` | None |

**Private inner classes:**
- `CompaniesResultResetExtractor` implements `ResultSetExtractor<List<Company>>` (line 98)
- `CompanyResultResetExtractor` implements `ResultSetExtractor<Company>` (line 136)

**Private static methods:**
- `mapCompany(ResultSet rs)` returns `Company` (line 160)

---

## Section 2 — Checklist Findings

### Section 1 — Secrets and Configuration

**`spring-security.xml` — Hardcoded OAuth2 client credentials (CRITICAL)**

The OAuth2 client-details configuration in `spring-security.xml` contains hardcoded client IDs and secrets in the committed XML file:

```xml
<oauth:client client-id="987654321"
              secret="8752361E593A573E86CA558FFD39E" ... />

<oauth:client client-id="fleetiq360"
              secret="rihah8eey4faibuengaixo6leiL1awii" ... />
```

See finding **B01-1** below.

**`spring-security.xml` — MD5 password encoder (HIGH)**

The `authentication-manager` bean uses `<password-encoder hash="md5"/>`, meaning all stored user passwords are MD5-hashed — a cryptographically broken algorithm. See finding **B01-2**.

**`application.properties` / `Configuration.java` — Cognito credentials stored in properties file:** `Configuration.java` injects `cognitoAPIUsername` and `cognitoAPIPassword` via `@Value`. Whether these are hardcoded depends on the properties file contents (not in scope for this pass), but the pattern warrants tracking. CLEAR from the source files read — deferred to properties file review.

---

### Section 2 — Authentication and Authorization

**Spring Security XML — no CSRF:** `spring-security.xml` configures `create-session="never"` on the `/rest/**` block with no CSRF element. OAuth2 resource server endpoints with Bearer tokens are generally CSRF-exempt by design, but the presence of cookie-based auth paths (if any) is not verified. N/A — API is stateless OAuth2.

**Spring Security XML — `/oauth/cache_approvals` and `/oauth/uncache_approvals` are `security="none"`:** These paths are explicitly unprotected with a comment "Just for testing...". See finding **B01-3**.

**IDOR — `getCompany` endpoint:** `GET /rest/company/get/{uid}` in `CompanyController` (line 37) passes the `{uid}` path variable directly to `companyDAO.findAllByDriverId(uid)` without verifying that the authenticated user's identity matches `uid`. Any authenticated `ROLE_DRIVER` user can supply any other driver's ID and retrieve all companies associated with that driver. See finding **B01-4**.

**IDOR — `getCompanyDrivers` endpoint:** `GET /rest/company/owner/{uid}/drivers` (line 44) passes `{uid}` to `driverDAO.findAllByCompanyOwner(uid)` without an ownership check. See finding **B01-5**.

**IDOR — `companyAccept` endpoint:** `PUT /rest/company/accept/{pid}` (line 148) accepts a permission ID and unconditionally sets `enabled = true` with no verification that the permission record belongs to the authenticated user's company. Any authenticated user can accept any pending driver request. See finding **B01-6**.

**IDOR — `companyDelete` endpoint:** `PUT /rest/company/delete/{pid}` (line 163) issues `DELETE FROM permission WHERE id = ?` with no ownership check. Any authenticated user can delete any permission record by guessing an ID. See finding **B01-7**.

**No `@PreAuthorize` or ownership enforcement in CompanyDAO / APIDAOImpl:** Neither DAO performs any binding between the calling user's identity and the data returned. All access control is limited to role presence, not data ownership.

---

### Section 3 — Input Validation and Injection

**`APIDAOImpl.findByName` — incorrect `queryForObject` overload (runtime failure / wrong mapping):** Line 40 calls:
```java
return getJdbcTemplate().queryForObject(sql, Driver.class, username);
```
The overload `queryForObject(String sql, Class<T> requiredType, Object... args)` is the scalar-type overload — it maps a single column to a simple Java type. `Driver.class` is not a scalar type; Spring will attempt to call `Driver.class.cast(columnValue)` on a single column, which will throw a `ClassCastException` at runtime. This means the method is dead code in practice (always throws). While not a SQL injection issue, it indicates the method has never been integration-tested and suggests the feature is untested. See finding **B01-8**.

**`APIDAOImpl.checkKey` — always returns `true`:** Line 28-34, `checkKey(String key)` logs the supplied API key and unconditionally returns `true`. Any API key check relying on this method will always pass. The commented-out SQL suggests this was left in an incomplete state. See finding **B01-9**.

**`CompanyDAO.findAllByKeyword` — unvalidated cross-tenant search:** The keyword is correctly parameterised (no SQL injection), but the search endpoint `GET /rest/company/search/{keyword}` returns data from all companies matching the keyword. There is no tenant or organisation scoping applied. Any authenticated user can enumerate company names and email addresses across the entire dataset. See finding **B01-10**.

**SQL in `BASE_QUERY_COMPANY` — parameterised correctly:** The base query uses `?` placeholders throughout. CLEAR for SQL injection in the DAO query methods.

**`save()` password handling:** The `save` method at line 41 accepts a plaintext `password` parameter and wraps it in `md5(?)` at the database level. This means the password is transmitted in plaintext to the database layer and stored as MD5. No injection risk (parameterised), but the MD5 storage is a cryptographic weakness (see B01-2).

**No `@Valid` / `@NotNull` / `@Size` validation:** No constraint annotations appear on any DAO parameter or on the `Permissions` / `Company` / `Driver` models. See finding **B01-11**.

---

### Section 4 — Session and CSRF

**CSRF:** The API is stateless OAuth2 with Bearer tokens. CSRF is not applicable to this layer. N/A.

**CORS:** No `@CrossOrigin` annotations present in `APIDAO.java`, `APIDAOImpl.java`, or `CompanyDAO.java`. CORS configuration deferred to servlet context review.

**Security headers:** Not configurable in DAO layer. N/A.

**`companyAcceptWeb` — unauthenticated token-based acceptance:** `GET /rest/company/accept/web/{token}` (line 121, `CompanyController`) is routed through the `/rest/**` intercept-url block, which requires one of `ROLE_DRIVER`, `ROLE_COMPANY_GROUP`, `ROLE_SYS_ADMIN`, or `ROLE_CLIENT`. Authentication is enforced. The token itself is `md5(to_char(createdat, 'DDMMYYYYHH12MI:SS')||id)` — predictable given knowledge of the permission ID and creation timestamp. See finding **B01-12**.

---

### Section 5 — Data Exposure

**`Company` model exposes `password` field (HIGH):** The `Company` class (line 23) has a `private String password` field. `@Data` (Lombok) generates a `getPassword()` getter. No `@JsonIgnore` is present. When `findById`, `findAllByDriverId`, or `findAllByKeyword` returns a `Company` object, the JSON serialization will include the `password` field — containing the MD5-hashed password of the company's contact driver. See finding **B01-13**.

**`Driver` model exposes `password`, `securityno`, `licno` fields (HIGH):** The `Driver` class (lines 25, 27, 29) has `private String password`, `private String securityno`, and `private String licno`. No `@JsonIgnore` is present on any of these. `Driver` objects are nested within `Company` responses (`contactDriver` field) and are returned directly by other endpoints. See finding **B01-14**.

**`Permissions` model exposes `gsm_token` field (MEDIUM):** The `Permissions` class (line 28) has a `private String gsm_token` field with no `@JsonIgnore`. This field is mapped from the `gsm_token` column in `BASE_QUERY_COMPANY` and serialized to API responses. Mobile push notification tokens (GSM tokens) constitute PII-adjacent device identifiers and should not be returned in general company lookup responses. See finding **B01-15**.

**`CompanyResultResetExtractor` NullPointerException path (MEDIUM):** At line 154, the single-company extractor unconditionally calls `cie.setArrRoles(roles)` without checking whether `cie` is null (which it would be for a query that returns zero rows). Spring's `queryForObject`-style use would throw `EmptyResultDataAccessException` first, but if called from a context that returns zero rows via the extractor path, the NPE would surface as a 500 response, which may leak a stack trace to the client. See finding **B01-16**.

**Sensitive data in logs:** `APIDAOImpl.checkKey` at line 29 logs the raw `key` value at `INFO` level:
```java
logger.info("Start checkKey : {}", key);
```
`APIDAOImpl.findByName` at line 37 logs the `username` at `INFO` level. While not a password, logging API keys at INFO in production creates a secrets-in-logs exposure path. See finding **B01-17**.

---

### Section 6 — Dependencies

N/A for these source files. Dependency review is deferred to `pom.xml` analysis.

---

### Section 7 — Build and CI

N/A for these source files.

---

## Findings

---

**B01-1** — CRITICAL
**Section:** 1 — Secrets and Configuration
**File:** `src/main/webapp/WEB-INF/spring/spring-security.xml:113-117`
**Description:** OAuth2 client secrets are hardcoded in a committed configuration file. Both client ID/secret pairs are stored in plaintext in version control. Anyone with repository read access obtains working credentials to authenticate against the token endpoint. The `fleetiq360` client has `ROLE_DRIVER`, `ROLE_COMPANY_GROUP`, and `ROLE_SYS_ADMIN` authorities, meaning an attacker with these credentials can request tokens with the highest roles.
**Evidence:**
```xml
<oauth:client client-id="987654321" authorized-grant-types="password,authorization_code,implicit"
              secret="8752361E593A573E86CA558FFD39E" authorities="ROLE_CLIENT" scope="read,write" access-token-validity="0"/>

<oauth:client client-id="fleetiq360" authorized-grant-types="password,authorization_code,refresh_token,implicit"
              secret="rihah8eey4faibuengaixo6leiL1awii" authorities="ROLE_DRIVER,ROLE_COMPANY_GROUP,ROLE_SYS_ADMIN" scope="read,write" access-token-validity="300" refresh-token-validity="300"/>
```

---

**B01-2** — HIGH
**Section:** 1 — Secrets and Configuration / 2 — Authentication
**File:** `src/main/webapp/WEB-INF/spring/spring-security.xml:74`
**Description:** The Spring Security authentication provider is configured with MD5 as the password hashing algorithm. MD5 is a cryptographically broken hash function with no salt, no work factor, and is trivially reversed via rainbow tables and GPU cracking. All stored user passwords are at risk of rapid compromise if the database is breached.
**Evidence:**
```xml
<authentication-provider user-service-ref="userDetailsService">
    <password-encoder hash="md5"/>
</authentication-provider>
```

---

**B01-3** — HIGH
**Section:** 2 — Authentication and Authorization
**File:** `src/main/webapp/WEB-INF/spring/spring-security.xml:13-14`
**Description:** Two URL patterns are explicitly excluded from security (`security="none"`) with a comment "Just for testing...". These endpoints — `/oauth/cache_approvals` and `/oauth/uncache_approvals` — are reachable without any authentication in production. OAuth2 token approval cache manipulation endpoints being publicly accessible is a significant auth bypass risk.
**Evidence:**
```xml
<!-- Just for testing... -->
<http pattern="/oauth/cache_approvals" security="none" xmlns="http://www.springframework.org/schema/security" />
<http pattern="/oauth/uncache_approvals" security="none" xmlns="http://www.springframework.org/schema/security" />
```

---

**B01-4** — HIGH
**Section:** 2 — Authentication and Authorization
**File:** `src/main/java/com/journaldev/spring/jdbc/controller/CompanyController.java:37`
**Description:** The `getCompany` endpoint accepts a `{uid}` path variable and directly returns all company memberships for that driver ID with no check that the authenticated user's identity equals `uid`. Any authenticated driver can enumerate company associations for any other driver by varying the `uid` parameter. This is an Insecure Direct Object Reference (IDOR) vulnerability.
**Evidence:**
```java
@RequestMapping(value= RestURIConstants.GET_COMPANY, method=RequestMethod.GET)
public @ResponseBody List<Company> getCompany( @PathVariable("uid") Long uid) {
    logger.info("Start getCompany for {}", uid);
    return this.companyDAO.findAllByDriverId(uid);
}
```
The response includes `Company` objects which (per B01-13) also expose password hashes.

---

**B01-5** — HIGH
**Section:** 2 — Authentication and Authorization
**File:** `src/main/java/com/journaldev/spring/jdbc/controller/CompanyController.java:44`
**Description:** `GET /rest/company/owner/{uid}/drivers` passes `{uid}` to `driverDAO.findAllByCompanyOwner(uid)` with no ownership check. Any authenticated user can retrieve the full driver list for any company owner by varying `{uid}`.
**Evidence:**
```java
@RequestMapping(value= RestURIConstants.GET_COMPANY_DRIVERS, method=RequestMethod.GET)
public @ResponseBody List<Driver> getCompanyDrivers(@PathVariable("uid") int uid) {
    logger.info("Start getCompanyDrivers.");
    List<Driver> drivers = driverDAO.findAllByCompanyOwner(uid);
    return drivers;
}
```

---

**B01-6** — HIGH
**Section:** 2 — Authentication and Authorization
**File:** `src/main/java/com/journaldev/spring/jdbc/controller/CompanyController.java:147-159`
**Description:** `PUT /rest/company/accept/{pid}` unconditionally sets `enabled = true` on the permission record identified by `{pid}`, with no verification that the permission record belongs to a company owned by the authenticated user. Any authenticated user can accept any pending driver-to-company permission request by guessing or enumerating the permission ID.
**Evidence:**
```java
@RequestMapping(value= RestURIConstants.COMPANY_ACCEPT, method=RequestMethod.PUT)
public @ResponseBody ResponseEntity<Results> companyAccept( @PathVariable("pid") int pid) {
    ...
    String query = "update permission set enabled = true, updatedat = now() where id = ?";
    jdbcTemplate.update(query, new Object[] {pid});
    ...
}
```

---

**B01-7** — HIGH
**Section:** 2 — Authentication and Authorization
**File:** `src/main/java/com/journaldev/spring/jdbc/controller/CompanyController.java:162-174`
**Description:** `PUT /rest/company/delete/{pid}` issues `DELETE FROM permission WHERE id = ?` with the caller-supplied `pid` and no ownership verification. Any authenticated user can remove any permission record, including records belonging to other companies. This enables denial-of-service by destroying legitimate driver access.
**Evidence:**
```java
@RequestMapping(value= RestURIConstants.COMPANY_DELETE, method=RequestMethod.PUT)
public @ResponseBody ResponseEntity<Results> companyDelete( @PathVariable("pid") int pid) {
    ...
    String query = "delete from permission where id = ?";
    jdbcTemplate.update(query, new Object[] {pid});
    ...
}
```

---

**B01-8** — MEDIUM
**Section:** 3 — Input Validation and Injection
**File:** `src/main/java/com/journaldev/spring/jdbc/DAO/APIDAOImpl.java:38-40`
**Description:** `APIDAOImpl.findByName` uses the wrong `JdbcTemplate.queryForObject` overload. The call `queryForObject(sql, Driver.class, username)` invokes the scalar-type overload that maps a single column value to the given class — not the row-mapper overload. `Driver` is not a scalar type, so this call will throw a `ClassCastException` or `IncorrectResultSetColumnCountException` at runtime for any non-trivial query. This indicates the method has never been exercised by tests, which undermines confidence in the correctness and security of APIDAO functionality overall.
**Evidence:**
```java
public Driver findByName(String username) {
    logger.info("Start checkKey for : {}", username);
    String sql = "select * from tblusers where md5(email) = ?";
    return getJdbcTemplate().queryForObject(sql, Driver.class, username);
}
```

---

**B01-9** — HIGH
**Section:** 2 — Authentication and Authorization / 3 — Input Validation
**File:** `src/main/java/com/journaldev/spring/jdbc/DAO/APIDAOImpl.java:28-34`
**Description:** `checkKey(String key)` is a stub that always returns `true` regardless of the key supplied. The commented-out SQL suggests it was originally intended to validate an API key against a database. Any caller relying on this method for access gating receives no protection — all keys are accepted unconditionally.
**Evidence:**
```java
public boolean checkKey(String key){
    logger.info("Start checkKey : {}", key);
    //String sql = "INSERT INTO CUSTOMER (CUST_ID, NAME, AGE) VALUES (?, ?, ?)";
    return true;
}
```

---

**B01-10** — MEDIUM
**Section:** 2 — Authentication and Authorization / 5 — Data Exposure
**File:** `src/main/java/com/journaldev/spring/jdbc/DAO/CompanyDAO.java:87-96` and `src/main/java/com/journaldev/spring/jdbc/controller/CompanyController.java:52-58`
**Description:** `GET /rest/company/search/{keyword}` returns matching companies from the entire database with no tenant scoping. Any authenticated driver can search for and retrieve company name and email information across all organisations. Combined with B01-13, this also leaks password hashes for all matched companies.
**Evidence:**
```java
public List<Company> findAllByKeyword(String keyword) {
    StringBuilder builder = new StringBuilder(BASE_QUERY_COMPANY);
    builder.append(" where c.name ilike ? or c.email ilike ?");
    List<Company> complst = getJdbcTemplate().query(builder.toString(),
                                                new Object[]{configuration.getImageURL(), "%"+keyword+"%", "%"+keyword+"%"},
                                                new CompaniesResultResetExtractor());
    return complst;
}
```

---

**B01-11** — MEDIUM
**Section:** 3 — Input Validation and Injection
**File:** `src/main/java/com/journaldev/spring/jdbc/DAO/CompanyDAO.java` (all methods); `src/main/java/com/journaldev/spring/jdbc/DAO/APIDAOImpl.java` (all methods)
**Description:** No input validation annotations (`@Valid`, `@NotNull`, `@Size`, `@Pattern`) are applied to any DAO method parameters. The `Company`, `Driver`, and `Permissions` model classes have no JSR-303 constraint annotations. Null or malformed inputs propagate directly to SQL queries and JDBC calls. While parameterised queries prevent injection, unbounded string inputs (e.g., arbitrarily large `keyword` values) and null IDs produce unhandled runtime exceptions.
**Evidence:**
```java
public List<Company> findAllByKeyword(String keyword) { // no null check, no length limit
public int save(Company company, int driverId, String email, String password) { // no null checks
public Driver findByName(String username) { // no null check
```

---

**B01-12** — MEDIUM
**Section:** 2 — Authentication and Authorization / 4 — Session and CSRF
**File:** `src/main/java/com/journaldev/spring/jdbc/controller/CompanyController.java:121-145`
**Description:** The web-based company acceptance link uses a token of the form `md5(to_char(createdat, 'DDMMYYYYHH12MI:SS')||id)`. The token is deterministic: given the permission `id` (an auto-incremented integer) and the creation timestamp (truncated to seconds), an attacker with knowledge of these values can forge a valid acceptance token. Timestamps may be predictable in a low-traffic environment and permission IDs are sequential. MD5 provides no keyed MAC security.
**Evidence:**
```java
query = "select md5(to_char(createdat, 'DDMMYYYYHH12MI:SS')||id) from permission where id =  ?";
String token = jdbcTemplate.queryForObject(query,String.class,new Object[]{id});
String url = configuration.getAcceptURL()+token;
```

---

**B01-13** — HIGH
**Section:** 5 — Data Exposure
**File:** `src/main/java/com/journaldev/spring/jdbc/model/Company.java:23` and `src/main/java/com/journaldev/spring/jdbc/DAO/CompanyDAO.java:184-185`
**Description:** The `Company` model includes a `password` field that is populated directly from the `c.password` database column (line 185 of `CompanyDAO.java`, positional index 3 in `mapCompany`). No `@JsonIgnore` annotation is present. When any endpoint returns a `Company` object — including the public-facing search endpoint — the (MD5-hashed) password is included in the JSON response body.
**Evidence:**
```java
// Company.java:23
private String password;

// CompanyDAO.java mapCompany():
cie = Company.builder()
        .id(rs.getLong(1))
        .name(rs.getString(2))
        .password(rs.getString(3))   // populated from DB column c.password
        ...
```
No `@JsonIgnore` on the `password` field in `Company.java`.

---

**B01-14** — HIGH
**Section:** 5 — Data Exposure
**File:** `src/main/java/com/journaldev/spring/jdbc/model/Driver.java:25-29` and `src/main/java/com/journaldev/spring/jdbc/DAO/CompanyDAO.java:162-172`
**Description:** The `Driver` model includes `password`, `securityno` (social security / identity number), and `licno` (licence number) with no `@JsonIgnore` annotations. `Driver` objects are constructed in `mapCompany()` and nested into `Company` responses as `contactDriver`. These fields are populated from the `driver` table columns (`licno`, `securityno`) which are sensitive operator PII. They are serialized and returned in every company lookup response.
**Evidence:**
```java
// Driver.java
private String password;    // line 25
private String licno;       // line 27
private String securityno;  // line 29

// CompanyDAO.java mapCompany()
Driver driver = Driver.builder()
        ...
        .licno(rs.getString("licno"))
        .securityno(rs.getString("securityno"))
        ...
        .build();
```
No `@JsonIgnore` present on any of these fields.

---

**B01-15** — MEDIUM
**Section:** 5 — Data Exposure
**File:** `src/main/java/com/journaldev/spring/jdbc/model/Permissions.java:28` and `src/main/java/com/journaldev/spring/jdbc/DAO/CompanyDAO.java:180`
**Description:** The `Permissions` model includes a `gsm_token` field (mobile push notification token) that is populated from the database and embedded in `Company` responses. No `@JsonIgnore` is present. Push notification tokens allow targeting a specific mobile device and should not be disclosed to arbitrary authenticated callers.
**Evidence:**
```java
// Permissions.java:28
private String gsm_token;

// CompanyDAO.java mapCompany()
Permissions permissions = Permissions.builder()
        ...
        .gsm_token(rs.getString("gsm_token"))
        .build();
```

---

**B01-16** — LOW
**Section:** 5 — Data Exposure
**File:** `src/main/java/com/journaldev/spring/jdbc/DAO/CompanyDAO.java:154`
**Description:** `CompanyResultResetExtractor.extractData` calls `cie.setArrRoles(roles)` at line 154 without a null guard on `cie`. If the query returns zero rows (e.g., the company does not exist), `cie` is null and a `NullPointerException` is thrown. Depending on the exception handler configuration, this may result in a 500 response that leaks a stack trace to the API client.
**Evidence:**
```java
public Company extractData(ResultSet rs) throws SQLException, DataAccessException {
    Company cie = null;
    List<Roles> roles = new ArrayList<>();
    while (rs.next()) {
        if (cie == null) { cie = mapCompany(rs); }
        roles.add(...);
    }
    cie.setArrRoles(roles);   // line 154 — NullPointerException if rs had zero rows
    return cie;
}
```

---

**B01-17** — LOW
**Section:** 5 — Data Exposure (Logging)
**File:** `src/main/java/com/journaldev/spring/jdbc/DAO/APIDAOImpl.java:29`
**Description:** `checkKey` logs the full API key value at `INFO` level on every invocation. In production logging configurations that capture INFO output, this writes caller API keys to log files, which may be less restricted than the database. If `findByName` is called with a username that is also a token or credential, that value is similarly logged.
**Evidence:**
```java
logger.info("Start checkKey : {}", key);
logger.info("Start checkKey for : {}", username);
```

---

## Summary Table

| Finding | Severity | Section | Description |
|---------|----------|---------|-------------|
| B01-1 | CRITICAL | 1 — Secrets | OAuth2 client secrets hardcoded in spring-security.xml |
| B01-2 | HIGH | 1/2 — Secrets/Auth | MD5 password hashing configured in authentication provider |
| B01-3 | HIGH | 2 — Auth | `/oauth/cache_approvals` and `/oauth/uncache_approvals` have `security="none"` |
| B01-4 | HIGH | 2 — Auth | IDOR: `GET /rest/company/get/{uid}` — no ownership check |
| B01-5 | HIGH | 2 — Auth | IDOR: `GET /rest/company/owner/{uid}/drivers` — no ownership check |
| B01-6 | HIGH | 2 — Auth | IDOR: `PUT /rest/company/accept/{pid}` — no ownership check |
| B01-7 | HIGH | 2 — Auth | IDOR: `PUT /rest/company/delete/{pid}` — no ownership check |
| B01-8 | MEDIUM | 3 — Injection | Wrong `queryForObject` overload — `Driver.class` used as scalar type |
| B01-9 | HIGH | 2/3 — Auth/Injection | `checkKey()` always returns `true` — access control stub |
| B01-10 | MEDIUM | 2/5 — Auth/Exposure | Cross-tenant company search — no organisation scoping |
| B01-11 | MEDIUM | 3 — Injection | No input validation on any DAO parameters or model fields |
| B01-12 | MEDIUM | 2/4 — Auth/Session | Predictable MD5-based permission acceptance token |
| B01-13 | HIGH | 5 — Data Exposure | `Company.password` exposed in JSON responses — no `@JsonIgnore` |
| B01-14 | HIGH | 5 — Data Exposure | `Driver.password`, `.securityno`, `.licno` exposed in JSON — no `@JsonIgnore` |
| B01-15 | MEDIUM | 5 — Data Exposure | `Permissions.gsm_token` exposed in company lookup responses |
| B01-16 | LOW | 5 — Data Exposure | NPE on empty result set in `CompanyResultResetExtractor` — potential 500/stack trace |
| B01-17 | LOW | 5 — Data Exposure | API key logged at INFO level in `checkKey` |
