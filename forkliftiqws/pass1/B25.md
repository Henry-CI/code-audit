# Security Audit — Pass 1 (Security Review)
**Agent:** B25
**Date:** 2026-02-27
**Repository:** forkliftiqws (branch: master)
**Checklist:** PASS1-CHECKLIST-forkliftiq-spring.md

---

## Files Assigned

- `src/main/java/com/journaldev/spring/jdbc/service/APKUpdaterException.java`
- `src/main/java/com/journaldev/spring/jdbc/service/APKUpdaterService.java`
- `src/main/java/com/journaldev/spring/jdbc/service/AWSFileStorageService.java`

Supporting files read for context:
- `src/main/java/com/journaldev/spring/jdbc/service/AbstractFileStorageService.java`
- `src/main/java/com/journaldev/spring/jdbc/controller/APKUpdaterController.java`
- `src/main/java/com/journaldev/spring/jdbc/model/PackageEntry.java`
- `src/main/webapp/WEB-INF/spring/spring-security.xml`
- `src/main/webapp/WEB-INF/web.xml`
- `environment.dev.properties`
- `environment.prod.properties`
- `environment.uat.properties`
- `src/main/resources/fleetiq360ws.properties`
- `pom.xml`
- `.gitignore`

---

## Step 3 — Reading Evidence

### File 1: APKUpdaterException.java

**Fully qualified class name:** `com.journaldev.spring.jdbc.service.APKUpdaterException`

**Extends:** `java.lang.RuntimeException`

**Implements:** (none beyond what RuntimeException provides)

**Fields:** none declared

**Class-level annotations:** none

**Public methods:**

| Return type | Method name | Parameters | Line |
|---|---|---|---|
| (constructor) | `APKUpdaterException` | `String message` | 5 |
| (constructor) | `APKUpdaterException` | `String message, Throwable cause` | 9 |

**Method annotations:** none

---

### File 2: APKUpdaterService.java

**Fully qualified class name:** `com.journaldev.spring.jdbc.service.APKUpdaterService`

**Extends:** (none — implicit `Object`)

**Implements:** (none)

**Class-level annotations:** `@Service`

**Fields:**

| Modifier | Type | Name | Annotation |
|---|---|---|---|
| private | `String` | `packageDir` | `@Value("${packageDir}")` |
| private | `Pattern` | `pattern` | (none) |

**Public methods:**

| Return type | Method name | Parameters | Line |
|---|---|---|---|
| `Optional<PackageEntry>` | `getAvailablePackage` | `String baseUrl, String pkgName, String currentVersion` | 28 |
| `Resource` | `loadPackageAsResource` | `String pkgname, String version` | 54 |

**Method annotations:** none on either method

**Imports of note:**
- `java.nio.file.Files`, `java.nio.file.Path`, `java.nio.file.Paths`
- `org.springframework.core.io.UrlResource`
- `java.util.regex.Pattern`, `java.util.regex.Matcher`
- `org.springframework.beans.factory.annotation.Value`
- `org.springframework.stereotype.Service`

---

### File 3: AWSFileStorageService.java

**Fully qualified class name:** `com.journaldev.spring.jdbc.service.AWSFileStorageService`

**Extends:** `com.journaldev.spring.jdbc.service.AbstractFileStorageService`

**Implements:** (indirectly `com.journaldev.spring.jdbc.service.FileStorageService` via parent)

**Class-level annotations:**
- `@Service("awsFileStorage")`
- `@Slf4j`

**Fields:**

| Modifier | Type | Name | Annotation |
|---|---|---|---|
| private | `String` | `cloudImagedDir` | `@Value("${cloudImagedDir}")` |
| private | `String` | `bucketName` | `@Value("${bucketName}")` |
| private static | `AWSCredentials` | `credentials` | (none — initialised inline with `new BasicAWSCredentials(...)`) |

**Public methods:**

| Return type | Method name | Parameters | Line |
|---|---|---|---|
| `String` | `saveImage` | `InputStream inputStream` | 38 |
| `Resource` | `loadImageAsResource` | `String fileName` | 45 |

**Method annotations:**
- `saveImage` — `@Override`
- `loadImageAsResource` — `@Override`

**Private methods:**

| Return type | Method name | Parameters | Line |
|---|---|---|---|
| `AmazonS3` | `connectAWSS3` | (none) | 50 |
| `void` | `uploadObject` | `String key_name, String file_path` | 62 |

**Imports of note:**
- `com.amazonaws.auth.AWSCredentials`
- `com.amazonaws.auth.AWSStaticCredentialsProvider`
- `com.amazonaws.auth.BasicAWSCredentials`
- `com.amazonaws.regions.Regions`
- `com.amazonaws.services.s3.model.CannedAccessControlList`
- `com.amazonaws.services.s3.model.PutObjectRequest`

---

## Step 4 — Checklist Review

### Section 1: Secrets and Configuration

**1.1 Hardcoded AWS credentials in source code — ISSUE (see B25-1)**

`AWSFileStorageService.java` line 31–34 initialises a `static` field with a literal AWS Access Key ID and Secret Access Key baked directly into source code:

```java
private static AWSCredentials credentials = new BasicAWSCredentials(
        "AKIA**REDACTED**",
        "****REDACTED****"
);
```

Both values are hard-coded string literals, not read from `@Value` properties or environment variables. Because the file is tracked in git, these credentials are permanently recorded in version-control history even if they are later removed from the file.

**1.2 Environment property files tracked in git — ISSUE (see B25-2)**

`.gitignore` contains only:
```
target/
out/
*.iml
*.class
.idea/
environment.local.properties
```

`environment.dev.properties`, `environment.prod.properties`, and `environment.uat.properties` are all tracked by git (confirmed: `git ls-files` returns all three). These files contain:
- `cognitoAPIUsername=ciiadmin` / `cognitoAPIPassword=ciiadmin` (all three environments)
- `bucketName=forkliftiq360` (infrastructure identifier, all three environments)
- Server hostnames and internal IP addresses

**1.3 Database credentials in pom.xml — ISSUE (see B25-3)**

`pom.xml` Maven profiles contain plaintext database credentials:
- `local` profile, line 29: `<flyway.password>gmtp-postgres</flyway.password>`; line 32: `<flyway.password>fleetiq360</flyway.password>`
- `uat` profile, line 76: `<flyway.user>dev_admin</flyway.user>`, line 77: `<flyway.password>C!1admin</flyway.password>`

`pom.xml` is tracked in git, exposing database credentials in version-control history.

**1.4 OAuth2 client secrets hardcoded in spring-security.xml — ISSUE (see B25-4)**

`spring-security.xml` lines 113–117 contain hardcoded OAuth2 client secrets in the in-memory `clientDetails` store:
- Client `987654321` secret: `8752361E593A573E86CA558FFD39E`
- Client `fleetiq360` secret: `rihah8eey4faibuengaixo6leiL1awii`

These are tracked in git.

**1.5 Cognito API password in properties files — ISSUE (see B25-2 — covered above)**

Already captured in B25-2. No separate finding required.

**1.6 pom.xml repository over plain HTTP — ISSUE (see B25-5)**

`pom.xml` line 88 defines a third-party Maven repository using plain HTTP:
```xml
<url>http://splunk.jfrog.io/splunk/ext-releases-local</url>
```
This allows a man-in-the-middle to substitute malicious artifacts during the build.

---

### Section 2: Authentication and Authorization

**2.1 APK endpoints accessible to ROLE_CLIENT only — CLEAR (but note)**

`spring-security.xml` line 31: `/rest/apk/**` requires `ROLE_CLIENT`. This restricts APK download and update-check to authenticated clients. Appropriate.

**2.2 OAuth client token with zero expiry — ISSUE (see B25-6)**

`spring-security.xml` line 114: client `987654321` has `access-token-validity="0"`. A value of `0` means non-expiring tokens. A non-expiring access token is a security risk — if a token is compromised it remains valid indefinitely.

**2.3 MD5 password hashing in authentication provider — ISSUE (see B25-7)**

`spring-security.xml` line 74: `<password-encoder hash="md5"/>`. MD5 is a broken hash function unsuitable for password storage. It is trivially reversible with rainbow tables and GPU attacks.

**2.4 No authentication required on `/oauth/cache_approvals` and `/oauth/uncache_approvals` — ISSUE (see B25-8)**

`spring-security.xml` lines 13–14:
```xml
<http pattern="/oauth/cache_approvals" security="none" ... />
<http pattern="/oauth/uncache_approvals" security="none" ... />
```
These endpoints are completely unauthenticated. A comment in the file reads "Just for testing...". If these endpoints are present in the production build they represent an unauthenticated attack surface.

---

### Section 3: Input Validation and Injection

**3.1 Path traversal in loadPackageAsResource — ISSUE (see B25-9)**

`APKUpdaterService.java` lines 55–56:

```java
Path filePath = Paths.get(packageDir).resolve(
    String.format("%s-%s.apk", pkgname, version));
```

`pkgname` and `version` come directly from `@PathVariable` and `@RequestParam` in `APKUpdaterController.java` lines 56–61, with no sanitisation:

```java
public ResponseEntity<Resource> downloadPackage(
        @PathVariable("pkgname") String pkgname,
        @RequestParam("version") String version) {
    Resource resource = apkUpdaterService.loadPackageAsResource(pkgname, version);
```

An attacker can supply `pkgname` or `version` values containing `../` sequences. On POSIX systems `Paths.get(packageDir).resolve("../../../etc/passwd-1.0.apk")` would resolve to `/etc/passwd-1.0.apk` (the `.apk` suffix is appended by `String.format` but the directory traversal still escapes `packageDir`). More practically, a value like `../../sensitive-file-` with version `suffix` could read arbitrary files accessible to the Tomcat process user. No call to `normalize()`, no prefix check, and no allowlist validation is present.

**3.2 Path traversal in getAvailablePackage — CLEAR**

`getAvailablePackage` calls `Files.list(Paths.get(packageDir))` which lists the fixed `packageDir` directory. The `pkgName` and `currentVersion` parameters are only used for comparison via the regex matcher and `PackageEntry.compareTo()`, not for constructing file paths. The regex pattern `(\\w*)-(\\d*\\.?\\d*?\\.?\\d*?\\.?-\\w*)\\.apk` applied to the *filename* (not user input) also restricts what filenames are processed.

**3.3 S3 key name sanitisation in AWSFileStorageService — ISSUE (see B25-10)**

`AWSFileStorageService.java` line 40:
```java
uploadObject(cloudImagedDir + fileName, targetLocation.toString());
```

`fileName` is generated by `AbstractFileStorageService.saveImage()` at line 65 of that class:
```java
this.fileName = this.imagePrefix + Util.generateRadomName() + this.imageExt;
```

The file extension `imageExt` is determined from the MIME type sniffed off the uploaded input stream (line 55–58 of `AbstractFileStorageService`). If MIME detection fails, the default `.jpg` is used. The S3 key name is therefore `cloudImagedDir + imagePrefix + random + extension`. Because `generateRadomName()` controls the random component and the extension is derived from server-side MIME detection, there is no direct user-controlled path component in the S3 key. However, the MIME type is sniffed using `URLConnection.guessContentTypeFromStream()`, which reads the first bytes of the stream supplied by the caller — the extension is therefore attacker-influenced. An attacker who uploads a file crafted to appear as an uncommon MIME type could manipulate the file extension placed in the S3 key. The risk here is low (it is an extension, not a key prefix), but it is noted.

**3.4 SSRF in APKUpdaterService — CLEAR**

`APKUpdaterService` does not make any outbound HTTP requests. It reads from a local filesystem directory (`packageDir`). No SSRF surface is present in the three assigned files.

**3.5 The `baseUrl` parameter in getAvailablePackage — NOTE**

`getAvailablePackage` accepts `baseUrl` as a parameter. This URL is constructed by the controller from `HttpServletRequest` (the incoming request's own URL), not from a user-supplied query parameter or request body. It is used only to construct the `PackageEntry.url` field returned in the JSON response. The URL is derived from `request.getRequestURL()`, which reflects the `Host` header. A client controlling the `Host` header could influence the `url` value in the response, causing a device to download an APK from a crafted server. This is noted as a Host header injection risk (see B25-11).

**3.6 SQL injection — N/A for assigned files**

No SQL operations are present in the three assigned files.

**3.7 Command injection — CLEAR**

No `Runtime.getRuntime().exec()` or `ProcessBuilder` usage in assigned files.

**3.8 XXE — N/A**

No XML parsing in assigned files.

**3.9 Deserialization — CLEAR**

No `ObjectInputStream` usage in assigned files.

---

### Section 4: Session and CSRF

**4.1 CSRF — N/A for assigned files**

CSRF is a concern at the security configuration level; no CSRF configuration is present in the assigned files. The `spring-security.xml` (read for context) uses OAuth2 bearer tokens via a stateless resource server (`create-session="never"`). CSRF protection is typically not applicable to stateless bearer-token APIs. No issue raised against assigned files.

**4.2 CORS — N/A for assigned files**

No `@CrossOrigin` annotations or CORS registry configuration in the assigned files.

**4.3 Security headers — N/A for assigned files**

Not configured in the assigned files.

---

### Section 5: Data Exposure

**5.1 Internal server path exposed in exception message — ISSUE (see B25-12)**

`APKUpdaterService.java` line 62:
```java
throw new FileNotFoundException("Unable to find " + pkgname + " , version " + version +
    " at location : " + filePath.toString() + " on server");
```

`filePath.toString()` includes the full absolute path on the server filesystem (e.g. `/var/local/tomcat8/upload/apk/myapp-1.0.apk`). This exception message propagates upward. If the caller (`APKUpdaterController.downloadPackage`) does not catch and sanitise it before returning a response body, the full filesystem path leaks to the API client. No exception handler wrapping this call is visible in `APKUpdaterController`; the `FileNotFoundException` is not caught there, meaning Spring will expose the exception message in an error response.

**5.2 S3 bucket name and file path logged at INFO — ISSUE (see B25-13)**

`AWSFileStorageService.java` line 63:
```java
log.info("Uploading  to S3 bucket key name:{}, file path:{}, bucket name: {}",
         key_name, file_path, bucketName);
```

The bucket name (`forkliftiq360`) and the full local filesystem path of the uploaded file are logged at `INFO` level. INFO-level log statements appear in production logs. This exposes S3 infrastructure identifiers and server filesystem layout in log aggregation systems (e.g. Splunk, which is configured in this project).

**5.3 S3 objects uploaded with PublicRead ACL — ISSUE (see B25-14)**

`AWSFileStorageService.java` line 73–74:
```java
s3client.putObject(
    new PutObjectRequest(bucketName, key_name, new File(file_path))
            .withCannedAcl(CannedAccessControlList.PublicRead));
```

Every uploaded image is set to `PublicRead`. This means all uploaded operator/forklift images are publicly accessible to anyone who knows (or guesses) the S3 object URL. There is no access-controlled download path — objects are world-readable directly from S3 without authentication. For a forklift management system storing operator identity images or site images, this is a data exposure concern.

**5.4 Operator/telemetry data exposure — N/A for assigned files**

No operator records, telemetry, or incident data handled in assigned files.

---

### Section 6: Dependencies

**6.1 Spring Framework 3.2.14.RELEASE — ISSUE (see B25-15)**

`pom.xml` line 13: `<org.springframework-version>3.2.14.RELEASE</org.springframework-version>`. Spring 3.2.x reached end-of-life in December 2016 and has not received security patches since then. Multiple CVEs affecting Spring 3.x exist (including CVE-2018-1270, CVE-2018-1271, CVE-2018-1272, CVE-2022-22965 "Spring4Shell" — Spring4Shell affects 5.x but the EOL status of 3.x means there are no backports for any post-2016 vulnerabilities).

**6.2 Spring Security 3.1.1.RELEASE — ISSUE (see B25-15)**

`pom.xml` line 232: `<version>3.1.1.RELEASE</version>`. Spring Security 3.1.x is deeply EOL. Known vulnerabilities include CVE-2014-0097 and others. The in-memory OAuth2 configuration (spring-security-oauth2 1.0.0.RELEASE, pom.xml line 241) is similarly ancient.

**6.3 Jackson-databind 2.6.7 — ISSUE (see B25-15)**

`pom.xml` line 100: `<version>2.6.7</version>`. Jackson 2.6.7 is affected by numerous deserialization CVEs including CVE-2017-7525, CVE-2018-7489, CVE-2019-14379, and many others due to the gadget-chain blacklist approach used in that era.

**6.4 commons-fileupload 1.3.1 — ISSUE (see B25-15)**

`pom.xml` line 201: `<version>1.3.1</version>`. CVE-2016-1000031 affects commons-fileupload < 1.3.3 (remote code execution via DiskFileItem deserialization).

**6.5 aws-java-sdk 1.11.163 — ISSUE (see B25-15)**

`pom.xml` line 271: `<version>1.11.163</version>`. Released in 2017. The current SDK is 1.12.x or 2.x. While not a specific CVE in the SDK itself, using an 8-year-old AWS SDK means missing security fixes and deprecated APIs. The `doesBucketExist` method used in the code has also been deprecated in favour of `doesBucketExistV2`.

**6.6 Third-party Maven repository over plain HTTP — ISSUE (see B25-5, already noted)**

See B25-5.

**6.7 junit 4.7 in non-test scope — CLEAR**

`pom.xml` line 226: `<scope>test</scope>` is correctly set.

**6.8 SNAPSHOT dependencies — CLEAR**

No SNAPSHOT versions found in `pom.xml`.

---

### Section 7: Build and CI

**7.1 No Bitbucket Pipelines file — N/A**

No `bitbucket-pipelines.yml` found in the repository. CI/CD pipeline security cannot be assessed.

**7.2 Test skipping — N/A**

No pipeline configuration found.

**7.3 Compiler warnings enabled — CLEAR**

`pom.xml` line 307: `-Xlint:all` is set, `showWarnings` and `showDeprecation` are `true`. This is positive.

---

## Findings

---

**B25-1** — CRITICAL
**Section:** 1. Secrets and Configuration
**File:** `src/main/java/com/journaldev/spring/jdbc/service/AWSFileStorageService.java:31`
**Description:** AWS IAM Access Key ID and Secret Access Key are hardcoded as static field initialisers in source code. The key ID prefix `AKIAJ` indicates a long-term IAM access key, not a temporary credential. Because this file is tracked in git, the credentials are permanently stored in version-control history and are accessible to anyone with read access to the repository. If the key has not already been revoked, it grants whoever holds it the ability to access the `forkliftiq360` S3 bucket and any other permissions attached to this IAM user.
**Evidence:**
```java
// AWSFileStorageService.java lines 31-34
private static AWSCredentials credentials = new BasicAWSCredentials(
        "AKIA**REDACTED**",
        "****REDACTED****"
);
```

---

**B25-2** — HIGH
**Section:** 1. Secrets and Configuration
**File:** `environment.dev.properties:15`, `environment.prod.properties:15`, `environment.uat.properties:15`
**Description:** Environment-specific property files containing credentials and infrastructure identifiers are tracked in git and not excluded by `.gitignore`. The files contain `cognitoAPIUsername` and `cognitoAPIPassword` for all three environments (dev, prod, uat), plus the S3 bucket name and server hostnames. The `.gitignore` excludes only `environment.local.properties`, leaving all other environment files tracked.
**Evidence:**
```
# .gitignore (line 6)
environment.local.properties   # only this variant is excluded

# environment.dev.properties (lines 15-16)
cognitoAPIUsername=ciiadmin
cognitoAPIPassword=ciiadmin

# environment.uat.properties (lines 15-16)
cognitoAPIUsername=ciiadmin
cognitoAPIPassword=ciiadmin
```

---

**B25-3** — HIGH
**Section:** 1. Secrets and Configuration
**File:** `pom.xml:29`, `pom.xml:32`, `pom.xml:76`, `pom.xml:77`
**Description:** Plaintext database credentials are committed in `pom.xml` Maven build profiles. The UAT profile contains a PostgreSQL password for `dev_admin` on an AWS RDS instance; the local profile contains passwords for the `fleetiq360` database user. `pom.xml` is tracked in git.
**Evidence:**
```xml
<!-- pom.xml local profile, lines 29-32 -->
<flyway.password>gmtp-postgres</flyway.password>
...
<flyway.password>fleetiq360</flyway.password>

<!-- pom.xml uat profile, lines 75-77 -->
<flyway.url>jdbc:postgresql://forkliftiq360.cmjwsurtk4tn.us-east-1.rds.amazonaws.com:5432/postgres</flyway.url>
<flyway.user>dev_admin</flyway.user>
<flyway.password>C!1admin</flyway.password>
```

---

**B25-4** — HIGH
**Section:** 1. Secrets and Configuration
**File:** `src/main/webapp/WEB-INF/spring/spring-security.xml:113`
**Description:** OAuth2 client secrets are hardcoded in plaintext in `spring-security.xml`, which is tracked in git. Both secrets are in the in-memory `clientDetails` store, meaning they are loaded from source at runtime. An attacker with repository read access can use these client secrets to obtain OAuth2 tokens.
**Evidence:**
```xml
<!-- spring-security.xml lines 113-117 -->
<oauth:client client-id="987654321"
              secret="8752361E593A573E86CA558FFD39E"
              authorities="ROLE_CLIENT" ... />

<oauth:client client-id="fleetiq360"
              secret="rihah8eey4faibuengaixo6leiL1awii"
              authorities="ROLE_DRIVER,ROLE_COMPANY_GROUP,ROLE_SYS_ADMIN" ... />
```

---

**B25-5** — MEDIUM
**Section:** 1. Secrets and Configuration / 6. Dependencies
**File:** `pom.xml:88`
**Description:** The Splunk Maven repository is configured with a plain HTTP URL. During a build, Maven will fetch JARs over an unencrypted channel, exposing the build to a man-in-the-middle attack that could substitute a malicious artifact.
**Evidence:**
```xml
<!-- pom.xml lines 87-90 -->
<repository>
    <id>splunk-artifactory</id>
    <name>Splunk Releases</name>
    <url>http://splunk.jfrog.io/splunk/ext-releases-local</url>
</repository>
```

---

**B25-6** — HIGH
**Section:** 2. Authentication and Authorization
**File:** `src/main/webapp/WEB-INF/spring/spring-security.xml:113`
**Description:** OAuth2 client `987654321` has `access-token-validity="0"`, which in Spring Security OAuth2 1.x means a non-expiring access token. If a token issued to this client is compromised (e.g., intercepted from a device, extracted from a database), it remains valid indefinitely. This client holds `ROLE_CLIENT` authority, which grants access to all `/rest/apk/**` endpoints.
**Evidence:**
```xml
<!-- spring-security.xml line 113 -->
<oauth:client client-id="987654321"
              authorized-grant-types="password,authorization_code,implicit"
              secret="8752361E593A573E86CA558FFD39E"
              authorities="ROLE_CLIENT"
              scope="read,write"
              access-token-validity="0"/>
```

---

**B25-7** — HIGH
**Section:** 2. Authentication and Authorization
**File:** `src/main/webapp/WEB-INF/spring/spring-security.xml:74`
**Description:** User passwords are hashed with MD5. MD5 is a cryptographically broken hash function with no salt, making stored passwords trivially recoverable via rainbow tables or GPU-based brute force. Any database breach immediately exposes all user passwords.
**Evidence:**
```xml
<!-- spring-security.xml line 74 -->
<password-encoder hash="md5"/>
```

---

**B25-8** — HIGH
**Section:** 2. Authentication and Authorization
**File:** `src/main/webapp/WEB-INF/spring/spring-security.xml:13`
**Description:** Two OAuth approval-management endpoints are configured with `security="none"` — fully unauthenticated — with an inline comment indicating they are "Just for testing". If these endpoints are present in production builds they expose unauthenticated manipulation of OAuth approval state.
**Evidence:**
```xml
<!-- spring-security.xml lines 12-14 -->
<!-- Just for testing... -->
<http pattern="/oauth/cache_approvals" security="none" ... />
<http pattern="/oauth/uncache_approvals" security="none" ... />
```

---

**B25-9** — HIGH
**Section:** 3. Input Validation and Injection
**File:** `src/main/java/com/journaldev/spring/jdbc/service/APKUpdaterService.java:55`
**Description:** Path traversal vulnerability in `loadPackageAsResource`. The `pkgname` and `version` parameters arrive from HTTP path/query variables with no sanitisation and are used to construct a filesystem path via `Paths.get(packageDir).resolve(String.format("%s-%s.apk", pkgname, version))`. No call to `normalize()` is made and no check verifies the resulting path stays within `packageDir`. An attacker supplying `pkgname` as `../../../etc/shadow` with `version` as `1.0-release` would construct the path `packageDir/../../../etc/shadow-1.0-release.apk`. While the `.apk` suffix is appended, on Linux the entire path before the suffix is traversed, potentially allowing reads of arbitrary files readable by the Tomcat process. The returned `UrlResource` is then served directly to the client.
**Evidence:**
```java
// APKUpdaterService.java lines 55-63
Path filePath = Paths.get(packageDir).resolve(
    String.format("%s-%s.apk", pkgname, version));

Resource resource = new UrlResource(filePath.toUri());
if(resource.exists()) {
    return resource;
} else {
    throw new FileNotFoundException("Unable to find " + pkgname +
        ", version " + version + " at location : " + filePath.toString() + " on server");
}

// APKUpdaterController.java lines 55-61 (caller — no sanitisation before call)
@RequestMapping(value = "/rest/apk/{pkgname}", method = RequestMethod.GET)
public ResponseEntity<Resource> downloadPackage(
        @PathVariable("pkgname") String pkgname,
        @RequestParam("version") String version) {
    Resource resource = apkUpdaterService.loadPackageAsResource(pkgname, version);
```

---

**B25-10** — LOW
**Section:** 3. Input Validation and Injection
**File:** `src/main/java/com/journaldev/spring/jdbc/service/AWSFileStorageService.java:40`
**Description:** The file extension embedded in the S3 key name is derived from MIME type detection (`URLConnection.guessContentTypeFromStream`) applied to the raw bytes of the uploaded stream. An attacker can craft a file whose initial bytes produce a MIME type that maps to a chosen extension, influencing the key name stored in S3. The risk is limited to the extension component (not the prefix), and the rest of the key is a random UUID-like string; however, it could be used to store files with unexpected extensions under the `cloudImagedDir` prefix.
**Evidence:**
```java
// AbstractFileStorageService.java lines 55-58
String contentType = URLConnection.guessContentTypeFromStream(inputStream);
MimeType imageType = MimeTypes.getDefaultMimeTypes().forName(contentType);
imageExt = imageType.getExtension();   // attacker-influenced

// AWSFileStorageService.java line 40
uploadObject(cloudImagedDir + fileName, targetLocation.toString());
// fileName = imagePrefix + random + imageExt
```

---

**B25-11** — MEDIUM
**Section:** 3. Input Validation and Injection
**File:** `src/main/java/com/journaldev/spring/jdbc/controller/APKUpdaterController.java:28`
**Description:** The `baseUrl` passed to `getAvailablePackage` is constructed from `request.getRequestURL()`, which reflects the HTTP `Host` header. The resulting URL is embedded in the `PackageEntry.url` field returned as JSON to Android clients. A man-in-the-middle or a spoofed server response with a crafted `Host` header could redirect Android devices to download APK updates from an attacker-controlled server. No `Host` header validation or server-side whitelisting of the base URL is performed.
**Evidence:**
```java
// APKUpdaterController.java lines 28-33
private String getURLBase(HttpServletRequest request, String pkgName) throws MalformedURLException {
    URL requestURL = new URL(request.getRequestURL().toString());
    String port = requestURL.getPort() == -1 ? "" : ":" + requestURL.getPort();
    return requestURL.getProtocol() + "://" + requestURL.getHost() + port +
           StringUtils.substringBefore(requestURL.getPath(), "/" + pkgName + "/update");
}

// PackageEntry.java line 33
this.url = String.format("%s/%s?version=%s", baseUrl, name, version);
```

---

**B25-12** — MEDIUM
**Section:** 5. Data Exposure
**File:** `src/main/java/com/journaldev/spring/jdbc/service/APKUpdaterService.java:62`
**Description:** When a requested APK file is not found, the exception message includes the full absolute filesystem path of the expected file location. This exception is not caught in `APKUpdaterController.downloadPackage` and will propagate as an error response, leaking the server's internal directory structure (e.g. `/var/local/tomcat8/upload/apk/`) to API clients.
**Evidence:**
```java
// APKUpdaterService.java line 62
throw new FileNotFoundException("Unable to find " + pkgname +
    ", version " + version + " at location : " + filePath.toString() + " on server");
```

---

**B25-13** — LOW
**Section:** 5. Data Exposure
**File:** `src/main/java/com/journaldev/spring/jdbc/service/AWSFileStorageService.java:63`
**Description:** The S3 bucket name and full local filesystem path of every uploaded file are written to the log at INFO level. In production environments these logs are shipped to Splunk. This exposes S3 infrastructure identifiers and the server's upload directory layout in log aggregation systems, increasing the value of a log compromise.
**Evidence:**
```java
// AWSFileStorageService.java line 63
log.info("Uploading  to S3 bucket key name:{}, file path:{}, bucket name: {}",
         key_name, file_path, bucketName);
```

---

**B25-14** — HIGH
**Section:** 5. Data Exposure
**File:** `src/main/java/com/journaldev/spring/jdbc/service/AWSFileStorageService.java:72`
**Description:** Every object uploaded to S3 is set to `CannedAccessControlList.PublicRead`, making all uploaded images world-readable directly from S3 without any authentication. For a forklift management system this may include operator identity images, site images, or other sensitive operational data. There is no access-controlled download path through the application — any party who discovers an object URL (or enumerates the bucket) can retrieve these files.
**Evidence:**
```java
// AWSFileStorageService.java lines 72-74
s3client.putObject(
    new PutObjectRequest(bucketName, key_name, new File(file_path))
            .withCannedAcl(CannedAccessControlList.PublicRead));
```

---

**B25-15** — HIGH
**Section:** 6. Dependencies
**File:** `pom.xml:13`, `pom.xml:100`, `pom.xml:201`, `pom.xml:230`, `pom.xml:240`
**Description:** Multiple severely outdated dependencies with known CVEs are in use. Key issues:

| Dependency | Version in use | Issue |
|---|---|---|
| `org.springframework` | 3.2.14.RELEASE | EOL since Dec 2016; no security patches for any post-2016 CVEs |
| `spring-security-web/config` | 3.1.1.RELEASE | EOL; CVE-2014-0097 and others |
| `spring-security-oauth2` | 1.0.0.RELEASE | EOL; multiple CVEs in OAuth2 token handling |
| `jackson-databind` | 2.6.7 | CVE-2017-7525, CVE-2018-7489, CVE-2019-14379 and many others |
| `commons-fileupload` | 1.3.1 | CVE-2016-1000031 (RCE via DiskFileItem deserialization) |
| `aws-java-sdk` | 1.11.163 (2017) | 8 years old; deprecated APIs in use (`doesBucketExist`) |

**Evidence:**
```xml
<!-- pom.xml -->
<org.springframework-version>3.2.14.RELEASE</org.springframework-version>       <!-- line 13 -->
<jackson.databind-version>2.6.7</jackson.databind-version>                       <!-- line 15 -->
<version>1.3.1</version>  <!-- commons-fileupload -->                             <!-- line 201 -->
<version>3.1.1.RELEASE</version>  <!-- spring-security -->                        <!-- line 232 -->
<version>1.0.0.RELEASE</version>  <!-- spring-security-oauth2 -->                 <!-- line 241 -->
<version>1.11.163</version>  <!-- aws-java-sdk -->                                 <!-- line 271 -->
```

---

## Summary Table

| ID | Severity | Section | Description |
|---|---|---|---|
| B25-1 | CRITICAL | 1. Secrets | AWS IAM key hardcoded in source (AWSFileStorageService.java) |
| B25-2 | HIGH | 1. Secrets | Environment property files with credentials tracked in git |
| B25-3 | HIGH | 1. Secrets | Database passwords in pom.xml tracked in git |
| B25-4 | HIGH | 1. Secrets | OAuth2 client secrets hardcoded in spring-security.xml |
| B25-5 | MEDIUM | 1. Secrets / 6. Deps | Splunk Maven repository uses plain HTTP |
| B25-6 | HIGH | 2. Auth/Authz | OAuth2 client with non-expiring access token (validity=0) |
| B25-7 | HIGH | 2. Auth/Authz | MD5 password hashing configured in authentication provider |
| B25-8 | HIGH | 2. Auth/Authz | OAuth approval endpoints unauthenticated ("Just for testing") |
| B25-9 | HIGH | 3. Injection | Path traversal in loadPackageAsResource — unsanitised pkgname/version |
| B25-10 | LOW | 3. Injection | S3 key extension influenced by attacker-controlled MIME bytes |
| B25-11 | MEDIUM | 3. Injection | Host header injection in APK update URL construction |
| B25-12 | MEDIUM | 5. Data Exposure | Full filesystem path leaked in FileNotFoundException message |
| B25-13 | LOW | 5. Data Exposure | S3 bucket name and local file path logged at INFO level |
| B25-14 | HIGH | 5. Data Exposure | All S3 uploads set to PublicRead — no authenticated access control |
| B25-15 | HIGH | 6. Dependencies | Multiple severely EOL/CVE-affected dependencies (Spring 3.x, Jackson 2.6.7, commons-fileupload 1.3.1, etc.) |
