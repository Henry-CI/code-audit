# Audit Report — B20
**Agent:** B20
**Pass:** 1 (Security Review)
**Date:** 2026-02-27
**Repo:** forkliftiqws
**Branch:** master
**Assigned files:**
- `src/main/java/com/journaldev/spring/jdbc/model/OfflineSessions.java`
- `src/main/java/com/journaldev/spring/jdbc/model/PackageEntry.java`
- `src/main/java/com/journaldev/spring/jdbc/model/Permissions.java`

---

## Reading Evidence

### 1. `com.journaldev.spring.jdbc.model.OfflineSessions`

**Fully qualified class name:** `com.journaldev.spring.jdbc.model.OfflineSessions`

**Interfaces implemented:** `java.io.Serializable`

**Class-level annotations:** none

**Fields:**
- `private static final long serialVersionUID = -8930449759197168463L`
- `private Sessions sessions`
- `private Result results`

**Public methods:**

| Line | Return type | Method signature | Annotations |
|------|-------------|------------------|-------------|
| 14 | `Sessions` | `getSessions()` | none |
| 17 | `void` | `setSessions(Sessions sessions)` | none |
| 20 | `Result` | `getResults()` | none |
| 23 | `void` | `setResults(Result results)` | none |

**Extends:** none (implicitly `Object`)

---

### 2. `com.journaldev.spring.jdbc.model.PackageEntry`

**Fully qualified class name:** `com.journaldev.spring.jdbc.model.PackageEntry`

**Interfaces implemented:** `java.lang.Comparable<PackageEntry>`

**Class-level annotations:** `@Data`, `@NoArgsConstructor`

**Fields:**

| Modifier | Type | Name |
|----------|------|------|
| (package/Lombok-generated) | `String` | `name` |
| (package/Lombok-generated) | `String` | `fileName` |
| (package/Lombok-generated) | `String` | `url` |
| (package/Lombok-generated) | `int` | `major` |
| (package/Lombok-generated) | `int` | `minor` |
| (package/Lombok-generated) | `int` | `patch` |
| (package/Lombok-generated) | `String` | `env` |
| `@JsonIgnore` | `Pattern` | `pattern` |

**Methods:**

| Line | Return type | Method signature | Annotations |
|------|-------------|------------------|-------------|
| 29 | — (constructor) | `private PackageEntry(String fileName, String name, String version, String baseUrl)` | `@Builder` |
| 36 | `void` | `private initVersion(String version)` | none |
| 57 | `int` | `compareTo(PackageEntry o)` | `@Override` |

Lombok `@Data` generates: `getXxx()`, `setXxx()`, `equals()`, `hashCode()`, `toString()` for all non-static fields.

**Imports (relevant):** `com.fasterxml.jackson.annotation.JsonIgnore`, `lombok.Builder`, `lombok.Data`, `lombok.NoArgsConstructor`, `org.apache.commons.lang3.StringUtils`, `org.apache.commons.lang3.builder.CompareToBuilder`, `java.util.regex.Matcher`, `java.util.regex.Pattern`

---

### 3. `com.journaldev.spring.jdbc.model.Permissions`

**Fully qualified class name:** `com.journaldev.spring.jdbc.model.Permissions`

**Interfaces implemented:** `java.io.Serializable`

**Class-level annotations:** `@Data`, `@NoArgsConstructor`, `@EqualsAndHashCode(onlyExplicitlyIncluded = true)`

**Fields:**

| Modifier | Type | Name | Field annotations |
|----------|------|------|-------------------|
| (Lombok) | `Long` | `id` | none |
| (Lombok) | `Long` | `driver_id` | `@EqualsAndHashCode.Include` |
| (Lombok) | `String` | `driver_name` | none |
| (Lombok) | `Long` | `comp_id` | `@EqualsAndHashCode.Include` |
| (Lombok) | `String` | `enabled` | none |
| (Lombok) | `String` | `gsm_token` | none |
| `private static final` | `long` | `serialVersionUID = 1871252602934566751L` | none |

**Methods:**

| Line | Return type | Method signature | Annotations |
|------|-------------|------------------|-------------|
| 31 | — (constructor) | `private Permissions(Long id, Long driver_id, String driver_name, Long comp_id, String enabled, String gsm_token)` | `@Builder` |

Lombok `@Data` generates: `getId()`, `setId()`, `getDriver_id()`, `setDriver_id()`, `getDriver_name()`, `setDriver_name()`, `getComp_id()`, `setComp_id()`, `getEnabled()`, `setEnabled()`, `getGsm_token()`, `setGsm_token()`, `toString()`, and `equals()`/`hashCode()` limited to `driver_id` + `comp_id` per `@EqualsAndHashCode`.

---

## Checklist Review

### Section 1 — Secrets and Configuration

**Checked in support of this review:**
- `fleetiq360ws.properties` — uses `${...}` placeholder substitution for sensitive values (`imageURL`, `uploadDir`, `packageDir`, `cognitoAPIPort`, `cognitoAPIUsername`, `cognitoAPIPassword`, `bucketName`). No literal credential values committed.
- `acceptURL` on line 10 of `fleetiq360ws.properties` is a hardcoded production URL (`https://pandora.fleetiq360.com/pandora/acceptDriver?token=`). This is a URL rather than a credential, so it is a low-severity infrastructure disclosure rather than a secret exposure. Flagged below.
- `spring-security.xml` — hardcoded OAuth2 client credentials in the `<oauth:client-details-service>` block (lines 113–117). This is a critical finding beyond B20's three assigned model files, noted here for completeness; it will be covered by the controller/config auditor.

**Finding for B20 scope:** The `acceptURL` property is within scope of Section 1 as it is in the properties file that configures model-layer behaviour. The hardcoded production hostname reveals infrastructure topology.

CLEAR for the three assigned model files themselves.

---

### Section 2 — Authentication and Authorization

**Permissions model — role definition soundness:**

The `Permissions` model does not represent Spring Security roles. It is an application-level join-table model linking `driver_id` to `comp_id` with an `enabled` flag and a `gsm_token` (FCM/GCM push token). Role definitions reside in `spring-security.xml` and the `Roles` model.

The `enabled` field on `Permissions` is typed as `String` rather than `Boolean`. If downstream comparison code uses string equality checks (e.g. `"true"`, `"false"`, `"1"`, `"0"`), a malformed or unexpected value could lead to indeterminate authorisation state. See B20-1.

**Wildcard / privilege escalation risk:**

There is no wildcard permission field in the `Permissions` model itself. However, the `addCompany` endpoint in `CompanyController` accepts a `Permissions` object as a `@RequestBody` and uses `permission.getGsm_token()` directly from caller input when inserting a new permission row (`gsm_token` is written to the database without sanitisation). The `gsm_token` field in `Permissions` is caller-controlled in the create flow. See B20-2.

The `companyAccept` endpoint (`PUT /rest/company/accept/{pid}`) enables a permission row by its numeric `pid` with no check that the authenticated user owns or is the target of that permission. This is an IDOR vulnerability exposing the `Permissions` model's `enabled` flag. See B20-3.

The `companyDelete` endpoint (`DELETE /rest/company/delete/{pid}`) similarly deletes any permission row by numeric `pid` without ownership verification. See B20-4.

---

### Section 3 — Input Validation and Injection

**Deserialization — @JsonTypeInfo:**

None of the three assigned model classes use `@JsonTypeInfo`. No default typing annotation is present. CLEAR for deserialization on these files.

**Input validation on model fields:**

None of the three model classes carry JSR-303/Bean Validation constraints (`@NotNull`, `@Size`, `@Pattern`, `@Min`, `@Max`). The `Permissions` model accepts arbitrary string values for `enabled` and `gsm_token`. The `PackageEntry` model does not validate `url`, `name`, or `fileName`. See B20-5.

**Path traversal in PackageEntry / APKUpdaterService:**

`PackageEntry.fileName` is constructed from filenames read from the filesystem by `APKUpdaterService.getAvailablePackage()`, so server-side traversal from that field is not possible. However, `APKUpdaterService.loadPackageAsResource()` takes the user-supplied `pkgname` and `version` parameters from the HTTP request and passes them directly into `Paths.get(packageDir).resolve(String.format("%s-%s.apk", pkgname, version))`. This `resolve()` call will follow a relative path segment. If `pkgname` or `version` contains `../` sequences, the resolved path can escape `packageDir` and serve arbitrary files from the server filesystem. The `PackageEntry` model does not constrain or validate these fields. See B20-6.

**URL construction in PackageEntry:**

The `url` field is constructed in the `@Builder` constructor as:
```java
this.url = String.format("%s/%s?version=%s", baseUrl, name, version);
```
The `baseUrl` is derived from the incoming HTTP request's `Host` header by `APKUpdaterController.getURLBase()`. A caller who controls the `Host` header can inject an arbitrary base URL into the `PackageEntry.url` field that is returned in the API response. If a mobile client uses this URL to fetch the APK, this enables a Host-header injection / open redirect attack that could direct clients to a malicious download server. See B20-7.

---

### Section 4 — Session and CSRF

N/A for model classes. `spring-security.xml` is not assigned to B20; however, noted that `create-session="never"` is set on the `/rest/**` block (stateless OAuth2), which is appropriate.

---

### Section 5 — Data Exposure

**Permissions model — gsm_token exposed in API responses:**

The `Permissions` class has no `@JsonIgnore` on any field. Lombok `@Data` generates getters for all fields including `gsm_token`. The `gsm_token` field stores a Firebase/GCM push notification registration token that identifies a specific mobile device. This token is:

1. Included in the `Permissions` object embedded in `Company` objects returned by `CompanyDAO.findAllByDriverId()` → `CompanyController.getCompany()`.
2. Sent as part of the `GCMDataPermission` push notification wrapper.
3. Accepted as caller-supplied input via `addCompany` and written directly to the database.

Exposing `gsm_token` in API responses allows any authenticated caller who can retrieve company data to harvest device push tokens for all drivers associated with a company. A `gsm_token` can be used to send arbitrary push notifications to that device using the FCM API. See B20-8.

**PackageEntry — `url` and `env` fields:**

`PackageEntry.url` exposes the full download URL including the internal `baseUrl` derived from the server's own request URL. This reveals the internal server hostname/port in API responses. The `env` field (parsed from the APK filename, e.g. `prod`, `staging`, `dev`) reveals the deployment environment classification of each package. See B20-9.

**PackageEntry — `fileName` exposed:**

The `fileName` field (the actual filename on the server filesystem, e.g. `app-1.2.3-prod.apk`) is returned in API responses. Combined with `env`, this assists an attacker in enumerating APK naming conventions and targeting specific file versions. CLEAR for critical sensitivity, flagged as INFO.

**Permissions model — `enabled` field as String:**

The `enabled` field is typed as `String` rather than `Boolean`. When serialised to JSON, it emits its raw database string value (e.g. `"true"`, `"false"`, `"t"`, `"f"` depending on PostgreSQL driver behaviour). This could expose unexpected values and is inconsistent across client implementations. See B20-1 (also relevant here).

**Error responses:**

`APKUpdaterController.getAvailablePackage()` (line 49) returns `null` on `MalformedURLException`. Spring MVC will serialise `null` to an empty body with HTTP 200, giving no indication of the error. The `TODO Handle error` comment confirms this is unfinished. While this is not a direct data exposure issue, the absence of error handling means the calling client cannot distinguish between "no update available" and "server error". Not a security finding; noted as INFO.

`APKUpdaterService.loadPackageAsResource()` (line 62) throws a custom `FileNotFoundException` with a message that includes the full server filesystem path: `"Unable to find " + pkgname + ", version " + version + " at location : " + filePath.toString() + " on server"`. If this exception propagates to the client (depends on exception handler configuration), it discloses the `packageDir` value and the full absolute filesystem path. See B20-10.

---

### Section 6 — Dependencies

N/A (model classes only; `pom.xml` is not assigned to B20).

---

### Section 7 — Build and CI

N/A (model classes only).

---

## Findings

---

**B20-1** — MEDIUM
**Section:** 2 (Authentication and Authorization) / 5 (Data Exposure)
**File:** `src/main/java/com/journaldev/spring/jdbc/model/Permissions.java:27`
**Description:** The `enabled` field, which controls whether a driver-company permission link is active, is typed as `String` rather than `Boolean`. Boolean semantics are critical here: if the field receives an unexpected value (e.g. `"t"`, `"1"`, null, empty string), downstream authorisation checks that compare this string may behave incorrectly and either grant or deny access unintentionally. The `spring-security.xml` filter chain does not protect individual permission-scoped resources; authorisation of resource access at the permission level is delegated to application logic that reads this field.
**Evidence:**
```java
// Permissions.java line 27
private String enabled;
```
Used in SQL insert at `CompanyController.java:75`:
```java
"insert into permission (id,driver_id, comp_id,gsm_token,createdat,enabled) values (?,?,?,?,now(),false)"
```
And mapped back from DB at `CompanyDAO.java:179`:
```java
.enabled(rs.getString("permission_enable"))
```

---

**B20-2** — MEDIUM
**Section:** 2 (Authentication and Authorization)
**File:** `src/main/java/com/journaldev/spring/jdbc/model/Permissions.java:29` / `src/main/java/com/journaldev/spring/jdbc/controller/CompanyController.java:76`
**Description:** The `gsm_token` field in `Permissions` is accepted as caller-supplied input in the `addCompany` request body and is written to the database without validation or sanitisation. An authenticated attacker can register an arbitrary string (including a token from a device they control) as another driver's `gsm_token`, then receive push notifications intended for that driver. The `Permissions` model places no constraints on this field.
**Evidence:**
```java
// Permissions.java line 29
private String gsm_token;

// CompanyController.java line 62-76
public @ResponseBody ResponseEntity<Permissions> addCompany(@RequestBody Permissions permission) {
    ...
    query = "insert into permission (id,driver_id, comp_id,gsm_token,createdat,enabled) values (?,?,?,?,now(),false)";
    jdbcTemplate.update(query, new Object[] {id, permission.getDriver_id(), permission.getComp_id(), permission.getGsm_token()});
```

---

**B20-3** — HIGH
**Section:** 2 (Authentication and Authorization)
**File:** `src/main/java/com/journaldev/spring/jdbc/controller/CompanyController.java:148-158`
**Description:** The `companyAccept` endpoint (`PUT /rest/company/accept/{pid}`) sets `enabled = true` for any permission row identified by the caller-supplied `pid`. There is no check that the authenticated user is the company owner or the intended recipient of the permission request. Any authenticated driver (ROLE_DRIVER) can enable any permission row, including rows for companies they do not own, by enumerating `pid` values. This allows a driver to grant themselves or any other driver access to any company.
**Evidence:**
```java
// CompanyController.java lines 147-158
@RequestMapping(value= RestURIConstants.COMPANY_ACCEPT, method=RequestMethod.PUT)
public @ResponseBody ResponseEntity<Results> companyAccept( @PathVariable("pid") int pid) {
    ...
    String query = "update permission set enabled = true, updatedat = now() where id = ?";
    jdbcTemplate.update(query, new Object[] {pid});
    results.setMessage_id(RuntimeConfig.MSGID_SUCCESS);
    return new ResponseEntity<Results>(results, HttpStatus.OK);
}
```
Note: `COMPANY_ACCEPT = "/rest/company/accept/{pid}"` is protected by `ROLE_DRIVER,ROLE_COMPANY_GROUP,ROLE_SYS_ADMIN,ROLE_CLIENT` per `spring-security.xml:32`. Any of those roles can exploit this.

---

**B20-4** — HIGH
**Section:** 2 (Authentication and Authorization)
**File:** `src/main/java/com/journaldev/spring/jdbc/controller/CompanyController.java:162-174`
**Description:** The `companyDelete` endpoint (`PUT /rest/company/delete/{pid}`) deletes any permission row by caller-supplied `pid` with no ownership check. Any authenticated driver can remove the permission record of any other driver from any company by enumerating `pid` values. This can be used to revoke legitimate drivers' access across the entire platform.
**Evidence:**
```java
// CompanyController.java lines 162-174
@RequestMapping(value= RestURIConstants.COMPANY_DELETE, method=RequestMethod.PUT)
public @ResponseBody ResponseEntity<Results> companyDelete( @PathVariable("pid") int pid) {
    ...
    String query = "delete from permission where id = ?";
    jdbcTemplate.update(query, new Object[] {pid});
    results.setMessage_id(RuntimeConfig.MSGID_SUCCESS);
    return new ResponseEntity<Results>(results, HttpStatus.OK);
}
```

---

**B20-5** — MEDIUM
**Section:** 3 (Input Validation and Injection)
**File:** `src/main/java/com/journaldev/spring/jdbc/model/Permissions.java` / `src/main/java/com/journaldev/spring/jdbc/model/PackageEntry.java`
**Description:** Neither model class carries any JSR-303/Bean Validation constraints. `Permissions` fields `driver_id`, `comp_id`, `enabled`, and `gsm_token` are all unconstrained — no `@NotNull`, `@Size`, `@Pattern`, or range annotations. `PackageEntry` fields `name`, `fileName`, `url`, and `env` are similarly unconstrained. Controllers using these models as `@RequestBody` do not use `@Valid`, so Spring does not invoke validation. Any values, including nulls, overlong strings, or unexpected characters, are accepted.
**Evidence:**
```java
// Permissions.java — no constraints on any field
private Long id;
private Long driver_id;
private String driver_name;
private Long comp_id;
private String enabled;
private String gsm_token;

// CompanyController.java:62 — no @Valid annotation
public @ResponseBody ResponseEntity<Permissions> addCompany(@RequestBody Permissions permission)
```

---

**B20-6** — HIGH
**Section:** 3 (Input Validation and Injection)
**File:** `src/main/java/com/journaldev/spring/jdbc/service/APKUpdaterService.java:56` (supporting context for `PackageEntry`)
**Description:** `APKUpdaterService.loadPackageAsResource()` constructs a filesystem path using caller-supplied `pkgname` and `version` path variables via `Paths.get(packageDir).resolve(...)`. `Path.resolve()` with a relative path that begins with `../` will resolve outside of `packageDir`. An attacker can request `GET /rest/apk/../../../etc/passwd?version=1.0.0-prod` (URL-encoded as needed) to traverse the filesystem. The `PackageEntry` model does not define or enforce any naming constraints that would prevent this. No canonicalisation or prefix-check is performed before the `UrlResource` is returned.
**Evidence:**
```java
// APKUpdaterService.java lines 54-67
public Resource loadPackageAsResource(String pkgname, String version) {
    try {
        Path filePath = Paths.get(packageDir).resolve(String.format("%s-%s.apk", pkgname, version));
        Resource resource = new UrlResource(filePath.toUri());
        if(resource.exists()) {
            return resource;
        } else {
            throw new FileNotFoundException("Unable to find " + pkgname + ", version " + version
                + " at location : " + filePath.toString() + " on server");
        }
    } catch (IOException e) { ... }
}

// APKUpdaterController.java lines 55-68
@RequestMapping(value = "/rest/apk/{pkgname}", method = RequestMethod.GET)
public ResponseEntity<Resource> downloadPackage(@PathVariable("pkgname") String pkgname,
                                                @RequestParam("version") String version)
```

---

**B20-7** — MEDIUM
**Section:** 3 (Input Validation and Injection) / 5 (Data Exposure)
**File:** `src/main/java/com/journaldev/spring/jdbc/model/PackageEntry.java:33` / `src/main/java/com/journaldev/spring/jdbc/controller/APKUpdaterController.java:30-32`
**Description:** The `PackageEntry.url` field is constructed using a `baseUrl` derived from the incoming HTTP request's `Host` header (via `request.getRequestURL()`). If an attacker sends a crafted `Host` header (e.g. `Host: evil.example.com`), the `url` returned in the `PackageEntry` JSON response will point to the attacker's server. Mobile clients that automatically follow this URL to download APK updates would be redirected to download from an attacker-controlled location. This is a Host-header injection vulnerability.
**Evidence:**
```java
// APKUpdaterController.java lines 28-33
private String getURLBase(HttpServletRequest request, String pkgName) throws MalformedURLException {
    URL requestURL = new URL(request.getRequestURL().toString());
    String port = requestURL.getPort() == -1 ? "" : ":" + requestURL.getPort();
    return requestURL.getProtocol() + "://" + requestURL.getHost() + port + ...;
}

// PackageEntry.java line 33
this.url = String.format("%s/%s?version=%s", baseUrl, name, version);
```

---

**B20-8** — HIGH
**Section:** 5 (Data Exposure)
**File:** `src/main/java/com/journaldev/spring/jdbc/model/Permissions.java:29`
**Description:** The `gsm_token` field (FCM/GCM push notification device registration token) is not annotated with `@JsonIgnore`. Lombok `@Data` generates a public `getGsm_token()` getter, so the token is serialised into every JSON response that includes a `Permissions` object. This occurs in `CompanyController.getCompany()` (returns `List<Company>` where each `Company` embeds a `Permissions`) and in `GCMDataPermission` push notification payloads. Any authenticated user who can call `GET /rest/company/get/{uid}` can harvest push tokens for all drivers in that company. A harvested FCM token can be used to send arbitrary push notifications to the target device via the Firebase API.
**Evidence:**
```java
// Permissions.java lines 29 — no @JsonIgnore
private String gsm_token;

// CompanyDAO.java lines 55 — gsm_token selected in base query
"p.id as permission_id, p.enabled as permission_enable, p.gsm_token "

// CompanyDAO.java lines 174-180 — mapped into Permissions object returned in Company
Permissions permissions = Permissions.builder()
    ...
    .gsm_token(rs.getString("gsm_token")).build();

// Company.java line 25 — Permissions embedded in Company response
private Permissions permission;
```

---

**B20-9** — LOW
**Section:** 5 (Data Exposure)
**File:** `src/main/java/com/journaldev/spring/jdbc/model/PackageEntry.java:23`
**Description:** The `env` field of `PackageEntry` is parsed from the APK filename and returned in API responses without restriction. It exposes the deployment environment label (e.g. `prod`, `staging`, `dev`) to any authenticated client. Combined with the `fileName` field, this reveals the internal APK versioning and naming scheme and may facilitate targeted attacks against specific environment variants of the application.
**Evidence:**
```java
// PackageEntry.java lines 17-24
private String name;
private String fileName;
private String url;
private int major;
private int minor;
private int patch;
private String env;
// No @JsonIgnore on env or fileName
```

---

**B20-10** — MEDIUM
**Section:** 5 (Data Exposure)
**File:** `src/main/java/com/journaldev/spring/jdbc/service/APKUpdaterService.java:62`
**Description:** When a requested package file is not found, the exception message includes the full server-side filesystem path: `"Unable to find " + pkgname + ", version " + version + " at location : " + filePath.toString() + " on server"`. If this exception is not caught and swallowed by a global exception handler before reaching the HTTP response, the `packageDir` absolute path and the resolved filename are disclosed to the caller. This is referenced in the context of `PackageEntry` because it reveals the storage location of APK assets.
**Evidence:**
```java
// APKUpdaterService.java lines 60-63
throw new FileNotFoundException("Unable to find " + pkgname + ", version " + version
    + " at location : " + filePath.toString() + " on server");
```

---

## Summary Table

| ID | Severity | Section | Short description |
|----|----------|---------|-------------------|
| B20-1 | MEDIUM | 2, 5 | `enabled` field typed as String — indeterminate boolean semantics |
| B20-2 | MEDIUM | 2 | Caller-controlled `gsm_token` written to DB without validation |
| B20-3 | HIGH | 2 | IDOR: any authenticated user can enable any permission record by pid |
| B20-4 | HIGH | 2 | IDOR: any authenticated user can delete any permission record by pid |
| B20-5 | MEDIUM | 3 | No Bean Validation constraints on Permissions or PackageEntry fields |
| B20-6 | HIGH | 3 | Path traversal via user-supplied pkgname/version in APK download endpoint |
| B20-7 | MEDIUM | 3, 5 | Host-header injection populates PackageEntry.url returned to clients |
| B20-8 | HIGH | 5 | gsm_token (FCM device token) exposed in API responses — no @JsonIgnore |
| B20-9 | LOW | 5 | `env` and `fileName` fields disclose deployment environment and naming scheme |
| B20-10 | MEDIUM | 5 | Full server filesystem path disclosed in exception message |
