# Audit Report — Agent B21 — Pass 1 (Security Review)
**Date:** 2026-02-27
**Repo:** forkliftiqws (branch: master)
**Agent:** B21
**Files assigned:**
- `src/main/java/com/journaldev/spring/jdbc/model/Questions.java`
- `src/main/java/com/journaldev/spring/jdbc/model/ReportLists.java`
- `src/main/java/com/journaldev/spring/jdbc/model/Reports.java`

---

## Reading Evidence

---

### File 1: `src/main/java/com/journaldev/spring/jdbc/model/Questions.java`

**Fully qualified class name:** `com.journaldev.spring.jdbc.model.Questions`

**Interfaces implemented:** `java.io.Serializable`

**Class extended:** none

**Class-level annotations:** none

**Fields:**

| Modifier  | Type   | Name                | Line |
|-----------|--------|---------------------|------|
| private static final | long | serialVersionUID | 10 |
| private   | int    | id                  | 12   |
| private   | String | content             | 13   |
| private   | String | expectedanswer      | 14   |

**Public methods:**

| Return type | Method signature          | Line |
|-------------|---------------------------|------|
| int         | `getId()`                 | 17   |
| void        | `setId(int id)`           | 20   |
| String      | `getContent()`            | 23   |
| void        | `setContent(String content)` | 26 |
| String      | `getExpectedanswer()`     | 29   |
| void        | `setExpectedanswer(String expectedanswer)` | 32 |

**Method-level annotations:** none

---

### File 2: `src/main/java/com/journaldev/spring/jdbc/model/ReportLists.java`

**Fully qualified class name:** `com.journaldev.spring.jdbc.model.ReportLists`

**Interfaces implemented:** `java.io.Serializable`

**Class extended:** none

**Class-level annotations:** none

**Fields:**

| Modifier  | Type   | Name           | Line |
|-----------|--------|----------------|------|
| private static final | long | serialVersionUID | 11 |
| private   | int    | id             | 13   |
| private   | String | name           | 14   |
| private   | String | file_name      | 15   |
| private   | String | frequency      | 16   |
| private   | int    | comp_id        | 17   |

**Comment at line 10:** `// subscription table`

**Public methods:**

| Return type | Method signature                    | Line |
|-------------|-------------------------------------|------|
| int         | `getComp_id()`                      | 19   |
| void        | `setComp_id(int comp_id)`           | 22   |
| String      | `getFrequency()`                    | 25   |
| void        | `setFrequency(String frequency)`    | 28   |
| String      | `getFile_name()`                    | 31   |
| void        | `setFile_name(String file_name)`    | 34   |
| int         | `getId()`                           | 37   |
| void        | `setId(int id)`                     | 40   |
| String      | `getName()`                         | 43   |
| void        | `setName(String name)`              | 46   |

**Method-level annotations:** none

---

### File 3: `src/main/java/com/journaldev/spring/jdbc/model/Reports.java`

**Fully qualified class name:** `com.journaldev.spring.jdbc.model.Reports`

**Interfaces implemented:** `java.io.Serializable`

**Class extended:** none

**Class-level annotations:** none

**Fields:**

| Modifier  | Type   | Name   | Line |
|-----------|--------|--------|------|
| private static final | long | serialVersionUID | 10 |
| private   | String | field  | 12   |
| private   | String | object | 13   |
| private   | String | value  | 14   |

**Public methods:**

| Return type | Method signature            | Line |
|-------------|-----------------------------|------|
| String      | `getField()`                | 16   |
| void        | `setField(String field)`    | 19   |
| String      | `getObject()`               | 22   |
| void        | `setObject(String object)`  | 25   |
| String      | `getValue()`                | 28   |
| void        | `setValue(String value)`    | 31   |

**Method-level annotations:** none

---

## Checklist Review

---

### Section 1 — Secrets and Configuration

These are plain model (POJO) classes. They contain no configuration, credentials, database connection strings, API keys, or pipeline references.

**Verdict: N/A** — Model classes; no secrets concern applicable.

---

### Section 2 — Authentication and Authorization

These are plain model (POJO) classes. They carry no security annotations (`@PreAuthorize`, `@Secured`) and define no endpoints. Authorization enforcement must be evaluated at the controller and service layers.

However, a data-model concern with authorization implications is raised below under Section 5.

**Verdict: N/A** for this section at the model layer; cross-tenant concern escalated to Section 5.

---

### Section 3 — Input Validation and Injection

**Deserialization (`@JsonTypeInfo` / default typing):** No Jackson annotations are present on any of the three classes. No `@JsonTypeInfo`, `@JsonSubTypes`, or `ObjectMapper` configuration is present here. No `ObjectInputStream` usage is present.

All three classes implement `java.io.Serializable`. This is noted as a finding because Java serialization on model objects that transit through HTTP responses creates a latent attack surface if any endpoint ever marshals these via Java object serialization rather than JSON. The risk is low in isolation but escalated given that `serialVersionUID` values are explicitly declared (indicating intentional serialization design), and the `Reports` model uses highly generic field names (`field`, `object`, `value`) that could facilitate gadget-chain abuse if serialized payloads were ever accepted from untrusted sources.

**Input validation constraints:** No `@NotNull`, `@Size`, `@Pattern`, or any JSR-303/JSR-380 constraint annotations are present on any field in any of the three classes. If these models are used as `@RequestBody` targets in controllers, there is no model-layer validation to prevent malformed or oversized input.

**Verdict:** Two findings raised — see B21-1 and B21-2 below.

---

### Section 4 — Session and CSRF

These are plain model (POJO) classes. No session management, CSRF, CORS, or cookie configuration is present.

**Verdict: N/A** — Model classes; not applicable.

---

### Section 5 — Data Exposure

**ReportLists — cross-tenant / organisation scoping:**

`ReportLists` maps to what the inline comment identifies as a "subscription table" (line 10). It carries `comp_id` (company/organisation ID, line 17), `name`, `file_name`, and `frequency`. The `comp_id` field is a tenant discriminator. The model exposes a full getter (`getComp_id()`, line 19), meaning that when this model is serialised into a JSON HTTP response, the `comp_id` value is included in the response body. If a controller returns a list of `ReportLists` objects without filtering by the authenticated user's `comp_id`, all report subscription records across all tenants would be exposed. The model itself provides no mechanism to suppress `comp_id` from serialisation (no `@JsonIgnore`), and no `@JsonView` or DTO projection is used to limit which fields are emitted.

Additionally, `file_name` is exposed. In a multi-tenant report system, report file names may encode tenant-identifying path elements, internal naming conventions, or storage layout details that should not be disclosed cross-tenant.

**Reports — generic key/value aggregation model:**

`Reports` uses three string fields: `field`, `object`, and `value` (lines 12–14). This is a deliberately generic aggregation structure. Because the field names are schema-agnostic, any type of data — operator PII, incident descriptions, telemetry readings, site identifiers — can be stored in the `value` field at runtime. There is no structural mechanism within the model to enforce data classification, restrict cross-tenant aggregation, or apply field-level access control. If report query logic does not enforce tenant isolation before populating `Reports` instances, sensitive data from multiple organisations could be co-mingled and returned in a single response. This is a design-level concern: the model's intentional genericity makes it impossible to apply data-classification controls at the model layer.

**Questions — expectedanswer field exposure:**

`Questions` carries an `expectedanswer` field (line 14) with a public getter (`getExpectedanswer()`, line 29). Pre-op safety checklist questions with expected answers represent safety-critical configuration. If this model is returned directly to end-user clients (e.g., forklift operators completing a pre-op check), exposing the expected answer in the JSON payload would allow a client to trivially pass the checklist without the operator actually knowing the correct answer. The checklist answer should be withheld from the client response and validated server-side only.

**Verdict:** Three findings raised — see B21-3, B21-4, and B21-5 below.

---

### Section 6 — Dependencies

**Verdict: N/A** — Model classes; dependency analysis is not applicable at this layer.

---

### Section 7 — Build and CI

**Verdict: N/A** — Model classes; build and CI analysis is not applicable at this layer.

---

## Findings

---

**B21-1** — LOW
**Section:** 3 — Input Validation and Injection
**File:** `src/main/java/com/journaldev/spring/jdbc/model/Questions.java:5`, `src/main/java/com/journaldev/spring/jdbc/model/ReportLists.java:5`, `src/main/java/com/journaldev/spring/jdbc/model/Reports.java:5`
**Description:** All three model classes implement `java.io.Serializable` with explicitly declared `serialVersionUID` values, indicating intentional Java serialization design. No JSR-303/380 field-level validation constraints are present on any field. If these classes are ever accepted as `@RequestBody` from untrusted input or participate in Java object serialization (e.g., session storage, caching, RMI), the absence of constraints and the use of `Serializable` increases the deserialization gadget-chain attack surface. The risk is low in the context of a JSON REST API using Jackson, but should be reviewed to confirm Java serialization is never used for inbound data.
**Evidence:**
```java
// Questions.java:5
public class Questions implements Serializable {
    private static final long serialVersionUID = 1443419827915092612L;

// ReportLists.java:5
public class ReportLists implements Serializable{
    private static final long serialVersionUID = 583659787962286000L;

// Reports.java:5
public class Reports implements Serializable{
    private static final long serialVersionUID = -328199895252518312L;
```

---

**B21-2** — MEDIUM
**Section:** 3 — Input Validation and Injection
**File:** `src/main/java/com/journaldev/spring/jdbc/model/Questions.java:12-14`, `src/main/java/com/journaldev/spring/jdbc/model/ReportLists.java:13-17`, `src/main/java/com/journaldev/spring/jdbc/model/Reports.java:12-14`
**Description:** No JSR-303/380 validation annotations (`@NotNull`, `@Size`, `@Pattern`, `@Min`, `@Max`, etc.) are present on any field in any of the three model classes. If these classes are used as `@RequestBody` deserialization targets in any controller and `@Valid` or `@Validated` is applied, Spring will find no constraints to enforce, meaning oversized strings, null values, or malformed inputs will pass through to the persistence layer unchecked. This is particularly relevant for `Questions.content` (checklist question text) and `ReportLists.frequency` (report scheduling parameter), both of which are free-form strings with no length or format restrictions at the model layer.
**Evidence:**
```java
// Questions.java — no constraints on any field
private int id;
private String content;
private String expectedanswer;

// ReportLists.java — no constraints on any field
private int id;
private String name;
private String file_name;
private String frequency;
private int comp_id;

// Reports.java — no constraints on any field
private String field;
private String object;
private String value;
```

---

**B21-3** — HIGH
**Section:** 5 — Data Exposure
**File:** `src/main/java/com/journaldev/spring/jdbc/model/ReportLists.java:17,19`
**Description:** `ReportLists` exposes `comp_id` (the tenant/company discriminator) via a public getter with no `@JsonIgnore` or DTO projection suppressing it from serialized HTTP responses. The inline comment (`// subscription table`) confirms this field is the tenant key for a report subscription record. If a controller returns `ReportLists` collections without enforcing that results are scoped to the authenticated user's `comp_id`, all tenant report subscriptions will be disclosed to any authenticated caller, constituting a cross-tenant data exposure. Even where filtering is applied at the query layer, leaking `comp_id` in the response body reveals internal tenant IDs to clients, enabling enumeration of other tenants' IDs. Additionally, `file_name` is fully exposed, potentially revealing multi-tenant storage layout conventions.
**Evidence:**
```java
// ReportLists.java:10,17,19
// subscription table
private int comp_id;

public int getComp_id() {
    return comp_id;
}
```

---

**B21-4** — MEDIUM
**Section:** 5 — Data Exposure
**File:** `src/main/java/com/journaldev/spring/jdbc/model/Reports.java:12-14`
**Description:** `Reports` uses a generic key/value/object triple (`field`, `object`, `value`) as its data model. This design makes it structurally impossible to apply field-level access control or data classification at the model layer: any data — operator PII, incident records, telemetry, site identifiers — can appear in `value` at runtime. There is no `@JsonView`, no DTO projection, and no `@JsonIgnore` applied to any field. The model provides no mechanism to distinguish or restrict sensitive aggregated data from being included in serialized responses. This is a design-level concern: the genericity of the model means cross-tenant or cross-role data exposure can only be prevented by query-layer tenant filtering, which must be verified at the DAO/service layer (outside the scope of this file assignment).
**Evidence:**
```java
// Reports.java:12-14
private String field;
private String object;
private String value;

public String getField() { return field; }
public String getObject() { return object; }
public String getValue() { return value; }
```

---

**B21-5** — HIGH
**Section:** 5 — Data Exposure
**File:** `src/main/java/com/journaldev/spring/jdbc/model/Questions.java:14,29`
**Description:** `Questions` contains an `expectedanswer` field (line 14) with a fully public getter (`getExpectedanswer()`, line 29) and no `@JsonIgnore` or equivalent suppression. Pre-op safety checklist questions in a forklift management system carry expected answers that define whether an operator passes or fails a safety check. If the `Questions` model is serialized into a response delivered to operator-facing clients (e.g., a mobile app displaying the checklist), the correct answer is transmitted in the payload. This allows a client application or an operator to read the expected answer from the JSON response and submit it without genuine knowledge, defeating the purpose of the safety pre-op check. Expected answers should be withheld from client-facing responses and evaluated exclusively server-side.
**Evidence:**
```java
// Questions.java:14,29-31
private String expectedanswer;

public String getExpectedanswer() {
    return expectedanswer;
}
```

---

## Summary Table

| Finding | Severity | Section | File |
|---------|----------|---------|------|
| B21-1   | LOW      | 3 — Input Validation / Deserialization | `Questions.java:5`, `ReportLists.java:5`, `Reports.java:5` |
| B21-2   | MEDIUM   | 3 — Input Validation | `Questions.java:12-14`, `ReportLists.java:13-17`, `Reports.java:12-14` |
| B21-3   | HIGH     | 5 — Data Exposure (cross-tenant) | `ReportLists.java:17,19` |
| B21-4   | MEDIUM   | 5 — Data Exposure (generic model) | `Reports.java:12-14` |
| B21-5   | HIGH     | 5 — Data Exposure (safety check answer) | `Questions.java:14,29` |

**Sections 1, 4, 6, 7:** N/A (model classes — no applicability).
**Section 2:** N/A at model layer; cross-tenant concern surfaced under Section 5 (B21-3).
