# Security Audit Report — A131
**Agent:** A131
**Repo:** api_server
**Stack:** Elixir/Phoenix
**Branch:** master
**Run:** 2026-02-27-01
**Auditor model:** claude-sonnet-4-6

---

## Assigned Files

1. `lib/api_server_web/views/vx_abl_record_view.ex`
2. `lib/api_server_web/views/vx_access_fob_view.ex`
3. `lib/api_server_web/views/vx_customer_view.ex`

---

## Reading Evidence

### File 1: `lib/api_server_web/views/vx_abl_record_view.ex`

**Module name:** `ApiServerWeb.VXAblRecordView`

**Public functions (def):**

| Name | Arity | Line |
|------|-------|------|
| `render/2` ("index.json") | 2 | 8 |
| `render/2` ("show.json") | 2 | 12 |
| `render/2` ("vx_abl_record.json") | 2 | 16 |
| `render/2` ("services.json") | 2 | 22 |
| `clean_xml_value/1` | 1 | 28 |
| `clean_xml_number_value/1` | 1 | 37 |
| `render/2` ("service.json") | 2 | 46 |

**defstruct / defexception / schema defined:** None

**use / import / alias at module level:**
- `use ApiServerWeb, :view` (line 2)
- `alias ApiServerWeb.VXAblRecordView` (line 4)
- `alias ApiServer.Vx` (line 5)

---

### File 2: `lib/api_server_web/views/vx_access_fob_view.ex`

**Module name:** `ApiServerWeb.VXAccessFobView`

**Public functions (def):**

| Name | Arity | Line |
|------|-------|------|
| `render/2` ("index.json") | 2 | 5 |
| `render/2` ("show.json") | 2 | 9 |
| `render/2` ("vx_access_fob.json") | 2 | 13 |

**defstruct / defexception / schema defined:** None

**use / import / alias at module level:**
- `use ApiServerWeb, :view` (line 2)
- `alias ApiServerWeb.VXAccessFobView` (line 3)

---

### File 3: `lib/api_server_web/views/vx_customer_view.ex`

**Module name:** `ApiServerWeb.VXCustomerView`

**Public functions (def):**

| Name | Arity | Line |
|------|-------|------|
| `render/2` ("index.json") | 2 | 5 |
| `render/2` ("show.json") | 2 | 9 |
| `render/2` ("vx_customer.json") nil-clause | 2 | 13 |
| `render/2` ("vx_customer.json") | 2 | 14 |

**defstruct / defexception / schema defined:** None

**use / import / alias at module level:**
- `use ApiServerWeb, :view` (line 2)
- `alias ApiServerWeb.VXCustomerView` (line 3)

---

## Supporting Files Read (for context)

The following files were read to assess schema fields and authorization scope:

- `lib/api_server/vx/vx_abl_record.ex` — schema `abl_data_changes`; primary key `ablid`; fields include `ablimage` (raw XML blob), `ablip_address`, `ablusragnt` (user agent), `abluser`, `abllogtype`, `ablaction`, `abltable`, `ablimagetype`, `ablprocessed`.
- `lib/api_server/vx/vx_access_fob.ex` — schema `access_fobs`; fields `fob_code`, FK `assigned_to_user`.
- `lib/api_server/vx/vx_customer.ex` — schema `aaa_customers`; primary key `aaaid`; fields include `aaaprimcont`, `aaaprimemail`, `aaaprimtel`, `aaaudfcustcode`, `aaacolour`.
- `lib/api_server/vx/vx_user.ex` — schema `aac_user`; fields include `aacpassword`, `aacpasswordhash`, `[REDACTED-AWS-SMTP-PASSWORD]`.
- `lib/api_server/vx/vx_fleet.ex` — schema `aae_group`; primary key `aaeid`.
- `lib/api_server_web/controllers/vx_abl_record_controller.ex`
- `lib/api_server_web/controllers/vx_access_fob_controller.ex`
- `lib/api_server_web/controllers/vx_customer_controller.ex`
- `lib/api_server_web/router.ex`
- `lib/api_server/vx/vx.ex` (relevant sections)

---

## Checklist Review

### §1: Secrets and Configuration
These are view files. No config files, hardcoded credentials, API keys, or secrets are present in any of the three files.

**§1: No issues found.**

---

### §2: Authentication and Authorization

Relevant observations from the router and controllers:

- All three view modules are used by controllers that sit behind `pipe_through([:api, :authenticated])` in `router.ex`. The `[REDACTED-AWS-SMTP-PASSWORD]` `:rhm_service_records` action (line 112 of router) is within the authenticated scope.
- The `[REDACTED-AWS-SMTP-PASSWORD]` actions (`:index`, `:show`, `:update`, `:create`, `:delete`) are all within the authenticated scope (lines 139–143 of router).
- `[REDACTED-AWS-SMTP-PASSWORD]` (`:index`, `:show`, `:delete`) is **not registered in the router at all** — those controller actions exist in source but have no live route. This is an informational observation; there is no active exposure.

**Customer controller — IDOR in `show` and `delete`:** `VXCustomerController.show/2` calls `Vx.get_vx_customer!(id, customer)` where `customer` comes from the JWT claim, providing customer-scoped isolation. Similarly for `update` and `delete`. The `index` action calls `Vx.list_customers(customer)` also correctly scoped. No IDOR issue in the customer view/controller pairing.

**ABL record controller — missing customer scoping on `show`, `create`, `update`, `delete`:** The `[REDACTED-AWS-SMTP-PASSWORD]` defines `show/2`, `create/2`, `update/2`, and `delete/2` actions that call `Vx.get_vx_abl_record!(id)` and `Vx.create_vx_abl_record/1` without any customer prefix. However, these four actions are **not registered in the router**; only `:rhm_service_records` is registered and it correctly uses `customer` from JWT claims. This is an informational risk: if routes were added for these actions they would be unscoped.

---

**Finding:**

**A131-1** — MEDIUM — `[REDACTED-AWS-SMTP-PASSWORD]`: unscoped CRUD actions not yet routed

File: `lib/api_server_web/controllers/vx_abl_record_controller.ex` (lines 9–36)

The controller defines `create/2`, `show/2`, `update/2`, and `delete/2` actions that access `VXAblRecord` records without customer scoping — they call `Vx.get_vx_abl_record!(id)` and `Vx.create_vx_abl_record/1` which have no `prefix: customer` argument. These actions are currently not registered in the router so they are not reachable, but their presence creates a latent IDOR/cross-tenant data access risk if routes are ever added. The only routed action, `:rhm_service_records`, correctly scopes by customer JWT claim. The view `vx_abl_record_view.ex` will serve these unscoped results if the actions become reachable.

---

### §3: Input Validation and Injection
These files are view modules only. They contain no SQL queries, no atom creation from user input, no `binary_to_term`, and no `Code.eval_string`. The `clean_xml_value/1` and `clean_xml_number_value/1` helpers in `VXAblRecordView` perform basic nil-coalescing on already-parsed values — they do not process raw user input.

**§3: No issues found.**

---

### §4: Session and CSRF
View modules. No session handling or CSRF configuration is present.

**§4: No issues found.**

---

### §5: File and Data Handling

#### 5a. Over-exposure of sensitive fields in views

**VXAblRecordView — `service.json` template (lines 68–87):**

The `service.json` render exposes the following fields which warrant scrutiny:

- `ip_address: record.ablip_address` — the IP address of the user who performed the service action. This is internal audit-log data (a user's IP address). Exposing IP addresses of users in API responses is a PII/privacy concern; it may unnecessarily reveal information about user network locations to API consumers.
- `usr_agent: record.ablusragnt` — the full User-Agent string of the browser/client at the time of the action. This is also internal audit-log metadata not typically appropriate for API consumers.
- `custcode: record.ablcustcode` — the customer code. While not highly sensitive on its own, in a multi-tenant system this leaks the originating tenant identifier.
- `table: record.abltable` and `action: record.ablaction` — internal database table names and action codes (e.g., "UPD", "aad_thing") are schema implementation details that reveal the internal database structure.

**Finding:**

**A131-2** — MEDIUM — `VXAblRecordView` `service.json`: exposes internal audit metadata including user IP addresses and database internals

File: `lib/api_server_web/views/vx_abl_record_view.ex` (lines 68–87)

The `service.json` render clause exposes `ip_address` (the user's IP address at time of action), `usr_agent` (the full User-Agent string), `table` (internal database table name `"aad_thing"`), and `action` (internal DB operation code `"UPD"`). IP address and User-Agent are PII and internal audit metadata respectively. Exposing them to API consumers is unnecessary for the intended use case (service record listing) and constitutes over-exposure. The database table name and action code leak internal schema implementation details. The `ablimage` raw XML field is correctly withheld.

---

**VXAblRecordView — `vx_abl_record.json` template (lines 16–19):**

Renders `id: vx_abl_record.id` (the `ablid` raw primary key) and `ablcustcode`. The `ablid` is a raw database primary key. For an audit log record this is expected in a CRUD API context, but the template is only exercised by `show.json` and `index.json` which are not currently routed.

---

**VXAccessFobView — `vx_access_fob.json` template (lines 13–16):**

Renders `id: vx_access_fob.id` (raw DB primary key) and `fob_code`. The `fob_code` is the physical access fob identifier. Since the controller `index` action is not routed, exposure is currently inactive. However, `fob_code` is a physical security credential — knowledge of valid fob codes could facilitate physical access bypass. The schema shows `belongs_to :user` via `assigned_to_user` FK; the view correctly does not render the associated user data.

**Finding:**

**A131-3** — HIGH — `VXAccessFobView`: exposes physical access fob codes; no customer scoping on `list_vxaccessfobs`

File: `lib/api_server_web/views/vx_access_fob_view.ex` (lines 13–16)
Related: `lib/api_server_web/controllers/vx_access_fob_controller.ex` (line 10); `lib/api_server/vx/vx.ex` (line 146)

The `index` action calls `Vx.list_vxaccessfobs()` which performs `Repo.all(VXAccessFob)` with no customer prefix scoping — it would return all access fobs across all tenants. The view then renders `fob_code` (a physical security credential) for every record. The combination of (a) bulk enumeration, (b) cross-tenant scope, and (c) physical credential exposure makes this a HIGH finding. The actions are not currently registered in the router, mitigating active risk, but the code is latently dangerous if routes are added.

---

**VXCustomerView — `vx_customer.json` template (lines 18–33):**

The view renders the following fields from `VXCustomer`:
- `id: vx_customer.aaaid` — raw database primary key (`aaaid`). This is the internal integer primary key of the customer record.
- `code: vx_customer.aaacustcode`
- `name`, `address_line_1/2/3`, `post_code`
- `primary_contact_name: vx_customer.aaaprimcont`
- `primary_contact_telephone: vx_customer.aaaprimtel`
- `primary_contact_email: vx_customer.aaaprimemail`
- `timezone: vx_customer.aaatz`

The schema also contains `aaaudfcustcode` and `aaacolour` which are **commented out** in the view (lines 30–31). This is correctly withheld.

The rendered fields include the primary contact's name, telephone number, and email address. These are PII. In the context of a fleet management system, exposing customer contact PII via the API to authenticated users may be appropriate (customer records are a standard resource), but the API returns **all** customers visible to the JWT's `customer` prefix via `index`. The `primary_contact_telephone` and `primary_contact_email` fields especially should be reviewed as to whether all authenticated users of a tenant need access to contact details for all sub-customers.

**Finding:**

**A131-4** — LOW — `VXCustomerView`: exposes PII fields (contact name, telephone, email) for all customers in tenant

File: `lib/api_server_web/views/vx_customer_view.ex` (lines 22–29)

The `vx_customer.json` render includes `primary_contact_name`, `primary_contact_telephone`, and `primary_contact_email` for every customer record returned by the `index` endpoint. These are PII fields. The exposure is scoped to the authenticated user's tenant (the `list_customers` context function correctly uses `prefix: customer`), which limits the blast radius, but any authenticated user in the tenant can enumerate contact PII for all customers. Depending on the role model, read access to contact details may not be appropriate for all user types. The `aaaudfcustcode` and `aaacolour` fields are correctly commented out in the view.

---

**Finding:**

**A131-5** — MEDIUM — `VXCustomerController.create/2`: Ecto changeset error details returned to API caller

File: `lib/api_server_web/controllers/vx_customer_controller.ex` (line 28)

The `create/2` action's error branch sends a raw `inspect error.errors` string in the HTTP 500 response body:
```elixir
send_resp(conn, :internal_server_error, "{\"error\": \"error creating customer\", \"reason\": \"#{inspect error.errors}\" }")
```
Ecto changeset error tuples can contain internal field names (e.g., constraint names like `UQ1`), validation rule names, and database column identifiers. This discloses internal schema details to API consumers and violates the principle of minimal error disclosure. Additionally, `IO.inspect error` on line 27 logs the full error struct to stdout/logs, which may include sensitive data depending on the input. This is a controller-level finding directly affecting what the view layer returns.

---

#### 5b. PII / fleet data in Logger calls
The three view files contain no `Logger` calls.

**§5 summary:** Findings A131-2 (IP/UA/DB internals in audit view), A131-3 (fob code exposure + no tenant scoping), A131-4 (customer contact PII), A131-5 (error disclosure in customer create) raised above.

---

### §6: Dependencies
These are view files. No dependency declarations are present.

**§6: No issues found.**

---

### §7: Infrastructure Exposure
These are view files. No hardcoded hostnames, IPs, CORS configuration, or inter-service communication is present.

**§7: No issues found.**

---

## Findings Summary

| ID | Severity | Location | Title |
|----|----------|----------|-------|
| A131-1 | MEDIUM | `vx_abl_record_controller.ex` lines 9–36 | Unscoped CRUD actions (not routed, latent IDOR/cross-tenant risk) |
| A131-2 | MEDIUM | `vx_abl_record_view.ex` lines 68–87 | `service.json` exposes user IP address, User-Agent, and internal DB table/action names |
| A131-3 | HIGH | `vx_access_fob_view.ex` lines 13–16; `vx_access_fob_controller.ex` line 10 | Physical access fob codes exposed; `list_vxaccessfobs` has no tenant scoping |
| A131-4 | LOW | `vx_customer_view.ex` lines 22–29 | Contact PII (name, phone, email) exposed for all customers in tenant on index |
| A131-5 | MEDIUM | `vx_customer_controller.ex` line 28 | Raw Ecto error internals returned in HTTP 500 response body |

---

## Detailed Findings

### A131-1 — MEDIUM
**Title:** Unscoped VXAblRecord CRUD actions (latent IDOR / cross-tenant data access)

**File:** `lib/api_server_web/controllers/vx_abl_record_controller.ex`, lines 9–36
**View affected:** `lib/api_server_web/views/vx_abl_record_view.ex`

**Description:**
`[REDACTED-AWS-SMTP-PASSWORD]` defines `create/2`, `show/2`, `update/2`, and `delete/2` actions. Each retrieves or modifies records using `Vx.get_vx_abl_record!(id)` and `Vx.create_vx_abl_record/1`, which call `Repo.get!` and `Repo.insert` with no `prefix: customer` argument. In a multi-tenant Postgres schema-per-tenant deployment (as confirmed by the scoped queries elsewhere in the codebase), omitting the prefix would cause the query to operate on the default schema or raise a runtime error, depending on the Repo configuration. At minimum this is an incomplete implementation. If routes were added, any authenticated user could potentially access audit records from other tenants by supplying an arbitrary ID.

The contrast with `rhm_service_records` (the only routed action) is clear: that action correctly derives `customer` from JWT claims and passes it as prefix.

**Recommendation:** Add customer scoping to all four unrouted actions before adding routes. Remove the actions entirely if they will never be needed, to reduce attack surface.

---

### A131-2 — MEDIUM
**Title:** `service.json` render exposes user IP addresses, User-Agent strings, and internal database table/action codes

**File:** `lib/api_server_web/views/vx_abl_record_view.ex`, lines 68–87

**Description:**
The `service.json` render clause (used by the live `/rhm/services` endpoint) serialises the following fields from the `abl_data_changes` audit log that should not be returned to API consumers:

- `ip_address: record.ablip_address` — the IP address of the user who performed the service action. This is PII under most privacy frameworks (GDPR Art. 4(1) considers IP addresses personal data). It is audit-log provenance data with no legitimate use by the frontend service consumer.
- `usr_agent: record.ablusragnt` — the full User-Agent header string stored at the time of the action. Again, internal audit provenance.
- `table: record.abltable` — the internal database table name (`"aad_thing"`). Leaks internal schema.
- `action: record.ablaction` — the internal operation code (`"UPD"`). Leaks internal audit semantics to external consumers.

**Recommendation:** Remove `ip_address`, `usr_agent`, `table`, and `action` from the `service.json` render clause. If any of these are genuinely needed by a consuming application, gate them behind a specific role/permission check.

---

### A131-3 — HIGH
**Title:** Physical access fob codes exposed by `VXAccessFobView`; `list_vxaccessfobs` has no tenant scoping

**File:** `lib/api_server_web/views/vx_access_fob_view.ex`, lines 13–16
**Related:** `lib/api_server_web/controllers/vx_access_fob_controller.ex`, line 10
**Related:** `lib/api_server/vx/vx.ex`, line 146

**Description:**
The `vx_access_fob.json` render clause exposes `fob_code`. Access fob codes are physical security credentials — they are the identifiers programmed into RFID/proximity fobs that grant physical access to machinery or facilities. Enumerating valid fob codes provides an attacker with the information needed to clone fobs or bypass access controls.

Additionally, `Vx.list_vxaccessfobs/0` (called by `VXAccessFobController.index/2`) performs `Repo.all(VXAccessFob)` with no customer prefix. In a multi-tenant schema-per-tenant deployment this would return all access fobs across all tenants — a cross-tenant data leak.

While `[REDACTED-AWS-SMTP-PASSWORD]` is not currently registered in the router (no route exists for `:index`, `:show`, or `:delete`), the implementation is complete and the code is ready to be activated. The severity is rated HIGH because `fob_code` is a physical security credential and the underlying query is not tenant-scoped.

**Recommendation:**
1. Add `prefix: customer` to `Vx.list_vxaccessfobs/0` (or create a scoped variant) before routing the endpoint.
2. Evaluate whether `fob_code` needs to be returned in the API response at all, or whether a boolean `is_assigned` flag would suffice for the intended use case.
3. If `fob_code` must be returned, restrict the endpoint to privileged roles only.

---

### A131-4 — LOW
**Title:** Customer `index` endpoint exposes contact PII for all tenant sub-customers

**File:** `lib/api_server_web/views/vx_customer_view.ex`, lines 22–29
**Related:** `lib/api_server_web/controllers/vx_customer_controller.ex`, line 12
**Related:** `lib/api_server/vx/vx.ex`, line 2872

**Description:**
The `vx_customer.json` render clause includes `primary_contact_name`, `primary_contact_telephone`, and `primary_contact_email`. The `index` action returns all customers in the tenant (`Repo.all(VXCustomer, prefix: customer)`) meaning all authenticated users, regardless of role, can enumerate the name, telephone number, and email address of every contact person across all sub-customers in their tenant.

The customer scoping is correctly applied (prefix: customer), so cross-tenant leakage does not occur. The risk is intra-tenant: a low-privilege user (e.g., a driver or operator) should arguably not have read access to the contact details of other customers in the same tenant.

**Recommendation:** Review whether role-based access control should restrict access to contact PII fields. Consider a separate endpoint or projection for admin users vs. read-only users. At minimum, document the access control decision.

---

### A131-5 — MEDIUM
**Title:** Raw Ecto changeset error details returned in HTTP 500 response body

**File:** `lib/api_server_web/controllers/vx_customer_controller.ex`, line 28
**View affected:** N/A (uses `send_resp` directly, bypassing the view layer)

**Description:**
The `create/2` action's else-branch constructs a response body containing `inspect error.errors`:

```elixir
send_resp(conn, :internal_server_error,
  "{\"error\": \"error creating customer\", \"reason\": \"#{inspect error.errors}\" }")
```

`inspect error.errors` on an Ecto changeset produces output such as:
```
[aaacustcode: {"has already been taken", [constraint: :unique, constraint_name: "UQ1"]}]
```

This discloses:
- Internal database column names (`aaacustcode`)
- Database constraint names (`UQ1`)
- Validation rule details

These details are unnecessary for the API consumer and aid an attacker in enumerating valid values or understanding the schema. Additionally, `IO.inspect error` (line 27) writes the full changeset to standard output/logs, which may include the input data submitted by the user.

The standard Phoenix approach (`action_fallback` with `FallbackController` and `ChangesetView`) is already available in this codebase (the controller declares `action_fallback ApiServerWeb.FallbackController`) but is not used in the `else` branch.

**Recommendation:** Replace the manual `send_resp` error branch with `{:error, changeset}` returned from the `with` expression so that `FallbackController` handles it, or produce a generic error message without internal field/constraint names.
