# Security Audit Report — A143
**Agent:** A143
**Run:** 2026-02-27-01
**Branch:** master
**Stack:** Elixir/Phoenix
**Assigned files:**
- `lib/api_server_web/views/vx_user_view.ex`
- `lib/api_server_web/xml_plug.ex`

**Checklist applied:** PASS1-CHECKLIST-api_server.md (all 7 sections)

---

## Reading Evidence

### File 1: `lib/api_server_web/views/vx_user_view.ex`

**Module name:** `ApiServerWeb.VXUserView`

**Public functions (def, not defp):**

| Name | Arity | Line |
|------|-------|------|
| `render` | 2 — `"index.json"` clause | 5 |
| `render` | 2 — `"show.json"` clause | 9 |
| `render` | 2 — `"rhm_users.json"` clause | 13 |
| `render` | 2 — `"rhm_user.json"` clause | 17 |
| `render` | 2 — `"fleet_list.json"` clause | 58 |

**No defstruct, defexception, or schema defined.**

**use / import / alias at module level:**
```elixir
use ApiServerWeb, :view           # line 2
alias ApiServerWeb.VXUserView     # line 3
```

**No plug entries** (view module, not a plug or router).

---

### File 2: `lib/api_server_web/xml_plug.ex`

**Module name:** `Plug.Parsers.XML`

**Public functions (def, not defp):**

| Name | Arity | Line |
|------|-------|------|
| `parse` | 5 — matching `"xml"` subtype | 6 |
| `parse` | 5 — catch-all clause | 13 |

**Private functions:**

| Name | Arity | Line |
|------|-------|------|
| `decode` | 2 | 17 |

**No defstruct, defexception, or schema defined.**

**use / import / alias at module level:**
```elixir
@behaviour Plug.Parsers   # line 3
import Plug.Conn          # line 4
```

**Plug behaviour implemented:** `parse/5` (both clauses at lines 6 and 13).

---

## Supporting Context Read During Audit

The following additional files were read to fully assess the assigned files:

- `lib/api_server_web/endpoint.ex` — Plug.Parsers configuration and `xml_decoder` option
- `lib/api_server_web/router.ex` — pipeline and route scopes using `:api_xml`
- `lib/api_server/vx/vx_user.ex` — VXUser Ecto schema revealing all user fields
- `mix.exs` — dependency declarations including `elixir_xml_to_map ~> 0.1`
- `mix.lock` — pinned versions
- `config/config.exs` — application-wide configuration including hardcoded secrets

---

## Checklist Review

### §1: Secrets and Configuration

**Finding A143-1 (CRITICAL) — Hardcoded AWS SMTP credentials in config.exs**

`config/config.exs` lines 117–120 contain a live AWS SES SMTP username (IAM Access Key ID) and password in plaintext in a tracked source file:

```elixir
username: "[REDACTED-AWS-KEY-ID]",
password: "[REDACTED-AWS-SMTP-PASSWORD]",
```

A commented-out prior set of credentials also appears on lines 115–116:
```elixir
# username: "[REDACTED-AWS-KEY-ID]",
# password: "[REDACTED-AWS-SMTP-PASSWORD]",
```

Both the active and former credentials are committed to version history. These must be rotated immediately. Credentials must be loaded from environment variables or a secrets manager and must never appear in tracked source files.

**Finding A143-2 (CRITICAL) — Hardcoded secret_key_base in config.exs**

`config/config.exs` line 15:
```elixir
secret_key_base: "djHcKcu+CWBtfoT6k1mLsC1ObkKOy1ZF1G840aRXnQ+oAgAU9efRLUJ+yTd3x/Fh",
```

The Phoenix `secret_key_base` is used to sign session cookies. This value is hardcoded in a tracked file. Any party with repository access can forge session tokens. This key must be regenerated, stored as an environment variable (`System.get_env("SECRET_KEY_BASE")`), and removed from the repository including its git history.

**Finding A143-3 (CRITICAL) — Hardcoded Guardian secret_key in config.exs**

`config/config.exs` line 136:
```elixir
secret_key: "wf1TLkCaEKIPY61A5LvxtPrUA63wrV/hz0RAtaDPh7BENw5WgsCPUN0/qH65BYmA"
```

This is the HMAC secret used to sign all Guardian JWT tokens. Any party with repository access can mint valid JWTs for any user. This key must be rotated immediately, stored as an environment variable, and removed from version history.

**Finding A143-4 (HIGH) — Guardian TTL set to 52 weeks**

`config/config.exs` line 135:
```elixir
ttl: {52, :weeks},
```

JWT tokens are valid for one year with no apparent refresh or revocation mechanism. If a token is compromised, it remains valid for up to 52 weeks. The TTL should be reduced to hours or days, with a refresh token strategy implemented.

**Finding A143-5 (INFO) — Hardcoded AWS SES region reveals infrastructure topology**

`config/config.exs` line 113:
```elixir
server: "email-smtp.us-west-2.amazonaws.com",
```

The AWS region (`us-west-2`) is hardcoded and disclosed in source. This is lower severity but contributes to infrastructure topology exposure per §7.

---

### §2: Authentication and Authorization

**Finding A143-6 (CRITICAL) — Two unauthenticated routes that return fleet/operational data**

`lib/api_server_web/router.ex` lines 30–31 define two routes that are placed **before** `pipe_through([:api, :authenticated])` and therefore receive **no authentication**:

```elixir
get("/rhm/engine_usage", VXThingController, :combined_engine_usage)
get("/rhm/monday_hour_meters", VXThingController, :monday_hour_meters)
```

These routes sit inside the `scope "/api/v1"` block but outside the authenticated pipeline. Fleet operational data (engine usage, hour meters) is returned with no token verification. This is an IDOR risk — any unauthenticated caller can query these endpoints. Verify whether these routes are intentionally public; if not, move them inside the authenticated pipeline.

**Finding A143-7 (HIGH) — Password stored as plaintext alongside hash**

`lib/api_server/vx/vx_user.ex` line 21–22 shows the schema:
```elixir
field :aacpassword, :string
field :aacpasswordhash, :string
```

The presence of both a plaintext password field (`aacpassword`) and a hash field (`aacpasswordhash`) indicates the database stores or has stored plaintext passwords. The `password_changeset/2` function (line 73–76) casts `:aacpassword` directly with no hashing. The `convert_json_to_changeset/1` function (line 66) also maps `user_json["password"]` directly to `:aacpassword`. This is a CRITICAL risk if `aacpassword` is ever persisted. Password hashing must use bcrypt or argon2 and only the hash must be stored.

**Finding A143-8 (MEDIUM) — Guardian token TTL is 52 weeks with no revocation**

See A143-4. Noted here as an authentication concern — there is no evidence of a token blacklist or revocation store. Compromised tokens remain valid.

---

### §3: Input Validation and Injection

**Finding A143-9 (HIGH) — xml_plug.ex: `decoder` option is accepted but silently ignored; XML is always parsed by XmlToMap regardless of configured decoder**

`lib/api_server_web/xml_plug.ex` lines 6–11:
```elixir
def parse(conn, _, "xml", _headers, opts) do
  decoder = Keyword.get(opts, :xml_decoder) || raise ArgumentError, "XML parser expects a :xml_decoder option"
  conn
  |> read_body(opts)
  |> decode(decoder)
end
```

The `decoder` variable is retrieved from opts and passed to `decode/2`, but `decode/2` at lines 17–26 completely ignores it:

```elixir
defp decode({:ok, body, conn}, decoder) do
    case XmlToMap.naive_map(body) do
        map ->
            {:ok, %{xml: map}, conn}
        _ ->
            raise "Malformed XML"
    end
rescue
  e -> raise Plug.Parsers.ParseError, exception: e
end
```

The `decoder` argument is accepted in the `decode/2` function signature but never used. The actual parsing is always delegated to `XmlToMap.naive_map/1`. The endpoint (`endpoint.ex` line 28) specifies `xml_decoder: :xmerl_scan`, but this option is never applied. This is both a correctness defect and a security concern: the intent to control the XML backend via configuration is silently voided. Any future operator who changes `xml_decoder:` in the endpoint configuration will have no effect.

**Finding A143-10 (MEDIUM) — xml_plug.ex: no maximum body size limit enforced for XML input**

`lib/api_server_web/xml_plug.ex` line 9 calls `read_body(opts)`, which passes through the opts from `Plug.Parsers`. However, no explicit `length:` option is set in the endpoint's `Plug.Parsers` call for the XML parser. Without an explicit body size cap, an attacker could send a very large XML document, consuming memory during `XmlToMap.naive_map/1` parsing (which builds the entire document into an in-memory map). This is a denial-of-service amplification risk for the XML path specifically.

**Finding A143-11 (MEDIUM) — xml_plug.ex: catch-all match arm in `decode/2` is unreachable**

```elixir
case XmlToMap.naive_map(body) do
    map ->
        {:ok, %{xml: map}, conn}
    _ ->
        raise "Malformed XML"
end
```

The `_` arm is unreachable: the first arm `map ->` is an unconditional binding pattern that matches any value. `XmlToMap.naive_map/1` raises on malformed input rather than returning an error tuple, so malformed XML propagates as an uncaught exception. The `rescue` clause catches this and re-raises as `Plug.Parsers.ParseError`, which is correct behaviour. However, the dead `_ -> raise "Malformed XML"` arm is misleading and indicates the error handling logic was not reviewed carefully.

**§3 (SQL injection / atom creation / unsafe deserialization):** No issues found in the two assigned files. The view constructs a fixed-key map with no dynamic atom creation. The XML plug reads a binary body and passes it to a library; no `String.to_atom/1`, `binary_to_term/1`, or `Code.eval_string/1` calls are present in either assigned file.

---

### §4: Session and CSRF

**Finding A143-12 (HIGH) — Session cookie has no `secure`, `httponly`, or `samesite` flags configured**

`lib/api_server_web/endpoint.ex` lines 36–40:
```elixir
plug Plug.Session,
  store: :cookie,
  key: "_api_server_key",
  signing_salt: "5CSDVUtC"
```

No `secure: true`, `http_only: true`, or `same_site: "Strict"` options are set. The signing salt (`"5CSDVUtC"`) is short (8 bytes) and hardcoded. Without `secure: true`, session cookies can be sent over HTTP. Without `http_only: true`, they are accessible to JavaScript. This is noted here as contextual evidence read during review of the assigned files; the endpoint is not an assigned file but directly governs the security posture of all plug-handled requests.

**Finding A143-13 (MEDIUM) — CORSPlug applied globally with no origin restriction visible in config**

`lib/api_server_web/endpoint.ex` line 42:
```elixir
plug CORSPlug
```

`CORSPlug` is applied without any explicit `origin:` restriction at the endpoint level. The router has a commented-out `# plug CORSPlug, origin: "*"` in two pipelines (lines 13, 19). Without reviewing the `cors_plug` default configuration, the effective CORS policy defaults to `*` (allow all origins). For an authenticated API, this allows cross-origin requests from any domain. This was observed in supporting context during audit of the assigned files.

Note: Findings A143-12 and A143-13 are recorded here for completeness because they were observed in direct supporting context; the endpoint file itself is not an assigned file for this audit pass.

---

### §5: File and Data Handling

**§5 (vx_user_view.ex — sensitive field exposure check):**

The `render("rhm_user.json", ...)` function at lines 17–56 constructs the following map for API responses:

```elixir
user = %{
  id: user.aacid,
  customer_code: user.aaccustcode,
  first_name: user.aacfname,
  last_name: user.aacsurname,
  email: user.aacemail,
  offset: user.aactimezone,
  timezone: user.aactimezone,
  lang: user.aaclang,
  units: user.aacuom,
  default_dashboard: user.aacdash,
  date_format: user.aacdateformat,
  user_level: user_level
}
```

This explicit allowlist does **not** include `aacpassword`, `aacpasswordhash`, or `[REDACTED-AWS-SMTP-PASSWORD]`. The response shape is constructed by explicit key selection, not by serialising the whole struct. Password fields are not directly leaked by the view.

However, there is a conditional JWT inclusion at lines 18–23:
```elixir
jwt_component = cond do
  Map.has_key?(user, :jwt) ->
    %{jwt: user.jwt}
  true ->
    %{}
end
```

The JWT is included in the response when it is present on the user map. This is expected for the login flow (a JWT is issued and returned to the caller). This is standard practice and not a vulnerability in isolation, but it means the JWT secret exposure (A143-3) has direct downstream impact: an attacker who knows the secret can produce tokens that will be accepted by the API.

**Finding A143-14 (INFO) — `aacpassword` plaintext field exists on VXUser struct and is in scope in the view**

The VXUser schema (observed during review) contains `aacpassword` as a field. The view does not render it. However, the plaintext password field's mere existence in the database schema is a significant concern (see A143-7). If the view were modified carelessly (e.g., by using `Map.from_struct/1` or `Jason.encode!/1` on the raw struct), the plaintext password would be exposed in API responses. The explicit allowlist in the view is the only guard.

**§5 (xml_plug.ex — PII/data disclosure):** No Logger calls are present in `xml_plug.ex`. The module raises exceptions on parse errors but does not echo user-supplied XML back in error messages.

---

### §6: Dependencies

**Finding A143-15 (HIGH) — mariaex 0.8.4 is deprecated and has no security support**

`mix.lock` line 37:
```
"mariaex": {:hex, :mariaex, "0.8.4", ...}
```

`mix.exs` line 39 specifies `{:mariaex, "~>0.8.2"}`. The PASS1 checklist explicitly flags mariaex 0.8.2 as deprecated with no security support. The locked version 0.8.4 is in the same deprecated 0.8.x series. This library should be replaced with `myxql`, the current Elixir MySQL/MariaDB adapter, which is maintained and receives security updates.

**Finding A143-16 (MEDIUM) — elixir_xml_to_map pinned to 0.2.0, which is many major versions behind current (3.x)**

`mix.lock` line 21:
```
"elixir_xml_to_map": {:hex, :elixir_xml_to_map, "0.2.0", ...}
```

`mix.exs` line 52 specifies `{:elixir_xml_to_map, "~> 0.1"}`. The library is now at version 3.x. The 0.x series predates significant maintenance work. This should be updated to a current supported version.

**Finding A143-17 (MEDIUM) — Multiple dependencies are significantly out of date**

The following locked versions are substantially older than current releases, increasing the risk of unpatched vulnerabilities:

| Dependency | Locked Version | Current series | Note |
|---|---|---|------|
| `phoenix` | 1.5.13 | 1.7.x | Multiple security and bug fixes |
| `guardian` | 1.2.1 | 2.x | Major version behind |
| `ecto` | 2.2.12 | 3.x | Major version behind |
| `cowboy` | 1.1.2 | 2.x | Major version behind |
| `plug` | 1.13.6 | 1.16.x | Several patch updates |
| `httpoison` | 1.6.2 | 2.x | Major version behind |

**Finding A143-18 (INFO) — geonames dependency loaded from a local path, not hex.pm**

`mix.exs` line 56:
```elixir
{:geonames, path: "geonames-elixir"},
```

This dependency is loaded from a local filesystem path. It is not fetched from hex.pm and is not covered by `mix.lock` in the standard way. This makes it impossible to audit its provenance or verify its contents against a known hash. The contents of `geonames-elixir/` should be reviewed separately.

---

### §7: Infrastructure Exposure

**Finding A143-19 (MEDIUM) — AWS region and service endpoint hardcoded in config.exs**

`config/config.exs` line 113:
```elixir
server: "email-smtp.us-west-2.amazonaws.com",
```

The AWS region `us-west-2` is disclosed in source. See also A143-1 and A143-5.

**§7 (CORS, CSP, TLS, check_origin):** These are configured in the endpoint file, which is not an assigned file. Findings A143-12 and A143-13 are noted above from supporting context. No TLS termination configuration was observed in the assigned files.

---

## Summary of Findings

| ID | Severity | File | Description |
|----|----------|------|-------------|
| A143-1 | CRITICAL | `config/config.exs` | Hardcoded AWS SMTP credentials (live + former) in tracked file |
| A143-2 | CRITICAL | `config/config.exs` | Hardcoded `secret_key_base` in tracked file |
| A143-3 | CRITICAL | `config/config.exs` | Hardcoded Guardian JWT signing secret in tracked file |
| A143-4 | HIGH | `config/config.exs` | Guardian TTL set to 52 weeks — tokens valid for one year |
| A143-5 | INFO | `config/config.exs` | AWS region hardcoded, reveals infrastructure topology |
| A143-6 | CRITICAL | `router.ex` | Two routes serving fleet data with no authentication guard |
| A143-7 | HIGH | `vx/vx_user.ex` | Plaintext password field `aacpassword` in schema; no hashing in changeset |
| A143-8 | MEDIUM | `config/config.exs` | No JWT revocation mechanism; 52-week TTL compounds risk |
| A143-9 | HIGH | `xml_plug.ex` | `xml_decoder` option accepted but silently ignored; declared intent not honoured |
| A143-10 | MEDIUM | `xml_plug.ex` | No explicit XML body size cap; DoS amplification risk |
| A143-11 | MEDIUM | `xml_plug.ex` | Unreachable dead code arm in `decode/2`; error handling logic unclear |
| A143-12 | HIGH | `endpoint.ex` | Session cookie missing `secure`, `http_only`, `same_site` flags |
| A143-13 | MEDIUM | `endpoint.ex` | CORSPlug applied globally with no visible origin restriction |
| A143-14 | INFO | `vx_user_view.ex` | Plaintext password field in scope; allowlist is the only guard against accidental exposure |
| A143-15 | HIGH | `mix.lock` / `mix.exs` | mariaex 0.8.4 is deprecated, no security support |
| A143-16 | MEDIUM | `mix.lock` / `mix.exs` | elixir_xml_to_map 0.2.0 is many major versions behind (now 3.x) |
| A143-17 | MEDIUM | `mix.lock` / `mix.exs` | Multiple core dependencies significantly out of date |
| A143-18 | INFO | `mix.exs` | geonames loaded from local path, not hex.pm; provenance unverifiable |
| A143-19 | MEDIUM | `config/config.exs` | AWS region and SES endpoint hardcoded |

---

## XXE Assessment for xml_plug.ex

Per the specific instruction to assess XML injection and XXE in `xml_plug.ex`:

`XmlToMap.naive_map/1` (version 0.2.0, backed by erlsom 1.5.0) uses `erlsom:simple_form/1` internally. Erlsom does **not** resolve external entities; it is not a wrapper around xmerl. Based on published research ([vuln.be XXE in Erlang and Elixir](https://vuln.be/post/xxe-in-erlang-and-elixir/)) and erlsom's design, the XML parsing path through `XmlToMap.naive_map/1` is **not vulnerable to XXE** as erlsom does not expand external entity references.

However, two caveats apply:

1. The endpoint configuration (`endpoint.ex` line 28) specifies `xml_decoder: :xmerl_scan`. The `xmerl` library **is** vulnerable to XXE by default in older Erlang/OTP versions (the `allow_entities` default was only changed to `false` in a recent OTP release — [erlang/otp issue #7539](https://github.com/erlang/otp/issues/7539)). The xml_plug currently ignores this option entirely (finding A143-9), so xmerl is never actually invoked. However, if the `decode/2` function were ever corrected to honour the `decoder` option and pass through to `:xmerl_scan`, an XXE vulnerability would be introduced unless xmerl's entity expansion is explicitly disabled.

2. `XmlToMap.naive_map/1` is "naive" by design — it does not preserve XML namespaces or handle all XML constructs. Malformed or deeply nested XML could cause unexpected map structures that downstream code may handle incorrectly. No specific injection vector was identified in the assigned file.

**XXE conclusion:** The current code path is not directly exploitable for XXE. The risk of inadvertent XXE introduction upon any fix of finding A143-9 must be explicitly managed.

---

*Report by agent A143. No source files were modified. All findings are observations only.*
