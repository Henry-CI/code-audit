# Security Audit — Pass 1
**Agent:** A077
**Repo:** api_server
**Stack:** Elixir/Phoenix
**Branch:** master
**Run:** 2026-02-27-01

---

## Assigned Files

1. `lib/api_server/vx/vx_fleet.ex`
2. `lib/api_server/vx/vx_fleet_association.ex`
3. `lib/api_server/vx/vx_rayven_message_log.ex`

---

## File 1: `lib/api_server/vx/vx_fleet.ex`

### Reading Evidence

**Module name:** `ApiServer.Vx.VXFleet`

**Public functions:**

| Name | Arity | Line |
|------|-------|------|
| `convert_json_to_changeset` | 1 | 19 |
| `changeset` | 2 | 27 |

**Schema defined:** `schema "aae_group"` with `@primary_key {:aaeid, :id, autogenerate: true}`

Schema fields:
- `:aaeid` (primary key, integer, autogenerate)
- `:aaecustcode` — `:string`
- `:aaedesc` — `:string`
- `:aaecolour` — `:string`
- `:aaetype` — `:integer`
- `:aaeshowfilter` — `:boolean`
- `has_many :fleet_thing_joins` → `ApiServer.Vx.VXFleetAssociation`, foreign_key `:aafgroupid`, `on_delete: :delete_all`

**use / import / alias at module level:**
- `use Ecto.Schema`
- `import Ecto.Changeset`
- `alias ApiServer.Vx`

---

### Checklist Review

**§1 Secrets and Configuration:** No secrets, credentials, API keys, or environment variable access in this file.
§1: No issues found.

**§2 Authentication and Authorization:**
The `changeset/2` function casts `:aaedesc`, `:aaecolour`, `:aaetype`, `:aaeshowfilter` and validates only `:aaedesc` as required. The `:aaecustcode` field is defined in the schema but is **not included in the cast list** in `changeset/2`, which means it cannot be set or updated via the standard changeset path. This is noted as an observation but not a direct security flaw in this schema file.

The `convert_json_to_changeset/1` function accepts a raw JSON map and extracts `fleet_json["name"]`, `fleet_json["color"]`, `fleet_json["type"]`, `fleet_json["show_in_filters"]` by string key. No validation or type-checking is performed on these values before constructing the attribute map. The caller (`VXFleetController.create_fleet/2` and `update_fleet/2`) passes the resulting map directly into `VXFleet.changeset/2` and then into `Vx.update_vx_fleet/3` or `Vx.create_vx_fleet/2`. Ecto's `cast/3` provides type coercion and will reject bad values at the changeset layer, which partially mitigates this, but there are no explicit format or length validations on `:aaecolour`, `:aaetype`, or `:aaeshowfilter`.

§2: No issues found (authorization is enforced at the controller/context level, not in this schema module).

**§3 Input Validation and Injection:**
`convert_json_to_changeset/1` does not validate the `type` field (`:aaetype`, integer) or the `color` field (`:aaecolour`, string) for acceptable values or lengths. There is no `validate_inclusion/3` on `:aaetype` to restrict it to known fleet type values, and no `validate_format` or `validate_length` on `:aaecolour`. Ecto will perform a type cast but will not reject arbitrarily long strings.

§3: See finding A077-1.

**§4 Session and CSRF:** Not applicable to this schema module.
§4: No issues found.

**§5 File and Data Handling:** No file operations. No Logger calls with fleet data in this file.
§5: No issues found.

**§6 Dependencies:** Not applicable to this module.
§6: No issues found.

**§7 Infrastructure Exposure:** No hostnames, IPs, or service URLs.
§7: No issues found.

---

## File 2: `lib/api_server/vx/vx_fleet_association.ex`

### Reading Evidence

**Module name:** `ApiServer.Vx.VXFleetAssociation`

**Public functions:** None (no `def` declarations; this is a pure schema module).

**Schema defined:** `schema "aaf_groups_things"` with `@primary_key {:aafid, :id, autogenerate: true}`

Schema fields:
- `:aafid` (primary key, integer, autogenerate)
- `:aafcustcode` — `:string`
- `belongs_to :fleet` → `ApiServer.Vx.VXFleet`, foreign_key `:aafgroupid`, references `:aaeid`
- `belongs_to :thing` → `ApiServer.Vx.VXThing`, foreign_key `:aafthingid`, references `:aadid`

**use / import / alias at module level:**
- `require Ecto.Query` (file-level, outside the module, line 1)
- `require Ecto.Adapters.SQL` (file-level, outside the module, line 2)
- `use Ecto.Schema` (inside module)

**No changeset function defined.**

---

### Checklist Review

**§1 Secrets and Configuration:** No secrets or credentials.
§1: No issues found.

**§2 Authentication and Authorization:**
The `[REDACTED-AWS-SMTP-PASSWORD]` (`lib/api_server_web/controllers/vx_fleet_association_controller.ex`) defines `index/2`, `show/2`, and `delete/2` actions that use this schema. These actions call `Vx.list_vxfleetassociations/0`, `Vx.get_vx_fleet_association!/1`, and `Vx.delete_vx_fleet_association/1` — **none of which scope by customer or authenticated user**. However, this controller is **not wired into the router** (`lib/api_server_web/router.ex` contains no reference to `[REDACTED-AWS-SMTP-PASSWORD]`). The controller appears to be dead/unused code. This is an important observation in the event it is ever added to the router without additional scoping.

§2: See finding A077-2.

**§3 Input Validation and Injection:**
`require Ecto.Adapters.SQL` appears at file scope (lines 1-2, outside the `defmodule` block). This is a structural anomaly — the `require` directives are placed before the module definition rather than inside it. While this is technically valid Elixir (the macros are available to the file), it is non-idiomatic and suggests the file may have been edited hastily or intended for direct SQL queries that were never completed or were removed. No actual `Ecto.Adapters.SQL.query` calls exist in this file.

No changeset is defined, so mass-assignment protection is absent. In `Vx.update_fleet_assocs/3`, `Repo.insert_all/3` is called with caller-supplied maps containing `:aafgroupid` and `:aafthingid` derived from user input — the fleet_id from the URL parameter and the `ids_in_fleet` list from the request body. The `aafgroupid` is constructed via `String.to_integer(fleet_id)` in the controller, which will raise an `ArgumentError` on non-integer input (no rescue), potentially causing a 500 response. The `aafthingid` values are taken directly from `ids_in_fleet` without type-checking.

§3: See findings A077-3, A077-4.

**§4 Session and CSRF:** Not applicable to this schema module.
§4: No issues found.

**§5 File and Data Handling:** No file operations, no Logger calls.
§5: No issues found.

**§6 Dependencies:** Not applicable to this module.
§6: No issues found.

**§7 Infrastructure Exposure:** No hostnames, IPs, or service URLs.
§7: No issues found.

---

## File 3: `lib/api_server/vx/vx_rayven_message_log.ex`

### Reading Evidence

**Module name:** `ApiServer.Vx.VXRayvenMessageLog`

**Public functions:**

| Name | Arity | Line |
|------|-------|------|
| `changeset` | 2 | 16 |

**Schema defined:** `schema "rayven_message_log"` with `@primary_key {:message_id, :id, autogenerate: true}`

Schema fields:
- `:message_id` (primary key, integer, autogenerate)
- `:message_direction` — `:string`
- `:message_type` — `:string`
- `:hardware_id` — `:integer`
- `:event_id` — `:integer`
- `:response` — `:string`
- `:message` — `:string`
- `:created` — `:utc_datetime`

**use / import / alias at module level:**
- `use Ecto.Schema`
- `import Ecto.Changeset`

---

### Checklist Review

**§1 Secrets and Configuration:** No secrets or credentials.
§1: No issues found.

**§2 Authentication and Authorization:** Schema/changeset module; no authorization logic expected here.
§2: No issues found.

**§3 Input Validation and Injection:**
`changeset/2` casts `:message_direction`, `:message_type`, `:hardware_id`, `:event_id`, `:response`, `:message` but calls **no `validate_required/2`** and **no field-level validations** (no `validate_inclusion`, `validate_length`, `validate_format`). In particular:

- `:message_direction` and `:message_type` are free-form strings with no enumeration constraint. Any caller can insert arbitrary direction/type labels.
- `:response` and `:message` are unbounded strings. The `:message` field stores what appears to be a URL (`"https://my.rayven.io:8082"` observed in usage) but there is no length limit or format validation.
- `:created` is **not in the cast list**, meaning it must be set elsewhere (likely via database default) — this is acceptable.

The `:message` field stores a Rayven API endpoint URL. If the URL is ever constructed from external/user input upstream, the absence of format validation on this field is a concern.

§3: See finding A077-5.

**§4 Session and CSRF:** Not applicable to this schema module.
§4: No issues found.

**§5 File and Data Handling:**
The schema stores `:hardware_id` (equipment identifier) and `:event_id` (telemetry event). These are operational data fields. The table is queried in `utility_controller.ex` and `tcp.ex` without filtering by customer in the base queries when accessed via the context functions — but those queries do supply `prefix: customer` (Ecto multi-tenancy via schema prefix). The `:message` field stores Rayven API URLs which may encode endpoint information. No PII (driver names, GPS coordinates) is stored in this schema.
§5: No issues found.

**§6 Dependencies:** Not applicable to this module.
§6: No issues found.

**§7 Infrastructure Exposure:**
The `:message` field in the schema is used to store the Rayven API endpoint URL (`"https://my.rayven.io:8082"`) in log records. This is stored in the database, not hardcoded in this file. No hostnames or IPs are hardcoded in the schema itself.
§7: No issues found.

---

## Findings

### A077-1
**Severity:** LOW
**File:** `lib/api_server/vx/vx_fleet.ex`
**Location:** `changeset/2` (line 27–31), `convert_json_to_changeset/1` (line 19–25)
**Description:** The `changeset/2` function applies only a single `validate_required([:aaedesc])` validation. The fields `:aaecolour`, `:aaetype`, and `:aaeshowfilter` have no format, length, or inclusion constraints. `:aaetype` accepts any integer; no enumeration of valid fleet types is enforced at the schema level. `:aaecolour` accepts any string of any length, allowing very long values to reach the database. `convert_json_to_changeset/1` performs no pre-validation of the incoming JSON map values before constructing the attribute map.
**Risk:** Unexpected integer values for `:aaetype` could cause display or logic errors in consumers. Arbitrarily long strings for `:aaecolour` may cause database truncation errors or unexpected behaviour depending on column definition.
**Recommendation:** Add `validate_inclusion(:aaetype, [valid_type_ids])` and `validate_length(:aaecolour, max: N)` to `changeset/2`. Consider adding a `validate_format` for colour values (e.g. hex colour codes).

---

### A077-2
**Severity:** HIGH
**File:** `lib/api_server/vx/vx_fleet_association.ex` (schema); `lib/api_server_web/controllers/vx_fleet_association_controller.ex` (controller)
**Location:** Controller `index/2` (line 9–12), `show/2` (line 14–17), `delete/2` (line 19–24)
**Description:** `[REDACTED-AWS-SMTP-PASSWORD]` contains three actions that operate on fleet association records without any customer scoping or ownership verification:
- `index/2` calls `Vx.list_vxfleetassociations/0` which returns all associations across all customers (no `prefix:` tenant filter, no authentication claim checked).
- `show/2` calls `Vx.get_vx_fleet_association!/1` with a bare ID, returning a record regardless of which customer it belongs to.
- `delete/2` calls `Vx.delete_vx_fleet_association/1` on any record retrieved by bare ID.

The controller is currently not registered in `router.ex` and therefore these routes are not accessible. However, the controller exists in the codebase and could be inadvertently enabled in a future router change, immediately creating cross-customer data exposure (IDOR) and unauthenticated cross-tenant deletion vulnerabilities.
**Risk:** If routes are added to the router, any authenticated user could enumerate and delete fleet associations belonging to other customers.
**Recommendation:** Either delete this controller entirely if it is not needed, or add customer-scoped versions of all three context functions and verify authentication claims before any operation. Do not add routes for this controller until ownership checks are implemented.

---

### A077-3
**Severity:** MEDIUM
**File:** `lib/api_server/vx/vx_fleet_association.ex` (schema); used via `lib/api_server_web/controllers/vx_fleet_controller.ex` `manage_fleet/2` action
**Location:** Controller `manage_fleet/2` (lines 110–117); `Vx.update_fleet_assocs/3` in `vx.ex` (lines 378–390)
**Description:** In `manage_fleet/2`, `ids_in_fleet` is taken directly from the request body (`%{"equip_in_fleet" => ids_in_fleet}`) and mapped into association structs without type validation:
```elixir
formatted = ids_in_fleet
  |> Enum.map(fn(id) -> %{aafgroupid: String.to_integer(fleet_id), aafthingid: id} end)
```
The `aafthingid` values are used directly as-is (no `String.to_integer` call, no type coercion). These are passed to `Repo.insert_all/3` which bypasses Ecto changeset validation entirely. If the database column is typed as integer but a string is supplied, this may cause a runtime database error. More importantly, the fleet_id URL parameter is converted with `String.to_integer(fleet_id)` (no rescue), which raises `ArgumentError` on non-numeric input rather than returning a controlled error response, leaking an unhandled exception through to the fallback controller.

Additionally, the `customer` parameter in `manage_fleet/2` comes from the URL path (`%{"customer" => customer, ...}`), not from the authenticated JWT claims. There is no verification that the `customer` value in the URL matches the authenticated user's customer claim. An authenticated user from one customer can supply another customer's identifier in the URL and manage fleets in that tenant.
**Risk:** Cross-tenant fleet association manipulation. Authenticated users can modify fleet memberships in other customers' databases by supplying a different `customer` path parameter.
**Recommendation:** Replace `customer` URL parameter with the value from `ApiServer.Guardian.Plug.current_claims(conn)["customer"]` (as done in `get_fleets/2`). Wrap `String.to_integer(fleet_id)` in a rescue or use a pattern match to return a 400 error on non-integer input. Add a changeset for `VXFleetAssociation` and use it in `insert_all` or switch to individual `insert` calls with changeset validation.

---

### A077-4
**Severity:** MEDIUM
**File:** `lib/api_server/vx/vx_fleet_association.ex`
**Location:** Lines 1–2 (file scope, outside `defmodule`)
**Description:** `require Ecto.Query` and `require Ecto.Adapters.SQL` appear at file scope, outside the `defmodule ApiServer.Vx.VXFleetAssociation do` block. This is non-idiomatic and indicates the file was prepared for direct raw SQL execution (via `Ecto.Adapters.SQL.query/3`) that was either never implemented or subsequently removed. The presence of `require Ecto.Adapters.SQL` at module top-level is a code smell that warrants a review of the git history to determine whether raw SQL was removed cleanly or whether fragments remain elsewhere in the codebase using this schema.
**Risk:** Low direct risk in the current state (no SQL execution calls present). However, the pattern suggests intent for raw SQL that may reappear. If `Ecto.Adapters.SQL.query/3` is used with string interpolation of user-controlled values (e.g. `fleet_id` or `customer`), SQL injection would result.
**Recommendation:** Remove the out-of-module `require` directives. If `Ecto.Adapters.SQL` is genuinely needed, place it inside the module. Review git history to confirm that any previously present raw SQL was removed and did not rely on string interpolation of user input.

---

### A077-5
**Severity:** LOW
**File:** `lib/api_server/vx/vx_rayven_message_log.ex`
**Location:** `changeset/2` (lines 16–19)
**Description:** The `changeset/2` function casts six fields but applies no `validate_required/2` and no field-level validations. Specifically:
- `:message_direction` and `:message_type` have no `validate_inclusion` constraint. Any arbitrary string can be stored, making log queries that filter by these fields unreliable.
- `:message` is an unbounded string. In observed usage it stores a URL (`"https://my.rayven.io:8082"`), but the field could accept arbitrarily large payloads with no length guard.
- `:response` is an unbounded string storing `inspect(status)` values; again no length limit.
**Risk:** Without length constraints, a programming error upstream that passes an unexpectedly large value (e.g. a full response body) could cause performance issues or exceed database column limits silently. Without enumeration constraints on `:message_direction` / `:message_type`, log integrity for audit/monitoring purposes is weakened.
**Recommendation:** Add `validate_required([:message_direction, :message_type, :hardware_id])`, `validate_inclusion(:message_direction, ["sent-tags", "received", ...])`, `validate_inclusion(:message_type, ["event", ...])`, and `validate_length(:message, max: 2048)` or similar appropriate limits to `changeset/2`.

---

### A077-6
**Severity:** MEDIUM
**File:** `lib/api_server_web/controllers/vx_fleet_controller.ex` (controller for `VXFleet` schema)
**Location:** `create_fleet/2` (line 68), `delete_fleet/2` (line 91), `get_equipment_in_fleet/2` (line 105), `manage_fleet/2` (line 110), `update_fleet/2` (line 119)
**Description:** Multiple fleet controller actions accept `customer` as a URL path parameter and pass it directly to context functions as the database schema prefix without verifying it matches the authenticated user's `customer` claim from the JWT. For example:

```elixir
def delete_fleet(conn, %{"customer" => customer, "id" => id}) do
    vx_fleet = Vx.get_vx_fleet(id, customer)
    ...
    Vx.delete_vx_fleet(vx_fleet, customer)
```

The authenticated user's customer is available via `ApiServer.Guardian.Plug.current_claims(conn)["customer"]` but is not consulted. An authenticated user from customer `vx_abc` can pass `customer=vx_xyz` in the URL to read, create, update, or delete fleets belonging to `vx_xyz`.

By contrast, `get_fleets/2` (both clauses) and `get_fleets_with_equipment/2` correctly derive `customer` from JWT claims only. The inconsistency is a systematic IDOR vulnerability across the write/mutate and some read paths.
**Risk:** Cross-customer fleet data disclosure and modification. Any authenticated user can enumerate, create, update, delete fleets and manage equipment assignments in any other customer's database partition by simply supplying a different `customer` value in the URL.
**Recommendation:** Remove the `customer` URL parameter from all fleet endpoints and derive it exclusively from `ApiServer.Guardian.Plug.current_claims(conn)["customer"]`, matching the pattern already used in `get_fleets/2`.

---

### A077-7
**Severity:** MEDIUM
**File:** `lib/api_server_web/controllers/vx_fleet_controller.ex`
**Location:** `get_fleets/2` admin clause (lines 19–23), router `lib/api_server_web/router.ex` (line 103)
**Description:** The `get_fleets/2` action has two clauses. The first clause matches when the query parameter `admin=1` is present, and it returns **all fleets for the customer** without user-level scoping. The second clause (no `admin` parameter) returns only fleets accessible to the authenticated user.

The guard for the admin-all-fleets path is simply the presence of `"admin" => "1"` in the request parameters — this is a **client-supplied query parameter**, not a server-verified role or claim. Any authenticated user (regardless of their actual role) can append `?admin=1` to the `GET /api/v1/rhm/fleets` request and receive all customer fleets, bypassing the user-scoping that the second clause enforces.

There is no check against a JWT claim (e.g. `claims["role"] == "admin"`) or any other server-side authoritative source to verify the requester has administrative privileges.
**Risk:** Any authenticated user can bypass fleet visibility restrictions and enumerate all fleets within their customer partition by appending `?admin=1`.
**Recommendation:** Remove the query-parameter-based admin bypass. If an admin-all-fleets view is genuinely needed, gate it on a verifiable JWT claim (`claims["role"]` or similar) rather than a client-supplied parameter.

---

### A077-8
**Severity:** LOW
**File:** `lib/api_server_web/controllers/vx_fleet_controller.ex`
**Location:** `create_fleet/2` line 86, `update_fleet/2` line 129
**Description:** Error responses include the raw output of `inspect(changeset)` or `inspect(result)` interpolated directly into the JSON error body returned to the client:

```elixir
send_resp(conn, :internal_server_error, "{\"error\": \"error inserting update\", \"reason\": \"#{inspect changeset}\" }")
```

`inspect/1` on an Ecto Changeset can expose: field names, database column names, internal validation error atoms, and possibly partial data values that were submitted. This constitutes internal implementation disclosure in error responses.
**Risk:** Leaking internal schema field names and Ecto internals to API clients. In a multi-tenant fleet management context, this could expose column names or partial data that assists an attacker in crafting further requests.
**Recommendation:** Replace `inspect changeset` / `inspect result` with a user-facing message such as `"Validation failed"` or a structured error derived from `Ecto.Changeset.traverse_errors/2`. Log the full changeset server-side via `Logger.error/2` instead.

---

## Summary Table

| ID | Severity | File(s) | Topic |
|----|----------|---------|-------|
| A077-1 | LOW | `vx_fleet.ex` | Missing changeset validations on `:aaetype`, `:aaecolour` |
| A077-2 | HIGH | `vx_fleet_association.ex` / `vx_fleet_association_controller.ex` | Dead controller with no customer scoping — cross-tenant IDOR if routes ever enabled |
| A077-3 | MEDIUM | `vx_fleet_association.ex` (via `vx_fleet_controller.ex`) | `manage_fleet` uses URL `customer` param, no validation on `ids_in_fleet`, unhandled `String.to_integer` exception |
| A077-4 | MEDIUM | `vx_fleet_association.ex` | `require Ecto.Adapters.SQL` at file scope outside module — indicates removed raw SQL, verify no interpolation-based SQL remains |
| A077-5 | LOW | `vx_rayven_message_log.ex` | No `validate_required` or field constraints in `changeset/2` |
| A077-6 | MEDIUM | `vx_fleet_controller.ex` (VXFleet schema consumer) | `customer` URL param used instead of JWT claim on write/mutate fleet endpoints — cross-tenant IDOR |
| A077-7 | MEDIUM | `vx_fleet_controller.ex` | `?admin=1` query param bypasses user-scoped fleet visibility — no server-side role verification |
| A077-8 | LOW | `vx_fleet_controller.ex` | `inspect(changeset)` exposed in error responses — internal schema disclosure |
