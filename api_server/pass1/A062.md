# Audit Report A062
**Agent:** A062
**Run:** 2026-02-27-01
**Stack:** Elixir/Phoenix — api_server
**Branch:** master
**Date:** 2026-02-27

---

## Assigned Files

1. `lib/api_server/tcp/tcp_commands.ex`
2. `lib/api_server/vx/device_database_lookup.ex`
3. `lib/api_server/vx/email.ex`

---

## Reading Evidence

---

### File 1: `lib/api_server/tcp/tcp_commands.ex`

**Module name:** `ApiServer.TCP.Commands`

**`use` / `import` / `alias` at module level:**
- `import Ecto.Query, warn: false` (line 2)
- `alias ApiServer.FortyNineRepo` (line 3)
- `alias ApiServer.FortyNine.CalampPositionEvents` (line 4)
- `alias ApiServer.FortyNine.WebServicePositionQueue` (line 5)
- `alias ApiServer.Vx.DeviceDatabaseLookup` (line 6)
- `alias ApiServerWeb.UtilityController` (line 7)

**Public functions (`def`):**

| Name | Arity | Line |
|------|-------|------|
| `parse_hello_message` | 1 | 9 |
| `parse_data_message` | 3 | 35 |
| `parse_debug_record` | 3 | 120 |
| `parse_data_record` | 3 | 158 |
| `parse_debug_field` | 1 | 1325 |
| `parse_gps_field` | 1 | 1331 |
| `parse_digital_field` | 1 | 1385 |
| `parse_analog_field` | 1 | 1454 |
| `parse_analog32_field` | 1 | 1470 |
| `parse_trip_field` | 1 | 1541 |
| `parse_total_field` | 1 | 1556 |
| `parse_driverid_field` | 1 | 1571 |
| `parse_commit_message` | 2 | 1673 |
| `parse_iridium` | 2 | 1679 |
| `parse` | 2 | 1903 |
| `run` | 1 (header) | 1959 |
| `run` (hello clause) | 1 | 1961 |
| `run` (commit clause) | 1 | 1966 |
| `run` (data clause) | 1 | 1976 |
| `run` (close clause) | 1 | 1982 |

**`defstruct` / `defexception` / `schema`:** None defined in this file.

---

### File 2: `lib/api_server/vx/device_database_lookup.ex`

**Module name:** `ApiServer.Vx.DeviceDatabaseLookup`

**`use` / `import` / `alias` at module level:**
- `use Ecto.Schema` (line 2)
- `import Ecto.Changeset` (line 3)

**Public functions (`def`):**

| Name | Arity | Line |
|------|-------|------|
| `changeset` | 2 | 13 |

**Schema defined:**
```
schema "DeviceDatabaseLookup" do
    field :hardwareid, :string, source: :hardwareID
    field :customer, :string, source: :databaseName
    field :custcode, :string, source: :CustCode
    field :iccid, :string, source: :ICCID
end
```
Primary key: `@primary_key {:ID, :id, autogenerate: true}` (line 5)

**`defstruct` / `defexception`:** None.

---

### File 3: `lib/api_server/vx/email.ex`

**Module name:** `ApiServer.Email`

**`use` / `import` / `alias` at module level:**
- `use Bamboo.Phoenix, view: ApiServer.EmailView` (line 2)

**Public functions (`def`):**

| Name | Arity | Line |
|------|-------|------|
| `send_notification_email` | 3 | 4 |
| `send_test_email` | 3 | 14 |
| `send_enter_email` | 4 | 103 |
| `send_missing_serial_email` | 4 | 167 |
| `send_digital_matter_email` | 4 | 215 |
| `send_slow_email` | 4 | 262 |
| `send_exit_email` | 4 | 303 |

**`defstruct` / `defexception` / `schema`:** None.

---

## Checklist Review

---

### §1: Secrets and Configuration

**FINDING A062-1 — CRITICAL: Hardcoded third-party service password in source code**

File: `lib/api_server/tcp/tcp_commands.ex`, lines 1221–1222 and 1305–1306 (also 1891–1892 in `parse_iridium`)

The password `@trility!` for the downstream web service (`WSUSERNAME: "trility"`) is hardcoded directly in the source in three locations — once in `parse_data_record` (for integer serial match, line ~1221), once for string serial match (line ~1306), and once in `parse_iridium` (line ~1891):

```elixir
WSUSERNAME: "trility",
WSPASSWORD: "@trility!",
CONNECTIONNAME: "SVR49"
```

This credential is stored in the `[REDACTED-AWS-SMTP-PASSWORD]` table (field `WSPASSWORD`) and is written to the `FortyNineRepo` database, meaning it persists in plaintext in database rows. The password is also visible in version control history on any branch where this code was committed.

**FINDING A062-2 — MEDIUM: Hardcoded internal service username in source code**

Same locations as A062-1. `WSUSERNAME: "trility"` and `MOBILENAME: "1234"` are hardcoded credentials passed to the downstream FortyNine service. While the risk is lower than A062-1 (username alone without password), these values reveal service account names and should be read from application configuration, not compiled into the binary.

**FINDING A062-3 — MEDIUM: Hardcoded customer code and service endpoint identifier in source code**

File: `lib/api_server/tcp/tcp_commands.ex`, lines 1787 and 1810 (in `parse_iridium`)

```elixir
custcode: "TRILITY",
...
customer = "vx_trility"
```

The Iridium parser hardcodes the customer code and database name `"vx_trility"` rather than deriving them from the device lookup. This means all Iridium-origin data is unconditionally attributed to a single hardcoded customer, bypassing the device lookup that the rest of the codebase uses. If this string were ever rotated or if the mapping changes, the code would silently misdirect data.

**FINDING A062-4 — LOW: Hardcoded hardware ID in `parse_iridium`**

File: `lib/api_server/tcp/tcp_commands.ex`, line 1756:

```elixir
hardware_id = 462_743
```

The Iridium parser ignores the device-identity data carried in the parsed Iridium message and instead unconditionally assigns a single hardcoded serial number. This is a logic defect with a security dimension: all Iridium satellite messages are attributed to device 462743 regardless of which device actually sent them.

---

### §2: Authentication and Authorization

**FINDING A062-5 — HIGH: No authentication on TCP device connection; device identity accepted without verification**

File: `lib/api_server/tcp/tcp_commands.ex`, `parse_hello_message` (line 9)

The hello message handler accepts the serial number claimed in the binary payload at face value. After resolving the device via `UtilityController.device_lookup_with_hardware_id/1`, it immediately returns `{:ok, {:send, "hello", params}}` without any challenge-response, shared secret, TLS client certificate, or token verification. Any TCP client that sends a valid 4-byte little-endian serial number corresponding to a known device will be accepted as that device and its subsequent data records will be written to that device's account in the database.

**FINDING A062-6 — HIGH: Device data written to customer database with no per-customer boundary check**

File: `lib/api_server/tcp/tcp_commands.ex`, `parse_data_record` (around line 1119)

After building `thing_event`, the code calls:

```elixir
case ApiServer.Vx.get_vx_thing_with_hardware_id!(hardware_id, customer) do
  nil -> ""
  thing ->
    ApiServer.Vx.create_thingevent_record(to_save, customer)
```

The `customer` value originates from the device lookup table (`device.customer`, line 1025), which is populated from `[REDACTED-AWS-SMTP-PASSWORD]`. A spoofed serial number (the device provides its own serial in the hello message — see A062-5) can redirect event writes to any customer's database.

---

### §3: Input Validation and Injection

**FINDING A062-7 — HIGH: Binary parser performs no length bounds validation before fixed-size binary pattern match**

File: `lib/api_server/tcp/tcp_commands.ex`, multiple locations throughout the file.

Throughout `parse_hello_message`, `parse_data_message`, `parse_data_record`, `parse_gps_field`, `parse_trip_field`, `parse_total_field`, `parse_driverid_field`, and `parse_iridium`, the code uses fixed-size binary pattern matches such as:

```elixir
<<serial_number::bytes-size(4), modem_imei::bytes-size(16), sim_serial::bytes-size(21),
  product_id::bytes-size(1), hardware_revision::bytes-size(1), firmware_major::bytes-size(1),
  firmware_minor::bytes-size(1), flags::bytes-size(4), leftover::binary>> = remainder
```

Elixir pattern-matching on binary with `= remainder` raises a `MatchError` (and consequently crashes the current process) if `remainder` is shorter than the sum of the fixed-size fields. Because these functions are called from a TCP server process handling device input, a malicious or malfunctioning device sending a truncated packet will crash the handler process. Depending on the supervision strategy, this could be repeated to cause persistent disruption (denial of service).

There is no guard clause, `byte_size/1` pre-check, or `case` wrapper to produce a graceful `{:error, :malformed}` result.

**FINDING A062-8 — MEDIUM: `IO.puts` / `IO.inspect` used extensively for operational logging, including PII/fleet data**

File: `lib/api_server/tcp/tcp_commands.ex`, lines 25, 304–306, 381–383, 463–465, 553–555, 607–609, 640–642, 672–675, 769–771, 819–821, 1130, 1492, 1667, 1825.

Examples:

```elixir
IO.puts("Could not find device: #{inspect(serial)}")
IO.puts("Test unit 625425 found analog32 in field 4 #{inspect(field_four_data)}")
IO.puts("Analog values: #{inspect(analog_values)}")
IO.puts("driverid info parsed: type: #{driverid_type} data: #{driverid_data_encoded} final payload: #{inspect(driverid_parsed)}")
IO.inspect(error)
```

`IO.puts`/`IO.inspect` writes to stdout; in a production release this typically reaches the system journal or a log aggregator. Driver ID values (biometric identifiers — iButton and Weigand RFID card numbers), device serial numbers, GPS coordinates, and analog sensor readings are all emitted to stdout. This is PII and fleet-operations data that should not appear uncontrolled in logs. The `Logger` module with appropriate log levels should be used instead; production log levels can then suppress debug output without a code change.

**FINDING A062-9 — LOW: `parse_data_record` uses signed integer decoding for field lengths that are logically unsigned**

File: `lib/api_server/tcp/tcp_commands.ex`, lines 220–228 (field two length), 247–249 (field three), and several later field parsers.

Some field-length bytes are decoded as `little-signed-integer-size(8)` or `little-signed-integer-size(16)`. If the high bit of a length byte is set (values > 127 for 8-bit, > 32767 for 16-bit), the decoded length becomes negative. A subsequent `bytes-size(actual_field_length)` pattern match with a negative size raises a `FunctionClauseError` or `ArgumentError`, crashing the process. Wire-protocol field lengths should always be decoded as unsigned.

---

### §4: Session and CSRF

This module is a pure TCP binary-protocol parser with no HTTP session or CSRF surface. No Phoenix channels, cookies, or CSRF tokens are involved.

§4: No issues found.

---

### §5: File and Data Handling

**FINDING A062-10 — MEDIUM: Driver ID (biometric/RFID identifier) logged to stdout in plaintext**

File: `lib/api_server/tcp/tcp_commands.ex`, line 1666–1668:

```elixir
IO.puts(
  "driverid info parsed: type: #{driverid_type} data: #{driverid_data_encoded} final payload: #{inspect(driverid_parsed)}"
)
```

Driver ID data includes iButton serial numbers and Weigand RFID card numbers, which are used for driver identification and can constitute personal data under privacy legislation. Logging these to stdout in production exposes them in system logs and any log-aggregation tooling connected to the service.

**FINDING A062-11 — MEDIUM: `send_digital_matter_email` renders raw internal data struct directly into email HTML body**

File: `lib/api_server/vx/email.ex`, line 227:

```elixir
|> html_body("
  ...
  Data:<br><strong>"<> Kernel.inspect(data, limit: :infinity) <>"</strong><br>
  ...
")
```

`Kernel.inspect(data, limit: :infinity)` renders the full Elixir term representation of the `data` argument — whatever struct or map is passed — directly into the email HTML body with no sanitisation. If `data` contains HTML meta-characters (`<`, `>`, `&`, `"`) these will be rendered as raw HTML, which could produce misleading email content. More importantly, the `limit: :infinity` flag means arbitrarily large data structures will be serialised and included in the email body, which is a potential information-disclosure vector and could produce emails that are excessively large or contain internal system details. This function appears to be a debug/diagnostic email and should either be removed or have the data properly sanitised.

**FINDING A062-12 — LOW: `send_notification_email` ignores its `to` parameter; all notification emails are hardcoded to a single developer address**

File: `lib/api_server/vx/email.ex`, lines 4–12:

```elixir
def send_notification_email(to, subject, message) do
  from_email_address = "no-reply@mobilehourmeter.com"
  new_email()
  |> to("graham.oconnell@trackingsolutions.com.au")   # <-- hardcoded, ignores `to`
  |> from(from_email_address)
  ...
```

The function accepts a `to` parameter but ignores it, always sending to `graham.oconnell@trackingsolutions.com.au`. This is likely a development artefact that was never corrected before deployment. In production this means customer notification emails silently go to a developer rather than the intended recipient. The security concern is that customer-facing alert logic (geofence alerts, etc.) may silently fail to notify the correct party, and all such notifications are delivered to a single named individual's mailbox.

**FINDING A062-13 — LOW: Hardcoded image URL references a demo environment host in email templates**

File: `lib/api_server/vx/email.ex`, lines 46, 87, 152, 199, 246, 289, 336 (and similar):

```elixir
<img src='https://vx-demo.mobilehourmeter.com/img/logoleft_vx-demo.png'>
```

All email templates reference images hosted on `vx-demo.mobilehourmeter.com` — a demo/staging environment. If that host is unavailable or decommissioned, the production email logo will silently break. More relevantly for security, if the demo environment is controlled by a different party or becomes compromised, emails sent from the production system would load images from the attacker-controlled host, which enables email tracking pixel attacks and potential content substitution.

---

### §6: Dependencies

The assigned files do not contain dependency declarations. `mix.exs` and `mix.lock` are not in scope for this agent.

§6: No issues found in assigned files.

---

### §7: Infrastructure Exposure

**FINDING A062-14 — INFO: Internal service connection name `"SVR49"` hardcoded in source**

File: `lib/api_server/tcp/tcp_commands.ex`, lines 1222 and 1307 and 1892:

```elixir
CONNECTIONNAME: "SVR49"
```

This reveals the internal identifier for the FortyNine downstream service integration endpoint. Combined with the hardcoded username and password (A062-1, A062-2), this constitutes a complete set of credentials for the downstream service embedded in source. The connection name itself is low-risk in isolation but contributes to infrastructure topology disclosure in version control.

**FINDING A062-15 — INFO: Hardcoded list of production device serial numbers in source**

File: `lib/api_server/tcp/tcp_commands.ex`, lines 780–817 (yabby3 list), lines 888–904 and 1144–1160 (trility list), lines 1058 (special hardware IDs).

Large lists of production device serial numbers are hardcoded directly in the parsing logic. For example:

```elixir
when x in [598_608, 598_619, 598_627, 598_644, 598_646, 598_666, 598_673, 598_783,
           599_071, 599_307, 599_313, 599_314, 599_327, 599_336, 599_340, 550_798, ...]
```

These serial numbers identify specific physical devices deployed in the field for specific customers. Their presence in source (and therefore version control) exposes customer fleet asset enumeration data. An adversary with access to the repository can enumerate device serial numbers and spoof those devices on the TCP interface (see A062-5).

---

## Summary Table

| ID | Severity | File | Description |
|----|----------|------|-------------|
| A062-1 | CRITICAL | tcp_commands.ex | Hardcoded plaintext password `@trility!` for downstream FortyNine web service, persisted to database |
| A062-2 | MEDIUM | tcp_commands.ex | Hardcoded service username `trility` and mobile name `1234` in source |
| A062-3 | MEDIUM | tcp_commands.ex | Hardcoded customer code `TRILITY` / `vx_trility` in Iridium parser bypasses device lookup |
| A062-4 | LOW | tcp_commands.ex | Hardcoded hardware ID `462_743` in `parse_iridium`; all Iridium events attributed to one device |
| A062-5 | HIGH | tcp_commands.ex | No device authentication on TCP hello; device identity from unauthenticated binary payload |
| A062-6 | HIGH | tcp_commands.ex | Spoofed serial number can redirect event writes to arbitrary customer database |
| A062-7 | HIGH | tcp_commands.ex | Binary pattern match on device input without length guards; malformed packets crash process |
| A062-8 | MEDIUM | tcp_commands.ex | `IO.puts`/`IO.inspect` logs driver IDs, GPS coords, and serial numbers to stdout in production |
| A062-9 | LOW | tcp_commands.ex | Field lengths decoded as signed integers; values > 127 / > 32767 produce negative lengths and crash |
| A062-10 | MEDIUM | tcp_commands.ex | Driver ID (biometric RFID/iButton) logged to stdout in plaintext |
| A062-11 | MEDIUM | email.ex | `Kernel.inspect(data, limit: :infinity)` rendered into email HTML body without sanitisation |
| A062-12 | LOW | email.ex | `send_notification_email/3` ignores `to` parameter; all notifications go to hardcoded developer address |
| A062-13 | LOW | email.ex | Email image URLs reference demo environment host `vx-demo.mobilehourmeter.com` |
| A062-14 | INFO | tcp_commands.ex | Internal connection name `SVR49` hardcoded in source |
| A062-15 | INFO | tcp_commands.ex | Production device serial numbers enumerated in source, enabling asset disclosure and spoofing |
