# Security Audit Report — A098
**Agent:** A098
**Repo:** api_server
**Stack:** Elixir/Phoenix
**Branch:** master
**Run:** 2026-02-27-01
**Auditor:** Pass 1 Security Audit Agent A098

---

## Assigned Files

1. `lib/api_server_web/controllers/file_controller.ex`
2. `lib/api_server_web/controllers/geofence_controller.ex`
3. `lib/api_server_web/controllers/page_controller.ex`

---

## Reading Evidence

### File 1: `lib/api_server_web/controllers/file_controller.ex`

**Module name:** `ApiServerWeb.FileController`

**Public functions (def):**

| Name | Arity | Line |
|------|-------|------|
| `get_size` | 2 | 12 |
| `send_file_download` | 2 | 28 |

**Private functions (defp):**

| Name | Arity | Line |
|------|-------|------|
| `generate_binary_file_contents` | 1 | 42 |
| `check_crc` | 1 | 52 |

**defstruct / defexception / schema defined:** None

**use / import / alias at module level:**

```elixir
use ApiServerWeb, :controller
alias ApiServer.Operators
alias ApiServer.Operators.File
alias ApiServer.Vx
alias ApiServer.Vx.VXAccessFob
```

**action_fallback:** `ApiServerWeb.FallbackController`

---

### File 2: `lib/api_server_web/controllers/geofence_controller.ex`

**Module name:** `ApiServerWeb.GeofenceController`

**Public functions (def):**

| Name | Arity | Line |
|------|-------|------|
| `list_all_geofences` | 2 | 11 |
| `create_geofence` | 2 | 18 |
| `update_geofence` | 2 | 35 |
| `delete_geofence` | 2 | 57 |
| `process_things_geofences` | 2 | 73 |

**Private functions (defp):**

| Name | Arity | Line |
|------|-------|------|
| `check_geofences_for_unit` | 6 | 96 |
| `does_event_cause_geofence_events` | 4 | 115 |
| `check_event_for_left_events` | 6 (nil guard) | 132 |
| `check_event_for_left_events` | 6 | 133 |
| `check_event_for_entered_events` | 6 | 149 |
| `make_geofence_event` | 6 | 168 |
| `engine_hours_at_event` | 3 | 184 |

**defstruct / defexception / schema defined:** None

**use / import / alias at module level:**

```elixir
use ApiServerWeb, :controller
alias ApiServer.Vx
alias ApiServer.Vx.Geofence
import Ecto.Query, warn: false
alias ApiServer.Repo
```

---

### File 3: `lib/api_server_web/controllers/page_controller.ex`

**Module name:** `ApiServerWeb.PageController`

**Public functions (def):**

| Name | Arity | Line |
|------|-------|------|
| `index` | 2 | 4 |

**defstruct / defexception / schema defined:** None

**use / import / alias at module level:**

```elixir
use ApiServerWeb, :controller
```

---

## Checklist Review

### §1: Secrets and Configuration

Reviewed all three controller files for hardcoded credentials, API keys, secrets, or embedded infrastructure details.

`vx.ex` (context file, read for cross-reference) at line 200 contains a hardcoded string used by `get_vx_admin_fobs()`:

```elixir
def get_vx_admin_fobs() do
  "000019333303000019333AEA000019330E4E0000193354AC00001933382D00001932FCA800001933001A"
end
```

This string is consumed directly in `file_controller.ex` line 33 as the base of the `fobs_as_string` accumulator passed into binary file generation. This is a hardcoded credential/key value embedded in source — see finding A098-1.

`file_controller.ex`, `geofence_controller.ex`, `page_controller.ex`: No other hardcoded secrets, API keys, or database credentials found directly in these controller files.

---

### §2: Authentication and Authorization

**Router cross-reference (router.ex):**

The router defines two scopes under `/api/v1`:

**Scope 1 (lines 28–154):** Opens with two unauthenticated routes before calling `pipe_through([:api, :authenticated])`:

```elixir
scope "/api/v1", ApiServerWeb do
  # Avoid authentication, locking to a specific database
  get("/rhm/engine_usage", VXThingController, :combined_engine_usage)
  get("/rhm/monday_hour_meters", VXThingController, :monday_hour_meters)

  pipe_through([:api, :authenticated])
  ...
  get("/rhm/geofences", GeofenceController, :list_all_geofences)
  put("/rhm/geofence", GeofenceController, :create_geofence)
  post("/rhm/geofence", GeofenceController, :update_geofence)
  delete("/rhm/geofence/:id", GeofenceController, :delete_geofence)
  get("/rhm/reports/geofence_events", GeofenceController, :process_things_geofences)
```

All GeofenceController routes are within the authenticated block.

**Scope 2 (lines 156–177):** Uses only `pipe_through(:api)` — no `:authenticated` plug:

```elixir
scope "/api/v1", ApiServerWeb do
  pipe_through(:api)
  ...
  get("/files/getsize/:esn", FileController, :get_size)
  get("/files/getfile/:esn", FileController, :send_file_download)
```

Both `FileController` actions (`get_size`, `send_file_download`) are in an **unauthenticated** scope. Any caller who can reach the server can query any device by ESN and retrieve the full access-fob binary for it — see finding A098-2.

`get_vx_thing_with_hardware_id!` (called without a `customer` argument) performs a cross-tenant query with no `prefix:` — it queries the global/default schema. This means device lookups in `file_controller.ex` are not scoped to any organisation — see finding A098-3.

`page_controller.ex` has a single `index/2` that renders a static HTML page. No auth required; this appears intentional for a root/landing page. Not flagged.

---

### §3: Input Validation and Injection

**file_controller.ex:**

The `hardwareid` parameter from the URL path segment `:esn` flows into:

1. `Vx.get_vx_thing_with_hardware_id!(hardwareid)` — parameterised Ecto query (safe).
2. String interpolation into the `version_name` filename at line 36:

```elixir
version_name = "SM-" <> date_string <> "-" <> hardwareid <> ".bin"
send_download(conn, {:binary, generate_binary_file_contents(fobs_as_string)}, filename: version_name)
```

The `hardwareid` is used as a component of the `Content-Disposition: attachment; filename=` header value passed directly to Phoenix's `send_download/3`. If `hardwareid` contains characters such as `"`, `;`, newline, or carriage return, it can corrupt or inject into the HTTP response header — see finding A098-4.

`generate_binary_file_contents/1` calls `Base.decode16!(operator_string)`. If `fob_code` values contain non-hex characters, this raises an exception and leaks a stack trace through the fallback controller. The input is from the database so this is LOW risk but worth noting — see finding A098-7.

**geofence_controller.ex:**

`create_geofence/2` and `update_geofence/2` pass `geofence_params` (raw request body map) into `Vx.create_geofence/2` and `Vx.update_geofence/3` respectively. Whether changeset validation occurs was checked via context reference. The controller itself does not apply any parameter filtering or validation before forwarding — input validation is entirely delegated downstream. If the context functions lack strict changesets, there is no safety net here. This is noted as an observation rather than a confirmed finding — see finding A098-8.

`create_geofence/2` line 31 and `update_geofence/2` line 50 construct raw JSON error responses by string interpolation of `inspect(error)`:

```elixir
send_resp(conn, :internal_server_error, "{\"error\": \"error creating geofence\", \"reason\": \"#{inspect error}\" }")
```

The `inspect error` output of an Ecto changeset or database error can contain table names, column names, constraint names, schema prefixes (which are customer identifiers), and SQL fragments — see finding A098-5.

No `String.to_atom/1` on user input, no `Code.eval_string/1`, no `:erlang.binary_to_term/1` found in the three files.

---

### §4: Session and CSRF

`page_controller.ex` is served under the `:browser` pipeline (based on router scope `"/"` using `pipe_through(:browser)`). The browser pipeline includes `plug(:protect_from_forgery)` and `plug(:put_secure_browser_headers)`.

The FileController and GeofenceController actions are served under `:api` / `:authenticated` pipelines which do not include CSRF protection. This is standard and expected for stateless JWT-authenticated API endpoints.

§4: No issues found in the three assigned files beyond the authentication gap already reported in §2.

---

### §5: File and Data Handling

**Path traversal — file_controller.ex:**

Special attention was given per task instructions. The `send_file_download/2` action does **not** write to the filesystem: it uses `send_download(conn, {:binary, data}, filename: version_name)`. Phoenix's `send_download/3` with the `:binary` tuple sends in-memory data, not a file read from disk. There is no `File.read`, `File.write`, `File.open`, or `:file.read` call. Classical path traversal (directory escape to read/write arbitrary files) is **not present**.

However, as noted in §3, `hardwareid` from user input is included in the `filename:` option passed to `send_download/3`, which sets the `Content-Disposition` header — see A098-4 for the header injection risk.

**Content type validation — file_controller.ex:**

The endpoint generates and sends a binary firmware file (`.bin`). It accepts no user-uploaded file; it produces output. Content-type validation of an *incoming upload* is therefore not applicable. The outgoing `Content-Type` is set by Phoenix based on the filename extension `.bin`; this is server-controlled and acceptable.

**Information disclosure in error responses:**

`geofence_controller.ex` lines 31, 50: `inspect(error)` in HTTP response bodies — see A098-5.

`file_controller.ex` lines 16, 46, 47: `IO.puts` calls write debug information (fleet join data, CRC values) to stdout. In production these will appear in application logs. The line 16 output includes `fleet_thing_joins` association data:

```elixir
IO.puts "#{inspect length(thing.fleet_thing_joins)} #{inspect thing.fleet_thing_joins}"
```

This logs fleet structure data to the application log on every request — see finding A098-6.

**PII / GPS / fleet data scoping:**

`process_things_geofences/2` returns geofence event records that include `latitude`, `longitude`, `ignitionstatus`, `eventtype`, `eventcode`, and `engine_hours_at_event`. The function correctly extracts `customer` from the JWT claims and passes it to all data-access calls as a schema prefix. Fleet data scoping is enforced.

`list_all_geofences/2`, `create_geofence/2`, `update_geofence/2`, `delete_geofence/2`: all extract `customer` from JWT claims and pass to context functions. Scoping is enforced.

---

### §6: Dependencies

Not assessed in these three controller files. No dependency declarations appear here.

§6: Not applicable to assigned files (no mix.exs/mix.lock changes assessed here).

---

### §7: Infrastructure Exposure

`file_controller.ex`: No hardcoded hostnames, IPs, or port numbers.

`geofence_controller.ex`: No hardcoded hostnames, IPs, or port numbers.

`page_controller.ex`: No hardcoded hostnames, IPs, or port numbers.

The router (reviewed for context) does not configure CORS directly; commented-out `CORSPlug` lines are present but inactive.

§7: No issues found in the three assigned files.

---

## Findings

### A098-1 — MEDIUM — Hardcoded Access Fob Keys in Source

**File:** `lib/api_server/vx/vx.ex` (line 200, consumed by `lib/api_server_web/controllers/file_controller.ex` line 33)

**Description:**
`Vx.get_vx_admin_fobs/0` returns a hardcoded hex string representing seven administrative access fob codes:

```elixir
def get_vx_admin_fobs() do
  "000019333303000019333AEA000019330E4E0000193354AC00001933382D00001932FCA800001933001A"
end
```

This string is prepended to every firmware binary generated by `send_file_download/2`. The fob codes are compiled into the application binary and are present in version control history. Any person with read access to the repository can extract these codes. Rotation of a compromised fob requires a code change and redeployment.

**Recommendation:** Store admin fob codes in application configuration loaded from an environment variable or secrets manager. Do not embed them in source.

---

### A098-2 — CRITICAL — FileController Endpoints Are Unauthenticated

**File:** `lib/api_server_web/controllers/file_controller.ex` (lines 12, 28)
**Router:** `lib/api_server_web/router.ex` (lines 165–166)

**Description:**
Both `get_size/2` and `send_file_download/2` are registered under the second `/api/v1` scope, which uses only `pipe_through(:api)` — the `:authenticated` plug is absent:

```elixir
scope "/api/v1", ApiServerWeb do
  pipe_through(:api)
  ...
  get("/files/getsize/:esn", FileController, :get_size)
  get("/files/getfile/:esn", FileController, :send_file_download)
```

Any unauthenticated caller who can reach the server can:

1. Enumerate device ESNs and retrieve associated fleet and access-fob counts (`get_size`).
2. Download the complete access-fob binary for any device — including all seven hardcoded admin fobs — by supplying only a hardware ID (`send_file_download`).

The access-fob binary governs physical access control (who is authorised to operate fleet equipment). Unauthenticated retrieval of this binary for an arbitrary device is a critical access-control failure.

**Recommendation:** Move the `/files/*` routes inside the authenticated scope, or add `plug ApiServer.Guardian.AuthPipeline` directly to the FileController. Additionally, verify that the authenticated caller's organisation owns the requested device (see A098-3).

---

### A098-3 — HIGH — FileController Device Lookup is Not Tenant-Scoped

**File:** `lib/api_server_web/controllers/file_controller.ex` (lines 14, 29)
**Context:** `lib/api_server/vx/vx.ex` (line 1337)

**Description:**
Both `get_size/2` and `send_file_download/2` call `Vx.get_vx_thing_with_hardware_id!/1` — the single-arity variant that does **not** accept a `customer` prefix:

```elixir
def get_vx_thing_with_hardware_id!(hardwareid) do
  VXThing
      |> Ecto.Query.where(aadhardwareid: ^hardwareid)
      ...
      |> Repo.one   # no prefix: customer
end
```

This queries the default schema with no tenant isolation. Even if authentication were added (A098-2), any authenticated user from any customer organisation could query devices belonging to other customers' organisations by ESN, then obtain their fleet's access-fob data.

The two-arity form `get_vx_thing_with_hardware_id!(hardwareid, customer)` exists and is used elsewhere. The file controller should use this form after extracting the customer from JWT claims.

**Recommendation:** After adding authentication (A098-2), extract `customer` from `ApiServer.Guardian.Plug.current_claims(conn)["customer"]` and call `Vx.get_vx_thing_with_hardware_id!(hardwareid, customer)` in both actions.

---

### A098-4 — MEDIUM — HTTP Header Injection via User-Controlled Hardware ID in Content-Disposition

**File:** `lib/api_server_web/controllers/file_controller.ex` (lines 35–38)

**Description:**
The `:esn` path parameter (`hardwareid`) is interpolated directly into the `filename:` option of `send_download/3`:

```elixir
version_name = "SM-" <> date_string <> "-" <> hardwareid <> ".bin"
send_download(conn, {:binary, generate_binary_file_contents(fobs_as_string)}, filename: version_name)
```

Phoenix's `send_download/3` sets a `Content-Disposition: attachment; filename="<version_name>"` response header. If `hardwareid` contains double-quote characters, semicolons, or CRLF sequences (`\r\n`), the resulting header value can be malformed or split, enabling:

- Header injection (CRLF injection) that injects additional HTTP response headers.
- Filename manipulation on the client side.

**Recommendation:** Sanitise `hardwareid` before use in the filename: allow only alphanumeric characters, hyphens, and underscores. Reject or strip any character outside this set before constructing `version_name`.

---

### A098-5 — MEDIUM — Internal Error Details Leaked in HTTP Responses

**File:** `lib/api_server_web/controllers/geofence_controller.ex` (lines 31, 50, 53, 66, 69)

**Description:**
Multiple error responses in `GeofenceController` construct raw JSON by string interpolation of `inspect(error)` or literal internal messages:

```elixir
# Line 31 — create_geofence
send_resp(conn, :internal_server_error,
  "{\"error\": \"error creating geofence\", \"reason\": \"#{inspect error}\" }")

# Line 50 — update_geofence
send_resp(conn, :internal_server_error,
  "{\"error\": \"error inserting update\", \"reason\": \"#{inspect result}\" }")
```

The `inspect/1` of an Ecto changeset or database error typically includes:
- Table and column names.
- Database constraint names (which embed schema/table structure).
- The customer schema prefix (which is the organisation identifier).
- Potentially partial SQL fragments from `Ecto.Adapters.SQL`.

Returning this data in HTTP responses discloses internal schema structure to API clients.

Additionally, line 53 returns `"no geofence matches ID"` and line 69 returns `"No geofence with that ID to delete"` with a 500 status code rather than 404, which is misleading and non-standard.

**Recommendation:**
1. Replace `inspect(error)` with a generic error message in all HTTP responses. Log the full error server-side.
2. Return 404 (not 500) when a resource is not found.

---

### A098-6 — LOW — Debug IO.puts Calls Log Fleet Data in Production

**File:** `lib/api_server_web/controllers/file_controller.ex` (lines 16, 46, 47)

**Description:**
Three `IO.puts` calls remain active in production code paths:

```elixir
# Line 16 — get_size and send_file_download
IO.puts "#{inspect length(thing.fleet_thing_joins)} #{inspect thing.fleet_thing_joins}"

# Lines 46–47 — generate_binary_file_contents
IO.puts "CRC: #{inspect crc}"
IO.puts "CRC_String: #{inspect crc16_xmodem}"
```

Line 16 logs `fleet_thing_joins` association data to stdout on every invocation. This includes fleet membership data for the device queried. In a container/cloud environment `IO.puts` writes to stdout, which is collected by log aggregation. Logging fleet structural data on every request is unnecessary operational noise and may expose fleet IDs in log systems accessible more broadly than the application itself.

**Recommendation:** Remove all `IO.puts` debug calls from production code. Use `Logger.debug/1` with appropriate log level gating if tracing is needed during development.

---

### A098-7 — LOW — Unhandled Pattern Match in engine_hours_at_event May Crash Process

**File:** `lib/api_server_web/controllers/geofence_controller.ex` (lines 184–205)

**Description:**
`engine_hours_at_event/3` uses a `case` expression on `thing.aadcat` with integer cases 2–9 but provides no catch-all clause:

```elixir
defp engine_hours_at_event(thing, event, customer) do
  case thing.aadcat do
    2 -> event.calcengineseconds/3600
    3 -> event.input1calctotalseconds/3600
    4 -> ...
    5 -> ...
    6 -> ...
    7 -> ...
    8 -> ...
    9 -> event.odometer/1
  end
end
```

If `aadcat` is `nil`, `0`, `1`, or any value outside 2–9, this raises a `CaseClauseError`. This will crash the request process. The `action_fallback` is not declared in this controller, so the error handling depends on Phoenix's default error handler — which may return a 500 with stack trace depending on `ErrorView` configuration.

**Recommendation:** Add a catch-all clause (e.g., `_ -> 0.0`) to prevent unexpected crashes and return a safe default.

---

### A098-8 — INFO — No Controller-Level Parameter Filtering Before Context Calls in GeofenceController

**File:** `lib/api_server_web/controllers/geofence_controller.ex` (lines 18–33, 35–55)

**Description:**
`create_geofence/2` and `update_geofence/2` forward the raw `geofence_params` map (derived from the request body) directly to `Vx.create_geofence/2` and `Vx.update_geofence/3` without any controller-level parameter filtering:

```elixir
def create_geofence(conn, %{"geofence" => geofence_params}) do
  customer = ApiServer.Guardian.Plug.current_claims(conn)["customer"]
  geojson = Geofence.geojson_map_to_string(geofence_params["geoJSON"])
  params = Map.put(geofence_params, "geojson", geojson)
  with {:ok, %Geofence{} = geofence} <- Vx.create_geofence(params, customer) do
    ...
```

Whether Ecto changesets in the context layer enforce strict whitelisting was not verified in this pass. If the context changesets use `cast/3` with explicit field lists this is safe; if they use permissive patterns, over-posting (mass assignment) is possible.

**Recommendation:** Confirm that `Vx.create_geofence/2` and `Vx.update_geofence/3` use strict `cast/3` field whitelists in their changesets. If not, apply parameter filtering at the controller level before forwarding.

---

## Summary Table

| ID | Severity | File | Description |
|----|----------|------|-------------|
| A098-1 | MEDIUM | `vx.ex` (consumed by `file_controller.ex`) | Hardcoded admin access fob keys in source |
| A098-2 | CRITICAL | `file_controller.ex` / `router.ex` | FileController endpoints entirely unauthenticated |
| A098-3 | HIGH | `file_controller.ex` | Device lookup not tenant-scoped; cross-customer IDOR |
| A098-4 | MEDIUM | `file_controller.ex` | HTTP header injection via unsanitised hardwareid in Content-Disposition |
| A098-5 | MEDIUM | `geofence_controller.ex` | Internal Ecto/DB error details leaked in HTTP 500 responses |
| A098-6 | LOW | `file_controller.ex` | Active IO.puts debug calls log fleet data in production |
| A098-7 | LOW | `geofence_controller.ex` | Non-exhaustive case in engine_hours_at_event can crash request process |
| A098-8 | INFO | `geofence_controller.ex` | No controller-level parameter filtering before context calls |
