# Security Audit Report — A113
**Agent:** A113
**Run:** 2026-02-27-01
**Repo:** api_server
**Stack:** Elixir/Phoenix
**Branch:** master
**Date:** 2026-02-27

---

## Assigned Files

1. `lib/api_server_web/controllers/vx_thing_omega_controller.ex`
2. `lib/api_server_web/controllers/vx_thing_summary_controller.ex`
3. `lib/api_server_web/controllers/vx_user_controller.ex`

Supporting files read for context:
- `lib/api_server_web/router.ex`
- `lib/api_server_web/auth_pipeline.ex`
- `lib/api_server/guardian.ex`
- `lib/api_server/vx/vx_user.ex`
- `lib/api_server/vx/vx.ex` (relevant excerpts: lines 1–130, 2700–2726)
- `mix.exs`

---

## Reading Evidence

### File 1: `lib/api_server_web/controllers/vx_thing_omega_controller.ex`

**Module name:** `ApiServerWeb.VXThingOmegaController`

**Public functions (def):**

| Name | Arity | Line |
|---|---|---|
| `get_container_lift_report` | 2 | 10 |
| `get_lift_summary_report` | 2 | 22 (hardwareid clause) |
| `get_lift_list_report` | 2 | 33 |
| `get_lift_summary_report` | 2 | 44 (fleetid clause) |
| `get_operation_summary_report` | 2 | 53 |
| `get_engine_utilization_report` | 2 | 63 |

**defstruct / defexception / schema:** None defined.

**use / import / alias at module level:**
- `use ApiServerWeb, :controller` (line 2)
- `use Timex` (line 3)
- `alias ApiServer.Vx` (line 5)
- `alias ApiServer.Vx.VXThing` (line 6)
- `action_fallback ApiServerWeb.FallbackController` (line 8)

---

### File 2: `lib/api_server_web/controllers/vx_thing_summary_controller.ex`

**Module name:** `ApiServerWeb.VXThingSummaryController`

**Public functions (def):**

| Name | Arity | Line |
|---|---|---|
| `index` | 2 | 9 |
| `create` | 2 | 14 |
| `show` | 2 | 23 |
| `update` | 2 | 28 |
| `delete` | 2 | 36 |
| `do_fix_summary` | 2 | 45 |

**defstruct / defexception / schema:** None defined.

**use / import / alias at module level:**
- `use ApiServerWeb, :controller` (line 2)
- `alias ApiServer.Vx` (line 4)
- `alias ApiServer.Vx.VXThingSummary` (line 5)
- `action_fallback ApiServerWeb.FallbackController` (line 7)

---

### File 3: `lib/api_server_web/controllers/vx_user_controller.ex`

**Module name:** `ApiServerWeb.VXUserController`

**Public functions (def):**

| Name | Arity | Line |
|---|---|---|
| `create` | 2 | 9 |
| `lookup_customer_from_conn` | 1 | 18 |
| `login` | 2 | 41 |
| `change_password` | 2 | 59 |
| `get_users` | 2 | 82 |
| `get_user_with_email` | 2 | 89 |
| `update_key_if_value` | 3 | 99 (nil clause) |
| `update_key_if_value` | 3 | 100 |
| `update_user` | 2 | 104 (user clause) |
| `update_user` | 2 | 127 (no-user clause) |
| `create_user` | 2 | 131 |
| `delete_user` | 2 | 153 |
| `get_user_fleets` | 2 | 168 |
| `manage_user_fleets` | 2 | 180 |

**defstruct / defexception / schema:** None defined.

**use / import / alias at module level:**
- `use ApiServerWeb, :controller` (line 2)
- `alias ApiServer.Vx` (line 4)
- `alias ApiServer.Vx.VXUser` (line 5)
- `action_fallback ApiServerWeb.FallbackController` (line 7)

---

## Supporting Context: Router (relevant excerpts)

The router defines two scopes under `/api/v1`:

**Scope 1** (lines 28–154): Starts with two unauthenticated routes, then calls `pipe_through([:api, :authenticated])` at line 33. All routes for VXThingOmegaController, VXUserController (user management), and VXFleetController fall under this pipe_through.

**Scope 2** (lines 156–177): Uses only `pipe_through(:api)` — no `:authenticated` pipeline. Routes here include:
- `POST /api/v1/rhm/:customer/login/` → `VXUserController.login`
- `resources "/vx/thingsummaries"` → `[REDACTED-AWS-SMTP-PASSWORD]` (all CRUD actions)

**Auth pipeline** (`lib/api_server_web/auth_pipeline.ex`):
```elixir
plug Guardian.Plug.VerifyHeader, realm: "Bearer"
# plug Guardian.Plug.EnsureAuthenticated   <-- COMMENTED OUT
plug Guardian.Plug.LoadResource
```

---

## Checklist Findings

### §1: Secrets and Configuration

§1: No issues found in the three assigned controller files. (Config file analysis is out of scope for these three files; no hardcoded credentials appear in controller code.)

---

### §2: Authentication and Authorization

**A113-1 — CRITICAL: `Guardian.Plug.EnsureAuthenticated` is commented out in the auth pipeline**

File: `lib/api_server_web/auth_pipeline.ex`, line 7.

```elixir
plug Guardian.Plug.VerifyHeader, realm: "Bearer"
# plug Guardian.Plug.EnsureAuthenticated   <-- COMMENTED OUT
plug Guardian.Plug.LoadResource
```

The `:authenticated` pipeline only verifies the header token if present and loads the resource. It does **not** reject requests with no token or an invalid token. Any route under `pipe_through([:api, :authenticated])` can be accessed without a valid JWT: the token is merely parsed if supplied, but its absence is not enforced.

Impact: All authenticated routes — including vehicle data retrieval, user management, fleet management, geofence operations, and all omega reports — are reachable by unauthenticated callers. This is the most severe finding in this file set.

---

**A113-2 — CRITICAL: Passwords stored and compared in plaintext**

Files: `lib/api_server/vx/vx.ex` lines 2704–2717; `lib/api_server_web/controllers/vx_user_controller.ex` lines 44, 63–66; `lib/api_server/vx/vx_user.ex` lines 21, 75, 80.

Authentication in `get_rhm_user/3` and `check_password/3` performs a database query filtering on the raw password field `aacpassword`:

```elixir
# vx.ex line 2706-2707
|> Ecto.Query.where(aacemail: ^email)
|> Ecto.Query.where(aacpassword: ^password)
```

The schema has a separate `aacpasswordhash` field (line 22 of vx_user.ex) that is never populated or consulted. The `update_vx_user_password` function stores the new password directly into `aacpassword` without hashing:

```elixir
# vx_user_controller.ex line 65
changeset = %{aacpassword: new_password}
```

No bcrypt, argon2, or Comeonin dependency is present in `mix.exs`. Passwords are stored and compared in cleartext. A database read by any means — SQL injection, insider access, backup disclosure — exposes every user credential directly.

---

**A113-3 — HIGH: VXThingSummaryController CRUD is fully unauthenticated**

File: `lib/api_server_web/router.ex`, line 162.

```elixir
scope "/api/v1", ApiServerWeb do
  pipe_through(:api)          # no :authenticated
  ...
  resources("/vx/thingsummaries", VXThingSummaryController, except: [:new, :edit])
```

`[REDACTED-AWS-SMTP-PASSWORD]` provides `index`, `create`, `show`, `update`, and `delete` actions. All five are served from the second scope which only passes through `:api` (fetch session + accept JSON). There is no authentication requirement. Any caller can list, read, create, modify, or delete thing summary records without a token.

Additionally, none of the controller actions extract a customer claim or restrict results by customer. `Vx.list_vxthingsummaries()` (called with no arguments at line 10) and `Vx.get_vx_thing_summary!(id)` do not appear to be scoped to a customer or tenant, meaning cross-customer data access is possible.

---

**A113-4 — HIGH: IDOR on `get_user_fleets` and `manage_user_fleets` — authenticated user_id not validated against JWT subject**

File: `lib/api_server_web/controllers/vx_user_controller.ex`, lines 168–197.

```elixir
def get_user_fleets(conn, %{"user_id"=> user_id}) do
  customer = ApiServer.Guardian.Plug.current_claims(conn)["customer"]
  user_with_fleets = Vx.get_vx_user_fleets!(user_id, customer)
  ...

def manage_user_fleets(conn, %{"user_id" => user_id, "allowed_fleets" => allowed_fleets}) do
  customer = ApiServer.Guardian.Plug.current_claims(conn)["customer"]
  user_with_fleets = Vx.get_vx_user_fleets!(user_id, customer)
```

The `user_id` is taken directly from the URL parameter (`/rhm/user/:user_id/fleets`). The code reads the customer from the JWT claim, which provides tenant isolation, but it does not verify that `user_id` matches the authenticated user's own subject (`current_claims["sub"]`). Any authenticated user within the same customer tenant can supply another user's ID and read or modify that user's fleet assignments. This is a direct IDOR within the tenant.

---

**A113-5 — HIGH: IDOR on `update_user` and `delete_user` — no ownership check**

File: `lib/api_server_web/controllers/vx_user_controller.ex`, lines 104–165.

`update_user` retrieves the user by `user_params["id"]` (line 105) and `delete_user` by the `id` URL parameter (line 154). The customer is taken from the JWT in `update_user`, but `delete_user` takes the `customer` parameter from the **URL** (line 153):

```elixir
def delete_user(conn, %{"customer" => customer, "id" => id}) do
  user = Vx.get_vx_user!(id, customer)
```

Neither function verifies that the requesting user is an administrator or has any elevated role. Any authenticated user in the customer can delete or update any other user in that customer.

For `update_user`, the customer is correctly drawn from the JWT claim (line 83-style — actually at line 105 the customer is taken from the request parameter: `%{"customer" => customer, "user" => user_params}`, not from the JWT), meaning a caller can supply a different customer string and — if the auth pipeline does not enforce token validity (see A113-1) — operate across tenants.

---

**A113-6 — HIGH: `update_user` and `create_user` take `customer` from URL/request body, not JWT**

File: `lib/api_server_web/controllers/vx_user_controller.ex`, lines 104, 131, 153.

```elixir
def update_user(conn, %{"customer" => customer, "user" => user_params}) do
  user = Vx.get_vx_user!(user_params["id"], customer)

def create_user(conn, %{"customer" => customer, "user" => user_params}) do
  user = Vx.get_rhm_user(user_params["email"], customer)

def delete_user(conn, %{"customer" => customer, "id" => id}) do
  user = Vx.get_vx_user!(id, customer)
```

In all three functions the `customer` value used for all database operations is taken from the request payload or URL, not from `ApiServer.Guardian.Plug.current_claims(conn)["customer"]`. Compare to `get_users/2` (line 83) and `change_password/2` (line 60) which correctly read customer from the JWT. A caller can supply an arbitrary `customer` string to access or modify records in a different tenant's database schema. Combined with A113-1 (unenforced authentication), this is exploitable without any credentials.

---

**A113-7 — MEDIUM: `get_user_with_email` takes `customer` from request parameter, not JWT**

File: `lib/api_server_web/controllers/vx_user_controller.ex`, lines 89–97.

```elixir
def get_user_with_email(conn, %{"email" => email, "customer" => customer}) do
  [user | _] = Vx.get_rhm_user(email, customer)
```

The customer is drawn from the request parameter rather than the JWT claim. Any authenticated caller can query user records from an arbitrary customer tenant by supplying a different `customer` value.

---

**A113-8 — MEDIUM: `login` customer origin mapping falls through to `vx_dev` default**

File: `lib/api_server_web/controllers/vx_user_controller.ex`, lines 18–57.

`lookup_customer_from_conn/1` maps HTTP `Origin` headers to customer strings. The catch-all clause (line 37) maps any unrecognised origin — including no `Origin` header — to `"vx_dev"`:

```elixir
_ ->
  "vx_dev"
```

This `cust_from_origin` value is stored in the session (line 52) but the actual authentication uses the `customer` parameter from the POST body (line 44):

```elixir
user = Vx.get_rhm_user(email, password, customer)
case ApiServer.Guardian.encode_and_sign(user, %{customer: customer}) do
```

The session's `cust_from_origin` is therefore inconsistent with the token's customer claim. The session-stored customer (`vx_dev` for unknown origins) is stored but appears unused in other endpoints (which read from JWT). The inconsistency indicates dead/confusing code, but the default `vx_dev` assignment may allow enumeration of the dev/staging customer database from any client.

---

**A113-9 — MEDIUM: `login` does not distinguish failed authentication from missing user — information disclosure**

File: `lib/api_server_web/controllers/vx_user_controller.ex`, lines 41–57.

```elixir
user = Vx.get_rhm_user(email, password, customer)
case ApiServer.Guardian.encode_and_sign(user, %{customer: customer}) do
  {:ok, token, _claims} -> ...
  {:error, _message} ->
    send_resp(conn, :internal_server_error, "{\"error\": \"Incorrect email address or password\"}")
end
```

`Vx.get_rhm_user/3` returns `nil` when no user is found. `Guardian.encode_and_sign(nil, ...)` hits the nil guard in `subject_for_token/2` which returns `{:error, :reason_for_error}`. The error path is handled, but if `Repo.one` raises because the query returns multiple rows (unlikely but possible given no unique constraint enforcement in the query), an unhandled exception propagates to `FallbackController`. More importantly, timing differences between "wrong password" and "user not found" are not mitigated — the raw DB query either returns nil immediately or performs a full query scan, creating a username enumeration timing oracle.

---

**A113-10 — LOW: No role/admin check on user-management operations**

File: `lib/api_server_web/controllers/vx_user_controller.ex`, functions `create_user` (line 131), `delete_user` (line 153), `update_user` (line 104), `manage_user_fleets` (line 180).

None of these mutating user-management endpoints verify that the requesting user holds an administrative role (`aacusertype` or `function` association). Any authenticated user within the tenant can create, update, delete, or reassign fleets for other users.

---

### §3: Input Validation and Injection

**A113-11 — MEDIUM: Changeset leak in error responses exposes internal schema details**

File: `lib/api_server_web/controllers/vx_user_controller.ex`, lines 73 and 119.

```elixir
send_resp(conn, :internal_server_error,
  "{\"error\": \"Unknown error updating user password\",\"reason\": \"An error occured while updating this user\",\"changeset\": \"#{inspect changeset}\"}\" }")
```

`inspect changeset` serialises the full `%Ecto.Changeset{}` struct into the HTTP response body. This exposes internal field names, validation error atoms, schema metadata, and potentially partially-populated field values to the client. The same pattern appears in `create_user` at line 147.

---

**A113-12 — LOW: `user_level` from client JSON mapped directly into changeset for `put_assoc`**

File: `lib/api_server/vx/vx_user.ex`, line 70 and `lib/api_server_web/controllers/vx_user_controller.ex` line 109.

`VXUser.convert_json_to_changeset/1` includes:

```elixir
|> Vx.update_key_if_value(:user_level, user_json["user_level"])
```

This value feeds into `VXUser.changeset/2` at line 81:

```elixir
|> put_assoc(:function, %{aatfunction_id: attrs.user_level}, required: true)
```

The `user_level` (which maps to a function/role record) is taken directly from the client-supplied JSON in `update_user` and `create_user` requests. There is no validation that the caller is authorised to set or change the user's role level. A regular user could elevate their own or another user's privileges by supplying an arbitrary `user_level` value.

---

§3 (remainder): No raw SQL fragment injection or `String.to_atom/1` from user input was found in the three assigned controller files. Queries in vx.ex use parameterised Ecto bindings (`^variable`).

---

### §4: Session and CSRF

**A113-13 — INFO: Login stores JWT in server-side session but all other endpoints use Bearer token from header**

File: `lib/api_server_web/controllers/vx_user_controller.ex`, lines 51–52.

```elixir
|> put_session(:jwt, token)
|> put_session(:customer, cust_from_origin)
```

The session is populated on login, but the auth pipeline (`auth_pipeline.ex`) only uses `Guardian.Plug.VerifyHeader` — it does not call `Guardian.Plug.VerifySession`. The session values are therefore set but never consumed by the authentication system. This is dead code that wastes session storage and could create confusion in future development (e.g., a developer might add `VerifySession` believing the session is a valid auth path, creating dual-auth ambiguity).

---

§4 (remainder): CSRF protection is enabled in the `:browser` pipeline (`protect_from_forgery`), but the API controllers use the `:api` pipeline which does not include CSRF protection. This is normal and expected for token-authenticated JSON APIs.

---

### §5: File and Data Handling

**A113-14 — MEDIUM: Vehicle/fleet operational data returned without customer scoping in VXThingSummaryController**

File: `lib/api_server_web/controllers/vx_thing_summary_controller.ex`, line 10.

```elixir
def index(conn, _params) do
  vxthingsummaries = Vx.list_vxthingsummaries()
  render(conn, "index.json", vxthingsummaries: vxthingsummaries)
end
```

`list_vxthingsummaries()` is called with no customer or tenant argument. Given the multi-tenant schema-prefix architecture used throughout the rest of the codebase (all other queries pass `prefix: customer`), this call either returns data from the default schema (which may be a shared or system schema) or raises. Either way there is no per-customer scoping, violating the fleet-management data boundary requirement (checklist §5: "verify that any endpoint returning vehicle locations, driver records, or customer assets is scoped to the authenticated user's organisation").

Similarly `show`, `update`, and `delete` call `Vx.get_vx_thing_summary!(id)` and `Vx.update_vx_thing_summary/2` / `Vx.delete_vx_thing_summary/1` without a customer prefix.

---

**A113-15 — INFO: `IO.inspect` of request headers logged to stdout in production**

File: `lib/api_server_web/controllers/vx_user_controller.ex`, line 19.

```elixir
def lookup_customer_from_conn(conn) do
  IO.inspect get_req_header(conn, "origin")
```

`IO.inspect` writes directly to stdout. In a production OTP release this appears in the system journal/log. The `Origin` header itself is low-sensitivity, but this indicates debug instrumentation left in production code. Any future addition of higher-sensitivity header logging (e.g., `Authorization`) using this same pattern would be a disclosure issue.

---

§5 (remainder): No file upload handling or stack-trace-in-error-response patterns were found in the three assigned controller files beyond the changeset leak already noted (A113-11).

---

### §6: Dependencies

**A113-16 — HIGH: `mariaex ~> 0.8.2` is deprecated with no security support**

File: `mix.exs`, line 39.

```elixir
{:mariaex, "~>0.8.2"},
```

The checklist explicitly calls out Mariaex 0.8.2 as deprecated and without security support. This is the database driver for all data operations including those in the assigned files.

---

§6 (remainder): No `git:` source dependencies found. The `geonames` dependency uses a local `path:` reference (line 56) which should be reviewed separately. Dependency version audit (mix audit) is outside the scope of static file review.

---

### §7: Infrastructure Exposure

**A113-17 — MEDIUM: Hardcoded internal hostnames in `lookup_customer_from_conn` map**

File: `lib/api_server_web/controllers/vx_user_controller.ex`, lines 22–36.

```elixir
["http://cea-beta.mobilehourmeter.com"] -> "vx_cea"
["http://cea-omega.mobilehourmeter.com"] -> "vx_ceaomega"
["http://komatsuau-beta.mobilehourmeter.com"] -> "vx_komatsuau"
["http://komatsu-beta.mobilehourmeter.com"] -> "vx_komatsu"
["http://sielift-beta.mobilehourmeter.com"] -> "vx_sielift"
["http://demo.mobilehourmeter.com"] -> "vx_demo"
```

Customer-facing hostnames and their internal schema/database identifiers are hardcoded in source. This discloses customer names and the internal naming convention for database schema prefixes. All entries use `http://` rather than `https://`, indicating that these frontend applications may be served over unencrypted HTTP, or that the origin matching will fail for HTTPS-served frontends (the `Origin` header for an HTTPS page would be `https://...`, not `http://...`). The fallback to `vx_dev` for non-matching origins (including all HTTPS origins) is a separate operational concern (see A113-8).

---

§7 (remainder): No TLS termination, CORS configuration, or Content Security Policy handling was found in the three assigned controller files. CORS and endpoint configuration is outside scope for this file set.

---

## Summary of Findings

| ID | Severity | File | Description |
|---|---|---|---|
| A113-1 | CRITICAL | auth_pipeline.ex | `EnsureAuthenticated` plug commented out — all "authenticated" routes are actually unauthenticated |
| A113-2 | CRITICAL | vx_user_controller.ex / vx.ex | Passwords stored and compared in plaintext — no hashing |
| A113-3 | HIGH | router.ex / vx_thing_summary_controller.ex | VXThingSummaryController is fully unauthenticated and unscoped |
| A113-4 | HIGH | vx_user_controller.ex | IDOR: `get_user_fleets` and `manage_user_fleets` do not validate user_id against JWT sub |
| A113-5 | HIGH | vx_user_controller.ex | IDOR: `update_user` and `delete_user` have no ownership or admin check |
| A113-6 | HIGH | vx_user_controller.ex | `update_user`, `create_user`, `delete_user` use caller-supplied `customer` not JWT claim |
| A113-7 | MEDIUM | vx_user_controller.ex | `get_user_with_email` uses caller-supplied `customer` not JWT claim |
| A113-8 | MEDIUM | vx_user_controller.ex | Origin→customer mapping defaults unknown origins to `vx_dev`; all HTTPS origins fall through |
| A113-9 | MEDIUM | vx_user_controller.ex | Login error handling may expose timing oracle for username enumeration |
| A113-10 | LOW | vx_user_controller.ex | No role/admin check on mutating user-management operations |
| A113-11 | MEDIUM | vx_user_controller.ex | `inspect changeset` in error responses leaks internal schema detail to client |
| A113-12 | LOW | vx_user_controller.ex / vx_user.ex | Client-supplied `user_level` passed directly to role `put_assoc` — privilege escalation |
| A113-13 | INFO | vx_user_controller.ex | JWT stored in session but `VerifySession` not in pipeline — dead session code |
| A113-14 | MEDIUM | vx_thing_summary_controller.ex | Fleet asset data returned without customer/tenant scoping |
| A113-15 | INFO | vx_user_controller.ex | `IO.inspect` of request header in production code |
| A113-16 | HIGH | mix.exs | Mariaex 0.8.2 deprecated, no security support |
| A113-17 | MEDIUM | vx_user_controller.ex | Hardcoded customer hostnames and internal schema names; all use `http://` not `https://` |
