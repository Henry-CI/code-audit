# Audit Report A125
**Agent:** A125
**Run:** 2026-02-27-01
**Repo:** api_server
**Stack:** Elixir/Phoenix
**Branch:** master
**Pass:** 1

---

## Assigned Files

- `lib/api_server_web/views/error_helpers.ex`
- `lib/api_server_web/views/error_view.ex`
- `lib/api_server_web/views/file_view.ex`

---

## Reading Evidence

### File 1: `lib/api_server_web/views/error_helpers.ex`

**Module:** `ApiServerWeb.ErrorHelpers`

**Public functions:**
| Name | Arity | Line |
|---|---|---|
| `error_tag` | 2 | 11 |
| `translate_error` | 1 | 20 |

**defstruct / defexception / schema:** None defined.

**use / import / alias at module level:**
- `use Phoenix.HTML` (line 6)

---

### File 2: `lib/api_server_web/views/error_view.ex`

**Module:** `ApiServerWeb.ErrorView`

**Public functions:**
| Name | Arity | Line |
|---|---|---|
| `template_not_found` | 2 | 13 |

**defstruct / defexception / schema:** None defined.

**use / import / alias at module level:**
- `use ApiServerWeb, :view` (line 2)

  This macro expands (via `lib/api_server_web.ex`) to:
  - `use Phoenix.View, root: "lib/api_server_web/templates", namespace: ApiServerWeb`
  - `import Phoenix.Controller, only: [get_flash: 2, view_module: 1]`
  - `use Phoenix.HTML`
  - `import ApiServerWeb.Router.Helpers`
  - `import ApiServerWeb.ErrorHelpers`
  - `import ApiServerWeb.Gettext`

**Notable:** The commented-out block at lines 5–8 shows the Phoenix scaffold's suggested `render("500.html", _assigns)` override was left commented out. No explicit `render("500.json", ...)` or `render("500.html", ...)` functions are defined. All rendering falls through to `template_not_found/2`.

---

### File 3: `lib/api_server_web/views/file_view.ex`

**Module:** `ApiServerWeb.FileView`

**Public functions:**
| Name | Arity | Line |
|---|---|---|
| `render/2` ("index.json") | 2 | 5 |
| `render/2` ("show.json") | 2 | 9 |
| `render/2` ("filesize.json") | 2 | 13 |
| `render/2` ("file.json") | 2 | 20 |

**defstruct / defexception / schema:** None defined.

**use / import / alias at module level:**
- `use ApiServerWeb, :view` (line 2)
- `alias ApiServerWeb.FileView` (line 3)

**Supporting context reviewed (not assigned, read for evidence):**
- `lib/api_server_web/controllers/file_controller.ex`: provides callers of these view renders.
- `lib/api_server/operators/file.ex`: Ecto schema for "files" table — fields: `custcode`, `esn`, timestamps.

---

## Checklist Review

### §1: Secrets and Configuration

No config files, credentials, API keys, environment variable reads, or hardcoded secrets appear in these three view files. The view layer does not touch configuration.

**§1: No issues found.**

---

### §2: Authentication and Authorization

These are pure view/rendering modules. They do not perform authentication, issue tokens, or make authorization decisions. No Guardian configuration, password handling, or IDOR-relevant logic is present.

**§2: No issues found.**

---

### §3: Input Validation and Injection

`error_helpers.ex`:
- `translate_error/1` passes error messages and options to `Gettext.dgettext/4` and `Gettext.dngettext/5`. The message string originates from Ecto changeset validation messages, which are developer-defined atoms/strings, not raw user input. Options (including `:count`) originate from Ecto as well. No `String.to_atom/1`, no `fragment/1`, no `binary_to_term/1`, no `Code.eval_string/1`.

`error_view.ex`:
- `template_not_found/2` passes the template name string (e.g. `"404.json"`) to `Phoenix.Controller.status_message_from_template/1`. This template name is Phoenix-controlled, not user-supplied.

`file_view.ex`:
- Pure data serialization from Ecto structs. No user-supplied strings are processed.

**§3: No issues found.**

---

### §4: Session and CSRF

These are view modules with no session access, no CSRF token handling, no channel connection logic, and no cookie interaction.

**§4: No issues found.**

---

### §5: File and Data Handling — HIGH PRIORITY

#### 5a. `error_view.ex` — Information Disclosure in Error Responses

The file defines a single catch-all function:

```elixir
def template_not_found(template, _assigns) do
  %{error: Phoenix.Controller.status_message_from_template(template)}
end
```

The `_assigns` parameter is discarded entirely. This means:

- Stack traces passed via `assigns[:reason]` or `assigns[:conn]` are NOT returned to clients.
- Database errors (e.g., from a rescued `Ecto.QueryError`) passed via assigns are NOT returned to clients.
- The response is always a sanitized HTTP status phrase (e.g., `%{error: "Internal Server Error"}`) derived solely from the template filename.

The commented-out scaffold code at lines 5–8 was the proposed override for `render("500.html", _assigns)` returning a plain string; that it was left commented is benign — the catch-all already covers it cleanly.

**No explicit `render("500.json", ...)` or `render("500.html", ...)` overrides exist.** The catch-all is the sole implementation. Assigns including any raw exception data, changeset errors, or stack frames are dropped via `_assigns`.

This implementation is acceptable from an information-disclosure perspective. There is one observation worth flagging at INFO level:

---

**A125-1** — INFO
**File:** `lib/api_server_web/views/error_view.ex`, line 13
**Title:** No explicit 500 render clause — reliance on Phoenix catch-all
**Detail:** There is no explicit `render("500.json", ...)` or `render("500.html", ...)` function. All error responses (including 500) fall through to `template_not_found/2`, which discards assigns and returns only a status phrase. While the current behaviour is safe, the absence of an explicit 500 handler means that any future developer adding a `render("500.json", assigns)` that logs or returns `assigns[:reason]` could introduce information disclosure without any obvious prior art in the file indicating the risk. The existing commented-out scaffold block (lines 5–8) could mislead a developer into adding an unsafe implementation. Recommend adding an explicit, documented `render("500.json", _assigns)` clause with a comment clearly stating that assigns must not be forwarded to the client.

---

#### 5b. `file_view.ex` — File Path / System Path Exposure

The four render functions serialize the following fields:

- `render("filesize.json")`: `hardwareid`, `size`, `num_fobs`
- `render("file.json")`: `hardwareid`, `size`, `num_fobs`, `fobs`
- `render("index.json")` / `render("show.json")`: delegate to `"file.json"` above

No filesystem paths, absolute paths, server paths, or system-level strings are serialized. The module does not reference `File`, `Path`, or `System` modules, and no string interpolation of path components occurs.

**No file path or internal system path exposure found in `file_view.ex`.**

However, the `fobs` field warrants attention:

---

**A125-2** — MEDIUM
**File:** `lib/api_server_web/views/file_view.ex`, lines 20–26
**Title:** `fobs` field serialized wholesale into JSON response without field selection
**Detail:** `render("file.json", ...)` passes `file.fobs` directly into the JSON response map without explicitly selecting which sub-fields are included. Review of `file_controller.ex` shows that `fobs` is assembled from `Vx.get_vx_access_fobs_for_fleets!/1` which returns `VXAccessFob` structs. The raw struct (including all database-populated fields) is placed into the response. If `VXAccessFob` contains internal identifiers, operator codes, fleet group IDs, or other fields beyond what the hardware client needs, those fields will be disclosed. The view should enumerate exactly which fob fields are safe to return (e.g., only `fob_code` if that is what the hardware requires) rather than passing the entire struct. The controller also constructs `fobs_as_string` from `user.accessfob.fob_code` in `send_file_download/2`, confirming that `fob_code` is the operative field — but `render("file.json")` may return more than that.
**Recommendation:** Replace `fobs: file.fobs` with an explicit field projection in the view, e.g., `fobs: Enum.map(file.fobs, & &1.fob_code)` or equivalent, after confirming which fields are intentionally public.

---

**A125-3** — LOW
**File:** `lib/api_server_web/views/file_view.ex`, lines 13–17 and 20–26
**Title:** `hardwareid` (ESN) is a sensitive hardware identifier exposed in all file responses
**Detail:** The `hardwareid` field (derived from the `esn` column — Electronic Serial Number of a Vx hardware device) is returned in every response from this view. While this is likely intentional (the client is the device itself, requesting its own access fob binary), the ESN uniquely identifies physical hardware. If these endpoints are accessible to any authenticated user rather than being scoped to the device's own fleet/organisation, this could contribute to asset enumeration across customer boundaries. This should be verified at the controller and router level (outside the scope of these three files). Flag for cross-reference with the controller/router audit pass.

---

#### 5c. `error_helpers.ex` — PII / Data Exposure in Error Tags

`error_tag/2` renders field-level validation errors from Ecto changesets into HTML `<span>` elements. The content is the translated error message (e.g., "can't be blank", "is invalid"), not field values. No PII values from the form are included in the error tag output.

**§5: Two findings raised (A125-2 MEDIUM, A125-3 LOW). One observation raised (A125-1 INFO). See above.**

---

### §6: Dependencies

No dependency declarations appear in view files. `mix.exs` and `mix.lock` are outside this assignment.

**§6: No issues found.**

---

### §7: Infrastructure Exposure

No hostnames, IP addresses, port numbers, AWS resource names, CORS configuration, TLS configuration, or inter-service call logic appears in these three view files.

**§7: No issues found.**

---

## Summary of Findings

| ID | Severity | File | Title |
|---|---|---|---|
| A125-1 | INFO | `error_view.ex` | No explicit 500 render clause — reliance on catch-all is safe now but fragile |
| A125-2 | MEDIUM | `file_view.ex` | `fobs` struct serialized wholesale without field selection — potential over-disclosure |
| A125-3 | LOW | `file_view.ex` | `hardwareid` (ESN) exposed in all file responses — verify cross-customer scoping at controller layer |

---

*End of report A125.*
