# Security Audit Report — A122
**Agent:** A122
**Run:** 2026-02-27-01
**Branch:** master
**Stack:** Elixir/Phoenix
**Assigned files:**
- `lib/api_server_web/schema.ex`
- `lib/api_server_web/schema/thing_types.ex`
- `lib/api_server_web/views/changeset_view.ex`

**Supporting context read (not assigned, read for cross-reference):**
- `lib/api_server_web/resolvers/things.ex`
- `lib/api_server_web/resolvers/puls.ex`
- `lib/api_server_web/router.ex`
- `lib/api_server_web/endpoint.ex`
- `lib/api_server_web/views/error_helpers.ex`
- `lib/api_server/guardian.ex`
- `config/config.exs`

---

## Reading Evidence

### File 1: `lib/api_server_web/schema.ex`

**Module name:** `ApiServerWeb.Schema`

**Public functions (def):** None — this module uses Absinthe macro DSL only; no explicit `def` declarations are present.

**Schemas/types defined (via Absinthe query DSL):**
- Query field `:get_thing` (line 11) — args: `aadhardwareid` (non_null :string), `customer` (non_null :string) — resolver: `Resolvers.Things.find_thing/3`
- Query field `:get_puls_record` (line 18) — arg: `hardwareid` (non_null :string) — resolver: `Resolvers.Puls.puls_record/3`
- Query field `:get_all_things` (line 24) — arg: `customer` (non_null :string) — resolver: `Resolvers.Things.get_all_things/3`

**use / import / alias at module level:**
- `use Absinthe.Schema` (line 3)
- `import_types Absinthe.Type.Custom` (line 4)
- `import_types ApiServerWeb.Schema.ThingTypes` (line 5)
- `alias ApiServerWeb.Resolvers` (line 6)

**defstruct / defexception / schema:** None

---

### File 2: `lib/api_server_web/schema/thing_types.ex`

**Module name:** `ApiServerWeb.Schema.ThingTypes`

**Public functions (def):** None — Absinthe macro DSL only.

**Object types defined:**
- `:thing` (lines 5–37) — fields: `aadcustcode`, `aaddesc`, `aadintext`, `aadaddr`, `aadcustomerid`, `aadcat`, `aadhardwareid`, `aadhw_type`, `aadmake`, `aadmodel`, `aadserialno`, `aadmobile`, `aadimei`, `aadhourmeter`, `aadhourmeter1`, `aadhourmeter2`, `aadhourmeter3`, `aadhourmeter4`, `aadodometer`, `aadhourmeteromega`, `aadhourmeterothcan`, `aaddateintoservice`, `aadlastservice`, `aadvalid`, `aadserviceoffset`, `aadsvchrs`, `aadrange_lat`, `aadrange_long`, `aadrange_dist`, `aadrange_unit`, `service_calculation_input`
- `:puls_record` (lines 41–45) — fields: `esn`, `iccid`, `group`

**use / import / alias at module level:**
- `use Absinthe.Schema.Notation` (line 2)

**defstruct / defexception / schema:** None

---

### File 3: `lib/api_server_web/views/changeset_view.ex`

**Module name:** `ApiServerWeb.ChangesetView`

**Public functions (def):**
- `translate_errors/1` (line 10)
- `render/2` with clause `"error.json"` (line 14)

**use / import / alias at module level:**
- `use ApiServerWeb, :view` (line 2)

**defstruct / defexception / schema:** None

---

## Checklist Review

### §1: Secrets and Configuration

During cross-reference reading of `config/config.exs` (required to evaluate whether the GraphQL resolvers and schema connect to authenticated external services), the following hardcoded secrets were identified. These are reported here because they are directly relevant to the assigned resolver `Resolvers.Puls.puls_record/3`, which is the target resolver wired to the `:get_puls_record` query field in `schema.ex`.

**A122-1 — CRITICAL — Hardcoded AWS SES SMTP credentials in config.exs**

File: `config/config.exs`, lines 117–120

```elixir
username: "[REDACTED-AWS-KEY-ID]",
password: "[REDACTED-AWS-SMTP-PASSWORD]",
```

An AWS IAM access key ID (`[REDACTED-AWS-KEY-ID]`) and its corresponding SMTP password are hardcoded in the committed configuration file `config/config.exs`. This file is tracked by git. AWS SES SMTP credentials derived from IAM keys provide programmatic access to send email from the associated AWS account and may provide a pivot to other AWS services depending on the IAM policy attached to this key. A commented-out prior credential set is also visible on lines 115–116, indicating key rotation has occurred but old values remain in version history.

**A122-2 — CRITICAL — Hardcoded Guardian JWT secret key in config.exs**

File: `config/config.exs`, line 136

```elixir
secret_key: "wf1TLkCaEKIPY61A5LvxtPrUA63wrV/hz0RAtaDPh7BENw5WgsCPUN0/qH65BYmA"
```

The Guardian JWT signing secret is hardcoded in the committed `config/config.exs`. Any party with read access to the repository can forge valid JWT tokens, impersonating any user on the platform, including administrative accounts.

**A122-3 — CRITICAL — Hardcoded Phoenix secret_key_base in config.exs**

File: `config/config.exs`, line 15

```elixir
secret_key_base: "djHcKcu+CWBtfoT6k1mLsC1ObkKOy1ZF1G840aRXnQ+oAgAU9efRLUJ+yTd3x/Fh",
```

The Phoenix `secret_key_base` is hardcoded in the committed `config/config.exs`. This key is used to sign and verify cookies and session data. A known `secret_key_base` allows an attacker to forge signed cookies, potentially achieving session hijacking or remote code execution via maliciously crafted serialized session payloads.

**A122-4 — CRITICAL — Hardcoded third-party API credential (CalAmp PULS) in resolver source code**

File: `lib/api_server_web/resolvers/puls.ex`, line 4

```elixir
token = "VHJhY2tpbmdTb2x1dGlvbnM6U2tQREk4ZXo="
```

A Base64-encoded Basic Auth credential (`TrackingSolutions:SkPDI8ez` when decoded) for the CalAmp PULS external API is hardcoded directly in the resolver source file. This resolver is wired to the `:get_puls_record` query field in the assigned `schema.ex`. The credential is committed to version control and grants access to CalAmp PULS device records, including ESN, ICCID, and group membership for tracked hardware assets.

---

### §2: Authentication and Authorization

**A122-5 — CRITICAL — All three GraphQL queries lack authentication and authorization**

File: `lib/api_server_web/schema.ex`, lines 8–28; `lib/api_server_web/router.ex`, lines 195–202

The GraphQL endpoint is currently commented out in the router:

```elixir
# forward "/graphql",
#   Absinthe.Plug,
#   schema: ApiServerWeb.Schema
# forward "/graphiql",
#   Absinthe.Plug.GraphiQL,
#   schema: ApiServerWeb.Schema,
#   interface: :simple
```

The GraphQL routes are not currently mounted. However, the schema itself contains no authentication middleware, no authorization context checks, and no `middleware` declarations on any query field. All three queries — `:get_thing`, `:get_puls_record`, and `:get_all_things` — resolve directly to business logic with no identity or permission verification. If the GraphQL endpoint is ever re-enabled (the code is present and trivially re-activated), all three queries will be unauthenticated and unauthorised by default.

The resolvers in `Resolvers.Things` accept a `customer` argument from the caller and use it directly to scope database queries (`list_vxthings(customer)`, `get_vx_thing_with_hardware_id!(hardwareid, customer)`). The customer value is entirely attacker-controlled; there is no verification that the authenticated identity has access to the requested customer's data. This constitutes an IDOR / broken object-level authorization vulnerability.

**A122-6 — HIGH — Guardian token TTL is 52 weeks**

File: `config/config.exs`, line 135

```elixir
ttl: {52, :weeks},
```

JWT tokens issued by Guardian are valid for one full year with no evidence of a refresh-token rotation mechanism. A compromised token remains valid for up to 52 weeks. Industry standard for access tokens is minutes to hours; long-lived tokens dramatically extend the window of exploitation for stolen credentials.

**A122-7 — HIGH — GraphiQL interactive IDE configured with no authentication guard**

File: `lib/api_server_web/router.ex`, lines 198–202

```elixir
# forward "/graphiql",
#   Absinthe.Plug.GraphiQL,
#   schema: ApiServerWeb.Schema,
#   interface: :simple
```

The GraphiQL endpoint (interactive query IDE) is commented out but present. It is mounted at the same level as the main `/graphql` endpoint with no `:authenticated` pipeline. If re-enabled, it would expose the full interactive schema explorer to unauthenticated users.

---

### §3: Input Validation and Injection

**A122-8 — HIGH — Resolver accepts caller-controlled `customer` parameter with no validation or ownership check**

Files: `lib/api_server_web/schema.ex` lines 12–13, 26; `lib/api_server_web/resolvers/things.ex` lines 3–10, 13–21

The `:get_thing` and `:get_all_things` query fields accept a `customer` argument as a non-null string and pass it directly to context-scoped database queries. The `_resolution` parameter (which in Absinthe carries the authenticated context, including the current user's identity) is discarded with `_resolution` in both resolver functions. There is no check that the caller-supplied `customer` value matches the customer associated with the authenticated token. Any authenticated user can query data for any customer by supplying an arbitrary string.

**A122-9 — MEDIUM — Unbounded retry loop in PULS resolver is a denial-of-service vector**

File: `lib/api_server_web/resolvers/puls.ex`, lines 10–16

```elixir
:error ->
    IO.puts "Will attempt Re-send"
    receive do
    after
        60_000 ->
            puls_record(parent, %{hardwareid: hardwareid}, resolution)
    end
```

On HTTP error, the resolver tail-recursively retries indefinitely, sleeping 60 seconds between attempts. Each blocked GraphQL worker process holds a scheduler thread for the duration. A caller can trigger this by querying `:get_puls_record` for an invalid or unreachable hardware ID. Multiple concurrent requests could exhaust the BEAM process pool or trigger stack overflow via unbounded recursion.

**A122-10 — MEDIUM — `hardwareid` passed to external URL with no validation**

File: `lib/api_server_web/resolvers/puls.ex`, line 5

```elixir
url = "https://puls.calamp.com/service2/lmu/#{hardwareid}"
```

The `hardwareid` argument is interpolated directly into a URL without any format validation. While HTTPS to an external host limits the injection surface, an attacker-controlled hardware ID could be crafted to probe internal SSRF paths if the HTTP client follows redirects to non-HTTPS targets, or to enumerate valid device IDs in the CalAmp system.

§3: No additional injection issues found in the assigned schema files themselves.

---

### §4: Session and CSRF

The assigned files (`schema.ex`, `thing_types.ex`, `changeset_view.ex`) do not define session handling or CSRF logic. Observations from cross-reference context:

The endpoint at `lib/api_server_web/endpoint.ex` line 39 uses a hardcoded `signing_salt: "5CSDVUtC"` for session cookies, but this is less critical than the `secret_key_base` finding already covered under A122-3.

§4: No issues found within the scope of the three assigned files.

---

### §5: File and Data Handling

**A122-11 — HIGH — `:thing` type exposes GPS geolocation fields (`aadrange_lat`, `aadrange_long`) via GraphQL with no authorisation**

File: `lib/api_server_web/schema/thing_types.ex`, lines 33–34

```elixir
field :aadrange_lat, :float
field :aadrange_long, :float
```

The `:thing` GraphQL type exposes vehicle GPS coordinates. Combined with A122-5 (no authentication on the GraphQL endpoint) and A122-8 (caller-controlled `customer` parameter), these fields would be accessible to unauthenticated users or users querying across customer boundaries if the GraphQL endpoint is re-enabled. This constitutes potential PII and physical location disclosure for fleet vehicles and their operators.

**A122-12 — MEDIUM — `:thing` type exposes IMEI and mobile numbers**

File: `lib/api_server_web/schema/thing_types.ex`, lines 22–23

```elixir
field :aadmobile, :string
field :aadimei, :string
```

IMEI numbers and mobile phone numbers are personally identifiable device identifiers. These are exposed in the GraphQL `:thing` type with no field-level access control. If the GraphQL endpoint is re-enabled without authentication, this information would be publicly readable.

**A122-13 — LOW — `IO.puts` in production resolver leaks operational information to stdout**

File: `lib/api_server_web/resolvers/puls.ex`, line 11

```elixir
IO.puts "Will attempt Re-send"
```

`IO.puts/1` writes directly to stdout and bypasses the application's Logger configuration (log level filtering, structured metadata, redaction). In a containerised production deployment, stdout is typically captured by the host log aggregator. This is a code quality / minor information disclosure issue; no sensitive data appears in this specific message, but the pattern indicates the resolver was written without production logging discipline.

---

### §6: Dependencies

§6: Not directly evaluable from the three assigned files. No dependency declarations are made within `schema.ex`, `thing_types.ex`, or `changeset_view.ex`. Dependency review is deferred to other assigned agents.

---

### §7: Infrastructure Exposure

**A122-14 — MEDIUM — CalAmp PULS API hostname hardcoded in resolver**

File: `lib/api_server_web/resolvers/puls.ex`, line 5

```elixir
url = "https://puls.calamp.com/service2/lmu/#{hardwareid}"
```

The third-party CalAmp PULS service URL is hardcoded in source code. While the hostname itself is a vendor endpoint rather than internal infrastructure, the full URL path structure for the CalAmp LMU device API is disclosed in the repository. This is a minor information exposure and configuration management issue; the URL should be externalised to application configuration.

**A122-15 — HIGH — CORSPlug applied globally with no origin restriction visible in endpoint**

File: `lib/api_server_web/endpoint.ex`, line 42

```elixir
plug CORSPlug
```

`CORSPlug` is applied to the entire application at the endpoint level with no explicit configuration visible in the endpoint file. The default `CORSPlug` configuration allows all origins (`*`). This means CORS is permissive for all routes including authenticated API routes. The router shows commented-out `CORSPlug, origin: "*"` configurations (lines 13, 19) suggesting the intent was per-pipeline CORS configuration, but the global endpoint-level plug overrides this. For authenticated endpoints, permissive CORS enables cross-origin requests from attacker-controlled pages against authenticated sessions.

§7: No issues found in the three assigned files themselves beyond the above.

---

### GraphQL Schema Specific Checks

**A122-16 — HIGH — Absinthe introspection is enabled by default (no disable configuration)**

File: `lib/api_server_web/schema.ex`

Absinthe enables GraphQL introspection by default and the schema contains no `Absinthe.Schema.disable_introspection/0` call or equivalent middleware to disable `__schema`, `__type`, and `__typename` introspection queries. If the GraphQL endpoint is re-enabled, any caller (authenticated or not) can enumerate the complete schema structure including all object types, field names, argument names, and types. This directly reveals internal data model field naming conventions (the `aad`-prefixed field names that map to what appear to be database column names).

**A122-17 — INFO — GraphQL schema has shallow nesting; no deep-query DoS risk identified**

The schema as defined has a single level of object nesting: queries return `:thing` and `:puls_record`, both of which are flat scalar types with no nested object fields. There are no recursive or deeply nested type relationships. DoS via deeply nested queries is not a current risk given the schema topology, but should be re-evaluated if the schema is extended with nested object types.

---

### Changeset View Specific Checks

**A122-18 — LOW — Changeset error response exposes field names from Ecto schema**

File: `lib/api_server_web/views/changeset_view.ex`, lines 10–18

```elixir
def translate_errors(changeset) do
  Ecto.Changeset.traverse_errors(changeset, &translate_error/1)
end

def render("error.json", %{changeset: changeset}) do
  %{errors: translate_errors(changeset)}
end
```

`Ecto.Changeset.traverse_errors/2` returns a map keyed by the changeset field names (i.e., the Ecto schema field names, which correspond to database column names). The entire map is forwarded directly to the client as `%{errors: ...}`. This discloses the exact field names of the Ecto schema to any client that triggers a validation error. In this application the fields are named with database column naming conventions (e.g., `aadcustcode`, `aadmobile`, `aadimei`). While the risk is lower than exposing stack traces, it provides schema enumeration capability to an attacker probing the API. The error messages themselves are routed through `translate_error/1` via Gettext, which filters the message text — but the map keys (field names) are passed through unmodified.

---

## Summary Table

| ID      | Severity | File(s)                              | Issue                                                             |
|---------|----------|--------------------------------------|-------------------------------------------------------------------|
| A122-1  | CRITICAL | config/config.exs                    | Hardcoded AWS SES SMTP credentials (IAM key + password)           |
| A122-2  | CRITICAL | config/config.exs                    | Hardcoded Guardian JWT signing secret                             |
| A122-3  | CRITICAL | config/config.exs                    | Hardcoded Phoenix secret_key_base                                 |
| A122-4  | CRITICAL | resolvers/puls.ex                    | Hardcoded CalAmp PULS Basic Auth credential in source code        |
| A122-5  | CRITICAL | schema.ex, router.ex                 | All GraphQL queries lack authentication and authorization middleware |
| A122-6  | HIGH     | config/config.exs                    | Guardian JWT TTL is 52 weeks — tokens effectively non-expiring    |
| A122-7  | HIGH     | router.ex                            | GraphiQL IDE present with no authentication guard                 |
| A122-8  | HIGH     | schema.ex, resolvers/things.ex       | Caller-controlled `customer` param, no ownership verification (IDOR) |
| A122-9  | MEDIUM   | resolvers/puls.ex                    | Unbounded recursive retry loop — denial-of-service vector         |
| A122-10 | MEDIUM   | resolvers/puls.ex                    | Unvalidated `hardwareid` interpolated into external URL           |
| A122-11 | HIGH     | schema/thing_types.ex                | GPS coordinates (`aadrange_lat`, `aadrange_long`) exposed in GraphQL type without authorisation |
| A122-12 | MEDIUM   | schema/thing_types.ex                | IMEI and mobile phone number fields exposed in GraphQL type       |
| A122-13 | LOW      | resolvers/puls.ex                    | `IO.puts` in production path bypasses Logger                      |
| A122-14 | MEDIUM   | resolvers/puls.ex                    | CalAmp API hostname hardcoded (configuration management)          |
| A122-15 | HIGH     | endpoint.ex                          | CORSPlug applied globally with default allow-all origin           |
| A122-16 | HIGH     | schema.ex                            | Absinthe introspection not disabled — schema enumeration risk     |
| A122-17 | INFO     | schema.ex, schema/thing_types.ex     | Schema nesting is shallow; deep-query DoS not a current risk      |
| A122-18 | LOW      | views/changeset_view.ex              | Changeset errors expose Ecto field names (schema enumeration)     |

---

*Report generated by agent A122. No source files were modified.*
