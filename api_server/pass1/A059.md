# Pass 1 Security Audit — A059
**Agent:** A059
**Repo:** api_server (Elixir/Phoenix)
**Branch:** master
**Run:** 2026-02-27-01
**Auditor:** Claude Sonnet 4.6

---

## Assigned Files

1. `lib/api_server/operators/operators.ex`
2. `lib/api_server/repo.ex`
3. `lib/api_server/tcp/tcp.ex`

Supporting context files read (not assigned but referenced or required for full analysis):
- `lib/api_server/operators/file.ex`
- `lib/api_server/tcp/tcp_commands.ex`
- `config/config.exs`
- `config/dev.exs`
- `config/prod.exs`
- `config/prod.secret.exs`
- `.gitignore`

---

## Reading Evidence

---

### File 1: `lib/api_server/operators/operators.ex`

**Module name:** `ApiServer.Operators`

**Public functions (def):**

| Name | Arity | Line |
|---|---|---|
| `list_files` | 0 | 19 |
| `get_file!` | 1 | 37 |
| `create_file` | 1 | 51 |
| `update_file` | 2 | 69 |
| `delete_file` | 1 | 87 |
| `change_file` | 1 | 100 |

**defstruct / defexception / schema defined:** None (this is a context module; the schema is in `ApiServer.Operators.File`)

**use / import / alias at module level:**
- `import Ecto.Query, warn: false` (line 5)
- `alias ApiServer.Repo` (line 7)
- `alias ApiServer.Operators.File` (line 8)

---

### File 2: `lib/api_server/repo.ex`

**Module names:** `ApiServer.Repo` and `ApiServer.FortyNineRepo` (both defined in this file)

**Public functions (def):**

| Module | Name | Arity | Line |
|---|---|---|---|
| `ApiServer.Repo` | `init` | 2 | 8 |

**defstruct / defexception / schema defined:** None

**use / import / alias at module level:**
- `ApiServer.Repo`: `use Ecto.Repo, otp_app: :api_server` (line 2)
- `ApiServer.FortyNineRepo`: `use Ecto.Repo, otp_app: :api_server` (line 14)

---

### File 3: `lib/api_server/tcp/tcp.ex`

**Module name:** `ApiServer.TCP`

**Public functions (def):**

| Name | Arity | Line |
|---|---|---|
| `accept` | 1 | 23 |

**Private functions (defp) — listed for completeness:**
- `loop_acceptor/1` (line 32)
- `serve/2` (line 48)
- `read_line/3` (line 90)
- `write_line/2` (line 135, 139, 143, 147 — multiple clauses)

**defstruct / defexception / schema defined:** None

**use / import / alias at module level:**
- `import Ecto.Query, warn: false` (line 7)
- `alias ApiServer.Repo` (line 8)
- `alias ApiServer.Vx.VXUser` (line 9)
- `alias ApiServer.Vx.VXThingEvent` (line 10)
- `alias ApiServer.Vx.VXThingEventOmega` (line 11)
- `alias ApiServer.Vx.VXThingEventOmegaTires` (line 12)
- `alias ApiServer.Vx.VXFleetAssociation` (line 13)
- `alias ApiServer.Vx.VXRestriction` (line 14)
- `alias ApiServer.Vx.Geofence` (line 15)
- `alias ApiServer.Vx.VXThing` (line 16)
- `alias ApiServer.Vx.VXAblRecord` (line 17)
- `alias ApiServer.Vx.VXRayvenMessageLog` (line 18)
- `require Logger` (line 21)

---

## Checklist Review

---

### §1: Secrets and Configuration

**Finding A059-1 — CRITICAL: AWS SES SMTP credentials hardcoded in tracked config files**

`config/config.exs` lines 117–120 and identically in `config/dev.exs` lines 98–101 and `config/prod.exs` lines 45–48:

```elixir
username: "[REDACTED-AWS-KEY-ID]",
password: "[REDACTED-AWS-SMTP-PASSWORD]",
```

These are plaintext AWS IAM access key ID and SMTP password for the SES service. They appear identically in three separate tracked config files (`config.exs`, `dev.exs`, `prod.exs`). All three files are committed to version control. The AWS access key `[REDACTED-AWS-KEY-ID]` follows the AWS IAM key format and must be treated as a live, compromised credential. Additionally, commented-out credentials for a previous key (`[REDACTED-AWS-KEY-ID]` / `[REDACTED-AWS-SMTP-PASSWORD]`) also appear in all three files, suggesting a prior rotation that did not remove the old values from source.

---

**Finding A059-2 — CRITICAL: Phoenix secret_key_base hardcoded in tracked config files**

`config/config.exs` line 15:
```elixir
secret_key_base: "djHcKcu+CWBtfoT6k1mLsC1ObkKOy1ZF1G840aRXnQ+oAgAU9efRLUJ+yTd3x/Fh",
```

`config/prod.secret.exs` line 12:
```elixir
secret_key_base: "glcsjqnr64PEc+Las0f0pIwIBr/J91VELfvyzCWgXGWXOSg/Ow4eX0hWCNvspNjN",
```

The `secret_key_base` is used by Phoenix to sign session cookies and other cryptographic tokens. Two different values are tracked in source — one in `config.exs` (the base/dev default) and a different one in `prod.secret.exs`. Despite the file being named `prod.secret.exs`, the `.gitignore` contains the line `# /config/*.secret.exs` (commented out), meaning the exclusion rule is disabled. `prod.secret.exs` is being committed to version control. Any attacker with repository read access can forge session cookies for the production instance.

---

**Finding A059-3 — CRITICAL: Guardian JWT secret_key hardcoded in tracked config**

`config/config.exs` lines 133–136:
```elixir
config :api_server, ApiServer.Guardian,
  issuer: "rhmapi",
  ttl: {52, :weeks},
  secret_key: "wf1TLkCaEKIPY61A5LvxtPrUA63wrV/hz0RAtaDPh7BENw5WgsCPUN0/qH65BYmA"
```

The Guardian HMAC signing secret is hardcoded in a tracked file. Any party with repository access can forge valid JWT authentication tokens for any user. The `ttl` of 52 weeks (1 year) compounds the risk — tokens issued with this key are valid for a full year, and since the key is public, offline token forgery is trivial.

---

**Finding A059-4 — CRITICAL: Database credentials hardcoded in tracked config files**

Multiple databases have credentials embedded in tracked files:

`config/prod.exs` lines 14–18 (`ApiServer.FortyNineRepo`, external MySQL host):
```elixir
username: "svr49_hi_x_user",
password: "Q973bFtc9z/cVW#mA",
hostname: "svr49.tracking-intelligence.com",
```

`config/prod.exs` lines 33–36 (`ApiServer.Repo`, AWS RDS Aurora):
```elixir
username: "vxaurorasyduser",
password: "TRxbixk9fuZc",
hostname: "vxsandboxsydneytest-cluster-1.cluster-c4fwadrw9quy.ap-southeast-2.rds.amazonaws.com",
port: 3306
```

`config/dev.exs` repeats the same credentials for both repos (lines 60–88).

These credentials are in tracked files. The Aurora RDS endpoint `vxsandboxsydneytest-cluster-1.cluster-c4fwadrw9quy.ap-southeast-2.rds.amazonaws.com` reveals the AWS cluster identifier and region (`ap-southeast-2`), directly exposing infrastructure topology. The external `svr49.tracking-intelligence.com` hostname exposes a third-party partner's server identity. Note: `ApiServer.Repo.init/2` (in `repo.ex` line 9) does correctly load the primary repo URL from `DATABASE_URL` at runtime — however this is overridden by the static config in `prod.exs` and `dev.exs` which set all connection fields explicitly, meaning the `init/2` runtime override may not take effect when the adapter, database, username, password, and hostname keys are already set by the environment-specific config.

---

**Finding A059-5 — HIGH: Third-party service password hardcoded in tcp_commands.ex**

`lib/api_server/tcp/tcp_commands.ex` lines 1221 and 1306 (and again at lines 1891–1892):
```elixir
WSUSERNAME: "trility",
WSPASSWORD: "@trility!",
```

These are hardcoded credentials written into every `[REDACTED-AWS-SMTP-PASSWORD]` record inserted into the FortyNine database. This is a plaintext credential embedded in application source code for a downstream web service integration. The password appears three times in the file across different code paths.

---

**Finding A059-6 — MEDIUM: .gitignore does not exclude prod.secret.exs**

`.gitignore` line 27:
```
# /config/*.secret.exs
```

The line that would exclude secret config files is commented out. The Phoenix project generator adds this exclusion by default; it has been manually disabled here. As a result, `prod.secret.exs` is tracked and committed (confirmed above in Finding A059-2). The comment on line 21–26 of the `.gitignore` acknowledges this is a secret file and documents the risk, making this a deliberate decision rather than an oversight — but the outcome is the same: production secrets are in version control.

---

**Finding A059-7 — MEDIUM: Geonames username hardcoded in config.exs**

`config/config.exs` lines 138–140:
```elixir
config :geonames,
  username: "vinxstudio",
  language: "en"
```

A Geonames API service username is hardcoded in a tracked config file. While Geonames accounts have limited blast radius compared to AWS credentials, this still constitutes a hardcoded third-party service credential in version control.

---

**Finding A059-8 — INFO: Commented-out AWS EC2 hostname in prod.exs**

`config/prod.exs` line 22 (commented):
```elixir
# hostname: "ec2-13-210-120-188.ap-southeast-2.compute.amazonaws.com",
```

A public EC2 IP address (13.210.120.188) in the ap-southeast-2 region is present in a comment. While commented out, this reveals a historical infrastructure endpoint that may still be live or may assist in mapping the network topology.

---

### §2: Authentication and Authorization

**Finding A059-9 — HIGH: Guardian TTL is 52 weeks (1 year)**

`config/config.exs` line 135:
```elixir
ttl: {52, :weeks},
```

JWT tokens issued by Guardian have a one-year validity window. Combined with the hardcoded secret key (A059-3), any issued token cannot be revoked short of rotating the signing key (which would invalidate all active tokens). Even without A059-3, a one-year TTL is excessive for an API serving fleet management and vehicle location data. There is no evidence of a refresh token policy or token revocation mechanism in the assigned files.

**Note regarding assigned files:** `operators.ex` and `repo.ex` are context/data-access modules, not controllers or routers. Authorization checks at the context layer (i.e., whether `list_files/0` and `get_file!` are scoped to an authenticated user's organisation) cannot be evaluated from these files alone; this must be reviewed at the controller/router level. The `ApiServer.Operators` module has no organisation-scoping in any of its functions — `list_files/0` returns all records from the `files` table globally, and `get_file!/1` takes a bare ID with no ownership check. Whether this is protected at the controller layer is outside the assigned scope.

---

### §3: Input Validation and Injection

**Finding A059-10 — HIGH: Binary pattern matching in TCP parser performs no length bounds checking before slice**

`lib/api_server/tcp/tcp_commands.ex` line 92 (within `parse_data_message/3`):
```elixir
<<record::bytes-size(record_length), next_remainder::binary>> = remainder
```

`record_length` is decoded from the device-supplied binary payload (line 42). A device (or attacker) sending a crafted packet with a `record_length` value larger than the actual remaining binary will cause a `MatchError` (pattern match failure), crashing the serving `Task`. This is a denial-of-service vector against any TCP-connected device session. The same pattern repeats in `parse_data_record/3` (line 183), `parse_debug_record/3` (line 143), and field-level length parsing throughout `parse_data_record`. There is no guard ensuring `record_length <= byte_size(remainder)` before the destructuring match.

Similarly, `parse_analog32_field/1` (line 1523) does:
```elixir
[final_input1, final_input2, final_input3] = [
  Enum.at(analog_values, 0),
  Enum.at(analog_values, 1),
  Enum.at(analog_values, 2)
]
```
If the analog payload contains fewer than 3 values, `Enum.at` returns `nil` and the match succeeds, but downstream arithmetic on `nil` values will raise `ArithmeticError`. In `parse_driverid_field/1` (line 1597), `driverid_size_byte` is derived entirely from device-supplied data with no upper-bound validation.

---

**Finding A059-11 — MEDIUM: TCP server has no authentication or device verification before processing data records**

`lib/api_server/tcp/tcp.ex` — the `serve/2` / `read_line/3` / `loop_acceptor/1` chain accepts any TCP connection on the configured port and immediately begins processing binary frames. There is no IP allowlist, no TLS (the socket is opened with `:binary` and no SSL options at line 25), no pre-authentication challenge, and no rate limiting. The only device validation is in `parse_hello_message/1` (tcp_commands.ex line 20), which calls `device_lookup_with_hardware_id/1` — but if the device is not found, the error path returns `{:error, {:error, "error", %{}}}` and the `serve/2` function continues listening on the same socket (the error from `parse_hello_message` is passed back as the result of `Commands.parse`, then `Commands.run` is called on the error tuple). A device that fails the hello check is not disconnected. Data record frames (`<<4>>`) are processed without requiring a prior successful hello. Any host on the network that can reach the TCP port can inject telemetry records.

---

### §4: Session and CSRF

**§4: No issues found in the assigned files.** The assigned files (`operators.ex`, `repo.ex`, `tcp.ex`) do not implement session management or CSRF logic. The TCP server is a binary protocol handler unrelated to CSRF. Session configuration must be evaluated in the endpoint/router/plug pipeline, which is outside the assigned scope.

---

### §5: File and Data Handling

**Finding A059-12 — HIGH: Driver ID data (PII) logged to stdout via IO.puts in tcp_commands.ex**

`lib/api_server/tcp/tcp_commands.ex` lines 1666–1668:
```elixir
IO.puts(
  "driverid info parsed: type: #{driverid_type} data: #{driverid_data_encoded} final payload: #{inspect(driverid_parsed)}"
)
```

Every driver ID parsed from a device packet — including iButton codes (type 2, Base16-encoded 6-byte hardware ID) and Wiegand RFID card numbers (type 7) — is unconditionally written to standard output via `IO.puts`. This is PII (driver identification data) being written to process stdout on every single telemetry event that contains a driver ID. `IO.puts` output goes to the OS process stdout and is not controlled by the application's Logger level configuration. It cannot be silenced without code changes.

---

**Finding A059-13 — MEDIUM: Hardcoded customer code "TRILITY" and hardcoded hardware_id in parse_iridium**

`lib/api_server/tcp/tcp_commands.ex` lines 1756 and 1810:
```elixir
hardware_id = 462_743
customer = "vx_trility"
```

The `parse_iridium/2` function hardcodes both the target customer schema (`vx_trility`) and the hardware device ID (`462_743`). All Iridium-protocol messages are routed to a single customer, regardless of any device-to-customer mapping. This is a data isolation defect: if the TCP server ever receives Iridium traffic from a device that is not serial 462743 (or belongs to a different customer), the data is silently misattributed to the `vx_trility` customer schema. This is a cross-customer data boundary violation for fleet management data (checklist §5, fleet data must be scoped to the authenticated user's organisation).

---

**Finding A059-14 — INFO: IO.puts debug logging of device serial numbers and sensor data throughout tcp_commands.ex**

Multiple `IO.puts` calls throughout `tcp_commands.ex` log GPS coordinates, analog sensor values, and device serial numbers to stdout, gated only on membership in a hardcoded list of test serial numbers (e.g., `625_425`, the "yabby3" list at lines 780–821). These appear to be development debug statements. GPS coordinates and serial numbers constitute fleet tracking data that should not appear in plaintext in process logs outside of a controlled logging framework.

---

### §6: Dependencies

**§6: Cannot be fully evaluated from the assigned source files.** `mix.exs` and `mix.lock` are outside the assigned scope for this agent. However, the use of `Ecto.Adapters.MySQL` (not `MyXQL`, the modern replacement) in both repo configurations (`prod.exs`, `dev.exs`) is noted. The deprecated `Mariaex` adapter may be in use — this must be confirmed by a pass that reviews `mix.exs`/`mix.lock`.

---

### §7: Infrastructure Exposure

**Finding A059-15 — HIGH: AWS RDS Aurora cluster endpoint and region hardcoded in tracked config**

`config/prod.exs` line 36:
```elixir
hostname: "vxsandboxsydneytest-cluster-1.cluster-c4fwadrw9quy.ap-southeast-2.rds.amazonaws.com",
```

The full RDS cluster endpoint is committed to version control. This reveals: the cluster identifier (`vxsandboxsydneytest-cluster-1`), the Aurora cluster DNS suffix (`cluster-c4fwadrw9quy`), and the AWS region (`ap-southeast-2`). Combined with the hardcoded credentials in A059-4, this gives a complete connection string for direct database access.

---

**Finding A059-16 — HIGH: TCP server has no TLS — device telemetry is transmitted in plaintext**

`lib/api_server/tcp/tcp.ex` line 25:
```elixir
:gen_tcp.listen(port, [:binary, reuseaddr: true, active: false])
```

The TCP listener uses plain `:gen_tcp` with no SSL options. Vehicle telemetry data including GPS coordinates, driver IDs, speed, and ignition state are transmitted over the network in plaintext binary frames. An on-path attacker can read all device data or inject crafted packets. For a fleet management system processing vehicle location data, the absence of transport security is a significant exposure.

---

**Finding A059-17 — MEDIUM: External MySQL hostname for third-party integration exposed in tracked config**

`config/prod.exs` line 17 (and `dev.exs` line 65):
```elixir
hostname: "svr49.tracking-intelligence.com",
```

The hostname of an external partner system (`svr49.tracking-intelligence.com`) is hardcoded in tracked config files alongside valid credentials (A059-4). This reveals the partner organisation's server infrastructure and provides a complete attack vector against that system.

---

**Finding A059-18 — INFO: Unused aliases in tcp.ex**

`lib/api_server/tcp/tcp.ex` lines 9–18 contain 10 aliases (`VXUser`, `VXThingEvent`, `VXThingEventOmega`, `[REDACTED-AWS-SMTP-PASSWORD]`, `VXFleetAssociation`, `VXRestriction`, `Geofence`, `VXThing`, `VXAblRecord`, `VXRayvenMessageLog`) and an `import Ecto.Query`. A comment at line 6 acknowledges these need cleaning up ("Clean these up after we know which ones we use"). None of these aliases appear to be referenced in `tcp.ex` itself (all database work is delegated to `tcp_commands.ex`). This is dead code that should be removed to reduce the attack surface understanding, but does not introduce a direct vulnerability.

---

## Summary of Findings

| ID | Severity | Location | Summary |
|---|---|---|---|
| A059-1 | CRITICAL | `config/config.exs`, `dev.exs`, `prod.exs` | AWS SES SMTP credentials (IAM key + password) hardcoded in three tracked files |
| A059-2 | CRITICAL | `config/config.exs`, `prod.secret.exs` | Phoenix `secret_key_base` hardcoded in tracked files; `.gitignore` exclusion is commented out |
| A059-3 | CRITICAL | `config/config.exs` | Guardian JWT signing secret hardcoded in tracked file; 52-week token TTL |
| A059-4 | CRITICAL | `config/prod.exs`, `config/dev.exs` | Database credentials for Aurora RDS and external MySQL hardcoded in tracked files |
| A059-5 | HIGH | `lib/api_server/tcp/tcp_commands.ex` | Plaintext third-party web service password hardcoded and written to database |
| A059-6 | MEDIUM | `.gitignore` | `prod.secret.exs` exclusion rule commented out; file is tracked |
| A059-7 | MEDIUM | `config/config.exs` | Geonames API username hardcoded |
| A059-8 | INFO | `config/prod.exs` | Historical AWS EC2 IP address in comment |
| A059-9 | HIGH | `config/config.exs` | Guardian JWT TTL of 52 weeks is excessive for a fleet data API |
| A059-10 | HIGH | `lib/api_server/tcp/tcp_commands.ex` | No bounds validation before binary slice from device-supplied length field; DoS via crafted packet |
| A059-11 | MEDIUM | `lib/api_server/tcp/tcp.ex` | TCP server accepts all connections with no TLS, no authentication, no rate limiting |
| A059-12 | HIGH | `lib/api_server/tcp/tcp_commands.ex` | Driver ID (PII) unconditionally logged to stdout via `IO.puts` on every telemetry event |
| A059-13 | MEDIUM | `lib/api_server/tcp/tcp_commands.ex` | Hardcoded hardware_id and customer code in `parse_iridium/2`; data isolation violation |
| A059-14 | INFO | `lib/api_server/tcp/tcp_commands.ex` | Debug `IO.puts` statements log GPS/sensor data to stdout for specific serial numbers |
| A059-15 | HIGH | `config/prod.exs` | Full RDS Aurora cluster endpoint (with region) committed to version control |
| A059-16 | HIGH | `lib/api_server/tcp/tcp.ex` | TCP server uses no TLS; vehicle telemetry transmitted in plaintext |
| A059-17 | MEDIUM | `config/prod.exs`, `config/dev.exs` | External partner hostname exposed in tracked config alongside credentials |
| A059-18 | INFO | `lib/api_server/tcp/tcp.ex` | Ten unused module aliases acknowledged as dead code |
