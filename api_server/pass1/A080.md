# Audit Report A080
**Agent:** A080
**Repo:** api_server
**Stack:** Elixir/Phoenix
**Branch:** master
**Run:** 2026-02-27-01
**Auditor pass:** Pass 1

---

## Assigned Files

1. `lib/api_server/vx/vx_rayven_stream_status.ex`
2. `lib/api_server/vx/vx_rental.ex`
3. `lib/api_server/vx/vx_restriction.ex`

---

## Reading Evidence

### File 1 — `lib/api_server/vx/vx_rayven_stream_status.ex`

**Module name:** `ApiServer.Vx.VXRayvenStreamStatus`

**Public functions (def):**

| Name | Arity | Line |
|------|-------|------|
| `changeset` | 2 | 17 |

**Schema defined:** `"rayven_stream_status"` (primary key: `id` — autogenerate: true)

Fields:
- `:thing_id` — `:integer`
- `:hardware_id` — `:integer`
- `:last_event` — `:integer`
- `:last_event_time` — `:utc_datetime`
- `:streamed_at` — `:utc_datetime`
- `:delay` — `:integer`
- `:num_remaining` — `:integer`
- `:batch` — `:integer`

**use/import/alias:**
- `use Ecto.Schema`
- `import Ecto.Changeset`

---

### File 2 — `lib/api_server/vx/vx_rental.ex`

**Module name:** `ApiServer.Vx.VXRental`

**Public functions (def):**

| Name | Arity | Line |
|------|-------|------|
| `get_all_anniversaries_between_dates` | 4 | 24 |
| `get_current_rental_period_start` | 2 | 112 |
| `calculate_period_end_date` | 3 | 119 |
| `has_anniversary_on_day?` | 3 | 146 |
| `changeset` | 2 | 158 |
| `generate_previous_period_anniversay` | 3 | 246 |

**Private functions (defp):**
- `get_all_subsequent_anniversaries/5` (line 77)
- `generate_next_period_anniversay/3` (line 176)
- `calculate_period_start_date/3` (line 468)

**Schema defined:** `"abh_rentals"` (primary key: `abhid` — autogenerate: true)

Fields:
- `:abhcustcode` — `:string`
- `:abhclient` — `:string`
- `:abhstartdate` — `:date`
- `:abhenddate` — `:date`
- `:abhtransdate` — `:utc_datetime`
- `:abhnotes` — `:string`
- `:abhrental_freq` — `:string`
- `:abhallowed_hours` — `:integer`
- `:abhreport_freq` — `:string`
- `:abhcustomerid` — `:integer`
- `:period_calculation` — `:string`

Associations:
- `has_one :customer` — `ApiServer.Vx.VXCustomer` (foreign_key: `:aaaid`, references: `:abhcustomerid`)
- `belongs_to :thing` — `ApiServer.Vx.VXThing` (foreign_key: `:abhthingid`, references: `:aadid`)

**use/import/alias:**
- `use Ecto.Schema`
- `import Ecto.Changeset`

---

### File 3 — `lib/api_server/vx/vx_restriction.ex`

**Module name:** `ApiServer.Vx.VXRestriction`

**Public functions (def):**

| Name | Arity | Line |
|------|-------|------|
| `changeset` | 2 | 16 |

**Schema defined:** `"aau_rest"` (primary key: `aauid` — autogenerate: true)

Fields:
- `:aaucharval` — `:string`
- `:aaucustcode` — `:string`
- `:aaufun` — `:string`
- `:aaunumval` — `:integer`

Associations:
- `belongs_to :user` — `ApiServer.Vx.VXUser` (foreign_key: `:aauuser_id`, references: `:aacid`)

**use/import/alias:**
- `use Ecto.Schema`
- `import Ecto.Changeset`

---

## Checklist Review

### §1: Secrets and Configuration

No hardcoded credentials, API keys, database passwords, secret key bases, AWS credentials, RDS endpoints, or infrastructure identifiers appear in any of the three assigned files. All three files are pure schema and business-logic modules with no configuration loading.

**§1: No issues found.**

---

### §2: Authentication and Authorization

Cross-file context examined: `lib/api_server_web/controllers/vx_rental_controller.ex`, `lib/api_server_web/controllers/vx_restriction_controller.ex`, `lib/api_server_web/router.ex`, and `lib/api_server/vx/vx.ex` were reviewed to understand how the schemas are consumed.

**Rental controller — `customer` sourced from URL path parameter, not the JWT (CRITICAL)**

Routes in the router pattern-match `customer` from the URL path:

```
post("/rhm/:customer/rentals/", VXRentalController, :update_rental)
put("/rhm/:customer/rentals/",  VXRentalController, :create_rental)
delete("/rhm/:customer/rentals/:id", VXRentalController, :delete_rental)
```

The controller actions `create_rental/2`, `update_rental/2`, and `delete_rental/2` destructure `customer` from `params` (the path/body parameter map) and pass it directly as the Ecto multi-tenant prefix:

```elixir
def create_rental(conn, %{"customer" => customer, "rental" => rental_params}) do
  ...
  case Vx.create_rental(changeset, customer) do

def update_rental(conn, %{"customer" => customer, "rental" => rental_params}) do
  rental = Vx.get_rental(rental_params["id"], customer)
  ...
  Vx.update_rental(rental, changeset, customer)

def delete_rental(conn, %{"customer" => customer, "id" => id}) do
  rental = Vx.get_rental(id, customer)
  ...
  Vx.delete_rental(rental, customer)
```

By contrast, the read-only actions `get_rentals/2` and `rhm_active_rental/2` correctly extract `customer` from the JWT claims:

```elixir
customer = ApiServer.Guardian.Plug.current_claims(conn)["customer"]
```

An authenticated user from customer A can supply any other customer's schema name in the URL and successfully create, update, or delete rental records in that customer's data partition. This is a cross-tenant access (IDOR / tenant escape) vulnerability affecting fleet management data.

**`generate_previous_period_anniversay/3` is a public function but is a pure calculation helper with no authorization implications in isolation.** The concern is in the controller layer calling it with unsanitised tenant context.

**`list_vxaau_rest/0` in `vx.ex` has no tenant prefix**

```elixir
def list_vxaau_rest do
  Repo.all(VXRestriction)   # no prefix: customer
end
```

This context function (called from `vx.ex`) queries the `aau_rest` table without a multi-tenant prefix, which could return restriction rows across all tenants. If exposed via any endpoint this is a data-leakage path. The similar `get_vx_restriction!/1` also lacks a tenant prefix.

**`create_vx_restriction/1` and `update_vx_restriction/2` / `delete_vx_restriction/1` in `vx.ex` also have no tenant prefix:**

```elixir
def create_vx_restriction(attrs \\ %{}) do
  %VXRestriction{} |> VXRestriction.changeset(attrs) |> Repo.insert()
end

def update_vx_restriction(%VXRestriction{} = vx_restriction, attrs) do
  vx_restriction |> VXRestriction.changeset(attrs) |> Repo.update()
end

def delete_vx_restriction(%VXRestriction{} = vx_restriction) do
  Repo.delete(vx_restriction)
end
```

These are contrast to `add_fleet_to_user/3` and `get_restriction/4` which do pass `prefix: customer`. This inconsistency means the scaffold-generated CRUD helpers for VXRestriction are unusable safely. `[REDACTED-AWS-SMTP-PASSWORD]` is currently empty (no actions), so these helpers are not currently exercised via HTTP, but they remain dangerous dead code.

**Finding raised below as A080-1 and A080-2.**

---

### §3: Input Validation and Injection

**VXRayvenStreamStatus — `changeset/2` has no `validate_required/2`**

All fields are accepted via `cast/3` but none are marked required. When `update_rayven_stream_status_record/2` calls this changeset for an upsert, it passes `attrs` that are mapped directly from internal pipeline data (not direct user input), so immediate injection risk is low. However the absence of required-field validation means the changeset provides no integrity guarantee.

**VXRental — `changeset/2` has no `validate_required/2`**

The rental changeset casts 11 fields but validates none as required. In `create_rental/2` and `update_rental/2`, the controller constructs the changeset via `VXRentalView.convert_json_to_changeset/1` from request body data and passes it to the context. The absence of required-field validation means a caller can create a rental with null `abhstartdate` or null `abhrental_freq`, which would cause runtime exceptions in the business-logic functions (`calculate_period_start_date/3` calls `Timex.format!/2` on `rental.abhstartdate` — a nil value here raises at runtime).

**`get_all_anniversaries_between_dates/4` — unchecked `Date.from_iso8601!` on caller-supplied strings**

```elixir
{_, to_datetime}   = NaiveDateTime.new(Date.from_iso8601!(to_date),   ~T[23:59:59.001])
{_, from_datetime} = NaiveDateTime.new(Date.from_iso8601!(from_date), ~T[00:00:01.001])
```

`Date.from_iso8601!/1` raises `ArgumentError` on malformed input. This is called from `VXRentalController.get_rental_anniversaries/2` with `to_date` and `from_date` taken directly from URL query parameters. An authenticated user supplying a non-ISO-8601 value will cause an unhandled exception; depending on the error handler this may leak a stack trace.

No raw SQL fragments (`Ecto.Adapters.SQL.query/3` or `fragment/1` with interpolated user input), `String.to_atom/1`, `binary_to_term/1`, or `Code.eval_string/1` were found in the three assigned files.

**Finding raised as A080-3 and A080-4.**

---

### §4: Session and CSRF

The three assigned files are schema/business-logic modules. They contain no plug, pipeline, channel, or session configuration. CSRF and WebSocket concerns are not applicable to these files directly.

**§4: No issues found in assigned files.**

---

### §5: File and Data Handling

**VXRestriction — `aaufun` field controls access/function gating with no validation**

`aaufun` is a free-text `:string` field. In `vx.ex` the value `"FLEET"` is hard-coded in queries:

```elixir
|> Ecto.Query.where(aaufun: ^"FLEET")
```

The `VXRestriction.changeset/2` accepts `aaufun` via `cast/3` with no `validate_inclusion/4` constraint. If a code path ever writes a restriction row sourced from user input without validating the `aaufun` value, an attacker could inject arbitrary function names or corrupt restriction records. Currently not directly exploitable via HTTP (controller is empty), but constitutes a missing integrity guard on security-sensitive data.

**VXRental — fleet/customer data returned without organisation scope check**

`list_all_rentals/1` and `list_open_rentals/1` in `vx.ex` return all rentals for the supplied `customer` prefix. The `customer` value for these calls in `get_rentals/2` and `get_midpac_style_rental_report/2` is correctly sourced from the JWT. However `create_rental`, `update_rental`, and `delete_rental` use an attacker-controlled `customer` (see A080-1), so rental records, vehicle details, serial numbers, allowed hours, and customer names can be read across tenant boundaries via the mutating endpoints.

**No PII logging (`Logger.*`) was found in any of the three assigned files.**

**§5: No additional issues beyond those captured in A080-1.**

---

### §6: Dependencies

The three assigned files use only `Ecto.Schema`, `Ecto.Changeset`, and the `Timex` library (via public API calls). No dependency declarations appear in these files; dependency audit is a `mix.exs`/`mix.lock` concern outside the scope of these three files.

**§6: No issues found in assigned files.**

---

### §7: Infrastructure Exposure

No hardcoded hostnames, IPs, port numbers, CORS configuration, or TLS configuration appear in any of the three assigned files.

**§7: No issues found.**

---

## Findings

---

### A080-1 — CRITICAL: Tenant escape via attacker-controlled `customer` parameter in rental write endpoints

**File:** `lib/api_server_web/controllers/vx_rental_controller.ex` (controller consuming `VXRental` schema)
**Schema:** `lib/api_server/vx/vx_rental.ex`

**Routes:**
```
POST   /api/v1/rhm/:customer/rentals/    → VXRentalController.update_rental/2
PUT    /api/v1/rhm/:customer/rentals/    → VXRentalController.create_rental/2
DELETE /api/v1/rhm/:customer/rentals/:id → VXRentalController.delete_rental/2
```

**Evidence:**

```elixir
# create_rental — customer from URL param, NOT from JWT
def create_rental(conn, %{"customer" => customer, "rental" => rental_params}) do
  changeset = ApiServerWeb.VXRentalView.convert_json_to_changeset(rental_params)
  case Vx.create_rental(changeset, customer) do   # customer is attacker-controlled

# update_rental — customer from URL param, NOT from JWT
def update_rental(conn, %{"customer" => customer, "rental" => rental_params}) do
  rental = Vx.get_rental(rental_params["id"], customer)  # wrong tenant lookup

# delete_rental — customer from URL param, NOT from JWT
def delete_rental(conn, %{"customer" => customer, "id" => id}) do
  rental = Vx.get_rental(id, customer)   # wrong tenant lookup
```

Contrast with the read actions which correctly use:
```elixir
customer = ApiServer.Guardian.Plug.current_claims(conn)["customer"]
```

**Impact:** Any authenticated user can supply an arbitrary `customer` schema name in the URL path to create, update, or delete rental records in any other customer's partition. This exposes fleet vehicle records, serial numbers, rental contract terms, customer names, and allowed hours for the entire system.

**Recommendation:** Replace `%{"customer" => customer, ...}` destructuring with `ApiServer.Guardian.Plug.current_claims(conn)["customer"]` in all three write action heads. The URL `/:customer` path segment should be validated against the JWT claim or removed.

---

### A080-2 — HIGH: VXRestriction scaffold CRUD helpers operate without tenant prefix

**File:** `lib/api_server/vx/vx.ex` (consuming `lib/api_server/vx/vx_restriction.ex`)

```elixir
def list_vxaau_rest do
  Repo.all(VXRestriction)                          # no prefix: customer
end

def get_vx_restriction!(id), do: Repo.get!(VXRestriction, id)  # no prefix

def create_vx_restriction(attrs \\ %{}) do
  %VXRestriction{} |> VXRestriction.changeset(attrs) |> Repo.insert()  # no prefix
end

def update_vx_restriction(%VXRestriction{} = vx_restriction, attrs) do
  vx_restriction |> VXRestriction.changeset(attrs) |> Repo.update()   # no prefix
end

def delete_vx_restriction(%VXRestriction{} = vx_restriction) do
  Repo.delete(vx_restriction)                      # no prefix
end
```

The `aau_rest` table holds per-user fleet access restrictions which are security controls (rows with `aaufun = "FLEET"` gate which fleets a user may access). The tenant-unscoped helpers would read or write the default (un-prefixed) schema, which is likely either empty or the wrong tenant entirely. The production-correct equivalents `add_fleet_to_user/3` and `get_restriction/4` both use `prefix: customer`, confirming this is not intentional.

**Impact:** If any code path calls the scaffold helpers, restriction rows are written to or read from the wrong tenant, potentially granting or denying users access to fleets in another organisation, or silently failing. Currently the `[REDACTED-AWS-SMTP-PASSWORD]` is empty so there is no live HTTP path, but the helpers exist and can be called from elsewhere or added by a future developer without recognising the risk.

**Recommendation:** Add a `customer` parameter to all five scaffold helpers and pass `prefix: customer` to every `Repo.*` call, consistent with `add_fleet_to_user/3`. Alternatively, remove the scaffold helpers entirely and direct callers to the correctly-scoped helpers.

---

### A080-3 — MEDIUM: Unhandled exception on malformed date input in `get_rental_anniversaries`

**File:** `lib/api_server/vx/vx_rental.ex` (lines 25–26), called from `vx_rental_controller.ex` line 119

```elixir
def get_all_anniversaries_between_dates(rental, to_date, from_date, user_timezone) do
  {_, to_datetime}   = NaiveDateTime.new(Date.from_iso8601!(to_date),   ~T[23:59:59.001])
  {_, from_datetime} = NaiveDateTime.new(Date.from_iso8601!(from_date), ~T[00:00:01.001])
```

`Date.from_iso8601!/1` raises `ArgumentError` when the string is not a valid ISO-8601 date. The call site in the controller does not rescue this exception:

```elixir
# vx_rental_controller.ex line 119
all_anniversaries = VXRental.get_all_anniversaries_between_dates(rental, to_date, from_date, user_timezone)
```

`to_date` and `from_date` come directly from `%{"hardwareid" => hardwareid, "from" => from_date, "to" => to_date}` — user-supplied query parameters. A malformed value causes a 500, and depending on the error view configuration may return a stack trace to the caller.

**Recommendation:** Replace `Date.from_iso8601!/1` with `Date.from_iso8601/1` and pattern-match the `{:ok, date}` / `{:error, _}` result, returning a 400 Bad Request for invalid input.

---

### A080-4 — LOW: VXRayvenStreamStatus and VXRental changesets have no `validate_required` constraints

**Files:** `lib/api_server/vx/vx_rayven_stream_status.ex` (line 17), `lib/api_server/vx/vx_rental.ex` (line 158)

```elixir
# vx_rayven_stream_status.ex
def changeset(rayven_stream_status, attrs) do
  rayven_stream_status
  |> cast(attrs, [:thing_id, :hardware_id, :last_event, :last_event_time,
                  :streamed_at, :delay, :num_remaining, :batch])
  # no validate_required
end

# vx_rental.ex
def changeset(vx_rental, attrs) do
  vx_rental
  |> cast(attrs, [:abhid, :abhclient, :abhcustomerid, :abhthingid,
                  :abhstartdate, :abhenddate, :abhtransdate, :abhnotes,
                  :abhrentalfreq, :abhallowed_hours, :abhreport_freq,
                  :period_calculation])
  # no validate_required
end
```

For `VXRental`, the business-logic functions `calculate_period_start_date/3`, `get_all_anniversaries_between_dates/4`, and `generate_next_period_anniversay/3` all call `Timex.format!/2` or `NaiveDateTime.new/2` on `rental.abhstartdate` without nil-guarding it. A rental persisted with a null `abhstartdate` (which the changeset permits) will crash these functions at runtime when the scheduler or a reporting endpoint iterates over rentals.

**Recommendation:** Add `validate_required/2` to both changesets for the fields that are semantically mandatory. At minimum, `VXRental` should require `:abhstartdate` and `:abhrental_freq`.

---

### A080-5 — MEDIUM: Internal Ecto changeset details disclosed in HTTP error responses

**File:** `lib/api_server_web/controllers/vx_rental_controller.ex` (lines 169, 184)

```elixir
# Line 169
send_resp(conn, :internal_server_error,
  "{\"error\": \"Unknown error creating rental\",\"reason\": \"An error occured while creating this rental\", \"changeset\": \"#{inspect changeset}\"}\" }")

# Line 184
send_resp(conn, :internal_server_error,
  "{\"error\": \"error inserting update\", \"reason\": \"#{inspect result}\" }")
```

`inspect changeset` and `inspect result` on Ecto changesets and error tuples can expose internal field names, database constraint names, validation rule details, and Elixir module paths to API callers. This is an information-disclosure finding that assists an attacker in understanding the internal schema and error structure.

**Recommendation:** Replace `inspect changeset` / `inspect result` in HTTP responses with a static error message. Log the changeset/result server-side at an appropriate log level instead.

---

### A080-6 — INFO: `generate_previous_period_anniversay` is public but should be private

**File:** `lib/api_server/vx/vx_rental.ex` (line 246)

```elixir
def generate_previous_period_anniversay(current_anniversary, rental, user_timezone) do
```

This function is a pure internal date-arithmetic helper analogous to the private `generate_next_period_anniversay/3` (line 176, `defp`). It is called from `vx_rental_controller.ex` and `vx.ex` externally, however there is no semantic reason for it to be part of the public module API. The asymmetry (next is private, previous is public) increases the module's public surface area unnecessarily and also contains commented-out code blocks (lines 274–278, 388–398) suggesting ongoing development churn.

**Recommendation:** Evaluate whether callers can be moved into the module or whether the function should remain public for legitimate cross-module use. Clean up commented-out code.

---

## Summary Table

| ID | Severity | File(s) | Title |
|----|----------|---------|-------|
| A080-1 | CRITICAL | vx_rental.ex / vx_rental_controller.ex | Tenant escape via attacker-controlled `customer` in rental write endpoints |
| A080-2 | HIGH | vx_restriction.ex / vx.ex | VXRestriction scaffold CRUD helpers operate without tenant prefix |
| A080-3 | MEDIUM | vx_rental.ex | Unhandled exception on malformed date input (`Date.from_iso8601!`) |
| A080-4 | LOW | vx_rayven_stream_status.ex, vx_rental.ex | Changesets have no `validate_required` constraints |
| A080-5 | MEDIUM | vx_rental_controller.ex | Internal Ecto changeset details disclosed in HTTP error responses |
| A080-6 | INFO | vx_rental.ex | `generate_previous_period_anniversay` is unnecessarily public; stale commented-out code |
