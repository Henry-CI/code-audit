# Security Audit Report — A128
**Agent:** A128
**Repo:** api_server
**Stack:** Elixir/Phoenix
**Branch:** master
**Run:** 2026-02-27-01

---

## Assigned Files

1. `lib/api_server_web/views/geofence_view.ex`
2. `lib/api_server_web/views/layout_view.ex`
3. `lib/api_server_web/views/page_view.ex`

---

## Reading Evidence

### File 1: `lib/api_server_web/views/geofence_view.ex`

**Module name:** `ApiServerWeb.GeofenceView`

**Public functions (def):**

| Name | Arity | Line |
|------|-------|------|
| `render/2` ("index.json") | 2 | 9 |
| `render/2` ("geofence.json") | 2 | 13 |
| `render/2` ("geofence_events.json") | 2 | 22 |

**defstruct / defexception / schema defined:** None.

**use / import / alias at module level:**

| Directive | Value | Line |
|-----------|-------|------|
| `use` | `ApiServerWeb, :view` | 2 |
| `alias` | `ApiServerWeb.GeofenceView` | 4 |
| `alias` | `ApiServerWeb.VXThingView` | 5 |
| `alias` | `ApiServer.Vx` | 6 |
| `alias` | `ApiServer.Vx.Geofence` | 7 |

---

### File 2: `lib/api_server_web/views/layout_view.ex`

**Module name:** `ApiServerWeb.LayoutView`

**Public functions (def):** None defined explicitly (all behaviour is inherited from `ApiServerWeb, :view`).

**defstruct / defexception / schema defined:** None.

**use / import / alias at module level:**

| Directive | Value | Line |
|-----------|-------|------|
| `use` | `ApiServerWeb, :view` | 2 |

---

### File 3: `lib/api_server_web/views/page_view.ex`

**Module name:** `ApiServerWeb.PageView`

**Public functions (def):** None defined explicitly (all behaviour is inherited from `ApiServerWeb, :view`).

**defstruct / defexception / schema defined:** None.

**use / import / alias at module level:**

| Directive | Value | Line |
|-----------|-------|------|
| `use` | `ApiServerWeb, :view` | 2 |

---

## Checklist Review

### §1: Secrets and Configuration

`geofence_view.ex`, `layout_view.ex`, and `page_view.ex` contain no config references, no credentials, no API keys, no hardcoded secrets, and no environment variable reads. No module attributes embed credentials or secret values.

§1: No issues found.

---

### §2: Authentication and Authorization

The view layer itself does not make authentication or authorization decisions; those are the responsibility of the controller and plug pipeline. However, the view is the final point of data serialisation before transmission to the client, so it is relevant to cross-customer data leakage.

**`render("geofence_events.json", ...)`** at line 22–30 of `geofence_view.ex`:

```elixir
def render("geofence_events.json", %{geofence_events: geofence_events, thing: thing}) do
  Enum.map(geofence_events, fn(event) ->
    %{
      thing: render_one(thing, VXThingView, "rhm_thing.json"),
      ...
    }
  end)
end
```

Each element of the returned list re-renders the `thing` record via `VXThingView.render("rhm_thing.json", ...)`. Inspection of `VXThingView` (read as supporting context) shows `rhm_thing.json` emits:
- `hardwareid`, `customerid`, `serialno`, `address`, `make`, `model`, `hardware_type`, `hour_meters` (with all offset sub-fields), `time_to_service`, `weeks_to_service`, `usage`, `fleets`, `summary` (GPS coordinates: `abmlatitude`, `abmlongitude`), and PM notification metadata.

The concern here is that the `thing` record is embedded into **every event record** in the list. If there are N geofence events, the same full vehicle profile (including GPS, service data, driver-facing fields) is serialised N times. This is an information density issue rather than a cross-customer issue (the controller already scopes the query to the JWT customer claim), but it does produce unnecessarily verbose GPS and fleet data in the payload. This is noted below as a LOW/INFO finding.

Authorization scoping in the controller (`geofence_controller.ex`) reads the customer from `Guardian.Plug.current_claims(conn)["customer"]` and passes it through all `Vx.*` queries. This is correct.

§2: No issues found (authorization defects are not in the view layer; view does not bypass scoping).

---

### §3: Input Validation and Injection

The three view files perform no input parsing, no Ecto queries, no SQL fragments, no atom creation from external input, and no deserialization of untrusted data. They are pure serialisation modules that map Elixir structs to JSON maps.

No `String.to_atom/1`, no `:erlang.binary_to_term/1`, no `Code.eval_string/1`, no `Kernel.apply/3` with user-controlled arguments.

§3: No issues found.

---

### §4: Session and CSRF

View modules do not interact with sessions, CSRF tokens, cookies, or WebSocket connections.

§4: No issues found.

---

### §5: File and Data Handling

**GPS coordinates in `geofence_events.json` response**

`render("geofence_events.json", ...)` at line 24–29 passes the raw `event` map through to the `:geofence_event` key without any field filtering:

```elixir
Enum.map(geofence_events, fn(event) ->
  %{
    thing: render_one(thing, VXThingView, "rhm_thing.json"),
    geofence_event: event
  }
end)
```

The `geofence_event` value is the raw internal event map as constructed in `GeofenceController.make_geofence_event/6` (and equivalently in `Geofence.make_geofence_event_no_thing/5`), which contains:

```elixir
%{
  status: ...,
  geofence_name: ...,
  datetime: ...,
  engine_hours_at_event: ...,
  ignitionstatus: ...,
  eventtype: ...,
  eventcode: ...,
  latitude: ...,
  longitude: ...
}
```

This is a computed internal map, not a raw database row. The fields are bounded and GPS coordinates (`latitude`, `longitude`) are intentionally part of the geofence event response — the feature is explicitly a "where was this vehicle when it crossed a geofence boundary" query. This exposure is consistent with the product's purpose and scoped to the authenticated customer.

**`thing` re-embedded per event (information density)**

As noted in §2, the full vehicle profile including GPS summary coordinates (`abmlatitude`, `abmlongitude`) from `VXThingSummaryView.render("rhm_thing_summary.json", ...)` is serialised once per geofence event rather than once per response. This causes the same GPS fix, service records, and PM notification data to be repeated N times. While not a direct vulnerability, it increases the attack surface area of any response interception and may reveal more telemetry than the caller intends to consume.

**`layout_view.ex` and `page_view.ex`** are empty modules with no render clauses; they cannot disclose data.

**Logger calls:** None in any of the three view files.

**Error disclosure in view layer:** None. The view files do not render error templates or expose stack traces.

§5: No critical issues found. See finding A128-1 below.

---

### §6: Dependencies

The view files themselves introduce no dependencies beyond what is already pulled in via `use ApiServerWeb, :view`. No `mix.exs` or `mix.lock` entries are referenced here.

§6: No issues found (dependencies assessed at repository level by other agents).

---

### §7: Infrastructure Exposure

No hardcoded hostnames, IPs, ports, AWS resource identifiers, or inter-service URLs appear in any of the three view files. No CORS or CSP configuration is present in view modules (that belongs to the endpoint/router layer).

§7: No issues found.

---

## Findings

---

### A128-1 — INFO — Unnecessary GPS and Full Vehicle Profile Repeated Per Geofence Event

**File:** `lib/api_server_web/views/geofence_view.ex`, lines 22–30
**Severity:** INFO

**Description:**

The `render("geofence_events.json", ...)` clause embeds the complete vehicle profile (rendered via `VXThingView.render("rhm_thing.json", ...)`) inside every geofence event in the response list. The `rhm_thing.json` template includes GPS coordinates from the vehicle summary (`abmlatitude`, `abmlongitude`), hour meter offsets, PM notification metadata, service records, fleet memberships, and usage statistics.

If a vehicle has crossed N geofence boundaries in the requested period, the full vehicle profile is serialised N times in the response body. This unnecessarily multiplies the amount of sensitive fleet telemetry transmitted per API call.

**Code:**

```elixir
# geofence_view.ex lines 22-30
def render("geofence_events.json", %{geofence_events: geofence_events, thing: thing}) do
  Enum.map(geofence_events, fn(event) ->
    %{
      thing: render_one(thing, VXThingView, "rhm_thing.json"),
      geofence_event: event
    }
  end)
end
```

**Risk:**

- Each response for a day's worth of geofence crossings may contain dozens of copies of GPS coordinates, service intervals, PM notification dates, and fleet assignments.
- Larger response bodies increase the window for TLS interception, logging, and accidental exposure in proxy or CDN access logs.
- The `thing` object is identical in each list element; there is no reason to repeat it.

**Recommendation (report only — no source modification):**

The caller already has the vehicle context. The response structure should move `thing` to a top-level key outside the event list, rather than embedding it inside each event. This is an architectural improvement and does not constitute a vulnerability in the current threat model (data is already scoped to the authenticated customer), but it reduces unnecessary data exposure surface.

---

### A128-2 — LOW — `render("geofence_events.json")` Passes Raw Internal Event Map Without Explicit Field Whitelist

**File:** `lib/api_server_web/views/geofence_view.ex`, lines 24–29
**Severity:** LOW

**Description:**

The `geofence_event` field in the response is set to the raw map produced by `GeofenceController.make_geofence_event/6`. While that map is a controlled internal construct (not a direct Ecto schema struct), it is passed opaquely as `geofence_event: event` without an explicit field projection in the view. If the upstream controller or context function ever adds additional fields to the event map (for example, internal tracking IDs, raw database row data, or debugging fields), those fields will be silently included in the API response without any view-layer gatekeeping.

This pattern contrasts with the explicit field-by-field construction used in other views (e.g., `VXThingView.render("event_report.json", ...)` which individually maps each field to a named key in the output map).

**Code:**

```elixir
# geofence_view.ex lines 24-29
Enum.map(geofence_events, fn(event) ->
  %{
    thing: render_one(thing, VXThingView, "rhm_thing.json"),
    geofence_event: event     # <-- raw map passed through without field whitelist
  }
end)
```

**Risk:**

If `make_geofence_event` is ever modified to include internal fields (database IDs, raw event structs, debug metadata), they will leak into the API response with no view-layer barrier. The current map fields (`status`, `geofence_name`, `datetime`, `engine_hours_at_event`, `ignitionstatus`, `eventtype`, `eventcode`, `latitude`, `longitude`) are all reasonable to expose, but the pattern offers no protection against future additions.

**Recommendation (report only — no source modification):**

Explicitly project only the intended fields in the view layer for `geofence_event`, mirroring the pattern used in `VXThingView.render("event_report.json", ...)`.

---

*End of A128 findings. Total findings: 2 (0 CRITICAL, 0 HIGH, 0 MEDIUM, 1 LOW, 1 INFO).*
