# Audit Report A104
**Run:** 2026-02-27-01
**Agent:** A104
**Repo:** api_server
**Branch:** master
**Stack:** Elixir/Phoenix

---

## Assigned Files

1. `lib/api_server_web/controllers/vx_access_fob_controller.ex`
2. `lib/api_server_web/controllers/vx_customer_controller.ex`
3. `lib/api_server_web/controllers/vx_fleet_association_controller.ex`

---

## Reading Evidence

### File 1: `lib/api_server_web/controllers/vx_access_fob_controller.ex`

**Module name:** `ApiServerWeb.VXAccessFobController`

**Public functions (def):**

| Name    | Arity | Line |
|---------|-------|------|
| index   | 2     | 9    |
| show    | 2     | 14   |
| delete  | 2     | 19   |

**defstruct / defexception / schema defined:** None

**use / import / alias at module level:**
- `use ApiServerWeb, :controller` (line 2)
- `alias ApiServer.Vx` (line 4)
- `alias ApiServer.Vx.VXAccessFob` (line 5)
- `action_fallback ApiServerWeb.FallbackController` (line 7)

---

### File 2: `lib/api_server_web/controllers/vx_customer_controller.ex`

**Module name:** `ApiServerWeb.VXCustomerController`

**Public functions (def):**

| Name    | Arity | Line |
|---------|-------|------|
| index   | 2     | 9    |
| create  | 2     | 16   |
| show    | 2     | 32   |
| update  | 2     | 39   |
| delete  | 2     | 51   |

**defstruct / defexception / schema defined:** None

**use / import / alias at module level:**
- `use ApiServerWeb, :controller` (line 2)
- `alias ApiServer.Vx` (line 4)
- `alias ApiServer.Vx.VXCustomer` (line 5)
- `action_fallback ApiServerWeb.FallbackController` (line 7)

---

### File 3: `lib/api_server_web/controllers/vx_fleet_association_controller.ex`

**Module name:** `ApiServerWeb.VXFleetAssociationController`

**Public functions (def):**

| Name    | Arity | Line |
|---------|-------|------|
| index   | 2     | 9    |
| show    | 2     | 14   |
| delete  | 2     | 19   |

**defstruct / defexception / schema defined:** None

**use / import / alias at module level:**
- `use ApiServerWeb, :controller` (line 2)
- `alias ApiServer.Vx` (line 4)
- `alias ApiServer.Vx.VXFleetAssociation` (line 5)
- `action_fallback ApiServerWeb.FallbackController` (line 7)

---

## Supporting Context Examined

The following files were read to evaluate the assigned controllers in full context:

- `lib/api_server_web/router.ex` — full router, all pipelines and scopes
- `lib/api_server_web/auth_pipeline.ex` — Guardian plug pipeline
- `lib/api_server/guardian.ex` — Guardian callbacks
- `lib/api_server/vx/vx.ex` — context functions (relevant excerpts: lines 140–217, 420–466, 2865–2960)
- `lib/api_server/vx/vx_access_fob.ex` — VXAccessFob schema
- `lib/api_server/vx/vx_customer.ex` — VXCustomer schema and changeset
- `lib/api_server/vx/vx_fleet_association.ex` — VXFleetAssociation schema
- `lib/api_server_web/controllers/fallback_controller.ex` — FallbackController
- `lib/api_server_web/views/vx_access_fob_view.ex` — VXAccessFobView
- `lib/api_server_web/views/vx_customer_view.ex` — VXCustomerView

---

## Checklist Review

### §1: Secrets and Configuration

No hardcoded secrets, credentials, API keys, or environment variable defaults are present in any of the three assigned controller files.

§1: No issues found.

---

### §2: Authentication and Authorization

#### A104-1 — CRITICAL: `Guardian.Plug.EnsureAuthenticated` is commented out — all authenticated routes are effectively unauthenticated

File: `lib/api_server_web/auth_pipeline.ex`, line 7

```elixir
plug Guardian.Plug.VerifyHeader, realm: "Bearer"
# plug Guardian.Plug.EnsureAuthenticated   <-- DISABLED
plug Guardian.Plug.LoadResource
```

The `:authenticated` pipeline only calls `VerifyHeader` (which parses and validates the token if present, but does NOT reject requests that carry no token) and `LoadResource` (which loads the user if a token was found). `EnsureAuthenticated` — the plug that actually rejects unauthenticated connections with a 401 — is commented out.

Consequence: every route registered under `pipe_through([:api, :authenticated])` in the router, including ALL customer, fleet, thing, user, geofence, and rental management routes, accepts requests that carry no `Authorization` header at all. An anonymous caller can invoke any of those endpoints without credentials.

This directly affects all three assigned controllers:
- `[REDACTED-AWS-SMTP-PASSWORD]` — index, create, show, update, delete (lines 139–143 of router)
- `[REDACTED-AWS-SMTP-PASSWORD]` — no routes currently registered (see A104-3), but the infrastructure flaw applies to any future registration
- `[REDACTED-AWS-SMTP-PASSWORD]` — same as above

**Remediation:** Uncomment `plug Guardian.Plug.EnsureAuthenticated` in `lib/api_server_web/auth_pipeline.ex`.

---

#### A104-2 — CRITICAL: IDOR — `[REDACTED-AWS-SMTP-PASSWORD]` performs no organisation-scoped queries; `index`, `show`, and `delete` operate across all tenants

File: `lib/api_server_web/controllers/vx_access_fob_controller.ex`

```elixir
def index(conn, _params) do
  vxaccessfobs = Vx.list_vxaccessfobs()          # no customer scope
  render(conn, "index.json", vxaccessfobs: vxaccessfobs)
end

def show(conn, %{"id" => id}) do
  vx_access_fob = Vx.get_vx_access_fob!(id)      # bare Repo.get! — no customer scope
  render(conn, "show.json", vx_access_fob: vx_access_fob)
end

def delete(conn, %{"id" => id}) do
  vx_access_fob = Vx.get_vx_access_fob!(id)      # bare Repo.get! — no customer scope
  with {:ok, %VXAccessFob{}} <- Vx.delete_vx_access_fob(vx_access_fob) do
    send_resp(conn, :no_content, "")
  end
end
```

The backing context functions (vx.ex lines 145–147 and 163):

```elixir
def list_vxaccessfobs do
  Repo.all(VXAccessFob)        # returns ALL rows in the table, all organisations
end

def get_vx_access_fob!(id), do: Repo.get!(VXAccessFob, id)   # no prefix/org filter
```

Neither the controllers nor the context functions extract a `customer` claim from the JWT or apply any organisation-scoped prefix. Any authenticated user (or, due to A104-1, any anonymous caller) can list, view, and permanently delete access fobs belonging to other organisations. The VXAccessFob schema has no `prefix:` (multi-tenant schema) support applied at query time.

Compare with the correct pattern demonstrated in `[REDACTED-AWS-SMTP-PASSWORD]` and the corresponding context functions, which pass `prefix: customer` to every Repo call.

---

#### A104-3 — HIGH: `[REDACTED-AWS-SMTP-PASSWORD]` and `[REDACTED-AWS-SMTP-PASSWORD]` are not registered in the router — dead code with unresolved security debt

Neither `ApiServerWeb.VXAccessFobController` nor `ApiServerWeb.VXFleetAssociationController` appears anywhere in `lib/api_server_web/router.ex`. The controllers compile and ship with the application but are unreachable through any declared route.

This creates a security debt risk: if routes are added in future (via a resources/4 macro or explicit get/post/delete declarations) without a security review, the IDOR and missing authentication issues documented in A104-1 and A104-2 will become immediately exploitable. There is no defence-in-depth mechanism (no organisation check, no customer claim extraction) in either controller.

---

#### A104-4 — CRITICAL: IDOR — `[REDACTED-AWS-SMTP-PASSWORD]` performs no organisation-scoped queries; `index`, `show`, and `delete` operate across all tenants

File: `lib/api_server_web/controllers/vx_fleet_association_controller.ex`

```elixir
def index(conn, _params) do
  vxfleetassociations = Vx.list_vxfleetassociations()          # no customer scope
  render(conn, "index.json", vxfleetassociations: vxfleetassociations)
end

def show(conn, %{"id" => id}) do
  vx_fleet_association = Vx.get_vx_fleet_association!(id)      # bare Repo.get! — no customer scope
  render(conn, "show.json", vx_fleet_association: vx_fleet_association)
end

def delete(conn, %{"id" => id}) do
  vx_fleet_association = Vx.get_vx_fleet_association!(id)      # bare Repo.get! — no customer scope
  with {:ok, %VXFleetAssociation{}} <- Vx.delete_vx_fleet_association(vx_fleet_association) do
    send_resp(conn, :no_content, "")
  end
end
```

The backing context functions (vx.ex lines 427–466):

```elixir
def list_vxfleetassociations do
  VXFleetAssociation
    |> Ecto.Query.where([r], r.aafgroupid != ^"29")
    |> Ecto.Query.preload(:fleet)
    |> Ecto.Query.preload(:thing)
    |> Repo.all                   # no prefix: customer — returns all organisations
end

def get_vx_fleet_association!(id), do: Repo.get!(VXFleetAssociation, id)  # no org filter
```

Fleet associations (the mapping of vehicles/things to fleets) represent core fleet management data. Unrestricted listing or deletion of these records across customer boundaries is a severe confidentiality and integrity violation. This is a cross-tenant IDOR of the same character as A104-2.

---

#### A104-5 — MEDIUM: `VXCustomerController.index` returns all customers in the caller's organisation-scoped schema prefix, but the `customer` claim is sourced from the JWT without independent verification against the authenticated user's actual organisation

File: `lib/api_server_web/controllers/vx_customer_controller.ex`, line 10

```elixir
def index(conn, _params) do
  customer = ApiServer.Guardian.Plug.current_claims(conn)["customer"]
  vx_customers = Vx.list_customers(customer)
  render(conn, "index.json", vx_customers: vx_customers)
end
```

The `customer` value is used as the Postgres schema prefix for all Repo calls in this controller. It is taken directly from the JWT claims and used as a raw schema-prefix string without independent cross-checking against the user record that was loaded by `LoadResource`. If a token can be crafted or the `customer` claim can be tampered with (JWT symmetric key compromise, or algorithm confusion), an attacker can pivot to an arbitrary organisation's schema by setting `customer` to a known schema name.

This is a systemic issue across the controller and the Vx context: the customer prefix is always trusted from the token, never verified against a server-side user-organisation mapping. The impact is conditional on token forgery, hence MEDIUM.

---

### §3: Input Validation and Injection

#### A104-6 — HIGH: Raw `inspect/1` of Ecto changeset errors returned verbatim in HTTP response body

File: `lib/api_server_web/controllers/vx_customer_controller.ex`, lines 27–28

```elixir
IO.inspect error
send_resp(conn, :internal_server_error,
  "{\"error\": \"error creating customer\", \"reason\": \"#{inspect error.errors}\" }")
```

`inspect error.errors` serialises the full Ecto changeset error keyword list directly into the JSON response body. This response is returned to the caller with HTTP 500. The exposed content includes:
- Internal database column names (`:aaacustcode`, `:aaaname`, etc.) derived from the schema
- Unique constraint names (`:UQ1`) — internal database object names
- Ecto validation metadata

Additionally, `IO.inspect error` writes the full error struct to stdout/the application log, which in production will be visible in log aggregation systems.

The `IO.inspect` call is a leftover debug statement. Neither `IO.inspect` nor `inspect/1` should be used in production error handling paths.

---

#### A104-7 — MEDIUM: `VXCustomerController.create` computes `aaacustcode` from user-supplied `name` inside the schema module without input length or character validation before the string manipulation chain

File: `lib/api_server/vx/vx_customer.ex`, line 36

```elixir
|> Vx.update_key_if_value(:aaacustcode,
    String.upcase(
      String.slice(
        String.replace(
          String.reverse(customer_json["name"]), " ", ""), 0..8)))
```

`customer_json["name"]` is the raw user-supplied value from the HTTP request body, passed through `String.reverse/1`, `String.replace/3`, `String.slice/2`, and `String.upcase/1` without length-bounding or character validation before the chain executes. A name value of unusual length or encoding (e.g., very long strings, or strings with complex Unicode grapheme clusters) will flow through these operations without a guard. While this is not a direct injection issue, it bypasses the Ecto `validate_required([:aaaname])` and `unique_constraint` defined later — the `aaacustcode` derivation happens before the changeset cast, so malformed input could cause runtime errors surfaced back through the `inspect error.errors` path (compounding A104-6).

---

### §4: Session and CSRF

The assigned controllers are JSON API controllers operating under the `:api` pipeline, which does not use `protect_from_forgery`. This is appropriate for token-authenticated JSON APIs. The Guardian bearer-token model does not rely on cookies and is not subject to CSRF.

§4: No issues found in the assigned files.

---

### §5: File and Data Handling

#### A104-8 — MEDIUM: Fleet association and access fob data (vehicle assignments, fob codes) returned with no organisation boundary enforcement

As documented under A104-2 and A104-4, `list_vxfleetassociations` returns vehicle-to-fleet assignment records across all customer schemas (no `prefix:` applied), and `list_vxaccessfobs` returns all access fob records including fob codes. The `VXAccessFobView` renders `fob_code` directly:

```elixir
def render("vx_access_fob.json", %{vx_access_fob: vx_access_fob}) do
  %{id: vx_access_fob.id,
    fob_code: vx_access_fob.fob_code}
end
```

`fob_code` is a physical access credential used to control operator access to forklifts. Exposure of fob codes across customer boundaries constitutes a safety and physical-security risk beyond the data confidentiality concern. This point reinforces A104-2 with a specific safety dimension.

---

### §6: Dependencies

Dependency review (`mix.exs`, `mix.lock`) is out of scope for the assigned files in this pass. No dependency concerns are introduced by the three assigned controllers.

§6: No issues found in assigned files.

---

### §7: Infrastructure Exposure

No hardcoded hostnames, IPs, internal service URLs, CORS configuration, or TLS configuration is present in the three assigned controller files.

§7: No issues found.

---

## Findings Summary

| ID      | Severity | File(s)                                      | Description |
|---------|----------|----------------------------------------------|-------------|
| A104-1  | CRITICAL | `auth_pipeline.ex`                           | `EnsureAuthenticated` is commented out — all `:authenticated` routes accept unauthenticated requests |
| A104-2  | CRITICAL | `vx_access_fob_controller.ex`, `vx.ex`       | IDOR: `index`, `show`, `delete` have no organisation scope; all access fob records from all tenants are accessible |
| A104-3  | HIGH     | `vx_access_fob_controller.ex`, `vx_fleet_association_controller.ex`, `router.ex` | Both controllers are unregistered dead code with unresolved IDOR security debt — any future route registration exposes the flaws immediately |
| A104-4  | CRITICAL | `vx_fleet_association_controller.ex`, `vx.ex` | IDOR: `index`, `show`, `delete` have no organisation scope; all fleet-vehicle associations from all tenants are accessible |
| A104-5  | MEDIUM   | `vx_customer_controller.ex`, `guardian.ex`   | `customer` JWT claim used as raw Repo prefix without server-side organisation cross-check |
| A104-6  | HIGH     | `vx_customer_controller.ex`                  | Internal Ecto changeset errors (including schema column and constraint names) returned verbatim in HTTP 500 response body; `IO.inspect` debug call left in production code |
| A104-7  | MEDIUM   | `vx_customer.ex` (called from controller)    | User-supplied `name` string processed through multiple operations without length/character validation before changeset cast |
| A104-8  | MEDIUM   | `vx_access_fob_controller.ex`, `vx_fleet_association_controller.ex` | Physical fob codes and fleet-vehicle associations exposed with no tenant boundary — fob code exposure has physical access-control safety implications |
