# Audit Report A110 — api_server Pass 1
**Agent:** A110
**Stack:** Elixir/Phoenix
**Branch:** master
**Run:** 2026-02-27-01
**Date:** 2026-02-27

**Assigned files:**
- `lib/api_server_web/controllers/vx_thing_controller.ex`
- `lib/api_server_web/controllers/vx_thing_event_controller.ex`
- `lib/api_server_web/controllers/vx_thing_info_controller.ex`

---

## Reading Evidence

### File 1: `lib/api_server_web/controllers/vx_thing_controller.ex`

**Module name:** `ApiServerWeb.VXThingController`

**Public functions (`def`):**

| Name | Arity | Line |
|---|---|---|
| `get_checklists` | 2 | 10 |
| `get_movements` | 2 | 16 |
| `get_hardware_with_checklists` | 2 | 21 |
| `get_pm_data` | 2 | 30 |
| `get_all_pm_data` | 2 | 36 |
| `get_fleet_map` | 2 (clause 1: `fleetname`) | 44 |
| `get_fleet_map` | 2 (clause 2: `fleetid` + `customer`) | 51 |
| `get_fleet_map` | 2 (clause 3: `fleetid` only) | 56 |
| `get_fleet_map` | 2 (clause 4: wildcard) | 64 |
| `create` | 2 | 74 |
| `show` | 2 | 83 |
| `delete` | 2 | 88 |
| `rhm_get_thing` | 2 | 95 |
| `rhm_get_thing_usage` | 2 | 100 |
| `rhm_get_things_usage` | 2 | 111 |
| `rhm_get_thing_events` | 2 | 144 |
| `rhm_get_things` | 2 (clause 1: `fleet_id`) | 153 |
| `rhm_get_things` | 2 (clause 2: no fleet_id) | 161 |
| `rhm_get_things_with_usage` | 2 (clause 1: `fleet_id`) | 169 |
| `rhm_get_things_with_usage` | 2 (clause 2: wildcard) | 176 |
| `rhm_get_things_names` | 2 | 223 |
| `rhm_get_thing_records` | 2 | 231 |
| `create_thing` | 2 | 240 |
| `update_thing` | 2 | 254 |
| `monday_hour_meters` | 2 | 377 |
| `get_next_monday_between_dates` | 4 | 438 |
| `combined_engine_usage` | 2 | 453 |
| `pape_export` | 2 (clause 1: `format: "csv"`) | 603 |
| `pape_export` | 2 (clause 2: wildcard) | 617 |
| `sielift_export` | 2 (clause 1: `format: "json"`, `fleet_id`) | 724 |
| `sielift_export` | 2 (clause 2: `format: "json"`) | 735 |
| `sielift_export` | 2 (clause 3: wildcard) | 746 |
| `update_thing_cached_fields` | 2 | 850 |
| `get_timezones` | 2 | 859 |

**Private functions (`defp`):** `things_with_usage/2` (line 184), `get_data_for_pape_export/1` (line 285), `get_data_for_sielift_export/3` (line 625), `ifnilzero/1` (line 622)

**defstruct / defexception / schema:** None defined in this module.

**use / import / alias:**
- `use ApiServerWeb, :controller` (line 2)
- `use Timex` (line 3)
- `alias ApiServer.Vx` (line 5)
- `alias ApiServer.Vx.VXThing` (line 6)
- `action_fallback ApiServerWeb.FallbackController` (line 8)

---

### File 2: `lib/api_server_web/controllers/vx_thing_event_controller.ex`

**Module name:** `ApiServerWeb.VXThingEventController`

**Public functions (`def`):**

| Name | Arity | Line |
|---|---|---|
| `index` | 2 | 9 |
| `create` | 2 | 14 |
| `show` | 2 | 24 |
| `update` | 2 | 29 |
| `delete` | 2 | 38 |
| `write_partial_record` | 3 | 46 |
| `add_calculated_fields` | 2 | 74 |
| `get_current_omega_status` | 2 | 111 |

**Private functions (`defp`):** `calculated_hourmeter/2` (line 103)

**defstruct / defexception / schema:** None defined in this module.

**use / import / alias:**
- `use ApiServerWeb, :controller` (line 2)
- `alias ApiServer.Vx` (line 4)
- `alias ApiServer.Vx.VXThingEvent` (line 5)
- `action_fallback ApiServerWeb.FallbackController` (line 7)

---

### File 3: `lib/api_server_web/controllers/vx_thing_info_controller.ex`

**Module name:** `ApiServerWeb.VXThingInfoController`

**Public functions (`def`):**

| Name | Arity | Line |
|---|---|---|
| `fix_infos` | 2 | 9 |
| `get_info` | 2 | 17 |
| `do_fix_info` | 2 | 24 |

**defstruct / defexception / schema:** None defined in this module.

**use / import / alias:**
- `use ApiServerWeb, :controller` (line 2)
- `alias ApiServer.Vx` (line 4)
- `alias ApiServer.Vx.VXThingInfo` (line 5)
- `action_fallback ApiServerWeb.FallbackController` (line 7)

---

## Router Context (supporting evidence)

The router defines three scopes relevant to these controllers:

**Scope A — `/api/v1` with NO authentication pipeline (lines 28–32):**
```elixir
scope "/api/v1", ApiServerWeb do
  # Avoid authentication, locking to a specific database
  get("/rhm/engine_usage", VXThingController, :combined_engine_usage)
  get("/rhm/monday_hour_meters", VXThingController, :monday_hour_meters)

  pipe_through([:api, :authenticated])
  ...
```
The `pipe_through([:api, :authenticated])` call on line 33 only applies to routes defined **after** it within the same scope block. The two routes above it — `combined_engine_usage` and `monday_hour_meters` — are defined before `pipe_through` and thus receive **no authentication pipeline**.

**Scope B — `/api/v1` unauthenticated (lines 156–177):** Uses only `pipe_through(:api)` (no `:authenticated`). Routes under this scope that relate to our files:
- `GET /rhm/timezones` → `VXThingController.get_timezones` (line 175)
- `GET /rhm/:customer/fix_info` → `VXThingInfoController.fix_infos` (line 176)
- Several `/vx/:customer/...` routes → `VXThingController` actions (lines 169–173)

---

## Checklist Review

### §1: Secrets and Configuration
No hardcoded credentials, API keys, secret key bases, AWS endpoints, or embedded secrets found in any of the three files. All configuration access is done via Guardian JWT claims at runtime.

**§1: No issues found.**

---

### §2: Authentication and Authorization

**Finding A110-1 — CRITICAL: Two fleet data endpoints serve unauthenticated requests**

In `router.ex`, the following routes are declared **before** `pipe_through([:api, :authenticated])` in the same scope block and therefore bypass authentication entirely:

```elixir
# router.ex lines 28–32
scope "/api/v1", ApiServerWeb do
  # Avoid authentication, locking to a specific database
  get("/rhm/engine_usage", VXThingController, :combined_engine_usage)
  get("/rhm/monday_hour_meters", VXThingController, :monday_hour_meters)

  pipe_through([:api, :authenticated])
```

`combined_engine_usage/2` (line 453, `vx_thing_controller.ex`) accepts a `customers` query parameter as a comma-separated string and iterates over all of them, returning daily engine usage data for every vehicle across every named customer. `monday_hour_meters/2` (line 377) similarly accepts a `customers` string and returns per-vehicle GPS coordinates (`latitude`, `longitude`), hour meters, and last-reported timestamps for all vehicles belonging to the named customers.

Any unauthenticated caller who knows (or guesses) a customer identifier can retrieve full fleet telemetry — including GPS/location data — for that customer without presenting any credentials. The comment "Avoid authentication, locking to a specific database" suggests this was a deliberate shortcut that was never reverted.

**File:** `lib/api_server_web/controllers/vx_thing_controller.ex` lines 377–436, 453–601
**Router:** `lib/api_server_web/router.ex` lines 30–31

---

**Finding A110-2 — HIGH: `fix_infos` endpoint is unauthenticated and accepts arbitrary customer parameter**

`GET /rhm/:customer/fix_info` → `VXThingInfoController.fix_infos/2` routes through `pipe_through(:api)` only (router scope at line 156). No `:authenticated` pipeline is applied. The handler calls `Vx.list_vxthings(customer)` and then `do_fix_info/2` for every device belonging to the customer, allowing any caller to enumerate and trigger recalculation of all device info records for an arbitrary customer by supplying the customer identifier in the URL path.

**File:** `lib/api_server_web/controllers/vx_thing_info_controller.ex` lines 9–15
**Router:** `lib/api_server_web/router.ex` line 176

---

**Finding A110-3 — HIGH: Several VX endpoints (checklist, PM data, movements) are unauthenticated**

The following routes also reside in the unauthenticated scope B (`pipe_through(:api)` only, router lines 156–177):

```
GET /vx/:customer/thing/with_checklists   → VXThingController.get_hardware_with_checklists/2
GET /vx/:customer/thing/:hardwareid/checklists  → VXThingController.get_checklists/2
GET /vx/:customer/pmServicesAjax/:hardwareid    → VXThingController.get_pm_data/2
GET /vx/:customer/pmServicesAjax               → VXThingController.get_all_pm_data/2
GET /vx/:customer/thing/:hardwareid/movements/:day  → VXThingController.get_movements/2
```

These handlers accept `customer` and `hardwareid` directly from the URL path with no authentication check. Fleet checklist records, PM service data, and GPS movement tracks can be retrieved by any caller who knows (or guesses) a customer identifier and hardware ID.

`get_checklists/2` (line 10) notably receives `customer` in the pattern match but passes only `hardwareid` to `Vx.get_checklists/1`, meaning the customer parameter provides no access control — it is present in the signature but unused as a scope guard.

**File:** `lib/api_server_web/controllers/vx_thing_controller.ex` lines 10–27, 16–18
**Router:** `lib/api_server_web/router.ex` lines 169–172, 57

---

**Finding A110-4 — HIGH: IDOR in `VXThingController.show/2` and `VXThingController.delete/2` — no customer scoping**

`show/2` (line 83) fetches a device by hardware ID without any customer context:
```elixir
def show(conn, %{"id" => hardwareid}) do
  vx_thing = Vx.get_vx_thing_with_hardware_id!(hardwareid)
  render(conn, "show.json", vx_thing: vx_thing)
end
```

`delete/2` (line 88) fetches a device by internal database ID without any customer context:
```elixir
def delete(conn, %{"id" => id}) do
  vx_thing = Vx.get_vx_thing!(id)
  with {:ok, %VXThing{}} <- Vx.delete_vx_thing(vx_thing) do
    send_resp(conn, :no_content, "")
  end
end
```

Neither function verifies that the retrieved record belongs to the authenticated user's customer. An authenticated user from customer A can fetch or delete device records belonging to customer B by supplying a known or guessed hardware/database ID.

`VXThingController.create/2` (line 74) similarly calls `Vx.create_vx_thing(vx_thing_params)` without injecting or validating the authenticated customer, meaning a device can potentially be created under a customer that differs from the caller's identity.

**File:** `lib/api_server_web/controllers/vx_thing_controller.ex` lines 74–93

---

**Finding A110-5 — HIGH: IDOR in `[REDACTED-AWS-SMTP-PASSWORD]` — index/show/update/delete have no customer or org scoping**

`index/2` (line 9) calls `Vx.list_vxthingevents()` with no customer filter, returning all thing events across all customers.

`show/2` (line 24) fetches a single event record by raw numeric ID with no customer check:
```elixir
def show(conn, %{"id" => id}) do
  vx_thing_event = Vx.get_vx_thing_event!(id)
  render(conn, "show.json", vx_thing_event: vx_thing_event)
end
```

`update/2` (line 29) and `delete/2` (line 38) follow the same pattern — fetching by bare `id` with no ownership verification. An authenticated user can read, update, or delete event records (which contain GPS coordinates, ignition status, engine seconds, and timestamp data) belonging to other customers by enumerating IDs.

**File:** `lib/api_server_web/controllers/vx_thing_event_controller.ex` lines 9–44

---

**Finding A110-6 — MEDIUM: `rhm_get_thing/2` accepts `customer` from the URL path rather than the JWT claim**

```elixir
def rhm_get_thing(conn, %{"customer" => customer, "hardwareid" => hardwareid}) do
  {vx_thing, usage_data} = Vx.get_augmented_thing_with_hardware_id!(hardwareid, customer)
  render(conn, "rhm_thing.json", vx_thing: {vx_thing, usage_data})
end
```

The `customer` value comes from the URL path parameter (`/rhm/:customer/thing/:hardwareid`), not from `Guardian.Plug.current_claims(conn)["customer"]`. An authenticated user whose JWT claims customer="A" can supply customer="B" in the URL and retrieve device data for customer B. Several other pattern-match clauses in this controller correctly overwrite the URL-supplied `customer` with the JWT claim (e.g., `rhm_get_things/2` line 154, `rhm_get_things_names/2` line 224), but `rhm_get_thing/2` and the first clause of `rhm_get_things/2` (line 153) do not.

Also affects: `rhm_get_things/2` clause 1 (line 153) — `customer` from the URL path is shadow-replaced by the JWT claim on line 154, so the actual query is correctly scoped; however the function signature silently discards the URL parameter, which is confusing and inconsistent. The same inconsistency exists in `rhm_get_things_names/2` (line 223–224).

**File:** `lib/api_server_web/controllers/vx_thing_controller.ex` lines 95–98

---

### §3: Input Validation and Injection

**Finding A110-7 — HIGH: Changeset error detail exposed in HTTP response body**

`create_thing/2` (line 240) and `update_thing/2` (line 254) return the raw `inspect changeset` in the HTTP response body on error:

```elixir
# create_thing/2 line 250:
send_resp(conn, :internal_server_error, "{\"error\": \"error inserting update\", \"reason\": \"#{inspect changeset}\" }")

# update_thing/2 line 278:
send_resp(conn, :internal_server_error, "{\"error\": \"error inserting update\", \"reason\": \"#{inspect result}\" }")
```

`inspect/1` on an Ecto changeset emits the full Elixir struct representation including all field names, attempted values, constraint names, and internal state. This discloses database schema structure (table column names, constraints) and may include customer-supplied data reflected back in a machine-readable internal format. This is information disclosure to the client.

**File:** `lib/api_server_web/controllers/vx_thing_controller.ex` lines 250, 278

---

**Finding A110-8 — MEDIUM: `customers` parameter in `combined_engine_usage` and `monday_hour_meters` is user-controlled and iterated without bound**

Both `combined_engine_usage/2` (line 453) and `monday_hour_meters/2` (line 377) split a user-supplied `customers` string on commas and iterate over every resulting element, performing N database queries (device listing + per-device queries) per customer:

```elixir
customers_list = customers |> String.split(",")
all_customers_combined = Enum.flat_map(customers_list, fn customer ->
  things = Vx.list_vxthings_full(customer)
  ...
end)
```

There is no limit on the length of the `customers` string or on the number of customers that can be requested. A caller (or an unauthenticated caller — see A110-1) can trigger unbounded database load by supplying a large number of customer identifiers. This is a denial-of-service amplification vector.

**File:** `lib/api_server_web/controllers/vx_thing_controller.ex` lines 377–436, 453–601

---

**Finding A110-9 — MEDIUM: `add_calculated_fields/2` in `[REDACTED-AWS-SMTP-PASSWORD]` is public and accepts arbitrary map input**

`add_calculated_fields/2` (line 74) is declared `def` (public) and operates on a raw map, calling `Vx.get_vx_thing_with_hardware_id!/2` using `record_to_add.hardwareid` directly from the input map without validation. While it is currently called only internally from `write_partial_record/3`, its public visibility means it can be called from other controllers or from test/external code without the caller having validated the hardwareid field. The function should be `defp`.

**File:** `lib/api_server_web/controllers/vx_thing_event_controller.ex` lines 74–101

---

**Finding A110-10 — LOW: `IO.puts` with device hardware ID in `add_calculated_fields/2`**

```elixir
IO.puts(
  "totalengineseconds is nil for #{record_to_add.hardwareid} but aadhourmeter is set to #{vx_thing.aadhourmeter}, setting totalengineseconds to 0 value"
)
```

This logs the hardware ID and hour meter value of a vehicle to standard output (which in production typically goes to application logs). Hardware IDs are device identifiers for fleet assets. Depending on log aggregation and access controls this may expose fleet asset identifiers in application logs.

**File:** `lib/api_server_web/controllers/vx_thing_event_controller.ex` lines 78–81

---

### §4: Session and CSRF

The three controllers operate as JSON API controllers; CSRF is handled at the pipeline level (the `:browser` pipeline applies `protect_from_forgery`, the `:api` pipeline does not, consistent with token-authenticated JSON APIs). No per-controller session manipulation is present.

**§4: No issues found in these files specifically.** (See A110-1/A110-2/A110-3 regarding missing authentication pipeline on some routes, which is a §2 concern.)

---

### §5: File and Data Handling

**Finding A110-11 — HIGH: GPS coordinates returned in `monday_hour_meters` response for unauthenticated callers**

`monday_hour_meters/2` (line 377–436) constructs a response map that explicitly includes `latitude` and `longitude` fields from device event records:

```elixir
%{
  vehicle_name: thing.aaddesc,
  hour_meter: last_event.calcengineseconds,
  latitude: last_event.latitude,
  longitude: last_event.longitude,
  last_reported: last_event.gmtdatetime,
  monday_date: date
}
```

This endpoint is unauthenticated (see A110-1). GPS coordinates for every vehicle across all named customer organisations are returned in plain JSON to any caller with no credentials. This is a direct data exposure of precise vehicle location data across customer boundaries with no access control.

**File:** `lib/api_server_web/controllers/vx_thing_controller.ex` lines 405–424
**Router:** `lib/api_server_web/router.ex` line 31

---

**Finding A110-12 — MEDIUM: Customer data boundary is not enforced for `get_movements/2`**

`get_movements/2` (line 16) accepts both `customer` and `hardwareid` from the URL path and passes them to `Vx.get_movements/5`. Movement data includes GPS tracks. While this endpoint is in the unauthenticated scope (A110-3), even in an authenticated context there is no verification that the authenticated user belongs to the named customer. The `customer` path parameter is trusted directly.

**File:** `lib/api_server_web/controllers/vx_thing_controller.ex` lines 16–18
**Router:** `lib/api_server_web/router.ex` line 57

---

**Finding A110-13 — MEDIUM: Customer identifier included in CSV export responses and JSON bodies, enabling cross-customer data confirmation**

`combined_engine_usage/2` (line 453) explicitly embeds the `customer` string into each row of the output JSON:

```elixir
%{
  hardwareid: hardwareid,
  customer: customer,
  ...
}
```

For an unauthenticated caller (A110-1), this provides confirmation of which customer owns which hardware ID, enabling enumeration and cross-referencing of customer-to-asset mappings.

**File:** `lib/api_server_web/controllers/vx_thing_controller.ex` lines 508–513

---

**Finding A110-14 — LOW: Dead commented-out code contains a hardcoded list of production customer identifiers**

Lines 303–373 contain a large block of commented-out code that includes a hardcoded list of 47 production customer identifiers:

```elixir
# customers =  ["vx_aforklifts","vx_altertrading","vx_arctech","vx_atlanticforklifts", ...]
```

These strings enumerate the full customer namespace in the repository's version history and in the current working tree. While not a runtime risk, they disclose production customer organisation identifiers to anyone with read access to the repository (including CI systems, contributors, and any future repository exposure).

**File:** `lib/api_server_web/controllers/vx_thing_controller.ex` line 303

---

**Finding A110-15 — INFO: `IO.puts "Inserted"` and `IO.inspect changeset` in `write_partial_record/3`**

```elixir
{:ok, te} ->
  IO.puts("Inserted")

{:error, changeset} ->
  case changeset.errors do
    _ ->
      IO.inspect(changeset)
  end
```

`IO.inspect(changeset)` on error will print the full changeset struct to standard output/logs, which may include field values from the device event record (hardware IDs, GPS data, engine data). In a production environment with log aggregation, this represents unnecessary logging of fleet telemetry detail. The `IO.puts("Inserted")` is debug noise. Neither line has a severity path to customer data exposure on its own, but they indicate absent structured logging hygiene.

**File:** `lib/api_server_web/controllers/vx_thing_event_controller.ex` lines 62–68

---

### §6: Dependencies
Not assessed in this pass (assigned files are controller modules only; `mix.exs` and `mix.lock` are outside this file assignment).

**§6: Not applicable to assigned files.**

---

### §7: Infrastructure Exposure

**Finding A110-16 — INFO: Hardcoded customer-identifier prefix pattern `vx_` is visible**

The naming convention for customer database namespaces (`vx_<name>`) is visible throughout the code and in the hardcoded customer list (A110-14). This is low-severity but confirms naming conventions to anyone reading the source.

**§7: No additional infrastructure exposure issues (no hardcoded IPs, hostnames, TLS config, or CORS configuration) found in these three files.**

---

## Summary of Findings

| ID | Severity | File | Description |
|---|---|---|---|
| A110-1 | CRITICAL | `vx_thing_controller.ex` + `router.ex` | `combined_engine_usage` and `monday_hour_meters` are unauthenticated — full fleet telemetry data accessible without credentials |
| A110-2 | HIGH | `vx_thing_info_controller.ex` + `router.ex` | `fix_infos` endpoint unauthenticated — arbitrary customer device info can be enumerated and recalculated |
| A110-3 | HIGH | `vx_thing_controller.ex` + `router.ex` | Multiple VX endpoints (checklists, PM data, GPS movements) unauthenticated — fleet data exposed without credentials |
| A110-4 | HIGH | `vx_thing_controller.ex` | IDOR in `show/2`, `delete/2`, `create/2` — no customer scoping; device records accessible/deletable across org boundaries |
| A110-5 | HIGH | `vx_thing_event_controller.ex` | IDOR in `index/2`, `show/2`, `update/2`, `delete/2` — event records (GPS, ignition, engine data) accessible across org boundaries by ID |
| A110-6 | MEDIUM | `vx_thing_controller.ex` | `rhm_get_thing/2` uses URL-path `customer` instead of JWT claim — authenticated user can read another org's device data |
| A110-7 | HIGH | `vx_thing_controller.ex` | `inspect changeset` returned in HTTP 500 body — database schema and field values disclosed to client |
| A110-8 | MEDIUM | `vx_thing_controller.ex` | Unbounded `customers` comma-list in `combined_engine_usage` and `monday_hour_meters` — DoS amplification |
| A110-9 | MEDIUM | `vx_thing_event_controller.ex` | `add_calculated_fields/2` is public (`def`) but should be private (`defp`) |
| A110-10 | LOW | `vx_thing_event_controller.ex` | `IO.puts` logs hardware ID and hour meter value to stdout/logs |
| A110-11 | HIGH | `vx_thing_controller.ex` | GPS latitude/longitude for all fleet vehicles returned by unauthenticated `monday_hour_meters` endpoint |
| A110-12 | MEDIUM | `vx_thing_controller.ex` | `get_movements/2` trusts `customer` from URL path — GPS movement tracks accessible without ownership check |
| A110-13 | MEDIUM | `vx_thing_controller.ex` | Customer identifier embedded in `combined_engine_usage` JSON output — enables enumeration of customer-to-asset mappings |
| A110-14 | LOW | `vx_thing_controller.ex` | Hardcoded list of 47 production customer identifiers in commented-out dead code |
| A110-15 | INFO | `vx_thing_event_controller.ex` | `IO.inspect(changeset)` and `IO.puts` debug output in production path — unstructured logging of device event data |
| A110-16 | INFO | `vx_thing_controller.ex` | Customer namespace prefix convention (`vx_`) disclosed in source |
