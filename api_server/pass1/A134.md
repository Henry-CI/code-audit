# Audit Report A134
**Agent:** A134
**Run:** 2026-02-27-01
**Stack:** Elixir/Phoenix — api_server
**Branch:** master
**Date:** 2026-02-27

---

## Assigned Files

1. `lib/api_server_web/views/vx_fleet_association_view.ex`
2. `lib/api_server_web/views/vx_fleet_view.ex`
3. `lib/api_server_web/views/vx_rental_view.ex`

---

## Reading Evidence

### File 1: `lib/api_server_web/views/vx_fleet_association_view.ex`

**Module name:** `ApiServerWeb.VXFleetAssociationView`

**Public functions (def):**

| Name | Arity | Line |
|------|-------|------|
| `render` | 2 ("index.json", %{vxfleetassociationss: ...}) | 5 |
| `render` | 2 ("show.json", %{vx_fleet_association: ...}) | 9 |
| `render` | 2 ("vx_fleet_association.json", %{vx_fleet_association: ...}) | 13 |

**defstruct / defexception / schema:** None defined in this file.

**use / import / alias at module level:**
- `use ApiServerWeb, :view` (line 2)
- `alias ApiServerWeb.VXFleetAssociationView` (line 3)

---

### File 2: `lib/api_server_web/views/vx_fleet_view.ex`

**Module name:** `ApiServerWeb.VXFleetView`

**Public functions (def):**

| Name | Arity | Line |
|------|-------|------|
| `render` | 2 ("index.json", %{vxfleets: ...}) | 5 |
| `render` | 2 ("show.json", %{vx_fleet: ...}) | 9 |
| `render` | 2 ("vx_fleet.json", %{vx_fleet: ...}) | 13 |
| `render` | 2 ("rhm_fleets.json", %{vx_fleets: ...}) | 22 |
| `render` | 2 ("rhm_fleet.json", %{vx_fleet: ...}) | 25 |
| `render` | 2 ("rhm_fleets_with_equip.json", %{vx_fleets: ...}) | 34 |
| `render` | 2 ("rhm_fleet_with_equip.json", %{vx_fleet: ...}) | 37 |
| `render` | 2 ("rhm_fleet_equipment.json", %{results: ...}) | 47 |
| `render` | 2 ("assoc.json", %{vx_fleet: {fleet_id, equipment_id, equipment_name}}) | 51 |

**defstruct / defexception / schema:** None defined in this file.

**use / import / alias at module level:**
- `use ApiServerWeb, :view` (line 2)
- `alias ApiServerWeb.VXFleetView` (line 3)

---

### File 3: `lib/api_server_web/views/vx_rental_view.ex`

**Module name:** `ApiServerWeb.VXRentalView`

**Public functions (def):**

| Name | Arity | Line |
|------|-------|------|
| `render` | 2 ("rhm_rentals.json", %{vx_rentals: ..., customer: ...}) | 8 |
| `render` | 2 ("rhm_rental.json", %{vx_rental: ..., customer: ...}) | 13 |
| `render` | 2 ("midpac_report.json", %{data: ...}) | 64 |
| `render` | 2 ("rental_anniversaries.json", %{all_anniversary_data: ...}) | 68 |
| `convert_json_to_changeset` | 1 | 73 |

**defstruct / defexception / schema:** None defined in this file.

**use / import / alias at module level:**
- `use ApiServerWeb, :view` (line 2)
- `alias ApiServer.Vx` (line 3)
- `alias ApiServerWeb.VXRentalView` (line 4)
- `alias ApiServerWeb.VXThingView` (line 5)
- `alias ApiServerWeb.VXCustomerView` (line 6)

---

## Schema Field Coverage Analysis

Supporting schemas were read to assess whether views over-expose sensitive fields.

### `ApiServer.Vx.VXFleetAssociation` schema (`aaf_groups_things`)

Fields: `aafid` (PK), `aafcustcode`, `aafgroupid` (FK to fleet), `aafthingid` (FK to thing).

`VXFleetAssociationView.render("vx_fleet_association.json")` renders: `id` (aafid), `aafcustcode`.
The FK fields `aafgroupid` and `aafthingid` are not rendered. No sensitive fields omitted beyond the FKs — the customer code is an internal identifier but is surfaced (see findings).

### `ApiServer.Vx.VXFleet` schema (`aae_group`)

Fields: `aaeid` (PK), `aaecustcode`, `aaedesc`, `aaecolour`, `aaetype`, `aaeshowfilter`.

`VXFleetView.render("vx_fleet.json")` renders: `id`, `aaetype`, `aaeshowfilter`, `aaecolour`. Omits `aaecustcode`, `aaedesc`.
`VXFleetView.render("rhm_fleet.json")` renders: `id` (aaeid), `name` (aaedesc), `type` (aaetype), `show_in_filters` (aaeshowfilter), `color` (aaecolour). Omits `aaecustcode`.
`VXFleetView.render("rhm_fleet_with_equip.json")` renders: `id` (aaeid), `name` (aaedesc), `type` (aaetype), `show_in_filters` (aaeshowfilter), `equipment`. Omits `aaecustcode`, `aaecolour`. Note `equipment` is passed as a raw pre-built list from the controller — see findings.

### `ApiServer.Vx.VXRental` schema (`abh_rentals`)

Fields: `abhid` (PK), `abhcustcode`, `abhclient`, `abhstartdate`, `abhenddate`, `abhtransdate`, `abhnotes`, `abhrental_freq`, `abhallowed_hours`, `abhreport_freq`, `abhcustomerid`, `period_calculation`, plus associations `customer` and `thing`.

`VXRentalView.render("rhm_rental.json")` renders: `id`, `cust_code` (abhcustcode), `customer_id` (abhcustomerid), `thing_id` (abhthingid), `start_date`, `end_date`, `created_date` (abhtransdate), `notes`, `period` (abhrental_freq), `allowed_hours`, `reporting_period`, `period_calculation`, plus nested `thing` and `customer` renders and `usage` block.

The field `abhclient` is not rendered. All other schema fields are rendered. The `abhthingid` is rendered as `thing_id` even though a full nested `thing` object is also rendered. See findings below.

---

## Checklist Review

### §1: Secrets and Configuration

These are view modules only. No config files, credentials, API keys, module attributes with secrets, or hardcoded connection strings are present.

§1: No issues found.

---

### §2: Authentication and Authorization

#### VXFleetAssociationView / VXFleetAssociationController

The `[REDACTED-AWS-SMTP-PASSWORD]` defines three actions (`index`, `show`, `delete`). The controller **is not registered in the router** — no routes point to it. However, the `index` and `show`/`delete` actions contain a critical authorization defect that is relevant to the view's design:

- `Vx.list_vxfleetassociations()` (called by `index`) issues a global `Repo.all` with no `prefix:` (tenant/customer) scope. This would expose all fleet-to-thing association records across all customers.
- `Vx.get_vx_fleet_association!(id)` (called by `show` and `delete`) issues a `Repo.get!` with no tenant scope. Any authenticated user who can reach this endpoint could retrieve or delete any association record by ID.

Because the controller is not routed, the immediate exploitability is low, but the view and controller pair are ready-to-expose once a route is added. This pattern is flagged as a design defect.

#### VXFleetController

The `create` action (line 9–16) uses the scaffold-generated `show.json` template which calls `render("vx_fleet.json", ...)`. The `create` action uses no customer scoping from the JWT claim — it passes raw params from `vx_fleet_params` directly to `Vx.create_vx_fleet/1`. This is a controller-level concern but the view exposure is linked.

The `delete_fleet`, `update_fleet`, `get_equipment_in_fleet`, and `manage_fleet` actions all accept `customer` from the URL path parameter (`%{"customer" => customer}`), not from the JWT claim. See finding A134-3.

#### VXRentalController

`create_rental` and `update_rental` accept `customer` from the URL path (`%{"customer" => customer, ...}`), not from the JWT claim. An authenticated user from one tenant could pass a different customer code in the URL and create or modify rentals in another tenant's database prefix. See finding A134-3.

`delete_rental` similarly accepts `customer` from the path.

#### VXRentalView — `convert_json_to_changeset/1` in a View Module

See finding A134-4.

§2: Issues found — see A134-1, A134-2, A134-3.

---

### §3: Input Validation and Injection

No raw SQL fragments, `String.to_atom/1`, `Code.eval_string`, `:erlang.binary_to_term`, or `Kernel.apply` are present in any of the three view files.

`VXRentalView.convert_json_to_changeset/1` (lines 73–89) processes user-supplied JSON fields (string map keys) and maps them to internal atom-keyed map entries using `Vx.update_key_if_value/3`. The function uses bracket string-key access (`rental_json["period"]`, etc.) — no atom creation from user input. The `"28 Day Period"` match is a static literal comparison, not dynamic atom creation.

§3: No issues found.

---

### §4: Session and CSRF

View files only. No session, cookie, or CSRF configuration is present here.

§4: No issues found.

---

### §5: File and Data Handling

#### Pass-through renders (data leakage risk)

**`VXRentalView.render("midpac_report.json", %{data: data})`** (line 64–66):

```elixir
def render("midpac_report.json", %{data: data}) do
  data
end
```

This render function returns the `data` value **verbatim**, with zero transformation or field filtering. The `data` value is a list of maps constructed in the controller (`VXRentalController.get_midpac_style_rental_report/2`). While the controller constructs a selective map (vehicle_name, make, serial_number, at_customer, rental_start, rental_frequency, allowed_hours, operating hours, meter reading, usage, overtime, hours_since_last_service, hours_to_service, anniversary_date), the view provides no enforcement layer. If the controller is ever modified to pass richer structs, the view will blindly serialise all fields including any sensitive ones. The pattern also defeats the purpose of the view layer as a serialisation boundary.

**`VXRentalView.render("rental_anniversaries.json", %{all_anniversary_data: data})`** (line 68–70):

```elixir
def render("rental_anniversaries.json", %{all_anniversary_data: data}) do
  data
end
```

Identical pass-through pattern. The controller constructs the map selectively, but the view provides no guard.

See finding A134-5.

#### `VXRentalView.render("rhm_rental.json")` — Live database queries inside a view

Lines 15–26 call `Vx.fetch_actual_usage/5`, `Vx.get_usage_since_service/2`, and `Vx.get_avg_weekly_hours/2` directly from the view function. This places business logic and database I/O inside the view layer, which means errors from these calls (database errors, nil-pointer crashes) will surface as render errors, making stack traces potentially reachable through error responses. This is a structural concern but has a data-handling dimension.

See finding A134-6.

#### `VXFleetView.render("rhm_fleet_with_equip.json")` — Raw equipment map

Line 37–44 passes `vx_fleet.equipment` directly into the response:

```elixir
def render("rhm_fleet_with_equip.json", %{vx_fleet: vx_fleet}) do
  %{id: vx_fleet.aaeid,
    name: vx_fleet.aaedesc,
    ...
    equipment: vx_fleet.equipment
  }
end
```

The `equipment` field is a pre-built list from the controller (containing only `%{name: ..., hardwareid: ...}` entries), but the view applies no filtering. If the upstream data source changes (e.g., to include association or customer records), this will pass through silently.

See finding A134-7.

#### PII / GPS in Logger calls

No `Logger` calls are present in the three view files.

§5: Issues found — see A134-5, A134-6, A134-7.

---

### §6: Dependencies

View files only. No dependency declarations.

§6: No issues found.

---

### §7: Infrastructure Exposure

No hostnames, IPs, port numbers, CORS configuration, or inter-service call configuration is present in the view files.

§7: No issues found.

---

## Findings

---

### A134-1 — CRITICAL: VXFleetAssociationController index/show/delete have no tenant scoping

**Severity:** CRITICAL
**File:** `lib/api_server_web/controllers/vx_fleet_association_controller.ex` (context for the view's data source)
**Related view:** `lib/api_server_web/views/vx_fleet_association_view.ex`

`VXFleetAssociationController.index/2` calls `Vx.list_vxfleetassociations()` which executes:

```elixir
def list_vxfleetassociations do
  VXFleetAssociation
      |> Ecto.Query.where([r], r.aafgroupid != ^"29")
      |> Ecto.Query.preload(:fleet)
      |> Ecto.Query.preload(:thing)
      |> Repo.all      # no prefix: — hits the default/global schema
end
```

There is no `prefix:` option (no tenant isolation), no customer claim from the JWT, and no authorisation check that the requesting user belongs to the same tenant as the records returned. `Vx.get_vx_fleet_association!(id)` used in `show` and `delete` similarly calls `Repo.get!` without any tenant prefix.

The controller is not currently routed (no entry in `router.ex`). However, the scaffolded code exists on the master branch, is fully functional, and would immediately expose cross-tenant fleet-association data if a route were added. The view (`vx_fleet_association.json`) renders `aafcustcode` directly — confirming that customer-code data from other tenants would be returned to any authenticated caller.

**Recommendation:** Do not route this controller until tenant scoping is implemented. All three actions must pass the JWT claim's `customer` value to the data layer as a `prefix:` argument, and `show`/`delete` must verify the association's `aafcustcode` matches the requesting user's tenant before returning or acting on the record.

---

### A134-2 — HIGH: VXFleetAssociationView renders internal customer code (`aafcustcode`) in API responses

**Severity:** HIGH
**File:** `lib/api_server_web/views/vx_fleet_association_view.ex`, lines 13–16

```elixir
def render("vx_fleet_association.json", %{vx_fleet_association: vx_fleet_association}) do
  %{id: vx_fleet_association.id,
    aafcustcode: vx_fleet_association.aafcustcode}
end
```

The internal customer code (`aafcustcode`) is an internal tenant discriminator. Exposing it in API responses allows clients to enumerate tenant identifiers. In a multi-tenant fleet management system, internal customer codes should not be surfaced to end clients unless there is a documented requirement. The raw database column name is also leaked as the JSON key, which reveals schema internals.

**Recommendation:** Remove `aafcustcode` from the response, or if the client requires a tenant identifier, use a stable external ID that does not double as an internal discriminator.

---

### A134-3 — HIGH: Customer parameter accepted from URL path instead of JWT claim in rental and fleet mutation endpoints

**Severity:** HIGH
**File:** `lib/api_server_web/controllers/vx_rental_controller.ex` (lines 158, 174, 191); `lib/api_server_web/controllers/vx_fleet_controller.ex` (lines 68, 91, 105, 110, 119)

Multiple mutation endpoints accept the `customer` tenant identifier from the URL path parameter rather than from the authenticated JWT claim:

```elixir
# vx_rental_controller.ex
def create_rental(conn, %{"customer" => customer, "rental" => rental_params}) do
def update_rental(conn, %{"customer" => customer, "rental" => rental_params}) do
def delete_rental(conn, %{"customer" => customer, "id" => id}) do

# vx_fleet_controller.ex
def create_fleet(conn, %{"customer" => cust, "fleet" => fleet_params}) do
def delete_fleet(conn, %{"customer" => customer, "id" => id}) do
def get_equipment_in_fleet(conn, %{"customer" => customer, "id" => fleet_id}) do
def manage_fleet(conn, %{"customer" => customer, "id" => fleet_id, ...}) do
def update_fleet(conn, %{"customer" => customer, "fleet" => fleet_params}) do
```

An authenticated user from tenant A can supply `customer=tenant_B` in the URL to create, update, or delete records in tenant B's database prefix. This is a cross-tenant IDOR/privilege escalation vulnerability. The views (`rhm_rental.json`, `rhm_fleet.json`) will then render the resulting records from the attacker-specified tenant.

Read-path endpoints (`get_rentals`, `get_fleets`, `get_fleets_with_equipment`) correctly extract customer from the JWT claim (`ApiServer.Guardian.Plug.current_claims(conn)["customer"]`), making the inconsistency more pronounced.

**Recommendation:** Extract the `customer` value exclusively from the JWT claim (`ApiServer.Guardian.Plug.current_claims(conn)["customer"]`) in all mutation actions. Discard any client-supplied customer value.

---

### A134-4 — MEDIUM: `convert_json_to_changeset/1` is a public function defined in a View module

**Severity:** MEDIUM
**File:** `lib/api_server_web/views/vx_rental_view.ex`, lines 73–89

```elixir
def convert_json_to_changeset(rental_json) do
  rental_period = case rental_json["period"] do
    "28 Day Period" -> "28DAY"
    _ -> rental_json["period"]
  end
  changeset = %{}
    |> Vx.update_key_if_value(:abhthingid, rental_json["thing_id"])
    |> Vx.update_key_if_value(:abhstartdate, rental_json["start_date"])
    ...
end
```

This function is business logic (transforming user input into a changeset) placed inside a view module. View modules in Phoenix are intended solely for serialising data to a response format. Having public business-logic functions in a view module:

1. Blurs the boundary between input processing and output rendering, making it harder to identify the attack surface during code review.
2. Makes the function accessible from any module that aliases the view, potentially bypassing controller-level guards.
3. The function is called directly from two controller actions (`create_rental`, `update_rental`), coupling the controller to the view in an unusual direction.

The function also performs no validation — it only maps values if present (`update_key_if_value`). There are no type checks, length limits, or allow-list checks on any of the string fields (`abhthingid`, `abhstartdate`, `abhenddate`, `abhcustomerid`, `abhnotes`, `abhrental_freq`, `abhallowed_hours`, `abhreport_freq`). The resulting map is passed directly to `Vx.create_rental/2` or `Vx.update_rental/3`.

**Recommendation:** Move `convert_json_to_changeset/1` into `ApiServer.Vx.VXRental` or a dedicated input-parsing module. Add input validation (type coercion and boundary checks) before constructing the changeset map. The controller should call the schema module, not the view.

---

### A134-5 — MEDIUM: Pass-through render functions provide no serialisation boundary

**Severity:** MEDIUM
**File:** `lib/api_server_web/views/vx_rental_view.ex`, lines 64–70

```elixir
def render("midpac_report.json", %{data: data}) do
  data
end

def render("rental_anniversaries.json", %{all_anniversary_data: data}) do
  data
end
```

Both render functions return their input argument verbatim. The view layer provides no field filtering, type normalisation, or serialisation control. Any change to the upstream controller that includes additional fields (e.g., passing full Ecto structs, adding internal IDs, including PII) will be immediately reflected in the API response without any view-layer guard.

In the case of `midpac_report.json`, the controller builds the map manually and is reasonably selective. However, `rental_anniversaries.json` also passes the pre-built `anniversary_data` list, which includes `with_customer` (customer name), `serial_number`, `vehicle_name`, and `make` fields about fleet assets. If the controller logic expands, sensitive fields could leak silently.

**Recommendation:** Replace pass-through renders with explicit field maps. Define the exact keys and values the API contract requires, mirroring the pattern used in `rhm_rental.json`.

---

### A134-6 — MEDIUM: Database queries executed inside view render function

**Severity:** MEDIUM
**File:** `lib/api_server_web/views/vx_rental_view.ex`, lines 15–26

```elixir
def render("rhm_rental.json", %{vx_rental: vx_rental, customer: customer}) do
  {last_week, for_month, since_service, hours_to_service, average_weekly} = cond do
    vx_rental.thing != nil ->
      last_week = Vx.fetch_actual_usage(vx_rental.thing.aadhardwareid, ...)
      for_month = Vx.fetch_actual_usage(vx_rental.thing.aadhardwareid, ...)
      {_, since_service} = Vx.get_usage_since_service(vx_rental.thing, customer)
      average_weekly = Vx.get_avg_weekly_hours(vx_rental.thing, customer)
      ...
  end
  ...
end
```

Multiple live database/business-logic calls (`Vx.fetch_actual_usage/5`, `Vx.get_usage_since_service/2`, `Vx.get_avg_weekly_hours/2`) are made directly inside the view render function. This violates the Phoenix MVC convention and creates the following security-relevant concerns:

1. Database errors (connection failures, unexpected nil results) occurring in the view will produce render errors rather than being handled at the controller layer. Depending on the `FallbackController` and `ErrorView` configuration, these may produce responses that include internal error detail.
2. The `customer` value used for these data fetches is passed through from the controller. If the controller passes an attacker-controlled customer code (see A134-3), the view will query that customer's database prefix for usage data — the view layer provides no independent check.
3. Performance failures in these view-layer queries are difficult to instrument or time out cleanly.

**Recommendation:** Move all data fetching to the controller. The view should receive pre-computed values (last_week, for_month, since_service, etc.) in the assigns map and perform only formatting/serialisation.

---

### A134-7 — LOW: `equipment` field passed through without filtering in `rhm_fleet_with_equip.json`

**Severity:** LOW
**File:** `lib/api_server_web/views/vx_fleet_view.ex`, lines 37–44

```elixir
def render("rhm_fleet_with_equip.json", %{vx_fleet: vx_fleet}) do
  %{id: vx_fleet.aaeid,
    name: vx_fleet.aaedesc,
    type: vx_fleet.aaetype,
    show_in_filters: vx_fleet.aaeshowfilter,
    equipment: vx_fleet.equipment
  }
end
```

The `equipment` field is a pre-built list passed in from the controller. At present the controller builds it with only `%{name: vehicle_name, hardwareid: hardwareid}` entries. However, the view performs no field selection on the `equipment` list — it is passed through as-is. If the controller is changed to populate `equipment` with richer structs (e.g., Ecto-preloaded `VXThing` records), all fields including internal IDs, IMEI numbers, mobile numbers, and GPS coordinates would be serialised.

**Recommendation:** Render the equipment list explicitly in the view, selecting only the fields required for the API contract.

---

### A134-8 — INFO: Typo in `hours_to_service` JSON key in `rhm_rental.json`

**Severity:** INFO
**File:** `lib/api_server_web/views/vx_rental_view.ex`, line 55

```elixir
hours_to_serivce: hours_to_service,
```

The JSON key is misspelled as `hours_to_serivce` (transposed `i` and `v`). This is a bug rather than a security issue, but it is flagged as it represents an inconsistency in the API contract that may affect client-side processing and could mask incorrect values being silently ignored by API consumers.

**Recommendation:** Correct the key name to `hours_to_service` and update any API consumers that currently accept the misspelled key.

---

### A134-9 — INFO: `vx_fleet.json` template omits fleet name (`aaedesc`) — potential contract ambiguity

**Severity:** INFO
**File:** `lib/api_server_web/views/vx_fleet_view.ex`, lines 13–20

```elixir
def render("vx_fleet.json", %{vx_fleet: vx_fleet}) do
  %{
    id: vx_fleet.id,
    aaetype: vx_fleet.aaetype,
    aaeshowfilter: vx_fleet.aaeshowfilter,
    aaecolour: vx_fleet.aaecolour
  }
end
```

This template (used by the scaffolded `index.json` and `show.json` routes) omits `aaedesc` (the fleet name) and uses raw database column names as JSON keys (`aaetype`, `aaeshowfilter`, `aaecolour`). The `rhm_fleet.json` template (the primary application-facing template) maps these to semantic names. The existence of two parallel templates with different field sets and naming conventions is a maintenance risk — a client that receives `vx_fleet.json` instead of `rhm_fleet.json` will get column-named fields, which leaks schema structure.

**Recommendation:** If the `index.json`/`show.json` routes served by `vx_fleet.json` are still in use, align the template with `rhm_fleet.json` naming conventions. If these routes are unused, remove the templates.

---

## Summary Table

| ID | Severity | File | Title |
|----|----------|------|-------|
| A134-1 | CRITICAL | vx_fleet_association_view.ex / controller | VXFleetAssociationController has no tenant scoping on any action |
| A134-2 | HIGH | vx_fleet_association_view.ex | Internal customer code (`aafcustcode`) exposed in API response |
| A134-3 | HIGH | vx_rental_view.ex / vx_fleet_view.ex (controllers) | Customer tenant identifier accepted from URL path on mutation endpoints |
| A134-4 | MEDIUM | vx_rental_view.ex | Business logic (`convert_json_to_changeset`) placed in view module without input validation |
| A134-5 | MEDIUM | vx_rental_view.ex | Pass-through render functions provide no serialisation boundary |
| A134-6 | MEDIUM | vx_rental_view.ex | Database queries executed inside view render function |
| A134-7 | LOW | vx_fleet_view.ex | `equipment` field passed through without explicit field selection |
| A134-8 | INFO | vx_rental_view.ex | Typo in JSON key `hours_to_serivce` |
| A134-9 | INFO | vx_fleet_view.ex | `vx_fleet.json` template uses raw column names and is inconsistent with `rhm_fleet.json` |
