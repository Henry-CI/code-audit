# Audit Report A074
**Agent:** A074
**Run:** 2026-02-27-01
**Repo:** api_server (Elixir/Phoenix)
**Branch:** master
**Date:** 2026-02-27

---

## Assigned Files

1. `lib/api_server/vx/vx_abl_record.ex`
2. `lib/api_server/vx/vx_access_fob.ex`
3. `lib/api_server/vx/vx_customer.ex`

Supporting files read for context (not assigned, evidence not required):
- `lib/api_server_web/controllers/vx_abl_record_controller.ex`
- `lib/api_server_web/controllers/vx_access_fob_controller.ex`
- `lib/api_server_web/controllers/vx_customer_controller.ex`
- `lib/api_server_web/controllers/file_controller.ex`
- `lib/api_server_web/router.ex`
- `lib/api_server/vx/vx.ex` (relevant excerpts)

---

## Reading Evidence

---

### File 1: `lib/api_server/vx/vx_abl_record.ex`

**Module:** `ApiServer.Vx.VXAblRecord`

**Public functions (def):**

| Name | Arity | Line |
|---|---|---|
| `changeset` | 2 | 25 |
| `generate_service` | 10 | 31 |
| `clean_xml_value` | 1 | 54 |
| `clean_xml_number_value` | 1 | 63 |
| `expand_xml_to_struct` | 1 | 72 |

**Schema — `abl_data_changes`:**

Primary key: `{:ablid, :id, autogenerate: true}`

| Field | Type |
|---|---|
| `abldatetime` | `:utc_datetime` |
| `ablcustcode` | `:string` |
| `abluser` | `:string` |
| `abllogtype` | `:string` |
| `ablusragnt` | `:string` |
| `ablip_address` | `:string` |
| `abltable` | `:string` |
| `ablaction` | `:string` |
| `ablimagetype` | `:string` |
| `ablimage` | `:string` |
| `ablprocessed` | `:string` |
| `belongs_to :user` | `VXUser` (FK: `abluser` → `aacuser`, `define_field: false`) |

**Module-level use/import/alias:**

- `use Ecto.Schema`
- `import Ecto.Changeset`
- `alias ApiServer.Vx`

---

### File 2: `lib/api_server/vx/vx_access_fob.ex`

**Module:** `ApiServer.Vx.VXAccessFob`

**Public functions (def):** None defined in this file.

**Schema — `access_fobs`:**

Primary key: default (`:id`)

| Field | Type |
|---|---|
| `fob_code` | `:string` |
| `belongs_to :user` | `VXUser` (FK: `assigned_to_user` → `aacid`) |

**Module-level use/import/alias:**

- `use Ecto.Schema`
- Top-level `require Ecto.Query` (line 1, outside the module)
- Top-level `require Ecto.Adapters.SQL` (line 2, outside the module)

---

### File 3: `lib/api_server/vx/vx_customer.ex`

**Module:** `ApiServer.Vx.VXCustomer`

**Public functions (def):**

| Name | Arity | Line |
|---|---|---|
| `convert_json_to_changeset` | 1 | 25 |
| `changeset` | 2 | 43 |

**Schema — `aaa_customers`:**

Primary key: `{:aaaid, :id, autogenerate: true}`

| Field | Type |
|---|---|
| `aaaaddr1` | `:string` |
| `aaaaddr2` | `:string` |
| `aaaaddr3` | `:string` |
| `aaacolour` | `:string` |
| `aaaname` | `:string` |
| `aaapcode` | `:string` |
| `aaaprimcont` | `:string` |
| `aaaprimemail` | `:string` |
| `aaaprimtel` | `:string` |
| `aaatz` | `:string` |
| `aaaudfcustcode` | `:string` |
| `aaacustcode` | `:string` |
| `belongs_to :rental` | `VXRental` (FK: `aaaid` → `abhcustomerid`, `define_field: false`) |

**Module-level use/import/alias:**

- `use Ecto.Schema`
- `import Ecto.Changeset`
- `alias ApiServer.Vx`

---

## Findings

---

### A074-1 — HIGH — XML Injection via Unsanitised User-Controlled Values in `generate_service/10`

**File:** `lib/api_server/vx/vx_abl_record.ex`, line 34
**Also present:** `lib/api_server_web/controllers/vx_abl_record_controller.ex`, lines 148–160

`generate_service/10` constructs an XML document by direct Elixir string interpolation of its parameters into the XML literal string:

```elixir
abl_xml = "<?xml version='1.0'?><documentroot>
  <import_hour_meter>#{import_hour_meter}</import_hour_meter>
  <performed_by>#{performed_by}</performed_by>
  <hardwareid>#{thing.aadhardwareid}</hardwareid>
  ...
</documentroot>"
```

None of `import_hour_meter`, `performed_by`, `thing.aadhardwareid`, `existing_service_date`, `new_service_date`, `current_hour_meter`, `input_one_hour_meter`, or `usage.usage` are XML-escaped before interpolation. If any of these values contain characters such as `<`, `>`, `&`, `"`, or `'`, the resulting XML will be malformed or can be manipulated to inject arbitrary XML nodes.

The companion function `generate_service_record` in the controller (lines 148–160) has the identical pattern and the same values flow through, some of which originate directly or indirectly from user-supplied input (e.g. `new_service_date` from request parameters, `branch_name` from a DB value that was originally user-supplied).

`expand_xml_to_struct` (line 72) then parses the stored XML back via `XmlToMap.naive_map/1`. Injected structure in the stored XML would be parsed into unexpected map keys, potentially bypassing downstream filtering logic.

**Recommendation:** Use an XML library to produce well-formed XML with proper escaping, rather than string interpolation. At minimum, apply `&amp;`, `&lt;`, `&gt;` entity escaping to every interpolated value.

---

### A074-2 — HIGH — Hardcoded Access Fob Credentials (Admin Fob List)

**File:** `lib/api_server/vx/vx.ex`, lines 199–201 (observed during context reading for `VXAccessFob`)

```elixir
def get_vx_admin_fobs() do
  "000019333303000019333AEA000019330E4E0000193354AC00001933382D00001932FCA800001933001A"
end
```

Seven physical access-control fob codes are hardcoded as a hex string directly in source. These fob codes are used in `file_controller.ex` (line 33) as the seed of the binary access-file that is sent to hardware devices to control which fobs can operate the vehicle. Committing these credentials to version control means:

1. Anyone with read access to the repository knows all master/admin fob codes.
2. Rotating the codes requires a code change and deployment, not an operational action.
3. There is no mechanism to invalidate one code without redeploying.

**Recommendation:** Move admin fob codes to the application configuration, loaded from environment variables or a secrets manager, not embedded in source. The `file_controller.ex` endpoints are on the unauthenticated pipeline (see A074-4) which amplifies the exposure.

---

### A074-3 — HIGH — Information Disclosure: Internal Ecto Error Details Returned to Client

**File:** `lib/api_server_web/controllers/vx_customer_controller.ex`, lines 27–28

```elixir
IO.inspect error
send_resp(conn, :internal_server_error,
  "{\"error\": \"error creating customer\", \"reason\": \"#{inspect error.errors}\" }")
```

On a changeset error during customer creation, the raw `inspect/1` output of `error.errors` — which is the Ecto changeset error list — is serialised directly into the HTTP response body sent to the client. This can expose:

- Internal database constraint names (e.g. `UQ1` is already used in `VXCustomer.changeset/2`)
- Column names from the underlying VX database schema
- Validation logic that aids enumeration attacks

Additionally, `IO.inspect error` writes the full error struct to stdout/logs with no redaction.

**Recommendation:** Return a generic error message to the client. Log the detailed error server-side via `Logger` at the appropriate level. Remove `IO.inspect`.

---

### A074-4 — HIGH — Missing Tenant/Customer Scoping: `VXAccessFob` Index and Delete Endpoints

**File:** `lib/api_server_web/controllers/vx_access_fob_controller.ex`, lines 9–24
**Context:** `lib/api_server/vx/vx.ex`, lines 145–147 and 215–217

The `index` action calls `Vx.list_vxaccessfobs()` which performs `Repo.all(VXAccessFob)` — a full-table scan with no `prefix:` (tenant schema) qualifier and no filtering:

```elixir
def list_vxaccessfobs do
  Repo.all(VXAccessFob)
end
```

The `show` and `delete` actions similarly call `Vx.get_vx_access_fob!(id)` and `Vx.delete_vx_access_fob/1` with no tenant scoping. Compare this to `list_customers/1`, `get_vx_customer!/2`, and `delete_vx_customer/2` which all correctly pass `prefix: customer`.

All three actions return or delete fob records from across all customer tenants indiscriminately. This is an IDOR/cross-tenant data leak.

Note: `[REDACTED-AWS-SMTP-PASSWORD]` does not appear to be wired into the router (`router.ex` has no route to it), which means these endpoints are currently unreachable. However the underlying context functions (`list_vxaccessfobs`, `get_vx_access_fob!`) are also called from `file_controller.ex` which **is** on an unauthenticated pipeline (see A074-5). The schema module and context functions represent a latent cross-tenant vulnerability if routes are added.

**Recommendation:** Add `prefix: customer` to all access-fob queries. Remove or restrict the controller if the endpoints are not required.

---

### A074-5 — HIGH — Unauthenticated Access to Access Fob File Download Endpoints

**File:** `lib/api_server_web/router.ex`, lines 156–177
**Affected controller:** `lib/api_server_web/controllers/file_controller.ex`

The following routes are in the `pipe_through(:api)` scope (line 157) — **not** `pipe_through([:api, :authenticated])`:

```elixir
get("/files/getsize/:esn", FileController, :get_size)
get("/files/getfile/:esn", FileController, :send_file_download)
```

These endpoints:
- Accept a bare `esn` (hardware ID) parameter from any caller
- Look up all fleet fobs for the identified device
- Return the fob count (`:get_size`) or generate and deliver the complete binary access-control file including admin fob codes (`:get_file`)

No JWT or session authentication is required. Any party that can reach the API and knows (or guesses) a hardware ID can download the full access fob binary for any vehicle, including the seven hardcoded admin fobs. This bypasses the physical access control system.

**Recommendation:** Move these routes into the authenticated pipeline. Verify that the hardware device consuming these endpoints supports bearer token authentication; if not, implement a device-specific shared secret or mutual TLS.

---

### A074-6 — MEDIUM — `ablcustcode` Field Not Populated in `generate_service/10`

**File:** `lib/api_server/vx/vx_abl_record.ex`, lines 35–49

The `abl_changeset` map built in `generate_service/10` omits `ablcustcode`, setting `ablip_address` to the static string `"0.0.0.0"` instead of the actual caller IP. The changeset is then persisted via `Vx.create_abl_record/2`. In contrast, the controller version `generate_service_record/3` correctly captures `conn.remote_ip`.

The `generate_service/10` function (with the fake IP and missing `ablcustcode`) is a separate code path from `generate_service_record/3`. It is called elsewhere (e.g. from import/sync flows). Storing `0.0.0.0` as the originating IP degrades audit log integrity — if the ABL log is used for forensic or compliance purposes, these entries cannot be attributed.

**Recommendation:** Pass the real originating IP (or a meaningful system identifier for automated/import operations) and the customer code into the ABL record. Do not use `0.0.0.0` as a placeholder in production audit logs.

---

### A074-7 — MEDIUM — `convert_json_to_changeset/1` in `VXCustomer` Bypasses Ecto Changeset Validation

**File:** `lib/api_server/vx/vx_customer.ex`, lines 25–39

`convert_json_to_changeset/1` builds a plain `%{}` map by calling `Vx.update_key_if_value/3` for each field, then returns the raw map — not an `%Ecto.Changeset{}`. The result is passed directly to `Vx.create_vx_customer/2` and `Vx.update_vx_customer/3`, which then call `VXCustomer.changeset(struct, attrs)`.

The concern is the `aaacustcode` derivation at line 36:

```elixir
|> Vx.update_key_if_value(:aaacustcode,
    String.upcase(
      String.slice(
        String.replace(String.reverse(customer_json["name"]), " ", ""),
        0..8)))
```

If `customer_json["name"]` is `nil` (the key exists in the JSON but has a null value), `String.reverse(nil)` will raise a `FunctionClauseError` that is not caught. The `nil`-guard in `update_key_if_value/3` only prevents the key from being set when the **value** is nil, but the nil is already being passed into `String.reverse/1` before reaching `update_key_if_value/3`.

Additionally, `customer_json["aaaudfcustcode"]` and `customer_json["aaacolour"]` (lines 37–38) are accepted from the JSON payload with no validation — an attacker can set `aaaudfcustcode` to an arbitrary string. While the Ecto changeset would ultimately persist it, there is no length or format constraint on either field.

**Recommendation:** Guard `customer_json["name"]` for nil before the `String.reverse` pipeline. Move `aaacustcode` derivation into a changeset `validate_*` or `prepare_changes` step so it benefits from changeset error handling. Add length constraints on free-text fields.

---

### A074-8 — MEDIUM — `expand_xml_to_struct/1` Uses `Map.merge/2` to Merge XML Data onto a DB Struct

**File:** `lib/api_server/vx/vx_abl_record.ex`, lines 89–102

```elixir
Map.merge(abl_record, map_from_xml)
```

`abl_record` is an `%ApiServer.Vx.VXAblRecord{}` Ecto struct returned from the database. `Map.merge/2` is called with a plain map containing XML-derived keys. While the keys being merged (`new_service_date`, `old_service_date`, etc.) are controlled by the developer and not directly from user XML, the `hardwareid` value at line 75–87 is parsed directly from the stored `ablimage` XML with only a numeric parse and no further sanitisation. Any adversary able to write a crafted value into `ablimage` (possible via the XML injection identified in A074-1) could influence the `hardwareid` surfaced to callers.

The dead code at lines 80–84 is also notable: the two branches of the `if length(Integer.digits(value)) >= 10` conditional produce identical results, indicating an incomplete or abandoned length-check guard.

**Recommendation:** Use a typed struct or a purpose-built map with validated keys rather than `Map.merge/2` onto an Ecto struct. Remove or complete the dead length-check logic.

---

### A074-9 — LOW — `require` Directives Outside Module in `vx_access_fob.ex`

**File:** `lib/api_server/vx/vx_access_fob.ex`, lines 1–2

```elixir
require Ecto.Query
require Ecto.Adapters.SQL
```

Both `require` directives are placed **before** `defmodule`, making them file-level rather than module-level declarations. `Ecto.Adapters.SQL` is not used anywhere in the module body. Residual `require` statements for `Ecto.Adapters.SQL` are a common marker of removed raw SQL code; their continued presence suggests dead code cleanup has not been completed and could indicate a prior raw-SQL pattern that was partially removed.

**Recommendation:** Move `require` directives inside the `defmodule` block and remove the unused `require Ecto.Adapters.SQL`.

---

### A074-10 — LOW — `ablcustcode` Field in Schema Not Set via Changeset

**File:** `lib/api_server/vx/vx_abl_record.ex`, lines 27–28

The `changeset/2` function casts:

```elixir
cast(attrs, [:abldatetime, :abluser, :abllogtype, :ablusragnt, :ablip_address,
             :abltable, :ablaction, :ablimagetype, :ablimage, :ablprocessed])
```

The field `ablcustcode` is defined in the schema but is not included in the cast list. It can therefore only be set on the struct directly (bypassing changeset validation). The `generate_service/10` function also omits `ablcustcode` from its attrs map. This means `ablcustcode` will be `nil` for all records created through these code paths, despite the column existing in `abl_data_changes`. If this column is queried for reporting or access scoping, missing values will produce incorrect results.

**Recommendation:** Either include `ablcustcode` in the cast list and populate it at all call sites, or remove the field from the schema if it is no longer in use.

---

### A074-11 — INFO — `VXCustomer.changeset/2` Uses Non-Descriptive Unique Constraint Name

**File:** `lib/api_server/vx/vx_customer.ex`, line 47

```elixir
|> unique_constraint(:aaacustcode, name: :UQ1)
```

The constraint name `UQ1` provides no context about which table or column the uniqueness constraint applies to. While this is not a security issue, if `UQ1` is a name shared across multiple tables, Ecto may match the wrong constraint and surface misleading validation errors. Additionally, generic constraint names complicate database migration audits.

**Recommendation:** Use a descriptive constraint name (e.g. `aaa_customers_aaacustcode_index`).

---

## Checklist Summary

### §1: Secrets and Configuration
No hardcoded credentials found within the three assigned schema files themselves. A074-2 identifies hardcoded access fob codes in the broader `vx.ex` context module discovered while auditing `VXAccessFob` usage.

### §2: Authentication and Authorization
A074-4: `VXAccessFob` context functions lack tenant scoping (cross-tenant IDOR risk).
A074-5: File download endpoints using `VXAccessFob` data are on the unauthenticated pipeline.
No other auth issues found within the three schema modules themselves.

### §3: Input Validation and Injection
A074-1: XML injection via unsanitised string interpolation in `generate_service/10` and the controller equivalent.
A074-7: `convert_json_to_changeset/1` in `VXCustomer` passes `nil` to `String.reverse/1` which will raise at runtime.
No raw SQL fragments or atom creation from user input found in the three assigned files.

### §4: Session and CSRF
Not applicable to these schema/context modules directly. No session or CSRF logic present.

### §5: File and Data Handling
A074-3: Ecto error details (including constraint names) leaked to HTTP clients in `[REDACTED-AWS-SMTP-PASSWORD]`.
A074-6: Audit log (`abl_data_changes`) records created with fabricated IP address `0.0.0.0` from import paths, degrading forensic integrity.
A074-8: `Map.merge/2` onto Ecto struct from XML-derived data; dead code in integer length check.

### §6: Dependencies
Not assessed in this file set (no `mix.exs` or `mix.lock` changes observed).

### §7: Infrastructure Exposure
No hardcoded hostnames, IPs, or internal URLs found in the three assigned schema modules. The hardcoded admin fob hex codes (A074-2) are access-control credentials rather than infrastructure topology, but are noted under §1/§2.
