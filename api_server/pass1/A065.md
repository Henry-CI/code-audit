# Security Audit Report — A065
**Agent:** A065
**Run:** 2026-02-27-01
**Repo:** api_server
**Stack:** Elixir/Phoenix
**Branch:** master
**Date:** 2026-02-27

---

## Assigned Files

1. `lib/api_server/vx/equipment.ex`
2. `lib/api_server/vx/equipment_assignment.ex`
3. `lib/api_server/vx/erp_import.ex`

---

## Reading Evidence

---

### File 1: `lib/api_server/vx/equipment.ex`

**Module name:** `ApiServer.Vx.Equipment`

**Public functions (`def`):**

| Name | Arity | Line |
|------|-------|------|
| `changeset` | 2 | 20 |

**Schema defined:**

```elixir
@primary_key {:ID, :id, autogenerate: true}
schema "equipment" do
  field :id, :integer, source: :id
  field :name, :string, source: :name
  field :make, :string, source: :make
  field :model, :string, source: :model
  field :serial_number, :string, source: :serial_number
  field :class, :string, source: :class
  field :type, :string, source: :type
  field :created, :utc_datetime, source: :created
end
```

No `defstruct` or `defexception` defined.

**Module-level `use` / `import` / `alias`:**

| Directive | Value | Line |
|-----------|-------|------|
| `use` | `Ecto.Schema` | 2 |
| `import` | `Ecto.Changeset` | 3 |
| `alias` | `ApiServer.Vx` | 5 |

---

### File 2: `lib/api_server/vx/equipment_assignment.ex`

**Module name:** `ApiServer.Vx.EquipmentAssignment`

**Public functions (`def`):**

| Name | Arity | Line |
|------|-------|------|
| `changeset` | 2 | 20 |

**Schema defined:**

```elixir
@primary_key {:ID, :id, autogenerate: true}
schema "equipment_assignment" do
  field :id, :integer, source: :id
  field :equipment_id, :integer, source: :equipment_id
  field :device_group, :string, source: :device_group
  field :device_group_timezone, :string, source: :device_group_timezone
  field :assignment_start, :utc_datetime, source: :assignment_start
  field :assignment_end, :utc_datetime, source: :assignment_end
  field :created, :utc_datetime, source: :created
end
```

Note: `belongs_to :equipment` association is commented out on line 17.

No `defstruct` or `defexception` defined.

**Module-level `use` / `import` / `alias`:**

| Directive | Value | Line |
|-----------|-------|------|
| `use` | `Ecto.Schema` | 2 |
| `import` | `Ecto.Changeset` | 3 |
| `alias` | `ApiServer.Vx` | 5 |

---

### File 3: `lib/api_server/vx/erp_import.ex`

**Module name:** `ApiServer.Vx.ERPImport`

**Public functions (`def`):**

| Name | Arity | Line |
|------|-------|------|
| `changeset` | 2 | 15 |

**Schema defined:**

```elixir
@primary_key {:id, :id, autogenerate: true}
schema "erp_imports" do
  field :raw_record, :string
  field :serialno, :string
  field :name, :string
  field :matched, :boolean
  field :type, :string
end
```

No `defstruct` or `defexception` defined.
No timestamps macro — no `inserted_at` / `updated_at` fields.

**Module-level `use` / `import` / `alias`:**

| Directive | Value | Line |
|-----------|-------|------|
| `use` | `Ecto.Schema` | 2 |
| `import` | `Ecto.Changeset` | 3 |

---

## Checklist Review

Supporting context reviewed beyond the three assigned files:

- `lib/api_server/vx/vx.ex` — query functions for equipment, equipment_assignment, erp_import
- `lib/api_server_web/controllers/utility_controller.ex` — `erp_import/2`, `create_equipment/3`, `create_equipment_assignment/3`, `pull_equipment_data_from_rayven/1`
- `lib/api_server_web/controllers/vx_fleet_controller.ex` — fleet/equipment endpoint handlers
- `lib/api_server_web/router.ex` — routing and pipeline assignments

---

### §1: Secrets and Configuration

No hardcoded credentials, API keys, or secret key bases found within the three assigned schema files. Internal employee email addresses used as ERP routing identifiers are examined under §2 below.

**§1: No issues found in the schema files themselves.**

---

### §2: Authentication and Authorization

**A065-1 — CRITICAL — `/erp-import` endpoint is unauthenticated**

The route `POST /erp-import` is declared in `router.ex` (line 190) inside the scope that uses only `pipe_through(:api_xml)` (line 180). This pipeline contains no `:authenticated` plug. There is no Guardian authentication applied to this endpoint.

The `erp_import/2` action in `utility_controller.ex` (line 5666) accepts a `"from"` string parameter supplied by the caller and uses it to resolve the target customer/tenant schema prefix:

```elixir
customer =
  case from do
    "SQLserver@sielift.com"  -> "vx_sielift"
    "rayven+cea@trackingsolutions.io" -> "vx_cea"
    ...
    _ -> "vx_dev"
  end
```

Because there is no authentication, any unauthenticated caller on the network can POST to `/erp-import` with an arbitrary `"from"` value. Since the email addresses used as keys are either publicly known domain formats or derivable from patterns already visible in the codebase, an attacker can trivially target any customer tenant. The action then:

- Reads and writes ERP import records into the named tenant's schema (`Vx.create_erp_import/2`, `Vx.check_for_existing_erp_record/2`)
- Triggers `process_rental_from_erp/2` and `process_service_from_erp/2`, which write operational fleet data (rentals, services) into the tenant database
- Calls `Vx.list_vxthings(customer)` and iterates all vehicle records, invoking `do_fix_info` on each — a potentially expensive operation that can be used as an amplified denial-of-service vector against any tenant

The `_ -> "vx_dev"` catch-all also means that any unrecognised `from` value silently routes to the `vx_dev` tenant rather than returning an error, which may pollute development data or mask abuse.

**Affected files:**
- `lib/api_server_web/router.ex` line 190
- `lib/api_server_web/controllers/utility_controller.ex` line 5666
- `lib/api_server/vx/erp_import.ex` (the schema written to)

---

**A065-2 — HIGH — Tenant resolution via user-controlled email string with no validation**

Even if authentication were added to `/erp-import`, the current tenant resolution logic maps a caller-supplied `"from"` string directly to an internal database schema prefix. This is an indirect authorisation check: the caller asserts their identity by providing an email address, and the server trusts it.

The pattern used in `erp_import/2` (utility_controller.ex lines 5668–5698):

```elixir
customer =
  case from do
    "SQLserver@sielift.com" -> "vx_sielift"
    ...
    _ -> "vx_dev"
  end
```

This is not equivalent to verifying that the JWT or session token belongs to a user authorised for that tenant. Any authenticated caller (if authentication is added) could still provide any `from` value and be routed to `vx_dev`, or if the allowed email addresses became known, to any customer tenant. The correct pattern is to derive the customer identifier exclusively from the authenticated token claims (as done in `vx_fleet_controller.ex` lines 20, 28 using `Guardian.Plug.current_claims(conn)["customer"]`).

---

**A065-3 — MEDIUM — `EquipmentAssignment` schema `unique_constraint` does not match business intent**

In `equipment_assignment.ex` line 24:

```elixir
|> unique_constraint(:equipment_id)
```

This imposes a unique constraint on `equipment_id` alone, meaning each piece of equipment can have at most one assignment record at any time in the database. The commented-out association on line 17 and the presence of `assignment_start` / `assignment_end` fields strongly suggest the intent is to track a history of assignments over time (i.e., multiple rows per `equipment_id` with non-overlapping time windows). The over-restrictive unique constraint will silently cause insert failures via changeset errors when attempting to close an old assignment and create a new one, potentially leaving assignment history incomplete or causing silent data loss in `create_equipment_assignment_record/2`. This is a data-integrity and security-relevant issue because incorrect assignment records directly affect `device_group_timezone` lookups used in rental period calculations and timezone-sensitive business logic throughout `utility_controller.ex`.

---

### §3: Input Validation and Injection

**A065-4 — MEDIUM — `raw_record` field stores unvalidated external JSON as a plain string; `Poison.decode!` raises on malformed data**

In `erp_import.ex`, `raw_record` is a `:string` field that stores JSON encoded by `Poison.encode!(record)` (`utility_controller.ex` line 5748). On retrieval, `vx.ex` lines 3212 and 3218 call:

```elixir
|> Enum.filter(fn(erp_import) -> Poison.decode!(erp_import.raw_record) == raw_record end)
```

`Poison.decode!/1` raises `Poison.ParseError` if the stored value is not valid JSON. Any corrupted row in `erp_imports` will crash this filter enumeration with an unhandled exception, halting the duplicate-check for the entire batch. There is no rescue or error-tuple variant used. The correct approach is `Poison.decode/1` (returns `{:ok, val}` / `{:error, reason}`) with explicit error handling.

---

**A065-5 — LOW — `Equipment.changeset/2` permits mass-assignment of the primary key field `id`**

`equipment.ex` line 22:

```elixir
|> cast(attrs, [:id, :name, :make, :model, :serial_number, :class, :type, :created])
```

`:id` is included in the cast list. The primary key (`ID`) is configured with `autogenerate: true`, but passing `:id` through `cast/3` means caller-supplied `id` values will be accepted and set on the changeset. If any code path in `utility_controller.ex` constructs attrs from partially user-controlled input and passes them to `create_equipment_record/2`, an attacker could force a specific primary key value, potentially causing conflicts with or overwriting existing records. The same pattern exists in `equipment_assignment.ex` line 22 (`:id` in cast list). The `:id` field should be removed from the cast list in both changesets.

---

**A065-6 — LOW — `Equipment.changeset/2` permits mass-assignment of `:created` timestamp**

`equipment.ex` line 22 also includes `:created` in the cast list. An attacker with write access to the create path could supply an arbitrary timestamp for the `created` field, undermining audit trail integrity. The same applies to `equipment_assignment.ex` line 22 (both `:created`, `:assignment_start`, `:assignment_end` are cast). While `assignment_start` and `assignment_end` are legitimate business inputs, `:created` should be set server-side only and excluded from the cast list.

---

### §4: Session and CSRF

The three schema files are not involved in session or CSRF handling.

**§4: No issues found in the assigned files.**

---

### §5: File and Data Handling

**A065-7 — MEDIUM — Equipment PII and fleet asset data logged via `IO.puts` to stdout**

In `utility_controller.ex`, the functions that invoke the assigned schemas log sensitive fleet data using `IO.puts` (not `Logger`), which writes directly to stdout with no log-level filtering. Notable instances:

- Line 3519: `IO.puts("[equipment] #{inspect(map)}")` — logs the full equipment map including `serial_number`, `name`, `make`, `model`, `class`, `type` for every device processed.
- Line 3528: `IO.puts("[equipment_id] #{inspect(equipment_id)}")` — logs equipment IDs.
- Line 3591: `IO.puts("[equipment_assignment] #{inspect(map)}")` — logs full assignment maps including `equipment_id` and `device_group_timezone`.
- Line 3647: `IO.puts("[EQUIPMENT] #{inspect(equipment)}")` — logs the full `%Equipment{}` struct.
- Line 3648: `IO.puts("[ASSIGNMENTS] #{inspect(equipment_assignments)}")` — logs the full `%EquipmentAssignment{}` struct.
- Line 4671: `IO.puts("[RAYVEN_DATA] #{inspect(rayven_data)}")` — logs raw Rayven API response including device metadata.

Using `IO.puts` rather than `Logger` means these messages cannot be suppressed by log level configuration in production and will always appear in application logs. In a fleet management context, `serial_number`, device group, and customer asset names are PII / commercially sensitive data. This data should not be written to logs at all in production, or at minimum should use `Logger.debug` so it can be disabled.

---

**A065-8 — LOW — ERP import response echoes caller-supplied rental data back to client**

In `utility_controller.ex` line 5732:

```elixir
|> Plug.Conn.send_resp(:ok, Poison.encode!(%{matches: 0, rentals: rentals}))
```

The full `rentals` list (which was POSTed by the caller and may contain customer fleet data, serial numbers, and contract details) is serialised and returned in the response body. For an unauthenticated endpoint (see A065-1), this means any caller receives back the payload they submitted, potentially confirming data was accepted. More significantly, if any server-side transformation or enrichment were added to `rentals` in future, this would become an information-disclosure path.

---

### §6: Dependencies

Dependency analysis is outside the scope of the three assigned schema files. No dependency declarations are made within these files.

**§6: No issues found in the assigned files.**

---

### §7: Infrastructure Exposure

**A065-9 — INFO — Hardcoded internal customer tenant schema names throughout utility_controller.ex**

The `erp_import/2` action and surrounding helper functions in `utility_controller.ex` (lines 5668–5698 and elsewhere) contain hardcoded PostgreSQL schema prefix strings: `"vx_sielift"`, `"vx_sie_latest"`, `"vx_cea"`, `"vx_komatsuau"`, `"vx_yocam"`, `"vx_redpath"`, `"vx_dev"`. These names reveal the full set of customer tenants hosted on this multi-tenant deployment and the naming convention used for their database schemas. If this source file were ever exposed (e.g., via a repository leak or public error page), these names would enumerate all tenant namespaces. These should be maintained in configuration rather than embedded in source code.

This finding directly relates to the `ERPImport` schema because the hardcoded strings are used as the `prefix:` argument in all `Repo` calls operating on `erp_imports`.

---

## Summary of Findings

| ID | Severity | Title |
|----|----------|-------|
| A065-1 | CRITICAL | `/erp-import` endpoint is unauthenticated |
| A065-2 | HIGH | Tenant resolution via user-controlled email string with no validation |
| A065-3 | MEDIUM | `EquipmentAssignment` unique_constraint prevents assignment history |
| A065-4 | MEDIUM | `Poison.decode!` raises on malformed `raw_record`; no error handling |
| A065-5 | LOW | Primary key `:id` included in changeset cast list (Equipment, EquipmentAssignment) |
| A065-6 | LOW | `:created` timestamp cast from caller input; audit trail can be falsified |
| A065-7 | MEDIUM | Fleet/equipment PII logged via `IO.puts` with no log-level control |
| A065-8 | LOW | ERP import response echoes caller-supplied fleet data |
| A065-9 | INFO | Hardcoded tenant schema names enumerate customer deployment topology |
