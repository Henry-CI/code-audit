# Audit Report — A089
**Agent:** A089
**Run:** 2026-02-27-01
**Repo:** api_server
**Stack:** Elixir/Phoenix
**Branch:** master
**Date:** 2026-02-27

---

## Assigned Files

1. `lib/api_server/vx/vx_user.ex`
2. `lib/api_server/vx/vx_user_function.ex`
3. `lib/api_server_web.ex`

---

## Reading Evidence

---

### File 1: `lib/api_server/vx/vx_user.ex`

**Module name:** `ApiServer.Vx.VXUser`

**Public functions (def):**

| Name | Arity | Line |
|---|---|---|
| `convert_json_to_changeset/1` | 1 | 57 |
| `password_changeset/2` | 2 | 73 |
| `changeset/2` | 2 | 78 |

**Schema defined:** `schema "aac_user"` with `@primary_key {:aacid, :id, autogenerate: true}`

Schema fields:
- `:aaccustcode` — `:string`
- `:aacuser` — `:string`
- `:aacfname` — `:string`
- `:aacsurname` — `:string`
- `:aaccredte` — `:utc_datetime`
- `:aacexpdte` — `:date`
- `:aaclastupdated` — `:utc_datetime`
- `:aacpassword` — `:string`   *(plaintext password column)*
- `:aacpasswordhash` — `:string`   *(hash column present but unused in any changeset)*
- `:aacpasswordresetcode` — `:string`
- `:aactz` — `:string`
- `:aacfirstopt` — `:string`
- `:aacemail` — `:string`
- `:aacdash` — `:integer`
- `:aacpwdlastupd` — `:utc_datetime`
- `:aacuserdriver` — `:string`
- `:aaclic1` — `:string`
- `:aaclic1class` — `:string`
- `:aaclic1issuedate` — `:date`
- `:aaclic1expdate` — `:date`
- `:aaclic1issuer` — `:string`
- `:aaclic2` — `:string`
- `:aaclic2class` — `:string`
- `:aaclic2issuedate` — `:date`
- `:aaclic2expdate` — `:date`
- `:aaclic2issuer` — `:string`
- `:aacusertype` — `:string`
- `:aacproxyenabled` — `:string`
- `:aactimezone` — `:string`
- `:aacdeffleet` — `:integer`
- `:aacdateformat` — `:string`
- `:aachourformat` — `:integer`
- `:aaclang` — `:string`
- `:aacuom` — `:string`
- `:aacmaprefresh` — `:integer`

Associations:
- `has_one :accessfob, ApiServer.Vx.VXAccessFob, foreign_key: :assigned_to_user`
- `has_one :function, ApiServer.Vx.VXUserFunction, foreign_key: :aatuser_id, on_replace: :update`
- `has_many :assigned_fleets, ApiServer.Vx.VXRestriction, foreign_key: :aauuser_id`
- `has_many :abl_records, ApiServer.Vx.VXAblRecord, foreign_key: :abluser, references: :aacuser`

**use / import / alias at module level:**
- `use Ecto.Schema` (line 5)
- `import Ecto.Changeset` (line 7)
- `alias ApiServer.Vx` (line 9)

**Top-level requires (file level, outside defmodule):**
- `require Ecto.Query` (line 1)
- `require Ecto.Adapters.SQL` (line 2)

---

### File 2: `lib/api_server/vx/vx_user_function.ex`

**Module name:** `ApiServer.Vx.VXUserFunction`

**Public functions (def):**

| Name | Arity | Line |
|---|---|---|
| `changeset/2` | 2 | 14 |

**Schema defined:** `schema "aat_user_functions"` with `@primary_key {:aatid, :id, autogenerate: true}`

Schema fields:
- `:aatfunction_id` — `:integer`
- `:aatuser_id` — `:integer`

Associations:
- `belongs_to :user, ApiServer.Vx.VXUser, foreign_key: :aatuser_id, references: :aacid, primary_key: true, define_field: false`

**use / import / alias at module level:**
- `use Ecto.Schema` (line 2)
- `import Ecto.Changeset` (line 3)

---

### File 3: `lib/api_server_web.ex`

**Module name:** `ApiServerWeb`

**Public functions (def / defmacro):**

| Name | Arity | Line |
|---|---|---|
| `controller/0` | 0 | 20 |
| `view/0` | 0 | 29 |
| `router/0` | 0 | 46 |
| `channel/0` | 0 | 54 |
| `__using__/1` (defmacro) | 1 | 64 |

**Defstruct / schema:** None.

**use / import / alias at module level:** None at module level. All `use`/`import` directives are inside quoted blocks within each function.

Injected into controllers (via `controller/0` quote):
- `use Phoenix.Controller, namespace: ApiServerWeb`
- `import Plug.Conn`
- `import ApiServerWeb.Router.Helpers`
- `import ApiServerWeb.Gettext`

Injected into views (via `view/0` quote):
- `use Phoenix.View, root: "lib/api_server_web/templates", namespace: ApiServerWeb`
- `import Phoenix.Controller, only: [get_flash: 2, view_module: 1]`
- `use Phoenix.HTML`
- `import ApiServerWeb.Router.Helpers`
- `import ApiServerWeb.ErrorHelpers`
- `import ApiServerWeb.Gettext`

Injected into routers (via `router/0` quote):
- `use Phoenix.Router`
- `import Plug.Conn`
- `import Phoenix.Controller`

Injected into channels (via `channel/0` quote):
- `use Phoenix.Channel`
- `import ApiServerWeb.Gettext`

---

## Findings

---

### A089-1 — CRITICAL: Passwords stored and compared in plaintext

**File:** `lib/api_server/vx/vx_user.ex`
**Lines:** 21, 66, 75, 80

The schema defines a field `:aacpassword` of type `:string` alongside a separate `:aacpasswordhash` field. The `password_changeset/2` function casts directly into `:aacpassword` without any hashing step. The `changeset/2` function also casts `:aacpassword` directly. `convert_json_to_changeset/1` maps `user_json["password"]` straight into `:aacpassword`.

Cross-referencing `lib/api_server/vx/vx.ex` (lines 2707 and 2715, surfaced by grep), authentication queries compare the stored value with the incoming value using a simple `where` clause:

```elixir
|> Ecto.Query.where(aacpassword: ^password)
```

And `lib/api_server_web/controllers/vx_user_controller.ex` (line 65) writes a new password directly as a map value:

```elixir
changeset = %{aacpassword: new_password}
```

No bcrypt, argon2, Comeonin, or any other password hashing library is present in `mix.exs`. The `:aacpasswordhash` field exists in the schema but is never populated or used.

**Impact:** All user passwords are stored as plaintext (or at most in whatever format the legacy database uses). A database breach exposes every user credential directly. An attacker who can read the DB or intercept queries obtains all passwords immediately. This affects authentication across the entire fleet management platform.

**Checklist reference:** §2 — Authentication and Authorization (password hashing requirement: bcrypt or argon2).

---

### A089-2 — CRITICAL: Password reset tokens have no expiry and no single-use enforcement

**File:** `lib/api_server/vx/vx_user.ex`
**Line:** 23

The schema has a single field for password reset: `:aacpasswordresetcode` (type `:string`). There is no corresponding expiry timestamp field (e.g., `:aacpasswordresetexpiry`) in the schema, and grep across the entire codebase finds zero references to this field outside its schema declaration.

This means:
1. No evidence that a reset code is ever invalidated after use (single-use enforcement absent).
2. No evidence that a reset code carries or is checked against an expiry time (time-limiting absent).

A password reset code that never expires is a permanent backdoor. Once issued, it can be used at any time, indefinitely, even after the user has changed their password through normal means.

**Checklist reference:** §2 — Authentication and Authorization (password reset tokens must be time-limited and single-use).

---

### A089-3 — HIGH: `password_changeset/2` applies no validation

**File:** `lib/api_server/vx/vx_user.ex`
**Lines:** 73–76

```elixir
def password_changeset(user, attrs) do
    user
        |> cast(attrs, [:aacpassword])
end
```

The `password_changeset/2` function casts the new password but applies:
- No `validate_required/2` — an empty or nil password can be set.
- No minimum length validation.
- No complexity validation.
- No hashing (see A089-1).

The controller (`vx_user_controller.ex` line 64) does gate on `new_password != nil && new_password != ""`, but that guard is in application logic, not in the changeset, meaning the data layer offers no protection if this changeset is reused elsewhere.

**Checklist reference:** §2 — Authentication and Authorization; §3 — Input Validation.

---

### A089-4 — HIGH: `changeset/2` password field accepts arbitrary input with no hashing or validation

**File:** `lib/api_server/vx/vx_user.ex`
**Lines:** 78–86

The main `changeset/2` includes `:aacpassword` in the cast list alongside user profile fields. No hashing is applied. No length or complexity validation is applied to the password. A password can be set to any string (including empty) when creating or updating a user through this changeset.

**Checklist reference:** §2 — Authentication and Authorization; §3 — Input Validation.

---

### A089-5 — HIGH: `convert_json_to_changeset/1` maps raw user-supplied password without hashing

**File:** `lib/api_server/vx/vx_user.ex`
**Lines:** 57–71

```elixir
|> Vx.update_key_if_value(:aacpassword, user_json["password"])
```

This function constructs a map from raw JSON input (presumably from an HTTP request body) and places the plaintext password directly into `:aacpassword`. No sanitisation, no hashing, no validation. The function returns a plain map, not a changeset, so Ecto changeset validations are bypassed entirely at this stage.

**Checklist reference:** §2 — Authentication and Authorization; §3 — Input Validation.

---

### A089-6 — MEDIUM: `VXUserFunction.changeset/2` casts non-existent field `:aatfunctionid`

**File:** `lib/api_server/vx/vx_user_function.ex`
**Lines:** 14–18

```elixir
def changeset(vx_user_function, attrs) do
  vx_user_function
  |> cast(attrs, [:aatuser_id, :aatfunctionid])
  |> validate_required([:aatuser_id, :aatfunctionid])
end
```

The schema defines the field as `:aatfunction_id` (with underscore before `id`), but the changeset casts and validates `:aatfunctionid` (no underscore). Ecto will silently ignore the unknown field during `cast/3`, meaning the function ID is never actually written through this changeset. `validate_required` on an unknown field will always produce a validation error, making this changeset non-functional. While not directly a security vulnerability, this indicates the changeset has never been exercised in tests and may be masking a privilege assignment failure — user function (permission level) updates may silently fail.

**Checklist reference:** §3 — Input Validation (changeset correctness).

---

### A089-7 — MEDIUM: `__using__/1` macro dispatches to `apply(__MODULE__, which, [])` where `which` is caller-supplied atom

**File:** `lib/api_server_web.ex`
**Lines:** 64–66**

```elixir
defmacro __using__(which) when is_atom(which) do
  apply(__MODULE__, which, [])
end
```

This macro accepts any atom and calls `apply/3` on it as a function name within `ApiServerWeb`. The guard `when is_atom(which)` confirms the value is an atom but does not whitelist it to the four valid values (`controller`, `view`, `router`, `channel`).

In practice this is compile-time only (invoked as `use ApiServerWeb, :controller`), so runtime exploitation via user input is not possible through this path. However, it is a pattern to note: if any future code path constructs this `use` call with a dynamic atom, it becomes a function-name injection point. As written, it will call any zero-arity public function on `ApiServerWeb` at compile time if a caller passes an unexpected atom.

The risk is low in the current codebase but the pattern is architecturally unsafe. A whitelist match (`case which do :controller -> ... end`) would be the correct implementation.

**Checklist reference:** §3 — Input Validation (atom-based dispatch / `Kernel.apply/3` with caller-controlled function name).

---

### A089-8 — INFO: Dead/commented code contains legacy credentials in a neighbouring file

This finding is noted for cross-agent awareness. Grep surfaced `lib/api_server_web/controllers/utility_controller.ex` lines 3353–3356 and 3374, which contain commented-out credentials (`kz2xA8Y+n#btU*dk`) for a Rayven API integration. These are outside the assigned file set (they are in `utility_controller.ex`) and have been flagged here only for completeness; the assigned agent for that file should record the primary finding. No credentials were found in the three assigned files.

**Checklist reference:** §1 — Secrets and Configuration.

---

## Checklist Section Summary

| Section | Status |
|---|---|
| §1 Secrets and Configuration | No issues found in the three assigned files. |
| §2 Authentication and Authorization | CRITICAL findings A089-1, A089-2; HIGH findings A089-3, A089-4, A089-5. |
| §3 Input Validation and Injection | HIGH finding A089-5; MEDIUM findings A089-6, A089-7. |
| §4 Session and CSRF | No issues found in the three assigned files. |
| §5 File and Data Handling | No issues found in the three assigned files. |
| §6 Dependencies | Not applicable to these three files (reviewed separately). Note: no password hashing dependency present in mix.exs — supports A089-1. |
| §7 Infrastructure Exposure | No issues found in the three assigned files. |
