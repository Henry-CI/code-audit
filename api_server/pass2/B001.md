# Audit Report B001 — Pass 2
**Audit run:** 2026-02-27-01
**Agent:** B001
**Date:** 2026-02-27
**Scope:** Infrastructure / bootstrap source files

---

## Assigned Source Files

1. `lib/api_server.ex`
2. `lib/api_server/application.ex`
3. `lib/api_server/guardian.ex`
4. `lib/api_server/repo.ex`

---

## File 1 — `lib/api_server.ex`

### READING EVIDENCE

**Module:** `ApiServer`

**Functions / macros / callbacks defined:**
- None. The module body contains only a `@moduledoc` string (lines 1–9).

**Types / structs / constants:** None.

**Test file:** None (no `test/api_server_test.exs`).

**Indirect test coverage search:**
- Grep for `ApiServer` (bare module name) in `test/` returns only support infrastructure references (`ApiServer.Repo`, `ApiServer.DataCase`, etc.). No test references the `ApiServer` module itself.

### Findings

#### B001-1 — HIGH: `ApiServer` module has no test file and no indirect coverage

**Severity:** HIGH
**File:** `lib/api_server.ex`
**Lines:** 1–9

The top-level `ApiServer` module has no dedicated test file and is never referenced by any test. Although the module currently contains no functions (only a `@moduledoc`), it is the canonical namespace root for the application. Any future functions added here will inherit zero test coverage with no existing test scaffold.

**Recommendation:** Create `test/api_server_test.exs` as a baseline scaffold even if it contains only a module existence smoke test.

---

## File 2 — `lib/api_server/application.ex`

### READING EVIDENCE

**Module:** `ApiServer.Application`

**Functions / macros / callbacks defined:**

| Line | Visibility | Name / Arity | Description |
|------|------------|--------------|-------------|
| 6 | public (OTP callback) | `start/2` | Builds child spec list, starts `Supervisor.start_link/2` under strategy `:one_for_one` |
| 36 | public (OTP callback) | `config_change/3` | Delegates to `ApiServerWeb.Endpoint.config_change/2`, returns `:ok` |

**Child processes started in `start/2`:**
- `ApiServer.FortyNineRepo` (supervisor)
- `ApiServer.Repo` (supervisor)
- `ApiServerWeb.Endpoint` (supervisor)
- `ApiServer.Scheduler` (Quantum cron)
- `ApiServer.TCP.TaskSupervisor` (`Task.Supervisor`)
- Anonymous `Task` wrapping `ApiServer.TCP.accept(tcp_port)` with `restart: :permanent`
- `ConCache` named `:geocode_store`, `ttl_check_interval: false`

**Environment variable read:** `TCP_PORT` (line 9) — defaults to `"4001"` if absent.

**Supervision strategy:** `:one_for_one` (line 30).

**Types / structs / constants:** None.

**Test file:** None (no `test/api_server/application_test.exs`).

**Indirect test coverage search:**
- Grep for `ApiServer.Application`, `config_change`, `TCP_PORT` in `test/` returns zero matches.
- The application starts automatically in the test environment (standard Mix behaviour), so `start/2` is exercised at a process level — but no assertion is made about its behaviour, child count, or failure modes.

### Findings

#### B001-2 — HIGH: `ApiServer.Application` has no test file and no indirect coverage

**Severity:** HIGH
**File:** `lib/api_server/application.ex`
**Lines:** 1–40

Neither `start/2` nor `config_change/3` is exercised by any test. The supervisor tree starts as a side-effect of `ExUnit.start()`, but no test asserts on the resulting process topology, child registration, or restart behaviour.

**Recommendation:** Add `test/api_server/application_test.exs` with at minimum a smoke test that the named supervisor is alive and that required child processes are registered.

#### B001-3 — MEDIUM: `config_change/3` is completely untested

**Severity:** MEDIUM
**File:** `lib/api_server/application.ex`
**Lines:** 36–39

`config_change/3` delegates to `ApiServerWeb.Endpoint.config_change/2`. No test calls this callback, so any regression (e.g. accidentally reversing the argument order — `changed` vs `removed` are passed positionally) would go undetected.

**Recommendation:** Add a test that calls `ApiServer.Application.config_change(%{}, %{}, [])` and asserts `:ok` is returned.

#### B001-4 — MEDIUM: `TCP_PORT` environment variable — missing/invalid value path untested

**Severity:** MEDIUM
**File:** `lib/api_server/application.ex`
**Line:** 9

```elixir
tcp_port = String.to_integer(System.get_env("TCP_PORT") || "4001")
```

`String.to_integer/1` raises `ArgumentError` if `TCP_PORT` is set to a non-integer string (e.g. `"abc"` or `""`). There is no test verifying the default fallback path or the error path when the variable is malformed.

**Recommendation:** Add tests covering: (a) `TCP_PORT` unset (default `4001`), (b) `TCP_PORT` set to a valid integer string, (c) `TCP_PORT` set to an invalid string (expected to raise or be caught).

#### B001-5 — LOW: Supervisor child list — no test for partial startup failure

**Severity:** LOW
**File:** `lib/api_server/application.ex`
**Lines:** 12–26

The supervisor uses `:one_for_one`. If any child (e.g. `ApiServer.TCP.accept/1` TCP listener or `ConCache`) fails to start, the supervisor will attempt restarts but the overall system may silently degrade. No test validates behaviour when any individual child fails to initialise (e.g. when the TCP port is in use or `DATABASE_URL` is absent).

**Recommendation:** Add integration or unit tests mocking child startup failures to verify the supervisor tree handles restarts correctly.

#### B001-6 — LOW: Deprecated `Supervisor.Spec` import used

**Severity:** LOW
**File:** `lib/api_server/application.ex`
**Line:** 7

```elixir
import Supervisor.Spec
```

`Supervisor.Spec` was deprecated in Elixir 1.5. The `supervisor/2` helper (lines 14–17) is a deprecated API. While not a testing gap per se, there are no tests that would catch a future Elixir version removing these functions.

**Recommendation:** Migrate to the child spec map format (`%{id: ..., start: ..., type: :supervisor}`) and add a test confirming child specs are valid.

---

## File 3 — `lib/api_server/guardian.ex`

### READING EVIDENCE

**Module:** `ApiServer.Guardian`

Uses: `Guardian` (via `use Guardian, otp_app: :api_server`)
Alias: `ApiServer.Vx`

**Functions / macros / callbacks defined:**

| Line | Visibility | Name / Arity | Description |
|------|------------|--------------|-------------|
| 6–13 | public (Guardian callback) | `subject_for_token/2` — clause 1 | Guards `user == nil`; returns `{:error, :reason_for_error}` if nil; otherwise returns `{:ok, to_string(user.aacid)}` |
| 14–16 | public (Guardian callback) | `subject_for_token/2` — clause 2 | Catch-all; returns `{:error, :reason_for_error}` |
| 18–23 | public (Guardian callback) | `resource_from_claims/1` — clause 1 | Extracts `"sub"` and `"customer"` from claims, calls `Vx.get_vx_user!(id, customer)`, returns `{:ok, user}` |
| 24–26 | public (Guardian callback) | `resource_from_claims/1` — clause 2 | Catch-all; returns `{:error, :reason_for_error}` |

**Types / structs / constants:** None.

**Test file:** None (no `test/api_server/guardian_test.exs`).

**Indirect test coverage search:**
- Grep for `ApiServer.Guardian`, `subject_for_token`, `resource_from_claims` in `test/` returns zero matches.
- The existing controller tests (`vx_restriction_controller_test.exs`) do not set a Bearer token, meaning the Guardian pipeline is exercised without authentication — the `LoadResource` plug is invoked but returns `nil` resource. The callbacks themselves (`subject_for_token/2`, `resource_from_claims/1`) are never directly exercised.

### Findings

#### B001-7 — HIGH: `ApiServer.Guardian` has no test file and no indirect test coverage

**Severity:** HIGH
**File:** `lib/api_server/guardian.ex`
**Lines:** 1–27

The Guardian callbacks `subject_for_token/2` and `resource_from_claims/1` are the authentication foundation for the entire API (used in every authenticated controller action). Neither function is exercised by any test in the suite.

**Recommendation:** Create `test/api_server/guardian_test.exs` covering all clauses of both callbacks.

#### B001-8 — MEDIUM: `subject_for_token/2` — nil user path untested

**Severity:** MEDIUM
**File:** `lib/api_server/guardian.ex`
**Lines:** 6–13

```elixir
def subject_for_token(user, _claims) do
  if user == nil do
    {:error, :reason_for_error}
  else
    user_id = to_string(user.aacid)
    {:ok, user_id}
  end
end
```

The nil-user branch (line 7–8) is never tested. A token should not be creatable for a nil user, but there is no assertion verifying this contract.

**Recommendation:** Add a test: `assert {:error, :reason_for_error} = ApiServer.Guardian.subject_for_token(nil, %{})`.

#### B001-9 — MEDIUM: `subject_for_token/2` — catch-all clause 2 untested

**Severity:** MEDIUM
**File:** `lib/api_server/guardian.ex`
**Lines:** 14–16

```elixir
def subject_for_token(_, _) do
  {:error, :reason_for_error}
end
```

The catch-all second clause is never tested. It is unreachable when the first clause already matches all inputs (including nil), making the second clause dead code — a latent defect. No test exposes this.

**Recommendation:** Investigate whether clause 2 is actually reachable. If not, it should be removed; if so, add a test exercising it.

#### B001-10 — MEDIUM: `resource_from_claims/1` — missing `"sub"` key path untested

**Severity:** MEDIUM
**File:** `lib/api_server/guardian.ex`
**Lines:** 18–23**

```elixir
def resource_from_claims(claims) do
  id = claims["sub"]
  customer = claims["customer"]
  user = Vx.get_vx_user!(id, customer)
  {:ok, user}
end
```

If `claims["sub"]` or `claims["customer"]` is `nil` or absent, `Vx.get_vx_user!(nil, ...)` is called. Since `get_vx_user!/2` uses a bang function, it will raise `Ecto.NoResultsError` or similar — an unhandled exception rather than a graceful `{:error, ...}` tuple. No test covers this path.

**Recommendation:** Add tests for claims with missing `"sub"`, missing `"customer"`, and both absent, verifying graceful error handling rather than a raised exception.

#### B001-11 — MEDIUM: `resource_from_claims/1` — catch-all clause 2 untested

**Severity:** MEDIUM
**File:** `lib/api_server/guardian.ex`
**Lines:** 24–26

```elixir
def resource_from_claims(_claims) do
  {:error, :reason_for_error}
end
```

Identical issue to B001-9: the catch-all clause is never tested and is likely unreachable given clause 1 matches all map inputs (including maps with nil values).

**Recommendation:** Same as B001-9 — verify reachability, remove dead code, or add a test.

#### B001-12 — MEDIUM: `resource_from_claims/1` — exception from `Vx.get_vx_user!` is unhandled and untested

**Severity:** MEDIUM
**File:** `lib/api_server/guardian.ex`
**Lines:** 21**

```elixir
user = Vx.get_vx_user!(id, customer)
```

The bang variant raises on not-found. If a JWT is presented with a valid structure but a user ID that no longer exists in the database (deleted user, wrong tenant, etc.), a runtime exception propagates through the Guardian pipeline rather than returning `{:error, :reason_for_error}`. No test exercises this scenario.

**Recommendation:** Add a test that mocks `Vx.get_vx_user!` raising and asserts the error is handled gracefully. Consider using the non-bang `get_vx_user/2` with pattern matching instead.

#### B001-13 — LOW: Error atom `:reason_for_error` is a placeholder

**Severity:** LOW
**File:** `lib/api_server/guardian.ex`
**Lines:** 8, 15, 25

All error returns use the generic atom `:reason_for_error`, which is a Guardian scaffold placeholder. No test verifies that meaningful error atoms are returned, which makes it impossible for callers to distinguish between different failure modes (nil user vs. unknown user vs. missing claims).

**Recommendation:** Replace with specific atoms (e.g., `:user_not_found`, `:missing_claims`, `:invalid_token`) and add tests asserting the specific atoms.

---

## File 4 — `lib/api_server/repo.ex`

### READING EVIDENCE

**Module 1:** `ApiServer.Repo`

Uses: `Ecto.Repo, otp_app: :api_server`

**Functions / macros / callbacks defined:**

| Line | Visibility | Name / Arity | Description |
|------|------------|--------------|-------------|
| 8–10 | public (Ecto callback) | `init/2` | Reads `DATABASE_URL` env var; puts it into opts under `:url`; returns `{:ok, opts}` |

**Module 2:** `ApiServer.FortyNineRepo`

Uses: `Ecto.Repo, otp_app: :api_server`

**Functions / macros / callbacks defined:**
- None explicitly defined. `FortyNineRepo` relies entirely on `Ecto.Repo` defaults with no `init/2` override.

**Types / structs / constants:** None in either module.

**Test file:** None (no `test/api_server/repo_test.exs`).

**Indirect test coverage search:**
- `ApiServer.Repo` is referenced in `test/support/conn_case.ex`, `test/support/data_case.ex`, `test/support/channel_case.ex` only for sandbox checkout — the `init/2` callback itself is never directly tested.
- `ApiServer.FortyNineRepo` is not referenced in any test file.
- `test/test_helper.exs` has the Sandbox mode call commented out (line 3).

### Findings

#### B001-14 — HIGH: `ApiServer.Repo` has no dedicated test file; `init/2` is untested

**Severity:** HIGH
**File:** `lib/api_server/repo.ex`
**Lines:** 1–11

`ApiServer.Repo.init/2` reads `DATABASE_URL` from the environment and injects it into the keyword opts. This callback is critical for database connectivity. No test directly exercises it, meaning the following scenarios are unverified:

- `DATABASE_URL` is set: opts correctly contain `:url`.
- `DATABASE_URL` is unset (`nil`): `Keyword.put(opts, :url, nil)` is called — Ecto may silently ignore this or fall back to other config, but this is untested.

**Recommendation:** Add `test/api_server/repo_test.exs` testing `ApiServer.Repo.init(:runtime, [])` with and without `DATABASE_URL` set.

#### B001-15 — HIGH: `ApiServer.FortyNineRepo` has no test file and no indirect coverage

**Severity:** HIGH
**File:** `lib/api_server/repo.ex`
**Lines:** 13–15

`ApiServer.FortyNineRepo` has no `init/2` override. Its database URL must therefore be configured statically in `config/`. There is no test that checks `FortyNineRepo` connects, is accessible, or is properly configured. It is referenced in TCP command processing (`tcp_commands.ex`) using a schema prefix of `"trackingsolutions"` but is never tested.

**Recommendation:** Add tests (or at minimum a configuration assertion) verifying `FortyNineRepo` is properly configured and reachable in the test environment.

#### B001-16 — MEDIUM: `ApiServer.Repo.init/2` — `DATABASE_URL` nil/missing path untested

**Severity:** MEDIUM
**File:** `lib/api_server/repo.ex`
**Lines:** 8–10

```elixir
def init(_, opts) do
  {:ok, Keyword.put(opts, :url, System.get_env("DATABASE_URL"))}
end
```

`System.get_env("DATABASE_URL")` returns `nil` when the variable is not set. `Keyword.put(opts, :url, nil)` is then called. Ecto's behaviour when `:url` is `nil` depends on whether other connection options (`:hostname`, `:database`, etc.) are present in the config — but this fallback path is untested and could cause silent misconfiguration in production deployments.

**Recommendation:** Add a test that calls `init(:runtime, [])` in an environment where `DATABASE_URL` is unset and asserts the returned opts are handled predictably (either with a fallback or a meaningful error).

#### B001-17 — LOW: Test sandbox mode is commented out in `test_helper.exs`

**Severity:** LOW
**File:** `test/test_helper.exs`
**Line:** 3

```elixir
# Ecto.Adapters.SQL.Sandbox.mode(ApiServer.Repo, :manual)
```

The sandbox is set to `:manual` mode in `conn_case.ex` and `data_case.ex` via `setup` blocks, but the top-level `test_helper.exs` has the initial sandbox mode call commented out. This means the repo sandbox mode is not explicitly set before tests run; it relies on Ecto's default. While this is commonly acceptable, `ApiServer.FortyNineRepo` is never placed into sandbox mode at all, meaning any test that indirectly exercises `FortyNineRepo` writes would not be isolated within a transaction.

**Recommendation:** Ensure `ApiServer.FortyNineRepo` is also placed in sandbox mode (or document why it is excluded). Uncomment or add an explicit sandbox initialisation for both repos in `test_helper.exs`.

---

## Summary Table

| ID | Severity | File | Description |
|----|----------|------|-------------|
| B001-1 | HIGH | `api_server.ex` | Module has no test file and no indirect coverage |
| B001-2 | HIGH | `application.ex` | `ApiServer.Application` has no test file |
| B001-3 | MEDIUM | `application.ex` | `config_change/3` completely untested |
| B001-4 | MEDIUM | `application.ex` | `TCP_PORT` invalid/missing value path untested |
| B001-5 | LOW | `application.ex` | No test for partial supervisor child startup failure |
| B001-6 | LOW | `application.ex` | Deprecated `Supervisor.Spec` import with no regression test |
| B001-7 | HIGH | `guardian.ex` | `ApiServer.Guardian` has no test file and no indirect coverage |
| B001-8 | MEDIUM | `guardian.ex` | `subject_for_token/2` nil-user branch untested |
| B001-9 | MEDIUM | `guardian.ex` | `subject_for_token/2` catch-all clause 2 untested / potentially dead code |
| B001-10 | MEDIUM | `guardian.ex` | `resource_from_claims/1` missing claims keys path untested |
| B001-11 | MEDIUM | `guardian.ex` | `resource_from_claims/1` catch-all clause 2 untested / potentially dead code |
| B001-12 | MEDIUM | `guardian.ex` | Unhandled exception from `Vx.get_vx_user!` in `resource_from_claims/1` |
| B001-13 | LOW | `guardian.ex` | Placeholder `:reason_for_error` atom used in all error returns |
| B001-14 | HIGH | `repo.ex` | `ApiServer.Repo.init/2` untested; no dedicated test file |
| B001-15 | HIGH | `repo.ex` | `ApiServer.FortyNineRepo` has no test file and no indirect coverage |
| B001-16 | MEDIUM | `repo.ex` | `Repo.init/2` nil `DATABASE_URL` path untested |
| B001-17 | LOW | `repo.ex` / `test_helper.exs` | `FortyNineRepo` never placed in sandbox mode; sandbox init commented out |

**Totals:** 5 HIGH, 7 MEDIUM, 4 LOW, 0 CRITICAL, 0 INFO
