# Pass 3 Findings: A90

## File: SelectDriverAdapter.java
**Full path:** `app/src/main/java/au/com/collectiveintelligence/fleetiq360/ui/adapter/SelectDriverAdapter.java`

### Reading Evidence
- Class: `SelectDriverAdapter` extends `AbsRecyclerAdapter<User>` (line 10)
- Public Methods:
  - `SelectDriverAdapter(Context context, int resId, SelectDriverPresenter presenter)` — constructor (line 13)
  - `bindDatas(MyViewHolder holder, User item, int position)` — override of abstract public method from `AbsRecyclerAdapter` (line 19)
- Constants/Types: none defined

### Findings

#### A90-1: Constructor has no Javadoc [INFO]
- File: `SelectDriverAdapter.java`, Line: 13
- Description: The public constructor `SelectDriverAdapter(Context context, int resId, SelectDriverPresenter presenter)` has no Javadoc comment. Parameters `context`, `resId`, and `presenter` are undocumented.

#### A90-2: `bindDatas` override has no Javadoc [INFO]
- File: `SelectDriverAdapter.java`, Line: 19
- Description: The public method `bindDatas(MyViewHolder holder, User item, int position)` has no Javadoc comment. The method binds a `User` object to the view holder by setting the driver's full name on a TextView and loading a photo URL into an ImageView via the presenter, but none of this behaviour is described.

---

## File: SelectForkAdapter.java
**Full path:** `app/src/main/java/au/com/collectiveintelligence/fleetiq360/ui/adapter/SelectForkAdapter.java`

### Reading Evidence
- Class: `SelectForkAdapter` extends `AbsRecyclerAdapter<String>` (line 10)
- Public Methods:
  - `setPresenter(EquipmentSelectForkPresenter presenter)` (line 13)
  - `SelectForkAdapter(Context context, int resId)` — constructor (line 17)
  - `bindDatas(MyViewHolder holder, String data, int position)` — override of abstract public method from `AbsRecyclerAdapter` (line 22)
- Constants/Types: none defined

### Findings

#### A90-3: `setPresenter` has no Javadoc [INFO]
- File: `SelectForkAdapter.java`, Line: 13
- Description: The public method `setPresenter(EquipmentSelectForkPresenter presenter)` has no Javadoc comment. The method is the only way to inject the presenter after construction (the constructor does not accept a presenter), which is a noteworthy design detail that warrants documentation. Callers need to know to call this before the adapter is attached, or that a null presenter is tolerated (guarded at line 26).

#### A90-4: Constructor has no Javadoc [INFO]
- File: `SelectForkAdapter.java`, Line: 17
- Description: The public constructor `SelectForkAdapter(Context context, int resId)` has no Javadoc comment.

#### A90-5: `bindDatas` override has no Javadoc [INFO]
- File: `SelectForkAdapter.java`, Line: 22
- Description: The public method `bindDatas(MyViewHolder holder, String data, int position)` has no Javadoc comment. The method sets a fork name string on a TextView and conditionally loads an image URL from the presenter's `urlList` if the presenter is non-null and the position is within bounds. The conditional null/bounds guard is notable behaviour that would benefit from documentation.

---

## File: MyApplication.java
**Full path:** `app/src/main/java/au/com/collectiveintelligence/fleetiq360/ui/application/MyApplication.java`

### Reading Evidence
- Class: `MyApplication` extends `MultiDexApplication` (line 39)
- Public Methods (declared in this class):
  - `onCreate()` — lifecycle override (line 49)
  - `getHandler()` — static (line 112)
  - `runOnMainThread(final Runnable runnable)` — static (line 116)
  - `runLater(final Runnable runnable, int time)` — static (line 122)
  - `startLocationUpdate()` — static (line 140)
  - `getGPSProviderStatus()` — static (line 190)
  - `sendLocationUpdate()` — static (line 195)
  - `getContext()` — static (line 213)
- Constants/Types:
  - `context` — static `Context` field (line 41), package-private `Runnable runnable` field (line 45)
  - `locationService` — static `ScheduledExecutorService` (line 46), currently unused in active code paths (all scheduling code is commented out)
  - `GPSParam` — static `SaveSingleGPSParameter` (line 43)
  - `mHandler` — static `Handler` (line 42)
  - `networkConnected` — instance `boolean` (line 75)

### Findings

#### A90-6: `onCreate` has no Javadoc [INFO]
- File: `MyApplication.java`, Line: 49
- Description: The public `onCreate()` override has no Javadoc. It performs significant initialisation: Realm database setup, Handler creation, `WebApi` init, BLE controller init, image loader init, GPS location provider init, initial network state detection, and network broadcast receiver registration. The absence of documentation makes it difficult to understand the full startup sequence.

#### A90-7: `getHandler` has no Javadoc [INFO]
- File: `MyApplication.java`, Line: 112
- Description: The public static method `getHandler()` has no Javadoc comment. Returns the application-level main-thread `Handler`.

#### A90-8: `runOnMainThread` has no Javadoc [INFO]
- File: `MyApplication.java`, Line: 116
- Description: The public static method `runOnMainThread(Runnable runnable)` has no Javadoc comment. The method silently no-ops if `mHandler` is null or `runnable` is null; this null-tolerance is undocumented.

#### A90-9: `runLater` has no Javadoc [INFO]
- File: `MyApplication.java`, Line: 122
- Description: The public static method `runLater(Runnable runnable, int time)` has no Javadoc comment. The `time` parameter is in milliseconds (passed to `Handler.postDelayed`), which is not stated anywhere. The null guard behaviour is also undocumented.

#### A90-10: `startLocationUpdate` has no Javadoc and has misleading commented-out code [INFO]
- File: `MyApplication.java`, Lines: 140–163
- Description: The public static method `startLocationUpdate()` has no Javadoc comment. The method body contains a large block of commented-out code (lines 144–162) that describes a substantially different, more complete implementation involving a `ScheduledExecutorService` and configurable GPS frequency from `CurrentUser`. The active implementation unconditionally calls `LocationProvider.instance().beginUpdates()` if GPS is enabled, with no scheduling. The commented-out code references fields (`locationService`, the instance `runnable` field) that are now dead. The gap between the active code and the commented-out code could mislead maintainers into believing the scheduled upload behaviour is still in effect.

#### A90-11: `getGPSProviderStatus` has no Javadoc [INFO]
- File: `MyApplication.java`, Line: 190
- Description: The public static method `getGPSProviderStatus()` has no Javadoc comment. Returns `true` if the device's location provider is enabled, delegating to `LocationProvider.instance().hasLocationEnabled()`.

#### A90-12: `sendLocationUpdate` has no Javadoc and has misleading commented-out code [INFO]
- File: `MyApplication.java`, Lines: 195–210
- Description: The public static method `sendLocationUpdate()` has no Javadoc comment. The method name implies sending a location update to the server, which the active code does (`SaveUnitLocation()` is called if GPS is enabled). However, the commented-out block (lines 199–209) describes a shutdown of the `locationService` executor and ending GPS updates — logic that no longer runs. The method name `sendLocationUpdate` may mislead callers who expect it to also stop location tracking.

#### A90-13: `getContext` has no Javadoc [INFO]
- File: `MyApplication.java`, Line: 213
- Description: The public static method `getContext()` has no Javadoc comment. Returns the static application `Context`. Callers should be aware this returns an application context (not an Activity context), which is relevant for UI operations, but this is not documented.

#### A90-14: Dead field `locationService` is undocumented and unused [INFO]
- File: `MyApplication.java`, Line: 46
- Description: The static field `locationService` of type `ScheduledExecutorService` is declared but never initialised or used in any active code path — all references to it are inside commented-out blocks. The field `runnable` at line 45 is similarly declared but never assigned in active code. No comment explains that these fields are remnants of a deprecated scheduling strategy. This creates confusion about whether the GPS scheduling feature is partially implemented or intentionally disabled.
