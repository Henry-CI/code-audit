# Pass 3 Findings: A23

## File: LimitedMemoryCache.java
**Full path:** `LibImageloader/src/main/java/com/nostra13/universalimageloader/cache/memory/LimitedMemoryCache.java`

### Reading Evidence
- Class: `public abstract class LimitedMemoryCache extends BaseMemoryCache`
- Public Methods:
  - `LimitedMemoryCache(int sizeLimit)` (line 55) — constructor
  - `put(String key, Bitmap value)` (line 64) — `@Override`
  - `remove(String key)` (line 88) — `@Override`
  - `clear()` (line 99) — `@Override`
- Protected Methods (not public, included for completeness):
  - `getSizeLimit()` (line 105)
  - `getSize(Bitmap value)` (line 109) — abstract
  - `removeNext()` (line 111) — abstract
- Constants:
  - `MAX_NORMAL_CACHE_SIZE_IN_MB` = 16 (line 40) — `private static final int`
  - `MAX_NORMAL_CACHE_SIZE` = 16 * 1024 * 1024 bytes (line 41) — `private static final int`

### Findings

#### A23-1: `put` override has no Javadoc and its eviction behaviour is not documented [INFO]
- File: `LimitedMemoryCache.java`, Line: 64
- Description: The `put(String key, Bitmap value)` method overrides `MemoryCache.put` but carries no Javadoc of its own. The behaviour diverges meaningfully from what the interface comment implies: when `valueSize >= sizeLimit` the method returns `false` (indicating failure to cache), yet it still calls `super.put(key, value)` at line 83, which adds the bitmap to the soft (weak-reference) map in `BaseMemoryCache`. A caller reading only the interface doc would not know that a `false` return does not mean the item was completely rejected — it will still be weakly cached and retrievable until GC collects it. This nuance warrants at minimum an `{@inheritDoc}` override comment noting the dual-cache behaviour.

#### A23-2: `remove` override has no Javadoc [INFO]
- File: `LimitedMemoryCache.java`, Line: 88
- Description: `remove(String key)` carries no Javadoc. The method performs two distinct operations beyond a simple removal: it first calls `super.get(key)` to retrieve the bitmap from the soft map so it can be removed from `hardCache` and the size counter adjusted, then calls `super.remove(key)`. This implementation detail — that the hard-cache accounting is adjusted on removal — is not documented anywhere on the overriding method.

#### A23-3: `clear` override has no Javadoc [INFO]
- File: `LimitedMemoryCache.java`, Line: 99
- Description: `clear()` has no Javadoc. The method resets the `hardCache` list and the `cacheSize` atomic counter in addition to delegating to `super.clear()`. While the intent is obvious, the side-effect of resetting `cacheSize` to zero is a detail that a subclass author may need to be aware of, and it is entirely undocumented.

---

## File: MemoryCache.java
**Full path:** `LibImageloader/src/main/java/com/nostra13/universalimageloader/cache/memory/MemoryCache.java`

### Reading Evidence
- Class: `public interface MemoryCache`
- Public Methods:
  - `put(String key, Bitmap value)` (line 35)
  - `get(String key)` (line 38)
  - `remove(String key)` (line 41)
  - `keys()` (line 44)
  - `clear()` (line 47)
- Constants/Types: none

### Findings

#### A23-4: `remove` Javadoc omits the return value [LOW]
- File: `MemoryCache.java`, Line: 41
- Description: The Javadoc for `remove(String key)` reads only "Removes item by key". The method signature returns `Bitmap`, not `void`. The removed bitmap (or `null` if the key was absent) is returned to the caller, but the Javadoc contains no `@return` tag and no prose describing this. A caller relying solely on the documentation would not know they can capture and use the returned value, which is a material omission for an interface that forms the public API contract.

---

## File: FIFOLimitedMemoryCache.java
**Full path:** `LibImageloader/src/main/java/com/nostra13/universalimageloader/cache/memory/impl/FIFOLimitedMemoryCache.java`

### Reading Evidence
- Class: `public class FIFOLimitedMemoryCache extends LimitedMemoryCache`
- Public Methods:
  - `FIFOLimitedMemoryCache(int sizeLimit)` (line 41) — constructor
  - `put(String key, Bitmap value)` (line 46) — `@Override`
  - `remove(String key)` (line 56) — `@Override`
  - `clear()` (line 65) — `@Override`
- Protected Methods (not public, included for completeness):
  - `getSize(Bitmap value)` (line 71) — `@Override`
  - `removeNext()` (line 76) — `@Override`
  - `createReference(Bitmap value)` (line 81) — `@Override`
- Constants/Types: none (uses inherited constants from `LimitedMemoryCache`)

### Findings

#### A23-5: Constructor has no Javadoc [INFO]
- File: `FIFOLimitedMemoryCache.java`, Line: 41
- Description: The public constructor `FIFOLimitedMemoryCache(int sizeLimit)` has no Javadoc. The parent class constructor (`LimitedMemoryCache`) documents its `sizeLimit` parameter as "Maximum size for cache (in bytes)", but that documentation is not inherited by this constructor and no equivalent comment appears here. Users instantiating this concrete class directly have no inline documentation describing the unit or expected range of `sizeLimit`.

#### A23-6: `put` override has no Javadoc [INFO]
- File: `FIFOLimitedMemoryCache.java`, Line: 46
- Description: The `put` override manages the FIFO `queue` list in addition to delegating to `super.put`. Adding the value to the internal `queue` on success is the mechanism that enables the FIFO eviction policy, but this is not documented. A developer subclassing or maintaining this class has no documentation explaining why the `queue` is populated here.

#### A23-7: `remove` override has no Javadoc [INFO]
- File: `FIFOLimitedMemoryCache.java`, Line: 56
- Description: The `remove` override additionally removes the bitmap from the FIFO `queue` before delegating to `super.remove`. This queue maintenance step is undocumented. A developer reviewing this code must trace the logic manually to understand why `super.get(key)` is called before `super.remove(key)` — the intent being to retrieve the bitmap object reference needed to remove it from the queue by value.

#### A23-8: `clear` override has no Javadoc [INFO]
- File: `FIFOLimitedMemoryCache.java`, Line: 65
- Description: `clear()` clears the FIFO `queue` before delegating to `super.clear()`. No documentation describes this ordering or the fact that the local `queue` state is reset as part of the clear operation.
