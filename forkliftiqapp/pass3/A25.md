# Pass 3 Findings: A25

## File: LimitedAgeMemoryCache.java
**Full path:** `LibImageloader/src/main/java/com/nostra13/universalimageloader/cache/memory/impl/LimitedAgeMemoryCache.java`

### Reading Evidence
- Class: `LimitedAgeMemoryCache` (implements `MemoryCache`)
- Public Methods:
  - `LimitedAgeMemoryCache(MemoryCache cache, long maxAge)` (line 47) — constructor
  - `put(String key, Bitmap value)` (line 53)
  - `get(String key)` (line 62)
  - `remove(String key)` (line 73)
  - `keys()` (line 79)
  - `clear()` (line 84)
- Constants/Types: none (fields: `cache`, `maxAge`, `loadingDates` — all private/package)

### Findings

#### A25-1: `put` has no Javadoc [INFO]
- File: `LimitedAgeMemoryCache.java`, Line: 53
- Description: The public override `put(String key, Bitmap value)` has no Javadoc comment. The method records a timestamp in `loadingDates` when a put succeeds, which is behaviorally significant beyond the base `MemoryCache` contract. A brief doc noting this side-effect would aid maintainers.

#### A25-2: `get` has no Javadoc [INFO]
- File: `LimitedAgeMemoryCache.java`, Line: 62
- Description: The public override `get(String key)` has no Javadoc comment. The method contains non-trivial behaviour: it checks whether the entry has exceeded `maxAge` and, if so, removes it from both the delegate cache and `loadingDates` before delegating the get. This eviction-on-access behaviour is not documented anywhere on the method itself.

#### A25-3: `remove` has no Javadoc [INFO]
- File: `LimitedAgeMemoryCache.java`, Line: 73
- Description: The public override `remove(String key)` has no Javadoc comment. It removes the key from `loadingDates` in addition to delegating to the wrapped cache; this coordinated cleanup is undocumented.

#### A25-4: `keys` has no Javadoc [INFO]
- File: `LimitedAgeMemoryCache.java`, Line: 79
- Description: The public override `keys()` has no Javadoc comment.

#### A25-5: `clear` has no Javadoc [INFO]
- File: `LimitedAgeMemoryCache.java`, Line: 84
- Description: The public override `clear()` has no Javadoc comment. The method clears both the delegate cache and the internal `loadingDates` map; the dual-clear is undocumented.

---

## File: LruMemoryCache.java
**Full path:** `LibImageloader/src/main/java/com/nostra13/universalimageloader/cache/memory/impl/LruMemoryCache.java`

### Reading Evidence
- Class: `LruMemoryCache` (implements `MemoryCache`)
- Public Methods:
  - `LruMemoryCache(int maxSize)` (line 31) — constructor
  - `get(String key)` (line 44)
  - `put(String key, Bitmap value)` (line 56)
  - `remove(String key)` (line 105)
  - `keys()` (line 120)
  - `clear()` (line 127)
  - `toString()` (line 141)
- Constants/Types: none (fields: `map` LinkedHashMap, `maxSize` int, `size` int — all private)
- Note: This file has no Apache License / copyright header, unlike the other two files in the same package.

### Findings

#### A25-6: Missing copyright/license header [LOW]
- File: `LruMemoryCache.java`, Line: 1
- Description: `LruMemoryCache.java` has no copyright or license header. Every other file examined in this package (e.g., `LimitedAgeMemoryCache.java`, `UsingFreqLimitedMemoryCache.java`) carries the Apache 2.0 copyright block attributed to Sergey Tarasevich 2011-2014. The absence is inconsistent and may create licensing ambiguity for downstream consumers of the library.

#### A25-7: Class-level Javadoc uses ambiguous "head/end of queue" terminology inconsistent with `LinkedHashMap` access-order semantics [LOW]
- File: `LruMemoryCache.java`, Lines: 12-21
- Description: The class Javadoc states "Each time a Bitmap is accessed, it is moved to the head of a queue" and "the Bitmap at the end of that queue is evicted." Internally the cache uses `LinkedHashMap` with `accessOrder=true` (line 36). In a `LinkedHashMap` with access order, the most-recently-used entry is positioned at the **tail** of the internal linked list; the iterator yields entries from **eldest (least-recently-used)** to newest. The private `trimToSize` method evicts via `map.entrySet().iterator().next()`, which is the eldest (LRU) entry — consistent with LRU semantics. The doc's use of "head" and "end" is inverted relative to the internal data structure's orientation, which can mislead a developer reasoning about the implementation. While the described behaviour (LRU eviction) is correct at an abstract level, the directional language contradicts the implementation detail and could cause confusion.

#### A25-8: Constructor Javadoc omits units for `maxSize` [INFO]
- File: `LruMemoryCache.java`, Line: 30
- Description: The constructor Javadoc states "Maximum sum of the sizes of the Bitmaps in this cache" but does not mention that the unit is **bytes** (consistent with `sizeOf` returning `value.getRowBytes() * value.getHeight()`). Callers must infer the unit from context.

#### A25-9: `put` Javadoc does not document `NullPointerException` thrown for null arguments [INFO]
- File: `LruMemoryCache.java`, Line: 54
- Description: The Javadoc for `put` ("Caches {@code Bitmap} for {@code key}. The Bitmap is moved to the head of the queue.") does not document that the method throws `NullPointerException` when either `key` or `value` is null (line 57-59). The `get` and `remove` methods similarly throw on null key but their existing Javadoc also omits this. The omission for `put` is noted here as the method signature accepts two parameters both of which are guarded.

#### A25-10: `keys` has no Javadoc [INFO]
- File: `LruMemoryCache.java`, Line: 120
- Description: The public override `keys()` has no Javadoc comment. Notably the implementation returns a snapshot (`new HashSet`) rather than a live view of the key set; this is a non-obvious contract detail that is undocumented.

#### A25-11: `clear` has no Javadoc [INFO]
- File: `LruMemoryCache.java`, Line: 127
- Description: The public override `clear()` has no Javadoc comment.

#### A25-12: `toString` has no Javadoc [INFO]
- File: `LruMemoryCache.java`, Line: 141
- Description: The public override `toString()` has no Javadoc comment.

---

## File: UsingFreqLimitedMemoryCache.java
**Full path:** `LibImageloader/src/main/java/com/nostra13/universalimageloader/cache/memory/impl/UsingFreqLimitedMemoryCache.java`

### Reading Evidence
- Class: `UsingFreqLimitedMemoryCache` (extends `LimitedMemoryCache`)
- Public Methods:
  - `UsingFreqLimitedMemoryCache(int sizeLimit)` (line 48) — constructor
  - `put(String key, Bitmap value)` (line 53)
  - `get(String key)` (line 63)
  - `remove(String key)` (line 76)
  - `clear()` (line 85)
- Protected Methods (overrides, part of public API surface via superclass):
  - `getSize(Bitmap value)` (line 91)
  - `removeNext()` (line 96)
  - `createReference(Bitmap value)` (line 119)
- Constants/Types: none (field: `usingCounts` Map<Bitmap, Integer> — private)

### Findings

#### A25-13: Field comment on `usingCounts` describes wrong value semantics — says "usage date" instead of "usage count" [MEDIUM]
- File: `UsingFreqLimitedMemoryCache.java`, Lines: 41-45
- Description: The Javadoc comment on the `usingCounts` field reads: "Contains strong references to stored objects (keys) and **last object usage date (in milliseconds)**." The actual map type is `Map<Bitmap, Integer>` where the `Integer` value is a **usage frequency count** (initialized to `0` on `put`, incremented by `1` on each `get`). It is not a date or timestamp in any unit. This is a direct factual inaccuracy: the described semantics ("date in milliseconds") belong to a different eviction strategy (LRU/LimitedAge), not the frequency-based strategy implemented here. A developer relying on this comment to understand eviction logic would be materially misled about how the least-frequently-used entry is selected.

#### A25-14: Constructor `UsingFreqLimitedMemoryCache(int sizeLimit)` has no Javadoc [INFO]
- File: `UsingFreqLimitedMemoryCache.java`, Line: 48
- Description: The public constructor has no Javadoc comment. The parameter `sizeLimit` meaning (total byte limit for strong references) is not explained.

#### A25-15: `put` has no Javadoc [INFO]
- File: `UsingFreqLimitedMemoryCache.java`, Line: 53
- Description: The public override `put(String key, Bitmap value)` has no Javadoc. The method initialises the usage count to `0` in `usingCounts` on a successful put, which is a side-effect beyond the base contract.

#### A25-16: `get` has no Javadoc [INFO]
- File: `UsingFreqLimitedMemoryCache.java`, Line: 63
- Description: The public override `get(String key)` has no Javadoc. The method increments the usage count for the returned bitmap when it is present in the hard cache (`usingCounts`), which is the core frequency-tracking mechanism — entirely undocumented at the method level.

#### A25-17: `remove` has no Javadoc [INFO]
- File: `UsingFreqLimitedMemoryCache.java`, Line: 76
- Description: The public override `remove(String key)` has no Javadoc. The method removes the bitmap's usage count entry from `usingCounts` in addition to delegating removal to the superclass.

#### A25-18: `clear` has no Javadoc [INFO]
- File: `UsingFreqLimitedMemoryCache.java`, Line: 85
- Description: The public override `clear()` has no Javadoc.

#### A25-19: Inline comment typo "hardCahe" [INFO]
- File: `UsingFreqLimitedMemoryCache.java`, Line: 65
- Description: The inline comment reads "// Increment usage count for value if value is contained in hardCahe" — "hardCahe" is a misspelling of "hardCache". Minor but present.
