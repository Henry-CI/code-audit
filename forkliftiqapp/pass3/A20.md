# Pass 3 Findings: A20

## File: UnlimitedDiskCache.java
**Full path:** `LibImageloader/src/main/java/com/nostra13/universalimageloader/cache/disc/impl/UnlimitedDiskCache.java`

### Reading Evidence
- **Class:** `UnlimitedDiskCache extends BaseDiskCache` (public)
- **Public Methods:**
  - `UnlimitedDiskCache(File cacheDir)` - constructor (line 31)
  - `UnlimitedDiskCache(File cacheDir, File reserveCacheDir)` - constructor (line 39)
  - `UnlimitedDiskCache(File cacheDir, File reserveCacheDir, FileNameGenerator fileNameGenerator)` - constructor (line 49)
- **Constants/Types:** None defined in this file (all inherited from `BaseDiskCache`)

### Findings

No findings. All three public constructors have accurate `@param` Javadoc. The class-level Javadoc accurately describes the class as an unlimited disk cache implementation.

---

## File: DiskLruCache.java
**Full path:** `LibImageloader/src/main/java/com/nostra13/universalimageloader/cache/disc/impl/ext/DiskLruCache.java`

### Reading Evidence
- **Class:** `final class DiskLruCache implements Closeable` (package-private)
- **Constants (package/static):**
  - `JOURNAL_FILE = "journal"` (line 88)
  - `JOURNAL_FILE_TEMP = "journal.tmp"` (line 89)
  - `JOURNAL_FILE_BACKUP = "journal.bkp"` (line 90)
  - `MAGIC = "libcore.io.DiskLruCache"` (line 91)
  - `VERSION_1 = "1"` (line 92)
  - `ANY_SEQUENCE_NUMBER = -1` (line 93)
  - `LEGAL_KEY_PATTERN` (line 94)
  - `CLEAN`, `DIRTY`, `REMOVE`, `READ` (lines 95-98, private)
- **Public Methods on `DiskLruCache`:**
  - `open(File, int, int, long, int)` - static factory (line 203)
  - `get(String key)` (line 412)
  - `edit(String key)` (line 461)
  - `getDirectory()` (line 490)
  - `getMaxSize()` (line 498)
  - `getMaxFileCount()` (line 503)
  - `setMaxSize(long)` (line 511)
  - `size()` (line 521)
  - `fileCount()` (line 530)
  - `remove(String key)` (line 606)
  - `isClosed()` (line 636)
  - `flush()` (line 647)
  - `close()` (line 655)
  - `delete()` (line 689)
- **Public Methods on nested public class `Snapshot`:**
  - `edit()` (line 726)
  - `getFile(int index)` (line 731)
  - `getInputStream(int index)` (line 735)
  - `getString(int index)` (line 741)
  - `getLength(int index)` (line 746)
  - `close()` (line 750)
- **Public Methods on nested public class `Editor`:**
  - `newInputStream(int index)` (line 780)
  - `getString(int index)` (line 800)
  - `newOutputStream(int index)` (line 812)
  - `set(int index, String value)` (line 839)
  - `commit()` (line 853)
  - `abort()` (line 867)
  - `abortUnlessCommitted()` (line 871)

### Findings

#### A20-1: Missing `@param appVersion` in `open()` Javadoc [LOW]
- **File:** `DiskLruCache.java`, Line: 193-202
- **Description:** The Javadoc for `open(File directory, int appVersion, int valueCount, long maxSize, int maxFileCount)` documents four of the five parameters (`directory`, `valueCount`, `maxSize`, `maxFileCount`) but omits `appVersion` entirely. The `appVersion` parameter is used during journal validation to detect cache invalidation across application version changes, making it important for callers to understand. Its absence from the Javadoc leaves the caller with no documented guidance on its meaning or expected values.

#### A20-2: Grammar error in `get()` Javadoc obscures meaning [LOW]
- **File:** `DiskLruCache.java`, Line: 407-411
- **Description:** The Javadoc for `get(String key)` reads: "Returns a snapshot of the entry named {@code key}, or null if it doesn't exist is not currently readable." The phrase "doesn't exist is not currently readable" is missing the conjunction "or" between the two null-return conditions. It should read "doesn't exist **or** is not currently readable." As written, the sentence is grammatically broken and may confuse a reader into thinking only one condition (non-existence) causes a null return, when in fact an entry that exists but is not yet readable (has no committed edit) also returns null.

#### A20-3: `fileCount()` return type declared as `long` but backing field is `int` - doc does not mention this mismatch [INFO]
- **File:** `DiskLruCache.java`, Line: 526-532
- **Description:** The method `fileCount()` is documented as "Returns the number of files currently being used to store the values in this cache." The backing field `fileCount` is declared as `int` (line 149), but the method return type is `long`. The widening from `int` to `long` is silent and causes no runtime error, but the Javadoc makes no mention of the type discrepancy and provides no indication of the upper bound. This is a minor doc gap that could mislead a caller who inspects the return type expecting a truly large value range.

#### A20-4: `Snapshot.close()` has no Javadoc [INFO]
- **File:** `DiskLruCache.java`, Line: 750
- **Description:** The `close()` method on the public nested class `Snapshot` has no Javadoc comment. Although it implements `Closeable`, callers should be informed of what resources are released (the underlying `InputStream` array opened for the snapshot). Without documentation, it is unclear whether callers must call `close()` and what happens to open streams if they do not.

#### A20-5: `Editor.abortUnlessCommitted()` has no Javadoc [INFO]
- **File:** `DiskLruCache.java`, Line: 871
- **Description:** The public method `abortUnlessCommitted()` on the `Editor` nested class has no Javadoc at all. Its behavior - aborting the edit only if `commit()` has not already been called, and silently swallowing the resulting `IOException` - is non-obvious and important for correct usage in finally-blocks. The absence of any documentation leaves callers without guidance on this method's intended use pattern or its error-suppression behavior.

---

## File: LruDiskCache.java
**Full path:** `LibImageloader/src/main/java/com/nostra13/universalimageloader/cache/disc/impl/ext/LruDiskCache.java`

### Reading Evidence
- **Class:** `LruDiskCache implements DiskCache` (public)
- **Public Constants:**
  - `DEFAULT_BUFFER_SIZE = 32 * 1024` (line 41)
  - `DEFAULT_COMPRESS_FORMAT = Bitmap.CompressFormat.PNG` (line 43)
  - `DEFAULT_COMPRESS_QUALITY = 100` (line 45)
- **Protected Fields:**
  - `cache` (DiskLruCache, line 50)
  - `fileNameGenerator` (FileNameGenerator, line 53)
  - `bufferSize` (int, line 55)
  - `compressFormat` (Bitmap.CompressFormat, line 57)
  - `compressQuality` (int, line 58)
- **Public Methods:**
  - `LruDiskCache(File, FileNameGenerator, long)` - constructor (line 68)
  - `LruDiskCache(File, File, FileNameGenerator, long, int)` - constructor (line 82)
  - `getDirectory()` (line 125, @Override)
  - `get(String imageUri)` (line 130, @Override)
  - `save(String imageUri, InputStream imageStream, IoUtils.CopyListener listener)` (line 146, @Override)
  - `save(String imageUri, Bitmap bitmap)` (line 168, @Override)
  - `remove(String imageUri)` (line 190, @Override)
  - `close()` (line 200, @Override)
  - `clear()` (line 210, @Override)
  - `setBufferSize(int bufferSize)` (line 227)
  - `setCompressFormat(Bitmap.CompressFormat compressFormat)` (line 231)
  - `setCompressQuality(int compressQuality)` (line 235)

### Findings

#### A20-6: Malformed `{@value}` Javadoc tags on public constants [LOW]
- **File:** `LruDiskCache.java`, Lines: 40, 42, 44
- **Description:** The three public constants `DEFAULT_BUFFER_SIZE`, `DEFAULT_COMPRESS_FORMAT`, and `DEFAULT_COMPRESS_QUALITY` are each documented with `/** {@value */`. The `{@value}` inline tag is not properly closed - it requires a closing `}` before `*/`, forming `/** {@value} */`. As written, `/** {@value */` is syntactically malformed: the `*/` terminates the comment before the inline tag is closed, which causes Javadoc tooling to either ignore the tag or produce garbled output. The intent is clearly to render the field's literal value in the generated documentation, but this intent is never realized due to the syntax error. All three constant descriptions will appear blank or broken in published API docs.

#### A20-7: `setBufferSize()`, `setCompressFormat()`, and `setCompressQuality()` have no Javadoc [INFO]
- **File:** `LruDiskCache.java`, Lines: 227, 231, 235
- **Description:** The three public setter methods `setBufferSize(int)`, `setCompressFormat(Bitmap.CompressFormat)`, and `setCompressQuality(int)` have no Javadoc comments. While their names suggest purpose, there is no documentation of:
  - Valid value ranges (e.g., whether `bufferSize <= 0` is legal, what quality values 0-100 represent)
  - The effect of calling these setters after the cache is already in use
  - Whether changes take effect immediately or only on the next `save()` call
  The absence of documentation for these configuration entry-points is a gap for API consumers.

#### A20-8: `clear()` calls methods on `cache` after `cache.delete()` which internally calls `close()` - not documented [INFO]
- **File:** `LruDiskCache.java`, Lines: 210-221
- **Description:** The `clear()` method calls `cache.delete()` (line 213), which internally invokes `DiskLruCache.close()`, leaving the underlying `DiskLruCache` in a closed state. The subsequent call on line 217 - `initCache(cache.getDirectory(), reserveCacheDir, cache.getMaxSize(), cache.getMaxFileCount())` - retrieves values from the now-closed (but not null) `DiskLruCache` instance before reinitializing. While this works because `getDirectory()`, `getMaxSize()`, and `getMaxFileCount()` are simple field accessors that do not check the closed state, the pattern is fragile and undocumented. There is no Javadoc on `clear()` to explain this re-initialization behavior, nor any mention that the cache is fully deleted and rebuilt. A caller relying on `clear()` for behavior similar to "evict all entries" would not know the entire cache (including the journal) is deleted and recreated.
