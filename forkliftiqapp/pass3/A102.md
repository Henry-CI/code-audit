# Pass 3 Findings: A102

## File: CommonFunc.java
**Full path:** `app/src/main/java/au/com/collectiveintelligence/fleetiq360/util/CommonFunc.java`

### Reading Evidence
- Class: `CommonFunc` (public, no-instance-creation implied by all-static methods; no private constructor)
- Public Methods:
  - `isCurrentDay(DateTime dateTime)` (line 16)
  - `convertUTCDatetoLocalDate(Date utcDate)` (line 44)
  - `SHA1(String text)` (line 50)
  - `MD5_Hash(String s)` (line 68)
  - `isEmailInvalid(String email)` (line 85)
  - `isPasswordValid(String password)` (line 92)
- Private Methods (for completeness):
  - `isSameLocalDay(DateTime, DateTime)` (line 21)
  - `dateToLocalDayString(DateTime)` (line 32)
  - `getCurrentDateTimeZone()` (line 39)
- Constants/Types: None defined

### Findings

#### A102-1: `isCurrentDay` has no Javadoc [INFO]
- File: `CommonFunc.java`, Line: 16
- Description: The public method `isCurrentDay(DateTime dateTime)` has no Javadoc comment. There is no documentation of its parameter, return value, or the fact that comparison is performed in the device's local timezone.

#### A102-2: `convertUTCDatetoLocalDate` has no Javadoc [INFO]
- File: `CommonFunc.java`, Line: 44
- Description: The public method `convertUTCDatetoLocalDate(Date utcDate)` has no Javadoc comment. There is no documentation of its parameter, return value, or behavior.

#### A102-3: `convertUTCDatetoLocalDate` method name is misleading relative to implementation [MEDIUM]
- File: `CommonFunc.java`, Line: 44
- Description: The method is named `convertUTCDatetoLocalDate`, implying the input is a UTC `Date`. However, the implementation wraps the input in a `DateTime`, shifts it to the device's local timezone, then calls `toLocalDateTime().toDate()`. The `java.util.Date` returned by `toLocalDateTime().toDate()` is a wall-clock local time stored as a UTC epoch value — this is a well-known Joda-Time quirk. The method has no documentation at all, so callers have no warning that: (a) the input is assumed to be UTC, (b) the returned `Date` object's epoch milliseconds will not match the original UTC instant, and (c) the result may behave unexpectedly if passed to any API that treats `Date` as an absolute instant. The absence of documentation amplifies the risk of misuse.

#### A102-4: `SHA1` has no Javadoc [INFO]
- File: `CommonFunc.java`, Line: 50
- Description: The public method `SHA1(String text)` has no Javadoc comment. There is no documentation of parameter, return value, or error behavior.

#### A102-5: `SHA1` pads output to 32 characters, not the correct 40 for SHA-1 [MEDIUM]
- File: `CommonFunc.java`, Line: 62
- Description: The SHA-1 algorithm produces a 160-bit digest, which encodes to exactly 40 hexadecimal characters. The implementation zero-pads the hex string only up to 32 characters (`while (hash.length() < 32)`). For any digest whose leading bytes are all zero, the output will be shorter than 40 hex characters but padded only to 32. In practice, the hexadecimal representation of a SHA-1 digest will never be shorter than 32 characters for non-pathological inputs, but the constant `32` is semantically wrong (it is borrowed from the MD5 implementation below) and could produce incorrect output for inputs with many leading zero bytes in the digest. There is no documentation to warn callers of this anomaly or of the return value format.

#### A102-6: `SHA1` uses `text.length()` (char count) as byte length in `md.update` [LOW]
- File: `CommonFunc.java`, Line: 59
- Description: The call `md.update(text.getBytes(), 0, text.length())` passes `text.length()` (the number of UTF-16 `char` code units) as the `len` argument. `text.getBytes()` without a charset uses the platform default encoding; for non-ASCII characters the byte array length will exceed `text.length()`, causing trailing bytes to be silently truncated from the digest input. This is a silent correctness defect for any non-ASCII password or identifier. No documentation warns callers of this limitation.

#### A102-7: `SHA1` returns empty string on `NoSuchAlgorithmException` with no documentation [LOW]
- File: `CommonFunc.java`, Line: 54-57
- Description: On `NoSuchAlgorithmException` the method prints a stack trace and returns `""`. Callers have no documented contract for this error path. An empty string returned as a hash could be used silently in authentication or data-integrity contexts, leading to security or correctness issues.

#### A102-8: `MD5_Hash` has no Javadoc [INFO]
- File: `CommonFunc.java`, Line: 68
- Description: The public method `MD5_Hash(String s)` has no Javadoc comment. There is no documentation of its parameter, return value, or error behavior.

#### A102-9: `MD5_Hash` uses `s.length()` (char count) as byte length in `m.update`, same defect as SHA1 [LOW]
- File: `CommonFunc.java`, Line: 77
- Description: Same issue as A102-6 but in `MD5_Hash`: `m.update(s.getBytes(), 0, s.length())` will silently truncate bytes for non-ASCII input. No documentation warns callers.

#### A102-10: `MD5_Hash` will throw `NullPointerException` if `MessageDigest.getInstance` returns null (impossible by spec but `Objects.requireNonNull` wraps a field that was set in the catch block) [LOW]
- File: `CommonFunc.java`, Line: 77
- Description: `m` is initialised to `null` and assigned inside a `try` block. If `NoSuchAlgorithmException` is thrown, `m` remains `null` and `Objects.requireNonNull(m)` throws `NullPointerException` (unlike the `SHA1` method which returns early). The inconsistent error handling between `SHA1` and `MD5_Hash` is undocumented, leaving callers unaware that `MD5_Hash` can throw an unchecked exception while `SHA1` returns silently.

#### A102-11: `isEmailInvalid` has no Javadoc [INFO]
- File: `CommonFunc.java`, Line: 85
- Description: The public method `isEmailInvalid(String email)` has no Javadoc comment. There is no documentation of its parameter, return value, or the fact that a `null` input returns `true` (treated as invalid).

#### A102-12: `isPasswordValid` has no Javadoc [INFO]
- File: `CommonFunc.java`, Line: 92
- Description: The public method `isPasswordValid(String password)` has no Javadoc comment. There is no documentation of its parameter, return value, or validation rules. The method only checks for non-null and non-empty; no minimum length, complexity, or other rule is applied, which is not discoverable without reading the implementation.

---

## File: CompanyDateFormatter.java
**Full path:** `app/src/main/java/au/com/collectiveintelligence/fleetiq360/util/CompanyDateFormatter.java`

### Reading Evidence
- Class: `CompanyDateFormatter` (public, instantiable)
- Public Methods:
  - `CompanyDateFormatter(String companyDateTimeFormatPattern)` — constructor (line 14)
  - `formatTime(Date date)` (line 24)
  - `formatDate(Date date)` (line 28)
  - `formatDateTime(Date date)` (line 32)
  - `parseDate(String date)` (line 36)
- Private Fields:
  - `timeFormat` (`SimpleDateFormat`) (line 10)
  - `dateFormat` (`SimpleDateFormat`) (line 11)
  - `dateTimeFormat` (`SimpleDateFormat`) (line 12)
- Constants/Types: None defined

### Findings

#### A102-13: Constructor `CompanyDateFormatter(String)` has no Javadoc [INFO]
- File: `CompanyDateFormatter.java`, Line: 14
- Description: The public constructor has no Javadoc comment. There is no documentation of the expected format of `companyDateTimeFormatPattern`, the assumption that it must contain the substring `" HH:mm:ss"` (which is stripped to derive the date-only format), or the fact that all formatters are set to the device's default timezone.

#### A102-14: Constructor silently strips `" HH:mm:ss"` from pattern with no documentation [MEDIUM]
- File: `CompanyDateFormatter.java`, Line: 18
- Description: The `dateFormat` pattern is derived by calling `companyDateTimeFormatPattern.replace(" HH:mm:ss", "")`. If the input pattern does not contain this exact literal substring, no replacement occurs and `dateFormat` will behave identically to `dateTimeFormat`. This silent fallback is not documented and callers providing patterns with different time separators (e.g. `"T"` or no space before `HH`) will receive a silently wrong date-only formatter. The hardcoded removal string is a hidden contract.

#### A102-15: `formatTime` has no Javadoc [INFO]
- File: `CompanyDateFormatter.java`, Line: 24
- Description: The public method `formatTime(Date date)` has no Javadoc comment. There is no documentation of the fixed output format (`"HH:mm"` in 24-hour time, Locale.US), the timezone used, or behavior on `null` input.

#### A102-16: `formatDate` has no Javadoc [INFO]
- File: `CompanyDateFormatter.java`, Line: 28
- Description: The public method `formatDate(Date date)` has no Javadoc comment. There is no documentation of its parameter, return value, or how the format pattern is derived from the constructor argument.

#### A102-17: `formatDateTime` has no Javadoc [INFO]
- File: `CompanyDateFormatter.java`, Line: 32
- Description: The public method `formatDateTime(Date date)` has no Javadoc comment. There is no documentation of its parameter, return value, or how it uses the full pattern supplied at construction.

#### A102-18: `parseDate` has no Javadoc and silently returns `null` on parse failure [MEDIUM]
- File: `CompanyDateFormatter.java`, Line: 36
- Description: The public method `parseDate(String date)` has no Javadoc comment. The method uses `SimpleDateFormat.parse(String, ParsePosition)` which returns `null` when parsing fails (rather than throwing `ParseException`). This null-return-on-failure contract is entirely undocumented. Any caller that does not null-check the return value will encounter a `NullPointerException` at the point of use, which may be far removed from the parse call, making bugs hard to diagnose.

---

## File: ComplianceAccepter.java
**Full path:** `app/src/main/java/au/com/collectiveintelligence/fleetiq360/util/ComplianceAccepter.java`

### Reading Evidence
- Class: `ComplianceAccepter` (public, instantiable)
- Public Methods:
  - `ComplianceAccepter(Context context)` — constructor (line 23)
  - `askForCompliance()` (line 28)
- Private Fields:
  - `context` (`Context`) (line 20)
  - `user` (`User`) (line 21)
- Constants/Types: None defined

### Findings

#### A102-19: Constructor `ComplianceAccepter(Context)` has no Javadoc [INFO]
- File: `ComplianceAccepter.java`, Line: 23
- Description: The public constructor has no Javadoc comment. There is no documentation of the `context` parameter requirements (e.g. that it must be an `Activity` context to show an `AlertDialog`) or the side effect of calling `CurrentUser.get()` at construction time.

#### A102-20: Constructor captures `CurrentUser.get()` at construction time with no documentation [LOW]
- File: `ComplianceAccepter.java`, Line: 25
- Description: The constructor calls `CurrentUser.get()` and stores the result in `this.user`. If the current user changes between construction and the call to `askForCompliance()` (e.g. due to a logout/re-login cycle), the stored `user` reference will be stale. This is a subtle lifecycle constraint that is entirely undocumented.

#### A102-21: `askForCompliance` has no Javadoc [INFO]
- File: `ComplianceAccepter.java`, Line: 28
- Description: The public method `askForCompliance()` has no Javadoc comment.

#### A102-22: `askForCompliance` has critical undocumented side effects [HIGH]
- File: `ComplianceAccepter.java`, Line: 28
- Description: The method `askForCompliance()` has two major undocumented behavioral branches:
  1. **Accept path (line 37-40):** Updates `user.complianceDate` to the current time, then fires an async `WebApi.updateUser()` call. The `WebListener<CommonResult>()` passed is a default no-op listener — any network error or server-side rejection is silently discarded. No documentation warns callers that the update may fail silently.
  2. **Refuse path (lines 46-48):** Calls `WebData.instance().logout()` and then navigates unconditionally to `LoginActivity` via `context.startActivity()`. This is an application-wide logout triggered from inside a utility class, with no error handling and no documentation. Callers have no indication that calling this method may result in the destruction of the current session and navigation away from the current screen.
  Both of these side effects are security- and UX-critical and are completely absent from any form of documentation.

#### A102-23: `askForCompliance` uses `Context` as an `Activity` context without documentation or validation [LOW]
- File: `ComplianceAccepter.java`, Line: 31
- Description: `new AlertDialog.Builder(context)` requires an `Activity`-derived context (or a context with a valid window token). If an `Application` context is passed, the dialog creation will crash at runtime with a `BadTokenException`. There is no documentation requiring callers to supply an `Activity` context, and no runtime guard against an incorrect context type.
