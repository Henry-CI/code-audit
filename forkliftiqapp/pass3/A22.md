# Pass 3 Findings: A22

## File: HashCodeFileNameGenerator.java

**Full path:** `LibImageloader/src/main/java/com/nostra13/universalimageloader/cache/disc/naming/HashCodeFileNameGenerator.java`

### Reading Evidence

- Class: `HashCodeFileNameGenerator` (public, implements `FileNameGenerator`)
- Public Methods:
  - `generate(String imageUri)` (line 26) — overrides `FileNameGenerator.generate`
- Constants/Types: None defined in this file
- Class-level Javadoc: Lines 18–23 — "Names image file as image URI hashcode"

### Findings

#### A22-1: `generate` has no method-level Javadoc [INFO]

- File: `HashCodeFileNameGenerator.java`, Line: 25–28
- Description: The `generate` method carries `@Override` but has no Javadoc of its own. Documentation is inherited solely from the `FileNameGenerator` interface. While Java tooling will inherit the interface Javadoc, it is good practice for overriding implementations to document any implementation-specific behaviour (e.g. that the result is the decimal string representation of `String.hashCode()`, that it can be negative, and that collisions are possible). No method-level documentation is present here.

---

## File: Md5FileNameGenerator.java

**Full path:** `LibImageloader/src/main/java/com/nostra13/universalimageloader/cache/disc/naming/Md5FileNameGenerator.java`

### Reading Evidence

- Class: `Md5FileNameGenerator` (public, implements `FileNameGenerator`)
- Public Methods:
  - `generate(String imageUri)` (line 36) — overrides `FileNameGenerator.generate`
- Private Methods:
  - `getMD5(byte[] data)` (line 42)
- Constants:
  - `HASH_ALGORITHM = "MD5"` (line 32, private static final String)
  - `RADIX = 10 + 26` (= 36) (line 33, private static final int)
- Class-level Javadoc: Lines 24–29 — "Names image file as MD5 hash of image URI"

### Findings

#### A22-2: Class Javadoc inaccurately describes the output format [LOW]

- File: `Md5FileNameGenerator.java`, Lines: 24–29 (class Javadoc) and 36–40 (generate method)
- Description: The class-level Javadoc states the file is named as the "MD5 hash of image URI". A reader would reasonably interpret "MD5 hash" as a standard 32-character hexadecimal string (the conventional representation). The actual implementation at lines 37–39 converts the MD5 digest bytes into a `BigInteger`, takes its absolute value, and calls `.toString(36)` (base 36, using digits and lowercase letters). The resulting string is a base-36 numeral, not a hexadecimal MD5 hash string. The two representations are different in format, character set, and length. The documentation is therefore inaccurate and misleading to any developer relying on it to predict the generated filename format.

#### A22-3: `generate` has no method-level Javadoc [INFO]

- File: `Md5FileNameGenerator.java`, Line: 35–40
- Description: The `generate` method carries `@Override` but has no method-level Javadoc. No documentation explains the output encoding (base-36), the charset used to convert the URI to bytes (`imageUri.getBytes()` uses the platform default charset, which is not documented and may vary by device), or the behaviour when `getMD5` returns `null` (see A22-4).

#### A22-4: Silent null return from `getMD5` is undocumented and causes a latent NullPointerException [MEDIUM]

- File: `Md5FileNameGenerator.java`, Lines: 42–52 (`getMD5`) and 37–38 (`generate`)
- Description: When a `NoSuchAlgorithmException` is caught at line 48, `getMD5` logs the error via `L.e(e)` and then returns `null` (the uninitialised value of `hash`). Back in `generate` at line 38, the return value is passed directly to `new BigInteger(md5)` without a null check. Passing `null` to `BigInteger(byte[])` throws a `NullPointerException`. The exception is therefore swallowed at one level and converted into an unrelated unchecked exception at another, with no documentation of this failure mode. This is a documentation gap compounded by a latent runtime error path. The risk is LOW in practice (MD5 is universally available on Android) but the undocumented silent-failure-then-crash contract is a documentation accuracy issue.

#### A22-5: `imageUri.getBytes()` uses platform-default charset — undocumented [INFO]

- File: `Md5FileNameGenerator.java`, Line: 37
- Description: `imageUri.getBytes()` encodes the URI string using the JVM's default charset. On Android this is typically UTF-8, but this is not guaranteed and is not documented. If the charset differs across devices or configurations, the same URI could produce different MD5 digests and therefore different filenames. No Javadoc or inline comment documents the assumed charset. This is a documentation omission that could cause subtle cache-miss bugs in non-standard environments.

---

## File: BaseMemoryCache.java

**Full path:** `LibImageloader/src/main/java/com/nostra13/universalimageloader/cache/memory/BaseMemoryCache.java`

### Reading Evidence

- Class: `BaseMemoryCache` (public abstract, implements `MemoryCache`)
- Public Methods (all override `MemoryCache`):
  - `get(String key)` (line 36)
  - `put(String key, Bitmap value)` (line 46)
  - `remove(String key)` (line 52)
  - `keys()` (line 58)
  - `clear()` (line 65)
- Protected Abstract Methods:
  - `createReference(Bitmap value)` (line 70) — has inline Javadoc
- Fields:
  - `softMap` (line 33, private final `Map<String, Reference<Bitmap>>`) — has inline comment "Stores not strong references to objects"
- Class-level Javadoc: Lines 23–29 — describes base memory cache providing non-strong reference storage

### Findings

#### A22-6: `put` always returns `true`, contradicting the interface contract documented in `MemoryCache` [LOW]

- File: `BaseMemoryCache.java`, Line: 46–49
- Description: The `MemoryCache` interface documents `put` as: "returns `true` if value was put into cache successfully, `false` if value was **not** put into cache." The `BaseMemoryCache.put` implementation at line 47 unconditionally calls `softMap.put(...)` and always returns `true` at line 48, regardless of whether the underlying map operation succeeds or fails. There is no Javadoc on the overriding method in `BaseMemoryCache` to clarify that this implementation always returns `true`, nor any note that the `false` return path is not reachable in this implementation. A caller reading the interface contract and expecting a meaningful return value will be misled. The missing override-level documentation leaves the deviation from the documented contract silent.

#### A22-7: Overriding public methods `get`, `remove`, `keys`, `clear` have no method-level Javadoc [INFO]

- File: `BaseMemoryCache.java`, Lines: 36, 52, 58, 65
- Description: None of the five overriding public methods (`get`, `put`, `remove`, `keys`, `clear`) carry method-level Javadoc in `BaseMemoryCache`. All documentation is inherited from `MemoryCache`. Specifically, `get` does not document that it returns `null` both when the key is absent AND when the referenced bitmap has been garbage collected (the weak/soft reference has been cleared) — these are two distinct null-return paths that are invisible to callers relying solely on the interface documentation. Similarly, `remove` does not document that it returns `null` if the referenced bitmap was already collected before removal.
