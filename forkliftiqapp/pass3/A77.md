# Pass 3 Findings: A77

## File: TokenAuthenticator.java
**Full path:** `app/src/main/java/au/com/collectiveintelligence/fleetiq360/autoupdate/util/TokenAuthenticator.java`

### Reading Evidence
- Class: `TokenAuthenticator` (package-private, implements `okhttp3.Authenticator`)
- Public Methods: none — the class itself has package-private visibility; `authenticate()` is an `@Override` of the `Authenticator` interface and is the only non-private method (line 27), but the class is not `public`
- Private Methods: `getAccessToken()` (line 36)
- Constants/Types: none defined; no enums
- No Javadoc present anywhere in the file

### Findings

#### A77-1: No Javadoc on `authenticate()` override [INFO]
- File: `TokenAuthenticator.java`, Line: 27
- Description: The `authenticate(Route, Response)` method has no Javadoc comment. While the class is package-private, `authenticate()` is the sole externally callable method (invoked by OkHttp's interceptor chain when a 401 is received). Its behaviour — fetching a new OAuth token and rebuilding the request with an `Authorization` header, or returning `null` to abandon the retry if token fetch fails — is non-trivial and warrants at least a brief description. The absence of any comment leaves maintainers relying on OkHttp's own documentation to understand the contract.

---

## File: CacheService.java
**Full path:** `app/src/main/java/au/com/collectiveintelligence/fleetiq360/model/CacheService.java`

### Reading Evidence
- Class: `CacheService` (public, extends `android.app.IntentService`)
- Public Methods:
  - `CacheService()` constructor (line 21)
  - `startService()` static (line 76)
- Protected Methods:
  - `onHandleIntent(Intent)` override (line 26)
- Constants/Types: none defined; `TAG` is a private static `String` field (line 18)
- No Javadoc present anywhere in the file

### Findings

#### A77-2: No Javadoc on public constructor `CacheService()` [INFO]
- File: `CacheService.java`, Line: 21
- Description: The default constructor has no Javadoc. Notably, it passes `IntentService.class.getSimpleName()` (which evaluates to the literal string `"IntentService"`) as the worker-thread name argument to `super()`. This is almost certainly unintentional — the thread would appear in stack traces and profilers as `"IntentService"` rather than a name that identifies this service. The constructor warrants a comment explaining the intent, or at minimum the thread name argument should reflect the actual service name.

#### A77-3: No Javadoc on public static method `startService()` [INFO]
- File: `CacheService.java`, Line: 76
- Description: `startService()` is the only public API callers use to trigger caching, but it has no Javadoc. Its behaviour includes a hardcoded 5000 ms (5-second) deferred start via `MyApplication.runLater()`. Nothing in the method signature or surrounding comments documents this delay, its purpose, or the conditions under which the service may not start (e.g., no current user, no network). A maintainer reading a call site cannot determine why the delay exists or whether it is safe to change.

#### A77-4: No Javadoc on `onHandleIntent()` override [INFO]
- File: `CacheService.java`, Line: 26
- Description: `onHandleIntent()` is protected and overrides the `IntentService` contract. It performs multiple distinct steps: guards on current user and network availability, conditionally fetches and caches equipment list data, then iterates each equipment item to conditionally cache pre-start questions, and finally sleeps for 100 ms. The 100 ms `Thread.sleep()` at line 69 is completely undocumented — its purpose (likely to allow async web API callbacks to complete before the service exits) is not explained anywhere.

---

## File: DataBaseHelp.java
**Full path:** `app/src/main/java/au/com/collectiveintelligence/fleetiq360/model/DataBaseHelp.java`

### Reading Evidence
- Class: `DataBaseHelp` (package-private)
- Public Methods: none — both methods are package-private static
- Package-private Static Methods:
  - `getRealmQuery(Realm, Class<E>)` (line 9)
  - `isExpired(long)` (line 13)
- Constants/Types: none formally defined; the expiry duration `2 * 60 * 60 * 1000` (7,200,000 ms = 2 hours) is a hardcoded magic number inline at line 19, not extracted to a named constant
- No Javadoc present anywhere in the file

### Findings

#### A77-5: No Javadoc on `getRealmQuery()` [INFO]
- File: `DataBaseHelp.java`, Line: 9
- Description: `getRealmQuery()` is a generic utility shared across the model layer but has no Javadoc. Its behaviour — constructing a `RealmQuery` filtered by the current user's ID via the `"userKey"` field — has an implicit precondition that `WebData.instance().getUserId()` returns a valid, non-null value. If called when no user session is active this silently produces a query against a null or empty key. This precondition and the semantic meaning of the `"userKey"` field should be documented.

#### A77-6: No Javadoc on `isExpired()` and undocumented magic-number expiry threshold [LOW]
- File: `DataBaseHelp.java`, Lines: 13–21
- Description: `isExpired(long updateTime)` has no Javadoc. Two specific issues compound the lack of documentation:
  1. The expiry threshold is a hardcoded inline expression `2 * 60 * 60 * 1000` (2 hours in milliseconds) at line 19. It is not extracted to a named constant, making the value invisible to callers and impossible to locate or change consistently across the codebase.
  2. The guard condition at line 15 (`if (updateTime > currentTime) return false`) silently treats any future timestamp as non-expired. This is a meaningful edge-case decision (e.g., handling clock skew or a freshly written timestamp that has been recorded in the future) that is not explained anywhere. Without documentation a maintainer may not understand why a future timestamp is considered valid and could inadvertently remove the guard.
  - Severity is LOW rather than INFO because the undocumented magic number and the undocumented future-timestamp guard together create a real risk of accidental regression during maintenance.
