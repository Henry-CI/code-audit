# Pass 3 Findings: A100

## File: UniversityGuideFragment.java
**Full path:** `app/src/main/java/au/com/collectiveintelligence/fleetiq360/ui/fragment/UniversityGuideFragment.java`

### Reading Evidence
- Class: `UniversityGuideFragment extends FleetFragment`
- Public Methods:
  - `onCreateView(LayoutInflater, ViewGroup, Bundle)` (line 21) — override
  - `initViews()` (line 26)
  - `onResume()` (line 49) — override
  - `onPause()` (line 53) — override
- Constants/Types: none defined in this file

### Findings

#### A100-1: `initViews()` has no Javadoc [INFO]
- File: `UniversityGuideFragment.java`, Line: 26
- Description: `initViews()` is a public method with no Javadoc comment. It sets up two button click listeners: a "Go" button that builds a university URL from `MyCommonValue.currentEquipmentItem.id` and launches `WebActivity`, and a "Close" button that pops the fragment back stack. The method's purpose, expected call timing (it must be called after `onCreateView` has inflated `mRootView`), and the dependency on `MyCommonValue.currentEquipmentItem` being non-null are entirely undocumented. The lifecycle override methods (`onCreateView`, `onResume`, `onPause`) are standard Android callbacks and their omission from Javadoc is accepted convention; they are not raised as findings.

---

## File: UserPhotoFragment.java
**Full path:** `app/src/main/java/au/com/collectiveintelligence/fleetiq360/ui/fragment/UserPhotoFragment.java`

### Reading Evidence
- Class: `UserPhotoFragment` (top-level class; despite the name it does NOT extend `Fragment` or any Android fragment base class)
- Inner class: `UserPhotoFragment.SSLCertificateHandler` (public static)
- Public Methods:
  - `SSLCertificateHandler.nuke()` (line 41) — public static
  - `SSLCertificateHandler` (anonymous `X509TrustManager`) interface implementations: `getAcceptedIssuers()` (line 44), `checkClientTrusted()` (line 49), `checkServerTrusted()` (line 53) — these are anonymous inner class overrides, not named public methods of the outer class
  - Anonymous `HostnameVerifier.verify()` (line 63) — anonymous inner class override
- Package-private Methods:
  - `showUserPhoto(ImageView)` (line 18) — static, package-private (no `public` modifier)
- Constants/Types:
  - `SSLCertificateHandler.TAG = "NukeSSLCerts"` (line 38, `protected static final String`)

### Findings

#### A100-2: `SSLCertificateHandler` class has no Javadoc [INFO]
- File: `UserPhotoFragment.java`, Line: 37
- Description: The public static inner class `SSLCertificateHandler` has no class-level Javadoc comment. Its purpose is to globally disable SSL certificate validation and hostname verification for all `HttpsURLConnection` connections in the process for the lifetime of the app. This is a significant, process-wide side effect and warrants at minimum a class-level comment explaining why this exists and what the intended scope is.

#### A100-3: `SSLCertificateHandler.nuke()` has no Javadoc and its security impact is undocumented [HIGH]
- File: `UserPhotoFragment.java`, Line: 41
- Description: `nuke()` is a public static method with no Javadoc. Its implementation installs a trust-all `X509TrustManager` (both `checkClientTrusted` and `checkServerTrusted` are no-ops) and a hostname verifier that unconditionally returns `true`, then sets both as the JVM-wide defaults via `HttpsURLConnection.setDefaultSSLSocketFactory` and `HttpsURLConnection.setDefaultHostnameVerifier`. The effect is that after this call, ALL HTTPS connections made anywhere in the process accept any certificate from any host, making them vulnerable to man-in-the-middle attacks. The method name ("nuke") gives no indication of what is being nuked. There is no Javadoc explaining: what the method does, why it exists, what its global scope is, or when it is safe to call. Given the severity of the security impact (complete SSL bypass, process-wide, persistent for the lifetime of the app), the absence of documentation is rated HIGH. The `@SuppressLint("TrustAllX509TrustManager")` annotation suppresses lint warnings but provides no human-readable explanation. `showUserPhoto` calls `nuke()` every time a user photo is displayed, meaning the SSL bypass is activated silently during normal photo loading.

#### A100-4: `showUserPhoto()` has no Javadoc [INFO]
- File: `UserPhotoFragment.java`, Line: 18
- Description: `showUserPhoto(ImageView)` is package-private (not public), so this finding is informational only. The method has no comment. Its behavior — checking `CurrentUser.get()` and `user.getPhotoUrl()` for null, calling `SSLCertificateHandler.nuke()` as a side effect before loading the image, and falling back to a default drawable — is not described anywhere. The silent invocation of `nuke()` as a side effect of displaying a photo is particularly worth documenting.

#### A100-5: Misleading class name — `UserPhotoFragment` does not extend any Fragment class [LOW]
- File: `UserPhotoFragment.java`, Line: 17
- Description: The class is named `UserPhotoFragment` but does not extend `android.support.v4.app.Fragment`, `android.app.Fragment`, or any fragment base class. It is a plain utility class containing a package-private static method and a public static inner class. The "Fragment" suffix is misleading to any reader of the code and constitutes an inaccurate implicit documentation claim via naming convention. This is a LOW-severity documentation finding because naming conventions serve as implicit documentation.

---

## File: CurrentUser.java
**Full path:** `app/src/main/java/au/com/collectiveintelligence/fleetiq360/user/CurrentUser.java`

### Reading Evidence
- Class: `CurrentUser` (not instantiable; all members are static)
- Public Methods:
  - `get()` (line 26) — public static
  - `setUser(User newUser)` (line 32) — public static
  - `setUser(LoginItem loginItem)` (line 37) — public static (overload)
  - `getTrainingList()` (line 53) — public static
  - `login(LoginHandler handler)` (line 80) — public static
  - `setTemporaryLoginInformation(String email, String password)` (line 120) — public static
  - `logout()` (line 125) — public static
- Public Interface:
  - `LoginHandler` (line 114), with abstract methods `HandleSuccess()` (line 115) and `HandleIncorrectCredentials()` (line 117)
- Constants/Types:
  - `CURRENT_USER_ID_KEY = "current_user_id"` (line 19, `private static final String`)
- Private static fields: `user` (`User`), `loginEmail` (`String`), `loginPassword` (`String`), `training` (`List<TrainingItem>`)

### Findings

#### A100-6: `get()` has no Javadoc [INFO]
- File: `CurrentUser.java`, Line: 26
- Description: `get()` has no Javadoc. The method first checks the in-memory `user` field; if null, it reads a user ID from `ModelPrefs` using `CURRENT_USER_ID_KEY` and fetches from `UserDb`. The lazy-initialisation pattern and the fallback to `ModelPrefs`/`UserDb` are undocumented. The return value when no persisted user ID exists (e.g. on first install) is undocumented — it returns `null` in that case.

#### A100-7: `setUser(User)` has no Javadoc [INFO]
- File: `CurrentUser.java`, Line: 32
- Description: `setUser(User)` has no Javadoc. The method sets the in-memory user and persists the user's ID to `ModelPrefs`. It does not persist the full `User` object; callers may not expect that the User must already exist in `UserDb` for it to be retrievable across restarts.

#### A100-8: `setUser(LoginItem)` has no Javadoc; side effects on associated drivers and training are undocumented [MEDIUM]
- File: `CurrentUser.java`, Line: 37
- Description: The `setUser(LoginItem)` overload has no Javadoc. Beyond setting the current user it performs two additional side effects that are not apparent from the method signature: (1) it iterates over `loginItem.drivers` and saves each associated driver to `UserDb` (line 38-39); (2) it calls `setUserTraining(loginItem.arrDriverTrainings)` (line 41) to replace the entire in-memory training list. Neither side effect is documented. Callers relying on method name alone would not anticipate that this method modifies the `UserDb` for other users or replaces the training list.

#### A100-9: `getTrainingList()` has no Javadoc [INFO]
- File: `CurrentUser.java`, Line: 53
- Description: `getTrainingList()` has no Javadoc. The returned list is the raw static field; it is mutable and shared. There is no documentation indicating whether callers should treat it as read-only, how it is populated (only via `setUser(LoginItem)`), or what it contains when no login has occurred (it is initialised to an empty `ArrayList` at class load time).

#### A100-10: `login()` has no Javadoc; non-obvious fallback and credential-hashing behaviour are undocumented [MEDIUM]
- File: `CurrentUser.java`, Line: 80
- Description: `login(LoginHandler)` has no Javadoc. Several non-obvious behaviours are invisible to callers:
  1. The method reads credentials from the static fields `loginEmail` and `loginPassword`, which must have been pre-populated by a prior call to `setTemporaryLoginInformation()`. If that call has not been made, both fields are `null` and the login request will be sent with null values. This call-ordering dependency is entirely undocumented.
  2. The email is MD5-hashed inside this method (line 82: `CommonFunc.MD5_Hash(loginEmail)`), but `loginPassword` is used as-is — it was already MD5-hashed when stored by `setTemporaryLoginInformation()`. This asymmetry is not documented and is a potential source of confusion.
  3. On `onFailed`, an HTTP 502 (Bad Gateway) response is treated identically to invalid credentials and triggers `HandleIncorrectCredentials()` rather than a network-error path. This behaviour is surprising and undocumented.
  4. On `onFailed` for all other HTTP errors, the method falls back silently to a local database lookup using the raw (pre-hashed) `loginEmail` and `loginPassword` fields. Successful local lookup causes `HandleSuccess()` to be called even though the server was unreachable. This offline-login capability is undocumented.

#### A100-11: `setTemporaryLoginInformation()` has no Javadoc; hashing of password is undocumented [MEDIUM]
- File: `CurrentUser.java`, Line: 120
- Description: `setTemporaryLoginInformation(String email, String password)` has no Javadoc. The method stores `email` as-is in `loginEmail` but stores an MD5 hash of `password` (not the plain-text value) in `loginPassword` via `CommonFunc.MD5_Hash(password)` (line 122). The fact that the password is hashed before storage is not communicated to callers. This is relevant because the stored hashed value is later passed directly to `WebApi` and to `UserDb.get()` — callers supplying a pre-hashed password would cause double-hashing. The word "Temporary" in the method name suggests the data is ephemeral, but there is no documentation on when it is cleared (it is never cleared — not even by `logout()`).

#### A100-12: `logout()` does not clear login credentials; gap is undocumented [MEDIUM]
- File: `CurrentUser.java`, Line: 125
- Description: `logout()` has no Javadoc. The method removes the persisted user ID from `ModelPrefs` and nulls the in-memory `user` field. However, it does NOT clear `loginEmail`, `loginPassword`, or `training`. After `logout()`, a subsequent call to `login()` would still use the previously stored (stale) credentials from `loginEmail`/`loginPassword`. This gap between the implied semantics of `logout()` (complete session teardown) and its actual behaviour (partial teardown) is undocumented. The omission of `training` from the logout cleanup is also undocumented.

#### A100-13: `LoginHandler` interface has no Javadoc [INFO]
- File: `CurrentUser.java`, Line: 114
- Description: The public `LoginHandler` interface and its two abstract methods `HandleSuccess()` and `HandleIncorrectCredentials()` have no Javadoc. In particular, `HandleIncorrectCredentials()` is called both for genuinely incorrect credentials AND for HTTP 502 responses, which is a non-obvious overloading of the method's semantics that should be documented on the interface contract.
