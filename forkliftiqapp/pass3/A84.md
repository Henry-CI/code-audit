# Pass 3 Findings: A84

## File: SessionTimeoutJobService.java
**Full path:** `app/src/main/java/au/com/collectiveintelligence/fleetiq360/session/SessionTimeoutJobService.java`

### Reading Evidence
- Class: `SessionTimeoutJobService` extends `android.app.job.JobService` (public)
- Public Methods:
  - `onStartJob(JobParameters params)` (line 18) — overrides `JobService`
  - `onStopJob(JobParameters params)` (line 32) — overrides `JobService`
- Package-private Methods (not public, excluded from undocumented-public findings):
  - `schedule(Context context)` (line 36) — static, package-private
  - `cancel(Context context)` (line 46) — static, package-private
- Constants/Types:
  - `SESSION_TIMEOUT_JOB_SERVICE_ID = 1` (private static final int, line 15)

### Findings

#### A84-1: `onStartJob` has no Javadoc [INFO]
- File: `SessionTimeoutJobService.java`, Line: 18
- Description: The public method `onStartJob(JobParameters)` has no Javadoc comment. The method's behaviour is non-trivial: it reads the unfinished session from the local database, calls `endSession()` if the session is already finished, and calls `showSessionTimeoutWarningDialog()` if the session should show a warning. It always returns `false` (no ongoing async work on the job thread). None of this is documented.

#### A84-2: `onStopJob` has no Javadoc [INFO]
- File: `SessionTimeoutJobService.java`, Line: 32
- Description: The public method `onStopJob(JobParameters)` has no Javadoc comment. The method unconditionally returns `false`, meaning the job will not be rescheduled if it is stopped early. This is a deliberate policy decision with no explanation.

---

## File: SessionTimeouter.java
**Full path:** `app/src/main/java/au/com/collectiveintelligence/fleetiq360/session/SessionTimeouter.java`

### Reading Evidence
- Class: `SessionTimeouter` (public, singleton)
- Public Methods:
  - `getInstance()` (line 30) — static
  - `start(Context context)` (line 36)
  - `cancel(Context context)` (line 42)
  - `register(Activity activity)` (line 108) — static
  - `unregister(Activity activity)` (line 114) — static
- Package-private Methods (excluded from undocumented-public findings):
  - `endSession()` (line 62)
  - `showSessionTimeoutWarningDialog(Context context)` (line 120)
  - `showSessionTimeoutWarningDialog()` (line 159) — static overload
- Private Methods:
  - `restart()` (line 47)
  - `preEndSession()` (line 53)
  - `onSessionEnded()` (line 86)
  - `getContext()` (line 165)
- Constants/Types:
  - `instance` — private static field (singleton holder), line 27
  - `warningDisplayed` — private boolean field, line 28
  - `registrations` — private static `HashMap<Activity, SessionTimeouterReceiver>`, line 102, initialised in static block (line 104–106)

### Findings

#### A84-3: `getInstance` has no Javadoc [INFO]
- File: `SessionTimeouter.java`, Line: 30
- Description: The public static factory method `getInstance()` has no Javadoc. It is a non-thread-safe lazy singleton initialiser (no synchronisation guard). The absence of documentation means callers have no indication that concurrent first-time access is unsafe.

#### A84-4: `start` has no Javadoc [INFO]
- File: `SessionTimeouter.java`, Line: 36
- Description: The public method `start(Context)` has no Javadoc. Its behaviour includes two distinct side effects beyond scheduling the periodic job: it resets the `warningDisplayed` flag and it immediately calls `preEndSession()`, which reads the current unfinished session, marks it as pre-ended, and fires an asynchronous web API call (`saveSessionPreEnd`). The pre-end API call on start is a significant and non-obvious side effect that is entirely undocumented.

#### A84-5: `cancel` has no Javadoc [INFO]
- File: `SessionTimeouter.java`, Line: 42
- Description: The public method `cancel(Context)` has no Javadoc. It cancels the periodic job and resets `warningDisplayed`. The reset of `warningDisplayed` as a side effect of cancellation is not documented.

#### A84-6: `register` has no Javadoc [INFO]
- File: `SessionTimeouter.java`, Line: 108
- Description: The public static method `register(Activity)` has no Javadoc. It creates a `SessionTimeouterReceiver`, registers it as a broadcast receiver with the hardcoded intent filter string `"MyApplication.INTENT_DISPLAYERROR"`, and stores the receiver in the `registrations` map. The hardcoded filter string is a notable coupling detail. There is no documentation of the required pairing call to `unregister`, the risk of leaking the receiver if `unregister` is not called, or the purpose of the registration within the session timeout lifecycle.

#### A84-7: `unregister` has no Javadoc [INFO]
- File: `SessionTimeouter.java`, Line: 114
- Description: The public static method `unregister(Activity)` has no Javadoc. It removes the activity from the `registrations` map and unregisters the associated broadcast receiver. Silent no-op if the activity was never registered (receiver will be `null`). None of this is documented.

---

## File: SessionTimeouterReceiver.java
**Full path:** `app/src/main/java/au/com/collectiveintelligence/fleetiq360/session/SessionTimeouterReceiver.java`

### Reading Evidence
- Class: `SessionTimeouterReceiver` extends `android.content.BroadcastReceiver` — **package-private** (no `public` modifier on the class declaration)
- Package-private Constructor:
  - `SessionTimeouterReceiver(Activity activity)` (line 11) — package-private
- Public Methods (by override contract, but class is package-private):
  - `onReceive(Context context, Intent intent)` (line 16) — overrides `BroadcastReceiver`
- Constants/Types: none
- Fields:
  - `context` — private `Context`, line 9

### Findings

No findings. The class is package-private and has no public API surface accessible outside the package. The single method `onReceive` is a framework callback override on a non-public class; no Javadoc is required under the audit scope of undocumented *public* methods on *public* classes.
