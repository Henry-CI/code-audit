# Pass 3 Findings: A24

## File: FuzzyKeyMemoryCache.java
**Full path:** `LibImageloader/src/main/java/com/nostra13/universalimageloader/cache/memory/impl/FuzzyKeyMemoryCache.java`

### Reading Evidence
- Class: `FuzzyKeyMemoryCache` (implements `MemoryCache`)
- Public Methods:
  - `FuzzyKeyMemoryCache(MemoryCache cache, Comparator<String> keyComparator)` (line 39) — constructor
  - `put(String key, Bitmap value)` (line 45)
  - `get(String key)` (line 63)
  - `remove(String key)` (line 68)
  - `clear()` (line 73)
  - `keys()` (line 78)
- Constants/Types: none (two private final fields: `cache`, `keyComparator`)

### Findings

#### A24-1: Constructor `FuzzyKeyMemoryCache` has no Javadoc [INFO]
- File: `FuzzyKeyMemoryCache.java`, Line: 39
- Description: The public constructor accepts a `MemoryCache` delegate and a `Comparator<String>` used for fuzzy key matching, but has no Javadoc comment. Neither parameter is documented. The class-level Javadoc describes the comparator's role at a high level, but does not substitute for parameter-level documentation on the constructor.

#### A24-2: `put(String, Bitmap)` has no Javadoc [INFO]
- File: `FuzzyKeyMemoryCache.java`, Line: 45
- Description: The `put` override contains meaningful non-trivial logic — it scans all existing cache keys using the comparator, removes any key that compares equal to the incoming key (lines 48-57), and then delegates to the inner cache. This key-removal side-effect is the defining behavior of this decorator class and is not documented at the method level. The class-level Javadoc partially describes the intent but does not document method parameters, return value, or thread-safety (the method synchronizes on `cache` internally).

#### A24-3: `get(String)`, `remove(String)`, `clear()`, and `keys()` have no Javadoc [INFO]
- File: `FuzzyKeyMemoryCache.java`, Lines: 63, 68, 73, 78
- Description: All four methods are pure delegation overrides with no method-level Javadoc. While these are straightforward delegations to the inner cache, their absence of documentation is inconsistent with the level of documentation present elsewhere in the library (e.g., the class-level comment). These are grouped as a single INFO finding because each individually involves no behavioral subtlety beyond the delegation.

---

## File: LRULimitedMemoryCache.java
**Full path:** `LibImageloader/src/main/java/com/nostra13/universalimageloader/cache/memory/impl/LRULimitedMemoryCache.java`

### Reading Evidence
- Class: `LRULimitedMemoryCache` (extends `LimitedMemoryCache`)
- Public Methods:
  - `LRULimitedMemoryCache(int maxSize)` (line 48) — constructor
  - `put(String key, Bitmap value)` (line 53)
  - `get(String key)` (line 63)
  - `remove(String key)` (line 69)
  - `clear()` (line 75)
- Protected Methods (not public, noted for completeness):
  - `getSize(Bitmap value)` (line 81)
  - `removeNext()` (line 86)
  - `createReference(Bitmap value)` (line 100)
- Constants/Types:
  - `INITIAL_CAPACITY = 10` (line 41, private static final int)
  - `LOAD_FACTOR = 1.1f` (line 42, private static final float)
  - `lruCache` — private `Map<String, Bitmap>` backed by access-ordered `LinkedHashMap` (line 45)

### Findings

#### A24-4: `put(String, Bitmap)` has no Javadoc [INFO]
- File: `LRULimitedMemoryCache.java`, Line: 53
- Description: No Javadoc is present on this override. The method delegates to `super.put()` and, on success, also inserts into the LRU tracking map. No documentation explains this dual-store behavior or the return value semantics.

#### A24-5: `get(String)` has no Javadoc and a non-obvious implementation detail is undocumented [INFO]
- File: `LRULimitedMemoryCache.java`, Line: 63
- Description: No Javadoc is present on this override. The implementation calls `lruCache.get(key)` solely for its access-ordering side-effect (the return value is discarded), then calls `super.get(key)` for the actual result. An inline comment exists (`// call "get" for LRU logic`), but there is no method-level Javadoc explaining why the return value of the first call is intentionally discarded or the dual-lookup behavior, which could confuse future maintainers.

#### A24-6: `remove(String)` and `clear()` have no Javadoc [INFO]
- File: `LRULimitedMemoryCache.java`, Lines: 69, 75
- Description: Neither override has Javadoc. Both are straightforward dual-map operations (remove/clear from both `lruCache` and the superclass), but are undocumented.

#### A24-7: Protected `removeNext()` uses a misleading variable name inconsistent with LRU semantics [INFO]
- File: `LRULimitedMemoryCache.java`, Line: 87
- Description: The local variable is named `mostLongUsedValue`, which suggests it refers to the most-recently-used entry. In reality, the method removes the *least* recently used entry — the first entry returned by the iterator of the access-ordered `LinkedHashMap`. This is not a Javadoc issue (the method is protected and has no Javadoc) but is a code-level documentation concern. The variable name directly contradicts the documented LRU eviction policy stated in the class-level Javadoc. This finding is noted as INFO because `removeNext()` is protected and the misleading name is internal, but it could cause errors in subclasses or future refactoring.

---

## File: LargestLimitedMemoryCache.java
**Full path:** `LibImageloader/src/main/java/com/nostra13/universalimageloader/cache/memory/impl/LargestLimitedMemoryCache.java`

### Reading Evidence
- Class: `LargestLimitedMemoryCache` (extends `LimitedMemoryCache`)
- Public Methods:
  - `LargestLimitedMemoryCache(int sizeLimit)` (line 48) — constructor
  - `put(String key, Bitmap value)` (line 53)
  - `remove(String key)` (line 63)
  - `clear()` (line 72)
- Protected Methods (not public, noted for completeness):
  - `getSize(Bitmap value)` (line 78)
  - `removeNext()` (line 83)
  - `createReference(Bitmap value)` (line 106)
- Constants/Types:
  - `valueSizes` — private `Map<Bitmap, Integer>` (line 46), maps Bitmap instances to their sizes in bytes

### Findings

#### A24-8: `valueSizes` field Javadoc contains a broken `{@link #softMap}` cross-reference [LOW]
- File: `LargestLimitedMemoryCache.java`, Lines: 41-45
- Description: The Javadoc comment on the `valueSizes` field states: "it continue exist at {@link #softMap} and can be collected by GC at any time". The field `softMap` does not exist in `LargestLimitedMemoryCache` or its immediate parent `LimitedMemoryCache`; it is a private field of the grandparent class `BaseMemoryCache`. A `{@link #softMap}` reference within `LargestLimitedMemoryCache` will not resolve correctly — the Javadoc generator will produce a broken link or no link at all, and the reference is meaningless to readers of this class. This comment appears to be copy-pasted verbatim from the `hardCache` field Javadoc in `LimitedMemoryCache` (which also incorrectly uses `{@link #softMap}` rather than a fully qualified reference), and was adapted without correcting the cross-class reference. The same broken pattern exists in `LimitedMemoryCache` at line 49 of that file.
- Risk: A reader following the link or searching for `softMap` in this class will find nothing; the concept of the soft/weak reference map is part of the eviction explanation and its absence may lead to misunderstanding of the eviction lifecycle.

#### A24-9: Constructor `LargestLimitedMemoryCache` has no Javadoc [INFO]
- File: `LargestLimitedMemoryCache.java`, Line: 48
- Description: The public constructor accepts a `sizeLimit` parameter (the maximum cache size in bytes, as established by the parent) but has no Javadoc. The parameter is not described. Compare with `LRULimitedMemoryCache`, whose constructor has an `@param` tag for the equivalent parameter.

#### A24-10: `put(String, Bitmap)`, `remove(String)`, and `clear()` have no Javadoc [INFO]
- File: `LargestLimitedMemoryCache.java`, Lines: 53, 63, 72
- Description: None of these public override methods has Javadoc. Of particular note is `remove(String key)` (line 63): its implementation calls `super.get(key)` first to obtain the Bitmap reference (so it can remove the corresponding entry from `valueSizes`), then calls `super.remove(key)`. This two-step lookup is subtle — if the bitmap has already been garbage-collected from the soft reference map (and `super.get()` returns `null`), the `valueSizes` map will not be cleaned up for that entry. This behavioral edge case is completely undocumented. While it is an INFO finding from a documentation-only perspective, the underlying logic gap (stale entries in `valueSizes` when weak references are collected before `remove` is called) may warrant a separate code-correctness review.
