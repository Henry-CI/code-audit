# Pass 3 Findings: A89

## File: SignupActivity.java
**Full path:** `app/src/main/java/au/com/collectiveintelligence/fleetiq360/ui/activity/SignupActivity.java`

### Reading Evidence
- Class: `SignupActivity` (extends `FleetActivity`)
- Public Methods:
  - `onCreate(Bundle savedInstanceState)` (line 10) — overrides `AppCompatActivity`/`FleetActivity`
- Constants/Types: None defined

### Findings

#### A89-1: `onCreate` is undocumented [INFO]
- File: `SignupActivity.java`, Line: 10
- Description: The `onCreate` override has no Javadoc comment. While it is an Android lifecycle callback, the method performs non-trivial work specific to this activity: it inflates `R.layout.activity_signup` and immediately commits a `SignupFragment` into `R.id.login_framelayout_id` using `showFragmentWithoutStack`. Neither the purpose of this layout-container mismatch naming (`login_framelayout_id` used for signup) nor the use of `showFragmentWithoutStack` (vs a back-stack variant) is explained. A brief Javadoc noting what is loaded and why the no-stack variant is used would aid maintainers.

---

## File: AbsRecyclerAdapter.java
**Full path:** `app/src/main/java/au/com/collectiveintelligence/fleetiq360/ui/adapter/AbsRecyclerAdapter.java`

### Reading Evidence
- Class: `AbsRecyclerAdapter<T>` (abstract, extends `RecyclerView.Adapter<ViewHolder>`)
- Public Methods (on the outer class):
  - `AbsRecyclerAdapter(Context context, int resId)` — constructor (line 25)
  - `setDatas(List<T> datas)` (line 31)
  - `getDatas()` (line 36)
  - `getItemCount()` (line 41) — override
  - `onCreateViewHolder(ViewGroup parent, int viewType)` (line 47) — override
  - `onBindViewHolder(ViewHolder holder, int position)` (line 54) — override
  - `bindDatas(MyViewHolder holder, T data, int position)` (line 58) — abstract public
  - `setOnItemClickListener(OnItemClickListener onItemClickListener)` (line 100)
- Public Methods (inner class `MyViewHolder`):
  - `getView(int id)` (line 72)
  - `onClick(View v)` (line 84) — override
  - `onLongClick(View v)` (line 91) — override
- Inner Types/Interfaces:
  - `MyViewHolder` — public inner class extending `ViewHolder`, implements `View.OnClickListener`, `View.OnLongClickListener` (line 60)
  - `OnItemClickListener` — public interface (line 96), single method `onItemClick(View v, int position)`
- Constants: None defined

### Findings

#### A89-2: No Javadoc on class `AbsRecyclerAdapter` [INFO]
- File: `AbsRecyclerAdapter.java`, Line: 17
- Description: The abstract generic class has no class-level Javadoc. There is no explanation of the template parameter `<T>`, the role of the class as a base adapter, the caching ViewHolder strategy, or the required contract for subclasses (`bindDatas` must be implemented). This information would materially help new developers who need to subclass it.

#### A89-3: Constructor `AbsRecyclerAdapter(Context, int)` is undocumented [INFO]
- File: `AbsRecyclerAdapter.java`, Line: 25
- Description: The constructor has no Javadoc. The parameter `resId` is a layout resource ID, which is not obvious from the name alone. A note clarifying that `resId` is the item layout resource inflated for each row would improve usability.

#### A89-4: `setDatas(List<T>)` is undocumented [INFO]
- File: `AbsRecyclerAdapter.java`, Line: 31
- Description: No Javadoc. The method replaces the adapter's dataset entirely (not appends) and immediately calls `notifyDataSetChanged()`. The side effect of triggering a full UI refresh is a relevant detail for callers; it is not documented.

#### A89-5: `getDatas()` is undocumented [INFO]
- File: `AbsRecyclerAdapter.java`, Line: 36
- Description: No Javadoc. Returns a direct reference to the internal mutable `ArrayList`, meaning callers can mutate the list without triggering `notifyDataSetChanged`. This is a subtle contract detail that warrants documentation.

#### A89-6: `bindDatas(MyViewHolder, T, int)` abstract method is undocumented [INFO]
- File: `AbsRecyclerAdapter.java`, Line: 58
- Description: No Javadoc on the abstract method that all subclasses must implement. There is no description of the expected behaviour, the meaning of each parameter, or any threading or recycling constraints (e.g., that views from a recycled holder may have stale state). This is the primary extension point of the class and its lack of documentation increases the risk of incorrect subclass implementations.

#### A89-7: `setOnItemClickListener(OnItemClickListener)` is undocumented [INFO]
- File: `AbsRecyclerAdapter.java`, Line: 100
- Description: No Javadoc. The behaviour (delegates item-root click events to the provided listener via `getLayoutPosition()`) is not described. Callers are not told that only root-level clicks are forwarded, or that long-clicks are consumed silently (returns `true` with no listener support).

#### A89-8: `MyViewHolder.getView(int)` is undocumented [INFO]
- File: `AbsRecyclerAdapter.java`, Line: 72
- Description: No Javadoc. The method implements a `HashMap`-based view-lookup cache to avoid repeated `findViewById` calls. This caching behaviour is a non-trivial implementation detail relevant to subclass authors who rely on it inside `bindDatas`. It is not documented.

#### A89-9: `onLongClick` silently consumes all long-click events with no documentation or listener support [LOW]
- File: `AbsRecyclerAdapter.java`, Line: 91
- Description: `onLongClick` always returns `true` (consuming the event) and does nothing else. There is no `OnItemLongClickListener` interface or mechanism for callers to handle long-press events, and no Javadoc or inline comment explains this intentional design choice. Any caller who sets an `OnLongClickListener` on a child view inside `bindDatas` may find it does not fire as expected because the root-level long-click is always consumed first. The missing documentation and the silent swallowing of events together constitute a LOW-severity documentation/design risk.

#### A89-10: `OnItemClickListener` interface is undocumented [INFO]
- File: `AbsRecyclerAdapter.java`, Line: 96
- Description: The public interface and its single method `onItemClick(View v, int position)` have no Javadoc. The meaning of `position` (it is `getLayoutPosition()`, not `getAdapterPosition()`) is not described, which matters in animated or async-update scenarios where these values can differ.

---

## File: PrestartCheckListAdapter.java
**Full path:** `app/src/main/java/au/com/collectiveintelligence/fleetiq360/ui/adapter/PrestartCheckListAdapter.java`

### Reading Evidence
- Class: `PrestartCheckListAdapter` (extends `AbsRecyclerAdapter<String>`)
- Public Methods:
  - `PrestartCheckListAdapter(Context context, int resId)` — constructor (line 24)
  - `setPreStartCheckListPresenter(PreStartCheckListPresenter presenter, EquipmentPrestartFragment ui)` (line 18)
  - `bindDatas(MyViewHolder holder, String data, int position)` (line 29) — override of abstract method
- Constants/Types: None defined
- Private Fields:
  - `presenter` — `PreStartCheckListPresenter` (line 15)
  - `ui` — `EquipmentPrestartFragment` (line 16)

### Findings

#### A89-11: No class-level Javadoc on `PrestartCheckListAdapter` [INFO]
- File: `PrestartCheckListAdapter.java`, Line: 14
- Description: The class has no Javadoc. Its role (adapter for a prestart checklist with YES/NO radio-button answers, backed by a presenter's answer map) is not described anywhere.

#### A89-12: `setPreStartCheckListPresenter` is undocumented [INFO]
- File: `PrestartCheckListAdapter.java`, Line: 18
- Description: No Javadoc. This method must be called before the adapter is attached to a `RecyclerView` or `bindDatas` will throw a `NullPointerException` on `presenter.mapAnswers`. There is no `@throws` tag, no description of the required call order, and no indication that both `presenter` and `ui` are mandatory (neither is null-checked). The implicit mandatory-initialiser pattern is a maintenance risk with no documentation.

#### A89-13: `bindDatas` is undocumented [INFO]
- File: `PrestartCheckListAdapter.java`, Line: 29
- Description: No Javadoc. The method relies on direct field access to `ui.qustionItemArrayList` (note: misspelled field name `qustion` instead of `question`) and `presenter.mapAnswers`, both of which are public fields rather than encapsulated accessors. The behaviour of determining which radio button is pre-checked from the presenter's answer map, and the side-effect of calling `notifyDataSetChanged()` from within an item click handler (which triggers a full rebind while a view event is in progress), are undocumented. These are non-obvious behaviours that warrant at minimum inline comments.

#### A89-14: `bindDatas` calls `notifyDataSetChanged()` from within an item click listener — undocumented risk [LOW]
- File: `PrestartCheckListAdapter.java`, Lines: 44, 56
- Description: Both the "NO" and "YES" `OnClickListener` implementations call `notifyDataSetChanged()` immediately after updating `presenter.mapAnswers`. Calling `notifyDataSetChanged()` from within a click listener fires a full adapter rebind synchronously on the UI thread while the RecyclerView is still processing the click event, which can cause visual glitches or, in some RecyclerView versions, trigger `IllegalStateException: Cannot call this method while RecyclerView is computing a layout or scrolling`. This design decision is not documented by any comment, making it a hidden defect risk. Severity is LOW because it does not crash in common cases, but the absence of documentation means future maintainers are unlikely to identify it as the source of any resulting instability.

#### A89-15: Direct access to `ui.qustionItemArrayList` (misspelled public field) is undocumented [LOW]
- File: `PrestartCheckListAdapter.java`, Line: 35
- Description: `bindDatas` accesses `ui.qustionItemArrayList` directly — a public field on `EquipmentPrestartFragment`. The field name contains a typo (`qustion` instead of `question`). Neither the typo, the direct field access pattern, nor the assumption that `qustionItemArrayList.get(position)` is always in bounds (no guard against index-out-of-bounds if the adapter's data list and the fragment's question list are of different sizes) is documented. The undocumented coupling between the adapter and the fragment's internal field is a LOW severity finding.
