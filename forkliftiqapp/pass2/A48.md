# Audit Pass 2 – Agent A48
**Audit run:** 2026-02-26-01
**Assigned files:**
1. `app/src/main/java/au/com/collectiveintelligence/fleetiq360/model/RealmString.java`
2. `app/src/main/java/au/com/collectiveintelligence/fleetiq360/model/SafeRealm.java`
3. `app/src/main/java/au/com/collectiveintelligence/fleetiq360/model/SessionDb.java`

---

## Project-Wide Finding: Zero Automated Test Coverage

**ID:** A48-1
**Severity:** HIGH
**Scope:** Project-wide (app/ and LibCommon/ modules)

The `app/src/` directory contains only a `main/` source set. There is no `test/` or `androidTest/` subdirectory. The `LibCommon/src/` directory likewise contains only `main/`. No JUnit, Robolectric, or Espresso test source exists in either module. All findings below describe untested code in a codebase where zero automated tests exist for application logic. Any regression is detectable only through manual QA.

---

## File 1: RealmString.java

### Reading Evidence

**Fully qualified class name:** `au.com.collectiveintelligence.fleetiq360.model.RealmString`

**Extends:** `io.realm.RealmObject`

**Fields defined:**
| Field | Type | Modifier | Line |
|-------|------|----------|------|
| `data` | `String` | package-private | 9 |

**Methods defined:** None (no constructors, accessors, or instance methods declared beyond those inherited from `RealmObject`).

**Constants defined:** None.

**Test file:** None. No test class exists anywhere in the project that references `RealmString`.

### Findings

**ID:** A48-2
**Severity:** LOW
**Location:** `RealmString.java`, line 9
**Finding:** The `data` field has package-private visibility. There are no accessor methods (`getData()` / `setData()`). Any code outside the package that needs to read or write this field must do so through Realm-managed proxy reflection. This pattern is consistent with Realm conventions but means the field value can never be verified through a unit test without a live Realm instance. No test confirms that data round-trips correctly through Realm serialization.

**ID:** A48-3
**Severity:** INFO
**Location:** `RealmString.java`
**Finding:** `RealmString` exists solely as a `RealmList<RealmString>` wrapper for primitive strings (a common Realm workaround). No test verifies the intended use pattern — creating a `RealmString`, storing it, and retrieving it via a `RealmList` query. If Realm changes its handling of single-field `RealmObject` wrappers, this class would silently break with no test catching it.

---

## File 2: SafeRealm.java

### Reading Evidence

**Fully qualified class name:** `au.com.collectiveintelligence.fleetiq360.model.SafeRealm`

**Methods defined:**
| Line | Signature |
|------|-----------|
| 7 | `public static void Execute(SafeRealm.Action action)` |
| 13 | `public static void executeTransaction(final SafeRealm.Action action)` |
| 24 | `public static <T> T Execute(SafeRealm.Func<T> func)` |

**Interfaces defined:**
| Name | Line | Description |
|------|------|-------------|
| `SafeRealm.Action` | 31–33 | Callback interface — `void Execute(Realm realm)` |
| `SafeRealm.Func<T>` | 35–37 | Callback interface — `T Execute(Realm realm)` |

**Fields / Constants defined:** None.

**Test file:** None.

### Findings

**ID:** A48-4
**Severity:** HIGH
**Location:** `SafeRealm.java`, lines 7–11 (`Execute(Action)`)
**Finding:** No test covers the failure path where `action.Execute(realm)` throws a `RuntimeException`. When an exception is thrown on line 9, line 10 (`realm.close()`) is never reached because there is no `try/finally` guard. The Realm instance leaks. Leak accumulation can cause `io.realm.exceptions.RealmFileException` or silent data corruption. No test verifies that realm is closed on action failure.

**ID:** A48-5
**Severity:** HIGH
**Location:** `SafeRealm.java`, lines 13–22 (`executeTransaction(Action)`)
**Finding:** The `executeTransaction` method acquires a Realm instance on line 14 and calls `realm.close()` on line 21. If `realm.executeTransaction(...)` throws (e.g., `io.realm.exceptions.RealmException` on a write conflict or a `RuntimeException` propagated from `action.Execute`), line 21 is never reached and the instance leaks. There is no `try/finally` block. No test verifies realm is closed after a transaction failure.

**ID:** A48-6
**Severity:** HIGH
**Location:** `SafeRealm.java`, lines 24–29 (`Execute(Func<T>)`)
**Finding:** Same pattern as A48-4 — if `func.Execute(realm)` throws on line 26, line 27 (`realm.close()`) is skipped. No `try/finally`. No test covers the case where the Func callback throws.

**ID:** A48-7
**Severity:** HIGH
**Location:** `SafeRealm.java`, lines 7–29
**Finding:** No test verifies behavior when `Realm.getDefaultInstance()` itself throws (e.g., realm has been closed globally, configuration not initialized, or called from a non-Looper background thread). All three `Execute`/`executeTransaction` overloads call `Realm.getDefaultInstance()` unconditionally with no null-check or exception handling. The resulting `IllegalStateException` or `RealmFileException` would propagate uncaught to callers spread across the entire application.

**ID:** A48-8
**Severity:** HIGH
**Location:** `SafeRealm.java`, lines 13–22 (`executeTransaction`)
**Finding:** No test covers concurrent access. `Realm.getDefaultInstance()` returns a thread-local instance, but the `executeTransaction` wrapper provides no synchronization guarantee at the application level. If two callers on different threads invoke `executeTransaction` for the same data simultaneously, Realm's internal locking may serialize them, but the application-level callback (`action.Execute`) may receive stale data from the first call by the time the second executes. No test exercises concurrent writes through this wrapper.

**ID:** A48-9
**Severity:** MEDIUM
**Location:** `SafeRealm.java`, lines 7–11 (`Execute(Action)`)
**Finding:** `Execute(Action)` acquires a Realm instance and calls `action.Execute` but does NOT wrap the call in a transaction. Any `RealmObject` writes performed inside `action` outside of an explicit `realm.executeTransaction(...)` call will throw `io.realm.exceptions.RealmException: Changing Realm data can only be done from inside a transaction`. There is no test verifying that callers of `Execute(Action)` correctly manage their own transactions, and no test to detect misuse of this method for write operations.

**ID:** A48-10
**Severity:** MEDIUM
**Location:** `SafeRealm.java`, lines 31–37 (interfaces `Action`, `Func<T>`)
**Finding:** The naming convention capitalizes `Execute` on interface methods (line 32: `void Execute(Realm realm)`) while Java conventions use camelCase (`execute`). This inconsistency with standard Java and with Realm's own `Realm.Transaction.execute(Realm)` method means IDE autocompletion and code-reading are error-prone. No test validates that the correct interface method is wired up (though this is a static-analysis concern, the absence of tests removes one safety net).

---

## File 3: SessionDb.java

### Reading Evidence

**Fully qualified class name:** `au.com.collectiveintelligence.fleetiq360.model.SessionDb`

**Extends:** `io.realm.RealmObject`

**Fields defined:**
| Field | Type | Modifier | Line |
|-------|------|----------|------|
| `userKey` | `int` | public | 21 |
| `sessionId` | `int` | package-private | 23 |
| `dataStr` | `String` | private | 24 |
| `equipmentItemStr` | `String` | private | 25 |
| `connectionRetry` | `int` | private | 27 |
| `equipmentSetupDone` | `boolean` | private | 29 |
| `preStartFinished` | `boolean` | public | 30 |
| `preStartResults` | `String` | private | 31 |
| `sessionFinished` | `boolean` | private | 33 |
| `startedOffline` | `boolean` | private | 34 |
| `stoppedOffline` | `boolean` | private | 35 |
| `prestartOffline` | `boolean` | private | 36 |
| `abortedOffline` | `boolean` | package-private | 37 |
| `aborted` | `boolean` | private | 38 |
| `toDelete` | `boolean` | private | 39 |

**Methods defined:**
| Line | Signature |
|------|-----------|
| 41 | `public SessionResult getSessionResult()` |
| 50 | `public void setSessionResult(SessionResult result)` |
| 54 | `public EquipmentItem getEquipmentItem()` |
| 58 | `public static boolean isEquipmentSetupDone(final int sessionId)` |
| 68 | `public static boolean isPreStartFinished(final int sessionId)` |
| 78 | `SavePreStartItem getPreStartResultsParameter()` |
| 101 | `static void setSessionSynced(final SaveSessionsParameter saveSessionsParameter, final SessionResult sessionResult)` |
| 127 | `static ArrayList<SessionDb> readAllFinishedSessionsToSync()` |
| 145 | `public static boolean isSessionAborted(final int sessionId)` |
| 154 | `static ArrayList<SessionDb> readAllAbortedSessionsToSync()` |
| 163 | `static void removeSessionsToDelete()` |
| 178 | `public static void setSessionPreFinish(final int sessionId, final String finishTime)` |
| 202 | `public static void addRunningChangeListener(final RealmChangeListener<RealmResults<SessionDb>> listener)` |
| 214 | `private static ArrayList<SessionDb> readRunningSessionList()` |
| 224 | `private static void endSessions(Realm realm)` |
| 255 | `public static SessionDb readRunningSessionDb()` |
| 260 | `public static EquipmentItem readRunningEquipmentItem()` |
| 265 | `public static SessionResult readRunningSession()` |
| 270 | `public static SessionResult readUnfinishedSession()` |
| 280 | `private boolean canDeleteSessionDb()` |
| 290 | `public static boolean hasOfflineData(final int sessionId)` |
| 306 | `public static void setSessionAborted(final int sessionId, final boolean offline)` |
| 338 | `public static void setSessionFinished(final int sessionId, final String finish_time, final boolean offline)` |
| 374 | `private void setToDeleteIfPossible()` |
| 378 | `public static void setSessionResultWithPreStartRequired(final SessionResult sessionResult, boolean prestartRequired)` |
| 395 | `public static void setSessionPreStartFinished(final int sessionId, final SavePreStartParameter parameter, final boolean offline)` |
| 418 | `public static void setSessionConnected(final int sessionId, final boolean connected)` |
| 435 | `private static void saveData(final int sessionId, final SessionResult result, final EquipmentItem equipmentItem, final boolean offline)` |
| 461 | `public static void saveData(final SessionResult result, final EquipmentItem equipmentItem, final boolean offline)` |
| 467 | `public int incrementConnectionRetry()` |

**Constants defined:** None.

**Test file:** None.

### Findings

**ID:** A48-11
**Severity:** HIGH
**Location:** `SessionDb.java`, line 21
**Finding:** `userKey` is initialized at field-declaration time with `WebData.instance().getUserId()`. This initialization runs at the moment a `SessionDb` object is constructed or deserialized by Realm. If `WebData.instance()` returns null (e.g., no logged-in user, or the singleton has not been initialized), this line throws a `NullPointerException` that cannot be caught by any caller because it occurs inside Realm's object instantiation. No test verifies behavior when no user is active at construction time.

**ID:** A48-12
**Severity:** HIGH
**Location:** `SessionDb.java`, lines 338–372 (`setSessionFinished`)
**Finding:** On line 351, `GsonHelper.objectFromString(sessionDb.dataStr, SessionResult.class)` is called and the result is used on line 352 (`sessionResult.finish_time = finish_time`) without a null check. If `dataStr` is null or malformed, `GsonHelper.objectFromString` returns null, and line 352 throws a `NullPointerException` inside a Realm transaction, leaving transaction state undefined. No test covers the case where `dataStr` is null or unparseable when `setSessionFinished` is called.

**ID:** A48-13
**Severity:** HIGH
**Location:** `SessionDb.java`, lines 467–487 (`incrementConnectionRetry`)
**Finding:** Line 486 calls `Objects.requireNonNull(readRunningSessionDb()).connectionRetry`. If there is no running session (e.g., the session was concurrently finished between the write on lines 470–484 and the read on line 486), `readRunningSessionDb()` returns null and `Objects.requireNonNull` throws a `NullPointerException`. This is a crash path in normal application operation. No test covers the scenario where the session disappears between the increment write and the subsequent read.

**ID:** A48-14
**Severity:** HIGH
**Location:** `SessionDb.java`, lines 224–253 (`endSessions`)
**Finding:** `endSessions` is called from inside a `SafeRealm.Execute(Func)` lambda in `readRunningSessionList` (line 218). Inside `endSessions`, `realm.executeTransaction(...)` is called (line 225). This constitutes a nested transaction initiation — executing a `realm.executeTransaction` call on a Realm instance that was obtained from `SafeRealm.Execute` (which does not itself open a transaction). If Realm's version at build time does not support nesting, or if the outer context already has a transaction open, this will throw at runtime. No test verifies that this nested transaction pattern is safe or that it applies the session-ending logic correctly.

**ID:** A48-15
**Severity:** HIGH
**Location:** `SessionDb.java`, lines 101–125 (`setSessionSynced`)
**Finding:** `setSessionSynced` is called with a `saveSessionsParameter` whose `sessions` field is accessed on line 106 without a null check. If `saveSessionsParameter.sessions` is null, a `NullPointerException` is thrown before the transaction begins, but after `SafeRealm.Execute` has acquired a Realm instance — which, due to the missing `try/finally` in `SafeRealm.Execute`, then leaks. No test verifies behavior when `saveSessionsParameter.sessions` is null.

**ID:** A48-16
**Severity:** HIGH
**Location:** `SessionDb.java`, lines 127–143 (`readAllFinishedSessionsToSync`)
**Finding:** No test covers the session boundary logic for sync eligibility. The query combines `sessionFinished=true`, `abortedOffline=false`, `toDelete=false`, and a group requiring at least one of `startedOffline`, `prestartOffline`, or `stoppedOffline` to be true. There is no test verifying that sessions in every boundary state (e.g., all three offline flags false, only one true, mixed) are correctly included or excluded from the sync set.

**ID:** A48-17
**Severity:** HIGH
**Location:** `SessionDb.java`, lines 395–416 (`setSessionPreStartFinished`)
**Finding:** On lines 401 and 411, `session` is captured from outside the Realm transaction lambda (line 401 assigns `sessions.get(0)` before entering `realm.executeTransaction`). Realm managed objects are only valid inside the thread and transaction they were obtained from. Accessing `session.dataStr` on line 411 after the transaction has closed may return stale or invalid data if the Realm instance has been modified. No test verifies that data read after a completed transaction reflects the committed state.

**ID:** A48-18
**Severity:** HIGH
**Location:** `SessionDb.java`, lines 202–212 (`addRunningChangeListener`)
**Finding:** `addRunningChangeListener` opens a Realm instance via `SafeRealm.Execute(Action)`, attaches a `RealmChangeListener` to a `RealmResults` object, then closes the Realm on line 10 of `SafeRealm.Execute`. Closing the Realm invalidates all its associated `RealmResults` and change listeners. The listener registered here will never fire after the Realm is closed. This is a functional defect in the change-listener registration pattern. No test verifies that the listener is actually invoked when session data changes.

**ID:** A48-19
**Severity:** MEDIUM
**Location:** `SessionDb.java`, lines 58–66 (`isEquipmentSetupDone`) and lines 68–76 (`isPreStartFinished`)
**Finding:** Both methods return `false` when no `SessionDb` record matches the given `sessionId`. There is no distinction between "the session exists and setup is not done" and "the session does not exist at all." Callers have no way to detect a missing session. No test covers the case where `sessionId` does not match any record.

**ID:** A48-20
**Severity:** MEDIUM
**Location:** `SessionDb.java`, lines 78–99 (`getPreStartResultsParameter`)
**Finding:** The method returns `null` in three distinct cases: `prestartOffline` is false (line 80), `preStartResults` is null (line 83), or `GsonHelper.objectFromString` returns null due to malformed JSON (line 90). Callers cannot distinguish between these cases. No test verifies any of these three null-return paths or confirms that callers handle each case correctly.

**ID:** A48-21
**Severity:** MEDIUM
**Location:** `SessionDb.java`, lines 280–288 (`canDeleteSessionDb`)
**Finding:** The deletion eligibility logic combines five boolean flags (`toDelete`, `aborted`, `abortedOffline`, `sessionId <= 0`, `sessionFinished`, `startedOffline`, `prestartOffline`, `stoppedOffline`) across two branches. This logic has at least 2^5 = 32 distinct input combinations. No test exercises any combination. The risk is that sessions that should be retained are deleted (data loss) or sessions that should be deleted are retained (storage growth and sync pollution).

**ID:** A48-22
**Severity:** MEDIUM
**Location:** `SessionDb.java`, lines 163–176 (`removeSessionsToDelete`)
**Finding:** `removeSessionsToDelete` calls `sessionsToDelete.deleteAllFromRealm()` inside a transaction. The `RealmResults` object `sessionsToDelete` is obtained outside the transaction (line 167) and used inside it (line 171). While Realm supports this pattern, the results set is live and may change between the outer query and the inner deletion if another thread writes concurrently. No test verifies that only the expected records are deleted.

**ID:** A48-23
**Severity:** MEDIUM
**Location:** `SessionDb.java`, lines 338–372 (`setSessionFinished`) and lines 306–336 (`setSessionAborted`)
**Finding:** Both methods silently return when no matching session is found (`sessions.size() <= 0`). The caller receives no signal that the operation was a no-op. If a session ID is wrong (e.g., a race condition has already deleted the record), the finish or abort is silently dropped with no log, no exception, and no return value indicating failure. No test verifies this silent-failure path.

**ID:** A48-24
**Severity:** MEDIUM
**Location:** `SessionDb.java`, lines 435–459 (`saveData` private overload)
**Finding:** When no existing session matches `sessionId`, `realm.createObject(SessionDb.class)` is called (line 448) without a primary key argument. `SessionDb` has a `sessionId` field that appears to serve as a logical key but is not annotated `@PrimaryKey`. If Realm is configured to require a primary key for this class, this call throws at runtime. No test covers the code path where `saveData` creates a new record (as opposed to updating an existing one).

**ID:** A48-25
**Severity:** MEDIUM
**Location:** `SessionDb.java`, lines 461–465 (`saveData` public overload)
**Finding:** The public `saveData(SessionResult, EquipmentItem, boolean)` calls `result.id` on line 464 without a null check on `result`. Although the private overload guards against null on line 439, the public overload does not check for null before dereferencing `result.id`. Calling `saveData(null, equipmentItem, false)` throws a `NullPointerException`. No test covers this case.

**ID:** A48-26
**Severity:** MEDIUM
**Location:** `SessionDb.java`, lines 214–222 (`readRunningSessionList`) and lines 255–258 (`readRunningSessionDb`)
**Finding:** `readRunningSessionDb` returns the first element of `readRunningSessionList()`, which in turn calls `endSessions` as a side effect before querying. This means every call to `readRunningSessionDb` (and consequently `readRunningEquipmentItem`, `readRunningSession`, and `incrementConnectionRetry`) silently runs a session-expiry sweep and may trigger `SyncService.startService()` as a side effect. No test documents or verifies this side-effect coupling.

**ID:** A48-27
**Severity:** LOW
**Location:** `SessionDb.java`, lines 145–152 (`isSessionAborted`)
**Finding:** The method checks `abortedOffline=true` to determine if a session is aborted, but `setSessionAborted` also sets `aborted=true` (line 319). A session aborted online (`offline=false`) will have `aborted=true` but `abortedOffline=false`, so `isSessionAborted` returns `false` for online-aborted sessions. This naming inconsistency may cause callers to treat online-aborted sessions as not aborted. No test covers the online-abort case for `isSessionAborted`.

**ID:** A48-28
**Severity:** LOW
**Location:** `SessionDb.java`, line 229
**Finding:** `endSessions` adds 1000 milliseconds to current time (`Calendar.getInstance().getTime().getTime() + 1000`) as a tolerance buffer before comparing against `finish_time`. This 1-second tolerance is undocumented and untested. A session finishing within 1 second of the check will be force-expired. No test verifies this boundary condition.

**ID:** A48-29
**Severity:** INFO
**Location:** `SessionDb.java`, lines 101–125 (`setSessionSynced`)
**Finding:** `setSessionSynced` is package-private (`static void` with no access modifier). It is therefore untestable from any external test module without reflection or moving the test to the same package. If test infrastructure is added in future, this access level will require either changing visibility or using in-package test placement.

**ID:** A48-30
**Severity:** INFO
**Location:** `SessionDb.java`, lines 127–143, 154–161 (`readAllFinishedSessionsToSync`, `readAllAbortedSessionsToSync`)
**Finding:** Both sync-read methods are package-private. They are the entry points for the offline sync subsystem but are not testable from outside the package without reflection. Future test coverage would require adjusting visibility or co-locating tests in the same package.
