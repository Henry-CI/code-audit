# Audit Pass 2 — Agent A02
## Test Coverage Findings

**Audit run:** 2026-02-26-01
**Agent:** A02
**Assigned files:**
1. `LibCommon/src/main/java/com/yy/libcommon/BaseFragment.java`
2. `LibCommon/src/main/java/com/yy/libcommon/BaseSubFragment.java`
3. `LibCommon/src/main/java/com/yy/libcommon/BaseThemedDialog.java`

---

## PROJECT-WIDE FINDING

### A02-1 [HIGH] — Zero automated test coverage across app/ and LibCommon/ modules

Both the `app/` and `LibCommon/` modules contain no test directories of any kind. Neither `src/test/` nor `src/androidTest/` exist in either module. Confirmed by filesystem inspection: `app/src/` contains only `main/`, and `LibCommon/src/` contains only `main/`.

The only test files present in the repository are in third-party library modules (`LibImageloader` and `LibImagePicker`/`LibPercentProgress`), which are vendored dependencies, not project code.

This means every class in the core application logic and `LibCommon` shared library — including all three files assigned to this agent — has zero test coverage. All findings below arise from this root condition. Any regression, refactor, or behavioural change in these classes is made without any safety net.

**Affected modules:** `app/`, `LibCommon/`
**Test files found:** 0
**Source files affected:** All classes in both modules

---

## File 1: BaseFragment.java

### Reading Evidence

**Fully qualified class name:** `com.yy.libcommon.BaseFragment`
**Superclass:** `android.support.v4.app.Fragment`
**Implements:** `com.yy.libcommon.BaseController`

**Constants defined:**
- `REQUEST_TAKE_PHOTO` — `public static final int` = `200` (line 33)
- `LOGTAG` — `private static final String` = `"BaseFragment"` (line 36)
- `sChildFragmentManagerField` — `private static final Field` (lines 35, 160–169)

**Fields defined:**
- `mRootView` — `protected ViewGroup` (line 37)
- `isDestroyed` — `public boolean`, default `false` (line 38)
- `takePictureIntent` — `private Intent` (line 40)
- `tempPhotoFilePath` — `public String`, default `""` (line 41)
- `subFragPermission` — `public SubFragPermission` (line 42)

**Methods with line numbers and signatures:**

| Line | Signature |
|------|-----------|
| 45 | `public void takePhoto()` |
| 90 | `public BaseActivity getBaseActivity()` |
| 94 | `public BaseFragment()` (constructor) |
| 97 | `public int getScreenWidth()` |
| 104 | `public void setSimpleSpinner(Spinner spinner, int stringArrayId)` |
| 112 | `public void showErrDialog(String s)` |
| 116 | `public void showToast(String msg)` |
| 124 | `public void showProgress(String title, String message)` |
| 130 | `public void showSavingProgress()` |
| 136 | `public void showDeletingProgress()` |
| 142 | `public void showLoadingProgress()` |
| 148 | `public void updateProgress(String message)` |
| 154 | `public void hideProgress()` |
| 160 | `static { }` (static initializer for `sChildFragmentManagerField`) |
| 172 | `@Override public void onStart()` |
| 179 | `@Override public void onActivityCreated(Bundle savedInstanceState)` |
| 188 | `protected View findViewById(int id)` |
| 198 | `@Override public void onDetach()` |
| 212 | `@Override public void onDestroy()` |
| 221 | `@Override public void onStop()` |
| 227 | `@Override public void onResume()` |
| 233 | `@Override public void onPause()` |
| 237 | `public void showDialog(Context context, String title, String msg)` |
| 249 | `public void showDialog(Context context, String title, String msg, boolean cancelable, ErrorDialog.OnErrorCallback callback)` |
| 263 | `public void showDialog(Context context, String title, String msg, ErrorDialog.OnErrorCallback callback)` |
| 276 | `public SubFragPermission getSubFragPermission()` |
| 281 | `@Override public boolean isDestroyed()` |
| 286 | `@Override public FragmentManager getCurrentFragmentManager()` |
| 292 | `public static void addFragment(FragmentManager fragmentManager, Fragment fragment, int container)` |
| 296 | `public static void addFragment(FragmentManager fragmentManager, Fragment fragment, int container, boolean backStack)` |
| 305 | `public static void removeFragment(FragmentManager fragmentManager, int container)` |
| 311 | `public void addFragment(Fragment fragment, int container)` |
| 315 | `public void addFragment(Fragment fragment, int container, boolean backStack)` |
| 324 | `public void removeSelfFromParent()` |

---

### A02-2 [HIGH] — takePhoto(): no test for null FileManager.createLocalImageFile() return

`takePhoto()` (line 45) calls `FileManager.createLocalImageFile(null)` and checks for a `null` return value on line 52. The null branch displays a toast and returns early, aborting the photo capture. There is no test exercising this error path. A storage or I/O failure that causes `createLocalImageFile` to return `null` will silently abort photo capture; a test would verify the user feedback ("Failed to create image file!") is actually shown.

**Location:** `BaseFragment.java:52–54`

---

### A02-3 [HIGH] — takePhoto(): no test for unresolvable camera intent (no camera app installed)

On line 61, `takePictureIntent.resolveActivity(getActivity().getPackageManager())` is checked for `null`. If no camera application is installed or available, the inner block is simply skipped — no user feedback is given, no error is shown, and the method exits silently via the outer `checkFilePermissionWithRun` runnable completing without action. There is no test covering this silent-failure path.

**Location:** `BaseFragment.java:61`

---

### A02-4 [MEDIUM] — takePhoto(): no test for camera permission denied path

`subFragPermission.checkCameraPermissionWithRun(runnable)` (line 74) stores the runnable and defers execution if the camera permission is not yet granted. There is no test verifying that when camera permission is denied the pending runnable is stored correctly, and that `startActivityForResult` is not called before permission is granted.

**Location:** `BaseFragment.java:74–82`

---

### A02-5 [MEDIUM] — takePhoto(): no test for file/storage permission denied path

`subFragPermission.checkFilePermissionWithRun(runnable)` (line 46) is called first. When storage permission is not granted, the entire inner runnable (including file creation and camera intent setup) is deferred. There is no test verifying this deferral behaviour or that `filePendingRunnable` is set and `tempPhotoFilePath` remains empty in this case.

**Location:** `BaseFragment.java:46–50`

---

### A02-6 [MEDIUM] — static initializer: no test for reflection failure on mChildFragmentManager

The static initializer (lines 160–169) uses reflection to obtain the private `mChildFragmentManager` field from `Fragment`. If the field name changes (e.g., on a support library update), `getDeclaredField` throws `NoSuchFieldException`, which is caught and logged but results in `sChildFragmentManagerField` being `null`. The `onDetach()` method silently skips the null-set in that case (line 201). There is no test verifying this graceful degradation, nor any test confirming that `onDetach()` does not throw when the field is null.

**Location:** `BaseFragment.java:160–169`, `onDetach():198–209`

---

### A02-7 [MEDIUM] — onStop(): NPE if subFragPermission is null

`onStop()` (line 221–224) calls `subFragPermission.onDestroy()` unconditionally. `subFragPermission` is only initialised in `onActivityCreated()` (line 184). If `onStop()` is called before `onActivityCreated()` (a known edge case in certain Fragment back-stack scenarios), a `NullPointerException` will be thrown. By contrast, `onDestroy()` (line 212) correctly guards with `if(subFragPermission != null)`. There is no test covering this inconsistency.

**Location:** `BaseFragment.java:221–224`

---

### A02-8 [MEDIUM] — showToast(): no test for suppression when fragment is not resumed

`showToast()` (line 116) silently suppresses the toast when `!isResumed() || getActivity() == null`. There is no test verifying that: (a) the toast is not shown when the fragment is paused/stopped, and (b) the toast is shown correctly when resumed.

**Location:** `BaseFragment.java:116–122`

---

### A02-9 [MEDIUM] — showProgress / showSavingProgress / showDeletingProgress / showLoadingProgress / updateProgress / hideProgress: no test for isDestroyed guard

Six progress-delegation methods (lines 124–158) all guard on `getBaseActivity() != null && !isDestroyed`. There is no test verifying that calls made after `isDestroyed` is set to `true` (post-`onDestroy()`) do not forward to the activity, avoiding potential NPE or interaction with a destroyed UI.

**Location:** `BaseFragment.java:124–158`

---

### A02-10 [MEDIUM] — removeFragment(): no test for null fragment from findFragmentById

`removeFragment(FragmentManager, int)` (line 305) calls `fragmentManager.findFragmentById(container)` and passes the result directly to `ft.remove()` without a null check. If no fragment occupies the specified container, `findFragmentById` returns `null`, and `ft.remove(null)` will throw an `IllegalArgumentException` or `NullPointerException`. There is no test for this error path.

**Location:** `BaseFragment.java:305–310`

---

### A02-11 [LOW] — showDialog (3 overloads): no test coverage for any variant

All three `showDialog()` overloads (lines 237, 249, 263) are untested. While the dialog display mechanism is largely UI-driven, the overloads have distinguishable logic: setting `cancelable`, attaching `OnErrorCallback`, and forwarding to `ErrorDialog.newInstance()`. No test verifies the correct overload is wired (e.g., that the cancelable-flag variant actually calls `setCancelable()`).

**Location:** `BaseFragment.java:237–273`

---

### A02-12 [LOW] — getScreenWidth(): no test for valid return

`getScreenWidth()` (line 97) delegates to the window manager. It is untested and contains no null guard on `getActivity()`. A call before the fragment is attached would throw an NPE.

**Location:** `BaseFragment.java:97–102`

---

### A02-13 [LOW] — setSimpleSpinner(): no test for invalid stringArrayId

`setSimpleSpinner()` (line 104) passes a raw resource ID to `ArrayAdapter.createFromResource()`. No test verifies behaviour when an invalid or zero resource ID is supplied, which would throw a `Resources.NotFoundException` at runtime.

**Location:** `BaseFragment.java:104–109`

---

### A02-14 [LOW] — addFragment() instance variants: no test for backStack=true path

The instance `addFragment(Fragment, int, boolean)` (line 315) has a conditional `ft.addToBackStack(null)` branch. The branch is untested. The static overload (line 296) has the same gap.

**Location:** `BaseFragment.java:296–303`, `315–323`

---

### A02-15 [LOW] — removeSelfFromParent(): no test for null parent fragment path

`removeSelfFromParent()` (line 324) does nothing when `getParentFragment()` returns null. There is no test verifying the silent no-op behaviour when the fragment has no parent.

**Location:** `BaseFragment.java:324–332`

---

## File 2: BaseSubFragment.java

### Reading Evidence

**Fully qualified class name:** `com.yy.libcommon.BaseSubFragment`
**Superclass:** `java.lang.Object` (no extension)
**Implements:** (none)

**Fields defined:**
- `mRootView` — `protected ViewGroup` (line 13)
- `mBaseController` — `protected BaseController` (line 14)
- `mBaseActivity` — `protected BaseActivity` (line 15)
- `isHidden` — `protected boolean`, default `true` (line 16)

**Constants defined:** (none)

**Methods with line numbers and signatures:**

| Line | Signature |
|------|-----------|
| 18 | `public BaseSubFragment(BaseController baseController, BaseActivity activity)` (constructor) |
| 25 | `public void onActive(View rootView)` |
| 30 | `public void onActive()` |
| 34 | `public boolean isActive()` |
| 38 | `public void onHidden()` |
| 43 | `public void onDestroy()` |

---

### A02-16 [MEDIUM] — onActive(View rootView): no test for null rootView cast

`onActive(View rootView)` (line 25) performs an unchecked cast `(ViewGroup) rootView`. If a caller passes a `View` that is not a `ViewGroup` (e.g., a `TextView`), a `ClassCastException` is thrown at runtime. There is no test exercising this contract or the null-rootView case (which would assign `mRootView = null`, reverting the activated state partially while still setting `isHidden = false`).

**Location:** `BaseSubFragment.java:25–28`

---

### A02-17 [LOW] — isActive(): no test for state transitions

`isActive()` (line 34) returns `!isHidden`. The default state is `isHidden = true` (i.e., `isActive()` returns `false`). There is no test verifying the full lifecycle: constructor -> `isActive()` == false, after `onActive()` -> `isActive()` == true, after `onHidden()` -> `isActive()` == false.

**Location:** `BaseSubFragment.java:16`, `30–36`, `38–40`

---

### A02-18 [LOW] — onDestroy(): no test for empty body override contract

`onDestroy()` (line 43) is an intentional empty hook for subclasses to override. There is no test verifying that subclasses are expected to call `super.onDestroy()` or that the empty base implementation does not inadvertently suppress subclass behaviour. The related `SubFragPermission.onDestroy()` (which does meaningful work: unregistering a broadcast receiver) overrides this method without calling `super`.

**Location:** `BaseSubFragment.java:43–45`

---

### A02-19 [INFO] — Constructor: no test verifying both fields are set

The constructor (line 18) assigns both `mBaseActivity` and `mBaseController`. There is no test verifying that passing `null` for either parameter does not cause immediate failure, and that the stored references are what was passed (basic constructor contract).

**Location:** `BaseSubFragment.java:18–23`

---

## File 3: BaseThemedDialog.java

### Reading Evidence

**Fully qualified class name:** `com.yy.libcommon.BaseThemedDialog`
**Superclass:** `com.yy.libcommon.BaseDialog` (which extends `android.support.v4.app.DialogFragment`)
**Implements:** (via `BaseDialog`) `com.yy.libcommon.BaseController`

**Constants defined:**
- `DIALOG_SHADOW_WIDTH` — `private static final int` = `16` (line 25)
- `LOLLIPOP_DIALOG_SHADOW_WIDTH` — `private static final int` = `32` (line 26)
- `VIBRATION_DURATION_MS` — `private static final int` = `10` (line 27)
- `TITLE_BAR_HEIGHT` — `private static final int` = `60` (line 28)

**Fields defined:**
- `mLayoutView` — `protected ViewGroup` (line 30)
- `layoutResource` — `protected int` (line 31)
- `mMainLayout` — `protected RelativeLayout` (line 32)
- `mRequests` — `protected ArrayList<String>` (line 33)
- `mLayoutWidth` — `private int` (line 34)
- `mVibrator` — `private Vibrator` (line 35)
- `mVibrateButtons` — `private ArrayList<View>` (line 36)
- `base_themed_dialog_right_text_view` — `public TextView` (line 37)
- `base_themed_dialog_left_text_view` — `public TextView` (line 38)
- `headerRightText` — `public String` (line 40)
- `headerLeftText` — `public String` (line 41)
- `base_themed_dialog_titleView` — `protected View` (line 43)
- `mTitle` — `protected String` (line 44)
- `isWideDialog` — `protected boolean`, default `false` (line 46)

**Methods with line numbers and signatures:**

| Line | Signature |
|------|-----------|
| 48 | `protected void onLeftButton()` |
| 52 | `protected void onRightButton()` |
| 57 | `@Override protected void setupViews()` |
| 89 | `@Override public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState)` |
| 108 | `public BaseThemedDialog()` (constructor) |
| 112 | `public void setLayout(int layoutResource)` |
| 116 | `public void setTitleText(String titleText)` |
| 122 | `protected void inflateLayout(LayoutInflater inflater)` |
| 156 | `@Override public void onActivityCreated(Bundle savedInstanceState)` |
| 162 | `private void setViewParams()` |
| 166 | `protected View findViewById(int viewId)` |
| 171 | `private int getCurrentWidth()` |
| 175 | `private int getCurrentHeight()` |
| 179 | `protected void vibrateOnPress(View view)` |
| 199 | `protected void setLayoutClickable(View view, boolean enabled)` |
| 203 | `private void vibrate()` |
| 207 | `private void vibrate(int duration)` |
| 211 | `@Override public void onPause()` |

---

### A02-20 [HIGH] — inflateLayout(): mLayoutWidth left as 0 when layoutResource <= 0; setViewParams() then sets window width to 0

`inflateLayout()` (line 122) only sets `mLayoutWidth` inside the `if (layoutResource > 0)` block (lines 124–141). If `setLayout()` is never called, or is called with `0`, `mLayoutWidth` remains the Java default of `0`. `setViewParams()` (line 163) is called from `onActivityCreated()` (line 158) and passes `mLayoutWidth` directly to `getDialog().getWindow().setLayout()`. A dialog displayed without a layout resource set will have its window width forced to `0` pixels. There is no guard and no test covering this path.

**Location:** `BaseThemedDialog.java:122–141`, `162–164`

---

### A02-21 [HIGH] — inflateLayout(): duplicate setup code creates inconsistent state risk

`inflateLayout()` (lines 143–151) repeats verbatim the same setup code that `onCreateView()` (lines 95–103) already executes: creating a new `Vibrator`, re-initialising `mVibrateButtons` to a fresh `ArrayList`, requesting `FEATURE_NO_TITLE`, setting soft-input mode, and re-assigning `base_themed_dialog_titleView`, `base_themed_dialog_right_text_view`, and `base_themed_dialog_left_text_view`. Any `mVibrateButtons` entries added between `onCreateView()` and `inflateLayout()` (which would be unusual but possible in a subclass) would be silently discarded. There is no test verifying the initialisation order or catching this duplication.

**Location:** `BaseThemedDialog.java:89–106`, `143–152`

---

### A02-22 [HIGH] — vibrate(int duration): Long conversion via String is fragile

`vibrate(int duration)` (line 207) converts the `int` to `long` via `Long.valueOf(String.valueOf(duration))`. This is an unnecessary double-conversion through string parsing. While functionally correct for normal non-negative values, if `duration` were negative, `mVibrator.vibrate()` would receive a negative `long`, which on some Android versions throws `IllegalArgumentException`. There is no test verifying: (a) the correct duration is passed, (b) the behaviour with zero duration, or (c) that a negative duration does not crash.

**Location:** `BaseThemedDialog.java:207–209`

---

### A02-23 [MEDIUM] — setupViews(): no test for null headerRightText / headerLeftText visibility toggle

`setupViews()` (line 57) checks `headerRightText != null && headerRightText.length() > 0` (line 73) and similarly for `headerLeftText` (line 80). Four states are possible: both null, both empty strings, one set and one not, both set. There is no test exercising these visibility-toggling branches. An empty-string input (length 0) hides the button just as null does — this boundary condition is untested.

**Location:** `BaseThemedDialog.java:73–85`

---

### A02-24 [MEDIUM] — setTitleText(): no test for null titleText guard (and NPE when mRootView is null)

`setTitleText()` (line 116) guards against null `titleText` but performs `mRootView.findViewById(...)` without guarding against `mRootView` being null. If called before `onCreateView()` has run, `mRootView` is null and a `NullPointerException` is thrown. There is no test verifying: (a) the null `titleText` no-op, (b) a valid title is set correctly, or (c) a call before view inflation fails safely.

**Location:** `BaseThemedDialog.java:116–119`

---

### A02-25 [MEDIUM] — vibrateOnPress(): iterates all mVibrateButtons and resets listeners on every call

`vibrateOnPress(View view)` (line 179) adds the given view to `mVibrateButtons`, then iterates the entire list and re-attaches `OnTouchListener` to every view already in it. Each subsequent call to `vibrateOnPress()` attaches a new listener to all previously registered views, effectively adding duplicate listeners (each touch will fire multiple `vibrate()` calls). There is no test verifying that calling `vibrateOnPress()` multiple times does not multiply vibration events.

**Location:** `BaseThemedDialog.java:179–197`

---

### A02-26 [MEDIUM] — inflateLayout(): no test for isWideDialog=true branch (screen-width calculation)

When `isWideDialog` is `true` (line 132), `mLayoutWidth` is set to `(int)(screenWidth * 0.9)`. The shadow-width addition is applied in both branches, but the wide-dialog branch does not measure the layout view — it uses a fixed 90% of screen width. There is no test covering this branch, including edge cases such as very small screen widths where `(int)(screenWidth * 0.9)` rounds to an unexpectedly small value.

**Location:** `BaseThemedDialog.java:128–140`

---

### A02-27 [MEDIUM] — inflateLayout(): no test for Build.VERSION.SDK_INT branch (Lollipop vs pre-Lollipop shadow)

Line 136 branches on `Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP` to apply either 32dp or 16dp of shadow width. Neither branch is tested. This is the kind of SDK-version conditional that is easily broken by changes to `DIALOG_SHADOW_WIDTH` or `LOLLIPOP_DIALOG_SHADOW_WIDTH` constants.

**Location:** `BaseThemedDialog.java:136–140`

---

### A02-28 [MEDIUM] — getCurrentHeight(): TITLE_BAR_HEIGHT subtracted in pixels despite Util.dpToPx conversion

`getCurrentHeight()` (line 175) returns `mRootView.getMeasuredHeight() - Util.dpToPx(TITLE_BAR_HEIGHT, getContext())`. The constant `TITLE_BAR_HEIGHT = 60` represents 60dp, and `Util.dpToPx` converts it to pixels before subtracting. This is correct intent. However, neither `getCurrentWidth()` nor `getCurrentHeight()` are called anywhere in the class — both are dead (unused) private methods. There is no test verifying their output, and their inaccessibility from outside the class means they can never be exercised via standard testing.

**Location:** `BaseThemedDialog.java:171–177`

---

### A02-29 [LOW] — setLayout(): no test for zero or negative layoutResource

`setLayout(int layoutResource)` (line 112) assigns the resource ID with no validation. A zero or negative value skips the entire `inflateLayout()` block (line 124: `if (layoutResource > 0)`), leaving `mLayoutView` null. Any subsequent call to `findViewById(int viewId)` (line 166) will then throw a `NullPointerException` on `mLayoutView.findViewById(viewId)`. There is no test verifying this chain of failure.

**Location:** `BaseThemedDialog.java:112–114`, `166–168`

---

### A02-30 [LOW] — onLeftButton() / onRightButton(): empty hook methods with no test verifying override contract

Both `onLeftButton()` (line 48) and `onRightButton()` (line 52) are empty protected hook methods intended for subclass override. There is no test verifying that the click listeners in `setupViews()` (lines 61–72) correctly dispatch to these methods. A subclass could override one without realising the listener is wired in the base class, and no test would catch a broken wiring.

**Location:** `BaseThemedDialog.java:48–54`, `57–86`

---

### A02-31 [INFO] — FILE_EDIT_NOTIFY and CAMERA_NOTIFY constants in SubFragPermission have identical values

Noted in the context of `BaseFragment.takePhoto()` and the permission system it relies on: `SubFragPermission` (line 25–26) defines both `FILE_EDIT_NOTIFY` and `CAMERA_NOTIFY` as the same string `"com.fleetiq.fleetiq360.file"`. The `broadcastReceiver.onReceive()` dispatches on `intent.getAction()` — but since both actions are the same string, the file-permission and camera-permission broadcast paths are indistinguishable. A camera-permission broadcast will also trigger the file-permission handler, and vice versa. This is a logic defect in the permission subsystem that `BaseFragment.takePhoto()` depends on. There is no test that would catch this collision.

**Location:** `SubFragPermission.java:25–26`, `95–109` (supporting context for `BaseFragment.takePhoto()`)

---

## Summary Table

| ID | File | Severity | Description |
|----|------|----------|-------------|
| A02-1 | (project-wide) | HIGH | Zero automated test coverage in app/ and LibCommon/ |
| A02-2 | BaseFragment | HIGH | takePhoto(): null return from createLocalImageFile() untested |
| A02-3 | BaseFragment | HIGH | takePhoto(): null resolveActivity() (no camera app) silent failure untested |
| A02-4 | BaseFragment | MEDIUM | takePhoto(): camera permission denied deferral path untested |
| A02-5 | BaseFragment | MEDIUM | takePhoto(): file/storage permission denied deferral path untested |
| A02-6 | BaseFragment | MEDIUM | Static initializer: reflection failure leaves sChildFragmentManagerField null; onDetach graceful-degradation untested |
| A02-7 | BaseFragment | MEDIUM | onStop(): NPE if subFragPermission null (missing null guard, unlike onDestroy) |
| A02-8 | BaseFragment | MEDIUM | showToast(): suppression when not resumed is untested |
| A02-9 | BaseFragment | MEDIUM | Progress delegation methods: isDestroyed guard behaviour untested |
| A02-10 | BaseFragment | MEDIUM | removeFragment(): null fragment from findFragmentById causes NPE/IAE, untested |
| A02-11 | BaseFragment | LOW | showDialog() 3 overloads: entirely untested |
| A02-12 | BaseFragment | LOW | getScreenWidth(): NPE if called before attach, untested |
| A02-13 | BaseFragment | LOW | setSimpleSpinner(): invalid resource ID throws NotFoundException, untested |
| A02-14 | BaseFragment | LOW | addFragment() backStack=true branch untested |
| A02-15 | BaseFragment | LOW | removeSelfFromParent(): null parent silent no-op untested |
| A02-16 | BaseSubFragment | MEDIUM | onActive(View): non-ViewGroup cast throws ClassCastException, untested |
| A02-17 | BaseSubFragment | LOW | isActive(): full lifecycle state-transition sequence untested |
| A02-18 | BaseSubFragment | LOW | onDestroy(): empty hook override contract untested |
| A02-19 | BaseSubFragment | INFO | Constructor null parameter contract untested |
| A02-20 | BaseThemedDialog | HIGH | inflateLayout(): mLayoutWidth=0 when no layoutResource set; window width forced to 0px |
| A02-21 | BaseThemedDialog | HIGH | inflateLayout(): duplicate setup vs onCreateView() can silently discard mVibrateButtons entries |
| A02-22 | BaseThemedDialog | HIGH | vibrate(int): String-based Long conversion; negative duration crashes on some Android versions, untested |
| A02-23 | BaseThemedDialog | MEDIUM | setupViews(): header text visibility toggle boundary conditions (null vs empty) untested |
| A02-24 | BaseThemedDialog | MEDIUM | setTitleText(): NPE when mRootView null (called before onCreateView), untested |
| A02-25 | BaseThemedDialog | MEDIUM | vibrateOnPress(): re-attaches listeners on every call, multiplying vibration events, untested |
| A02-26 | BaseThemedDialog | MEDIUM | inflateLayout(): isWideDialog=true branch (90% screen width) untested |
| A02-27 | BaseThemedDialog | MEDIUM | inflateLayout(): SDK_INT Lollipop branch for shadow width untested |
| A02-28 | BaseThemedDialog | MEDIUM | getCurrentWidth()/getCurrentHeight() are dead private methods; never callable, untestable |
| A02-29 | BaseThemedDialog | LOW | setLayout(): zero/negative layoutResource leaves mLayoutView null, subsequent findViewById() NPEs untested |
| A02-30 | BaseThemedDialog | LOW | onLeftButton()/onRightButton() hook dispatch from click listeners untested |
| A02-31 | (SubFragPermission) | INFO | FILE_EDIT_NOTIFY and CAMERA_NOTIFY share identical broadcast action string, causing cross-handler dispatch; untested in context of BaseFragment.takePhoto() |
