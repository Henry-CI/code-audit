# Audit Pass 2 — Agent A08
**Audit run:** 2026-02-26-01
**Agent:** A08
**Files assigned:**
1. `LibCommon/src/main/java/com/yy/libcommon/SignatureDialog.java`
2. `LibCommon/src/main/java/com/yy/libcommon/SquareImageView.java`
3. `LibCommon/src/main/java/com/yy/libcommon/SubFragPermission.java`

---

## Project-Wide Finding

### A08-1 — HIGH: Zero automated test coverage across app/ and LibCommon/ modules

**Severity:** HIGH

No test directories exist under either the `app/` module or the `LibCommon/` module. A search for `**/test/**/*.java` and `**/androidTest/**/*.java` across the entire repository found test files only in third-party library modules (`LibImageloader`, `LibImagePicker`, `LibPercentProgress`). No first-party production code in `app/` or `LibCommon/` has any automated test coverage of any kind — unit, integration, or instrumentation.

This means every finding below describing an untested method, error path, or edge case reflects a gap that exists with no mitigating test safety net anywhere in the first-party codebase.

---

## File 1: SignatureDialog.java

### Reading Evidence

**Fully qualified class name:** `com.yy.libcommon.SignatureDialog`
**Superclass:** `com.yy.libcommon.BaseDialog` (which extends `DialogFragment`)

**Constants defined:**
- `BLOB_REF_KEY` (private static final String, line 26) — bundle argument key `"BLOB_REF_KEY"`

**Fields:**
- `mRootView` (ViewGroup, line 29)
- `mDrawingView` (DrawingView, line 30)
- `mClearButton` (Button, line 31)
- `mCancelButton` (Button, line 32)
- `mSaveButton` (Button, line 33)
- `filePath` (String, package-private, line 36)
- `mSignatureCallback` (SignatureCallback, line 37)

**Inner interface defined:**
- `SignatureCallback` (line 207–209): single method `callBack(String filePath)`

**Methods (with line numbers):**
| Line | Signature |
|------|-----------|
| 40   | `public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState)` |
| 55   | `public static SignatureDialog newInstance(String path)` |
| 63   | `public void setCallback(SignatureCallback signatureCallback)` |
| 68   | `public void onActivityCreated(Bundle savedInstanceState)` |
| 76   | `public void init()` |
| 80   | `public void findViews()` |
| 87   | `public void setupViews()` |
| 93   | `private void setUpViewListeners()` |
| 114  | `private void onSavePress()` |
| 157  | `private void onCancelPress()` |
| 161  | `private boolean saveSignature(Bitmap bitmap)` |
| 193  | `private void updateImageView(String currentPhotoPath)` |

---

### Findings for SignatureDialog.java

#### A08-2 — HIGH: `saveSignature()` swallows IOException silently and callers have no test coverage

**Severity:** HIGH
**Location:** `saveSignature()`, lines 161–190

`saveSignature(Bitmap bitmap)` catches `IOException` at line 185, calls `e.printStackTrace()`, and returns `false`. The caller (`onSavePress()`, line 120) handles `false` by showing a generic error dialog. No test verifies:
- That a write failure correctly causes `onSavePress()` to show the error dialog.
- That `filePath` remains unchanged (it is only updated on success at line 181) when a failure occurs.
- The IOException path is exercised at all.

The disk-write failure path is an important correctness boundary — a user believes they have saved a signature but the file was not written. Without a test, regressions in this path are invisible.

---

#### A08-3 — HIGH: `saveSignature()` receives a null Bitmap with no null-guard

**Severity:** HIGH
**Location:** `saveSignature()`, lines 161–190; called from `onSavePress()`, line 120

`onSavePress()` calls `mDrawingView.getDrawingCache()` (line 120) and passes the result directly to `saveSignature()`. `DrawingView.getDrawingCache()` can return `null` if the drawing cache has not been built or has been invalidated. Inside `saveSignature()` there is no null-check on `bitmap` before calling `bitmap.compress(...)` at line 176, which will throw a `NullPointerException`. There is no test covering the null-bitmap path, and no test verifying the drawing cache is always valid at the point of the save press.

---

#### A08-4 — MEDIUM: `onSavePress()` logic inversion — "hasImage" comment is wrong, untested

**Severity:** MEDIUM
**Location:** `onSavePress()`, lines 135–154

When `mDrawingView.hasBeenDrawnOn()` is false, the code branches on `!mDrawingView.hasImage()` (line 137). The inline comment reads `// EditText not empty`, which is incorrect — there is no EditText. The actual intent appears to be: if there is no pre-existing image, show the "Please sign!" error. But the comment suggests the logic was copy-pasted from a different feature and may not reflect the intended condition. No test validates the three-branch decision tree:
1. Drawing has occurred → save.
2. No drawing, no pre-existing image → show error.
3. No drawing, but pre-existing image exists → accept the existing image and dismiss.

Branch 3 in particular (accepting a pre-existing signature without redrawing) has subtle correctness implications that require a test to verify intent.

---

#### A08-5 — MEDIUM: `newInstance()` passes `path` as `Serializable` but reads it back as `getString()`

**Severity:** MEDIUM
**Location:** `newInstance()`, line 58; `onCreateView()`, line 49

`bundle.putSerializable(BLOB_REF_KEY, path)` (line 58) stores the value using `putSerializable()`. `getArguments().getString(BLOB_REF_KEY)` (line 49) retrieves it using `getString()`. On Android, `getString()` on a key stored via `putSerializable()` returns `null` for all Android API levels. This means `filePath` will always be `null` when the dialog is opened with a pre-existing path, so `setupViews()` will never call `updateImageView()` and the signature view will never be pre-populated. No test exercises the round-trip: create dialog with a non-null path, confirm `filePath` is populated in `onCreateView()`.

---

#### A08-6 — MEDIUM: `updateImageView()` calls `Util.decodeFile()` with no null-check on returned Bitmap

**Severity:** MEDIUM
**Location:** `updateImageView()`, lines 193–204

`Util.decodeFile(currentPhotoPath, getScreenWidth())` may return `null` if the file does not exist or cannot be decoded. The result is passed directly to `mDrawingView.setImageBitmap(imageBitmap)` (line 198). Inside `DrawingView.setImageBitmap()` (a separately audited class), the call `bitmap.copy(...)` at line 91 of `DrawingView.java` will throw a `NullPointerException` if `bitmap` is null. No test covers the case of `updateImageView()` being called with a path that maps to an unreadable or missing file.

---

#### A08-7 — MEDIUM: `saveSignature()` does not close `FileOutputStream` on exception (resource leak)

**Severity:** MEDIUM
**Location:** `saveSignature()`, lines 163–189

`FileOutputStream fo` is opened at line 177. If `fo.write(bytes.toByteArray())` (line 178) throws an `IOException`, the stream is never closed because the `fo.close()` at line 179 is inside the try block, not in a finally block. This leaks a file descriptor on write failure. No test triggers this failure mode to verify resource cleanup.

---

#### A08-8 — LOW: `mSignatureCallback` nullability is not tested when callback is absent

**Severity:** LOW
**Location:** `onSavePress()`, lines 122–124 and lines 147–149

Both success branches in `onSavePress()` guard the callback call with `if (mSignatureCallback != null)`. The callback can be legitimately absent. No test verifies that the dialog dismisses correctly and does not crash when no callback is registered, for either the "new signature saved" path or the "pre-existing image accepted" path.

---

#### A08-9 — LOW: `onCancelPress()` has no test

**Severity:** LOW
**Location:** `onCancelPress()`, lines 157–159

`onCancelPress()` calls `dismiss()`. While trivial, no test verifies that pressing Cancel dismisses the dialog and does not invoke the callback.

---

#### A08-10 — INFO: Hardcoded error message string contains a double comma typo

**Severity:** INFO
**Location:** `onSavePress()`, line 130

The error message `"Failed to save, , please check your internet connection and retry."` contains a double comma. Additionally, the message references "internet connection", which is misleading — saving a signature is a local disk operation and does not require network connectivity. No test checks the content of error messages shown to the user.

---

## File 2: SquareImageView.java

### Reading Evidence

**Fully qualified class name:** `com.yy.libcommon.SquareImageView`
**Superclass:** `android.widget.ImageView`

**Constants defined:** None

**Methods (with line numbers):**
| Line | Signature |
|------|-----------|
| 13   | `public SquareImageView(Context context)` |
| 17   | `public SquareImageView(Context context, AttributeSet attrs)` |
| 21   | `public SquareImageView(Context context, AttributeSet attrs, int defStyle)` |
| 25   | `protected void onDraw(Canvas canvas)` |
| 30   | `@Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec)` |

---

### Findings for SquareImageView.java

#### A08-11 — MEDIUM: `onMeasure()` always forces height equal to width, ignoring `heightMeasureSpec` entirely — untested

**Severity:** MEDIUM
**Location:** `onMeasure()`, lines 30–33

`setMeasuredDimension(getMeasuredWidth(), getMeasuredWidth())` forces both dimensions to the measured width unconditionally, discarding `heightMeasureSpec` entirely. This means:
- When the view is placed in a layout that constrains height (e.g., a `RecyclerView` with fixed row height or a `ConstraintLayout` with explicit height constraints), the width will be used for both dimensions. If the constrained height is smaller than the available width, content will be clipped. If larger, extra whitespace appears.
- No test verifies the squaring behavior under varied `MeasureSpec` modes (`EXACTLY`, `AT_MOST`, `UNSPECIFIED`) for both dimensions.
- No test verifies that the view behaves correctly when width is zero or unspecified.

---

#### A08-12 — LOW: `onDraw()` is a pass-through with no added behavior — pointless override, untested

**Severity:** LOW
**Location:** `onDraw()`, lines 25–27

`onDraw(Canvas canvas)` calls `super.onDraw(canvas)` and does nothing else. This override adds no behavior and should not exist. No test confirms the draw behavior is equivalent to the superclass implementation. While harmless today, the empty override is a maintenance hazard — future developers may add drawing logic here expecting it to interact correctly with the squaring measurement.

---

## File 3: SubFragPermission.java

### Reading Evidence

**Fully qualified class name:** `com.yy.libcommon.SubFragPermission`
**Superclass:** `com.yy.libcommon.BaseSubFragment`

**Constants defined:**
| Line | Name | Value |
|------|------|-------|
| 25   | `FILE_EDIT_NOTIFY` (instance final String) | `"com.fleetiq.fleetiq360.file"` |
| 26   | `CAMERA_NOTIFY` (instance final String)    | `"com.fleetiq.fleetiq360.file"` |
| 178  | `REQUEST_FILE_PERMISSION` (public static final int) | `100` |
| 179  | `REQUEST_CAMERA_PERMISSION` (public static final int) | `200` |

**Fields:**
- `cameraPendingRunnable` (public Runnable, line 28)
- `filePendingRunnable` (public Runnable, line 29)
- `broadcastReceiver` (BroadcastReceiver anonymous class, lines 87–112)

**Methods (with line numbers):**
| Line | Signature |
|------|-----------|
| 32   | `public SubFragPermission(BaseActivity baseActivity, BaseController baseController)` |
| 37   | `public void onCameraFeatureEnabled()` |
| 50   | `public void onCameraFeatureDisabled()` |
| 61   | `public void onFileFeatureEnabled()` |
| 74   | `public void onFileFeatureDisabled()` |
| 87   | `BroadcastReceiver.onReceive(Context context, Intent intent)` (anonymous class) |
| 114  | `public void onActive()` |
| 123  | `public void onHidden()` |
| 128  | `public void onDestroy()` |
| 132  | `public boolean checkCameraPermissionWithRun(Runnable runnable)` |
| 150  | `public static boolean isFilePermissionEnabled(Context context)` |
| 159  | `public boolean checkFilePermissionWithRun(Runnable runnable)` |
| 180  | `public void requestFilePermission()` |
| 191  | `public void requestCameraPermission()` |
| 202  | `public void onRequestPermissionsResult(int requestCode, String permissions[], int[] grantResults)` |

---

### Findings for SubFragPermission.java

#### A08-13 — CRITICAL: `FILE_EDIT_NOTIFY` and `CAMERA_NOTIFY` are identical strings — broadcast routing is broken

**Severity:** CRITICAL
**Location:** Lines 25–26

```java
final String FILE_EDIT_NOTIFY = "com.fleetiq.fleetiq360.file";
final String CAMERA_NOTIFY    = "com.fleetiq.fleetiq360.file";
```

Both action strings are identical. In `broadcastReceiver.onReceive()` (lines 95–109), the receiver evaluates both `intent.getAction().equals(CAMERA_NOTIFY)` and `intent.getAction().equals(FILE_EDIT_NOTIFY)`. Because the strings are equal, every broadcast with action `"com.fleetiq.fleetiq360.file"` will match both `if` blocks and trigger both `onCameraFeatureEnabled/Disabled` AND `onFileFeatureEnabled/Disabled` simultaneously — regardless of which permission was actually granted or denied.

Additionally, `IntentFilter` at lines 116–118 registers for both actions, but since they are identical only one registration slot is effectively used.

This is a functional defect that causes incorrect state transitions whenever any permission broadcast is received. No test validates that a camera permission result triggers only camera callbacks, or that a file permission result triggers only file callbacks.

---

#### A08-14 — HIGH: `onRequestPermissionsResult()` does not handle empty `grantResults` array safely — NPE risk on denial

**Severity:** HIGH
**Location:** `onRequestPermissionsResult()`, lines 202–230

The result handling at lines 207 and 218 checks `grantResults.length > 0` before accessing `grantResults[0]`, which is correct. However, if the system calls this method with a null `grantResults` array (which is possible on some OEM Android builds), `grantResults.length` will throw a `NullPointerException`. No test exercises:
- Null `grantResults` array.
- Empty `grantResults` array (length 0) — currently falls through to the else branch (denied), which is the correct behavior, but is not verified.
- Unknown `requestCode` values — the switch has no default case; unknown codes are silently ignored.

---

#### A08-15 — HIGH: `checkCameraPermissionWithRun()` overwrites `cameraPendingRunnable` without executing the previous one

**Severity:** HIGH
**Location:** `checkCameraPermissionWithRun()`, lines 132–147

If `checkCameraPermissionWithRun(runnable)` is called a second time before the first permission request is resolved (e.g., user triggers two UI actions rapidly), the previous `cameraPendingRunnable` is silently replaced at line 136 with the new one. The first runnable is lost. The same pattern applies to `checkFilePermissionWithRun()` at line 165. No test verifies:
- That rapid successive calls do not drop pending runnables.
- That the stored runnable is cleared after execution to prevent double-execution if `onCameraFeatureEnabled()` is called multiple times.

---

#### A08-16 — HIGH: `cameraPendingRunnable` and `filePendingRunnable` are never cleared after execution

**Severity:** HIGH
**Location:** `onCameraFeatureEnabled()`, lines 37–48; `onFileFeatureEnabled()`, lines 61–73

After `cameraPendingRunnable.run()` is called at line 40, `cameraPendingRunnable` is not set to `null`. Due to finding A08-13 (identical broadcast action strings), every broadcast triggers both feature callbacks, meaning a pending runnable will be re-executed every time a broadcast arrives after the first. Even without A08-13, if `onCameraFeatureEnabled()` is called more than once (e.g., via both the broadcast receiver path and the direct `onRequestPermissionsResult()` path in a race), the runnable executes multiple times. No test covers this double-execution scenario.

---

#### A08-17 — HIGH: `broadcastReceiver` is registered in `onActive()` but never unregistered in `onHidden()`

**Severity:** HIGH
**Location:** `onActive()` lines 114–121; `onHidden()` lines 123–126; `onDestroy()` lines 128–130

`onActive()` registers `broadcastReceiver`. `onHidden()` (lines 123–126) has an empty body — it does not unregister the receiver. `onDestroy()` (line 129) unregisters, but `onDestroy()` may not be called if the parent dialog or fragment is simply hidden rather than destroyed. During the hidden period, the receiver is still live and will process broadcasts, calling `mBaseActivity.showToast()` or running pending runnables even though the UI is hidden or potentially in an inconsistent state. No test verifies that broadcasts received while the component is hidden do not produce unintended side effects.

---

#### A08-18 — MEDIUM: `broadcastReceiver.onReceive()` calls `intent.getAction()` without a null-check

**Severity:** MEDIUM
**Location:** `broadcastReceiver.onReceive()`, lines 95 and 103

`intent.getAction().equals(CAMERA_NOTIFY)` (line 95) and `intent.getAction().equals(FILE_EDIT_NOTIFY)` (line 103) do not guard against `intent.getAction()` returning null. While `LocalBroadcastManager` in practice always sets an action when matching the registered IntentFilter, sending an intent with no action to `LocalBroadcastManager` would cause a `NullPointerException`. No test verifies behavior with a null-action intent.

---

#### A08-19 — MEDIUM: `isFilePermissionEnabled()` uses deprecated `WRITE_EXTERNAL_STORAGE` — untested for Android 10+

**Severity:** MEDIUM
**Location:** `isFilePermissionEnabled()`, lines 150–157

`Manifest.permission.WRITE_EXTERNAL_STORAGE` is deprecated as of Android 10 (API 29) and has no effect on Android 13+ (API 33). On Android 10+ with `requestLegacyExternalStorage=false`, this permission is always granted but the protected storage is not actually accessible via arbitrary paths. The method's return value thus becomes meaninglessly `true` on modern Android while actual file access may still fail. No test verifies the method's semantics across API levels.

---

#### A08-20 — MEDIUM: `onRequestPermissionsResult()` — switch-case has no default; unknown request codes are silently dropped

**Severity:** MEDIUM
**Location:** `onRequestPermissionsResult()`, lines 202–230

If this method is called with a `requestCode` that is neither `REQUEST_FILE_PERMISSION` (100) nor `REQUEST_CAMERA_PERMISSION` (200) — for example, if a subclass or another component in the same Activity uses a different request code and the result is delegated here — the result is silently discarded. The `switch` statement has no `default` case. No test verifies that unrecognised request codes are handled gracefully.

---

#### A08-21 — MEDIUM: `checkCameraPermissionWithRun()` stores runnable before requesting permission — runnable leaks if permission is already granted by the time request returns

**Severity:** MEDIUM
**Location:** `checkCameraPermissionWithRun()`, lines 132–147

When permission is not granted, the method stores `runnable` in `cameraPendingRunnable` (line 136) and then calls `requestCameraPermission()` (line 137). `requestCameraPermission()` itself re-checks `checkSelfPermission` before calling `requestPermissions()` (lines 191–199). If permission is granted in the instant between the two checks (a race that can occur on some Android OEM implementations), `requestPermissions()` is never called, `onRequestPermissionsResult()` is never invoked, and `cameraPendingRunnable` is stored but never executed. No test covers this race window.

---

#### A08-22 — LOW: `onHidden()` is empty — override adds no behavior

**Severity:** LOW
**Location:** `onHidden()`, lines 123–126

`onHidden()` overrides the parent `BaseSubFragment.onHidden()` with an empty body. The parent also has an empty body. This override is a dead stub. The receiver unregistration that logically belongs here (see A08-17) is absent. No test verifies the hidden lifecycle transition.

---

#### A08-23 — LOW: `cameraPendingRunnable` and `filePendingRunnable` are public fields

**Severity:** LOW
**Location:** Lines 28–29

Both `cameraPendingRunnable` and `filePendingRunnable` are declared `public`. Any external code can read or overwrite them directly, bypassing the `checkCameraPermissionWithRun()` / `checkFilePermissionWithRun()` access paths. This breaks encapsulation and makes state transitions harder to reason about. No test verifies that external mutation of these fields does not cause unexpected behavior.

---

#### A08-24 — INFO: `SubFragPermission` constructor argument order does not match `BaseSubFragment` parameter names

**Severity:** INFO
**Location:** `SubFragPermission()`, line 32–34; `BaseSubFragment()`, line 18

`SubFragPermission(BaseActivity baseActivity, BaseController baseController)` calls `super(baseController, baseActivity)` — the arguments are reversed relative to the `SubFragPermission` constructor's parameter order. `BaseSubFragment`'s constructor signature is `(BaseController, BaseActivity)`. While this matches `BaseSubFragment` correctly, the reversal between `SubFragPermission`'s own parameter list and the `super()` call is confusing and is a latent readability and maintenance risk. No test verifies that `mBaseActivity` and `mBaseController` are populated correctly after construction.

---

## Summary Table

| ID     | Severity | File                    | Description |
|--------|----------|-------------------------|-------------|
| A08-1  | HIGH     | Project-wide            | Zero automated test coverage in app/ and LibCommon/ |
| A08-2  | HIGH     | SignatureDialog.java     | `saveSignature()` swallows IOException; failure path untested |
| A08-3  | HIGH     | SignatureDialog.java     | Null Bitmap passed to `saveSignature()` causes NPE; untested |
| A08-4  | MEDIUM   | SignatureDialog.java     | `onSavePress()` three-branch logic contains wrong comment; untested |
| A08-5  | MEDIUM   | SignatureDialog.java     | `putSerializable` / `getString` mismatch means `filePath` is always null |
| A08-6  | MEDIUM   | SignatureDialog.java     | `updateImageView()` passes potentially null Bitmap to `DrawingView.setImageBitmap()` |
| A08-7  | MEDIUM   | SignatureDialog.java     | `FileOutputStream` not closed on write exception — resource leak |
| A08-8  | LOW      | SignatureDialog.java     | Null callback dismiss paths not tested |
| A08-9  | LOW      | SignatureDialog.java     | `onCancelPress()` not tested |
| A08-10 | INFO     | SignatureDialog.java     | Typo in error message; misleading "internet connection" reference |
| A08-11 | MEDIUM   | SquareImageView.java     | `onMeasure()` discards height spec entirely; zero-width edge case untested |
| A08-12 | LOW      | SquareImageView.java     | `onDraw()` is a no-op override; maintenance hazard |
| A08-13 | CRITICAL | SubFragPermission.java  | `FILE_EDIT_NOTIFY` and `CAMERA_NOTIFY` are identical strings — both callbacks always fire |
| A08-14 | HIGH     | SubFragPermission.java  | `onRequestPermissionsResult()` null `grantResults` causes NPE; not tested |
| A08-15 | HIGH     | SubFragPermission.java  | Pending runnable overwritten without executing previous; lost actions untested |
| A08-16 | HIGH     | SubFragPermission.java  | Pending runnables never cleared after execution; double-execution untested |
| A08-17 | HIGH     | SubFragPermission.java  | Broadcast receiver not unregistered in `onHidden()`; leaks while hidden |
| A08-18 | MEDIUM   | SubFragPermission.java  | `intent.getAction()` not null-checked in `onReceive()` |
| A08-19 | MEDIUM   | SubFragPermission.java  | `WRITE_EXTERNAL_STORAGE` deprecated on Android 10+; semantics untested |
| A08-20 | MEDIUM   | SubFragPermission.java  | No default case in `onRequestPermissionsResult()` switch; unknown codes dropped silently |
| A08-21 | MEDIUM   | SubFragPermission.java  | Race window: runnable stored but never executed if permission granted between checks |
| A08-22 | LOW      | SubFragPermission.java  | `onHidden()` is empty dead stub |
| A08-23 | LOW      | SubFragPermission.java  | `cameraPendingRunnable` / `filePendingRunnable` are public — encapsulation broken |
| A08-24 | INFO     | SubFragPermission.java  | Constructor argument order reversal between `SubFragPermission` and `super()` call |
