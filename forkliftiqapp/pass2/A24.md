# Audit Pass 2 — A24
**Audit run:** 2026-02-26-01
**Agent:** A24
**Files assigned:**
1. `app/src/main/java/au/com/collectiveintelligence/fleetiq360/WebService/webserviceclasses/PreStartHelpItem.java`
2. `app/src/main/java/au/com/collectiveintelligence/fleetiq360/WebService/webserviceclasses/PreStartQuestionItem.java`
3. `app/src/main/java/au/com/collectiveintelligence/fleetiq360/WebService/webserviceclasses/RefreshTokenItem.java`

---

## Project-Wide Finding: Zero Automated Test Coverage

**Finding ID:** A24-0
**Severity:** HIGH

The `app/` and `LibCommon/` modules contain no test directories whatsoever. A search across the entire repository for `**/test/**/*.java` and `**/androidTest/**/*.java` yields only two files, both in third-party library modules (`LibImageloader` and `LibImagePicker`/`LibPercentProgress`). No unit tests, no instrumentation tests, and no integration tests exist for any production code in the `app/` or `LibCommon/` modules.

This is a project-wide gap. Every finding below is a specific consequence of that blanket absence. None of the classes, methods, parsing logic, or security-sensitive token handling in the assigned files has any test coverage of any kind.

---

## File 1: PreStartHelpItem.java

### Reading Evidence

**Fully qualified class name:**
`au.com.collectiveintelligence.fleetiq360.WebService.webserviceclasses.PreStartHelpItem`

**Implements:** `java.io.Serializable`

**Fields defined (all public, no accessors):**
| Field | Type | Line |
|---|---|---|
| `id` | `int` | 14 |
| `input_order` | `int` | 15 |
| `input_type` | `String` | 16 |
| `input_label` | `String` | 17 |
| `input_value` | `String` | 18 |
| `input_image` | `String` | 19 |
| `expected_answer` | `String` | 20 |

**Methods defined:**
| Method | Line | Signature |
|---|---|---|
| Default constructor | 22 | `PreStartHelpItem()` |
| JSON constructor | 25 | `PreStartHelpItem(JSONObject jsonObject) throws JSONException` |

**Constants defined:** None.

**Callers identified:** `PreStartHelpResultArray` constructs instances via the JSON constructor (line 26 of `PreStartHelpResultArray.java`).

---

### Findings

#### A24-1 — No test file exists for PreStartHelpItem
**Severity:** LOW

There is no test file corresponding to `PreStartHelpItem.java`. A grep for `PreStartHelpItem` across all `.java` files returns only production sources: the class itself, its result-array wrapper, and a fragment that consumes it. No test exercises either constructor.

**Untested methods:**
- `PreStartHelpItem()` (line 22) — default constructor leaves all fields at their zero/null defaults; no test verifies this starting state.
- `PreStartHelpItem(JSONObject)` (line 25) — JSON parsing constructor; see A24-2 for edge-case gaps.

#### A24-2 — No test covers JSON parsing edge cases in PreStartHelpItem(JSONObject)
**Severity:** MEDIUM

The JSON constructor (lines 25–65) conditionally parses seven fields by checking `jsonObject.isNull(key)` before reading each one. Several edge cases are never tested:

1. **Null JSONObject argument (line 27):** The outer `if (jsonObject != null)` guard is correct, but no test confirms that passing `null` produces a fully zero/null-initialized object rather than throwing.
2. **Missing keys entirely vs. explicit JSON null:** `JSONObject.isNull(key)` returns `true` for both an explicit JSON `null` and an absent key. No test verifies that a key absent from the JSON payload (rather than set to `null`) is handled identically — this distinction matters if the server omits optional fields.
3. **`input_type` and `input_label` as empty strings:** No test verifies that an empty string `""` is accepted, stored as-is, and does not cause downstream rendering failures. These strings drive UI display logic.
4. **`input_order` type mismatch:** `input_order` is read as `getInt()` (line 37). No test verifies behavior when the server returns a floating-point or string value for this field — `JSONException` would propagate uncaught to the caller.
5. **`id` = 0 or negative:** No test verifies that zero or negative IDs are accepted; these could produce lookup failures downstream.

#### A24-3 — expected_answer field in PreStartHelpItem is never validated or tested
**Severity:** LOW

The `expected_answer` field (line 20) is parsed from JSON (lines 60–63) but its purpose in a pre-start help item is ambiguous — help items are guidance content, not questions. No test verifies what value this field holds, whether it can be null, or what the application does if it is null when a downstream caller reads it. The field name implies safety-relevant logic (an "expected answer" to a help prompt) that should be explicitly covered.

---

## File 2: PreStartQuestionItem.java

### Reading Evidence

**Fully qualified class name:**
`au.com.collectiveintelligence.fleetiq360.WebService.webserviceclasses.PreStartQuestionItem`

**Implements:** `java.io.Serializable`

**Fields defined (all public, no accessors):**
| Field | Type | Line |
|---|---|---|
| `id` | `int` | 14 |
| `content` | `String` | 15 |
| `expectedanswer` | `String` | 16 |

**Methods defined:**
| Method | Line | Signature |
|---|---|---|
| Default constructor | 18 | `PreStartQuestionItem()` |
| JSON constructor | 21 | `PreStartQuestionItem(JSONObject jsonObject) throws JSONException` |

**Constants defined:** None.

**Callers identified:**
- `PreStartQuestionResultArray` constructs instances via the JSON constructor (line 26 of `PreStartQuestionResultArray.java`).
- `EquipmentPrestartFragment` holds an `ArrayList<PreStartQuestionItem>` and reads `item.content` directly (line 55) to populate a checklist UI presented to forklift operators before they begin a session.
- `EquipmentPrestartFragment.onMiddleButton()` (line 136) compares `presenter.mapAnswers.size()` against `qustionItemArrayList.size()` to determine whether all questions have been answered before allowing the operator to proceed.

---

### Findings

#### A24-4 — No test file exists for PreStartQuestionItem
**Severity:** MEDIUM

There is no test file for `PreStartQuestionItem.java`. This class carries safety-critical data: the `content` field is the question text shown to forklift operators, and `expectedanswer` is the correct response that the pre-start check process implicitly validates against. No test exercises either constructor.

**Untested methods:**
- `PreStartQuestionItem()` (line 18) — default constructor; no test confirms initial field state.
- `PreStartQuestionItem(JSONObject)` (line 21) — safety-critical parsing path; see A24-5.

#### A24-5 — No test for safety-critical question parsing logic in PreStartQuestionItem(JSONObject)
**Severity:** MEDIUM

The JSON constructor (lines 21–41) is the sole entry point for question data flowing into the forklift pre-start checklist shown to operators. Parsing failures or silent data corruption here directly affect operational safety. The following gaps are untested:

1. **Null JSONObject argument:** The guard `if (jsonObject != null)` (line 23) is present, but no test confirms that passing `null` produces a zero/null-initialized object. If a caller (e.g., `PreStartQuestionResultArray`) receives a malformed JSON array element, it could silently produce a `PreStartQuestionItem` with `content == null` and `expectedanswer == null`, which would then appear in the operator's checklist as a blank question.
2. **`content` field null or absent:** `EquipmentPrestartFragment` reads `item.content` directly (line 55) and passes it to `dataList.add(item.content)`. If `content` is null (because the key was absent in JSON), this adds a `null` string to the list. No test covers this path, and no null guard exists in the fragment.
3. **`expectedanswer` field null or absent:** `expectedanswer` carries the correct answer for each pre-start check question. No test verifies that a null or absent `expectedanswer` from the server is handled gracefully, nor that it does not cause silent acceptance of any operator response (including wrong answers) due to a null comparison downstream.
4. **`id` = 0 or duplicate IDs:** No test verifies behavior with zero, negative, or duplicate `id` values. If two questions share an ID, answer-tracking logic in the presenter may silently discard one answer, allowing an operator to bypass a check.
5. **`content` as empty string:** No test verifies that an empty question string is rejected or handled, preventing a blank checklist item from being presented to the operator.
6. **Large or malformed `content` strings:** No test covers oversized strings or strings containing special characters that might affect UI rendering.

#### A24-6 — expectedanswer field has no validation or type constraint
**Severity:** MEDIUM

The `expectedanswer` field (line 16) is a free-form `String` with no validation. In the context of a forklift pre-start safety check, this field determines the "correct" answer an operator must provide. No test verifies:
- That `expectedanswer` is non-null before it is used in any comparison.
- That its value is one of a constrained set (e.g., "yes"/"no"/"ok") rather than an arbitrary server-provided string.
- That case sensitivity or whitespace differences do not cause a correct operator response to be treated as incorrect (or vice versa), either preventing equipment use or — more critically — allowing unsafe equipment to be approved.

---

## File 3: RefreshTokenItem.java

### Reading Evidence

**Fully qualified class name:**
`au.com.collectiveintelligence.fleetiq360.WebService.webserviceclasses.RefreshTokenItem`

**Implements:** `java.io.Serializable`

**Fields defined (all public, no accessors):**
| Field | Type | Line |
|---|---|---|
| `value` | `String` | 14 |
| `expiration` | `int` | 15 |

**Methods defined:**
| Method | Line | Signature |
|---|---|---|
| Default constructor | 17 | `RefreshTokenItem()` |
| JSON constructor | 20 | `RefreshTokenItem(JSONObject jsonObject) throws JSONException` |

**Constants defined:** None.

**Callers identified:**
- `GetTokenResult` constructs a `RefreshTokenItem` from a nested `"refreshToken"` JSON object (line 52 of `GetTokenResult.java`). `GetTokenResult` also holds its own `value` (access token) and `expiration` fields alongside the refresh token.

---

### Findings

#### A24-7 — No test file exists for RefreshTokenItem
**Severity:** HIGH

There is no test file for `RefreshTokenItem.java`. This class holds authentication credentials — specifically the OAuth/JWT refresh token (`value`) and its expiration timestamp (`expiration`). No test exercises either constructor, no test verifies the token's lifecycle, and no test confirms secure handling of the credential data. Credential-handling code with zero test coverage is a HIGH-severity gap because failures are silent, difficult to detect in production, and have direct security impact.

**Untested methods:**
- `RefreshTokenItem()` (line 17) — default constructor; no test confirms that `value` initializes to `null` (not an empty string or stale value).
- `RefreshTokenItem(JSONObject)` (line 20) — credential-parsing constructor; see A24-8.

#### A24-8 — No test verifies token value is cleared after use or expiry
**Severity:** HIGH

`RefreshTokenItem` holds `value` (the refresh token string) and `expiration` (an integer, presumably a Unix timestamp or TTL). The class is `Serializable`, meaning instances can be persisted to disk or transmitted across process boundaries. No test verifies:

1. **Token cleared after use:** There is no method on `RefreshTokenItem` to nullify or zero out `value` after the token has been exchanged for a new access token. The field is public with no accessor control. No test verifies that callers clear the token after use, meaning a spent token may persist in memory or a serialized form.
2. **Token cleared on expiry:** `expiration` is an `int`. No code in this class enforces expiry — no `isExpired()` method, no validation in the constructor that `expiration` is a future timestamp, and no test confirms that an expired token is rejected rather than accepted. A caller receiving a stale `RefreshTokenItem` with a past `expiration` has no in-class signal that the token is invalid.
3. **`expiration` type width:** `int` holds values up to approximately 2,147,483,647. If `expiration` is a Unix epoch timestamp in seconds, this wraps in January 2038 (the Year 2038 problem). If it is a TTL in seconds, large values could silently overflow to negative, making the token appear already-expired. No test covers this boundary.
4. **`value` field exposed publicly:** The refresh token string is a `public` field with no encapsulation. Any code holding a reference to the object can read or modify the credential without restriction. No test verifies that the credential is not readable from an inappropriate context.
5. **Null `value` after JSON parsing:** If the server omits the `"value"` key or sends it as JSON `null`, `value` remains `null`. No test verifies that a null token is detected and rejected by callers before an authentication attempt is made with it.

#### A24-9 — RefreshTokenItem implements Serializable with no serialVersionUID
**Severity:** LOW

`RefreshTokenItem` implements `Serializable` (line 12) but declares no `serialVersionUID`. This means the JVM auto-generates a `serialVersionUID` based on the class structure. If any field is added, removed, or reordered in a future version, deserialization of previously-persisted instances (e.g., from shared preferences, files, or intent extras) will throw `InvalidClassException`. For a credential-bearing class, this silent breakage could cause authentication failures after an app update. No test covers serialization round-trips or version compatibility.

#### A24-10 — expiration field semantics are undefined and untested
**Severity:** MEDIUM

The `expiration` field (line 15) is an `int` with no documentation, no unit defined (epoch seconds? epoch milliseconds? TTL in seconds?), and no validation in the constructor. No test establishes what a valid expiration value looks like, whether zero or negative values are acceptable, or how the rest of the application interprets this field when deciding whether to attempt a token refresh. Ambiguous expiration semantics in an authentication context can lead to premature token rejection (locking out users) or failure to reject expired tokens (accepting stale credentials).

---

## Summary Table

| ID | Severity | File | Description |
|---|---|---|---|
| A24-0 | HIGH | Project-wide | Zero automated test coverage in `app/` and `LibCommon/` modules |
| A24-1 | LOW | PreStartHelpItem | No test file; both constructors untested |
| A24-2 | MEDIUM | PreStartHelpItem | JSON parsing edge cases untested (null arg, missing keys, type mismatch) |
| A24-3 | LOW | PreStartHelpItem | `expected_answer` field semantics and null handling untested |
| A24-4 | MEDIUM | PreStartQuestionItem | No test file; safety-critical constructors untested |
| A24-5 | MEDIUM | PreStartQuestionItem | Safety-critical question parsing untested (null content, null expectedanswer, duplicate IDs) |
| A24-6 | MEDIUM | PreStartQuestionItem | `expectedanswer` has no validation, type constraint, or comparison-logic tests |
| A24-7 | HIGH | RefreshTokenItem | No test file; credential-bearing constructors untested |
| A24-8 | HIGH | RefreshTokenItem | No test verifies token cleared after use or expiry; public field exposes credential |
| A24-9 | LOW | RefreshTokenItem | No `serialVersionUID`; serialization round-trips untested |
| A24-10 | MEDIUM | RefreshTokenItem | `expiration` field semantics undefined, untested, potential int-width overflow |
