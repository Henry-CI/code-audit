# Audit Pass 2 — Agent A19
**Audit run:** 2026-02-26-01
**Agent:** A19
**Files assigned:**
1. `app/src/main/java/au/com/collectiveintelligence/fleetiq360/WebService/WebApi.java`
2. `app/src/main/java/au/com/collectiveintelligence/fleetiq360/WebService/WebData.java`
3. `app/src/main/java/au/com/collectiveintelligence/fleetiq360/WebService/WebListener.java`

---

## PROJECT-WIDE FINDING

### A19-1 | CRITICAL | Zero Automated Test Coverage Across app/ and LibCommon/ Modules

The `app/` module and the `LibCommon/` module contain no test directories whatsoever. A search of the repository confirms the complete absence of `app/src/test/`, `app/src/androidTest/`, `LibCommon/src/test/`, and `LibCommon/src/androidTest/`. The only test directories found in the entire repository belong to third-party library submodules (`LibImageloader`, `LibImagePicker`, `LibPercentProgress`), none of which contain tests for application code.

All three files assigned to this agent — `WebApi.java`, `WebData.java`, and `WebListener.java` — are part of the core networking and authentication layer of the application. None of them has a corresponding test file, nor are they referenced from any test file anywhere in the codebase. Every finding below is a gap against a background of zero existing test coverage.

**Impact:** Every bug in business logic, every credential-handling error, every authentication failure, and every API error path is invisible to automated regression. Regressions introduced by any future change will not be caught until they reach production devices.

---

## Reading Evidence

### File 1: WebApi.java

**Fully qualified class name:** `au.com.collectiveintelligence.fleetiq360.WebService.WebApi`

**Fields:**
- Line 19: `private static Context mContext` — static, suppressed `@SuppressLint("StaticFieldLeak")`
- Line 20: `private boolean isSynchronous = false`
- Line 21: `private HttpClient httpClient`

**Methods (by line number and signature):**
| Line | Modifier | Signature |
|------|----------|-----------|
| 23 | `public static` | `WebApi sync()` |
| 31 | `public static` | `WebApi async()` |
| 39 | `public static` | `void init(Context context)` |
| 43 | `private <T>` | `void enqueueRequest(GsonRequest<T> gsonRequest)` |
| 47 | `public` | `void resendReport(int uid, int rid, WebListener<CommonResult> resultListener)` |
| 51 | `public` | `void saveShockEvent(SaveShockEventParameter parameter, WebListener<CommonResult> resultListener)` |
| 55 | `public` | `void updateUser(int uid, UpdateUserParameter parameter, WebListener<CommonResult> resultListener)` |
| 59 | `public` | `void addEquipment(AddEquipmentParameter parameter, WebListener<CommonResult> resultListener)` |
| 63 | `public` | `void getEmails(int uid, WebListener<GetEmailResult> resultListener)` |
| 67 | `public` | `void getReports(int uid, WebListener<ReportResultArray> resultListener)` |
| 71 | `public` | `void getEquipmentStats(int uid, int frequency, WebListener<EquipmentStatsResultArray> resultListener)` |
| 84 | `public` | `void getDriverStats(int uid, WebListener<GetDriverStatsResultArray> resultListener)` |
| 88 | `public` | `void saveService(WebServiceParameterPacket parameter, WebListener<WebServiceResultPacket> resultListener)` |
| 92 | `public` | `void getServiceRecord(int uid, WebListener<ServiceRecordResultArray> resultListener)` |
| 96 | `(package-private)` | `void authApp(WebListener<GetTokenResult> resultListener)` |
| 112 | `public` | `void resetPassword(ResetPasswordParameter parameter, WebListener<WebServiceResultPacket> resultListener)` |
| 131 | `public` | `void login(LoginParameter parameter, WebListener<LoginResultArray> resultListener)` |
| 150 | `public` | `void register(UserRegisterParameter parameter, WebListener<LoginItem> resultListener)` |
| 187 | `public` | `void setupEmails(SetEmailsParameter parameter, WebListener<WebServiceResultPacket> resultListener)` |
| 192 | `public` | `void getEquipmentList(int userId, WebListener<GetEquipmentResultArray> resultListener)` |
| 210 | `public` | `void getPreStartQuestionList(int eid, WebListener<PreStartQuestionResultArray> resultListener)` |
| 226 | `public` | `void savePreStartResult(SavePreStartParameter parameter, WebListener<WebServiceResultPacket> resultListener)` |
| 243 | `public` | `void saveSessionStart(EquipmentItem equipmentItem, SessionStartParameter parameter, WebListener<SessionResult> resultListener)` |
| 265 | `public` | `void syncSaveSession(SaveSessionsParameter parameter, WebListener<SessionResult> resultListener)` |
| 269 | `public` | `void deleteSession(int sessionId, WebListener<WebServiceResultPacket> resultListener)` |
| 286 | `public` | `void saveSessionPreEnd(SessionResult sessionResult, SessionEndParameter parameter, WebListener<SessionEndResult> resultListener)` |
| 300 | `public` | `void saveSessionEnd(SessionResult sessionResult, SessionEndParameter parameter, WebListener<SessionEndResult> resultListener)` |
| 321 | `public` | `void getManufacture(WebListener<ManufactureResultArray> resultListener)` |
| 325 | `public` | `void getEquipmentType(int mid, WebListener<EquipmentTypeResultArray> resultListener)` |
| 329 | `public` | `void getFuelType(int mid, int etype, WebListener<FuelTypeResultArray> resultListener)` |
| 333 | `public` | `void saveLicense(SaveLicenseParameter parameter, WebListener<SaveLicenseResult> resultListener)` |
| 337 | `public` | `void saveImpact(ImpactParameter parameter, WebListener<SaveImpactResult> resultListener)` |
| 341 | `public` | `void saveSingleGPSLocation(SaveSingleGPSParameter parameter, WebListener<SaveSingleGPSResult> resultListener)` |
| 345 | `public` | `void saveMultipleGPSLocation(SaveMultipleGPSParameter parameter, WebListener<SaveMultipleGPSResult> resultListener)` |

**Constants/types defined:** None in this file. All result/parameter types are imported from other packages.

---

### File 2: WebData.java

**Fully qualified class name:** `au.com.collectiveintelligence.fleetiq360.WebService.WebData`

**Fields:**
- Line 21: `private static WebData ourInstance` — singleton instance
- Line 22: `private final static String authHeaderType = "Authorization"`
- Line 23: `private final static int MAC_ADDRESS_LENGTH = 17`
- Line 25: `private GetTokenResult getTokenResult`
- Line 27: `private final static String TOKEN_ITEM_KEY = "token_result"`

**Hardcoded credential literals (embedded in `getTokenFormData()`, lines 59–77):**
- `grant_type` = `"password"`
- `client_id` = `"987654321"`
- `client_secret` = `"8752361E593A573E86CA558FFD39E"`
- `username` = `"gas"`
- `password` = `"ciiadmin"`

**Methods (by line number and signature):**
| Line | Modifier | Signature |
|------|----------|-----------|
| 29 | `public static` | `int getTempSessionId()` |
| 36 | `static` | `boolean isOffline()` |
| 40 | `public static` | `boolean isSessionOffline(int sessionId)` |
| 46 | `public static` | `SessionResult getTempSessionResult(SessionStartParameter parameter)` |
| 56 | `public` | `String getTokenFormData()` |
| 84 | `public static` | `WebData instance()` |
| 91 | `(package-private)` | `void setGetTokenResult(GetTokenResult result)` |
| 96 | `public` | `SessionResult getSessionResult()` |
| 100 | `public` | `void onSessionEnded()` |
| 104 | `public static` | `boolean isValidMacAddress(String address)` |
| 108 | `public` | `void logout()` |
| 112 | `public` | `int getUserId()` |
| 117 | `private` | `String getTokenString()` |
| 124 | `(package-private)` | `boolean isAppInitialized()` |
| 129 | `(package-private)` | `void setHttpHeaderForConnection(HttpURLConnection connection)` |
| 134 | `(package-private)` | `String getAuthHeader()` |
| 138 | `(package-private)` | `void setHttpHeader(boolean authMessage, Map<String, String> header)` |

**Constants defined:**
- `authHeaderType` = `"Authorization"` (line 22)
- `MAC_ADDRESS_LENGTH` = `17` (line 23)
- `TOKEN_ITEM_KEY` = `"token_result"` (line 27)

---

### File 3: WebListener.java

**Fully qualified class name:** `au.com.collectiveintelligence.fleetiq360.WebService.WebListener<T>`

**Fields:**
- Line 9: `private static final String TAG = "WebListener"`

**Methods (by line number and signature):**
| Line | Modifier | Signature |
|------|----------|-----------|
| 11 | `public` | `void onSucceed(T result)` — empty default implementation |
| 13 | `public` | `void onFailed(WebResult result)` — empty default implementation |

**Constants/types defined:** Generic type parameter `T`. No other types or constants.

---

## Findings

### A19-2 | CRITICAL | `WebData.getTokenFormData()` — Hardcoded OAuth Client Credentials in Source Code

**File:** `WebData.java`, lines 59–77

**Detail:** The method `getTokenFormData()` builds a URL-encoded OAuth token request body by assembling five credential values that are all hardcoded as string literals in source code:

```java
String clientId = "987654321";                     // line 64
String clientSecret = "8752361E593A573E86CA558FFD39E"; // line 68
String userName = "gas";                           // line 72
String password = "ciiadmin";                      // line 76
```

These credentials are baked into the compiled APK in plaintext. Any attacker who obtains the APK can extract them with a basic APK decompiler (e.g., jadx, apktool) without reverse engineering. The `client_secret` value in particular is an OAuth client secret that should never appear in client-side code at all.

**Test gap:** No test exists that would:
- Detect if any of these credential values are changed or removed (regression guard)
- Verify that the method does not transmit credentials in a log statement
- Assert that the encoded string is well-formed and contains all required fields
- Verify that the `UnsupportedEncodingException` path is handled without silently returning a partial credential string (stack trace is printed but the partial `StringBuilder` result is still returned, potentially causing a malformed OAuth request that could fail in unexpected ways)

**Severity rationale:** The credentials are already committed to version control and compiled into every release APK. The finding is CRITICAL because (a) the credentials are exposed now with no mitigating runtime controls, (b) the OAuth `client_secret` value grants the ability to request tokens against the backend independently of the mobile app, and (c) no test provides any safety net against accidental modification or expansion of the leak.

---

### A19-3 | CRITICAL | `WebData.logout()` — OAuth Token Not Cleared on Logout

**File:** `WebData.java`, lines 108–110

**Detail:**
```java
public void logout() {
    CurrentUser.logout();
}
```

`CurrentUser.logout()` (in `CurrentUser.java`, lines 125–128) clears only the user record from `ModelPrefs` and nulls the static `user` field. It does not touch `WebData.getTokenResult` or the persisted token stored under `TOKEN_ITEM_KEY` in `ModelPrefs`.

The token is persisted to storage by `setGetTokenResult()` (line 91–94):
```java
void setGetTokenResult(GetTokenResult result) {
    getTokenResult = result;
    ModelPrefs.saveObject(TOKEN_ITEM_KEY, result);
}
```

After `logout()` is called:
- The in-memory `getTokenResult` field on the singleton `WebData` instance remains populated.
- The persisted `TOKEN_ITEM_KEY` entry in `ModelPrefs` remains on disk.
- `isAppInitialized()` continues to return `true` because `getTokenString()` still returns the old token.
- `getAuthHeader()` and `setHttpHeader()` continue to attach the old bearer token to requests.

This means a subsequent user (or attacker with device access after the first user logs out) can make authenticated API calls using the previous user's bearer token without re-authenticating.

**Test gap:** No test exists that:
- Calls `logout()` and then asserts `isAppInitialized()` returns `false`
- Calls `logout()` and then asserts `getTokenString()` returns `null`
- Calls `logout()` and then asserts the persisted `TOKEN_ITEM_KEY` is absent from `ModelPrefs`
- Verifies that API calls issued after `logout()` do not carry a valid bearer token

---

### A19-4 | CRITICAL | `WebApi.authApp()` — No Test for OAuth Token Acquisition Failure

**File:** `WebApi.java`, lines 96–110

**Detail:** `authApp()` is the method that acquires the OAuth bearer token by sending the hardcoded credentials to the token endpoint. It is called by `login()`, `register()`, and `resetPassword()` whenever `isAppInitialized()` returns false (i.e., on first run or after token loss).

The `onFailed` branch at lines 106–108 simply forwards the failure to the caller's listener. No test exists that verifies:
- The failure is correctly propagated to the UI layer
- The app does not retry with the same credentials in an infinite loop
- The app does not cache a failed/null token result
- The `WebData.instance().setGetTokenResult(result)` call on success (line 101) is not invoked with a null result

**Severity rationale:** Authentication token acquisition is the gateway to all authenticated API operations. An untested failure path here means any server-side change to the OAuth endpoint or credential rotation will produce silent, undiagnosed failures.

---

### A19-5 | HIGH | `WebApi.login()` — No Test for Any Outcome Path

**File:** `WebApi.java`, lines 131–148

**Detail:** `login()` has two distinct execution paths:
1. **App already initialized** (line 132–135): Directly enqueues a login request.
2. **App not initialized** (lines 137–148): First calls `authApp()`, then enqueues a login request on success, or propagates the `authApp` failure.

No test exists for any of these paths. Specifically untested:
- Successful login response with valid `LoginResultArray`
- Login failure response (`onFailed`) propagated to the caller
- The case where `authApp` itself fails before the login request is issued
- The case where the server returns HTTP 401 or 403 after token acquisition
- Empty or null `LoginResultArray` in the response body

---

### A19-6 | HIGH | `WebApi.register()` — No Test for Null Result Handling or Auth-Gate Path

**File:** `WebApi.java`, lines 150–185

**Detail:** `register()` contains an explicit null check on the result (lines 154–157):
```java
if (result == null) {
    resultListener.onFailed(new WebResult());
    return;
}
```
This is the only null guard of its kind across all `WebApi` methods and suggests the author is aware that the registration endpoint may return a null body. No test verifies this path. Additionally, `register()` calls `CurrentUser.setUser(result)` (line 159) on success with the received `LoginItem`, meaning a malformed but non-null server response could corrupt the current user state. This is also untested.

---

### A19-7 | HIGH | `WebApi.getEquipmentStats()` — Silent No-Op When `frequency` Is Out of Range

**File:** `WebApi.java`, lines 71–82

**Detail:**
```java
public void getEquipmentStats(int uid, int frequency, ...) {
    UrlItem urlItem = null;
    if (frequency == 0) { ... }
    else if (frequency == 1) { ... }
    else if (frequency == 2) { ... }
    enqueueRequest(new GsonRequest<>(urlItem, ...));
}
```

If `frequency` is any value other than 0, 1, or 2, `urlItem` remains `null` and is passed directly to `GsonRequest`. The behavior of `GsonRequest` when given a null `UrlItem` is not visible in this file, but the most likely outcomes are a `NullPointerException` at request-build time or a silent no-op. Neither outcome is communicated to the caller's `resultListener`. No test exists for:
- `frequency = -1` (below range)
- `frequency = 3` (above range)
- `frequency = Integer.MIN_VALUE` or `Integer.MAX_VALUE`
- The comment on line 72 is the only documentation of the valid range; no validation enforces it

---

### A19-8 | HIGH | `WebApi.saveSessionPreEnd()` — Offline Branch Returns Success Without Server Confirmation

**File:** `WebApi.java`, lines 286–298

**Detail:**
```java
if (WebData.isSessionOffline(parameter.id) && !isSynchronous && resultListener != null) {
    resultListener.onSucceed(new SessionEndResult());
    return;
}
```

When the session is offline and the instance is async, `saveSessionPreEnd()` immediately calls `onSucceed` with a freshly constructed, empty `SessionEndResult` object — no server round-trip occurs. The caller receives a success callback with no actual server-confirmed data. No test exists that:
- Verifies the offline success path is taken under the correct conditions
- Verifies the returned `SessionEndResult` is distinguishable from a real server result
- Verifies the session is correctly queued for later synchronization in this path

---

### A19-9 | HIGH | `WebApi.deleteSession()` — Local DB Mutation on Success Not Tested

**File:** `WebApi.java`, lines 269–284

**Detail:** On a successful server response, `deleteSession()` calls `SessionDb.setSessionAborted(sessionId, false)` (line 275). No test exists that:
- Verifies the DB mutation happens when and only when the server returns success
- Verifies the DB state after the `onFailed` path (DB is not mutated on failure)
- Verifies the method handles `sessionId = 0` or negative values

---

### A19-10 | HIGH | `WebApi.saveSessionEnd()` — Side Effects Chain Not Tested

**File:** `WebApi.java`, lines 300–319

**Detail:** On success, `saveSessionEnd()` calls three side-effecting operations in sequence:
```java
SessionDb.setSessionFinished(parameter.id, parameter.finish_time, false);  // line 308
SyncService.startService();                                                  // line 309
WebData.instance().onSessionEnded();                                         // line 310
```

No test exists that verifies:
- All three operations are called in the success path
- None of the three operations is called in the failure path
- The order of operations is correct (DB commit before service start)
- `SyncService.startService()` is not called if `SessionDb.setSessionFinished` throws

---

### A19-11 | HIGH | `WebApi.getEquipmentList()` — DB Write on Success Not Tested

**File:** `WebApi.java`, lines 192–207

**Detail:** On success, `getEquipmentList()` calls `EquipmentDb.saveEquipmentResultArray(userId, result)` before forwarding to the caller. No test verifies:
- The DB write occurs before `resultListener.onSucceed` is called
- The DB write is not attempted when the result is null or empty
- The `onFailed` path does not write to the DB

---

### A19-12 | HIGH | `WebApi.getPreStartQuestionList()` — DB Write on Success Not Tested

**File:** `WebApi.java`, lines 210–224

**Detail:** Identical pattern to A19-11. On success, `PreStartQuestionDb.saveQuestions(eid, result)` is called. No test verifies the DB write contract (write-before-callback, no-write-on-failure, null result handling).

---

### A19-13 | HIGH | `WebApi.savePreStartResult()` — DB Mutation on Success Not Tested

**File:** `WebApi.java`, lines 226–241

**Detail:** On success, `SessionDb.setSessionPreStartFinished(parameter.session_id, parameter, false)` is called. No test verifies:
- This mutation occurs in the success path
- This mutation is absent in the failure path
- The behavior when `parameter.session_id` does not correspond to any existing session record

---

### A19-14 | HIGH | `WebApi.saveSessionStart()` — Business Logic Mutation of Server Response Not Tested

**File:** `WebApi.java`, lines 243–263

**Detail:** On success, `saveSessionStart()` modifies the server's response before passing it to the caller:
```java
if (PreStartHistoryDb.hasPreStartDoneForToday(parameter.driver_id, parameter.unit_id))
    result.prestart_required = false;
```

This is business logic that overrides a server-authoritative field with a local DB lookup. No test exists that:
- Verifies `prestart_required` is set to `false` when the history DB says a pre-start was done today
- Verifies `prestart_required` is not modified when the history DB says no pre-start was done
- Verifies the behavior when `parameter.driver_id` or `parameter.unit_id` is 0 or negative

---

### A19-15 | HIGH | `WebApi.resetPassword()` — Auth-Gate Path Not Tested

**File:** `WebApi.java`, lines 112–129

**Detail:** `resetPassword()` follows the same two-path pattern as `login()`: direct request if initialized, `authApp()` then request otherwise. Neither path is tested. Particularly, the `onFailed` callback from `authApp` is forwarded to the caller without logging or retry. No test verifies that a failed app initialization prevents the password reset request from being sent.

---

### A19-16 | MEDIUM | `WebData.getTokenFormData()` — Silent Partial Return on Encoding Failure

**File:** `WebData.java`, lines 56–82

**Detail:** The `catch (UnsupportedEncodingException e)` block at lines 78–80 calls only `e.printStackTrace()` and falls through, causing the method to return whatever partial string the `StringBuilder` had accumulated at the point of failure. A malformed credential string sent to the OAuth endpoint would produce an opaque authentication failure at the server, with no indication at the call site that encoding failed. No test exercises this exception path.

---

### A19-17 | MEDIUM | `WebData.isValidMacAddress()` — Validation Logic Is Incomplete and Untested

**File:** `WebData.java`, lines 104–106

**Detail:**
```java
public static boolean isValidMacAddress(String address) {
    return (address != null && (address.length() == MAC_ADDRESS_LENGTH));
}
```

The method validates only that the address is non-null and exactly 17 characters long. It does not validate the format (groups of hex digits separated by colons or hyphens). A string such as `"XXXXXXXXXXXXXXXXX"` (17 Xs) would be accepted as a valid MAC address. No test exists for:
- A valid MAC address (positive case)
- A null input
- A string of the correct length but wrong format
- Strings of length 16 and 18 (boundary conditions around `MAC_ADDRESS_LENGTH = 17`)
- An empty string

---

### A19-18 | MEDIUM | `WebData.getTempSessionId()` — Decrement Logic Untested, Negative Overflow Not Guarded

**File:** `WebData.java`, lines 29–34

**Detail:**
```java
public static int getTempSessionId() {
    int sid = ModelPrefs.readInt("last_session_id");
    int ii = sid >= 0 ? -1 : sid - 1;
    ModelPrefs.saveInt("last_session_id", ii);
    return ii;
}
```

If `sid` is `Integer.MIN_VALUE`, `sid - 1` wraps around to `Integer.MAX_VALUE` (a large positive integer). This would cause the returned "temp session ID" to be positive, potentially colliding with a real server-assigned session ID. No test exists for:
- First call (no persisted value / `sid = 0`)
- Repeated calls producing a decreasing sequence
- Behavior when `sid = Integer.MIN_VALUE` (overflow)

---

### A19-19 | MEDIUM | `WebData.isSessionOffline()` — Composite Logic Untested

**File:** `WebData.java`, lines 40–44

**Detail:**
```java
public static boolean isSessionOffline(int sessionId) {
    if (isOffline())
        return true;
    return SessionDb.hasOfflineData(sessionId);
}
```

Two conditions determine the result: network connectivity and the DB offline-data flag. No test verifies:
- Returns `true` when network is absent regardless of DB state
- Returns `true` when network is present but DB has offline data
- Returns `false` when network is present and DB has no offline data
- Behavior with an invalid `sessionId` (-1, 0)

---

### A19-20 | MEDIUM | `WebData.getTokenString()` — Lazy Load from ModelPrefs Not Tested

**File:** `WebData.java`, lines 117–122

**Detail:**
```java
private String getTokenString() {
    if (getTokenResult == null) {
        getTokenResult = (GetTokenResult) ModelPrefs.readObject(TOKEN_ITEM_KEY, GetTokenResult.class);
    }
    return getTokenResult != null ? getTokenResult.value : null;
}
```

The lazy-load from `ModelPrefs` is triggered the first time `getTokenString()` is called after a cold start (or after `getTokenResult` is null). If `ModelPrefs.readObject` returns a `GetTokenResult` with a null or empty `value` field, `isAppInitialized()` would return `false` even though a persisted token record exists. No test verifies:
- Cold-start scenario where token is loaded from storage
- `getTokenResult.value` is null despite a non-null `GetTokenResult` object in storage
- Stale token in storage after server-side revocation

---

### A19-21 | MEDIUM | `WebData.setHttpHeader()` — Auth Header Silently Omitted When Token Is Null

**File:** `WebData.java`, lines 138–146

**Detail:**
```java
void setHttpHeader(boolean authMessage, Map<String, String> header) {
    String auth = getTokenString();
    if (auth != null) {
        String ba = "Bearer " + auth;
        header.put(authHeaderType, ba);
    }
    header.put("Content-Type", ...);
}
```

When `getTokenString()` returns null, the `Authorization` header is silently omitted. The resulting request is sent without authentication. The caller has no way to detect that the header was not set. No test verifies:
- The `Authorization` header is present when a token exists
- The `Authorization` header is absent when no token exists
- The `Content-Type` header is always set regardless of token state

---

### A19-22 | MEDIUM | `WebData.getTempSessionResult()` — Pre-Start State Inversion Untested

**File:** `WebData.java`, lines 46–54

**Detail:**
```java
sessionResult.prestart_required = !PreStartHistoryDb.hasPreStartDoneForToday(
    parameter.driver_id, parameter.unit_id);
```

The boolean inversion (`!`) means `prestart_required` is `true` when no pre-start has been done and `false` when one has. This is a semantic inversion that is easy to get wrong. No test verifies:
- That `prestart_required` is `true` when `hasPreStartDoneForToday` returns `false`
- That `prestart_required` is `false` when `hasPreStartDoneForToday` returns `true`
- That the returned `SessionResult` fields match the input `parameter` fields

---

### A19-23 | MEDIUM | `WebData.instance()` — Singleton Not Thread-Safe

**File:** `WebData.java`, lines 84–88

**Detail:**
```java
public static WebData instance() {
    if (ourInstance == null) {
        ourInstance = new WebData();
    }
    return ourInstance;
}
```

The singleton creation is not synchronized. Two threads calling `instance()` concurrently before the singleton is created can each see `ourInstance == null` and create separate instances. In Android, background threads (e.g., sync services, BLE callbacks) frequently call into `WebData`. No test verifies thread-safety under concurrent access.

---

### A19-24 | LOW | `WebApi.sync()` / `WebApi.async()` — Static `mContext` Set via `init()` Creates Crash Risk

**File:** `WebApi.java`, lines 23–41

**Detail:** `sync()` and `async()` both call `new HttpClient(mContext)` where `mContext` is a static field. If either factory method is called before `init(Context context)` has been called, `mContext` is null and `HttpClient` construction will throw a `NullPointerException`. No test verifies:
- That calling `sync()` before `init()` produces a meaningful error rather than a crash
- That `init()` correctly stores the provided context
- That calling `init()` with a null context is handled

---

### A19-25 | LOW | `WebListener` — Empty Default Implementations Mask Unhandled Callbacks

**File:** `WebListener.java`, lines 11–15

**Detail:** Both `onSucceed` and `onFailed` have empty method bodies as defaults. Any subclass that forgets to override `onFailed` will silently swallow all network errors. Multiple anonymous subclasses of `WebListener` in `WebApi.java` override `onFailed` correctly, but the pattern itself makes it trivially easy to create a silent-failure listener. No test verifies that the default `onFailed` behavior does not cause data loss (e.g., if a session end failure is silently swallowed, the session DB state becomes inconsistent).

---

### A19-26 | LOW | `WebApi` — All Methods Void; No Return Value Allows Cancellation

**File:** `WebApi.java`, all public methods

**Detail:** Every method in `WebApi` returns `void`. Once a request is enqueued, the caller has no handle to cancel it. If the user navigates away from a screen mid-request, the `WebListener` callback may fire against a destroyed Activity context, causing a crash or memory leak. No test verifies cancellation behavior or that callbacks are not invoked after cancellation would be expected.

---

### A19-27 | INFO | `WebData.getTokenFormData()` — Credentials Should Be Supplied via Build Config or Secure Storage

**File:** `WebData.java`, lines 59–77

**Detail:** As a follow-on to A19-2, even if the immediate credential-leakage risk is addressed, the architecture of embedding credentials in source code is fundamentally insecure. Credentials should be injected at build time via `BuildConfig` (keeping them out of version history through CI secrets) or fetched from a secure remote configuration service at first launch. This is an INFO finding because the architectural recommendation does not add new risk beyond A19-2, but is required for a correct remediation path.

---

### A19-28 | INFO | `WebData` — `TOKEN_ITEM_KEY` Persisted Token Has No Expiry Check

**File:** `WebData.java`, lines 117–122

**Detail:** The token loaded from `ModelPrefs` by `getTokenString()` is used as-is without checking whether it has expired. OAuth bearer tokens have a finite lifetime. If the persisted token has expired, `isAppInitialized()` will return `true` and API calls will be sent with an expired bearer token, resulting in 401 responses. No mechanism exists to detect token expiry and trigger re-authentication. This is an INFO finding because the OAuth server will reject the expired token (no silent data corruption), but the user experience (repeated unexplained 401 failures) is poor and the path to re-authentication is unclear from the code.

---

## Summary Table

| ID | Severity | File | Description |
|----|----------|------|-------------|
| A19-1 | CRITICAL | Project-wide | Zero automated test coverage in `app/` and `LibCommon/` modules |
| A19-2 | CRITICAL | WebData.java | Hardcoded OAuth `client_id`, `client_secret`, `username`, `password` in source code |
| A19-3 | CRITICAL | WebData.java | `logout()` does not clear in-memory or persisted OAuth token |
| A19-4 | CRITICAL | WebApi.java | `authApp()` failure paths untested; token acquisition entirely uncovered |
| A19-5 | HIGH | WebApi.java | `login()` — no test for any outcome path or auth-gate branch |
| A19-6 | HIGH | WebApi.java | `register()` — null result handling and user-state mutation untested |
| A19-7 | HIGH | WebApi.java | `getEquipmentStats()` — silent null `UrlItem` when `frequency` out of range |
| A19-8 | HIGH | WebApi.java | `saveSessionPreEnd()` — offline success-without-server path untested |
| A19-9 | HIGH | WebApi.java | `deleteSession()` — DB mutation on success/failure untested |
| A19-10 | HIGH | WebApi.java | `saveSessionEnd()` — three-operation side-effect chain untested |
| A19-11 | HIGH | WebApi.java | `getEquipmentList()` — DB write on success untested |
| A19-12 | HIGH | WebApi.java | `getPreStartQuestionList()` — DB write on success untested |
| A19-13 | HIGH | WebApi.java | `savePreStartResult()` — DB mutation on success untested |
| A19-14 | HIGH | WebApi.java | `saveSessionStart()` — business-logic override of server `prestart_required` field untested |
| A19-15 | HIGH | WebApi.java | `resetPassword()` — auth-gate path untested |
| A19-16 | MEDIUM | WebData.java | `getTokenFormData()` — partial credential string returned silently on encoding exception |
| A19-17 | MEDIUM | WebData.java | `isValidMacAddress()` — length-only validation accepts non-MAC strings; boundary cases untested |
| A19-18 | MEDIUM | WebData.java | `getTempSessionId()` — integer underflow to positive value on `MIN_VALUE` input |
| A19-19 | MEDIUM | WebData.java | `isSessionOffline()` — composite offline logic untested |
| A19-20 | MEDIUM | WebData.java | `getTokenString()` — lazy load from storage untested; null `value` field edge case |
| A19-21 | MEDIUM | WebData.java | `setHttpHeader()` — auth header silently omitted when token null, no caller notification |
| A19-22 | MEDIUM | WebData.java | `getTempSessionResult()` — boolean inversion of pre-start state untested |
| A19-23 | MEDIUM | WebData.java | `instance()` — non-thread-safe singleton creation |
| A19-24 | LOW | WebApi.java | `sync()`/`async()` — NullPointerException if called before `init()` |
| A19-25 | LOW | WebListener.java | Empty default `onFailed` silently swallows errors in any non-overriding subclass |
| A19-26 | LOW | WebApi.java | No cancellation handle returned; callbacks may fire against destroyed contexts |
| A19-27 | INFO | WebData.java | Credentials should be injected via BuildConfig secrets or secure remote config |
| A19-28 | INFO | WebData.java | Persisted OAuth token has no expiry check; stale tokens produce unexplained 401s |
