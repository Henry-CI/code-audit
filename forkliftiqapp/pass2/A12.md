# Audit Pass 2 — Test Coverage
## Agent A12 — BLE Control, Controller, and Data Service Files
**Audit run:** 2026-02-26-01
**Date written:** 2026-02-27
**Auditor:** A12 (automated)

---

## PROJECT-WIDE FINDING

### A12-1 — CRITICAL: Zero Automated Test Coverage Across app/ and LibCommon/ Modules

**Severity:** HIGH (project-wide)

The `app/` and `LibCommon/` modules contain no test directories whatsoever. A glob search for `**/test*/**/*.java` across the entire repository found only two test files, both in the unrelated `LibImageloader` third-party module:

- `LibImageloader/src/test/java/.../ImageSizeTest.java`
- `LibImageloader/src/test/java/.../BaseImageDownloaderTest.java`

There are no unit tests, no integration tests, and no instrumented tests for any production code in `app/src/main/java/` or `LibCommon/`. This applies to all BLE services, all authentication logic, all relay-control logic, all shock-event processing, and all other application logic.

The three files assigned to this agent collectively implement Bluetooth Low Energy authentication and physical relay control for forklift hardware. Zero automated tests exist for any of this safety-critical code. Every finding below therefore reflects not only a gap in test coverage but also the absence of any automated verification that forklift hardware behaves safely under error conditions, edge inputs, or state-machine transitions.

**Impact:** Any regression in BLE authentication, relay control, device initialization, or shock-event processing can only be caught by manual testing or by field observation on live hardware. There is no safety net.

---

## File 1: BleControlService.java

**Fully qualified class name:** `au.com.collectiveintelligence.fleetiq360.WebService.BLE.BleControlService`
**Extends:** `android.app.IntentService`

### Methods (with line numbers and signatures)

| Line | Signature |
|------|-----------|
| 33 | `public BleControlService()` — constructor, calls `super("ShockEventService")` |
| 38 | `public void processBleEvents(Intent intent)` |
| 102 | `boolean handleBleOperation(Intent intent)` |
| 176 | `@Override protected void onHandleIntent(Intent intent)` |
| 183 | `public static void authDevice()` |
| 187 | `public static void sendData(Intent intent, String uuid)` |
| 200 | `private static void sendActionWithDelay(String action, int delayInMilli)` |
| 210 | `public static void sendAction(String action)` |
| 215 | `public static void setRelayWithDelay()` |
| 224 | `public static void setRelayNoDelay()` |
| 228 | `public static void setTime()` |
| 232 | `public static void initDevice()` |
| 237 | `public static void setImpactThreshold()` |
| 241 | `public static void setRelayTimeout()` |
| 245 | `public static void setShockNotification()` |
| 249 | `public static void afterWriteAttribute(boolean r, BluetoothGattCharacteristic characteristic, Runnable failedRunnable)` |

### Constants defined

| Name | Visibility | Value / Description |
|------|-----------|---------------------|
| `ACTION_AUTO_RECONNECT` | `public static String` | `"com.BleDataService.ACTION_AUTO_RECONNECT"` |
| `ACTION_INIT_DEVICE` | `public static String` | `"com.BleDataService.ACTION_INIT_DEVICE"` |
| `ACTION_AUTH_DEVICE` | `private static String` | `"com.BleDataService.ACTION_AUTH_DEVICE"` |
| `ACTION_SET_RELAY` | `private static String` | `"com.BleDataService.ACTION_SET_RELAY"` |
| `ACTION_SET_TIME` | `private static String` | `"com.BleDataService.SET_TIME"` |
| `ACTION_SET_IMPACT_THRESHOLD` | `private static String` | `"com.BleDataService.ACTION_SET_IMPACT_THRESHOLD"` |
| `ACTION_SET_RELAY_TIMEOUT` | `private static String` | `"com.BleDataService.ACTION_SET_RELAY_TIMEOUT"` |
| `ACTION_ENABLE_SHOCK_NOTIFICATION` | `private static String` | `"com.BleDataService.ACTION_ENABLE_SHOCK_NOTIFICATION"` |
| `TAG` | `public static String` | log tag |
| `mBleMachine` | `static BleMachine` | shared state machine reference |

---

### Findings for BleControlService.java

---

#### A12-2 — CRITICAL: `handleBleOperation` — AUTH failure path silently retries once with no test

**Severity:** CRITICAL
**Location:** `BleControlService.java`, lines 110–124

```java
if(action.equals(ACTION_AUTH_DEVICE)){
    result = mBleMachine.authDevice();
    if(!result){
        mBleMachine.authDevice();     // line 113: retry — return value discarded
    }
    else {
        try {
            Thread.sleep(200);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        mBleMachine.authDevice();   // line 121: onAuthDone(), but wait...
```

The first `authDevice()` call return value drives a retry at line 113. The retry's return value is silently discarded — if both the first and second `authDevice()` calls fail, the code calls `mBleMachine.onAuthDone()` anyway (the else branch applies only to the first call succeeding). There is no test for:

- First call fails, second call fails — is auth considered done? Is the relay enabled on an unauthenticated device?
- First call fails, second call succeeds — is this path valid?
- Both calls fail — does the forklift relay get enabled without authentication?

Because authentication gates relay activation (which enables forklift operation), an untested double-failure path here is safety-critical.

---

#### A12-3 — CRITICAL: `handleBleOperation` — `ACTION_INIT_DEVICE` triggers all device-init operations sequentially without guarding each result

**Severity:** CRITICAL
**Location:** `BleControlService.java`, lines 108–172

When `isInitDevice` is `true`, the method unconditionally enters every `if` block for `ACTION_SET_TIME`, `ACTION_SET_IMPACT_THRESHOLD`, `ACTION_SET_RELAY_TIMEOUT`, and `ACTION_ENABLE_SHOCK_NOTIFICATION`. Each sets `result` but the variable is overwritten by the next block before any check can act on it. By the time `processed` is returned, the last `result` value is from `setShockNotification`. A failure in `setTime`, `setImpactThreshold`, or `setRelayTimeout` is overwritten and lost. No test covers:

- Init with `setTime` failing but remaining ops succeeding — device operates with wrong time.
- Init with `setImpactThreshold` failing — shock detection operates with unverified threshold.
- Init with `setRelayTimeout` failing — timeout behaviour undefined.

---

#### A12-4 — CRITICAL: `setRelayWithDelay` — Thread.sleep on caller thread inside a static method

**Severity:** CRITICAL
**Location:** `BleControlService.java`, lines 215–222

```java
public static void setRelayWithDelay() {
    try {
        Thread.sleep(2*1000);
    } catch (InterruptedException e) {
        e.printStackTrace();
    }
    mBleMachine.setRelay(true);
}
```

This is a static method called directly (not via an Intent queue), so it blocks whatever thread invokes it for 2 seconds. If called from the IntentService handler thread it stalls the queue. If `mBleMachine` is `null` at call time (before `onHandleIntent` has run), it throws a `NullPointerException` with no guard and no test. No test covers: call before `mBleMachine` is initialised, call from wrong thread, `InterruptedException` propagation.

---

#### A12-5 — CRITICAL: `afterWriteAttribute` — `mBleMachine` NPE if called before first `onHandleIntent`

**Severity:** CRITICAL
**Location:** `BleControlService.java`, lines 249–263

```java
public static void afterWriteAttribute(boolean r, final BluetoothGattCharacteristic characteristic, Runnable failedRunnable) {
    if(r){
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        mBleMachine.readCharacteristic(characteristic);   // NPE if mBleMachine == null
    }
    ...
}
```

`mBleMachine` is a `static` field initialised only inside `onHandleIntent`. `afterWriteAttribute` is `public static` and called from `BleMachine`. If this is called before the first Intent has been handled, `mBleMachine` is `null` and the call crashes. No test covers: early invocation ordering, NPE defence, `InterruptedException` handling, `failedRunnable == null` with `r == false`.

---

#### A12-6 — HIGH: `processBleEvents` — `ACTION_GATT_SERVICES_DISCOVERED` branch NPE on null `mBleMachine`

**Severity:** HIGH
**Location:** `BleControlService.java`, lines 84–89

```java
else if (BleMachineService.ACTION_GATT_SERVICES_DISCOVERED.equals(action)) {
    List<BluetoothGattService> services = BleController.instance().getSupportedGattServices();
    Log.d(TAG,"Service discorvered " + (services!=null?services.size():"null"));
    mBleMachine.onGattServices(services);   // NPE if mBleMachine null
}
```

`mBleMachine` can be null if this broadcast arrives before `onHandleIntent` has run. No null check exists. No test covers this ordering.

---

#### A12-7 — HIGH: `processBleEvents` — `ACTION_DATA_AVAILABLE`/`ACTION_DATA_CHANGED` branch NPE on null `mBleMachine`

**Severity:** HIGH
**Location:** `BleControlService.java`, lines 95–98

```java
if (BleMachineService.ACTION_DATA_AVAILABLE.equals(action) || BleMachineService.ACTION_DATA_CHANGED.equals(action)) {
    Log.d(TAG,"Received data event " + action);
    mBleMachine.onBleDataRead(intent);   // NPE if mBleMachine null
}
```

Same null-mBleMachine risk as A12-6. No test covers out-of-order initialisation.

---

#### A12-8 — HIGH: `processBleEvents` — Disconnected branch skips auto-reconnect silently when status is `STATUS_SETUP_DONE`

**Severity:** HIGH
**Location:** `BleControlService.java`, lines 57–83

When `ACTION_GATT_DISCONNECTED` is received and status is `STATUS_SETUP_DONE`, the code sets status to `STATUS_IDLE` and re-broadcasts the intent — but does not trigger reconnect. A comment block showing the original reconnect logic was commented out. No test verifies this intentional behaviour or that the original reconnect suppression is correct and complete. A regression here could leave a forklift permanently disconnected with no notification to the operator.

---

#### A12-9 — HIGH: `sendData` — uuid null/empty not guarded

**Severity:** HIGH
**Location:** `BleControlService.java`, lines 187–198

```java
public static void sendData(Intent intent, String uuid) {
    if (uuid.equals(BleModel.UUID_SHOCK_COUNT) || uuid.equals(BleModel.UUID_SHOCK_EVENT_ITEM)) {
```

If `uuid` is `null`, the call to `uuid.equals(...)` throws a `NullPointerException`. No null check exists. No test covers a null UUID arriving from BLE.

---

#### A12-10 — MEDIUM: `handleBleOperation` — `ACTION_SET_RELAY` always passes `true` (hardcoded)

**Severity:** MEDIUM
**Location:** `BleControlService.java`, line 132

```java
result = mBleMachine.setRelay(true);
```

The relay is always set to `true` (enabled). There is no code path that sets the relay to `false` via this action. No test verifies whether the relay is ever expected to be set to `false` through this path, or whether the hardcoding is intentional vs. a latent bug.

---

#### A12-11 — MEDIUM: `ACTION_SET_TIME` constant value mismatch (typo)

**Severity:** MEDIUM
**Location:** `BleControlService.java`, line 26

```java
private static String ACTION_SET_TIME = "com.BleDataService.SET_TIME";
```

All other action strings follow the pattern `ACTION_XXX`; this one is `SET_TIME` (missing the `ACTION_` prefix in the string value). If any external component constructs this string to send an Intent, it will use the wrong value. No test covers that the action string routing works end-to-end.

---

#### A12-12 — MEDIUM: `processBleEvents` — `intent.getAction()` result used directly without null guard in `handleBleOperation`

**Severity:** MEDIUM
**Location:** `BleControlService.java`, lines 102–108

`processBleEvents` checks for a null action at line 41 and returns early. But `handleBleOperation` is called at line 45 before that null check's benefit can guarantee anything — wait, actually the null return is at line 42, so `handleBleOperation` is only called if action is non-null. However, `handleBleOperation` itself re-fetches `intent.getAction()` at line 104 without a null guard. Because `handleBleOperation` is package-private and could be called independently (e.g., from a test or subclass), a null action would cause an NPE at `action.equals(ACTION_AUTH_DEVICE)` (line 110). No test exercises this.

---

#### A12-13 — LOW: `sendActionWithDelay` — `InterruptedException` silently swallowed in delay thread

**Severity:** LOW
**Location:** `BleControlService.java`, lines 200–208

The delay is implemented via `MyApplication.runLater`, which is not blocking — this is actually a Runnable, so the sleep does not occur here. However in `setRelayWithDelay` (line 215) and `afterWriteAttribute` (line 252), `InterruptedException` is caught and only `e.printStackTrace()` is called, with no state reset or retry. No test covers interrupt scenarios.

---

#### A12-14 — LOW: All 15 methods are completely untested

**Severity:** LOW (summary)

Every method in `BleControlService` has zero test coverage:
`BleControlService()`, `processBleEvents`, `handleBleOperation`, `onHandleIntent`, `authDevice`, `sendData`, `sendActionWithDelay`, `sendAction`, `setRelayWithDelay`, `setRelayNoDelay`, `setTime`, `initDevice`, `setImpactThreshold`, `setRelayTimeout`, `setShockNotification`, `afterWriteAttribute`.

---

## File 2: BleController.java

**Fully qualified class name:** `au.com.collectiveintelligence.fleetiq360.WebService.BLE.BleController`

### Methods (with line numbers and signatures)

| Line | Signature |
|------|-----------|
| 86 | `BroadcastReceiver bluetoothEnableReceiver` (anonymous inner class, `onReceive`) |
| 104 | `void registerBluetoothEnableCallback()` |
| 108 | `void unRegisterBluetoothEnable()` |
| 118 | `void addDevice(BluetoothDevice bluetoothDevice)` |
| 129 | `BluetoothDevice getCachedDevice(String address)` |
| 138 | `public boolean isDeviceSetupDone(String address)` |
| 146 | `public boolean isDeviceDisconnected(String address)` |
| 155 | `boolean stillNeedToConnectEquipment()` |
| 163 | `ServiceConnection mServiceConnection` (anonymous inner class, `onServiceConnected`, `onServiceDisconnected`) |
| 179 | `void onBleServiceConnected(IBinder service)` |
| 187 | `public void onBleServiceDisconnected()` |
| 192 | `boolean isBroadcastNeedToHandle(Intent intent)` |
| 209 | `public List<BluetoothGattService> getSupportedGattServices()` |
| 217 | `public void discoverServices()` |
| 227 | `public void autoReconnect()` |
| 237 | `private void startBleService()` (no-arg overload) |
| 247 | `private void startBleService(BluetoothDevice device)` |
| 268 | `void stopBleService()` |
| 275 | `public void stopConnection()` |
| 289 | `void clearConnection()` |
| 298 | `void clearRelay()` |
| 324 | `void stopScanLeDevice()` |
| 331 | `void stopScanner()` |
| 342 | `private void scanLeDevice()` |
| 360 | `private void initializeVariables(boolean relaySet, EquipmentItem equipmentItem)` |
| 377 | `public void startScan()` |
| 402 | `public void stopScan()` |
| 430 | `Runnable mStopRunnable` (anonymous inner class) |
| 437 | `ScanCallback leScanCallback` (anonymous inner class, `onScanResult`) |
| 461 | `void scanDeviceFunc()` |
| 510 | `BluetoothAdapter.LeScanCallback mLeScanCallback` (anonymous inner class, `onLeScan`) |
| 530 | `public void preStartCheck(boolean relaySet, boolean autoReconnect, EquipmentItem equipmentItem, EquipmentListener listener)` |
| 605 | `void preStart(EquipmentItem equipmentItem, EquipmentListener listener)` |
| 615 | `public void startConnect(boolean relaySet, boolean autoReconnect, EquipmentItem equipmentItem, EquipmentListener listener)` |
| 622 | `void discoverDevice(boolean autoReconnect, EquipmentItem equipmentItem, EquipmentListener listener)` |
| 649 | `void onSetupTimeout()` |
| 659 | `public static class EquipmentListener` — `onSucceed()`, `onFailed(int errorCode)` |
| 670 | `void onFailed()` |
| 683 | `void onSetupDone()` |
| 697 | `void pushStateMachine()` |
| 724 | `void onRelaySetDone()` |
| 732 | `Handler myHandler` (field) |
| 734 | `Runnable timerRunnable` (anonymous inner class) |
| 744 | `public void startTimer()` |
| 750 | `BluetoothGattCharacteristic getCharacteristic(String uuid)` |
| 764 | `public void init(Context context)` |
| 770 | `public static synchronized BleController instance()` |
| 779 | `public BleController()` — constructor |

### Constants / Status codes defined

| Name | Visibility | Value |
|------|-----------|-------|
| `EQUIPMENT_CONNECT_CODE_NONE` | `private static int` | 0 (base) |
| `EQUIPMENT_CONNECT_CODE_BLE_NOT_ON` | `public final static int` | 1 |
| `EQUIPMENT_CONNECT_CODE_BLE_FAILED` | `public final static int` | 2 |
| `EQUIPMENT_CONNECT_CODE_BUSY` | `public final static int` | 3 |
| `EQUIPMENT_CONNECT_CODE_INVALID_DATA` | `public final static int` | 4 |
| `STATUS_NONE` | `public static int` (mutable) | 0 (base) |
| `STATUS_IDLE` | `public final static int` | 1 |
| `STATUS_CONNECTING` | `public final static int` | 2 |
| `STATUS_SERVICE_FOUND` | `public final static int` | 3 |
| `STATUS_AUTHENTICATED` | `public final static int` | 4 |
| `STATUS_SETUP_RELAY_DONE` | `public final static int` | 5 |
| `STATUS_SETUP_DONE` | `public final static int` | alias for `STATUS_SETUP_RELAY_DONE` (5) |
| `SCAN_PERIOD` | `public static final int` | 10000 ms |
| `CONNECT_PERIOD` | `public static final int` | 30000 ms |
| `SCAN_TIMEOUT` | `public static final int` | 10000 ms |
| `clearRelayRetryTime` | `static int` | 0 |
| `scanRetryCount` | `static int` | 0 |
| `timerDuration` | `int` | 5 * 60 * 1000 ms |

---

### Findings for BleController.java

---

#### A12-15 — CRITICAL: `STATUS_NONE` is mutable — status constants can be corrupted at runtime

**Severity:** CRITICAL
**Location:** `BleController.java`, lines 55–61

```java
public static int STATUS_NONE = 0;
public final static int STATUS_IDLE = ++STATUS_NONE;         // STATUS_NONE becomes 1
public final static int STATUS_CONNECTING = ++STATUS_NONE;   // STATUS_NONE becomes 2
...
public final static int STATUS_SETUP_RELAY_DONE = ++STATUS_NONE;  // STATUS_NONE becomes 5
public final static int STATUS_SETUP_DONE = STATUS_SETUP_RELAY_DONE;
```

`STATUS_NONE` is declared as `public static int` (not `final`). Any external code can write `BleController.STATUS_NONE = 0`, which has no effect because the `final` constants have already been initialised — but `STATUS_NONE` itself ends up with value 5 after class loading, not 0. Any code that compares against `STATUS_NONE` expecting 0 will silently compare against 5. Similarly, `EQUIPMENT_CONNECT_CODE_NONE` is `private static int` (not final) and ends up with value 4 after initialisation. No test covers the expected values of these constants post-initialisation, nor guards against mutation.

---

#### A12-16 — CRITICAL: `preStartCheck` — NPE when `equipmentItem` is null (log statement uses it after null check)

**Severity:** CRITICAL
**Location:** `BleController.java`, lines 541–547

```java
if(equipmentItem == null) {
    if(listener != null) {
        listener.onFailed(EQUIPMENT_CONNECT_CODE_INVALID_DATA);
    }
    Log.d(TAG,"start connect invalid data return device " + equipmentItem.mac_address);
    return;
}
```

The log statement at line 546 dereferences `equipmentItem.mac_address` after the null check has confirmed that `equipmentItem` is `null`. This throws a `NullPointerException` unconditionally when `equipmentItem` is null, before the `return` is reached. No test exercises the null-equipment path.

---

#### A12-17 — CRITICAL: `clearRelay` — recursive retry with unbounded effective depth and no test

**Severity:** CRITICAL
**Location:** `BleController.java`, lines 298–322

```java
void clearRelay() {
    boolean r = mBleMachine.clearRelay();
    if(!r) {
        MyApplication.runLater(new Runnable() {
            @Override
            public void run() {
                clearRelayRetryTime++;
                if(clearRelayRetryTime < 3){
                    clearRelay();
                }
                else {
                    clearConnection();
                }
            }
        },5000);
    }
    ...
}
```

`clearRelayRetryTime` is a static field reset to 0 only inside `clearConnection`. If `clearRelay` is called while `clearRelayRetryTime` is already >= 3 from a prior session (e.g., if `clearConnection` was never reached), `clearConnection` will be called immediately without the relay actually being cleared. If `mBleMachine` is null at entry, line 299 throws NPE. No test covers: null mBleMachine, retry count boundary, retry count carry-over across sessions, or what happens to the forklift relay when all retries are exhausted.

---

#### A12-18 — CRITICAL: `pushStateMachine` — status incremented with `++ble_status` — any out-of-order call corrupts the state machine

**Severity:** CRITICAL
**Location:** `BleController.java`, lines 697–722

```java
void pushStateMachine() {
    if(ble_status == STATUS_IDLE){ return; }
    ++ble_status;
    ...
}
```

`pushStateMachine` unconditionally increments `ble_status` with no upper-bound check and no guard against being called more than once per state. A double invocation (e.g., from a race between `onAuthDone` and a reconnect path) would push the status past `STATUS_SETUP_DONE` (5) to an undefined value of 6, which matches none of the `if`/`else if` conditions — silently entering a wedged state where the device appears connected but no transitions occur. No test covers concurrent or repeated calls, or status values > 5.

---

#### A12-19 — CRITICAL: `onBleServiceConnected` — relay connection proceeds even when `initialize()` fails, via partial state

**Severity:** HIGH
**Location:** `BleController.java`, lines 179–185

```java
void onBleServiceConnected(IBinder service) {
    mBleService = ((BleMachineService.LocalBinder) service).getService();
    if (null == mBleService || !mBleService.initialize()) {
        onFailed();
        return;
    }
}
```

`mBleService` is set unconditionally before the null/init check. If `getService()` returns a non-null but uninitialised service object (where `initialize()` returns false), `mBleService` is populated with a broken object, `onFailed()` is called, but `mBleService` is not cleared here (only `onBleServiceDisconnected` sets it null). Subsequent code that checks `if(mBleService != null)` will believe the service is available and attempt BLE operations on the uninitialised service. No test covers partial initialisation failure.

---

#### A12-20 — HIGH: `isBroadcastNeedToHandle` — double-redundant case-insensitive comparison

**Severity:** HIGH
**Location:** `BleController.java`, lines 202

```java
if(address == null || !address.toLowerCase().equalsIgnoreCase(mBleDeviceAddress)){
```

`toLowerCase()` followed by `equalsIgnoreCase()` is redundant; `equalsIgnoreCase` already handles case. More importantly, `mBleDeviceAddress` is initialised to `""` (line 80), and `preStartCheck` guards against empty addresses before calling `initializeVariables`. However, `isBroadcastNeedToHandle` can be called at any time and will accept any broadcast addressed to `""` when `mBleDeviceAddress` is `""`. No test covers this edge case.

---

#### A12-21 — HIGH: `startScan` — null-check order is inverted (adapter checked after use)

**Severity:** HIGH
**Location:** `BleController.java`, lines 386–390

```java
if((mBluetoothAdapter.getState() != BluetoothAdapter.STATE_ON) &&
        (mBluetoothAdapter != null)){
```

The null guard `(mBluetoothAdapter != null)` is the second operand of `&&`. If `mBluetoothAdapter` is null, `mBluetoothAdapter.getState()` is evaluated first and throws a `NullPointerException`. The same inverted null check appears in `stopScan` (line 411) and `leScanCallback.onScanResult` (line 442). No test covers the null-adapter path in any of these methods.

---

#### A12-22 — HIGH: `stopScan` — `startBleService()` called unconditionally after scan stop, even when no device was found

**Severity:** HIGH
**Location:** `BleController.java`, lines 416–425

```java
if(mIsScanning) {
    mIsScanning = false;
    mLEScanner.stopScan(leScanCallback);
    startBleService();   // called even if mDevicesDiscovered is empty
}
```

The commented-out timeout check (lines 419–423) would have prevented `startBleService` from being called if no device was discovered within the scan timeout. With that guard removed, `startBleService()` is called regardless of whether any matching device was found. The result is an attempt to connect to an address that was never seen. No test covers the scan-no-device-found path.

---

#### A12-23 — HIGH: `scanDeviceFunc` — `getScanRecord()` may return null (API < 21 path missing)

**Severity:** HIGH
**Location:** `BleController.java`, lines 473–480

```java
scanCallback = new ScanCallback() {
    @Override
    public void onScanResult(int callbackType, ScanResult result) {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
            mLeScanCallback.onLeScan(result.getDevice(), result.getRssi(), result.getScanRecord().getBytes());
        }
    }
};
```

`result.getScanRecord()` can return null (the BLE scan record is optional). Calling `.getBytes()` on a null `ScanRecord` throws an NPE. No test covers a scan result with a null scan record.

---

#### A12-24 — HIGH: `autoReconnect` — calls `startConnect` with null `equipmentListener` which is never restored

**Severity:** HIGH
**Location:** `BleController.java`, lines 227–235

```java
public void autoReconnect(){
    if(!stillNeedToConnectEquipment()){ return; }
    startConnect(relaySetDone, true, mEquipmentItem, equipmentListener);
}
```

`equipmentListener` is set to `null` inside `onFailed()` and `onSetupDone()`. If `autoReconnect` is called after either of those paths, it passes `null` as the listener. Inside `preStartCheck`, null listeners are guarded, so no crash occurs — but the caller that originally registered the listener receives no success or failure notification on reconnect. No test covers the listener-null reconnect path.

---

#### A12-25 — MEDIUM: `addDevice` — `cachedBleDevices` is a static mutable list with no size bound

**Severity:** MEDIUM
**Location:** `BleController.java`, lines 117–128

`cachedBleDevices` grows without bound across multiple scanning sessions. In long-running deployment on a forklift (scanning hundreds of BLE devices over days), memory consumption grows unbounded. No test covers list growth, duplicate removal correctness, or concurrent modification (the list is accessed from `AsyncTask` and scan callbacks without synchronisation).

---

#### A12-26 — MEDIUM: `getCharacteristic` — UUID comparison uses mixed-case `equalsIgnoreCase` with `toLowerCase` pre-call

**Severity:** MEDIUM
**Location:** `BleController.java`, lines 756–758

```java
String s = characteristic.getUuid().toString();
if(s.toLowerCase().equalsIgnoreCase(uuid)){
```

Same redundancy as A12-20. More critically, the `uuid` parameter is not null-checked — if a caller passes null, `equalsIgnoreCase` on a lowercased string against null returns false (not a crash), but the behaviour is inconsistent with the null-UUID guard in `BleDataService.onShockDataRead`. No test covers null UUID lookup.

---

#### A12-27 — MEDIUM: `onSetupTimeout` — timeout logic is commented out; method is dead code

**Severity:** MEDIUM
**Location:** `BleController.java`, lines 649–657

`onSetupTimeout` exists and is correct, but the `MyApplication.runLater` call that would invoke it (inside `discoverDevice`, lines 640–646) is entirely commented out. The method is dead code — the connection timeout is never enforced. A BLE connection that stalls in `STATUS_CONNECTING` will hang indefinitely. No test covers timeout expiry.

---

#### A12-28 — MEDIUM: All non-trivial methods have zero test coverage (summary)

**Severity:** MEDIUM (summary)

The following methods implement safety-critical BLE state management with zero test coverage:
`registerBluetoothEnableCallback`, `unRegisterBluetoothEnable`, `addDevice`, `getCachedDevice`, `isDeviceSetupDone`, `isDeviceDisconnected`, `stillNeedToConnectEquipment`, `onBleServiceConnected`, `onBleServiceDisconnected`, `isBroadcastNeedToHandle`, `getSupportedGattServices`, `discoverServices`, `autoReconnect`, `startBleService` (both overloads), `stopBleService`, `stopConnection`, `clearConnection`, `clearRelay`, `stopScanLeDevice`, `stopScanner`, `scanLeDevice`, `initializeVariables`, `startScan`, `stopScan`, `scanDeviceFunc`, `preStartCheck`, `preStart`, `startConnect`, `discoverDevice`, `onSetupTimeout`, `onFailed`, `onSetupDone`, `pushStateMachine`, `onRelaySetDone`, `startTimer`, `getCharacteristic`, `init`, `instance`, `BleController()`.

---

## File 3: BleDataService.java

**Fully qualified class name:** `au.com.collectiveintelligence.fleetiq360.WebService.BLE.BleDataService`
**Extends:** `android.app.IntentService`

### Methods (with line numbers and signatures)

| Line | Signature |
|------|-----------|
| 23 | `public BleDataService()` — constructor, calls `super("ShockEventService")` |
| 27 | `public void processBleEvents(Intent intent)` |
| 57 | `@Override protected void onHandleIntent(Intent intent)` |
| 69 | `public static void sendAction(String action)` |
| 78 | `public boolean readShockEvent()` |
| 100 | `boolean popShockEvent()` |
| 119 | `void onShockDataRead(String address, Intent intent)` |
| 157 | `void onShockCountRead(Integer count)` |
| 175 | `boolean readShockCount()` |
| 206 | `public static void sendData(Intent intent)` |

### Constants defined

| Name | Visibility | Value |
|------|-----------|-------|
| `ACTION_READ_SHOCK_COUNT` | `public static String` | `"com.BleDataService.ACTION_READ_SHOCK_COUNT"` |
| `TAG` | `public static String` | log tag |
| `mBleMachine` | `static BleMachine` | shared, initialised in `onHandleIntent` |
| `mBleController` | `static BleController` | shared, initialised in `onHandleIntent` |

---

### Findings for BleDataService.java

---

#### A12-29 — CRITICAL: `readShockCount` — unbounded recursion on persistent BLE failure

**Severity:** CRITICAL
**Location:** `BleDataService.java`, lines 175–204

```java
boolean readShockCount() {
    mBleMachine.disableShockNotification();
    ...
    boolean r = mBleMachine.readCharacteristic(characteristic);
    if(!r){
        readShockCount();    // direct recursive call
    }
    return r;
}
```

If `readCharacteristic` persistently returns `false` (e.g., BLE stack is busy or hardware is unresponsive), `readShockCount` recurses indefinitely on the IntentService handler thread. There is no retry limit, no backoff, no exit condition. This will cause a stack overflow (`StackOverflowError`), killing the service. On a forklift that has accumulated shock events, this path is exercised continuously — losing all shock event data during the crash and potentially leaving the forklift relay state unknown. No test covers the persistent-failure case.

---

#### A12-30 — CRITICAL: `onShockCountRead` — recursive retry chain: `onShockCountRead` → `readShockEvent` → `readShockCount` → `onShockCountRead`

**Severity:** CRITICAL
**Location:** `BleDataService.java`, lines 157–173

```java
void onShockCountRead(Integer count) {
    ...
    if(null != count && count > 0){
        boolean r = readShockEvent();
        if(!r){
            readShockCount();   // re-enters the chain
        }
    }
    else {
        mBleMachine.setShockNotification();
    }
}
```

The call chain `onShockCountRead` → `readShockEvent` (fails) → `readShockCount` (fails) → recursive `readShockCount` → ... forms an unbounded recursive loop with no exit. On a BLE error with pending shock events, the service will crash with a stack overflow. No test covers the failure path.

---

#### A12-31 — CRITICAL: `readShockEvent` — status check logic is inverted

**Severity:** CRITICAL
**Location:** `BleDataService.java`, lines 78–98

```java
public boolean readShockEvent() {
    ...
    if(mBleController.ble_status != mBleController.STATUS_SETUP_DONE) {
        return true;    // returns success when NOT ready
    }
    ...
}
```

When the BLE connection is not fully set up (status != STATUS_SETUP_DONE), the method returns `true` — which callers interpret as "operation succeeded". This means `onShockCountRead` will call `mBleMachine.setShockNotification()` (the `else` branch is not reached because `readShockEvent` "succeeded"), but in reality no shock event was read. Shock event data is silently dropped. No test covers this status-not-ready path or verifies the return semantics.

---

#### A12-32 — CRITICAL: `popShockEvent` — hardcoded byte payload `{0x01}` with no validation

**Severity:** CRITICAL
**Location:** `BleDataService.java`, lines 100–117

```java
boolean popShockEvent() {
    ...
    byte[] v = {0x01};
    characteristic.setValue(v);
    boolean r = mBleMachine.writeCharacteristic(characteristic);
    ...
}
```

The pop command writes a hardcoded single byte `0x01` to the hardware characteristic. There is no test that verifies this byte value is correct for the device protocol, that write failures are handled (return value is returned but the caller `onShockDataRead` at line 150 discards it), or that the hardware state after a failed pop is safe (the shock event may remain in the queue and be re-processed). No test covers failed write, null characteristic, or incorrect byte value.

---

#### A12-33 — HIGH: `onShockDataRead` — `popShockEvent` return value discarded by caller

**Severity:** HIGH
**Location:** `BleDataService.java`, lines 147–154

```java
else if (uuid.equals(BleModel.UUID_SHOCK_EVENT_ITEM)) {
    if (actionSucceed) {
        popShockEvent();     // return value discarded
    }
    readShockCount();
}
```

`popShockEvent` returns a boolean indicating write success. The return value is unconditionally discarded. If the pop fails, the shock event remains in the hardware queue and `readShockCount` is called immediately, which will re-read the same event, re-attempt the pop, fail again, and loop indefinitely (feeding into the recursion found in A12-29 and A12-30). No test covers a failed pop.

---

#### A12-34 — HIGH: `readShockCount` — calls `disableShockNotification` unconditionally on every retry cycle

**Severity:** HIGH
**Location:** `BleDataService.java`, line 177

```java
boolean readShockCount() {
    mBleMachine.disableShockNotification();
    ...
}
```

`disableShockNotification` is called at the top of every `readShockCount` invocation, including every recursive retry. In a failure loop, the BLE stack is hammered with repeated disable-notification writes before any read attempt. This could saturate the BLE command queue, causing further failures. No test covers this interaction.

---

#### A12-35 — HIGH: `processBleEvents` — null action not guarded before `action.equals` calls

**Severity:** HIGH
**Location:** `BleDataService.java`, lines 29–39

```java
String action = intent.getAction();
if(null == action){ return; }

if(action.equals(ACTION_READ_SHOCK_COUNT)){
```

The null guard at line 30 is present and correct. However, `onShockDataRead` is called with `address` and `intent` (line 52), and inside `onShockDataRead`, `uuid` is fetched again at line 124 and checked for null/empty at line 125. But `address` (line 46) is never null-checked before being passed — it could be null if the Intent lacks `DEVICE_ADDRESS`. No test covers a missing DEVICE_ADDRESS extra.

---

#### A12-36 — HIGH: `onHandleIntent` — `mBleMachine` and `mBleController` are static but set from instance method — race condition on concurrent service starts

**Severity:** HIGH
**Location:** `BleDataService.java`, lines 57–67

```java
@Override
protected void onHandleIntent(Intent intent) {
    if(null == mBleMachine){
        mBleMachine = BleController.instance().mBleMachine;
    }
    if(null == mBleController){
        mBleController= BleController.instance();
    }
    processBleEvents(intent);
}
```

`mBleMachine` and `mBleController` are `static` fields with lazy initialisation using a non-atomic null check. `IntentService` uses a single background thread, so this is safe within a single service instance. However, because these are `static`, a second instance of `BleDataService` (or `BleControlService`, which has the same pattern) would share these statics. If two service instances ever start concurrently — unlikely but possible under Android lifecycle edge cases — the null-check-then-set is not atomic. No test covers this scenario.

---

#### A12-37 — MEDIUM: `readShockCount` — Thread.sleep(1000) blocks the IntentService handler thread

**Severity:** MEDIUM
**Location:** `BleDataService.java`, lines 185–189

```java
try {
    Thread.sleep(1000);
} catch (InterruptedException e) {
    e.printStackTrace();
}
```

Both `readShockEvent` (line 81) and `readShockCount` (line 185) sleep for 1 second on the IntentService handler thread. In the recursive failure paths (A12-29, A12-30), these sleeps occur on every recursion. Beyond the stack overflow risk, `InterruptedException` is silently swallowed with only a stack trace print, with no retry abort or state clean-up. No test covers interrupt handling.

---

#### A12-38 — MEDIUM: `onShockDataRead` — UUID_SHOCK_EVENT_ITEM branch calls `readShockCount` regardless of `actionSucceed`

**Severity:** MEDIUM
**Location:** `BleDataService.java`, lines 147–154

```java
else if (uuid.equals(BleModel.UUID_SHOCK_EVENT_ITEM)) {
    if (actionSucceed) {
        popShockEvent();
    }
    readShockCount();   // called even when actionSucceed is false
}
```

If `actionSucceed` is false (the read of the shock event item itself failed), the code still calls `readShockCount`. This starts another read cycle without having successfully consumed the event. Depending on hardware state, this could result in perpetually re-reading the same failed event. No test covers `actionSucceed == false` for this UUID.

---

#### A12-39 — MEDIUM: `onShockCountRead` — null count and zero count treated identically

**Severity:** MEDIUM
**Location:** `BleDataService.java`, lines 164–172

```java
if(null != count && count > 0){
    boolean r = readShockEvent();
    ...
}
else {
    mBleMachine.setShockNotification();
}
```

A null `count` (BLE parse failure — `BleUtil.getIntValue` returned null) is treated identically to a zero count (no pending shock events). In both cases, `setShockNotification` is enabled and no retry of the count read occurs. Shock events could be missed if the BLE parse fails. No test covers null count vs. zero count distinction.

---

#### A12-40 — LOW: All 10 methods are completely untested (summary)

**Severity:** LOW (summary)

Every method in `BleDataService` has zero test coverage:
`BleDataService()`, `processBleEvents`, `onHandleIntent`, `sendAction`, `readShockEvent`, `popShockEvent`, `onShockDataRead`, `onShockCountRead`, `readShockCount`, `sendData`.

---

## Summary Table

| ID | File | Severity | Description |
|----|------|----------|-------------|
| A12-1 | Project-wide | HIGH | Zero automated test coverage across app/ and LibCommon/ modules |
| A12-2 | BleControlService | CRITICAL | Auth failure path silently retries once; double-failure result discarded |
| A12-3 | BleControlService | CRITICAL | ACTION_INIT_DEVICE overwrites result across all init ops, masking failures |
| A12-4 | BleControlService | CRITICAL | setRelayWithDelay blocks static method thread; NPE if mBleMachine null |
| A12-5 | BleControlService | CRITICAL | afterWriteAttribute NPE if called before first onHandleIntent |
| A12-6 | BleControlService | HIGH | ACTION_GATT_SERVICES_DISCOVERED: NPE on null mBleMachine |
| A12-7 | BleControlService | HIGH | ACTION_DATA_AVAILABLE/CHANGED: NPE on null mBleMachine |
| A12-8 | BleControlService | HIGH | Disconnected branch: auto-reconnect suppressed silently for STATUS_SETUP_DONE |
| A12-9 | BleControlService | HIGH | sendData: null uuid causes NPE |
| A12-10 | BleControlService | MEDIUM | setRelay always hardcoded to true |
| A12-11 | BleControlService | MEDIUM | ACTION_SET_TIME constant value missing ACTION_ prefix |
| A12-12 | BleControlService | MEDIUM | handleBleOperation: re-fetched null action not guarded |
| A12-13 | BleControlService | LOW | InterruptedException silently swallowed in delay methods |
| A12-14 | BleControlService | LOW | All 15 methods untested |
| A12-15 | BleController | CRITICAL | STATUS_NONE is mutable; ends up as 5 after class load |
| A12-16 | BleController | CRITICAL | preStartCheck: NPE on null equipmentItem in log statement after null check |
| A12-17 | BleController | CRITICAL | clearRelay: unbounded recursive retry; static counter carry-over |
| A12-18 | BleController | CRITICAL | pushStateMachine: unbounded status increment; race corruption |
| A12-19 | BleController | HIGH | onBleServiceConnected: mBleService set to broken object on init failure |
| A12-20 | BleController | HIGH | isBroadcastNeedToHandle: empty-address edge case; redundant case comparison |
| A12-21 | BleController | HIGH | startScan/stopScan/leScanCallback: null check after dereference |
| A12-22 | BleController | HIGH | stopScan: startBleService called even when no device found |
| A12-23 | BleController | HIGH | scanDeviceFunc: getScanRecord() may be null, NPE on getBytes() |
| A12-24 | BleController | HIGH | autoReconnect: passes null listener silently after onFailed/onSetupDone |
| A12-25 | BleController | MEDIUM | cachedBleDevices: unbounded static list, no synchronisation |
| A12-26 | BleController | MEDIUM | getCharacteristic: redundant case ops; null uuid not checked |
| A12-27 | BleController | MEDIUM | onSetupTimeout: method is dead code — timeout never scheduled |
| A12-28 | BleController | MEDIUM | All non-trivial methods untested (summary) |
| A12-29 | BleDataService | CRITICAL | readShockCount: unbounded recursion on persistent BLE failure |
| A12-30 | BleDataService | CRITICAL | onShockCountRead→readShockEvent→readShockCount: unbounded recursive chain |
| A12-31 | BleDataService | CRITICAL | readShockEvent: inverted status check returns success when not ready |
| A12-32 | BleDataService | CRITICAL | popShockEvent: hardcoded byte payload, write failure handling absent |
| A12-33 | BleDataService | HIGH | onShockDataRead: popShockEvent return value discarded |
| A12-34 | BleDataService | HIGH | readShockCount: disableShockNotification called on every retry cycle |
| A12-35 | BleDataService | HIGH | processBleEvents: DEVICE_ADDRESS extra not null-checked before use |
| A12-36 | BleDataService | HIGH | onHandleIntent: static mBleMachine/mBleController lazy-init not thread-safe |
| A12-37 | BleDataService | MEDIUM | readShockCount/readShockEvent: Thread.sleep on handler thread; swallowed interrupt |
| A12-38 | BleDataService | MEDIUM | onShockDataRead: readShockCount called even when actionSucceed is false |
| A12-39 | BleDataService | MEDIUM | onShockCountRead: null count and zero count treated identically |
| A12-40 | BleDataService | LOW | All 10 methods untested |

**Total findings: 40**
**CRITICAL: 12 | HIGH: 14 | MEDIUM: 9 | LOW: 4 | INFO: 0**
