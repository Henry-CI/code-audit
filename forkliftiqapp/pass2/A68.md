# Audit Pass 2 — Agent A68
**Audit run:** 2026-02-26-01
**Agent:** A68
**Files assigned:**
1. `app/src/main/java/au/com/collectiveintelligence/fleetiq360/ui/fragment/UserPhotoFragment.java`
2. `app/src/main/java/au/com/collectiveintelligence/fleetiq360/user/CurrentUser.java`
3. `app/src/main/java/au/com/collectiveintelligence/fleetiq360/user/User.java`

---

## PROJECT-WIDE FINDING — No Automated Test Coverage

**ID:** A68-0
**Severity:** HIGH
**Scope:** Project-wide (`app/` and `LibCommon/` modules)

The `app/src/` directory contains only a `main/` subdirectory. There is no `test/` or `androidTest/` source set anywhere under `app/src/` or `LibCommon/src/`. The only test files found in the repository belong to the third-party `LibImageloader` module (`ImageSizeTest.java`, `BaseImageDownloaderTest.java`), which are tests for vendored library code, not for application code.

Zero automated test coverage exists for all production code in `app/` and `LibCommon/`. Every finding below is therefore amplified: there is no test harness that could detect regressions, security issues, or behavioral changes introduced during future development.

---

## File 1: UserPhotoFragment.java

### Reading Evidence

**Fully qualified class name:** `au.com.collectiveintelligence.fleetiq360.ui.fragment.UserPhotoFragment`

**Inner class:** `au.com.collectiveintelligence.fleetiq360.ui.fragment.UserPhotoFragment.SSLCertificateHandler`

**Fields / Constants defined:**

| Location | Name | Type | Value |
|---|---|---|---|
| `SSLCertificateHandler` (line 38) | `TAG` | `protected static final String` | `"NukeSSLCerts"` |

**Methods:**

| Line | Signature |
|---|---|
| 18 | `static void showUserPhoto(final ImageView imageView)` |
| 41 | `public static void nuke()` (on `SSLCertificateHandler`) |
| 44 | `public X509Certificate[] getAcceptedIssuers()` (anonymous `X509TrustManager`, inline) |
| 49 | `public void checkClientTrusted(X509Certificate[] certs, String authType)` (anonymous `X509TrustManager`, inline) |
| 53 | `public void checkServerTrusted(X509Certificate[] certs, String authType)` (anonymous `X509TrustManager`, inline) |
| 63 | `public boolean verify(String arg0, SSLSession arg1)` (anonymous `HostnameVerifier`, inline) |

---

### Findings — UserPhotoFragment.java

#### A68-1
**Severity:** CRITICAL
**Location:** `UserPhotoFragment.SSLCertificateHandler.nuke()` — lines 41–69
**Title:** SSL/TLS validation globally disabled with no test preventing production use

`SSLCertificateHandler.nuke()` replaces the JVM-wide default `SSLSocketFactory` and `HostnameVerifier` with implementations that accept all certificates and all hostnames without any validation:

- `checkClientTrusted()` (line 49): empty body — accepts any client certificate.
- `checkServerTrusted()` (line 53): empty body — accepts any server certificate, including self-signed, expired, or certificates issued by untrusted authorities.
- `verify()` (line 63): unconditionally returns `true` — accepts any hostname regardless of the certificate's `CN` or `SAN` fields.
- `getAcceptedIssuers()` (line 45): returns an empty array.

`HttpsURLConnection.setDefaultSSLSocketFactory()` and `HttpsURLConnection.setDefaultHostnameVerifier()` (lines 59–66) are JVM-process-global: once called, all subsequent HTTPS connections in the process — including those made by third-party libraries, network clients, and WebViews — are made without TLS validation. This creates a universal MITM attack surface for the lifetime of the process.

The method is annotated `@SuppressLint("TrustAllX509TrustManager")` and `@SuppressLint("BadHostnameVerifier")`, confirming the lint system flags this code as dangerous; those warnings have been silenced rather than addressed.

There is no test that:
- verifies `nuke()` is never called in a production/release build;
- asserts that the default `SSLSocketFactory` remains intact after any code path that might invoke `nuke()`;
- verifies that a build-flavor or debug guard restricts this method to development builds.

**Additional scope:** `nuke()` is called in three production code sites:
- `UserPhotoFragment.showUserPhoto()` (line 30) — on every photo display when a user has a photo URL.
- `SelectDriverPresenter.showImage()` (line 39 of that file).
- `EquipmentSelectForkPresenter.showImage()` (line 71 of that file).

It is called unconditionally on every image load, not just once. Each invocation re-applies the trust-all policy to the entire process.

---

#### A68-2
**Severity:** CRITICAL
**Location:** `UserPhotoFragment.showUserPhoto()` — lines 18–35
**Title:** No test file exists for `UserPhotoFragment`; `showUserPhoto()` has no test coverage

`showUserPhoto()` is package-private (no access modifier), which means it cannot be tested from a test package without using reflection. There is no test file for `UserPhotoFragment` anywhere in the repository. The method's behavior — invoking `nuke()` when a user photo URL is present — is therefore entirely untested. No test validates:
- the branch taken when `CurrentUser.get()` returns `null`;
- the branch taken when `user.getPhotoUrl()` returns `null`;
- the branch taken when both conditions are non-null (which calls `nuke()`);
- whether the fallback image (`R.drawable.user_default`) is set correctly for null paths.

---

#### A68-3
**Severity:** MEDIUM
**Location:** `UserPhotoFragment.showUserPhoto()` — line 29
**Title:** Null-check logic does not guard against `user.getPhotoUrl()` returning an empty string

The guard at line 29 is `user != null && user.getPhotoUrl() != null`. If `getPhotoUrl()` returns an empty string `""`, the condition is `true`, `nuke()` is called, and `ImageLoader.displayImage()` is invoked with an empty URL. There is no test for this edge case. The `DisplayImageOptions` does configure `showImageForEmptyUri`, so the image loader may handle it gracefully, but `nuke()` will still have been invoked globally.

---

## File 2: CurrentUser.java

### Reading Evidence

**Fully qualified class name:** `au.com.collectiveintelligence.fleetiq360.user.CurrentUser`

**Constants defined:**

| Line | Name | Type | Value |
|---|---|---|---|
| 19 | `CURRENT_USER_ID_KEY` | `private final static String` | `"current_user_id"` |

**Fields defined:**

| Line | Name | Type |
|---|---|---|
| 21 | `user` | `private static User` |
| 22 | `loginEmail` | `private static String` |
| 23 | `loginPassword` | `private static String` |
| 24 | `training` | `private static List<TrainingItem>` |

**Inner interface:**

| Line | Name | Methods |
|---|---|---|
| 114–118 | `LoginHandler` | `HandleSuccess()`, `HandleIncorrectCredentials()` |

**Methods:**

| Line | Signature |
|---|---|
| 26 | `public static User get()` |
| 32 | `public static void setUser(User newUser)` |
| 37 | `public static void setUser(LoginItem loginItem)` |
| 48 | `private static void setUserTraining(List<TrainingItem> newTraining)` |
| 53 | `public static List<TrainingItem> getTrainingList()` |
| 58 | `private static User createUser(LoginItem loginItem)` |
| 80 | `public static void login(final LoginHandler handler)` |
| 120 | `public static void setTemporaryLoginInformation(String email, String password)` |
| 125 | `public static void logout()` |

---

### Findings — CurrentUser.java

#### A68-4
**Severity:** HIGH
**Location:** `CurrentUser.logout()` — lines 125–128
**Title:** `logout()` does not clear `loginEmail` and `loginPassword` static fields; no test verifies credential erasure

`logout()` deletes the persisted user ID key and nulls the `user` reference, but it does not clear the static fields `loginEmail` and `loginPassword`. These fields retain the user's MD5-hashed email and plaintext password (see A68-7) in JVM memory after logout. A subsequent call to `login()` without an intervening `setTemporaryLoginInformation()` will reuse the credentials of the previous user.

There is no test that:
- calls `logout()` and then asserts `loginEmail` and `loginPassword` are `null`;
- verifies that a subsequent `login()` call after `logout()` without re-supplying credentials fails rather than authenticating as the previous user.

Because `loginEmail` and `loginPassword` are `private static`, testing requires reflection — but no such test exists.

---

#### A68-5
**Severity:** HIGH
**Location:** `CurrentUser.login()` — lines 98–110 (`onFailed` callback)
**Title:** Offline fallback in `login()` allows revoked or deactivated accounts to authenticate using locally cached credentials; no test covers this path

When the web API call fails with any `WebResult` status code other than `HTTP_BAD_GATEWAY` (502), `login()` falls back to `UserDb.get(loginEmail, loginPassword)` (line 103). If a local `UserRealmObject` exists with matching credentials, `HandleSuccess()` is called and the user is logged in.

This means:
1. An account that has been revoked, suspended, or deleted server-side can continue to authenticate locally as long as cached credentials exist on-device.
2. A device with no network connectivity bypasses all server-side access controls.
3. The offline check uses `loginEmail` (the MD5 hash of the email, set at line 82) but the `UserDb.get(String, String)` query (line 59 of `UserDb.java`) matches on `email` and `password` fields stored in Realm — the stored email field is the plaintext email from the server response (`loginItem.email` in `createUser()`), while `loginEmail` is the MD5 hash. This creates a potential mismatch: the offline lookup queries hashed email against a plaintext stored email, meaning the fallback may never succeed even when it should — or the semantics are inconsistent depending on how `setTemporaryLoginInformation` is called relative to stored data.

There is no test that:
- exercises the `onFailed` path with a non-502 status code;
- verifies that a revoked account cannot authenticate offline;
- verifies that the credential comparison in the offline path is consistent (hashed vs. plaintext);
- verifies that a 502 response triggers `HandleIncorrectCredentials()` and not the offline fallback.

---

#### A68-6
**Severity:** MEDIUM
**Location:** `CurrentUser.login()` — lines 80–112
**Title:** No test for the `onSucceed` path with an empty result array

In `onSucceed` (line 87), if `result.arrayList` is non-null but empty (`size() == 0`), `HandleIncorrectCredentials()` is called. There is no test verifying this path. Additionally, there is no test for `result.arrayList` being `null`.

---

#### A68-7
**Severity:** HIGH
**Location:** `CurrentUser.setTemporaryLoginInformation()` — lines 120–123; `CurrentUser.login()` — line 82
**Title:** MD5 used for password hashing with no test for correctness or collision resistance

`setTemporaryLoginInformation()` hashes the password via `CommonFunc.MD5_Hash(password)` (line 122) and stores the result in the static field `loginPassword`. In `login()`, `loginParameter.password = loginPassword` sends this MD5 hash as the credential to the server.

MD5 is cryptographically broken:
- It is vulnerable to collision attacks (two different inputs can produce the same hash).
- It is vulnerable to preimage attacks using rainbow tables.
- Sending an MD5 hash as a password is equivalent to sending the plaintext password if the hash is intercepted, since the server accepts the hash as the credential (the hash itself becomes the secret).

The email is also MD5-hashed (`loginParameter.email = CommonFunc.MD5_Hash(loginEmail)` at line 82), where `loginEmail` was already stored as the raw email string (line 122 sets `loginEmail = email`, not a hash of email — the MD5 of the email is computed only at login time, line 82).

There is no test that:
- verifies `MD5_Hash()` produces the correct output for known inputs;
- verifies that a collision in MD5 does not permit a different password to authenticate;
- verifies the hash is computed correctly before transmission;
- verifies the password is not transmitted in plaintext on any code path.

---

#### A68-8
**Severity:** MEDIUM
**Location:** `CurrentUser.get()` — lines 26–29
**Title:** Static `user` field caching has no test for stale-cache behavior across user switches

`get()` returns the cached static `user` if non-null, falling back to a database lookup by the persisted user ID. There is no test that verifies:
- switching users (calling `setUser()` for a different user) correctly updates the cache;
- after `logout()` (which nulls `user` but does not update `CURRENT_USER_ID_KEY` to an invalid sentinel), a subsequent `get()` call correctly returns `null` rather than re-loading the previous user from the database.

The key `CURRENT_USER_ID_KEY` is deleted by `logout()` (line 126), so `ModelPrefs.readInt()` with a missing key will return 0 (or a default). `UserDb.get(0)` would then query for a user with `id == 0`, which may or may not return `null` depending on stored data. This edge case is untested.

---

#### A68-9
**Severity:** MEDIUM
**Location:** `CurrentUser.setUser(LoginItem loginItem)` — lines 37–46
**Title:** No test for `loginItem.drivers` being null or empty

`setUser(LoginItem loginItem)` iterates `loginItem.drivers` at line 38 without a null check. If `loginItem.drivers` is `null`, a `NullPointerException` will be thrown. There is no test for this path. Similarly, `loginItem.arrDriverTrainings` passed to `setUserTraining()` at line 41 has no null guard and is stored directly into the static `training` field, which is then returned by `getTrainingList()` — a null list would propagate to all callers.

---

#### A68-10
**Severity:** LOW
**Location:** `CurrentUser.getTrainingList()` — lines 53–56
**Title:** No test for initial empty training list vs. null training after `setUserTraining(null)`

`training` is initialized to an empty `ArrayList` (line 24). However, `setUserTraining()` (line 48) replaces it with whatever `newTraining` is passed in, including `null` (see A68-9). There is no test that verifies `getTrainingList()` returns a non-null list when the server returns a null `arrDriverTrainings`.

---

## File 3: User.java

### Reading Evidence

**Fully qualified class name:** `au.com.collectiveintelligence.fleetiq360.user.User`

**Fields defined:**

| Line | Name | Type |
|---|---|---|
| 12 | `id` | `private int` |
| 13 | `companyId` | `private int` |
| 14 | `firstName` | `private String` |
| 15 | `lastName` | `private String` |
| 16 | `email` | `private String` |
| 17 | `password` | `private String` |
| 18 | `phoneNumber` | `private String` |
| 19 | `licenseNumber` | `private String` |
| 20 | `expiryDate` | `private Date` |
| 21 | `address` | `private String` |
| 22 | `securityNumber` | `private String` |
| 23 | `photoUrl` | `private String` |
| 24 | `isContactPerson` | `private boolean` |
| 25 | `dateFormat` | `private String` |
| 26 | `maxSessionLength` | `private int` |
| 27 | `complianceDate` | `private Date` |
| 28 | `gps_frequency` | `private int` |

**Methods:**

| Line | Signature |
|---|---|
| 30 | `User(int id, int companyId, String firstName, String lastName, String email, String password, String phoneNumber, String licenseNumber, Date expiryDate, String address, String securityNumber, String photoUrl, boolean isContactPerson, String dateFormat, int maxSessionLength, Date complianceDate, int gpsFrequency)` (package-private constructor) |
| 66 | `public String fullName()` |
| 70 | `public String definedName()` |
| 78 | `public boolean complianceIsValid()` |
| 82 | `public boolean hasAssociatedDrivers()` |
| 86 | `public List<User> associatedDrivers()` |
| 90 | `public void updateInformation(String firstName, String lastName, String complianceDate)` |
| 97 | `public void updateLicense(String licenseNumber, String securityNumber, String address, String expiryDate)` |
| 105 | `public void updateCompliance(Date complianceDate)` |
| 110 | `void setPassword(String password)` (package-private) |
| 115 | `public int getId()` |
| 119 | `public int getCompanyId()` |
| 123 | `public String getFirstName()` |
| 127 | `public String getLastName()` |
| 131 | `public String getEmail()` |
| 135 | `public String getPassword()` |
| 139 | `String getPhoneNumber()` (package-private) |
| 143 | `public String getLicenseNumber()` |
| 147 | `public Date getExpiryDate()` |
| 151 | `public String getAddress()` |
| 155 | `public String getSecurityNumber()` |
| 159 | `public String getPhotoUrl()` |
| 163 | `public boolean isContactPerson()` |
| 167 | `public String getDateFormat()` |
| 171 | `public int getMaxSessionLength()` |
| 175 | `public int getGps_frequency()` |
| 179 | `public Date getComplianceDate()` |

---

### Findings — User.java

#### A68-11
**Severity:** HIGH
**Location:** `User.getPassword()` — line 135
**Title:** Password stored and exposed in plaintext via public getter; no test verifying this field is not logged or serialized

`User` stores the password as a `private String password` field (line 17) and exposes it via `public String getPassword()` (line 135). The password is set from `loginItem.password` (via `createUser()` in `CurrentUser`, line 66 of `CurrentUser.java`) and is the MD5 hash of the user's password (due to hashing in `setTemporaryLoginInformation()`).

`setPassword()` at line 110 is package-private and called by `CurrentUser.login()` (`get().setPassword(loginPassword)` at line 90 of `CurrentUser.java`), storing `loginPassword` (the MD5 hash) into the `User` object, which is then persisted to the Realm database via `UserDb.save(this)` at line 112.

There is no test that verifies:
- the password value returned by `getPassword()` is not logged anywhere in the application;
- the password is not included in any serialized representation of `User` sent to external services;
- `getPassword()` cannot be called by code outside the `user` package (it is public, so it can be called from anywhere).

---

#### A68-12
**Severity:** MEDIUM
**Location:** `User.definedName()` — lines 70–76
**Title:** No test for `definedName()` when both `firstName` and `lastName` are empty but `email` is also empty

`definedName()` returns `fullName()` if either `firstName` or `lastName` is non-empty, then returns `email` if non-empty, and falls back to `"-"`. There is no test for any of these branches. In particular:
- `fullName()` (line 66) uses `String.format("%s %s", firstName, lastName)` — if both are empty strings, the result is `" "` (a single space), not `"-"`. The condition at line 71 is `!firstName.isEmpty() || !lastName.isEmpty()`, which is `false` when both are empty, so `" "` would not be returned in that case — but this logic is subtle and untested.
- There is no test for `firstName` or `lastName` being `null`, which would cause a `NullPointerException` in both `fullName()` and the `isEmpty()` calls in `definedName()`.

---

#### A68-13
**Severity:** MEDIUM
**Location:** `User.complianceIsValid()` — lines 78–80
**Title:** No test for `complianceIsValid()` date semantics; method name implies validity but only checks for non-null

`complianceIsValid()` returns `complianceDate != null`. It does not check whether the compliance date has expired (i.e., whether `complianceDate` is in the future). A user with a past compliance date is considered "valid" by this method. There is no test exercising:
- a past `complianceDate`;
- a future `complianceDate`;
- a null `complianceDate`.

---

#### A68-14
**Severity:** MEDIUM
**Location:** `User.hasAssociatedDrivers()` — line 82–84
**Title:** No test for `hasAssociatedDrivers()` when `isContactPerson` is false vs. true

`hasAssociatedDrivers()` queries the database (`UserDb.driversOfCompany(companyId)`) only when `isContactPerson` is `true`. There is no test for either branch or for the case where the database query returns an empty list vs. a non-empty list.

---

#### A68-15
**Severity:** LOW
**Location:** `User` constructor — line 60
**Title:** Default date format `"MM/dd/yyyy"` applied silently when `dateFormat` is null; no test for null vs. empty string

The constructor applies `dateFormat == null ? "MM/dd/yyyy" : dateFormat` (line 60). If `dateFormat` is an empty string `""`, the empty string is stored and used. There is no test verifying the null-substitution behavior or the empty-string edge case.

---

#### A68-16
**Severity:** LOW
**Location:** All `update*()` methods — lines 90–108
**Title:** `updateInformation()`, `updateLicense()`, `updateCompliance()` have no tests

All three mutation methods directly modify fields and call `UserDb.save(this)`. There are no tests for:
- partial updates (e.g., passing `null` for individual parameters);
- date parsing failures in `ServerDateFormatter.parseDate()` returning `null` (which would overwrite a valid date with `null`);
- concurrency: these methods modify an object that may be referenced by the static `CurrentUser.user` field from any thread.

---

#### A68-17
**Severity:** INFO
**Location:** `User.java` — general
**Title:** All getter methods are untested; no test for `User` object construction

The 17-parameter package-private constructor has no test verifying that all fields are correctly assigned. Each public getter is untested. While getters are trivial, the constructor is not — particularly the `gpsFrequency` parameter name vs. `gps_frequency` field name inconsistency (line 28 vs. line 62), and the `dateFormat` null substitution.

---

## Summary Table

| ID | Severity | File | Title |
|---|---|---|---|
| A68-0 | HIGH | Project-wide | No automated test coverage in `app/` and `LibCommon/` |
| A68-1 | CRITICAL | UserPhotoFragment.java | `SSLCertificateHandler.nuke()` disables all TLS validation globally; no test preventing production use |
| A68-2 | CRITICAL | UserPhotoFragment.java | No test file for `UserPhotoFragment`; `showUserPhoto()` entirely untested including path that calls `nuke()` |
| A68-3 | MEDIUM | UserPhotoFragment.java | Empty-string `photoUrl` not guarded; `nuke()` still invoked |
| A68-4 | HIGH | CurrentUser.java | `logout()` does not clear `loginEmail`/`loginPassword`; no test for credential erasure |
| A68-5 | HIGH | CurrentUser.java | Offline fallback in `login()` allows revoked accounts to authenticate; credential comparison inconsistency (hash vs. plaintext) untested |
| A68-6 | MEDIUM | CurrentUser.java | No test for `onSucceed` with empty or null result array |
| A68-7 | HIGH | CurrentUser.java | MD5 password hashing; no test for correctness or collision resistance |
| A68-8 | MEDIUM | CurrentUser.java | Stale-cache behavior after logout/user-switch untested |
| A68-9 | MEDIUM | CurrentUser.java | No null check on `loginItem.drivers`; NPE risk untested |
| A68-10 | LOW | CurrentUser.java | `getTrainingList()` can return null after `setUserTraining(null)`; untested |
| A68-11 | HIGH | User.java | Password exposed via public `getPassword()`; no test verifying it is not logged or serialized externally |
| A68-12 | MEDIUM | User.java | `definedName()` null/empty edge cases untested; NPE risk with null first/last name |
| A68-13 | MEDIUM | User.java | `complianceIsValid()` does not check date expiry; semantics untested |
| A68-14 | MEDIUM | User.java | `hasAssociatedDrivers()` branches untested |
| A68-15 | LOW | User.java | Default `dateFormat` null-substitution and empty-string edge case untested |
| A68-16 | LOW | User.java | `updateInformation()`, `updateLicense()`, `updateCompliance()` untested including null-date and concurrency risks |
| A68-17 | INFO | User.java | Constructor field assignment and all getters untested |
