# Audit Pass 2 — Agent A07
**Audit run:** 2026-02-26-01
**Agent:** A07
**Files assigned:**
1. `LibCommon/src/main/java/com/yy/libcommon/LibConfig.java`
2. `LibCommon/src/main/java/com/yy/libcommon/NotesDialog.java`
3. `LibCommon/src/main/java/com/yy/libcommon/RadioImageButton.java`

---

## Project-Wide Finding: Zero Automated Test Coverage

### A07-1 [HIGH] — No test directories exist anywhere in the project

**Scope:** Project-wide (affects all modules: `app/`, `LibCommon/`)

A comprehensive glob search for `**/test/**/*.java` and `**/androidTest/**/*.java` across the entire repository returned zero results. Neither the `app/` module nor the `LibCommon/` module contains a `test/` or `androidTest/` source set. There are no unit tests, no instrumentation tests, and no test resources of any kind.

Every method, every error path, every boundary condition, and every integration point in all source files is completely without automated verification. Any regression introduced by a code change will not be caught by automated means before it reaches production.

**Evidence:**
- `find **/test/**/*.java` → 0 files found
- `find **/androidTest/**/*.java` → 0 files found
- No `src/test/` or `src/androidTest/` directories exist in `app/` or `LibCommon/`

**Recommendation:** Establish JUnit 4/5 unit test source sets and Espresso/Robolectric instrumentation test sets for both modules. Prioritise logic-bearing classes first (`RadioImageButton`, `NotesDialog`, `FileManager`).

---

## File 1: `LibConfig.java`

### Reading Evidence

**Fully qualified class name:** `com.yy.libcommon.LibConfig`

**Methods defined:** None (no methods)

**Constants defined:**
| Line | Name | Type | Value |
|------|------|------|-------|
| 8 | `BASE_DIRECTOY` | `public static final String` | `"ForkIQ360"` |
| 9 | `IMAGE_DIRECTORY` | `public static final String` | `"images"` |

**Types/interfaces/errors defined:** None

**Cross-reference:** Both constants are consumed by `FileManager.java` to construct external-storage file paths (confirmed by grep).

---

### Findings for LibConfig.java

### A07-2 [MEDIUM] — Typo in constant name `BASE_DIRECTOY` is untested and permanently baked in

`BASE_DIRECTOY` (line 8) is missing the letter `r` — it should be `BASE_DIRECTORY`. Because there are no tests, nothing validates this constant's value or its correct spelling. All callers in `FileManager` embed this constant in filesystem paths; if the value itself were wrong, no test would catch it. The typo is also part of the public API surface, meaning any external consumer that spells the constant correctly will receive a compile error and must perpetuate the misspelling.

**Severity rationale:** MEDIUM — the constant value `"ForkIQ360"` is currently correct even though its name is misspelled, so there is no runtime failure today. However, no test guards against a future accidental change to the value, and the API surface is misleading.

**Untested conditions:**
- Constant value equals exactly `"ForkIQ360"` (no spaces, correct capitalisation, no trailing slash)
- Constant value equals exactly `"images"`
- Both constants are non-null and non-empty

### A07-3 [LOW] — Constants carry no test for non-null/non-empty contract

Both `BASE_DIRECTOY` and `IMAGE_DIRECTORY` are used directly in `File.separator`-joined path construction inside `FileManager`. There is no test asserting that either constant is non-null and non-empty before it is used as a path component. While the literals are hardcoded and cannot be null in practice, the contract is undocumented and untested, leaving no safety net if the class is ever refactored to load values from configuration.

---

## File 2: `NotesDialog.java`

### Reading Evidence

**Fully qualified class name:** `com.yy.libcommon.NotesDialog`

**Superclass:** `com.yy.libcommon.BaseDialog` (which extends `android.support.v4.app.DialogFragment`)

**Methods defined:**
| Line | Signature |
|------|-----------|
| 32 | `public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState)` |
| 40 | `public static NotesDialog newInstance(String title, String hint, String content, Callback callback)` |
| 63 | `public void setAcceptText(String string)` |
| 69 | `protected void setupViews()` |

**Inner interfaces defined:**
| Line | Name |
|------|------|
| 117 | `public interface Callback { void callback(String notes); }` |

**Fields:**
- `mCallback` (Callback, line 19)
- `mTitleTextView` (TextView, line 20)
- `mInputEditText` (EditText, line 21)
- `mSaveButton` (Button, line 22)
- `mSaveButtonText` (String, line 23)
- `mCancelButton` (Button, line 24)
- `mTitle` (String, line 26)
- `mHint` (String, line 27)
- `mContent` (String, line 28)

---

### Findings for NotesDialog.java

### A07-4 [CRITICAL] — `mCallback` null-pointer dereference on Save button click with no test

In `setupViews()` (line 101–107), the Save button's `OnClickListener` calls `mCallback.callback(...)` unconditionally. `mCallback` is only assigned in `newInstance()` when the `callback` argument is non-null (line 52–54). If `newInstance()` is called with `callback == null`, `mCallback` remains `null` and any tap of the Save button will throw a `NullPointerException` at runtime, crashing the host activity.

There is no test covering:
- `newInstance()` with `callback == null` followed by a click of the Save button
- Any defensive null-check of `mCallback` before invocation

**Location:** Line 104 — `mCallback.callback(mInputEditText.getText().toString());`

**Severity rationale:** CRITICAL — this is a guaranteed crash path that can be reached through normal UI interaction. The factory method silently accepts a null callback with no indication to the caller that doing so makes the dialog non-functional and crash-prone.

### A07-5 [HIGH] — `newInstance()` silently discards null arguments with no test

`newInstance()` (lines 40–61) treats all four parameters as optional using null checks, but provides no feedback to the caller when a null is passed. In particular:

- Passing `callback == null` results in a crashable dialog (see A07-4).
- Passing `title == null` causes `setupViews()` to fall back to the hardcoded string `"Title"` (line 81), which may be unintended.
- Passing `hint == null` sets hint to empty string (line 91).
- Passing `content == null` sets text to empty string (line 98).

No tests exercise any of these null paths, so the silent-fallback behaviour is invisible and could mask caller errors for years.

**Untested paths:**
- `newInstance(null, null, null, null)` — all nulls
- `newInstance(null, validHint, validContent, validCallback)` — null title → fallback to "Title"
- `newInstance(validTitle, null, validContent, validCallback)` — null hint → empty hint
- `newInstance(validTitle, validHint, null, validCallback)` — null content → empty text

### A07-6 [HIGH] — `setAcceptText()` called after dialog shown has no effect; no test for ordering

`setAcceptText(String string)` (line 63) stores its value in `mSaveButtonText`, which is applied in `setupViews()`. `setupViews()` is invoked from `onActivityCreated()` in `BaseDialog` (before the caller has any opportunity to call `setAcceptText()` post-show). If `setAcceptText()` is called after the dialog is already attached and `setupViews()` has already executed, the button text will not update because there is no guard or re-application logic. There is no test verifying:

- Correct ordering: `setAcceptText()` before show → button text changes
- Late call: `setAcceptText()` after show → button text does NOT change (surfacing the ordering dependency)
- `setAcceptText(null)` — no null guard exists; `mSaveButton.setText(null)` would be called

### A07-7 [MEDIUM] — Save button delivers empty string to callback without warning; no test

When the user taps Save without entering any text, `mInputEditText.getText().toString()` returns an empty string `""`, and `mCallback.callback("")` is called with no indication to the dialog or the caller that the input was empty. No test exercises:

- Save with empty input
- Save with whitespace-only input
- Save with maximum-length input (potential truncation or performance issue)

The calling code in `EquipmentPrestartFragment` stores the result directly as a comment string with no validation. The untested empty-string path propagates silently to the data layer.

### A07-8 [MEDIUM] — `onCreateView()` calls `super.onCreate()` instead of `super.onCreateView()`; no test to catch regression

At line 33, `onCreateView()` calls `super.onCreate(savedInstanceState)` rather than `super.onCreateView(inflater, container, savedInstanceState)`. This is an incorrect lifecycle call — `onCreate()` is a different lifecycle method than `onCreateView()`. Because `BaseDialog` does not override `onCreate()` in a meaningful way the bug is latent, but this represents a structural error in lifecycle management. No test exercises the creation path to detect this kind of regression if the base class behaviour changes.

### A07-9 [LOW] — `setupViews()` hard-codes fallback title string "Title" with no test

Line 81 sets the title to the hardcoded literal `"Title"` when `mTitle` is null. This is a UI string baked into Java source rather than a string resource, bypassing localisation. No test asserts the fallback value, so a future change to this literal would not be caught.

---

## File 3: `RadioImageButton.java`

### Reading Evidence

**Fully qualified class name:** `com.yy.libcommon.RadioImageButton`

**Superclass:** `android.widget.ImageButton`
**Implements:** `android.widget.Checkable`

**Methods defined:**
| Line | Signature |
|------|-----------|
| 14 | `public RadioImageButton(Context context)` |
| 18 | `public RadioImageButton(Context context, AttributeSet attrs)` |
| 23 | `public RadioImageButton(Context context, AttributeSet attrs, int defStyle)` |
| 31 | `private void parseAttributes(AttributeSet attrs)` |
| 41 | `public boolean isChecked()` |
| 46 | `public void setChecked(boolean checked)` |
| 59 | `public void toggle()` |
| 68 | `public boolean performClick()` |
| 75 | `public OnCheckedChangeListener getOnCheckedChangeListener()` |
| 79 | `public void setOnCheckedChangeListener(OnCheckedChangeListener onCheckedChangeListener)` |
| 83 | `public void setOnClickListener(OnCheckedChangeListener onCheckedChangeListener)` |
| 88 | `public void onCheckedChanged(RadioImageButton buttonView, boolean isChecked)` (inside `OnCheckedChangeListener`) |

**Fields:**
| Line | Name | Type | Initial value |
|------|------|------|---------------|
| 12 | `onCheckedChangeListener` | `OnCheckedChangeListener` | `null` |
| 13 | `isChecked` | `boolean` (package-private) | `false` |
| 28 | `checkedDrawable` | `int` | `0` (default) |
| 29 | `uncheckedDrawable` | `int` | `0` (default) |

**Inner classes:**
| Line | Name |
|------|------|
| 87 | `public static class OnCheckedChangeListener` |

**Constants/Errors defined:** None

---

### Findings for RadioImageButton.java

### A07-10 [HIGH] — `toggle()` is asymmetric (one-way only); behaviour is non-obvious and untested

`toggle()` (lines 59–65) returns immediately if `isChecked` is true, making it impossible to uncheck the button by toggling. This is an intentional "radio" semantic (once checked, stays checked), but it diverges from the standard `Checkable.toggle()` contract which must flip state in both directions. No test documents or verifies this one-way behaviour, meaning:

- There is no test confirming that `toggle()` on a checked button is a no-op.
- There is no test confirming that `toggle()` on an unchecked button checks it.
- The semantic distinction from a standard toggle is entirely undocumented.

A developer unfamiliar with this class who calls `toggle()` expecting bidirectional behaviour will silently get wrong results.

### A07-11 [HIGH] — `setChecked()` calls `setImageResource()` with potentially invalid resource IDs; no test

`setChecked(boolean checked)` (line 51) calls `setImageResource(isChecked ? checkedDrawable : uncheckedDrawable)`. The single-argument constructor `RadioImageButton(Context context)` (line 14) never calls `parseAttributes()`, so `checkedDrawable` and `uncheckedDrawable` remain `0` (the default `int` value). Calling `setImageResource(0)` clears the image to nothing rather than throwing an exception, producing silent visual failure. No test covers:

- Constructing with the single-argument constructor and calling `setChecked(true)` or `setChecked(false)`
- The sentinel value `-1` returned by `a.getResourceId()` when the attribute is absent (line 34–35) — `setImageResource(-1)` will throw a `Resources.NotFoundException` at runtime

### A07-12 [HIGH] — `parseAttributes()` does not recycle `TypedArray` on exception; no test for attribute error path

`parseAttributes()` (lines 31–38) calls `a.recycle()` only at the end of the happy path. If `a.getResourceId()` or `setChecked()` throws an exception, `a.recycle()` is never called, leaking the `TypedArray` native resource. No test exercises attribute parsing with invalid or missing style attributes to verify correct resource cleanup.

### A07-13 [MEDIUM] — `setOnClickListener(OnCheckedChangeListener)` is a no-op silently shadowing `View.setOnClickListener()`

Lines 83–85 declare a method named `setOnClickListener` that accepts an `OnCheckedChangeListener` and does nothing. This method shadows (in name only — the parameter type differs) the standard `View.setOnClickListener(View.OnClickListener)`. Any caller who mistakenly passes an `OnCheckedChangeListener` to this method will see a successful compile and a silently discarded listener. No test verifies that this method does nothing, and no test detects the naming confusion.

### A07-14 [MEDIUM] — `performClick()` calls `toggle()` but `toggle()` is a no-op when checked; click on checked button fires listener only via `super.performClick()`

`performClick()` (lines 68–73) calls `toggle()`, which is a no-op if already checked. This means a click on an already-checked `RadioImageButton` does not invoke `onCheckedChanged()`. However, `super.performClick()` still fires any standard `View.OnClickListener`. This split between the radio-listener and standard click listener is untested, and the asymmetry can cause callers to believe a click always results in a state-change callback when it does not.

**Untested paths:**
- Click on checked button → no `onCheckedChanged` fired, but `performClick()` returns `true`
- Click on unchecked button → `onCheckedChanged` fires and `performClick()` returns `true`
- Rapid repeated clicks on unchecked button (first click checks it; subsequent clicks are no-ops)

### A07-15 [MEDIUM] — `isChecked` field has package-private visibility instead of private; no test guards encapsulation

`isChecked` (line 13) is package-private (no access modifier). This allows any class in the same package to directly mutate the field, bypassing `setChecked()` and the listener notification mechanism. No test verifies that state changes always go through `setChecked()`, leaving the listener contract unenforceable from outside the class.

### A07-16 [LOW] — `OnCheckedChangeListener.onCheckedChanged()` base implementation has an explicit `return` statement that is meaningless

Line 89 (`return;`) in the no-op base implementation of `OnCheckedChangeListener.onCheckedChanged()` is syntactically valid but adds no value. No test verifies that overriding subclasses are actually called (the base class being a concrete class rather than an interface or abstract class means a caller could instantiate the base directly and receive no-op callbacks silently).

### A07-17 [LOW] — Single-argument constructor `RadioImageButton(Context context)` never calls `parseAttributes()`; drawable fields remain 0

This is the programmatic construction path. When a developer constructs `RadioImageButton` in code rather than XML, `checkedDrawable` and `uncheckedDrawable` are `0` with no way to set them except via `setImageResource` manually (which the class does not expose as a setter). There is no test confirming what the visual state of the button is when constructed programmatically and then checked/unchecked.

---

## Summary Table

| ID | Severity | File | Short Description |
|----|----------|------|-------------------|
| A07-1 | HIGH | Project-wide | Zero automated test coverage across all modules |
| A07-2 | MEDIUM | LibConfig.java | Typo in `BASE_DIRECTOY` constant name; value untested |
| A07-3 | LOW | LibConfig.java | No tests assert constants are non-null and non-empty |
| A07-4 | CRITICAL | NotesDialog.java | NPE crash when callback is null and Save is tapped |
| A07-5 | HIGH | NotesDialog.java | `newInstance()` silently ignores null args; no tests for null paths |
| A07-6 | HIGH | NotesDialog.java | `setAcceptText()` ordering dependency untested; null not guarded |
| A07-7 | MEDIUM | NotesDialog.java | Empty/whitespace input delivered to callback without validation; untested |
| A07-8 | MEDIUM | NotesDialog.java | `onCreateView()` calls `super.onCreate()` (wrong lifecycle method); untested |
| A07-9 | LOW | NotesDialog.java | Hardcoded fallback title "Title" bypasses localisation; untested |
| A07-10 | HIGH | RadioImageButton.java | `toggle()` is one-way only; asymmetric contract untested |
| A07-11 | HIGH | RadioImageButton.java | `setChecked()` with uninitialised or -1 drawable resource IDs; untested |
| A07-12 | HIGH | RadioImageButton.java | `TypedArray` leak on exception in `parseAttributes()`; error path untested |
| A07-13 | MEDIUM | RadioImageButton.java | `setOnClickListener(OnCheckedChangeListener)` is silent no-op |
| A07-14 | MEDIUM | RadioImageButton.java | Click on checked button fires no `onCheckedChanged`; split listener untested |
| A07-15 | MEDIUM | RadioImageButton.java | `isChecked` field is package-private; bypasses listener notification |
| A07-16 | LOW | RadioImageButton.java | No-op base `OnCheckedChangeListener` returns silently; untested |
| A07-17 | LOW | RadioImageButton.java | Programmatic construction leaves drawable fields at 0; untested |
