# Pass 2 Test Coverage Audit — Agent A11
**Repo:** forkliftiqapp
**Date:** 2026-02-27
**Audit Run:** 2026-02-26-01
**Agent:** A11
**Stack:** Android / Java
**Assigned File:** `LibCommon/src/main/java/com/yy/libcommon/YesNoDialog.java`

---

## Project-Wide Finding: Zero Automated Test Coverage

**[A11-1] [HIGH] No test directories exist in app/ or LibCommon/ modules**

Neither the `app/` module nor the `LibCommon/` module contains any `src/test/` or `src/androidTest/` directory. Confirmed by filesystem search across the repository:

- `app/src/test/` — does not exist
- `app/src/androidTest/` — does not exist
- `LibCommon/src/test/` — does not exist
- `LibCommon/src/androidTest/` — does not exist

The only test directories found in the entire repository belong to third-party library modules (`LibImageloader/src/test`, `LibImagePicker/src/androidTest`, `LibPercentProgress/src/androidTest`), none of which contain tests for application code.

This means every class in `app/` and `LibCommon/` — including all business logic, UI components, presenters, dialogs, and utilities — has zero automated test coverage. No unit tests, no instrumented tests, no integration tests. Every finding below describing an "untested method" or "untested path" exists within this broader context of total absence of test infrastructure.

Severity is **HIGH** because the absence of any test harness means regressions, logic errors, and edge-case failures in any module can only be caught manually. This applies to the entire `LibCommon` library used across the application.

---

## Reading Evidence

### Fully Qualified Class Name

`com.yy.libcommon.YesNoDialog`

**File:** `LibCommon/src/main/java/com/yy/libcommon/YesNoDialog.java`
**Superclass:** `com.yy.libcommon.BaseDialog` (which extends `android.support.v4.app.DialogFragment`)

---

### Every Method — Line Number and Signature

| Line | Visibility | Signature |
|------|-----------|-----------|
| 36   | `public` (override) | `View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState)` |
| 45   | `public static` | `YesNoDialog newInstance(String title, String content, String buttonAcceptText, String buttonDeclineText, int timeoutInSeconds, Callback callback)` |
| 88   | `public` (override) | `void onActivityCreated(Bundle savedInstanceState)` |
| 95   | `public` | `void init()` |
| 107  | `private` | `void setInitialValues()` |
| 134  | `private` | `void setListeners()` |

**Inner interface `Callback` (lines 159–167):**

| Line | Visibility | Signature |
|------|-----------|-----------|
| 161  | `public` | `void onAcceptPress()` |
| 163  | `public` | `void onDeclinePress()` |
| 165  | `public` | `void onTimeOutDialog()` |

---

### Every Field / Constant / Type Defined

| Line | Kind | Name | Type |
|------|------|------|------|
| 20   | instance field | `mRootView` | `ViewGroup` (private) |
| 22   | instance field | `mTitleTextView` | `TextView` (private) |
| 23   | instance field | `mDetailsTextView` | `TextView` (private) |
| 24   | instance field | `mAcceptButton` | `Button` (private) |
| 25   | instance field | `mDeclineButton` | `Button` (private) |
| 27   | instance field | `mTitle` | `String` (private) |
| 28   | instance field | `mContent` | `String` (private) |
| 29   | instance field | `mAcceptButtonText` | `String` (private) |
| 30   | instance field | `mDeclineButtonText` | `String` (private) |
| 31   | class field | `countDownTimer` | `CountDownTimer` (private static) |
| 32   | instance field | `mCallback` | `Callback` (private) |
| 159  | inner interface | `Callback` | interface (public) |

---

## Findings

---

### A11-2 [HIGH] `newInstance` — null callback with positive timeout is silently ignored

**File:** `YesNoDialog.java`, lines 66–81
**Method:** `newInstance`

```java
if (callback != null){
    fragment.mCallback = callback;

    if(timeoutInSeconds > 0) {
        countDownTimer = new CountDownTimer(1000 * timeoutInSeconds, 1000) {
            ...
            public void onFinish() {
                fragment.mCallback.onTimeOutDialog();
            }
        }.start();
    }
}
```

If `callback` is `null` and `timeoutInSeconds > 0`, no timer is created and no warning is issued. The dialog will be displayed with no programmatic way to dismiss it (since `setCancelable(false)` is set at line 41), effectively locking the UI permanently. There is no test for the combination of `callback == null` and `timeoutInSeconds > 0`.

There is also no test for `callback == null` combined with the accept or decline button being pressed: `setListeners()` at line 134 calls `mCallback.onAcceptPress()` and `mCallback.onDeclinePress()` unconditionally at lines 139 and 149 without a null guard. If `newInstance` is called without a callback, pressing either button will throw a `NullPointerException` at runtime. No test exercises this crash path.

---

### A11-3 [HIGH] `setListeners` — `mCallback` null dereference on button press

**File:** `YesNoDialog.java`, lines 134–157
**Method:** `setListeners` (private)

```java
mAcceptButton.setOnClickListener(new View.OnClickListener() {
    @Override
    public void onClick(View v) {
        mCallback.onAcceptPress();   // line 139 — no null check
        if(countDownTimer != null)
            countDownTimer.cancel();
        dismiss();
    }
});

mDeclineButton.setOnClickListener(new View.OnClickListener() {
    @Override
    public void onClick(View v) {
        mCallback.onDeclinePress();  // line 149 — no null check
        if(countDownTimer != null)
            countDownTimer.cancel();
        dismiss();
    }
});
```

`mCallback` is only assigned inside the `if (callback != null)` block in `newInstance` (line 66). It has no default value and is never assigned elsewhere. If `newInstance` is called with `callback == null`, `mCallback` remains `null`. When the user taps either button, `mCallback.onAcceptPress()` or `mCallback.onDeclinePress()` throws a `NullPointerException`, crashing the app.

No test covers:
- Pressing accept when `callback` was `null` at construction time.
- Pressing decline when `callback` was `null` at construction time.

---

### A11-4 [HIGH] `static countDownTimer` field causes cross-instance timer corruption

**File:** `YesNoDialog.java`, line 31
**Method:** `newInstance`, lines 69–79

```java
private static CountDownTimer countDownTimer;
```

`countDownTimer` is declared `static`. Every call to `newInstance` with `timeoutInSeconds > 0` overwrites the single shared static reference. If two `YesNoDialog` instances are created with a timeout (possible in multi-pane layouts or rapid navigation), the timer from the first instance is abandoned (not cancelled) and replaced by the timer from the second. The first dialog's timeout will never fire, but the first timer continues running internally, burning resources. Additionally, when the second dialog is dismissed, its `countDownTimer.cancel()` call at lines 141 and 151 operates on the correct (second) timer — but if the sequence is reversed (second created before first is dismissed), `countDownTimer.cancel()` in the first dialog's click handler cancels the second dialog's timer.

No test covers:
- Constructing two `YesNoDialog` instances with timeouts in sequence.
- Verifying that only the intended timer fires.
- Verifying that cancelling one dialog does not affect a different dialog's timer.

---

### A11-5 [MEDIUM] `newInstance` — zero-length string inputs not tested

**File:** `YesNoDialog.java`, lines 45–85
**Method:** `newInstance`

The factory method guards against `null` for all four string parameters (`title`, `content`, `buttonAcceptText`, `buttonDeclineText`) but has no guard against empty strings (`""`). An empty string is accepted and set on the corresponding field, which then flows into `setInitialValues()`. Empty strings will result in blank labels in the UI. While not a crash, empty button labels (`mAcceptButton.setText("")`) make the dialog non-functional from a user perspective.

No test covers:
- `title = ""`
- `content = ""`
- `buttonAcceptText = ""`
- `buttonDeclineText = ""`
- All four simultaneously empty.

---

### A11-6 [MEDIUM] `newInstance` — negative or zero `timeoutInSeconds` boundary not tested

**File:** `YesNoDialog.java`, lines 69–80
**Method:** `newInstance`

```java
if(timeoutInSeconds > 0) {
    countDownTimer = new CountDownTimer(1000 * timeoutInSeconds, 1000) { ... }.start();
}
```

The timeout guard uses a strict `> 0` check, so `timeoutInSeconds = 0` produces no timer (correct and expected). However:

- `timeoutInSeconds = -1` is also silently accepted and produces no timer. No indication is given to the caller that a negative value was supplied.
- `timeoutInSeconds = Integer.MIN_VALUE` is silently accepted. If the guard were ever changed to `>= 0`, the multiplication `1000 * Integer.MIN_VALUE` would overflow.

No test covers `timeoutInSeconds` values of `0`, `-1`, or `Integer.MIN_VALUE`.

---

### A11-7 [MEDIUM] `onCreateView` — `mRootView` null if layout inflation fails; no error path tested

**File:** `YesNoDialog.java`, lines 36–43
**Method:** `onCreateView`

```java
mRootView = (ViewGroup) inflater.inflate(R.layout.yes_no_dialog, container);
```

If `R.layout.yes_no_dialog` does not exist (e.g., resource stripped by a misconfigured ProGuard/R8 rule or missing in a variant) or if `inflater` is null, layout inflation will throw an exception that propagates uncaught. `mRootView` would remain null, and every subsequent `mRootView.findViewById(...)` call in `init()` would throw a `NullPointerException`. There is no test that exercises the inflation-failure path or verifies the correct layout IDs are resolved.

---

### A11-8 [MEDIUM] `init()` — public method calls `getDialog()` which may return null

**File:** `YesNoDialog.java`, lines 95–105
**Method:** `init()`

```java
public void init(){
    getDialog().getWindow().setLayout(...);
    mTitleTextView = (TextView) mRootView.findViewById(R.id.yes_no_dialog_titleTextView);
    ...
}
```

`init()` is declared `public`, meaning it can be called from outside the class at any time. If `init()` is called before the dialog is attached to a window (i.e., before `onCreateView` has been called and the dialog shown), `getDialog()` returns `null`, and `getDialog().getWindow()` throws a `NullPointerException`. Similarly `mRootView` would be `null` if `init()` is invoked before `onCreateView`. No test covers premature calls to `init()`.

---

### A11-9 [MEDIUM] `setInitialValues` — `mDetailsTextView.setHint("")` instead of `setText("")` when content is null

**File:** `YesNoDialog.java`, lines 115–119
**Method:** `setInitialValues` (private)

```java
if (mContent != null) {
    mDetailsTextView.setText(mContent);
} else {
    mDetailsTextView.setHint("");   // inconsistent — sets hint, not text
}
```

When `mTitle` is null, `mTitleTextView.setText("")` is called (line 112) — the text is cleared. But when `mContent` is null, `mDetailsTextView.setHint("")` is called instead of `setText("")`. This is inconsistent: the hint is set to an empty string (effectively a no-op, since the default hint is already empty) rather than clearing any pre-existing text on the view. If the `TextView` somehow had non-empty text prior to this call, it would not be cleared.

No test verifies the rendering output when `mContent` is `null`, or checks that the `mDetailsTextView` displays the expected state.

---

### A11-10 [MEDIUM] Timer `onFinish` fires on a dialog that may already be destroyed

**File:** `YesNoDialog.java`, lines 76–78
**Method:** anonymous `CountDownTimer.onFinish()` inside `newInstance`

```java
public void onFinish() {
    fragment.mCallback.onTimeOutDialog();
}
```

The `CountDownTimer` holds a strong reference to `fragment` (captured in the anonymous class). If the dialog is destroyed (e.g., back-stack pop, configuration change) before the timer expires, the timer continues to run. When it fires, it calls `fragment.mCallback.onTimeOutDialog()` on a detached/destroyed fragment. This can cause:

- Callbacks operating on a dead fragment's state.
- Memory leaks from the timer retaining the fragment.
- `IllegalStateException` if the callback attempts a fragment transaction.

The timer is only cancelled in the button click listeners (lines 141, 151). There is no cancellation in `onDestroy`, `onStop`, or `onDestroyView`. No test covers the case where the dialog is dismissed or destroyed before the timer fires.

---

### A11-11 [LOW] `newInstance` — all four nullable string parameters untested individually

**File:** `YesNoDialog.java`, lines 45–85
**Method:** `newInstance`

Each of the four string parameters (`title`, `content`, `buttonAcceptText`, `buttonDeclineText`) independently defaults to a null-safe fallback in `setInitialValues`. However, no test exists for:

- Only `title` being null (others non-null).
- Only `content` being null (others non-null).
- Only `buttonAcceptText` being null (others non-null).
- Only `buttonDeclineText` being null (others non-null).
- All four being null simultaneously with a valid callback.

Pairwise and single-parameter null tests are absent.

---

### A11-12 [LOW] `onCreateView` — `super.onCreate()` called instead of `super.onCreateView()`

**File:** `YesNoDialog.java`, line 37
**Method:** `onCreateView`

```java
public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);   // should be super.onCreateView(...)
    ...
}
```

`onCreateView` calls `super.onCreate(savedInstanceState)` rather than `super.onCreateView(inflater, container, savedInstanceState)`. This is a lifecycle contract violation: `super.onCreateView` is never invoked, and `super.onCreate` is called out of sequence (it was already called by the framework before `onCreateView`). While Android's `DialogFragment` implementation may tolerate this in practice (because `DialogFragment.onCreateView` does very little), the omission of the correct super-call and the duplication of the `onCreate` super-call is incorrect and untested. No test verifies the fragment lifecycle proceeds without error.

---

### A11-13 [LOW] `Callback` interface `onTimeOutDialog` — never called except from timer; no test for the case where no timer exists

**File:** `YesNoDialog.java`, lines 159–167
**Interface:** `Callback`

`onTimeOutDialog()` is defined in the `Callback` interface and is only invoked from the `CountDownTimer.onFinish()` anonymous class inside `newInstance`. If `timeoutInSeconds <= 0`, no timer is created and `onTimeOutDialog()` is never called. There is no test that:

- Verifies `onTimeOutDialog` is called exactly once when the timer expires.
- Verifies `onTimeOutDialog` is never called when no timeout is set.
- Verifies behavior when `onTimeOutDialog` is called but the dialog has already been dismissed via button press.

---

### A11-14 [INFO] No test file exists for `YesNoDialog`

**File:** `LibCommon/src/main/java/com/yy/libcommon/YesNoDialog.java`

There is no test file for `YesNoDialog` anywhere in the repository. A grep of the entire codebase for `YesNoDialog` finds it referenced in ten files — all production code. No test directory exists under `LibCommon/src/` at any level. This is a specific manifestation of the project-wide finding A11-1 for this class.

Recommended test file location (if test infrastructure were added):
`LibCommon/src/test/java/com/yy/libcommon/YesNoDialogTest.java` (unit/Robolectric)
`LibCommon/src/androidTest/java/com/yy/libcommon/YesNoDialogTest.java` (instrumented)

---

## Summary Table

| ID    | Severity | Title |
|-------|----------|-------|
| A11-1 | HIGH     | Project-wide: no test directories in `app/` or `LibCommon/` — zero automated test coverage |
| A11-2 | HIGH     | `newInstance`: null callback + positive timeout locks UI; null callback + button press causes NPE |
| A11-3 | HIGH     | `setListeners`: `mCallback` called without null guard — NPE crash on button press when callback is null |
| A11-4 | HIGH     | `static countDownTimer` field causes cross-instance timer corruption when multiple dialogs created |
| A11-5 | MEDIUM   | `newInstance`: empty string inputs (`""`) not tested for any of the four string parameters |
| A11-6 | MEDIUM   | `newInstance`: negative and zero `timeoutInSeconds` boundary values not tested |
| A11-7 | MEDIUM   | `onCreateView`: layout inflation failure path not tested; null `mRootView` propagates to `init()` |
| A11-8 | MEDIUM   | `init()` is public and calls `getDialog()` without null guard — premature call crashes with NPE |
| A11-9 | MEDIUM   | `setInitialValues`: inconsistent null handling — `mDetailsTextView.setHint("")` vs `mTitleTextView.setText("")` — not tested |
| A11-10| MEDIUM   | Timer `onFinish` fires on destroyed/detached fragment; timer not cancelled in `onDestroy`/`onStop` |
| A11-11| LOW      | `newInstance`: individual null combinations for four string parameters not tested |
| A11-12| LOW      | `onCreateView` calls `super.onCreate()` instead of `super.onCreateView()` — lifecycle violation not tested |
| A11-13| LOW      | `Callback.onTimeOutDialog()`: no test for fire-exactly-once, never-fires, or post-dismiss invocation |
| A11-14| INFO     | No test file exists anywhere in the repository for `YesNoDialog` |
