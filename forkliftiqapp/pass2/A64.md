# Audit Pass 2 – Test Coverage
**Agent:** A64
**Audit Run:** 2026-02-26-01
**Assigned Files:**
1. `app/src/main/java/au/com/collectiveintelligence/fleetiq360/ui/fragment/ProfileFragment.java`
2. `app/src/main/java/au/com/collectiveintelligence/fleetiq360/ui/fragment/SavedReportFragment.java`
3. `app/src/main/java/au/com/collectiveintelligence/fleetiq360/ui/fragment/SavedReportListAdapter.java`

---

## Project-Wide Finding: Zero Automated Test Coverage

### A64-1 — HIGH: No test directories exist in app/ or LibCommon/ modules

**Severity:** HIGH

The `app/` module and `LibCommon/` module contain no `test/` or `androidTest/` source sets whatsoever. A search of the entire repository confirms that only third-party library modules (`LibImageloader`, `LibImagePicker`, `LibPercentProgress`) carry test directories, and those contain only auto-generated boilerplate `ApplicationTest.java` stubs — no meaningful assertions.

Every class in `app/src/main/java/` is completely untested. This includes all business logic, network interaction, user session management, data persistence, and UI fragments covered by this audit. There is no test harness, no test runner configuration, no mocking framework, and no CI-enforced coverage gate.

**Impact:** Any regression in business logic, API integration, or user data handling can ship undetected. The three files assigned to this agent collectively touch authentication state, network calls with success/failure paths, date formatting, and list rendering — none of which can be verified by automated means.

---

## File 1: ProfileFragment.java

### Reading Evidence

**Fully qualified class name:**
`au.com.collectiveintelligence.fleetiq360.ui.fragment.ProfileFragment`

**Superclass / interfaces:**
- Extends `FleetFragment` (which extends `Fragment`)
- Implements `View.OnClickListener`

**Fields defined (lines 28–31):**
| Field | Type | Access |
|---|---|---|
| `activity` | `ProfileActivity` | package-private |
| `lastEText` | `EditText` | private |
| `firstEText` | `EditText` | private |
| `editButton` | `LinearLayout` | private |
| `saveButton` | `LinearLayout` | private |

**Constants / static imports:**
- `INVISIBLE` from `android.view.View`
- `VISIBLE` from `android.view.View`

**Methods with line numbers and signatures:**

| Line | Signature |
|---|---|
| 34 | `public View onCreateView(@NonNull LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState)` |
| 40 | `public void onActivityCreated(Bundle savedInstanceState)` |
| 46 | `private void setUserData()` |
| 59 | `public void initViews()` |
| 79 | `public void onLeftButton(View view)` |
| 84 | `public void onRightButton(View view)` |
| 89 | `public void onResume()` |
| 94 | `public void onStop()` |
| 99 | `public void onDestroy()` |
| 103 | `private void saveModifiedResult()` |
| 122 | `private void updateUser(int uid, final UpdateUserParameter parameter)` |
| 147 | `private void onEnableEdit(boolean enable)` |
| 155 | `public void onClick(View view)` |

---

### Findings

#### A64-2 — HIGH: `saveModifiedResult()` completely untested — guards against null user but not against empty or whitespace-only name fields

**Severity:** HIGH
**Location:** `ProfileFragment.java`, line 103–120

`saveModifiedResult()` checks only that the edit fields are enabled (line 104) and that `CurrentUser.get()` is non-null (line 110) before building and dispatching an `UpdateUserParameter`. It does not validate that `firstEText` or `lastEText` contain non-empty, non-whitespace content. A user can save an empty first name or last name string to the server. This logic path has zero test coverage.

No test exercises:
- Saving with an empty first name (`""`)
- Saving with an empty last name (`""`)
- Saving with whitespace-only names (`"   "`)
- The guard branch when `firstEText.isEnabled()` returns false
- The guard branch when `CurrentUser.get()` returns null

#### A64-3 — HIGH: `saveModifiedResult()` calls `ServerDateFormatter().formatDate(user.getComplianceDate())` with a potentially null date — NPE risk, untested

**Severity:** HIGH
**Location:** `ProfileFragment.java`, line 118

`user.getComplianceDate()` returns a `Date` field that is populated from `ServerDateFormatter().parseDate(loginItem.compliance_date)`, which explicitly returns `null` when the date string is null or empty (see `ServerDateFormatter.java` line 30). `ServerDateFormatter.formatDate()` calls `dateFormat.format(date)` directly, which throws `NullPointerException` if the `Date` argument is null. There is no null check on `user.getComplianceDate()` before calling `formatDate()`.

No test covers the scenario where a user account has no compliance date set, which would cause an unhandled crash at the point of saving the profile.

#### A64-4 — MEDIUM: `updateUser()` network callback success path calls `CurrentUser.get().updateInformation()` without null guard — untested

**Severity:** MEDIUM
**Location:** `ProfileFragment.java`, line 129

In the `onSucceed` callback at line 129, `CurrentUser.get()` is called again without checking for null. If the user session was cleared between the time the save request was dispatched and the time the response was received (e.g., due to logout or session expiry), this will throw a `NullPointerException`. The equivalent null check present in `saveModifiedResult()` (line 110) is absent here.

No test exercises the race condition where `CurrentUser.get()` returns null by the time `onSucceed` fires.

#### A64-5 — MEDIUM: `updateUser()` `onFailed` callback silently resets edit mode — untested error path

**Severity:** MEDIUM
**Location:** `ProfileFragment.java`, lines 139–143

When the network call fails, `onFailed` hides the progress dialog, shows an error dialog, and then calls `onEnableEdit(false)` — which disables the text fields and shows the Edit button. This means the user's in-progress edits (the modified first/last name text) are discarded without warning: the fields are disabled, but the original values from `setUserData()` are not explicitly restored. The user sees an error then finds their text is locked but the displayed values may be the edited (unsaved) versions.

No test verifies the UI state after a failed save, nor whether the text fields retain or revert their content.

#### A64-6 — MEDIUM: `setUserData()` is untested — no coverage of the null user branch or role label logic

**Severity:** MEDIUM
**Location:** `ProfileFragment.java`, lines 46–57

`setUserData()` has an early return when `CurrentUser.get()` returns null (line 48), leaving all view fields blank. No test verifies this safe-return path. The role label at line 56 uses a ternary on `user.isContactPerson()` to display either `"Company"` or `"Driver"` — neither branch is tested for correct string output.

#### A64-7 — MEDIUM: `onClick()` navigation cases untested — `activity` field is never null-checked before use

**Severity:** MEDIUM
**Location:** `ProfileFragment.java`, lines 163–167

`onClick()` calls `activity.showFragmentWithStack(...)` for both `R.id.my_resume` and `R.id.my_equipments` without checking whether `activity` is null. The field is assigned conditionally in `onActivityCreated()` only when `getActivity() instanceof ProfileActivity` (line 42–43). If the fragment is attached to a different activity type (including during instrumented test scenarios), `activity` remains null and the click handlers will throw `NullPointerException`.

No test exercises either navigation click path or verifies the null-safety of the `activity` field.

#### A64-8 — LOW: Lifecycle override methods (`onResume`, `onStop`, `onDestroy`) are all empty delegate shells — untested and unnecessary

**Severity:** LOW
**Location:** `ProfileFragment.java`, lines 89–101

`onResume()`, `onStop()`, and `onDestroy()` each contain only a `super.` call. They provide no additional logic and add noise to the class. Because they are public and override lifecycle methods, they can be called by the Android framework, but since they add nothing beyond the superclass behavior they present no behavioral risk. However, their presence as overrides without logic means any future developer may add code inside them without recognizing they are untested scaffolding.

#### A64-9 — LOW: `onEnableEdit()` visibility toggle logic is untested

**Severity:** LOW
**Location:** `ProfileFragment.java`, lines 147–152

`onEnableEdit(boolean enable)` toggles visibility of `editButton` and `saveButton` and enables/disables the two text fields. The boolean logic (`enable ? INVISIBLE : VISIBLE`) is inverted relative to its parameter name in a way that requires careful reading: passing `true` makes the edit button invisible and the save button visible. No test verifies the correct button visibility states for `enable=true` vs `enable=false`, leaving the toggle logic susceptible to silent regression if the ternary operands are accidentally swapped.

---

## File 2: SavedReportFragment.java

### Reading Evidence

**Fully qualified class name:**
`au.com.collectiveintelligence.fleetiq360.ui.fragment.SavedReportFragment`

**Superclass:**
- Extends `FleetFragment`

**Fields defined (lines 23–24):**
| Field | Type | Access |
|---|---|---|
| `listAdapter` | `SavedReportListAdapter` | private |
| `listData` | `ArrayList<ReportItem>` | private, initialized to empty list |

**Methods with line numbers and signatures:**

| Line | Signature |
|---|---|
| 28 | `public View onCreateView(@NonNull LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState)` |
| 33 | `public void initViews()` |
| 45 | `private void loadData()` |
| 65 | `private void onData(ReportResultArray resultArray)` |
| 71 | `void onResend(ReportItem reportItem)` |

---

### Findings

#### A64-10 — HIGH: `onData()` calls `resultArray.arrayList` after checking it in `onSucceed` but without null-checking inside `onData()` itself

**Severity:** HIGH
**Location:** `SavedReportFragment.java`, lines 65–69

`onData(ReportResultArray resultArray)` is called from `onSucceed` at line 51. The caller checks `result.arrayList == null || result.arrayList.size() == 0` at line 52 — but this check happens *after* `onData(result)` is called at line 51. The sequence is:

```
onData(result);                                           // line 51 — called first
if (result.arrayList == null || result.arrayList.size() == 0) { // line 52 — checked after
```

Inside `onData()` at line 67, `listData.addAll(resultArray.arrayList)` is called with no null check. If `resultArray.arrayList` is null, this throws `NullPointerException` before the null guard at line 52 ever executes. No test exercises the empty-list or null-array response path.

#### A64-11 — MEDIUM: `loadData()` `onFailed` callback uses `showToast()` instead of a dialog — inconsistent error UX, untested

**Severity:** MEDIUM
**Location:** `SavedReportFragment.java`, lines 58–61

When `getReports()` fails, `onFailed` shows a toast message. The `onResend()` failure path at line 87 uses `showErrDialog()`. The two failure paths use different UI patterns for what is conceptually the same category of error (network failure). No test verifies either failure path is reached or that the correct UI feedback mechanism is invoked.

#### A64-12 — MEDIUM: `onResend()` makes an API call with `reportItem.id` without null-checking `reportItem` — untested

**Severity:** MEDIUM
**Location:** `SavedReportFragment.java`, line 71–91

`onResend(ReportItem reportItem)` accepts the item from the adapter without a null guard. While the adapter uses `Objects.requireNonNull()` (see `SavedReportListAdapter.java` line 47), that throws immediately in the adapter rather than preventing propagation. The fragment itself does not validate the incoming parameter. If the adapter's null-check is ever bypassed or the method is called from another code path with a null argument, the API call at line 73 proceeds with an uninitialized `reportItem.id` (default int value 0), potentially corrupting server-side data.

No test covers `onResend(null)` or `onResend()` with a zero-id item.

#### A64-13 — MEDIUM: `onResend()` success callback calls `getBaseActivity().runLater()` — `getBaseActivity()` not null-checked, untested

**Severity:** MEDIUM
**Location:** `SavedReportFragment.java`, lines 77–82

The `onSucceed` callback at line 77 calls `getBaseActivity().runLater(...)`. If the fragment has been detached from its activity between request dispatch and response receipt, `getBaseActivity()` may return null, causing a `NullPointerException` in a non-UI thread context — which would be difficult to diagnose. No test exercises the fragment-detached-during-network-call scenario.

#### A64-14 — LOW: `loadData()` shows an error dialog for an empty report list — edge case untested

**Severity:** LOW
**Location:** `SavedReportFragment.java`, lines 52–54

An empty (but non-null) list from the server triggers `showErrDialog(getString(R.string.ci_no_reports_alert))`. This is arguably a normal state (a user who has never generated a report), not an error. No test verifies the dialog is shown for an empty list but not shown for a populated list, nor that the behavior is appropriate for first-time users.

---

## File 3: SavedReportListAdapter.java

### Reading Evidence

**Fully qualified class name:**
`au.com.collectiveintelligence.fleetiq360.ui.fragment.SavedReportListAdapter`

**Superclass:**
- Extends `ArrayAdapter<ReportItem>`

**Fields defined (lines 18–20):**
| Field | Type | Access |
|---|---|---|
| `context` | `Context` | private |
| `mData` | `ArrayList<ReportItem>` | private |
| `savedReportFragment` | `SavedReportFragment` | package-private |

**Inner class (lines 70–73):**
`static class ListHolder` — fields: `TextView name`, `View resend_report_view`

**Methods with line numbers and signatures:**

| Line | Signature |
|---|---|
| 22 | `SavedReportListAdapter(Context context, ArrayList<ReportItem> data)` (package-private) |
| 30 | `public View getView(int position, View convertView, @NonNull ViewGroup parent)` |
| 61 | `public int getCount()` |
| 66 | `public ReportItem getItem(int i)` |

---

### Findings

#### A64-15 — HIGH: `getView()` casts `context` to `Activity` unconditionally — will throw `ClassCastException` if context is not an Activity

**Severity:** HIGH
**Location:** `SavedReportListAdapter.java`, line 34

```java
LayoutInflater inflater = ((Activity) context).getLayoutInflater();
```

The constructor accepts a `Context` parameter (line 22). `Context` is the supertype; it can legally be an `Application` context, a `Service` context, or any other non-`Activity` context. The unconditional cast to `Activity` at line 34 will throw `ClassCastException` at runtime if a non-Activity context is provided. No test exercises this path, and there is no guard or `instanceof` check.

#### A64-16 — HIGH: `getView()` calls `Objects.requireNonNull(recordItem)` but `mData.get(position)` can return null if the backing list contains null entries — crash at runtime, untested

**Severity:** HIGH
**Location:** `SavedReportListAdapter.java`, line 47

`getItem(position)` delegates to `mData.get(i)` (line 67), which can return null if the `ArrayList` contains a null entry. `Objects.requireNonNull()` at line 47 will then throw `NullPointerException` explicitly — a correct guard, but one that surfaces as an unhandled crash. The name-display and click-listener setup on lines 47–54 proceed only after this check, so the crash happens at the `requireNonNull` call rather than at a null dereference later.

No test exercises the scenario where the backing list contains a null `ReportItem`, nor that the list is ever validated for null entries before being passed to the adapter.

#### A64-17 — MEDIUM: `getView()` sets an `OnClickListener` on `resend_report_view` on every `getView()` call, even for recycled views — accumulated listener risk, untested

**Severity:** MEDIUM
**Location:** `SavedReportListAdapter.java`, lines 48–54

The `OnClickListener` for `resend_report_view` is set unconditionally both in the inflate branch (new view) and in the recycled-view else branch (indirectly, since listener assignment happens after the if/else). For recycled views, the new listener correctly captures the current `recordItem` via a final local variable — but if `recordItem` capturing were ever modified to use a mutable variable, this pattern would silently capture the wrong item. No test verifies that clicking the resend button on a recycled row invokes `onResend` with the correct `ReportItem`.

#### A64-18 — MEDIUM: `getItem()` overrides the superclass `getItem()` but bypasses `ArrayAdapter`'s internal array — state can diverge

**Severity:** MEDIUM
**Location:** `SavedReportListAdapter.java`, lines 66–68

`getItem(int i)` returns `mData.get(i)` directly, bypassing `ArrayAdapter`'s internal item management. `getCount()` similarly returns `mData.size()` rather than `super.getCount()`. Because `mData` is the same reference passed into `super(context, layout, data)`, these are functionally equivalent — but if `mData` is ever replaced (re-assigned rather than cleared-and-refilled), the superclass internal state and `mData` will diverge. `SavedReportFragment.onData()` clears and refills the same list object (lines 66–67), so this works correctly now, but the design is fragile and untested for the case where the list reference changes.

#### A64-19 — LOW: `savedReportFragment` field is package-private and set by external assignment rather than via constructor — null risk, untested

**Severity:** LOW
**Location:** `SavedReportListAdapter.java`, line 20 and `SavedReportFragment.java`, line 40

The `savedReportFragment` field is set by direct field assignment (`listAdapter.savedReportFragment = this`) after construction. The `getView()` click handler at line 51 guards against this being null (`if (savedReportFragment != null)`), which prevents a crash. However, the guard means a click on a resend button is silently swallowed if `savedReportFragment` has not been set or has been set to null. No test verifies the wiring is established before items become interactive, nor that the null-guard path produces any user-visible feedback.

#### A64-20 — LOW: `getCount()` and `getItem()` are untested for boundary inputs

**Severity:** LOW
**Location:** `SavedReportListAdapter.java`, lines 61–68

No test verifies:
- `getCount()` returns 0 for an empty list
- `getItem(0)` on a single-item list returns the correct element
- `getItem(mData.size())` (out-of-bounds) throws `IndexOutOfBoundsException` as expected from `ArrayList`
- `getItem(-1)` similarly

These are trivially simple methods, but the complete absence of a test framework means even these boundary behaviors are untested project-wide.

---

## Summary Table

| ID | Severity | File | Description |
|---|---|---|---|
| A64-1 | HIGH | Project-wide | No test directories in app/ or LibCommon/ — zero automated coverage |
| A64-2 | HIGH | ProfileFragment | `saveModifiedResult()` does not validate empty/whitespace name fields before API call |
| A64-3 | HIGH | ProfileFragment | `user.getComplianceDate()` can be null; `ServerDateFormatter.formatDate(null)` throws NPE |
| A64-4 | MEDIUM | ProfileFragment | `onSucceed` calls `CurrentUser.get().updateInformation()` without null-checking result |
| A64-5 | MEDIUM | ProfileFragment | `onFailed` resets edit mode, discarding user edits silently without restoring original values |
| A64-6 | MEDIUM | ProfileFragment | `setUserData()` null user branch and role label branches are untested |
| A64-7 | MEDIUM | ProfileFragment | `onClick()` calls `activity.showFragmentWithStack()` without null-checking `activity` field |
| A64-8 | LOW | ProfileFragment | Empty lifecycle overrides (`onResume`, `onStop`, `onDestroy`) are untested scaffolding |
| A64-9 | LOW | ProfileFragment | `onEnableEdit()` inverted-boolean toggle logic untested, susceptible to silent regression |
| A64-10 | HIGH | SavedReportFragment | `onData()` called before null check on `arrayList`; NPE if server returns null array |
| A64-11 | MEDIUM | SavedReportFragment | `onFailed` uses toast; `onResend` failure uses dialog — inconsistent, both untested |
| A64-12 | MEDIUM | SavedReportFragment | `onResend()` does not null-check incoming `ReportItem`; zero-id item sent silently |
| A64-13 | MEDIUM | SavedReportFragment | `getBaseActivity()` not null-checked in `onSucceed` callback — NPE if fragment detached |
| A64-14 | LOW | SavedReportFragment | Empty report list triggers error dialog — inappropriate UX for first-time users, untested |
| A64-15 | HIGH | SavedReportListAdapter | Unconditional `(Activity) context` cast in `getView()` — `ClassCastException` if non-Activity context used |
| A64-16 | HIGH | SavedReportListAdapter | `Objects.requireNonNull(recordItem)` crashes if backing list contains null entries |
| A64-17 | MEDIUM | SavedReportListAdapter | `OnClickListener` set per-`getView()` call on recycled views — incorrect-item capture risk |
| A64-18 | MEDIUM | SavedReportListAdapter | `getItem()` bypasses `ArrayAdapter` internals — fragile if list reference is ever replaced |
| A64-19 | LOW | SavedReportListAdapter | `savedReportFragment` set by field assignment not constructor — silent null-swallow on click |
| A64-20 | LOW | SavedReportListAdapter | `getCount()` and `getItem()` boundary inputs (empty list, out-of-bounds) untested |
