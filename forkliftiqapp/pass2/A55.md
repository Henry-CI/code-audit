# Audit Pass 2 — Agent A55
## Files Audited
1. `app/src/main/java/au/com/collectiveintelligence/fleetiq360/ui/activity/IncidentActivity.java`
2. `app/src/main/java/au/com/collectiveintelligence/fleetiq360/ui/activity/JobsActivity.java`
3. `app/src/main/java/au/com/collectiveintelligence/fleetiq360/ui/activity/LoginActivity.java`

---

## PROJECT-WIDE FINDING (HIGH)

### A55-1 — Zero automated test coverage across app/ and LibCommon/ modules

**Severity: HIGH**

Neither the `app/` module nor the `LibCommon/` module contains any test directory (`src/test/` or `src/androidTest/`). The only test files found in the entire repository are confined to the third-party library module `LibImageloader/` (`ImageSizeTest.java`, `BaseImageDownloaderTest.java`) — tests that cover image-loading utility code unrelated to application business logic — and a pair of stub `ApplicationTest.java` files in `LibImagePicker/` and `LibPercentProgress/` which are empty scaffolding generated by Android Studio.

Every source file in the app under audit, including all Activities, Fragments, WebService classes, model classes, and user-management classes, has zero automated test coverage. This means:

- No regression net exists. Any change to any class can silently break behaviour.
- Login, session management, incident reporting, and BLE device interaction have never been exercised by an automated test.
- There is no CI gate preventing broken code from being merged.

All file-specific findings below are contingent on this overarching gap: they describe what tests *should* exist but do not.

---

## Reading Evidence

### File 1 — IncidentActivity.java

**Fully qualified class name:** `au.com.collectiveintelligence.fleetiq360.ui.activity.IncidentActivity`

**Superclass chain:** `IncidentActivity` → `FleetActivity` → `BaseActivity` → `AppCompatActivity`

**Fields / constants defined:**
| Name | Type | Visibility | Line |
|---|---|---|---|
| `impactParameter` | `ImpactParameter` | `public` | 12 |
| `impactResult` | `SaveImpactResult` | `public` | 13 |
| `signaturePath` | `String` | `public` | 14 |
| `mCurrentPhotoPath` | `String` | `public` | 15 |
| `injuryTypes` | `String[]` | `public` | 16 |

**Methods defined:**
| Line | Signature |
|---|---|
| 19 | `protected void onCreate(Bundle savedInstanceState)` |
| 36 | `public void onBackPressed()` |

**ImpactParameter fields (referenced in `onCreate`):**
`injury_type`, `incident` (boolean), `injury` (boolean) — all initialised inline at lines 26–30.

---

### File 2 — JobsActivity.java

**Fully qualified class name:** `au.com.collectiveintelligence.fleetiq360.ui.activity.JobsActivity`

**Superclass chain:** `JobsActivity` → `FleetActivity` → `BaseActivity` → `AppCompatActivity`

**Fields / constants defined:** None beyond inherited.

**Methods defined:**
| Line | Signature |
|---|---|
| 10 | `protected void onCreate(Bundle savedInstanceState)` |

---

### File 3 — LoginActivity.java

**Fully qualified class name:** `au.com.collectiveintelligence.fleetiq360.ui.activity.LoginActivity`

**Superclass chain:** `LoginActivity` → `FleetActivity` → `BaseActivity` → `AppCompatActivity`

**Fields / constants defined:** None beyond inherited.

**Methods defined:**
| Line | Signature |
|---|---|
| 14 | `protected void onCreate(Bundle savedInstanceState)` |

**Key dependencies exercised in `onCreate`:**
- `CurrentUser.get()` — reads `ModelPrefs` (SharedPreferences) to look up a persisted user ID, then queries Realm via `UserDb.get(int)`. Returns `null` if no user is persisted.
- `user.hasAssociatedDrivers()` — queries Realm for drivers belonging to `user.companyId`. Determines whether redirect target is `DriversActivity` or `DashboardActivity`.
- `Intent.makeMainActivity(ComponentName)` — constructs launch Intent with `FLAG_ACTIVITY_NEW_TASK`.
- `startActivity(intent)` / `finish()` — called only on the authenticated path.
- `showFragmentWithoutStack(...)` — called only on the unauthenticated path to load `LoginFragment`.

---

## Findings

### A55-2 — LoginActivity: No test for the already-authenticated redirect path

**Severity: HIGH**

**File:** `LoginActivity.java`, lines 18–23

**Description:**
`onCreate` calls `CurrentUser.get()` and, if a non-null `User` is returned, immediately starts either `DriversActivity` or `DashboardActivity` and calls `finish()`. This is the primary guard that stops an authenticated user from landing on the login screen again. If this guard misfires — returning to the login screen when the user is already logged in, or skipping to the dashboard when the user is not — the consequences are either a redirect loop or an unauthenticated user reaching protected screens.

No test exercises this path. The following sub-cases are entirely untested:

1. **User is authenticated, `hasAssociatedDrivers()` returns `false`**: redirect should go to `DashboardActivity`. No test verifies this.
2. **User is authenticated, `hasAssociatedDrivers()` returns `true`**: redirect should go to `DriversActivity`. No test verifies this.
3. **User is null**: `LoginFragment` should be loaded. No test verifies this.
4. **`CurrentUser.get()` returns a stale user whose Realm record was deleted**: `hasAssociatedDrivers()` calls `UserDb.driversOfCompany(companyId)` via Realm — may throw or return unexpected results. No test covers this.

`CurrentUser.get()` is a static method that reads `ModelPrefs` (SharedPreferences) and then Realm. Both are global singletons with no seam for injection, making this logic difficult to test without Robolectric or an instrumentation test harness — neither of which is present in the project.

---

### A55-3 — LoginActivity: No test for redirect loop when authenticated user is sent back to LoginActivity

**Severity: HIGH**

**File:** `LoginActivity.java`, lines 18–23

**Description:**
If the application navigates back to `LoginActivity` while `CurrentUser.get()` returns a valid user — for example, if another activity's back-stack pops to `LoginActivity` without clearing the stack — the code calls `startActivity` and `finish()`. However, the new Intent is built with `Intent.makeMainActivity()`, which adds `FLAG_ACTIVITY_NEW_TASK`. If the target activity itself navigates back to `LoginActivity` (e.g., due to a misconfigured back-stack or a crash-and-relaunch scenario), a redirect loop is possible: `LoginActivity` → `DashboardActivity` → back-press → `LoginActivity` → `DashboardActivity` ...

The guard only calls `finish()` after `startActivity()`, which is correct, but the activity's launch mode and task affinity are not covered by any test. No test verifies that the activity correctly finishes itself and does not re-enter the back-stack.

---

### A55-4 — LoginActivity: No test for login with empty email or password

**Severity: HIGH**

**File:** `LoginFragment.java` (loaded by `LoginActivity`), lines 67–76; `CurrentUser.java`, lines 80–112, 120–123

**Description:**
The login validation in `LoginFragment.login()` only checks that the password is at least 4 characters long (line 68). It does not validate that the email field (`nameText`) is non-empty. If the user submits an empty email:

- `CurrentUser.setTemporaryLoginInformation("", password)` is called, storing an empty string as `loginEmail`.
- `CurrentUser.login()` hashes the empty string with `CommonFunc.MD5_Hash("")` and sends it to the server.
- The server may return HTTP 502 (Bad Gateway), which the code treats as incorrect credentials (`HandleIncorrectCredentials`). This branch is exercised, but only by accident — the response code from the server is not guaranteed to be 502 for an empty credential payload.
- The offline fallback (`UserDb.get(loginEmail, loginPassword)`) queries Realm for `email == ""`, which may match a corrupt record or simply return null. Neither case is tested.

No test exercises:
- Empty email with valid-length password.
- Empty password (below minimum length guard produces a toast, but toast is not verified by any test).
- Whitespace-only email (passes the empty check, will be hashed and sent as a non-empty MD5).
- Password exactly 4 characters (boundary: accepted).
- Password exactly 3 characters (boundary: rejected with toast).

---

### A55-5 — IncidentActivity: No test for incident data loss on process death

**Severity: HIGH**

**File:** `IncidentActivity.java`, lines 12–16 and 25–32

**Description:**
`IncidentActivity` accumulates incident state across a multi-step fragment flow. The activity holds mutable public fields (`impactParameter`, `impactResult`, `signaturePath`, `mCurrentPhotoPath`) that are written to progressively by `IncidentFragment`, `IncidentPart2Fragment`, and downstream fragments as the user proceeds through the incident-reporting wizard.

None of these fields are preserved in `onSaveInstanceState`. `ImpactParameter` implements `Serializable`, so it *could* be written to a Bundle, but `IncidentActivity` does not override `onSaveInstanceState` and provides no save/restore logic whatsoever.

If the Android OS kills the process while the user is mid-way through the incident wizard (e.g., the user switches apps, the system runs low on memory, or a phone call arrives), then when the user returns:

- A fresh `IncidentActivity` instance is created via `onCreate`.
- `impactParameter` is re-initialised to a brand-new `ImpactParameter()` with default values (lines 25–30), discarding all data the user had entered across previous steps.
- `impactResult` is null, `signaturePath` is null, `mCurrentPhotoPath` is null.
- Any fragment on the back-stack attempting to cast `getActivity()` to `IncidentActivity` and read `impactParameter` fields will see blank/default data, silently corrupting the user's incident report.

No test exercises this scenario. A Robolectric or instrumentation test could call `ActivityController.recreate()` or simulate `onSaveInstanceState` / `onRestoreInstanceState` to verify data survival.

---

### A55-6 — IncidentActivity: onBackPressed logic not tested — impactResult null check has no test

**Severity: MEDIUM**

**File:** `IncidentActivity.java`, lines 36–42

**Description:**
`onBackPressed` has a branch: if `impactResult != null`, call `finish()` directly; otherwise, delegate to `super.onBackPressed()`. The two branches have different user-facing effects:

- `super.onBackPressed()` pops the fragment back-stack, allowing the user to navigate back through the wizard steps.
- `finish()` closes the entire activity, which is the correct behaviour after a successful save (`impactResult` is set after the server response).

No test verifies:
1. That pressing back before save (`impactResult == null`) correctly pops the fragment rather than finishing the activity.
2. That pressing back after save (`impactResult != null`) correctly finishes the activity rather than navigating to a stale wizard step.

A bug in this branch (e.g., `impactResult` being set prematurely) would silently discard user navigation intent.

---

### A55-7 — IncidentActivity: Public mutable fields are an untested API surface

**Severity: MEDIUM**

**File:** `IncidentActivity.java`, lines 12–16

**Description:**
All five state fields (`impactParameter`, `impactResult`, `signaturePath`, `mCurrentPhotoPath`, `injuryTypes`) are declared `public` with no encapsulation. `IncidentFragment` and its siblings access and mutate these fields directly (e.g., `incidentActivity.impactParameter.unit_id = ...`). This design creates an implicit contract between the activity and its fragments that is entirely untested.

Specific untested scenarios:

- `injuryTypes` is populated from `getResources().getStringArray(R.array.injury_type)`. If the resource array is empty or missing, `injuryTypes[0]` at line 29 throws `ArrayIndexOutOfBoundsException`. No test checks the length of this array before access.
- `impactParameter.injury_type` is set to `injuryTypes[0]` unconditionally. No test verifies that the resource array contains at least one element.
- `signaturePath` and `mCurrentPhotoPath` are file-system paths that remain `null` if the corresponding steps are skipped. No test verifies that downstream consumers of these fields handle `null` correctly.

---

### A55-8 — JobsActivity: No test for fragment attachment failure

**Severity: LOW**

**File:** `JobsActivity.java`, lines 10–14

**Description:**
`JobsActivity.onCreate` calls `showFragmentWithoutStack(R.id.jobs_act_framelayout_id, ...)`. No test verifies that the fragment container `R.id.jobs_act_framelayout_id` exists in `R.layout.activity_jobs`, that `JobsFragment` attaches successfully, or that the activity renders anything visible to the user. While this is a thin delegation activity, a resource ID mismatch would produce a silent no-op or a crash that is not covered.

---

### A55-9 — JobsActivity: No test for savedInstanceState re-use

**Severity: LOW**

**File:** `JobsActivity.java`, lines 10–14

**Description:**
`JobsActivity.onCreate` unconditionally calls `showFragmentWithoutStack` without checking whether `savedInstanceState` is null. If the system restores the activity from a saved state (e.g., after a configuration change), the fragment manager already holds the saved `JobsFragment` and calling `showFragmentWithoutStack` again will add a duplicate fragment or replace the restored one. The `FleetActivity` / `BaseActivity` superclass may guard against this, but no test verifies that a configuration-change scenario (screen rotation, locale change) does not result in duplicate fragments or lost state.

---

### A55-10 — LoginActivity: No test for null or missing savedInstanceState on re-creation

**Severity: LOW**

**File:** `LoginActivity.java`, lines 14–27

**Description:**
Like `JobsActivity`, `LoginActivity.onCreate` unconditionally calls `showFragmentWithoutStack` on the unauthenticated path without checking `savedInstanceState`. If the system recreates the activity after a configuration change while the user is on the login screen (e.g., keyboard shown, screen rotated), a duplicate `LoginFragment` may be stacked. The entered email and password in the first fragment instance would be lost. No test exercises the recreation path.

---

### A55-11 — CurrentUser.get() — static mutable state is untestable without reset mechanism

**Severity: INFO**

**File:** `CurrentUser.java` (dependency of `LoginActivity`), lines 21–29

**Description:**
`CurrentUser` uses a private static `user` field as an in-process cache. `get()` returns the cached value if non-null; otherwise it queries Realm. This static field is never reset between test cases and has no `@VisibleForTesting` injection point. If a test sets up a logged-in state, subsequent tests in the same JVM process will observe the cached user, producing test-order-dependent failures. This is a structural testability problem that would need to be addressed before unit tests for `LoginActivity` could be written reliably.

---

### A55-12 — LoginFragment: Password minimum-length validation is tested only by a toast — no test for edge boundaries

**Severity: INFO**

**File:** `LoginFragment.java` (loaded by `LoginActivity`), lines 67–70

**Description:**
The password length guard (`passwordText.getText().length() < 4`) produces a `showToast(...)` call on failure and returns early. No test verifies:
- That the toast is shown with the correct message.
- That the login network call is suppressed when length < 4.
- That a password of exactly 4 characters passes the guard.
- That a password of exactly 3 characters is rejected.

These are simple boundary conditions that would be straightforward to cover with an instrumented UI test using Espresso, but no such test exists.
