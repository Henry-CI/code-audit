# Audit Pass 2 — Agent A13
## Files: BleMachine.java, BleMachineService.java, BleModel.java
**Audit run:** 2026-02-26-01
**Branch:** master

---

## PROJECT-WIDE FINDING (HIGH): Zero Automated Test Coverage in app/ and LibCommon/

**Severity:** HIGH

The `app/` and `LibCommon/` modules contain no test directories whatsoever. A search across the entire repository confirms:

- `app/src/` contains only `main/` — no `test/` or `androidTest/` subdirectory exists.
- `LibCommon/src/` contains only `main/` — no `test/` or `androidTest/` subdirectory exists.
- The only test directories found in the repo are inside third-party library modules: `LibImageloader`, `LibImagePicker`, and `LibPercentProgress`. These test files cover third-party image-loading and UI utilities, not any application business logic.

Every finding in this report is therefore also a missing-test finding by definition. There is no test infrastructure at all to run against the BLE subsystem or any other application code.

---

## Reading Evidence

### File 1: BleMachine.java

**Fully qualified class name:** `au.com.collectiveintelligence.fleetiq360.WebService.BLE.BleMachine`

**Fields (instance):**
- `TAG` (String, private final) — line 18
- `mBleController` (BleController) — line 19
- `expectingRelayValue` (public int) — line 20
- `expectingTimeItem` (public BleUtil.BleTimeItem) — line 21
- `expectingImpactThreshold` (public int) — line 22

**Methods (with line numbers and signatures):**

| Line | Signature |
|------|-----------|
| 24 | `BleMachine(BleController bleController)` — constructor |
| 28 | `boolean authDevice()` — package-private |
| 46 | `void onServiceFound()` — package-private |
| 76 | `void onAuthDone()` — package-private |
| 83 | `boolean disableShockNotification()` — package-private |
| 96 | `boolean setShockNotification()` — package-private |
| 109 | `boolean setRelay(final boolean enable)` — package-private |
| 133 | `boolean clearRelay()` — package-private |
| 149 | `void logTime(String s, BleUtil.BleTimeItem bleTimeItem)` — package-private |
| 155 | `boolean setTime()` — package-private |
| 174 | `boolean setImpactThreshold()` — package-private |
| 198 | `boolean setRelayTimeout()` — package-private |
| 204 | `private boolean setRelayTimeout(String relayTimeoutUUID)` — private |
| 215 | `boolean writeCharacteristic(BluetoothGattCharacteristic characteristic)` — package-private |
| 222 | `boolean readCharacteristic(BluetoothGattCharacteristic characteristic)` — package-private |
| 229 | `void onBleDataRead(Intent intent)` — package-private |
| 289 | `void onGattServices(List<BluetoothGattService> gattServices)` — package-private |

**Constants/types defined:** None defined here; references `BleModel.*` and `BleUtil.*` constants, and `BleController.STATUS_*` constants defined in BleController.

**Noteworthy implementation observations:**
- `authDevice()` (line 28–44): Returns `true` (success) both when `ble_status != STATUS_SERVICE_FOUND` (line 30–31) AND when the characteristic is null (line 36–38). This means failure cases silently appear as success to the caller in `onServiceFound()`, which then calls `onAuthDone()` as if authentication succeeded.
- `onBleDataRead()` (lines 241–249): The handler for `UUID_TOKEN_AUTH` is entirely commented out. No logic validates the authentication response from the hardware device. The method simply does nothing when auth-characteristic data arrives.
- `setRelay()` (line 109): Calls `mBleController.onFailed()` if status is not `STATUS_AUTHENTICATED`, but the relay-value verification in `onBleDataRead()` (line 256) only checks `actionSucceed && value == expectingRelayValue` — there is no cryptographic or challenge-response check at the BLE protocol level.
- `setRelayTimeout()` (line 210): Hardcodes timeout value of `60` (seconds) with no configurability.
- `setImpactThreshold()` (lines 180–183): Silently substitutes `80000` when `impact_threshold == 0`, with no notification to the caller.

---

### File 2: BleMachineService.java

**Fully qualified class name:** `au.com.collectiveintelligence.fleetiq360.WebService.BLE.BleMachineService`

**Constants (public static final String):**
- `STATE_DISCONNECTED = 0` (line 51, public)
- `STATE_CONNECTING = 1` (line 52, private)
- `STATE_CONNECTED = 2` (line 53, private)
- `ACTION_GATT_CONNECTED` (line 55)
- `ACTION_GATT_DISCONNECTED` (line 56)
- `ACTION_GATT_SERVICES_DISCOVERED` (line 57)
- `ACTION_DATA_AVAILABLE` (line 58)
- `ACTION_DATA_WRITE` (line 59)
- `ACTION_DATA_CHANGED` (line 60)
- `CHARA_UUID` (line 61)
- `EXTRA_DATA` (line 62)
- `DEVICE_ADDRESS` (line 63)
- `STATUS_CODE` (line 64)

**Fields (instance, private):**
- `mBluetoothManager` (BluetoothManager) — line 45
- `mBluetoothAdapter` (BluetoothAdapter) — line 46
- `mBleDeviceAddress` (String) — line 47
- `mBluetoothGatt` (BluetoothGatt) — line 48
- `mConnectionState` (int) — line 49
- `mBinder` (IBinder, final) — line 260

**Anonymous inner class:**
- `mGattCallback` (BluetoothGattCallback, private final) — line 72

**Methods (with line numbers and signatures):**

| Line | Signature |
|------|-----------|
| 67 | `public void discoverServices()` |
| 74 | `onConnectionStateChange(BluetoothGatt, int, int)` — callback override |
| 101 | `onServicesDiscovered(BluetoothGatt, int)` — callback override |
| 112 | `onCharacteristicRead(BluetoothGatt, BluetoothGattCharacteristic, int)` — callback override |
| 121 | `onCharacteristicChanged(BluetoothGatt, BluetoothGattCharacteristic)` — callback override |
| 130 | `onCharacteristicWrite(BluetoothGatt, BluetoothGattCharacteristic, int)` — callback override |
| 137 | `public boolean connect(final String address)` |
| 155 | `public boolean connect(final BluetoothDevice device)` |
| 172 | `void startConnect(BluetoothDevice device)` — package-private |
| 179 | `public void disconnect()` |
| 187 | `public void close()` |
| 195 | `public boolean readCharacteristic(BluetoothGattCharacteristic characteristic)` |
| 206 | `public boolean writeCharacteristic(BluetoothGattCharacteristic characteristic)` |
| 216 | `public boolean setCharacteristicNotification(BluetoothGattCharacteristic, boolean)` |
| 237 | `public List<BluetoothGattService> getSupportedGattServices()` |
| 244 | `BleMachineService getService()` — inner class LocalBinder |
| 250 | `@Override public IBinder onBind(Intent intent)` |
| 255 | `@Override public boolean onUnbind(Intent intent)` |
| 262 | `private void broadcastUpdate(final String action, String address)` |
| 266 | `private void broadcastUpdate(boolean succeed, String address, final String action, final BluetoothGattCharacteristic characteristic)` |
| 282 | `public boolean initialize()` |

**Inner class:** `LocalBinder extends Binder` — line 243

**Noteworthy implementation observations:**
- `connect(BluetoothDevice)` (line 155–170): Contains a dead null-check on `device` at line 162 after the parameter has already been dereferenced at line 161 (`device.getAddress()`). The null-check can never be reached if `device` is null because the NPE would have already occurred.
- `broadcastUpdate()` (line 278): `sendBroadcast(intent)` is commented out and replaced with `BleControlService.sendData(intent, uuid)`, bypassing the Android broadcast system. This is not tested.
- `setCharacteristicNotification()` (line 228): `descriptor` is retrieved without a null check and immediately dereferenced at line 231. If the GATT descriptor is missing, this will throw a NullPointerException.

---

### File 3: BleModel.java

**Fully qualified class name:** `au.com.collectiveintelligence.fleetiq360.WebService.BLE.BleModel`

**Constants (public static final String — UUIDs and token):**
- `UUID_BLE_TIME = "00002a2b-0000-1000-8000-00805f9b34fb"` — line 13
- `UUID_BLE_DEVICE_NAME = "00002a00-0000-1000-8000-00805f9b34fb"` — line 14
- `UUID_BLE_MANUFACTURE = "00002a29-0000-1000-8000-00805f9b34fb"` — line 15
- `UUID_BLE_MODEL = "00002a24-0000-1000-8000-00805f9b34fb"` — line 16
- `UUID_SHOCK_COUNT = "69dfccac-59b7-ef3e-5309-db222d1c2d09"` — line 17
- `UUID_SHOCK_EVENT_ITEM = "53535322-e7fc-8229-b470-89d9fda99e46"` — line 18
- `UUID_POP_SHOCK_EVENT = "1642fcc6-bcc9-63f5-039a-721e9acbfb93"` — line 19
- `UUID_SHOCK_THRESHOLD = "6d3f3a08-06dd-4c11-6add-00c0c2443c77"` — line 20
- `UUID_RELAY_0 = "3cfd3551-3e85-7cfa-7425-9b54c464c6b1"` — line 21
- `UUID_RELAY_1 = "1ffbb954-2443-c7c4-f98d-78e9abdd54de"` — line 22
- `UUID_TOKEN_AUTH = "6d1e95a3-12bf-1107-705e-16edf5954aba"` — line 23
- `TOKEN_AUTH = "uS8MgpklMx"` — line 24 — **CRITICAL: plaintext hardcoded authentication token**
- `UUID_RELAY_0_TIMEOUT = "e4d93331-cd59-9f70-4490-7f3adda0784d"` — line 26
- `UUID_RELAY_1_TIMEOUT = "465330b5-8bc7-ed83-d3c5-a6601946b503"` — line 27
- `CLIENT_CHARACTERISTIC_CONFIG = "00002902-0000-1000-8000-00805f9b34fb"` — line 29 (public static, non-final)

**Constants (package-private static final String — characteristic paths):**
- `basePath = "au.com.collectiveintelligence.characteristic."` — line 32
- `PATH_VERSION_MAIN = "system.version_main"` — line 33
- `PATH_VERSION_RADIO = "system.version_radio"` — line 34
- `PATH_SHOCK_EVENT_THRESHOLD = "shock_detection.shock_magnitude_threshold"` — line 35
- `PATH_SHOCK_EVENT_POP = "shock_detection.pop_shock_event"` — line 36
- `PATH_SHOCK_EVENT = "shock_detection.shock_event"` — line 37
- `PATH_SHOCK_EVENT_COUNT = "shock_detection.shock_event_count"` — line 38

**Fields (instance):**
- `mapUuidForPath` (HashMap<String,String>) — line 39
- `ourInstance` (private static BleModel) — line 41

**Methods (with line numbers and signatures):**

| Line | Signature |
|------|-----------|
| 42 | `public static BleModel instance()` |
| 52 | `public BleModel()` — constructor, calls initUuids() |
| 56 | `public String getPrimaryRelayId()` |
| 60 | `public String getRelayId(int index)` |
| 70 | `private void initUuids()` |
| 85 | `public String getPathExternalRelayKey(int index)` |
| 89 | `public String getUUIDFromPath(String path)` |

**Noteworthy implementation observations:**
- `CLIENT_CHARACTERISTIC_CONFIG` is declared `public static` but not `final` (line 29), making it mutable from any class in the project.
- `instance()` (line 42–50) is a non-synchronized singleton. Under concurrent access, two `BleModel` instances could be created.
- `getRelayId(int index)` (line 60–68): Returns empty string `""` for any index other than 0 or 1, with no exception or error indication. Callers receive a silent empty UUID.
- `getUUIDFromPath()` (line 89–121): Derives UUIDs by SHA1-hashing a dotted path string, then slicing substring indices `[0,9]`, `[9,13]`, `[13,17]`, `[17,21]`, `[21,32]` to form a UUID. The slice `[0,9]` produces an 8-character segment, not the standard 8-character first group (which is correct), but `[21,32]` produces an 11-character segment for the last UUID group, not the standard 12 characters. The resulting "UUID" is a non-standard format. No test verifies that these computed UUIDs match the hardware device's actual GATT characteristic UUIDs.

---

## Findings

---

### A13-1: Hardcoded plaintext BLE authentication token with no test verifying it is required before relay commands

**Severity:** CRITICAL
**File:** `BleModel.java`, line 24; `BleMachine.java`, lines 28–44, 229–249
**Class:** `au.com.collectiveintelligence.fleetiq360.WebService.BLE.BleModel`

`TOKEN_AUTH = "uS8MgpklMx"` is a plaintext shared secret stored directly in source code at `BleModel.java:24`. This token is written to the BLE characteristic `UUID_TOKEN_AUTH` by `BleMachine.authDevice()` to authenticate the app to the forklift hardware before relay (engine/ignition control) commands are accepted.

Two compounding problems exist simultaneously:

1. **The token is in source**: Any party with APK access can extract this token via decompilation (no obfuscation, no keystore, no derivation). The token never changes (no rotation mechanism exists). An attacker with the token and a BLE connection can authenticate to any ForkliftIQ device within BLE range and send relay commands.

2. **The auth response handler is fully commented out**: In `BleMachine.onBleDataRead()` at lines 241–249, the entire block that was meant to validate the hardware's response to the auth write is commented out with `//`. The app writes the token but then ignores whether the hardware accepted or rejected it. After a 200 ms delay, `onAuthDone()` is called unconditionally (see `onServiceFound()` lines 63–73). Authentication is therefore always considered successful from the app's perspective, regardless of the hardware's actual response.

There is no test of any kind verifying:
- That relay commands (`setRelay()`) cannot be sent without a prior successful authentication handshake.
- That the token value matches what the hardware expects.
- That a wrong token causes rejection.
- That the commented-out auth response path has been intentionally disabled or is safe to omit.

**Risk:** A compromised or decompiled APK exposes a static token that grants BLE-level forklift ignition control with no server-side verification or revocation path.

---

### A13-2: authDevice() returns true (success) on all failure paths, causing silent auth bypass

**Severity:** CRITICAL
**File:** `BleMachine.java`, lines 28–44
**Method:** `boolean authDevice()`

`authDevice()` returns `true` in three distinct cases:
1. Line 31: `ble_status != STATUS_SERVICE_FOUND` — wrong state, no auth attempted.
2. Line 37–38: `characteristic == null` — auth UUID not found in GATT table, no write attempted.
3. Line 41–43: `writeCharacteristic()` succeeded — the intended success path.

In `onServiceFound()` (line 63), the return value of `authDevice()` is used to decide whether to call `onAuthDone()` immediately (true path) or to delegate to `BleControlService.authDevice()` (false path). This means cases 1 and 2 — which are error conditions — cause the state machine to advance to `STATUS_AUTHENTICATED` exactly as if authentication had succeeded.

No test exists that:
- Calls `authDevice()` when `ble_status != STATUS_SERVICE_FOUND` and verifies the device does not advance to `STATUS_AUTHENTICATED`.
- Calls `authDevice()` when `UUID_TOKEN_AUTH` characteristic is absent and verifies authentication is denied.

---

### A13-3: BLE authentication response from hardware is entirely ignored (commented-out handler)

**Severity:** CRITICAL
**File:** `BleMachine.java`, lines 241–249
**Method:** `void onBleDataRead(Intent intent)`

The handler for `UUID_TOKEN_AUTH` data reads (lines 241–249) is completely commented out:

```java
if (uuid.equals(BleModel.UUID_TOKEN_AUTH)) {
//  Log.d(TAG,"auth device  return " + actionSucceed);
//  if(actionSucceed) {
//      pushStateMachine();
//  }
//  else {
//      authDevice();
//  }
}
```

The hardware's reply to the token write is received but discarded. The design intent is visible in the comment: if the device accepted the token, push the state machine forward; if not, retry. Neither branch executes. Instead, `onServiceFound()` advances the state machine after a fixed 200 ms delay regardless of the hardware response.

This means:
- The app can send relay commands (forklift ignition control) even if the hardware device explicitly rejected the authentication token.
- There is no test confirming this is an intentional design decision or verifying that the hardware enforces authentication independently.

---

### A13-4: setCharacteristicNotification() dereferences descriptor without null check

**Severity:** HIGH
**File:** `BleMachineService.java`, lines 228–233
**Method:** `public boolean setCharacteristicNotification(BluetoothGattCharacteristic, boolean)`

```java
BluetoothGattDescriptor descriptor = characteristic.getDescriptor(
        UUID.fromString(BleModel.CLIENT_CHARACTERISTIC_CONFIG));
descriptor.setValue(BluetoothGattDescriptor.ENABLE_NOTIFICATION_VALUE);
```

`characteristic.getDescriptor()` returns `null` if the descriptor is not present. The return value is never checked before calling `descriptor.setValue()` on line 231, which will throw a `NullPointerException` if the descriptor is absent. This crashes the BLE notification setup for shock counting.

No test exercises the path where the shock-count characteristic lacks a `CLIENT_CHARACTERISTIC_CONFIG` descriptor.

---

### A13-5: connect(BluetoothDevice) contains unreachable null check causing false safety impression

**Severity:** HIGH
**File:** `BleMachineService.java`, lines 155–170
**Method:** `public boolean connect(final BluetoothDevice device)`

```java
mBleDeviceAddress = device.getAddress();  // line 161 — dereferences device
if (device == null) {                      // line 162 — null check is dead code
    Log.w(TAG, "Device not found.  Unable to connect.");
    return false;
}
```

The null guard at line 162 can never be reached because `device.getAddress()` at line 161 would have already thrown a `NullPointerException` if `device` were null. The guard gives the false impression that the null case is handled safely. If a null `BluetoothDevice` is ever passed, the application crashes rather than returning `false` gracefully.

No test passes a null `BluetoothDevice` to `connect(BluetoothDevice)` and verifies it returns `false` without crashing.

---

### A13-6: All BleMachine state machine transitions have zero test coverage

**Severity:** HIGH
**File:** `BleMachine.java`, all methods
**Class:** `au.com.collectiveintelligence.fleetiq360.WebService.BLE.BleMachine`

The entire state machine that governs BLE device authentication and forklift setup is untested. The sequence `onGattServices() -> onServiceFound() -> authDevice() -> onAuthDone() -> [pushStateMachine to AUTHENTICATED] -> setRelay() -> [pushStateMachine to SETUP_DONE]` constitutes the critical path for forklift ignition control. No unit or integration test covers any of these transitions. Specific high-risk untested paths include:

- `onGattServices()` with `null` services list (calls `mBleController.onFailed()` — no test)
- `onGattServices()` with empty services list (should it fail or retry? — no test)
- `setRelay(false)` to disable the relay when `ble_status != STATUS_AUTHENTICATED` (calls `onFailed()` — no test)
- `clearRelay()` when `ble_status < STATUS_SETUP_DONE` (silently returns true — no test)
- `onBleDataRead()` when `uuid` is null or empty (returns early — no test)
- `onBleDataRead()` when relay value does not match `expectingRelayValue` (retries via `setRelayWithDelay()` — no test)
- `onBleDataRead()` when time sync fails (retries via `setTime()` — no test)
- `onBleDataRead()` when threshold does not match `expectingImpactThreshold` (retries via `setImpactThreshold()` — no test)

---

### A13-7: setRelay() uses STATUS_AUTHENTICATED check but setRelayTimeout/setTime/setImpactThreshold use STATUS_SETUP_DONE — inconsistent guard levels with no test

**Severity:** HIGH
**File:** `BleMachine.java`, lines 109–131, 155–172, 174–196, 198–213

`setRelay()` requires `ble_status == STATUS_AUTHENTICATED` (exact equality, line 111).
`setTime()`, `setImpactThreshold()`, and `setRelayTimeout()` require `ble_status >= STATUS_SETUP_DONE` (greater-or-equal, lines 156, 176, 199).

`STATUS_AUTHENTICATED` and `STATUS_SETUP_DONE` (`STATUS_SETUP_RELAY_DONE`) are different numeric values. The inconsistency means:
- `setTime()` and `setImpactThreshold()` can only be called after relay setup is complete.
- `setRelay()` can only be called at exactly the authenticated state, not after setup is done.

No test verifies the correct guard level is applied consistently, or that calling `setRelay()` at `STATUS_SETUP_DONE` correctly fails (it calls `onFailed()`, which fires the equipment failure listener and disconnects).

---

### A13-8: setImpactThreshold() silently substitutes hardcoded default 80000 when threshold is 0

**Severity:** MEDIUM
**File:** `BleMachine.java`, lines 180–183
**Method:** `boolean setImpactThreshold()`

```java
if(mBleController.mEquipmentItem.impact_threshold == 0){
    Log.d(TAG,"setImpactThreshold value is 0");
    temp_impact_threshold = 80000;
}
```

When `impact_threshold` is zero, the code substitutes `80000` with no notification to the caller, the equipment listener, or any error log at a level above DEBUG. Whether zero is a valid configured value or an uninitialized sentinel is not documented. The hardcoded fallback `80000` is never verified to be the correct safety threshold for any specific forklift model.

No test:
- Verifies that `impact_threshold == 0` triggers substitution of `80000`.
- Verifies that `80000` is the correct and safe default for all supported hardware.
- Verifies that non-zero values below a safe minimum are not also silently clamped.

---

### A13-9: setRelayTimeout() hardcodes 60-second timeout with no test and no configurability

**Severity:** MEDIUM
**File:** `BleMachine.java`, lines 198–213
**Method:** `boolean setRelayTimeout()` / `private boolean setRelayTimeout(String)`

```java
relayTimeout.setValue(60, BluetoothGattCharacteristic.FORMAT_UINT16, 0);
```

The relay timeout of 60 seconds is hardcoded. This controls how long the forklift relay stays energised without a BLE keep-alive. If the value is wrong for a given hardware revision, the relay may stay on longer than intended (safety risk) or drop prematurely (operational issue). No test verifies the value written, and there is no configuration path for operators or hardware revisions to adjust this.

---

### A13-10: BleModel.CLIENT_CHARACTERISTIC_CONFIG is public static non-final and can be mutated

**Severity:** MEDIUM
**File:** `BleModel.java`, line 29

```java
public static String CLIENT_CHARACTERISTIC_CONFIG = "00002902-0000-1000-8000-00805f9b34fb";
```

This field is `public static` but not `final`. Any class in the application can overwrite it at runtime, causing `setCharacteristicNotification()` in `BleMachineService` to look up the wrong descriptor UUID for the shock-count notification, silently breaking shock detection. No test verifies the field is immutable or that mutation causes a detectable failure.

---

### A13-11: BleModel singleton instance() is not thread-safe

**Severity:** MEDIUM
**File:** `BleModel.java`, lines 42–50
**Method:** `public static BleModel instance()`

```java
public static BleModel instance() {
    if (ourInstance == null) {
        ourInstance = new BleModel();
    }
    return ourInstance;
}
```

The double-checked locking pattern is absent. Under concurrent access from two threads (e.g., BleControlService and a UI thread both initialising), two `BleModel` instances can be created, each with a separately initialised `mapUuidForPath` cache. The second assignment would silently overwrite the first. `BleController.instance()` (in BleController.java) is `synchronized`; `BleModel.instance()` is not, creating an inconsistency. No test exercises concurrent initialisation.

---

### A13-12: getUUIDFromPath() produces non-standard UUID segment lengths with no test validating hardware compatibility

**Severity:** MEDIUM
**File:** `BleModel.java`, lines 89–121
**Method:** `public String getUUIDFromPath(String path)`

The UUID construction slices a SHA1 hex string as:
- Group 1: `[0, 9)` → 9 hex characters (standard: 8)
- Group 2: `[9, 13)` → 4 hex characters (standard: 4)
- Group 3: `[13, 17)` → 4 hex characters (standard: 4)
- Group 4: `[17, 21)` → 4 hex characters (standard: 4)
- Group 5: `[21, 32)` → 11 hex characters (standard: 12)

The total is 9+4+4+4+11 = 32 hex characters plus 4 hyphens = 36 characters, matching UUID length. However, the first group has 9 hex digits instead of the standard 8, and the last group has 11 instead of 12. This means the computed UUIDs are not standard RFC 4122 UUIDs. No test verifies that UUIDs produced this way match any characteristic UUID on actual hardware, nor that `UUID.fromString()` or the Android BLE stack accepts them without modification.

---

### A13-13: getRelayId() silently returns empty string for invalid index

**Severity:** MEDIUM
**File:** `BleModel.java`, lines 60–68
**Method:** `public String getRelayId(int index)`

```java
public String getRelayId(int index) {
    if(index == 0) { return UUID_RELAY_0; }
    else if(index == 1) { return UUID_RELAY_1; }
    return "";
}
```

For any index other than 0 or 1, the method returns `""`. Callers passing this to `getCharacteristic("")` would silently fail to find any characteristic and receive `null`, which may then propagate as a false-success return (as seen in `setRelay()` at line 118–121). No exception is thrown. No test exercises index values of -1, 2, or `Integer.MAX_VALUE`.

---

### A13-14: disableShockNotification() condition is inverted, making the log statement unreachable in normal operation

**Severity:** LOW
**File:** `BleMachine.java`, lines 83–94
**Method:** `boolean disableShockNotification()`

```java
if (mBleController.ble_status < mBleController.STATUS_SETUP_DONE)
    Log.d(TAG, "disableShockNotification enter");
```

The log line only executes when `ble_status < STATUS_SETUP_DONE`, i.e., during states where the device is not yet set up. `setShockNotification()` at line 96–107 has the identical condition. In normal operation — when disabling notifications after setup — the log is never emitted. This suggests the condition is inverted (should be `>=`) or the log is in the wrong branch. No test verifies the logging occurs on the expected code path.

---

### A13-15: broadcastUpdate() bypasses Android broadcast system with no test covering the replacement path

**Severity:** LOW
**File:** `BleMachineService.java`, lines 266–280
**Method:** `private void broadcastUpdate(boolean, String, String, BluetoothGattCharacteristic)`

```java
//sendBroadcast(intent);
BleControlService.sendData(intent, uuid);
```

The standard `sendBroadcast()` call is commented out and replaced by a direct static method call to `BleControlService.sendData()`. This bypasses the Android LocalBroadcastManager system entirely. Any other component that registered to receive the GATT broadcast actions will receive nothing. No test verifies that all components that need GATT event notifications actually receive them through the replacement mechanism.

---

### A13-16: handleBleOperation() calls authDevice() twice on failure without backoff

**Severity:** LOW
**File:** `BleControlService.java` (informational, referenced from BleMachine.java), lines 110–124

When `authDevice()` returns `false`, the code immediately calls `authDevice()` again on the next line with no delay:

```java
result = mBleMachine.authDevice();
if(!result){
    mBleMachine.authDevice();
}
```

No test covers what happens if both calls fail, nor whether back-to-back writes to the same GATT characteristic without awaiting the write callback is safe or supported by the Android BLE stack (it is generally not — the Android BLE stack requires waiting for the `onCharacteristicWrite` callback before issuing another write).

---

### A13-17: No test for BleMachineService.initialize() failure paths

**Severity:** LOW
**File:** `BleMachineService.java`, lines 282–300
**Method:** `public boolean initialize()`

`initialize()` returns `false` if `BluetoothManager` or `BluetoothAdapter` cannot be obtained. The caller in `BleController.onBleServiceConnected()` calls `onFailed()` in this case. No test exercises either failure path (null manager, null adapter), nor verifies that `onFailed()` is called exactly once without side effects.

---

### A13-18: No test for BleModel.getUUIDFromPath() with null or empty path

**Severity:** LOW
**File:** `BleModel.java`, lines 89–121
**Method:** `public String getUUIDFromPath(String path)`

If `path` is null, `mapUuidForPath.containsKey(null)` returns false, then `basePath + null` produces the string `"au.com.collectiveintelligence.characteristic.null"`, which is SHA1-hashed and returned as a spurious UUID. If `CommonFunc.SHA1()` returns null or empty, the method returns `""` at line 99. No test covers null input, empty string input, or the path where `SHA1()` returns null.

---

### A13-19: disableShockNotification() is defined but never called within the assigned files

**Severity:** INFO
**File:** `BleMachine.java`, lines 83–94
**Method:** `boolean disableShockNotification()`

`disableShockNotification()` is defined with package-private visibility but does not appear to be called anywhere in `BleMachine.java`, `BleMachineService.java`, or `BleModel.java`. A project-wide search would be required to confirm it has callers, but it is absent from `BleControlService.java` as well. Dead code in the BLE control path warrants investigation. No test verifies it can be called without side effects or that it correctly sets the GATT descriptor back to `DISABLE_NOTIFICATION_VALUE`.

---

*End of A13 findings. Total: 1 project-wide HIGH (zero test infrastructure), 3 CRITICAL, 3 HIGH, 5 MEDIUM, 4 LOW, 1 INFO.*
