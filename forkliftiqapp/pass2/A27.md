# Audit Pass 2 — Agent A27
**Audit run:** 2026-02-26-01
**Agent:** A27
**Files assigned:**
1. `app/src/main/java/au/com/collectiveintelligence/fleetiq360/WebService/webserviceclasses/ServiceRecordItem.java`
2. `app/src/main/java/au/com/collectiveintelligence/fleetiq360/WebService/webserviceclasses/ServiceSummaryItem.java`
3. `app/src/main/java/au/com/collectiveintelligence/fleetiq360/WebService/webserviceclasses/TrainingItem.java`

---

## PROJECT-WIDE FINDING

### A27-1 — HIGH: Zero automated test coverage across app/ and LibCommon/ modules

No test directories exist under `app/src/` or `LibCommon/src/`. The only test directories found in the repository are in third-party library modules (`LibImageloader`, `LibImagePicker`, `LibPercentProgress`) and test only those libraries' own internal logic. No unit tests, no instrumented tests, and no integration tests exist for any production code written by the application authors.

Every finding below (A27-2 through A27-15) is untested by definition. This project-wide gap means regressions in JSON parsing, data-integrity logic, and safety-critical training-expiry evaluation can ship undetected.

**Severity:** HIGH
**Scope:** Entire `app/` and `LibCommon/` modules

---

## File 1: ServiceRecordItem.java

### Reading Evidence

**Fully qualified class name:** `au.com.collectiveintelligence.fleetiq360.WebService.webserviceclasses.ServiceRecordItem`

**Implements:** `java.io.Serializable`

**Fields (all public, no explicit initializers beyond Java primitive defaults):**

| Field | Type | Default | Line |
|---|---|---|---|
| `acc_hours` | `double` | `0.0` | 14 |
| `unit_name` | `String` | `null` | 15 |
| `service_due` | `double` | `0.0` | 16 |
| `last_serv` | `int` | `0` | 17 |
| `next_serv` | `int` | `0` | 18 |
| `serv_duration` | `int` | `0` | 19 |
| `service_type` | `String` | `null` | 20 |
| `unit_id` | `int` | `0` | 21 |

**Methods:**

| Line | Signature |
|---|---|
| 23 | `public ServiceRecordItem()` |
| 26 | `public ServiceRecordItem(JSONObject jsonObject) throws JSONException` |

**Constants defined:** None

**Imports used in production:** `org.json.JSONException`, `org.json.JSONObject`, `java.io.Serializable` (the `JSONArray`, `ArrayList`, `BigDecimal`, and wildcard imports at lines 6–10 are unused).

---

### Findings for ServiceRecordItem.java

#### A27-2 — LOW: No test for no-arg constructor leaving all fields at zero/null defaults

`ServiceRecordItem()` (line 23) is the empty constructor. It leaves all numeric fields at `0`/`0.0` and both String fields (`unit_name`, `service_type`) at `null`. No test verifies these defaults before the object is used. Callers in `ServiceEditFragment` (line 151) already guard `service_type == null`, but `unit_name == null` is used directly with `setText()` at line 141 of `ServiceEditFragment`, which will throw a `NullPointerException` if the no-arg constructor is used and `unit_name` is never populated. Without a test that constructs a bare `ServiceRecordItem()` and passes it through the UI path, this crash path is latent and unverified.

**Severity:** LOW
**Untested method:** `ServiceRecordItem()`

#### A27-3 — MEDIUM: No test for `ServiceRecordItem(JSONObject)` with a null argument

Line 28 guards `if (jsonObject != null)` but there is no test that passes `null` directly to the constructor and asserts that all fields remain at their defaults. The guard is correct, but its correctness is untested. The constructor is called at line 26 of `ServiceRecordResultArray.java` via `jsonArray.getJSONObject(i)`, which never returns `null` (it throws `JSONException` instead), so in practice the guard is dead code — yet without a test, this is not documented and the path cannot be verified.

**Severity:** MEDIUM
**Untested path:** `ServiceRecordItem(null)`

#### A27-4 — MEDIUM: No test for `ServiceRecordItem(JSONObject)` with all keys absent

No test exercises the branch where the JSON object is present but every key is absent (i.e., all `isNull()` guards evaluate to true, so every field stays at its Java default). Because numeric fields default to `0` and `0.0`, a fully-absent JSON response is indistinguishable from a legitimate record where all values are zero. The `getStatus()` logic in `ServiceRecordFragment` (line 57) treats `service_due == 0 && acc_hours == 0` as `STATUS_NOT_SET`, so an empty record is masked rather than flagged as a parse error. Without a test, this silent-failure path is unverified.

**Severity:** MEDIUM
**Untested path:** All-absent keys in `ServiceRecordItem(JSONObject)`

#### A27-5 — MEDIUM: No test for `ServiceRecordItem(JSONObject)` with type-mismatched values

No test verifies the `JSONException` propagation when a field contains an unexpected JSON type (e.g., `"acc_hours": "notanumber"`). The constructor declares `throws JSONException` and propagates it to callers. `ServiceRecordResultArray` also propagates it. Whether the UI layer handles this exception gracefully is entirely untested.

**Severity:** MEDIUM
**Untested path:** Type-mismatched JSON values triggering `JSONException`

#### A27-6 — LOW: No test for `ServiceRecordItem(JSONObject)` with negative or extreme numeric values

No test covers `acc_hours` or `service_due` at `Double.MAX_VALUE`, `Double.MIN_VALUE`, `Double.NaN`, `Double.POSITIVE_INFINITY`, or large negative numbers. The `getStatus()` logic in `ServiceRecordFragment` makes comparisons against `service_due` (e.g., `service_due > 0`, `service_due <= 0`). `NaN` comparisons always return false in Java, meaning a `NaN` value for `service_due` would fall through all comparisons and return `STATUS_NOT_SET` silently. This is unverified.

**Severity:** LOW
**Untested boundary:** Extreme/NaN `double` values for `acc_hours` and `service_due`

#### A27-7 — LOW: Unused imports indicate dead code risk

Lines 6–10 import `JSONArray`, `ArrayList`, `BigDecimal`, and two wildcard packages that are not used by this class. No test catches a future developer adding code that relies on these imports to resolve a name collision or shadow. This is a code-quality marker for a file that may have been generated and not cleaned up.

**Severity:** LOW (INFO-adjacent, but signals unreviewed generated code)

---

## File 2: ServiceSummaryItem.java

### Reading Evidence

**Fully qualified class name:** `au.com.collectiveintelligence.fleetiq360.WebService.webserviceclasses.ServiceSummaryItem`

**Implements:** `java.io.Serializable`

**Fields (all public, no explicit initializers):**

| Field | Type | Default | Line |
|---|---|---|---|
| `unit_id` | `int` | `0` | 14 |
| `acc_hours` | `int` | `0` | 15 |
| `service_due` | `int` | `0` | 16 |
| `last_serv` | `int` | `0` | 17 |
| `next_serv` | `int` | `0` | 18 |
| `serv_duration` | `int` | `0` | 19 |
| `unit_name` | `String` | `null` | 20 |
| `service_type` | `String` | `null` | 21 |

**Methods:**

| Line | Signature |
|---|---|
| 23 | `public ServiceSummaryItem()` |
| 26 | `public ServiceSummaryItem(JSONObject jsonObject) throws JSONException` |

**Constants defined:** None

**Imports used in production:** `org.json.JSONException`, `org.json.JSONObject`, `java.io.Serializable` (the `JSONArray`, `ArrayList`, `BigDecimal`, and wildcard imports are unused).

---

### Findings for ServiceSummaryItem.java

#### A27-8 — MEDIUM: `acc_hours` declared as `int` here but `double` in `ServiceRecordItem` — type inconsistency is untested

`ServiceSummaryItem.acc_hours` is `int` (line 15), but `ServiceRecordItem.acc_hours` is `double` (line 14 of `ServiceRecordItem.java`). Both fields are populated from a JSON key named `"acc_hours"` from what is presumably the same server API or the same conceptual data domain. If the server ever returns a fractional value for `acc_hours`, `ServiceSummaryItem` will silently truncate it via `getInt()` while `ServiceRecordItem` preserves it via `getDouble()`. Similarly, `service_due` is `int` in `ServiceSummaryItem` but `double` in `ServiceRecordItem`. No test compares the two classes' behavior on the same JSON payload, and no test verifies truncation or the intentionality of the type difference.

**Severity:** MEDIUM
**Untested inconsistency:** `acc_hours` and `service_due` are `double` in `ServiceRecordItem` but `int` in `ServiceSummaryItem`

#### A27-9 — LOW: No test for no-arg constructor leaving all fields at zero/null defaults

Same structural gap as A27-2. `ServiceSummaryItem()` (line 23) leaves String fields null and numeric fields zero. No consumer of `ServiceSummaryItem` is evident in the fragments reviewed (it is consumed via `ServiceSummaryResultArray`), but the public field exposure makes accidental use of a default-constructed instance possible without compile-time protection. Untested.

**Severity:** LOW
**Untested method:** `ServiceSummaryItem()`

#### A27-10 — MEDIUM: No test for `ServiceSummaryItem(JSONObject)` with a null argument

Same structural gap as A27-3. The null guard on line 28 is untested. Correct behavior on `null` input is unverified.

**Severity:** MEDIUM
**Untested path:** `ServiceSummaryItem(null)`

#### A27-11 — MEDIUM: No test for `ServiceSummaryItem(JSONObject)` with type-mismatched values causing `JSONException`

Same structural gap as A27-5. The constructor propagates `JSONException` unhandled to callers. No test verifies the exception is raised for bad input or that the caller handles it.

**Severity:** MEDIUM
**Untested path:** Type-mismatched JSON values triggering `JSONException`

#### A27-12 — LOW: Unused imports (same pattern as ServiceRecordItem)

Lines 6–10 import `JSONArray`, `ArrayList`, `BigDecimal`, and wildcard packages not used by this class. Same generated-code hygiene issue as A27-7.

**Severity:** LOW

---

## File 3: TrainingItem.java

### Reading Evidence

**Fully qualified class name:** `au.com.collectiveintelligence.fleetiq360.WebService.webserviceclasses.TrainingItem`

**Implements:** `java.io.Serializable`

**Fields (all public, no explicit initializers):**

| Field | Type | Default | Line |
|---|---|---|---|
| `manufacture_id` | `int` | `0` | 10 |
| `type_id` | `int` | `0` | 11 |
| `fuel_type_id` | `int` | `0` | 12 |
| `training_date` | `String` | `null` | 13 |
| `expiration_date` | `String` | `null` | 14 |

**Methods:**

| Line | Signature |
|---|---|
| 16 | `public TrainingItem()` |
| 19 | `public TrainingItem(JSONObject jsonObject) throws JSONException` |

**Constants defined:** None

**Imports used in production:** `org.json.JSONException`, `org.json.JSONObject`, `java.io.Serializable` (all imports are used or minimal; no unused wildcard imports unlike the other two files).

---

### Findings for TrainingItem.java

#### A27-13 — HIGH: No test for `expiration_date` absent or null causing silent training-expiry bypass

`expiration_date` is populated only if `!jsonObject.isNull("expiration_date")` (line 44). If the key is absent, `expiration_date` remains `null`. In `EquipmentListFragment.getTrainingExpiryDate()` (line 169), `dateFormatter.parseDate(training.get(i).expiration_date)` is called with a potentially null string. If `parseDate()` returns `null` on a null input (its behavior is untested), then `getTrainingExpiryDate()` returns `null`, and the caller at line 121–124 of `EquipmentListFragment` treats `null` as "no training required" and immediately proceeds to allow equipment access (`goToCurrentEquipmentNext(position)`). This means a server that omits `expiration_date` grants equipment access unconditionally, bypassing the expiry check entirely. This is a safety-critical path with no test.

**Severity:** HIGH
**Untested path:** `expiration_date` absent from JSON -> `null` field -> `null` returned from `getTrainingExpiryDate()` -> access granted unconditionally

#### A27-14 — HIGH: No test for `training_date` absent or null and its downstream effect

`training_date` is populated only if `!jsonObject.isNull("training_date")` (line 39). If absent, it remains `null`. No consumer in the reviewed code uses `training_date` directly (only `expiration_date` drives the expiry check), but `training_date` is a public field that any future consumer could read without null-checking. The null default is unverified by any test. Additionally, if `training_date` is intended as the start-of-validity anchor, its absence is semantically significant and should produce a distinct result rather than a silent null.

**Severity:** HIGH (escalated because `training_date` is part of safety-gating logic for operator access; even if not currently consumed in the expiry path, its null state is unverified and the field is fully public)

**Untested path:** `training_date` absent from JSON -> `null` field used by any future consumer without null guard

#### A27-15 — MEDIUM: No test for `TrainingItem(JSONObject)` with a null argument

Same structural gap as A27-3 and A27-10. Line 21 guards `if (jsonObject != null)` but no test verifies that passing `null` results in all fields remaining at defaults. In `LoginItem.java` at line 64, `TrainingItem` is constructed from `jsonArray.getJSONObject(i)`, which never returns null (throws instead), so the guard is dead code in practice — untested and undocumented.

**Severity:** MEDIUM
**Untested path:** `TrainingItem(null)`

#### A27-16 — MEDIUM: No test for `expiration_date` containing a malformed date string

`expiration_date` is stored as a raw `String` with no format validation in this class. `EquipmentListFragment.getTrainingExpiryDate()` passes the string to `ServerDateFormatter.parseDate()`. If the server returns a malformed date (e.g., `"N/A"`, `""`, `"2024-99-99"`), `parseDate()` may return `null` or throw a `ParseException`. If it returns `null`, the caller grants equipment access (see A27-13). No test exercises a malformed `expiration_date` string through the full call chain.

**Severity:** MEDIUM
**Untested path:** Malformed `expiration_date` string -> parse failure -> potential access grant

#### A27-17 — LOW: No test for ID fields (`manufacture_id`, `type_id`, `fuel_type_id`) defaulting to `0` when absent

When any ID field is absent from JSON, it defaults to `0`. In `EquipmentListFragment.getTrainingExpiryDate()` (lines 165–167), the training lookup compares `equipment.manu_id == training.get(i).manufacture_id`, etc. If a `TrainingItem` has `manufacture_id == 0` due to an absent key, it could match an `EquipmentItem` that also has `manu_id == 0` (the Java default for `int`), producing a false positive match and returning a training record that does not actually apply to that equipment. No test exercises this boundary.

**Severity:** LOW
**Untested boundary:** ID fields defaulting to `0` causing false-positive matches in the training lookup

---

## Summary Table

| ID | Severity | File | Description |
|---|---|---|---|
| A27-1 | HIGH | Project-wide | Zero automated test coverage in app/ and LibCommon/ |
| A27-2 | LOW | ServiceRecordItem | No-arg constructor untested; null `unit_name` crash path latent |
| A27-3 | MEDIUM | ServiceRecordItem | `ServiceRecordItem(null)` path untested |
| A27-4 | MEDIUM | ServiceRecordItem | All-absent-keys JSON path untested; silent zero-default masking |
| A27-5 | MEDIUM | ServiceRecordItem | `JSONException` propagation on type mismatch untested |
| A27-6 | LOW | ServiceRecordItem | Extreme/NaN double values for `acc_hours`/`service_due` untested |
| A27-7 | LOW | ServiceRecordItem | Unused imports signal unreviewed generated code |
| A27-8 | MEDIUM | ServiceSummaryItem | `acc_hours`/`service_due` declared `int` vs `double` in ServiceRecordItem — inconsistency untested |
| A27-9 | LOW | ServiceSummaryItem | No-arg constructor untested |
| A27-10 | MEDIUM | ServiceSummaryItem | `ServiceSummaryItem(null)` path untested |
| A27-11 | MEDIUM | ServiceSummaryItem | `JSONException` propagation on type mismatch untested |
| A27-12 | LOW | ServiceSummaryItem | Unused imports |
| A27-13 | HIGH | TrainingItem | Absent `expiration_date` -> null -> equipment access granted unconditionally; untested |
| A27-14 | HIGH | TrainingItem | Absent `training_date` -> null field in safety-gating context; untested |
| A27-15 | MEDIUM | TrainingItem | `TrainingItem(null)` path untested |
| A27-16 | MEDIUM | TrainingItem | Malformed `expiration_date` string through parse chain untested |
| A27-17 | LOW | TrainingItem | ID fields defaulting to `0` when absent; false-positive training match untested |
