# Audit Pass 2 — Agent A37
## Test Coverage Review
**Audit run:** 2026-02-26-01
**Assigned files:**
1. `app/src/main/java/au/com/collectiveintelligence/fleetiq360/WebService/webserviceclasses/results/GetEmailResult.java`
2. `app/src/main/java/au/com/collectiveintelligence/fleetiq360/WebService/webserviceclasses/results/GetEquipmentResultArray.java`
3. `app/src/main/java/au/com/collectiveintelligence/fleetiq360/WebService/webserviceclasses/results/GetTokenResult.java`

---

## PROJECT-WIDE FINDING (HIGH): Zero Automated Test Coverage

**ID:** A37-1
**Severity:** HIGH
**Scope:** Entire project — `app/` and `LibCommon/` modules

The `app/` module contains no `src/test/` or `src/androidTest/` directories. The `LibCommon/` module likewise has no test directories. A search across the repository confirms that the only test files present are in third-party library modules (`LibImageloader`, `LibImagePicker`, `LibPercentProgress`) — none of which test application code.

Evidence:
- `app/src/` contains only `main/`. No `test/` or `androidTest/` sibling exists.
- Glob for `**/test/**/*.java` returns only `LibImageloader` results.
- Glob for `**/androidTest/**/*.java` returns only `LibImagePicker` and `LibPercentProgress` results.

**Impact:** Every finding below describing an untested method or behavior is untested not because a test was deleted or skipped — it is untested because no testing infrastructure exists at all for production code. Regressions, security defects, and parsing failures in authentication, equipment, and email flows have zero automated detection. Any defect in these classes reaches production without a safety net.

**Recommendation:** Establish JUnit 4/5 unit test infrastructure in `app/src/test/` and Espresso/Robolectric infrastructure in `app/src/androidTest/`. Prioritize security-sensitive classes (`GetTokenResult`, `WebData`, `TokenAuthenticator`) first.

---

## File 1: GetEmailResult.java

### Reading Evidence

**Fully qualified class name:**
`au.com.collectiveintelligence.fleetiq360.WebService.webserviceclasses.results.GetEmailResult`

**Superclass:** `WebServiceResultPacket` (which extends `WebServicePacket`)

**Implements:** `java.io.Serializable`

**Fields defined:**

| Field | Type | Line |
|---|---|---|
| `id` | `int` | 14 |
| `driver_id` | `int` | 15 |
| `email_addr1` | `String` | 16 |
| `email_addr2` | `String` | 17 |
| `email_addr3` | `String` | 18 |
| `email_addr4` | `String` | 19 |

**Methods defined:**

| Line | Signature |
|---|---|
| 21 | `public GetEmailResult()` |
| 24 | `public GetEmailResult(JSONObject jsonObject) throws JSONException` |

**Constants defined:** None.

**Corresponding test file:** None. No test file exists anywhere in the repository for this class or for `GetEmailResult` by name.

---

### Findings for GetEmailResult.java

**ID:** A37-2
**Severity:** LOW
**File:** `GetEmailResult.java`
**Lines:** 21, 24–61

**Finding:** Both constructors — the no-arg constructor `GetEmailResult()` (line 21) and the JSON-parsing constructor `GetEmailResult(JSONObject)` (lines 24–61) — have no test coverage.

The no-arg constructor produces an object where all `int` fields default to `0` and all `String` fields default to `null`. No test verifies that a consumer of this class handles those defaults safely (e.g., that a null `email_addr1` does not cause a NullPointerException in the email display UI).

The JSON constructor is the operationally critical path: it is invoked by `WebApi` when the server returns email configuration. No test exercises:
- Normal population of all six fields from a valid JSON object.
- Behavior when the `JSONObject` argument is `null` (the null guard at line 28 is present, but it is untested — the branch is never exercised).
- Behavior when individual keys are absent from the JSON (the `isNull()` guards at lines 31, 36, 41, 46, 51, 56 leave the corresponding fields at their Java default, which for `String` is `null` and for `int` is `0`). No test confirms consumers handle `null` email addresses gracefully.
- Behavior when a key is present but holds an unexpected type (e.g., `"id"` set to a string value), which would throw `JSONException` and propagate uncaught to the caller.

**ID:** A37-3
**Severity:** MEDIUM
**File:** `GetEmailResult.java`
**Lines:** 24–61

**Finding:** The JSON-parsing constructor declares `throws JSONException` but no test exercises the failure path where a key exists in the JSON with a wrong type. For example, if the server returns `"id": "not-a-number"`, the call `jsonObject.getInt("id")` at line 33 will throw `JSONException`. The `isNull()` guard only protects against JSON null values; it does not protect against type mismatches. No test verifies that the caller (`WebApi`) handles this exception, and no test confirms that the app degrades gracefully (shows an error rather than crashing) when email data is malformed. The `isNull()` guard pattern is consistently used for all six fields, so all six are vulnerable to the same type-mismatch failure path.

---

## File 2: GetEquipmentResultArray.java

### Reading Evidence

**Fully qualified class name:**
`au.com.collectiveintelligence.fleetiq360.WebService.webserviceclasses.results.GetEquipmentResultArray`

**Superclass:** `WebServiceResultPacket` (which extends `WebServicePacket`)

**Implements:** `java.io.Serializable`

**Fields defined:**

| Field | Type | Line |
|---|---|---|
| `arrayList` | `ArrayList<EquipmentItem>` | 14 |

**Methods defined:**

| Line | Signature |
|---|---|
| 16 | `public GetEquipmentResultArray()` |
| 19 | `public GetEquipmentResultArray(JSONArray jsonArray) throws JSONException` |

**Constants defined:** None.

**Corresponding test file:** None. No test file exists anywhere in the repository for this class or for `GetEquipmentResultArray` by name.

---

### Findings for GetEquipmentResultArray.java

**ID:** A37-4
**Severity:** LOW
**File:** `GetEquipmentResultArray.java`
**Lines:** 16, 19–30

**Finding:** Both constructors are untested. The no-arg constructor (line 16) leaves `arrayList` as `null`. No test confirms that callers handle a null `arrayList` (as opposed to the empty list produced by the JSON constructor when passed a `null` argument). This distinction matters: code that calls `result.arrayList.size()` after constructing via the no-arg path will throw `NullPointerException`.

The JSON constructor (lines 19–30) is operationally critical — it populates the equipment list shown to drivers. No test exercises:
- Normal population from a valid `JSONArray` containing one or more equipment entries.
- Behavior when `jsonArray` is `null` (line 23 null-guards this, resulting in an empty `arrayList` — untested but behavior is defined).
- Behavior when `jsonArray` is empty (zero elements — the loop executes zero times, `arrayList` is empty; not tested).
- Behavior when `jsonArray.getJSONObject(i)` returns malformed data that causes `EquipmentItem`'s constructor to throw `JSONException`. This exception propagates from `GetEquipmentResultArray`'s constructor to the caller with no recovery.
- Behavior when the array is very large (memory or performance boundary — not tested).

**ID:** A37-5
**Severity:** MEDIUM
**File:** `GetEquipmentResultArray.java`
**Lines:** 25–28

**Finding:** The loop at lines 25–28 calls `new EquipmentItem(jsonArray.getJSONObject(i))` with no per-element error handling. If any single element in the server response is malformed, `JSONException` is thrown and the entire array construction fails — the `arrayList` is left in a partially populated state (already-added items remain, but the field reference becomes irrelevant because the exception unwinds the constructor). No test verifies partial-failure behavior, no test confirms the caller presents an appropriate error, and no test verifies that a single bad array element does not silently drop the rest of the equipment list. This is particularly relevant for a fleet management application where missing equipment from the list could prevent a driver from checking out a vehicle.

---

## File 3: GetTokenResult.java

### Reading Evidence

**Fully qualified class name:**
`au.com.collectiveintelligence.fleetiq360.WebService.webserviceclasses.results.GetTokenResult`

**Superclass:** `WebServiceResultPacket` (which extends `WebServicePacket`)

**Implements:** `java.io.Serializable`

**Fields defined:**

| Field | Type | Line | Security sensitivity |
|---|---|---|---|
| `value` | `String` | 14 | CRITICAL — bearer access token (raw credential) |
| `expiration` | `int` | 15 | HIGH — token lifetime in seconds |
| `tokenType` | `String` | 16 | LOW — token scheme (e.g., "Bearer") |
| `expired` | `boolean` | 17 | HIGH — server-reported expiry flag |
| `refreshToken` | `RefreshTokenItem` | 18 | CRITICAL — refresh token credential (see `RefreshTokenItem.value`) |

Note on `RefreshTokenItem`: it has fields `value` (String, the refresh token credential) and `expiration` (int). Both are public and unencrypted.

**Methods defined:**

| Line | Signature |
|---|---|
| 20 | `public GetTokenResult()` |
| 23 | `public GetTokenResult(JSONObject jsonObject) throws JSONException` |

**Constants defined:** None.

**Corresponding test file:** None. No test file exists anywhere in the repository for this class or for `GetTokenResult` by name.

---

### Cross-reference: Token lifecycle in production code

The following was established by reading `WebData.java`, `TokenAuthenticator.java`, `CurrentUser.java`, and `ModelPrefs.java` to understand how `GetTokenResult` is used:

- `WebData.setGetTokenResult(GetTokenResult)` (line 91 of `WebData.java`) stores the full `GetTokenResult` object by serializing it as a JSON string into Android `SharedPreferences` under the key `"token_result"` via `ModelPrefs.saveObject()`.
- `SharedPreferences` stores data in a plain-text XML file on the device filesystem, readable by root or via an ADB backup on a non-production build. The bearer token value (`GetTokenResult.value`) and the refresh token value (`RefreshTokenItem.value`) are stored in plaintext.
- `WebData.logout()` (line 108) calls only `CurrentUser.logout()`, which deletes the `"current_user_id"` key from `SharedPreferences` and nulls the in-memory `user` reference. It does NOT delete `"token_result"` from `SharedPreferences`. The bearer token and refresh token survive logout on the device.
- `WebData.getTokenString()` (line 117) reads the token back from `SharedPreferences` on demand. No expiry check against the `expiration` field or the `expired` flag occurs before the token is used.
- `TokenAuthenticator.getAccessToken()` uses `WebData.instance().getTokenFormData()` to obtain hardcoded credentials (`client_secret: "8752361E593A573E86CA558FFD39E"`, `username: "gas"`, `password: "ciiadmin"`) when refreshing a token — this is a separate security concern but directly relevant to what `GetTokenResult` receives and stores.
- `isAppInitialized()` (line 124 of `WebData.java`) uses the presence of a non-empty token string (from `GetTokenResult.value`) to determine whether the app is already authenticated — no expiry validation is performed.

---

### Findings for GetTokenResult.java

**ID:** A37-6
**Severity:** CRITICAL
**File:** `GetTokenResult.java`
**Lines:** 14, 18
**Related files:** `WebData.java` lines 91–93, 108–110; `CurrentUser.java` lines 125–127; `ModelPrefs.java` lines 53–58

**Finding: Bearer token and refresh token are not cleared on logout. No test verifies this lifecycle.**

The `GetTokenResult.value` field holds the bearer access token. The `GetTokenResult.refreshToken` field (a `RefreshTokenItem`) holds the refresh token. Both are security credentials that grant API access on behalf of the authenticated user.

When `WebData.logout()` is called, it delegates entirely to `CurrentUser.logout()`. `CurrentUser.logout()` deletes the `"current_user_id"` key and nulls the in-memory `user` reference. Neither method deletes `"token_result"` from `SharedPreferences`.

The result is that after a user logs out:
1. The bearer token remains in `SharedPreferences` under key `"token_result"`.
2. The refresh token remains in `SharedPreferences` under the same key (serialized within the `GetTokenResult` JSON).
3. If another user picks up the device and attempts to log in, `WebData.isAppInitialized()` will return `true` (token string is non-null and non-empty), potentially bypassing the login flow entirely for the stale token.
4. An attacker with filesystem access (rooted device, ADB backup, or forensic acquisition) can recover both the bearer and refresh tokens from the plaintext XML `SharedPreferences` file after the victim has logged out.

Zero tests exist to detect this behavior. There is no test that: performs a login, sets a token, calls logout, and then asserts that `SharedPreferences` no longer contains `"token_result"`.

**ID:** A37-7
**Severity:** CRITICAL
**File:** `GetTokenResult.java`
**Lines:** 14–18
**Related files:** `ModelPrefs.java` lines 53–58, 62–63; `WebData.java` lines 117–122

**Finding: Bearer and refresh token stored in plaintext SharedPreferences. No test verifies secure storage.**

`GetTokenResult` and its embedded `RefreshTokenItem` are serialized to JSON via `GsonHelper.stringFromObjectNoPolicy()` and stored in Android `SharedPreferences` (a plain-text XML file at `/data/data/<package>/shared_prefs/prefs.xml`). All five public fields — including `value` (bearer token) and `refreshToken.value` (refresh token) — are serialized verbatim with no encryption.

On a rooted device, via an ADB backup (on debug builds), or through physical acquisition, this file is trivially readable. The bearer token and refresh token are sufficient to impersonate the authenticated user against the API server.

No test exists that verifies the stored representation of a `GetTokenResult` is encrypted or otherwise protected. No test exists that attempts to read back the token and confirms it cannot be decoded without a key.

**ID:** A37-8
**Severity:** CRITICAL
**File:** `GetTokenResult.java`
**Lines:** 15, 17
**Related files:** `WebData.java` lines 117–126; `TokenAuthenticator.java` lines 27–33

**Finding: Token expiry fields are parsed but never evaluated. No test verifies expiry handling.**

`GetTokenResult` parses two expiry-related fields from the server response: `expiration` (line 15, an integer — presumably a Unix timestamp or seconds-to-live) and `expired` (line 17, a boolean flag). Both fields are populated into public fields on the object.

Neither field is read anywhere in the application codebase. Specifically:
- `WebData.isAppInitialized()` checks only whether `getTokenResult.value` is non-null and non-empty. It does not check `expired` or compare `expiration` against the current time.
- `WebData.getTokenString()` returns the raw token value unconditionally — no expiry guard.
- `TokenAuthenticator.authenticate()` requests a new token when a 401 response is received, but this is a reactive refresh (triggered by server rejection) rather than a proactive check of the parsed expiry fields.

An expired token will be sent on every API call until the server explicitly rejects it with a 401. There is no proactive expiry detection or pre-emptive refresh based on the parsed `expiration` value. No test verifies that an expired token triggers a refresh or a re-login prompt before an API call is made.

**ID:** A37-9
**Severity:** HIGH
**File:** `GetTokenResult.java`
**Lines:** 20, 23–55

**Finding: Both constructors are entirely untested.**

The no-arg constructor `GetTokenResult()` (line 20) produces an object where `value` is `null`, `expiration` is `0`, `tokenType` is `null`, `expired` is `false`, and `refreshToken` is `null`. No test verifies that consumers handle this state: a null `value` passed to `WebData.getAuthHeader()` produces the string `"Bearer null"` (via string concatenation), which is sent as an Authorization header to the server — a silent authentication failure that could be hard to diagnose.

The JSON constructor `GetTokenResult(JSONObject)` (lines 23–55) is the critical parsing path invoked by both `WebApi` (on login) and `TokenAuthenticator` (via `Gson.fromJson`). No test exercises:
- Normal happy-path parsing where all five fields are present and correctly typed.
- Null-input: `jsonObject == null` — the outer null guard (line 27) causes all fields to remain at default values without throwing an exception. No test verifies a caller handles a completely empty `GetTokenResult`.
- Missing `"refreshToken"` key: `refreshToken` remains `null`. Callers that access `refreshToken.value` will throw `NullPointerException`. No test verifies this.
- Type mismatch on `"expiration"` or `"expired"` fields: `JSONException` propagates to the caller uncaught.
- A `refreshToken` JSON object present but internally malformed: the nested `new RefreshTokenItem(jsonObject.getJSONObject("refreshToken"))` call at line 52 can throw `JSONException`.

**ID:** A37-10
**Severity:** MEDIUM
**File:** `GetTokenResult.java`
**Lines:** 50–53

**Finding: Nested RefreshTokenItem construction has no error isolation. No test covers malformed refresh token data.**

The construction of the embedded `RefreshTokenItem` at lines 50–53 is performed inline within the `GetTokenResult` JSON constructor. If the `"refreshToken"` object is present in the JSON but its contents are malformed (wrong types for `"value"` or `"expiration"`), a `JSONException` is thrown from inside `RefreshTokenItem`'s constructor and propagates through `GetTokenResult`'s constructor to the caller.

There is no try-catch block isolating the refresh token sub-parse from the access token parse. A malformed refresh token field will therefore cause the entire `GetTokenResult` to fail to construct — the access token (`value`, `expiration`, `tokenType`, `expired`) will not be available even if those fields were valid. No test verifies this partial-failure path, and no test confirms the app degrades gracefully (re-prompts login) versus crashing.

**ID:** A37-11
**Severity:** INFO
**File:** `GetTokenResult.java`
**Lines:** 14–18

**Finding: Public mutable fields on a security-sensitive DTO allow post-construction mutation without detection.**

All five fields of `GetTokenResult` are `public` non-final. The same is true of `RefreshTokenItem.value` and `RefreshTokenItem.expiration`. Any code with a reference to a `GetTokenResult` instance can overwrite the bearer token value, modify the expiry, or null out the refresh token without detection. A test-isolation concern: if a test modifies a `GetTokenResult` in place to simulate an expired state, it affects any other code holding the same reference.

No tests exist to exercise or document the expected immutability contract of this DTO. The recommendation (for a future test suite) is to verify that the parsing constructors produce objects whose fields match the JSON input exactly and that no code path mutates token fields outside of `WebData.setGetTokenResult()`.

---

## Summary Table

| ID | Severity | File | Lines | Description |
|---|---|---|---|---|
| A37-1 | HIGH | Project-wide | — | Zero automated test coverage in `app/` and `LibCommon/` modules |
| A37-2 | LOW | GetEmailResult.java | 21, 24–61 | Both constructors untested; null/default field behavior unverified |
| A37-3 | MEDIUM | GetEmailResult.java | 24–61 | JSONException on type-mismatch not exercised; caller error handling untested |
| A37-4 | LOW | GetEquipmentResultArray.java | 16, 19–30 | Both constructors untested; null arrayList from no-arg path can cause NPE |
| A37-5 | MEDIUM | GetEquipmentResultArray.java | 25–28 | Single malformed array element aborts entire construction; no partial-failure test |
| A37-6 | CRITICAL | GetTokenResult.java | 14, 18 | Bearer and refresh tokens not cleared on logout; no test for this lifecycle |
| A37-7 | CRITICAL | GetTokenResult.java | 14–18 | Tokens stored as plaintext in SharedPreferences; no secure storage test |
| A37-8 | CRITICAL | GetTokenResult.java | 15, 17 | Parsed expiry fields (`expiration`, `expired`) never evaluated; no expiry test |
| A37-9 | HIGH | GetTokenResult.java | 20, 23–55 | Both constructors untested; null-value produces "Bearer null" header silently |
| A37-10 | MEDIUM | GetTokenResult.java | 50–53 | Malformed nested refresh token aborts full construction; no isolation or test |
| A37-11 | INFO | GetTokenResult.java | 14–18 | Public mutable fields on security DTO; no immutability contract tested |
