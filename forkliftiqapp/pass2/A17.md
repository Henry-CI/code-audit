# Audit Pass 2 — Agent A17
## Test Coverage: HttpClient, ImagePostBackgroundTask, ImagePostRequest

**Audit run:** 2026-02-26-01
**Branch:** master
**Agent:** A17
**Files assigned:**
1. `app/src/main/java/au/com/collectiveintelligence/fleetiq360/WebService/HttpClient.java`
2. `app/src/main/java/au/com/collectiveintelligence/fleetiq360/WebService/ImagePostBackgroundTask.java`
3. `app/src/main/java/au/com/collectiveintelligence/fleetiq360/WebService/ImagePostRequest.java`

---

## PROJECT-WIDE FINDING — CRITICAL: No Automated Test Coverage Exists

**Finding ID:** A17-0
**Severity:** HIGH
**Scope:** Project-wide (`app/` and `LibCommon/` modules)

Neither the `app/` module nor the `LibCommon/` module contains a `test/` or `androidTest/` source directory. Glob searches for `**/test/**/*.java` and `**/androidTest/**/*.java` returned zero results. There are no JUnit, Espresso, Robolectric, or Mockito test files anywhere in the repository.

This means:
- Every finding below describing an "untested" method is absolute — there is no indirect or integration test coverage anywhere in the codebase to fall back on.
- Security-critical paths (SSL bypass, HTTP multipart uploads, authentication token handling) have never been exercised by an automated test.
- Regressions in any part of the networking stack cannot be detected without manual testing.

All file-specific findings below are stated against the backdrop that **zero test coverage exists at any level**.

---

## File 1: HttpClient.java

### Reading Evidence

**Fully qualified class name:** `au.com.collectiveintelligence.fleetiq360.WebService.HttpClient`

**Constants defined:**
| Name | Type | Value | Line |
|------|------|-------|------|
| `DEFAULT_TIMEOUT_MS` | `public static final int` | 30000 | 42 |
| `LOGIN_TIMEOUT_MS` | `public static final int` | 60000 | 43 |
| `TAG` | `public static final String` | `"Volley"` | 62 |

**Fields defined:**
| Name | Type | Visibility | Line |
|------|------|-----------|------|
| `isSynchronous` | `boolean` | `public` | 40 |
| `mRequestQueue` | `RequestQueue` | `private static` | 48 |
| `mCurrentRequestDesc` | `String` | `private` | 52 |
| `mWebRequestQueue` | `ArrayDeque<Request>` | `private` | 54 |
| `mImageLoader` | `ImageLoader` | `private` | 58 |

**Methods defined:**
| Line | Visibility | Signature |
|------|-----------|-----------|
| 65 | `public` | `HttpClient(Context context)` |
| 72 | `public static` | `initRequestQueue(Context pContext): void` |
| 79 | `public` | `getRequestQueue(): RequestQueue` |
| 92 | `public static` | `setCommonData(JSONObject jsonObject): void` |
| 104 | `public static` | `jsonFromWebParam(Object object): JSONObject` |
| 110 | `private` | `sendRequest(WebRequest request): void` |
| 120 | `private` | `addRequest(WebRequest request): void` |
| 131 | `private` | `sendRequest(GsonRequest request): void` |
| 149 | `public` | `removeRequest(WebRequest request): void` |
| 154 | `public` | `enqueueRequest(GsonRequest webRequest): void` |
| 162 | `void` (package-private) | `syncSendRequest(final GsonRequest gsonRequest): void` |
| 225 | `private static` | `readStream(InputStream stream, int maxLength): String` |
| 248 | `protected` | `retryOnAuthFail(final WebRequest msg): void` |

**Types referenced:** `WebRequest`, `GsonRequest`, `RequestQueue`, `ImageLoader`, `FakeX509TrustManager`, `WebApi`, `WebListener`, `WebResult`, `GetTokenResult`, `WebData`, `GsonHelper`

---

### Findings — HttpClient.java

#### A17-1 — CRITICAL: `addRequest()` unconditionally installs a global SSL bypass with no test verifying the bypass is applied, removed, or constrained

**Severity:** CRITICAL
**Location:** `HttpClient.java`, line 122

`addRequest()` calls `FakeX509TrustManager.allowAllSSL()` on every single request, before the request is dispatched to Volley. `FakeX509TrustManager.allowAllSSL()` (reviewed as a supporting file) does two things:
1. Installs an anonymous `HostnameVerifier` on `HttpsURLConnection.setDefaultHostnameVerifier()` that returns `true` for every hostname with no validation.
2. Installs a custom `SSLSocketFactory` backed by an `X509TrustManager` whose `checkServerTrusted()` method is a no-op empty body — it trusts every certificate unconditionally.

Both of these are set as **JVM-global** defaults via static setters on `HttpsURLConnection`. Because there are no tests:
- There is no test confirming that the bypass is intentionally scoped (it is not — it is global).
- There is no test verifying that a man-in-the-middle presenting a self-signed or expired certificate is rejected (it is not).
- There is no test exercising what happens after `addRequest()` is called from the Volley path versus the `syncSendRequest()` path, which opens a plain `HttpURLConnection` and does not itself call `allowAllSSL()`.
- There is no regression test that would detect if `addRequest()` were refactored to remove the call, which is the desired fix direction.

The SSL bypass is an active, unconditional security vulnerability. The absence of tests means neither the bypass nor any hypothetical future fix can be verified to work correctly.

---

#### A17-2 — CRITICAL: `syncSendRequest()` opens an `HttpURLConnection` without calling `allowAllSSL()` — inconsistent TLS behavior with no test exposing the divergence

**Severity:** CRITICAL
**Location:** `HttpClient.java`, lines 162–219

`syncSendRequest()` is called from `enqueueRequest()` (line 155) when `isSynchronous == true`. It manually opens an `HttpURLConnection` at line 171 and configures headers, but it never calls `FakeX509TrustManager.allowAllSSL()` or sets any SSL configuration. The JVM-global state set by a prior `addRequest()` call may or may not be in effect depending on call ordering. This creates two separate problems:

1. **If `addRequest()` has been called first:** the global bypass is in place and `syncSendRequest()` silently inherits it — an unintentional trust dependency.
2. **If `syncSendRequest()` is called before any `addRequest()` call (e.g., on first launch when `isSynchronous` is set):** the default JVM SSL context applies, producing a behavioral difference between sync and async request paths that could cause connection failures to HTTPS endpoints on self-signed servers, or — if the server uses a valid certificate — silently enforce real TLS only on sync requests.

No test exercises `isSynchronous = true`, no test exercises the ordering of sync vs async calls, and no test checks which SSL policy is active during a synchronous request.

---

#### A17-3 — HIGH: `syncSendRequest()` silently swallows all exceptions — no test for network failure path

**Severity:** HIGH
**Location:** `HttpClient.java`, lines 214–217

The outer `catch (Exception ex)` block at line 214 calls only `ex.printStackTrace()`. After the catch, execution falls through to line 218: `gsonRequest.deliverResult(serverResponseCode, response)`. At this point `serverResponseCode` is still `0` (its initial value) and `response` is still `null`. The caller receives a result of `(0, null)` which is indistinguishable from a successful HTTP response with no body at status 0.

Concretely, the following failure cases all produce an identical `(0, null)` delivery with no distinguishing signal:
- DNS resolution failure (`UnknownHostException`)
- Connection timeout (`SocketTimeoutException`)
- SSL handshake failure (`SSLHandshakeException`)
- `MalformedURLException` on a bad URL
- `IOException` writing the request body

No test exists for any of these paths.

---

#### A17-4 — HIGH: `readStream()` has a logic error in the terminal condition — no test verifying correct stream reading

**Severity:** HIGH
**Location:** `HttpClient.java`, lines 225–246

At line 238, the method checks `if (numChars != -1)` before using the buffer. However, `numChars` is an accumulator that starts at `0` and is incremented by `readSize` on each iteration. It is impossible for `numChars` to be `-1` at that point — `numChars` can only be 0 or positive. The intended check is almost certainly `if (numChars != 0)` to guard against an empty stream returning a zero-length string. The current code will return an empty `String("")` rather than `null` when the input stream contains zero bytes, which is a different semantic from what the null-initialized `result` variable implies.

Additionally, the method is declared as `private static` and takes a `maxLength` parameter. The only call site (line 211) passes `1024*1024` (1 MB). An HTTP response body larger than 1 MB is silently truncated without any notification to the caller, and there is no test for:
- An empty stream (zero bytes)
- A stream of exactly `maxLength` bytes
- A stream exceeding `maxLength` bytes (truncation case)
- A stream returning `-1` on the first `read()` call

---

#### A17-5 — HIGH: `initRequestQueue()` is not idempotent from a concurrency standpoint — no test for race condition

**Severity:** HIGH
**Location:** `HttpClient.java`, lines 72–77

`initRequestQueue()` is `public static` and checks `if (mRequestQueue == null)` before initializing. This check-then-act sequence is not synchronized. If two threads call `initRequestQueue()` concurrently (e.g., during app startup with multiple components initializing), both can observe `mRequestQueue == null` and create separate `RequestQueue` instances. The second write wins, discarding the first queue and any requests already enqueued into it. There is no test for concurrent initialization.

---

#### A17-6 — MEDIUM: `setCommonData()` is a dead stub — no test, no behavior

**Severity:** MEDIUM
**Location:** `HttpClient.java`, lines 92–102

`setCommonData()` has a non-null guard around `jsonObject` (line 95) but the body of the `if` block is empty. The method does nothing. It is called by `jsonFromWebParam()` (line 106), which is presumably called when preparing request payloads. There is no test confirming the method is intentionally empty rather than accidentally gutted. The empty `catch (Exception e)` at line 100 also silently swallows any exception that could be thrown inside the empty `if` block in the future.

---

#### A17-7 — MEDIUM: `getRequestQueue()` throws `IllegalStateException` when queue is uninitialized — no test for this guard

**Severity:** MEDIUM
**Location:** `HttpClient.java`, lines 79–90

`getRequestQueue()` throws `IllegalStateException` if `mRequestQueue` is null. This can be reached if `addRequest()` or `sendRequest()` is called before the constructor has run (since `mRequestQueue` is `static` and `initRequestQueue()` checks for null but is never guaranteed to have been called). No test exercises the throw path.

---

#### A17-8 — MEDIUM: `retryOnAuthFail()` re-enqueues via `sendRequest(msg.update())` — no test for the retry loop or infinite retry scenario

**Severity:** MEDIUM
**Location:** `HttpClient.java`, lines 248–262

`retryOnAuthFail()` attempts a token refresh via `WebApi.async().authApp(...)` and on success calls `sendRequest(msg.update())`. There is no test verifying:
- That `msg.update()` returns a valid updated request rather than null
- That if the re-sent request also fails auth, `retryOnAuthFail()` is called again — potentially causing an unbounded retry loop
- That the `onFailed` callback correctly terminates the retry cycle

---

#### A17-9 — LOW: `mImageLoader` field is declared and never initialized or used — dead code

**Severity:** LOW
**Location:** `HttpClient.java`, line 58

The `mImageLoader` field of type `ImageLoader` is declared but never assigned and never referenced in any method. No test covers its initialization or usage.

---

#### A17-10 — LOW: `mCurrentRequestDesc` field is declared and never used — dead code

**Severity:** LOW
**Location:** `HttpClient.java`, line 52

The `mCurrentRequestDesc` field is declared with a descriptive comment ("The description of the current request, passed back to the triggering activity") but is never read or written in any method. No test touches this field.

---

#### A17-11 — LOW: `sendRequest(WebRequest)` pushes to `mWebRequestQueue` after calling `addRequest()` — order inconsistency, no test

**Severity:** LOW
**Location:** `HttpClient.java`, lines 110–118

`sendRequest(WebRequest)` calls `addRequest(request)` at line 114 (which dispatches to Volley), then pushes to `mWebRequestQueue` at line 116. The queue push happens after dispatch. The overload `sendRequest(GsonRequest)` does the same but in the opposite comment order. Because `removeRequest()` operates on `mWebRequestQueue`, there is a window between dispatch and push where the request cannot be cancelled. No test verifies either the order or the cancellation correctness.

---

#### A17-12 — INFO: Retry policy comment in `sendRequest(GsonRequest)` states the timeout is not working

**Severity:** INFO
**Location:** `HttpClient.java`, lines 132–138

The comment at line 133 explicitly reads "This timeout is not working." The `DefaultRetryPolicy` is set with `LOGIN_TIMEOUT_MS` (60 seconds), `0` retries, and the default backoff multiplier. No test exists that would confirm or deny whether the timeout fires correctly or whether the workaround referred to in `WebRequest` is sufficient.

---

## File 2: ImagePostBackgroundTask.java

### Reading Evidence

**Fully qualified class name:** `au.com.collectiveintelligence.fleetiq360.WebService.ImagePostBackgroundTask`

**Extends:** `AsyncTask<ImagePostBackgroundTask.ImageUploadParam, String, ImagePostBackgroundTask.ImageUploadResult>`

**Inner classes / static nested classes:**
| Name | Kind | Line | Fields |
|------|------|------|--------|
| `ImageUploadParam` | `public static class` | 21 | `url: String`, `imagePath: String`, `multiPathArray: ArrayList<String>`, `fileNames: ArrayList<String>`, `bitmap: Bitmap`, `callback: ImageUploadCallBack` |
| `ImageUploadResult` | `public static class` | 30 | `imageParam: ImageUploadParam`, `succeed: boolean` |
| `ImageUploadCallBack` | `public static class` | 35 | (method: `onUploadResult(ImageUploadResult): void`) |

**Fields defined:**
| Name | Type | Visibility | Line |
|------|------|-----------|------|
| `imageUploadParam` | `ImageUploadParam` | package-private | 18 |

**Methods defined:**
| Line | Visibility | Signature |
|------|-----------|-----------|
| 42 | `protected` (override) | `doInBackground(ImageUploadParam... params): ImageUploadResult` |
| 65 | `protected` (override) | `onPostExecute(ImageUploadResult result): void` |
| 72 | `private static` | `uploadImage(ImageUploadParam param): void` |
| 77 | `public static` | `uploadImage(String url, ArrayList<String> pathArray, ArrayList<String> fileNames, ImageUploadCallBack callback): void` |
| 97 | `public static` | `uploadImage(String url, String path, ImageUploadCallBack callback): void` |
| 114 | `public static` | `uploadImage(String url, Bitmap bitmap, ImageUploadCallBack callback): void` |
| 131 | `static` (package-private) | `readFileData(String imagePath): byte[]` |

---

### Findings — ImagePostBackgroundTask.java

#### A17-13 — HIGH: `doInBackground()` does not handle the case where all three image source fields are null — silently returns `succeed = false` with no diagnostic

**Severity:** HIGH
**Location:** `ImagePostBackgroundTask.java`, lines 42–62

The decision tree at lines 47–56 checks `imagePath`, then `bitmap`, then `multiPathArray`. If all three are null (a caller constructs an `ImageUploadParam` and forgets to set any image source), the method falls through all branches, `result` stays `false`, and `ImageUploadResult.succeed = false` is returned. The caller's `onUploadResult` callback receives a failure result that is indistinguishable from a genuine network failure. No test covers this case.

---

#### A17-14 — HIGH: `doInBackground()` accesses `params[0]` without bounds check — `ArrayIndexOutOfBoundsException` if called with zero params

**Severity:** HIGH
**Location:** `ImagePostBackgroundTask.java`, line 44

`AsyncTask.execute()` accepts a varargs `params` array. If `execute()` is called with no arguments, `params` is an empty array and `params[0]` throws `ArrayIndexOutOfBoundsException` on the background thread. `AsyncTask` will swallow this exception silently (in API < 11 behavior) or leave the task in a failed state. The private `uploadImage(ImageUploadParam)` helper always provides exactly one param, but no test guards against misuse of the public API.

---

#### A17-15 — HIGH: `readFileData()` does not handle a null bitmap from `BitmapFactory.decodeFile()` — NullPointerException propagated to caller

**Severity:** HIGH
**Location:** `ImagePostBackgroundTask.java`, lines 131–138

`BitmapFactory.decodeFile()` returns `null` when the file does not exist, is not a valid image, or cannot be read due to permissions. `readFileData()` passes the return value directly to `Util.preProcessBitmap(bitmap, ...)` without a null check. If `Util.preProcessBitmap()` does not guard against a null `Bitmap`, this will produce an unhandled `NullPointerException`. Note that `ImagePostRequest.SendHttpImage(String, String)` does perform a null check on the bitmap before delegating (line 26–28 of that file), but `readFileData()` itself does not, making it unsafe for any direct caller. No test covers a missing or corrupt image file path.

---

#### A17-16 — MEDIUM: `onPostExecute()` does not guard against `result.imageParam` being null — NullPointerException risk

**Severity:** MEDIUM
**Location:** `ImagePostBackgroundTask.java`, lines 65–69

`onPostExecute()` accesses `result.imageParam.callback` without checking whether `result.imageParam` is null. While the only code path that constructs `ImageUploadResult` (lines 58–61) always assigns `imageUploadParam` to `imageParam`, a future refactor that creates an `ImageUploadResult` independently could produce a null `imageParam`. No test covers `onPostExecute()` with a null `imageParam`.

---

#### A17-17 — MEDIUM: No test for `uploadImage(String, ArrayList, ArrayList, ImageUploadCallBack)` with mismatched `pathArray` and `fileNames` list sizes

**Severity:** MEDIUM
**Location:** `ImagePostBackgroundTask.java`, lines 77–95

The multipart upload overload packages `pathArray` and `fileNames` into `ImageUploadParam` and passes them to `ImagePostRequest.SendMultipartHttpImage()`. That method (see File 3) iterates `filePaths.size()` times and calls `fileNames.get(i)` — if `fileNames` is shorter than `filePaths`, an `IndexOutOfBoundsException` is thrown on the background thread. No test verifies equal-length lists or exercises the mismatch case.

---

#### A17-18 — MEDIUM: `uploadImage(String, String, ImageUploadCallBack)` passes a null or empty path directly to `ImagePostRequest.SendHttpImage()` with no pre-validation

**Severity:** MEDIUM
**Location:** `ImagePostBackgroundTask.java`, lines 97–112

The path-based `uploadImage()` overload stores `path` directly into `param.imagePath`. `doInBackground()` checks `imagePath != null && imagePath.length() > 0` before delegating to `SendHttpImage(url, imagePath)`. This means a caller passing a non-empty but invalid path (e.g., a path to a directory, a permissions-denied file, or a path with embedded null characters) will cause `BitmapFactory.decodeFile()` to return null, which is handled in `SendHttpImage(String, String)` by returning `false` — but no test verifies this silent failure path.

---

#### A17-19 — LOW: `ImageUploadCallBack.onUploadResult()` is a non-abstract method with an empty body — subclasses can forget to override it

**Severity:** LOW
**Location:** `ImagePostBackgroundTask.java`, lines 36–38

`ImageUploadCallBack` is a concrete class (not an interface or abstract class) with an empty `onUploadResult()` body. A caller that instantiates `ImageUploadCallBack()` directly rather than subclassing will receive upload results silently discarded. No test verifies that a caller-provided callback actually fires.

---

## File 3: ImagePostRequest.java

### Reading Evidence

**Fully qualified class name:** `au.com.collectiveintelligence.fleetiq360.WebService.ImagePostRequest`

**Constants defined (local variables used as effectively constant):**

In `SendHttpImage(String, byte[])`:
| Name | Type | Value | Line |
|------|------|-------|------|
| `lineEnd` | `String` | `"\r\n"` | 35 |
| `twoHyphens` | `String` | `"--"` | 36 |
| `boundary` | `String` | `"*****"` | 37 |
| `POST_FIELD` | `String` | `"file"` | 38 |
| `fileName` | `String` | `"image.jpg"` | 39 |

In `SendMultipartHttpImage()`:
| Name | Value | Line |
|------|-------|------|
| `boundary` | `"B0EC8D07-EBF1-4EA7-966C-E492A9F2C36E"` | 122 |

**Methods defined:**
| Line | Visibility | Signature |
|------|-----------|-----------|
| 24 | `public static` | `SendHttpImage(String urlServer, String pathToOurFile): boolean` |
| 32 | `public static` | `SendHttpImage(String urlServer, byte[] imageByte): boolean` |
| 100 | `public static` | `SendHttpImage(String urlServer, Bitmap bitmap): boolean` |
| 107 | `static` (package-private) | `isMultiPart(String urlServer): boolean` |
| 117 | `public static` | `SendMultipartHttpImage(String urlServer, ArrayList<String> filePaths, ArrayList<String> fileNames): boolean` |

**Imported but unused symbol:** `android.R.attr.src` (line 15, `import static`) — this is dead import.

---

### Findings — ImagePostRequest.java

#### A17-20 — CRITICAL: `SendHttpImage(String, byte[])` opens a plain `HttpURLConnection` (not `HttpsURLConnection`) — does not apply the global SSL bypass set by `HttpClient.addRequest()`, yet has no TLS validation of its own

**Severity:** CRITICAL
**Location:** `ImagePostRequest.java`, lines 44–46

`new URL(urlServer).openConnection()` returns an `HttpURLConnection` for `http://` URLs and an `HttpsURLConnection` for `https://` URLs. The global SSL bypass installed by `FakeX509TrustManager.allowAllSSL()` applies to `HttpsURLConnection` defaults, so HTTPS image uploads inherit the bypass. HTTP image uploads have no transport security at all. There is no test that:
- Verifies the correct protocol is selected for a given URL
- Verifies the SSL bypass applies to HTTPS image uploads
- Verifies HTTP uploads are rejected or warned against

This means user images (including driver access photos and impact images) may be transmitted over unencrypted HTTP with no test detecting this.

---

#### A17-21 — CRITICAL: `SendMultipartHttpImage()` silently swallows all exceptions with an empty `catch` block — failure is indistinguishable from HTTP 0

**Severity:** CRITICAL
**Location:** `ImagePostRequest.java`, lines 169–172

The `catch (Exception ex)` block at line 169 is completely empty — not even a `printStackTrace()` call. After the catch, `serverResponseCode` remains `0` and the method returns `false`. Every possible failure — DNS failure, timeout, SSL error, `OutOfMemoryError` from a large bitmap, `IndexOutOfBoundsException` from mismatched `filePaths`/`fileNames` lists — is silently discarded. There is no test that verifies failure diagnostics, and no way for an operator to distinguish between "upload failed because of a network error" and "upload failed because of a code bug."

---

#### A17-22 — HIGH: `SendHttpImage(String, byte[])` calls `connection.connect()` after `connection.getOutputStream()` and after writing the body — `connect()` is redundant and ordering is semantically wrong

**Severity:** HIGH
**Location:** `ImagePostRequest.java`, lines 61, 83–85

`connection.getOutputStream()` implicitly establishes the connection. Calling `connection.connect()` after the stream has already been written (line 84, after `outputStream.close()` at line 83) is at best a no-op and at worst implementation-defined behavior on some Android versions. The same pattern appears in `SendMultipartHttpImage()` (lines 165–167). No test exists to verify that data is actually transmitted to the server, or that calling `connect()` post-write does not cause request body truncation or duplication on specific Android API levels.

---

#### A17-23 — HIGH: `SendHttpImage(String, String)` — no test for null or invalid `urlServer` parameter

**Severity:** HIGH
**Location:** `ImagePostRequest.java`, lines 24–31`

`SendHttpImage(String, String)` returns `false` if `bitmap == null` (line 26–28) but passes `urlServer` directly to `SendHttpImage(urlServer, bitmap)` without any validation. If `urlServer` is null, `new URL(null)` at line 44 throws `MalformedURLException`, which is caught and silently swallowed (the response-code-0 path). If `urlServer` is a non-HTTP scheme (e.g., `"ftp://..."`), the same silent failure applies. No test covers null URL, empty URL, or invalid scheme.

---

#### A17-24 — HIGH: `isMultiPart()` uses substring matching on URL strings — brittle and untested for edge cases

**Severity:** HIGH
**Location:** `ImagePostRequest.java`, lines 107–115

`isMultiPart()` determines the upload format by checking whether the URL string contains `"driveraccess"`, `"appuser/photo"`, or `"impactimage"`. This approach:
- Will silently select the wrong encoding if the server changes URL structure
- Matches fragment or query-string portions of a URL, not just the path
- A URL such as `"http://example.com/other?ref=impactimage"` would be misclassified as multipart
- A URL containing these strings in the hostname would also match

No test covers any of these cases. There is no test that a known production URL correctly resolves to multipart or non-multipart, nor a test that an adversarial URL does not trigger misclassification.

---

#### A17-25 — HIGH: `SendMultipartHttpImage()` calls `BitmapFactory.decodeFile()` inside a loop with no null check — crash on corrupt or missing file

**Severity:** HIGH
**Location:** `ImagePostRequest.java`, lines 157–160

Inside the `for` loop, `BitmapFactory.decodeFile(filePaths.get(i))` is called and the result passed directly to `Util.preProcessBitmap(bitmap, byteArrayOutputStream)`. If any file in the `filePaths` list is missing, unreadable, or not a valid image, `decodeFile()` returns `null`. If `Util.preProcessBitmap()` dereferences the bitmap without a null check, a `NullPointerException` is thrown. This exception is then caught by the outer `catch (Exception ex)` block (line 169) and silently discarded, causing the entire multipart upload — including any successfully encoded images already written to the stream — to fail silently. No test exists for a partially invalid file list.

---

#### A17-26 — HIGH: No test for oversized image payload causing `OutOfMemoryError` in bitmap encoding path

**Severity:** HIGH
**Location:** `ImagePostRequest.java`, lines 100–105 and lines 157–160

Both the bitmap and the multipart code paths call `Util.preProcessBitmap()` and accumulate the result in a `ByteArrayOutputStream`. Very large images (e.g., a 12+ megapixel camera photo) can produce in-memory byte arrays of 30+ MB. With multiple images in a multipart upload, the combined in-memory representation can exhaust the Android heap. `OutOfMemoryError` is not caught by `catch (Exception ex)` in `SendMultipartHttpImage()` (which only catches `Exception`, not `Error`). No test exists for large images, and no size limit or pre-check is implemented.

---

#### A17-27 — MEDIUM: `SendHttpImage(String, byte[])` uses a hardcoded `boundary = "*****"` — collision risk with binary image data

**Severity:** MEDIUM
**Location:** `ImagePostRequest.java`, lines 37, 66–81

The multipart boundary `"*****"` is a five-character string that is far more likely to appear as a byte sequence in a JPEG file than a proper random UUID boundary. If the JPEG byte data contains the sequence `--*****` (40 2D 2D 2A 2A 2A 2A 2A), the server-side multipart parser will misinterpret the part boundary and either reject the upload or silently truncate the image. `SendMultipartHttpImage()` correctly uses a UUID-format boundary (line 122). The inconsistency between the two methods is untested. No test verifies that the encoded multipart body is parseable by an RFC 2046-compliant parser.

---

#### A17-28 — MEDIUM: `SendHttpImage(String, byte[])` does not close the `HttpURLConnection` in a `finally` block — connection leak on exception

**Severity:** MEDIUM
**Location:** `ImagePostRequest.java`, lines 33–97

The `connection` variable is declared at line 33 and opened at line 46. There is no `finally` block that calls `connection.disconnect()`. If an exception is thrown after the connection is opened (e.g., during stream writing), the connection is never released. On Android, this can exhaust the connection pool. `SendMultipartHttpImage()` has the same defect (lines 118–178). No test verifies connection cleanup on failure paths.

---

#### A17-29 — MEDIUM: `SendHttpImage(String, byte[])` does not set a connection or read timeout — hangs indefinitely on unresponsive server

**Severity:** MEDIUM
**Location:** `ImagePostRequest.java`, lines 44–85

No `setConnectTimeout()` or `setReadTimeout()` is called on the `HttpURLConnection`. By contrast, `SendMultipartHttpImage()` sets `connection.setConnectTimeout(10*1000)` at line 134 but does not set a read timeout. The single-image upload path has no timeouts at all. A hung connection will block the `AsyncTask` worker thread indefinitely with no error delivered to the caller. No test verifies timeout behavior.

---

#### A17-30 — LOW: Dead `import static android.R.attr.src` in `ImagePostRequest.java`

**Severity:** LOW
**Location:** `ImagePostRequest.java`, line 15

The static import `android.R.attr.src` is present but the symbol `src` is never referenced anywhere in the file. This is dead code left from development. While the compiler accepts it, it adds noise to the import section and no test would catch its presence or removal.

---

#### A17-31 — LOW: `isMultiPart()` is package-private but has no test — intended for package-internal use only but logic is not validated

**Severity:** LOW
**Location:** `ImagePostRequest.java`, lines 107–115

`isMultiPart()` has package-private visibility (no access modifier), suggesting it was intended to be testable at the package level. The logic is non-trivial (three distinct URL substring checks) and is called in three places. Despite its testability, no test exercises the method with any of the three trigger strings, with none of them, or with adversarial inputs.

---

## Summary Table

| ID | File | Severity | Description |
|----|------|----------|-------------|
| A17-0 | Project-wide | HIGH | Zero automated test coverage in `app/` and `LibCommon/` modules |
| A17-1 | HttpClient.java | CRITICAL | `addRequest()` unconditionally installs global SSL bypass; no test verifying bypass or its scope |
| A17-2 | HttpClient.java | CRITICAL | `syncSendRequest()` opens `HttpURLConnection` without calling `allowAllSSL()`; inconsistent TLS state, no test |
| A17-3 | HttpClient.java | HIGH | `syncSendRequest()` swallows all exceptions; `(0, null)` result indistinguishable from success; no test for network failures |
| A17-4 | HttpClient.java | HIGH | `readStream()` terminal condition bug (`!= -1` instead of `!= 0`); no test for empty, exact, or oversized streams |
| A17-5 | HttpClient.java | HIGH | `initRequestQueue()` has unsynchronized check-then-act; concurrent initialization race; no test |
| A17-6 | HttpClient.java | MEDIUM | `setCommonData()` is a dead stub with empty body; no test confirming intentional no-op |
| A17-7 | HttpClient.java | MEDIUM | `getRequestQueue()` throws `IllegalStateException`; no test exercising the uninitialized guard |
| A17-8 | HttpClient.java | MEDIUM | `retryOnAuthFail()` could produce unbounded retry loop; no test for retry logic |
| A17-9 | HttpClient.java | LOW | `mImageLoader` field declared but never used |
| A17-10 | HttpClient.java | LOW | `mCurrentRequestDesc` field declared but never used |
| A17-11 | HttpClient.java | LOW | `sendRequest(WebRequest)` pushes to queue after dispatch; cancellation window; no test |
| A17-12 | HttpClient.java | INFO | Comment states retry timeout "is not working"; no test to confirm or deny |
| A17-13 | ImagePostBackgroundTask.java | HIGH | `doInBackground()` silently returns failure when all image source fields are null |
| A17-14 | ImagePostBackgroundTask.java | HIGH | `doInBackground()` accesses `params[0]` without bounds check; `ArrayIndexOutOfBoundsException` if zero params |
| A17-15 | ImagePostBackgroundTask.java | HIGH | `readFileData()` passes `BitmapFactory.decodeFile()` result to `Util.preProcessBitmap()` without null check |
| A17-16 | ImagePostBackgroundTask.java | MEDIUM | `onPostExecute()` does not guard `result.imageParam` against null |
| A17-17 | ImagePostBackgroundTask.java | MEDIUM | No test for mismatched `pathArray` / `fileNames` list sizes in multipart upload |
| A17-18 | ImagePostBackgroundTask.java | MEDIUM | Path-based `uploadImage()` passes non-empty invalid paths through silently |
| A17-19 | ImagePostBackgroundTask.java | LOW | `ImageUploadCallBack` is a concrete class with empty body; silent discard if not overridden |
| A17-20 | ImagePostRequest.java | CRITICAL | Image uploads use plain `HttpURLConnection`; no test verifying TLS for HTTPS or rejecting HTTP |
| A17-21 | ImagePostRequest.java | CRITICAL | `SendMultipartHttpImage()` empty `catch` block swallows all exceptions silently |
| A17-22 | ImagePostRequest.java | HIGH | `connect()` called after body written and stream closed; semantically wrong ordering; no test |
| A17-23 | ImagePostRequest.java | HIGH | No test for null, empty, or non-HTTP scheme `urlServer` in `SendHttpImage(String, String)` |
| A17-24 | ImagePostRequest.java | HIGH | `isMultiPart()` uses substring matching; brittle against URL changes and adversarial inputs |
| A17-25 | ImagePostRequest.java | HIGH | `SendMultipartHttpImage()` loop calls `decodeFile()` without null check; crash on corrupt file silently swallowed |
| A17-26 | ImagePostRequest.java | HIGH | No test for oversized image; `ByteArrayOutputStream` accumulation can exhaust heap; `OutOfMemoryError` not caught |
| A17-27 | ImagePostRequest.java | MEDIUM | `SendHttpImage(String, byte[])` uses weak `"*****"` boundary; collision risk with JPEG byte data |
| A17-28 | ImagePostRequest.java | MEDIUM | `HttpURLConnection` not closed in `finally`; connection leak on exception path |
| A17-29 | ImagePostRequest.java | MEDIUM | `SendHttpImage(String, byte[])` has no `setConnectTimeout()` or `setReadTimeout()`; can hang indefinitely |
| A17-30 | ImagePostRequest.java | LOW | Dead `import static android.R.attr.src` |
| A17-31 | ImagePostRequest.java | LOW | `isMultiPart()` is package-private but has no tests validating its substring-matching logic |
