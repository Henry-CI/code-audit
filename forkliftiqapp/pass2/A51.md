# Audit Pass 2 — Agent A51
**Audit run:** 2026-02-26-01
**Agent:** A51
**Files assigned:**
1. `app/src/main/java/au/com/collectiveintelligence/fleetiq360/presenter/PreStartCheckListPresenter.java`
2. `app/src/main/java/au/com/collectiveintelligence/fleetiq360/presenter/SelectDriverPresenter.java`
3. `app/src/main/java/au/com/collectiveintelligence/fleetiq360/session/SessionTimeoutJobService.java`

---

## PROJECT-WIDE FINDING (HIGH)

### A51-1 [HIGH] — Zero automated test coverage across `app/` and `LibCommon/` modules

Both the `app/src/` and `LibCommon/src/` source trees contain only a `main/` subdirectory. No `test/` or `androidTest/` subdirectory exists in either module. Verified by directory listing: `app/src/` and `LibCommon/src/` each contain `main` only.

The only test files found in the entire repository belong to the third-party `LibImageloader` library module (`ImageSizeTest.java`, `BaseImageDownloaderTest.java`) — these are upstream library tests and provide no coverage of application code.

**Impact:** Every class, method, and code path in the application and common library is completely untested. There is no safety net for regressions, no verification of business logic, and no automated check of safety-critical workflows (pre-start checklist submission, session timeout enforcement, SSL handling). Any defect in these paths is detectable only at runtime in production.

**Scope:** All findings A51-2 through A51-15 below describe specific untested methods. They exist because of the root cause identified in A51-1.

---

## File 1 — `PreStartCheckListPresenter.java`

### Reading Evidence

**Fully qualified class name:** `au.com.collectiveintelligence.fleetiq360.presenter.PreStartCheckListPresenter`

**Fields / constants defined:**
| Name | Type | Line | Visibility |
|---|---|---|---|
| `ui` | `EquipmentPrestartFragment` | 23 | `private` |
| `mapAnswers` | `HashMap<Integer, AnswerItem>` | 25 | `public` |
| `serverDateFormatter` | `ServerDateFormatter` | 27 | `private` |

**Methods (with line numbers and signatures):**
| Line | Signature |
|---|---|
| 29 | `public PreStartCheckListPresenter(EquipmentPrestartFragment ui)` |
| 34 | `public void getPreStartCheckListInfo()` |
| 58 | `public void savePreStartCheckListAnswerResult(HashMap<Integer, AnswerItem> mapAnswers, String comments)` |

**Anonymous inner types:**
- `WebListener<PreStartQuestionResultArray>` at line 35 — `onSucceed()` (line 37), `onFailed()` (line 43)
- `WebListener<WebServiceResultPacket>` at line 68 — `onSucceed()` (line 70), `onFailed()` (line 83)
- Two `Runnable` implementations at lines 73 and 89/99

---

### Findings

#### A51-2 [HIGH] — `savePreStartCheckListAnswerResult()`: no test verifying that all questions are answered before submission is accepted

**Location:** `PreStartCheckListPresenter.java`, line 58

`savePreStartCheckListAnswerResult()` receives `mapAnswers` and immediately converts it to an `ArrayList` (line 59) without checking whether the map is empty or whether the number of entries matches the number of questions loaded. The caller (`EquipmentPrestartFragment.onMiddleButton()`, line 136–139 of `EquipmentPrestartFragment.java`) performs the count comparison `presenter.mapAnswers.size() != qustionItemArrayList.size()` before calling into the presenter — but this guard lives in the UI layer and is bypassed entirely if `savePreStartCheckListAnswerResult()` is called directly (e.g. from another code path, future refactoring, or a test).

No test exists to verify:
- That calling with an empty `mapAnswers` is rejected or handled safely before a network submission is made.
- That calling with a partial answer set (fewer entries than questions) is rejected.
- That the UI-layer guard and the presenter are consistent in their definition of "all questions answered."

In a safety-critical industrial setting (forklift pre-start inspection), submitting an incomplete or empty answer set to the server, followed by advancing the session to the `JobsFragment` on success (line 76–77), means a driver could begin operating a forklift without having answered all safety-inspection questions. This is a safety-critical logic gap.

**Severity rationale:** The business domain is industrial forklift operation. An incomplete pre-start checklist being accepted represents a direct safety risk.

---

#### A51-3 [HIGH] — `savePreStartCheckListAnswerResult()`: offline fallback path (`SessionDb.setSessionPreStartFinished`) accepts empty answer list

**Location:** `PreStartCheckListPresenter.java`, lines 84–95

When the network call fails and `SessionDb.hasOfflineData()` returns `true`, the code calls `SessionDb.setSessionPreStartFinished(parameter.session_id, parameter, true)` (line 85) and then proceeds to hide the progress dialog and call `ui.showNext()` (line 90–91), advancing the session regardless of whether `parameter.arrAnswers` contains any answers.

No test exists to verify:
- The offline path with an empty `mapAnswers`.
- That `setSessionPreStartFinished()` persists a meaningful answer set rather than an empty list when offline.
- That the session does not advance to the next screen when answers are absent and the network is unavailable.

The offline path has no validation that is not already absent from the online path (A51-2), and combines with it to ensure there is no code path under which an empty submission triggers an error.

---

#### A51-4 [MEDIUM] — `savePreStartCheckListAnswerResult()`: network failure with no offline data shows "save failed" but does not prevent session advancement for a brief window

**Location:** `PreStartCheckListPresenter.java`, lines 96–104

The `onFailed` branch when no offline data exists calls `ui.updateProgress("Prestart result save failed")` and then schedules `ui.hideProgress()` after 1000 ms. It does not call `ui.showNext()` in this branch. However, no test verifies that this branch genuinely blocks the session from progressing, nor that `hideProgress()` does not inadvertently trigger any downstream navigation. This is a medium-risk gap given the safety-critical context.

---

#### A51-5 [MEDIUM] — `getPreStartCheckListInfo()`: offline fallback path returns questions from the last cached unit, which may belong to a different unit

**Location:** `PreStartCheckListPresenter.java`, lines 43–51

When the network call fails, the code loads cached questions from `PreStartQuestionDb.getQuestionResultArray(WebData.instance().getSessionResult().unit_id)`. No test verifies:
- That the cached result returned actually corresponds to the current session's unit (i.e., that the unit_id lookup returns the correct dataset).
- The `null` result path (line 47): if `resultArray` is null, `ui.showToast("Get prestart info failed.")` is called — leaving the checklist empty with no retry mechanism and no navigation away. The driver is stuck on an empty screen with no guidance. No test covers this dead-end state.

---

#### A51-6 [LOW] — `mapAnswers` field is `public` with no accessor control

**Location:** `PreStartCheckListPresenter.java`, line 25

`mapAnswers` is declared `public`, allowing any code to mutate it directly outside the presenter. No test verifies that mutations to `mapAnswers` from outside the presenter do not corrupt internal state (e.g., adding an `AnswerItem` with a null `answer` field, adding duplicate keys). The `@SuppressLint("UseSparseArrays")` annotation acknowledges a lint warning but does not guard against external mutation.

---

#### A51-7 [LOW] — `savePreStartCheckListAnswerResult()`: `comments` parameter can be null, no null guard

**Location:** `PreStartCheckListPresenter.java`, line 58

The `comments` parameter is passed directly to `parameter.comment` (line 66) with no null check. `SavePreStartParameter.comment` is a `String` field. No test verifies behavior when `comments` is `null`. Depending on the server-side API contract, a `null` comment field serialised to JSON may differ from an empty-string comment and may cause server-side validation errors.

---

## File 2 — `SelectDriverPresenter.java`

### Reading Evidence

**Fully qualified class name:** `au.com.collectiveintelligence.fleetiq360.presenter.SelectDriverPresenter`

**Fields / constants defined:**
| Name | Type | Line | Visibility |
|---|---|---|---|
| `ui` | `DriverListFragment` | 15 | `public` |

**Methods (with line numbers and signatures):**
| Line | Signature |
|---|---|
| 17 | `public SelectDriverPresenter(DriverListFragment ui)` |
| 21 | `public void getCompanyDriversList()` |
| 25 | `public void showImage(String url, ImageView imageView)` |

---

### Findings

#### A51-8 [CRITICAL] — `showImage()` calls `SSLCertificateHandler.nuke()` unconditionally, disabling all TLS validation for the entire process

**Location:** `SelectDriverPresenter.java`, line 39

`showImage()` calls `UserPhotoFragment.SSLCertificateHandler.nuke()` on every invocation. `SSLCertificateHandler.nuke()` (defined in `UserPhotoFragment.java`, lines 41–69) installs a process-global `TrustManager` that:
- Returns an empty `X509Certificate[]` from `getAcceptedIssuers()` (accepts any certificate).
- Provides empty `checkClientTrusted()` and `checkServerTrusted()` implementations (performs no validation whatsoever).
- Installs a `HostnameVerifier` that always returns `true` (accepts any hostname).
- Sets these as the **default** `SSLSocketFactory` and `HostnameVerifier` via `HttpsURLConnection.setDefaultSSLSocketFactory()` and `HttpsURLConnection.setDefaultHostnameVerifier()`.

These are process-wide JVM-level defaults. Once `nuke()` is called, every subsequent HTTPS connection made anywhere in the process — including web-service calls to the ForkliftIQ backend, session start/stop/prestart submissions, and driver data retrieval — operates without TLS certificate validation. This renders all HTTPS connections vulnerable to man-in-the-middle attack for the remainder of the process lifetime.

No test exists to verify:
- That TLS validation is active before `showImage()` is called.
- That TLS validation is restored after `showImage()` completes.
- That calls to other network APIs following `showImage()` still use valid TLS.
- That `showImage()` with a null or empty URL does not still invoke `nuke()` (it does — there is no null guard on `url`).

**Severity rationale:** CRITICAL. The exploit requires only that `showImage()` be called once (which is normal application flow during driver selection). After that call, all subsequent network traffic in the process is unprotected against MITM. An attacker on the same network could intercept or tamper with session data, pre-start checklist answers, and authentication tokens. This affects safety-critical data integrity.

---

#### A51-9 [HIGH] — `showImage()` calls `nuke()` before every image load, not just once; TLS is re-nuked on every driver photo display

**Location:** `SelectDriverPresenter.java`, line 39

Even if `nuke()` were considered acceptable on first call (e.g., a deliberate decision to bypass TLS for image loading), calling it on every invocation of `showImage()` means TLS is repeatedly re-installed as disabled after any point where it might have been re-enabled. No test verifies the interaction between `showImage()` call frequency and the TLS state of other active connections.

---

#### A51-10 [HIGH] — `showImage()`: no null guard on `url` parameter; `nuke()` is called even for null/empty URLs

**Location:** `SelectDriverPresenter.java`, lines 25–41

If `url` is `null` or empty, `nuke()` is still called (line 39), then `ImageLoader.getInstance().displayImage(null, imageView, ...)` is called (line 40). `DisplayImageOptions.Builder` has `.showImageForEmptyUri(R.drawable.user_default)` set (line 27), which handles the empty URI display — but TLS has still been globally disabled unnecessarily. No test covers:
- Null URL input.
- Empty string URL input.
- The interaction between null URL and `nuke()` side-effects.

---

#### A51-11 [MEDIUM] — `showImage()`: no null guard on `imageView` parameter

**Location:** `SelectDriverPresenter.java`, lines 25–41

If `imageView` is `null`, `imageView.setImageBitmap(null)` at line 37 will throw a `NullPointerException`. `ImageLoader.getInstance().cancelDisplayTask(new ImageViewAware(imageView))` at line 35 wraps the view but may also fail or silently ignore the null. No test covers a null `imageView` argument.

---

#### A51-12 [MEDIUM] — `getCompanyDriversList()`: no test for null or empty driver list from `CurrentUser`

**Location:** `SelectDriverPresenter.java`, line 22

`getCompanyDriversList()` calls `ui.updateDriverList(CurrentUser.get().associatedDrivers())`. No test verifies:
- Behavior when `CurrentUser.get()` returns `null` (which would throw a `NullPointerException` at `.associatedDrivers()`).
- Behavior when `associatedDrivers()` returns an empty list.
- Behavior when `associatedDrivers()` returns `null`.

---

## File 3 — `SessionTimeoutJobService.java`

**Note:** The assigned file path in the audit brief listed this file under the `presenter/` package. The actual location is `session/SessionTimeoutJobService.java`. The correct absolute path is:
`/c/Projects/cig-audit/repos/forkliftiqapp/app/src/main/java/au/com/collectiveintelligence/fleetiq360/session/SessionTimeoutJobService.java`

### Reading Evidence

**Fully qualified class name:** `au.com.collectiveintelligence.fleetiq360.session.SessionTimeoutJobService`

**Superclass:** `android.app.job.JobService`

**Fields / constants defined:**
| Name | Type | Line | Visibility |
|---|---|---|---|
| `SESSION_TIMEOUT_JOB_SERVICE_ID` | `static final int` = 1 | 15 | `private static` |

**Methods (with line numbers and signatures):**
| Line | Signature |
|---|---|
| 18 | `public boolean onStartJob(JobParameters params)` |
| 32 | `public boolean onStopJob(JobParameters params)` |
| 36 | `static void schedule(Context context)` |
| 46 | `static void cancel(Context context)` |

---

### Findings

#### A51-13 [HIGH] — `onStartJob()`: no test for the path where `result.isFinished()` is `true` but `endSession()` fails silently

**Location:** `SessionTimeoutJobService.java`, lines 22–25

When `result.isFinished()` is `true`, `SessionTimeouter.getInstance().endSession()` is called. `endSession()` (in `SessionTimeouter.java`, lines 62–84) makes a network call to `WebApi.async().saveSessionEnd()`. If the network call fails, it logs an error but still calls `onSessionEnded()`, advancing the UI state. No test verifies that a failed `saveSessionEnd()` during a timeout-driven session end:
- Does not leave the session in an inconsistent state (server has not received the end, but the UI has moved past the session).
- Properly handles the offline case for session-end submissions initiated by timeout (distinct from user-initiated offline session end).

---

#### A51-14 [HIGH] — `onStartJob()`: returns `false` in all branches, silently abandoning the job if `endSession()` is asynchronous

**Location:** `SessionTimeoutJobService.java`, lines 18–29

`onStartJob()` returns `false` in all code paths (lines 21, 25, 28). Returning `false` from `onStartJob()` signals to the `JobScheduler` that the job has completed synchronously and the wakelock can be released. However, `SessionTimeouter.getInstance().endSession()` (line 23) is asynchronous — it fires a network request via `WebApi.async()`. Returning `false` immediately releases the wakelock before the async operation completes, which can cause the device to sleep before the session-end network call finishes, potentially dropping the request.

No test verifies:
- That `endSession()` completes successfully when `onStartJob()` returns `false`.
- That returning `false` (vs. `true` with a subsequent `jobFinished()` call) is the correct contract for this asynchronous operation.

---

#### A51-15 [HIGH] — `schedule()`: uses `Objects.requireNonNull(scheduler)` — throws NPE if JobScheduler service is unavailable

**Location:** `SessionTimeoutJobService.java`, line 43

`schedule()` guards against a null `context` (line 37) but then calls `Objects.requireNonNull(scheduler).schedule(info)` (line 43). If `context.getSystemService(JOB_SCHEDULER_SERVICE)` returns `null` (which can occur on some custom Android builds or in test environments), a `NullPointerException` is thrown with no catch and no error handling. The session timeout monitoring would then silently fail to start.

The same pattern exists in `cancel()` at line 49.

No test verifies:
- Behavior when `getSystemService(JOB_SCHEDULER_SERVICE)` returns `null`.
- That a null-scheduler condition produces a meaningful log or user-facing indication rather than a crash.

---

#### A51-16 [MEDIUM] — `onStopJob()` always returns `false`; job is never rescheduled after interruption

**Location:** `SessionTimeoutJobService.java`, lines 32–34

`onStopJob()` unconditionally returns `false`, instructing the `JobScheduler` not to reschedule the job if it is stopped prematurely (e.g., due to a constraint change or system resource pressure). Since session timeout monitoring is periodic and safety-relevant, a premature stop that is not rescheduled means the next timeout check may not occur for up to 60 seconds longer than intended (or at all, depending on why the job was stopped). No test verifies the effect of job interruption on timeout enforcement.

---

#### A51-17 [MEDIUM] — `onStartJob()`: `result.shouldShowWarning()` is called with no guard when `result` is known non-null but may have no `finish_time`

**Location:** `SessionTimeoutJobService.java`, line 27

After the `result == null` check (line 20) and the `result.isFinished()` check (line 22), line 27 calls `result.shouldShowWarning()`. No test verifies the behavior of `shouldShowWarning()` when the `SessionResult` has a null or unparseable `finish_time` field — a condition that `SessionDb.endSessions()` specifically guards against (checking `result.finish_time == null` before parsing). A `SessionResult` with a null `finish_time` may reach this code path in the job service.

---

#### A51-18 [LOW] — `schedule()` hardcodes a 60-second periodic interval with no configuration or test coverage

**Location:** `SessionTimeoutJobService.java`, line 40

`.setPeriodic(60000)` hardcodes a 60-second polling interval. On Android API 24+, the minimum enforced interval for periodic jobs is 15 minutes (900000 ms). The declared 60-second interval will be silently overridden to 15 minutes on devices running API 24 or higher, meaning session timeout warnings and forced session ends may arrive up to 15 minutes later than the code implies. No test verifies the effective scheduling interval on different API levels.

---

## Summary Table

| ID | Severity | File | Description |
|---|---|---|---|
| A51-1 | HIGH | Project-wide | Zero automated test coverage in `app/` and `LibCommon/` modules |
| A51-2 | HIGH | PreStartCheckListPresenter | No test verifying all questions answered before submission; empty map accepted |
| A51-3 | HIGH | PreStartCheckListPresenter | Offline fallback path accepts empty answer list and advances session |
| A51-4 | MEDIUM | PreStartCheckListPresenter | Network failure / no offline data branch not tested for navigation blocking |
| A51-5 | MEDIUM | PreStartCheckListPresenter | Offline question cache may return wrong unit's questions; null-result dead-end not tested |
| A51-6 | LOW | PreStartCheckListPresenter | `mapAnswers` is public; external mutation not guarded or tested |
| A51-7 | LOW | PreStartCheckListPresenter | Null `comments` parameter not guarded |
| A51-8 | CRITICAL | SelectDriverPresenter | `showImage()` calls `SSLCertificateHandler.nuke()` — disables TLS globally for process lifetime; no test |
| A51-9 | HIGH | SelectDriverPresenter | `nuke()` called on every image load; repeated disabling of TLS not tested |
| A51-10 | HIGH | SelectDriverPresenter | Null/empty URL still triggers `nuke()`; no null guard tested |
| A51-11 | MEDIUM | SelectDriverPresenter | Null `imageView` causes NPE; not tested |
| A51-12 | MEDIUM | SelectDriverPresenter | Null/empty driver list from `CurrentUser` not tested |
| A51-13 | HIGH | SessionTimeoutJobService | Failed `endSession()` on timeout leaves session in inconsistent state; not tested |
| A51-14 | HIGH | SessionTimeoutJobService | `onStartJob()` returns `false` despite async `endSession()` — wakelock released prematurely |
| A51-15 | HIGH | SessionTimeoutJobService | `Objects.requireNonNull(scheduler)` throws NPE if JobScheduler unavailable; untested |
| A51-16 | MEDIUM | SessionTimeoutJobService | `onStopJob()` returns `false` — interrupted jobs never rescheduled; not tested |
| A51-17 | MEDIUM | SessionTimeoutJobService | `shouldShowWarning()` not tested with null `finish_time` in session result |
| A51-18 | LOW | SessionTimeoutJobService | 60-second periodic interval silently overridden to 15 minutes on API 24+; not tested |
