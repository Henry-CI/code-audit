# Audit Pass 2 — Agent A69
**Audit run:** 2026-02-26-01
**Agent:** A69
**Files assigned:**
1. `app/src/main/java/au/com/collectiveintelligence/fleetiq360/user/UserDb.java`
2. `app/src/main/java/au/com/collectiveintelligence/fleetiq360/user/UserRealmObject.java`
3. `app/src/main/java/au/com/collectiveintelligence/fleetiq360/util/CommonFunc.java`

---

## PROJECT-WIDE FINDING

### A69-1 [CRITICAL] — Zero automated test coverage across app/ and LibCommon/ modules

**Scope:** Project-wide
**Confirmed context:** The `app/` module (177 Java source files) and the `LibCommon/` module (31 Java source files) contain no `test/` or `androidTest/` source sets. The only test code found in the repository lives in third-party library modules (`LibImageloader/src/test/`, `LibImagePicker/src/androidTest/`, `LibPercentProgress/src/androidTest/`), none of which test application logic.

**Evidence:**
```
find /c/Projects/cig-audit/repos/forkliftiqapp -type d -name "test" -o -type d -name "androidTest"
  → /c/Projects/cig-audit/repos/forkliftiqapp/LibImageloader/src/test          (third-party library)
  → /c/Projects/cig-audit/repos/forkliftiqapp/LibImagePicker/src/androidTest   (third-party library)
  → /c/Projects/cig-audit/repos/forkliftiqapp/LibPercentProgress/src/androidTest (third-party library)

No results under: app/src/test, app/src/androidTest, LibCommon/src/test, LibCommon/src/androidTest
```

**Impact:** Every security, correctness, and regression finding in this audit report exists with zero automated detection. Defects introduced by future changes — including changes to authentication, password storage, cryptographic functions, and input validation — cannot be caught mechanically before release. This is not a single gap; it is the absence of an entire quality gate for 208 application source files.

---

## File 1: UserDb.java

### Reading Evidence

**Fully qualified class name:** `au.com.collectiveintelligence.fleetiq360.user.UserDb`

**Fields / constants defined:** None (class has no instance or static fields).

**Methods (with line numbers and signatures):**

| Line | Visibility | Signature |
|------|-----------|-----------|
| 13 | `public static` | `void save(final User user)` |
| 32 | `public static` | `ArrayList<String> userEmails()` |
| 45 | `public static` | `User get(final int id)` |
| 55 | `public static` | `User get(final String email, final String password)` |
| 65 | `static` (package-private) | `List<User> driversOfCompany(final int companyId)` |

**Dependencies observed:**
- `SafeRealm` — thin Realm lifecycle wrapper (opens/closes instance, executes lambdas).
- `UserRealmObject` — the Realm-persisted model; queried directly by field values including `"password"`.
- `User` — the application-layer user model; produced by `UserRealmObject.makeUser()`.

---

### Findings — UserDb.java

#### A69-2 [CRITICAL] — `get(String email, String password)` enables offline brute-force with no rate-limiting, lockout, or test coverage

**Location:** `UserDb.java`, line 55–63

**Code:**
```java
public static User get(final String email, final String password) {
    return SafeRealm.Execute(new SafeRealm.Func<User>() {
        @Override
        public User Execute(Realm realm) {
            UserRealmObject user = realm.where(UserRealmObject.class)
                    .equalTo("email", email)
                    .equalTo("password", password)
                    .findFirst();
            return user != null ? user.makeUser() : null;
        }
    });
}
```

**Call site:** `CurrentUser.login()` (line 103 of `CurrentUser.java`) calls `UserDb.get(loginEmail, loginPassword)` in the `onFailed` handler — meaning every time a network request fails (including deliberate offline use), authentication falls through to this local Realm query.

**Problems:**
1. There is no failed-attempt counter, lockout threshold, or time delay applied anywhere between the network failure and this call. An attacker with physical access to the device, or a malicious app sharing the Realm database, can call `get(email, password)` in an unbounded loop.
2. The password value passed is the MD5 hash of the raw PIN (computed in `CurrentUser.setTemporaryLoginInformation` at line 122), but MD5 is a broken algorithm that can be reversed offline. The local Realm database stores this MD5 hash as the `password` field (see A69-6). An attacker who extracts the Realm file can crack the stored hashes without rate-limiting.
3. There is no test asserting that repeated failed calls within a time window trigger any protective response.
4. There is no test asserting that a null email or null password does not crash or return a spurious match — Realm's `equalTo` with a null argument throws `IllegalArgumentException` at runtime; this path is entirely unexercised.

**Severity justification:** CRITICAL — the offline authentication bypass is the primary fallback path, the password corpus is bounded (4–8 digit PINs as enforced in `LoginFragment.login()` at line 68), and MD5 hashing does not prevent offline dictionary attacks. The attack surface requires physical access to the device but no additional privileges once the device is unlocked.

---

#### A69-3 [HIGH] — `get(String email, String password)` — no test for null inputs (crash path)

**Location:** `UserDb.java`, line 55–63

Realm's `equalTo(String fieldName, String value)` throws `IllegalArgumentException` when `value` is null. There is no null-guard in this method. The callers in `CurrentUser.java` can supply a null password if `setTemporaryLoginInformation` was never called, or if `CommonFunc.MD5_Hash()` throws before returning (see A69-10). No test exercises the null-email or null-password input.

---

#### A69-4 [MEDIUM] — `save(User user)` — no test for update path vs. insert path

**Location:** `UserDb.java`, line 13–30

The `save` method branches on whether a `UserRealmObject` with the given `id` already exists: if found, `setValues(user)` is called on the existing managed object; if not, a new `UserRealmObject(user)` is constructed. There is no test verifying:
- That a round-trip save-then-get returns identical field values.
- That updating an existing record does not corrupt fields (particularly the conditional password update at `UserRealmObject.setValues` line 80).
- That saving a user with an id that does not exist creates a new record rather than silently no-opping.

---

#### A69-5 [MEDIUM] — `userEmails()` — no test for empty database, single user, or sort correctness

**Location:** `UserDb.java`, line 32–43

`userEmails()` queries all `UserRealmObject` records and returns their emails sorted alphabetically. No test verifies:
- Returns an empty list (not null) when no users are stored.
- Sort order is correct for mixed-case emails (Java's `Collections.sort` uses lexicographic order; `"b@x.com"` sorts before `"A@x.com"` due to ASCII ordering of uppercase/lowercase).
- Duplicate emails are included as duplicates (no deduplication is applied).

---

#### A69-5b [LOW] — `driversOfCompany(int companyId)` — no test for company with no drivers

**Location:** `UserDb.java`, line 65–75

Package-private. No test exercises the case where no `UserRealmObject` with the given `companyId` exists, which should return an empty list. The empty-list case is consumed by `User.hasAssociatedDrivers()` (line 83 of `User.java`), where incorrect null behaviour would cause a NullPointerException.

---

## File 2: UserRealmObject.java

### Reading Evidence

**Fully qualified class name:** `au.com.collectiveintelligence.fleetiq360.user.UserRealmObject`

**Superclass:** `io.realm.RealmObject`

**Fields defined (all private, lines 10–27):**

| Line | Type | Name | Annotation |
|------|------|------|-----------|
| 9–10 | `int` | `id` | `@PrimaryKey` |
| 11 | `int` | `companyId` | — |
| 12 | `String` | `firstName` | — |
| 13 | `String` | `lastName` | — |
| 14 | `String` | `email` | — |
| 15 | `String` | `password` | — |
| 16 | `String` | `phoneNumber` | — |
| 17 | `String` | `licenseNumber` | — |
| 18 | `Date` | `expiryDate` | — |
| 19 | `String` | `address` | — |
| 20 | `String` | `securityNumber` | — |
| 21 | `String` | `photoUrl` | — |
| 22 | `boolean` | `isContactPerson` | — |
| 23 | `String` | `dateFormat` | — |
| 24 | `int` | `maxSessionLength` | — |
| 25 | `Date` | `complianceDate` | — |
| 26 | `int` | `gps_frequency` | — |

**Methods (with line numbers and signatures):**

| Line | Visibility | Signature |
|------|-----------|-----------|
| 28 | `public` | `UserRealmObject()` — no-arg constructor required by Realm |
| 31 | `package-private` | `UserRealmObject(User user)` — copy constructor from domain model |
| 51 | `package-private` | `User makeUser()` — produces domain model from Realm fields |
| 71 | `package-private` | `String getEmail()` |
| 75 | `package-private` | `void setValues(User user)` — updates mutable fields from domain model |

---

### Findings — UserRealmObject.java

#### A69-6 [HIGH] — Password persisted in plaintext (MD5 hash) in Realm with no test verifying it is never exposed

**Location:** `UserRealmObject.java`, line 15 (field declaration); line 37 (copy constructor); line 80 (setValues conditional write); line 56 (makeUser — password copied into domain object)

**Detail:**

The `password` field stores the MD5 hash of the user's raw PIN, persisted without further protection:

```java
// Field declaration — line 15
private String password;

// Copy constructor — line 37
password = user.getPassword();

// setValues — line 80
if (user.getPassword() != null) password = user.getPassword();

// makeUser — line 56
password,   // passed directly into User constructor
```

The Realm database file (`default.realm`) is written to the device's internal storage. On a rooted device or via ADB backup (if `allowBackup` is not explicitly disabled), the file is extractable. The stored value is the MD5 hash of a 4–8 digit numeric PIN (enforced in `LoginFragment.login()`, line 68). A 4–8 digit PIN space has at most 99,999,999 candidates — trivially enumerable against MD5 in seconds on modern hardware.

Additionally, `makeUser()` at line 51–68 returns a `User` object that includes `getPassword()` (public, line 136 of `User.java`). This means every call path that retrieves a user from the database also surfaces the password hash to any code that holds a `User` reference.

No test exists verifying:
- That the password hash is not logged.
- That `makeUser()` does not expose the raw password field to UI layers.
- That the Realm schema does not include the password field in any serialised or exported form.

**Severity justification:** HIGH — requires device compromise (root or backup extraction) as a precondition, but once the Realm file is obtained the PIN space is exhausted in under one second with MD5 against a GPU.

---

#### A69-7 [HIGH] — `setValues` conditional password update — null password silently retains stale hash, no test

**Location:** `UserRealmObject.java`, lines 75–92

```java
void setValues(User user) {
    ...
    if (user.getPassword() != null) password = user.getPassword();
    ...
}
```

The intent of the null-guard is to preserve the existing password when a server response omits it. However:
1. If the server sends an empty string (`""`), the guard passes and the stored password is overwritten with an empty string, which would then match any offline login attempt supplying an empty password.
2. No test exercises the `password == null` branch (update that skips password) vs. the non-null branch (update that writes password) to confirm the correct field is preserved.
3. No test verifies that an update with `password = ""` does not create an authentication bypass.

---

#### A69-8 [MEDIUM] — `UserRealmObject(User user)` copy constructor — no test for null field propagation

**Location:** `UserRealmObject.java`, lines 31–49

All fields are copied directly from `User` without null checks. Realm permits null String and Date fields, so no crash occurs at construction. However:
- `makeUser()` (line 51) passes these potentially null values into the `User` constructor, whose methods (e.g., `fullName()`, `definedName()` in `User.java` lines 66–76) call `String.isEmpty()` on `firstName` and `lastName` without null guards. If a server response omits these fields and a null is stored and later retrieved, `definedName()` will throw `NullPointerException`.
- No test persists a user with null name fields and then calls `makeUser()` to verify the round-trip is safe.

---

#### A69-9 [LOW] — No test verifying `@PrimaryKey` conflict behaviour on duplicate id

**Location:** `UserRealmObject.java`, line 9–10

`id` is declared `@PrimaryKey`. Realm's `insertOrUpdate` in `UserDb.save()` handles duplicate keys by updating, not inserting. No test verifies that saving two `User` objects with the same `id` results in exactly one record with the second object's field values (not zero records, not two records, not a mix).

---

## File 3: CommonFunc.java

### Reading Evidence

**Fully qualified class name:** `au.com.collectiveintelligence.fleetiq360.util.CommonFunc`

**Fields / constants defined:** None.

**Methods (with line numbers and signatures):**

| Line | Visibility | Signature |
|------|-----------|-----------|
| 16 | `public static` | `boolean isCurrentDay(DateTime dateTime)` |
| 21 | `private static` | `boolean isSameLocalDay(DateTime dateTime, DateTime dateTime1)` |
| 32 | `private static` | `String dateToLocalDayString(DateTime dateTime)` |
| 39 | `private static` | `DateTimeZone getCurrentDateTimeZone()` |
| 44 | `public static` | `Date convertUTCDatetoLocalDate(Date utcDate)` |
| 50 | `public static` | `String SHA1(String text)` |
| 68 | `public static` | `String MD5_Hash(String s)` |
| 85 | `public static` | `boolean isEmailInvalid(String email)` |
| 92 | `public static` | `boolean isPasswordValid(String password)` |

---

### Findings — CommonFunc.java

#### A69-10 [HIGH] — `MD5_Hash(String s)` crashes on null input, no test; wrong padding constant produces incorrect hashes, no known-answer test

**Location:** `CommonFunc.java`, lines 68–83

```java
public static String MD5_Hash(String s) {
    MessageDigest m = null;
    try {
        m = MessageDigest.getInstance("MD5");
    } catch (NoSuchAlgorithmException e) {
        e.printStackTrace();
    }
    Objects.requireNonNull(m).update(s.getBytes(), 0, s.length());
    StringBuilder hash = new StringBuilder(new BigInteger(1, m.digest()).toString(16));
    while (hash.length() < 32) {
        hash.insert(0, "0");
    }
    return hash.toString();
}
```

**Problems:**

1. **Null input crash:** If `s` is null, `s.getBytes()` throws `NullPointerException` at line 77. No null guard exists. The caller in `CurrentUser.setTemporaryLoginInformation()` (line 122) passes `password` directly; if the UI ever delivers a null string, this crashes silently and the login flow breaks.

2. **Null digest instance crash via `requireNonNull`:** `MessageDigest.getInstance("MD5")` will not throw `NoSuchAlgorithmException` on standard Android (MD5 is guaranteed), but if it ever did, the catch block only prints the stack trace and does not rethrow or set a sentinel. `Objects.requireNonNull(m)` then immediately throws `NullPointerException`, meaning the exception-handling path itself crashes the application rather than returning a safe fallback.

3. **Wrong padding constant — incorrect hash output:** The padding loop pads to 32 characters (`while (hash.length() < 32)`). MD5 produces a 128-bit (16-byte) digest, whose hex representation is 32 characters — the constant is coincidentally correct for MD5. However, the identical padding loop in `SHA1()` uses the same constant (32), which is wrong for SHA-1 (160-bit / 20-byte / 40 hex chars). Because both methods share the same structural pattern, the same bug template exists in `MD5_Hash` for any future algorithm change. More critically, the absence of known-answer tests means neither function has ever been verified to produce the correct standard output.

4. **No known-answer test:** There is no test asserting that `MD5_Hash("password")` returns `"5f4dcc3b5aa765d61d8327deb882cf99"` (the standard MD5 of "password") or any other NIST-verifiable test vector. This is the only reliable way to detect encoder errors (charset assumptions, byte ordering, padding bugs).

5. **No empty-string test:** `MD5_Hash("")` calls `update("".getBytes(), 0, 0)` which is valid, and should return `"d41d8cd98f00b204e9800998ecf8427e"`. No test asserts this.

6. **Charset not specified:** `s.getBytes()` uses the platform default charset. On Android this is UTF-8, but the API contract does not guarantee it. A test verifying multi-byte input (e.g., non-ASCII characters) would catch any charset regression.

**Severity justification:** HIGH — `MD5_Hash` is used as the pre-processing step for authentication credentials in `CurrentUser.setTemporaryLoginInformation` (line 122) and the login parameter construction (line 82 of `CurrentUser.java`). A bug that produces wrong output or crashes silently breaks authentication for all users.

---

#### A69-11 [HIGH] — `SHA1(String text)` — null input crash, wrong padding (truncates valid hashes), no test

**Location:** `CommonFunc.java`, lines 50–66

```java
public static String SHA1(String text) {
    MessageDigest md;
    try {
        md = MessageDigest.getInstance("SHA-1");
    } catch (NoSuchAlgorithmException e) {
        e.printStackTrace();
        return "";
    }
    md.update(text.getBytes(), 0, text.length());
    StringBuilder hash = new StringBuilder(new BigInteger(1, md.digest()).toString(16));
    while (hash.length() < 32) {
        hash.insert(0, "0");
    }
    return hash.toString();
}
```

**Problems:**

1. **Null input crash:** `text.getBytes()` throws `NullPointerException` if `text` is null. No null guard.

2. **Wrong padding constant — hash truncation bug:** SHA-1 produces a 160-bit (20-byte) digest, whose correct hex representation is 40 characters. The padding loop pads only to 32 characters (`while (hash.length() < 32)`). `BigInteger(1, digest).toString(16)` does not zero-pad leading bytes — so for SHA-1 digests whose leading bytes are 0x00, the hex string will be shorter than 40 characters. The loop pads only up to 32, meaning:
   - Digests with a leading zero byte will have 38 hex characters padded to 38 (no change since 38 > 32).
   - Digests with two leading zero bytes (16-bit leading zeros) will produce a 36-character string, padded to 36.
   - Any leading-zero padding required beyond 32 characters is silently dropped.
   This produces a structurally incorrect SHA-1 string. Whether this matters depends on how the output is consumed; however, it means two inputs with different SHA-1 digests can produce the same truncated output (collision in the output space).

3. **No known-answer test:** There is no test asserting that `SHA1("abc")` returns `"a9993e364706816aba3e25717850c26c9cd0d89d"` (the standard SHA-1 of "abc"). Without such a test, the padding bug described above cannot be automatically detected.

4. **No empty-string test:** `SHA1("")` should return `"da39a3ee5e6b4b0d3255bfef95601890afd80709"` (40 characters). The padding loop caps at 32, so the returned string would be `"da39a3ee5e6b4b0d3255bfef95601890afd80709"` which is already 40 characters and would pass through correctly — but this is coincidental. A leading-zero case (e.g., a known input producing `"0097..."`) would expose the truncation.

5. **Exception handling inconsistency vs. `MD5_Hash`:** On `NoSuchAlgorithmException`, `SHA1` returns `""` (line 56). `MD5_Hash` by contrast does not return early — it crashes on `requireNonNull`. The two error paths are inconsistent and neither is tested.

**Severity justification:** HIGH — the padding truncation is a silent correctness bug that produces wrong output without any error signal. If SHA-1 output is used for any security-relevant comparison (token, signature, verification), collisions in the truncated output space weaken the guarantee. The current call-site usage of this method elsewhere in the codebase must be audited separately.

---

#### A69-12 [MEDIUM] — `isEmailInvalid(String email)` — no test for null, empty string, whitespace-only, or internationalized email

**Location:** `CommonFunc.java`, lines 85–90

```java
public static boolean isEmailInvalid(String email) {
    if (null == email) {
        return true;
    }
    return !android.util.Patterns.EMAIL_ADDRESS.matcher(email).matches();
}
```

The null guard is correct, but no test exercises:
- `null` input returning `true`.
- `""` (empty string) returning `true`.
- `"   "` (whitespace only) returning `true`.
- A valid email address returning `false`.
- An invalid but syntactically close address (e.g., `"user@"`, `"@domain.com"`) returning `true`.
- Internationalized domain names (e.g., `"user@münchen.de"`) — `Patterns.EMAIL_ADDRESS` behaviour with non-ASCII input is not tested.

---

#### A69-13 [MEDIUM] — `isPasswordValid(String password)` — no test for null, empty string, boundary lengths, or whitespace-only

**Location:** `CommonFunc.java`, lines 92–94

```java
public static boolean isPasswordValid(String password) {
    return password != null && password.length() != 0;
}
```

The implementation accepts any non-null, non-empty string as valid. `LoginFragment.login()` applies a separate length check (minimum 4 characters), creating two divergent validation rules. No test exercises:
- `null` returning `false`.
- `""` returning `false`.
- `"   "` (whitespace only) returning `true` — this is a likely unintended case.
- A single character returning `true` (passes `isPasswordValid` but fails the `LoginFragment` length check).

---

#### A69-14 [MEDIUM] — `isCurrentDay(DateTime dateTime)` — no test for null input, timezone boundaries, or DST transitions

**Location:** `CommonFunc.java`, lines 16–19

`isCurrentDay` delegates to `isSameLocalDay` (line 21), which returns `false` for a null `dateTime`. However:
- No test asserts that `isCurrentDay(null)` returns `false` (not throws).
- No test exercises behaviour at midnight boundaries where a UTC timestamp is "today" in UTC but "yesterday" in the local timezone (or vice versa) — a common source of off-by-one date bugs.
- No test exercises DST transition hours, where a 60-minute gap or overlap can cause an hour to belong to two different local "days" depending on clock direction.

---

#### A69-15 [MEDIUM] — `convertUTCDatetoLocalDate(Date utcDate)` — no test for null input, epoch, or DST boundary

**Location:** `CommonFunc.java`, lines 44–48

```java
public static Date convertUTCDatetoLocalDate(Date utcDate) {
    DateTime dt = new DateTime(utcDate);
    DateTime dtus = dt.withZone(getCurrentDateTimeZone());
    return dtus.toLocalDateTime().toDate();
}
```

`new DateTime(null)` throws `IllegalArgumentException` in Joda-Time. No null guard exists, and no test exercises this path. Additionally:
- No test asserts correct conversion for a known UTC timestamp to a known local time.
- No test exercises epoch (1970-01-01T00:00:00Z) or the maximum `Date` value.

---

#### A69-16 [INFO] — `MD5_Hash` and `SHA1` use deprecated/broken algorithms — no test flagging algorithm strength

**Location:** `CommonFunc.java`, lines 50 and 68

MD5 and SHA-1 are both cryptographically broken. Their use for password-related operations (observed in `CurrentUser.java`) is a design problem separate from test coverage. As a test-coverage observation: there is no test that would catch if these methods were silently swapped for each other (both return a `String`), and there is no test asserting algorithm identity (e.g., that `MD5_Hash` genuinely uses MD5 and not SHA-1 or some other algorithm). A known-answer test against a standard test vector would provide this assurance.

---

## Summary Table

| ID | Severity | File | Description |
|----|----------|------|-------------|
| A69-1 | CRITICAL | Project-wide | Zero automated test coverage in app/ and LibCommon/ modules |
| A69-2 | CRITICAL | UserDb.java | `get(email, password)` offline auth — no rate-limiting, lockout, or brute-force protection; no test |
| A69-3 | HIGH | UserDb.java | `get(email, password)` — null inputs cause crash; no test |
| A69-4 | MEDIUM | UserDb.java | `save(User)` — update vs. insert branching untested; no round-trip test |
| A69-5 | MEDIUM | UserDb.java | `userEmails()` — empty DB, case-sensitive sort, duplicate emails untested |
| A69-5b | LOW | UserDb.java | `driversOfCompany()` — empty result case untested |
| A69-6 | HIGH | UserRealmObject.java | Password (MD5 hash) persisted in Realm; exposed via `makeUser()`; no test verifying it is never surfaced to UI |
| A69-7 | HIGH | UserRealmObject.java | `setValues()` — empty-string password creates auth bypass; null-guard branches untested |
| A69-8 | MEDIUM | UserRealmObject.java | Copy constructor — null field propagation into `makeUser()` leads to NPE in `User.definedName()`; untested |
| A69-9 | LOW | UserRealmObject.java | `@PrimaryKey` collision behaviour on duplicate id not tested |
| A69-10 | HIGH | CommonFunc.java | `MD5_Hash()` — null crash, wrong exception handling, no known-answer test, no empty-string test |
| A69-11 | HIGH | CommonFunc.java | `SHA1()` — null crash, wrong padding constant (pads to 32 not 40), hash truncation bug, no known-answer test |
| A69-12 | MEDIUM | CommonFunc.java | `isEmailInvalid()` — null, empty, whitespace, international email cases untested |
| A69-13 | MEDIUM | CommonFunc.java | `isPasswordValid()` — null, empty, whitespace-only cases untested; inconsistent with `LoginFragment` length rule |
| A69-14 | MEDIUM | CommonFunc.java | `isCurrentDay()` — null input, timezone boundary, DST transition cases untested |
| A69-15 | MEDIUM | CommonFunc.java | `convertUTCDatetoLocalDate()` — null input crash, no correct-conversion test |
| A69-16 | INFO | CommonFunc.java | MD5 and SHA-1 are broken algorithms; no known-answer tests would catch silent algorithm substitution |
