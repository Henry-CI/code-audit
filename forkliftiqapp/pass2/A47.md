# Audit Pass 2 — Agent A47
**Audit run:** 2026-02-26-01
**Agent:** A47
**Assigned files:**
1. `app/src/main/java/au/com/collectiveintelligence/fleetiq360/model/PreStartHistoryDb.java`
2. `app/src/main/java/au/com/collectiveintelligence/fleetiq360/model/PreStartQuestionDb.java`
3. `app/src/main/java/au/com/collectiveintelligence/fleetiq360/model/RealmInt.java`

---

## PROJECT-WIDE FINDING

### A47-1 — CRITICAL: Zero automated test coverage across app/ and LibCommon/ modules

**Severity:** HIGH (project-wide)

The `app/` module and `LibCommon/` module contain no `test/` or `androidTest/` source directories whatsoever. A glob search for `**/test/**/*.java` and `**/androidTest/**/*.java` under the repository root returned zero results for these two modules. The only test files found in the entire repo belong to third-party library modules (`LibImageloader`, `LibImagePicker`, `LibPercentProgress`) and are not authored by the application team.

This means every class in `app/` — including safety-critical database and business-logic layers — runs in production with no regression safety net. Any refactoring, dependency upgrade, or edge-case bug has no automated check to catch it. For an industrial forklift management system where pre-start safety inspections gate vehicle operation, this is a serious project-wide risk.

**Affected modules:** `app/`, `LibCommon/`
**Evidence:** Glob of `**/test/**/*.java` and `**/androidTest/**/*.java` — no results in these modules.

---

## File 1: PreStartHistoryDb.java

### Reading Evidence

**Fully qualified class name:** `au.com.collectiveintelligence.fleetiq360.model.PreStartHistoryDb`
**Extends:** `io.realm.RealmObject`

**Fields defined:**
| Name | Type | Visibility | Line |
|---|---|---|---|
| `userKey` | `int` | `public` | 13 |
| `dateTime` | `String` | `private` | 15 |
| `driver_id` | `int` | `public` | 16 |
| `unit_id` | `int` | `public` | 17 |

**Methods defined:**
| Method | Visibility | Return type | Line |
|---|---|---|---|
| `hasPreStartDoneForToday(int driver_id, int unit_id)` | `public static` | `boolean` | 19 |
| `setPreStartDone(int driver_id, int unit_id)` | `static` (package-private) | `void` | 33 |

**No test file exists** for this class. Searched the entire repository for any test file referencing `PreStartHistoryDb`, `hasPreStartDoneForToday`, or `setPreStartDone` — zero matches.

---

### Findings

#### A47-2 — CRITICAL: `hasPreStartDoneForToday()` — safety gate logic completely untested

**File:** `PreStartHistoryDb.java`
**Lines:** 19–31
**Severity:** CRITICAL

`hasPreStartDoneForToday()` is the sole gate that determines whether a driver must complete a pre-start safety inspection before operating a forklift. It is called in two distinct safety-critical paths:

- `WebData.getTempSessionResult()` (line 52 of `WebData.java`): sets `sessionResult.prestart_required = !hasPreStartDoneForToday(...)` for offline session creation.
- `WebApi.saveSessionStart()` (line 251 of `WebApi.java`): overrides the server response with `result.prestart_required = false` if this method returns `true`, bypassing any server-side requirement.

If this method returns `true` (inspection done) when it should return `false` (inspection not done), the pre-start safety check is silently skipped and the driver can operate the forklift without completing the inspection. There are no tests for:

- The normal case: inspection recorded today, method returns `true`.
- The normal case: no record in database, method returns `false`.
- The case where `preStartHistories.get(0).dateTime` is null or malformed (line 27 calls `DateTime.parse()` with no null/format guard on the stored string; a corrupt or null value would throw an uncaught exception inside the Realm callback, whose return value in `SafeRealm.Execute` would then be `null`, which is unboxed to `boolean` — a NullPointerException at the call site).
- The case where `preStartHistories` contains more than one entry for the same `(driver_id, unit_id)` pair: `get(0)` is used with no ordering clause, so the result is non-deterministic if duplicate rows exist.

**Impact:** A false `true` result silently bypasses the mandatory pre-start inspection, allowing an operator to drive a potentially unsafe forklift. A crash from a malformed `dateTime` string would surface as a runtime exception with no graceful fallback.

---

#### A47-3 — CRITICAL: `hasPreStartDoneForToday()` — untested boundary: date/timezone transition at midnight

**File:** `PreStartHistoryDb.java` / `CommonFunc.java`
**Lines:** 27–28 (`PreStartHistoryDb.java`), 16–19 (`CommonFunc.java`)
**Severity:** CRITICAL

The "is today" decision delegates to `CommonFunc.isCurrentDay(dateTime)`, which calls `isSameLocalDay()`, which applies `TimeZone.getDefault()` at call time. There are no tests for:

- An inspection stored just before midnight (e.g., 23:59:58) being checked just after midnight (00:00:01) — the stored timestamp is yesterday in local time; the method must correctly return `false`.
- The device timezone changing between the time the inspection was recorded (`setPreStartDone` stores `DateTime.now().toString()`) and the time `hasPreStartDoneForToday` is called. `DateTime.now().toString()` produces an ISO-8601 string with an offset (e.g., `+10:00`). `DateTime.parse()` on line 27 parses this with that offset preserved. `isCurrentDay` then converts both datetimes to the *current* default timezone before comparing. If the device timezone has changed, the stored timestamp retains its original offset but the comparison uses the new default zone, creating a mismatch that could cause the method to return `false` on the same calendar day.
- Daylight Saving Time transitions: a one-hour clock shift means "today" and "yesterday" boundaries shift, and a stored timestamp from before the DST change might compare incorrectly.

**Impact:** Any of these edge cases could cause the safety gate to fail open (returning `false` when the inspection was done) forcing a redundant inspection, or fail closed (returning `true` when the inspection was from the previous day) allowing a driver to skip today's required inspection.

---

#### A47-4 — HIGH: `setPreStartDone()` — untested, no verification of write success

**File:** `PreStartHistoryDb.java`
**Lines:** 33–51
**Severity:** HIGH

`setPreStartDone()` is the only mechanism for recording that a pre-start inspection was completed. It is called by `SessionDb` after a pre-start is marked finished. There are no tests for:

- The happy path: calling `setPreStartDone()` followed by `hasPreStartDoneForToday()` and verifying the result is `true`.
- The upsert branch: when no existing record exists (`histories.size() == 0`), a new `PreStartHistoryDb` object is created. When an existing record exists, it is updated in-place. Neither branch is tested.
- Realm transaction failure: `realm.executeTransaction()` can throw `RealmException` or `IllegalStateException` (e.g., if the Realm instance is closed or the schema is incompatible). `SafeRealm.Execute(Action)` on line 34 does not catch exceptions; a failure would leave no record written and no error signalled to the caller.
- The package-private visibility of `setPreStartDone()` means it is not accessible from test code in a different package without reflection.

---

#### A47-5 — MEDIUM: `hasPreStartDoneForToday()` — `SafeRealm.Execute` return value can be `null`, unboxed to NPE

**File:** `PreStartHistoryDb.java`
**Lines:** 19–31
**Severity:** MEDIUM

`SafeRealm.Execute(Func<Boolean>)` returns `T` (i.e., `Boolean`). The lambda's `Execute(Realm)` method returns `false` (line 26) or the result of `dateTime != null && CommonFunc.isCurrentDay(dateTime)` (line 28). However, if `realm.close()` is called before the result is returned (not the case here, but possible if `SafeRealm` is refactored), or if `DateTime.parse()` throws and the exception propagates out of the lambda, `SafeRealm.Execute` returns `null`. The public method signature is `boolean` (primitive), so auto-unboxing of a `null` `Boolean` causes a `NullPointerException` at the call sites in `WebData` and `WebApi`. No test covers this failure mode.

---

#### A47-6 — MEDIUM: `hasPreStartDoneForToday()` — `get(0)` on unordered results; non-deterministic when duplicate records exist

**File:** `PreStartHistoryDb.java`
**Lines:** 23–28
**Severity:** MEDIUM

The Realm query on lines 23–24 fetches all `PreStartHistoryDb` records matching `(driver_id, unit_id)` with no ordering applied (`findAll()` with no `.sort()`). `get(0)` is then called on the result set. If more than one record exists for the same `(driver_id, unit_id)` pair (which `setPreStartDone()` prevents by upserting, but could occur from a previous schema migration or direct database manipulation), the record examined is non-deterministic. No test verifies behaviour when duplicate records are present, and no test verifies that the upsert in `setPreStartDone()` prevents accumulation of duplicates over time.

---

## File 2: PreStartQuestionDb.java

### Reading Evidence

**Fully qualified class name:** `au.com.collectiveintelligence.fleetiq360.model.PreStartQuestionDb`
**Extends:** `io.realm.RealmObject`

**Fields defined:**
| Name | Type | Visibility | Line |
|---|---|---|---|
| `userKey` | `int` | `public` | 15 |
| `updateTime` | `long` | `private` | 17 |
| `prestartQuestionResultArray` | `String` | `private` | 18 |
| `equipmentId` | `int` | `private` | 20 |

**Methods defined:**
| Method | Visibility | Return type | Line |
|---|---|---|---|
| `isExpired()` | `private` | `boolean` | 22 |
| `needToCache(int equipmentId)` | `static` (package-private) | `boolean` | 26 |
| `getQuestionResultArray(int equipmentId)` | `public static` | `PreStartQuestionResultArray` | 37 |
| `saveQuestions(int equipmentId, PreStartQuestionResultArray)` | `public static` | `void` | 53 |

**No test file exists** for this class. Searched the entire repository for any test file referencing `PreStartQuestionDb`, `needToCache`, `getQuestionResultArray`, or `saveQuestions` — zero matches.

---

### Findings

#### A47-7 — HIGH: `needToCache()` — expiry logic completely untested

**File:** `PreStartQuestionDb.java`
**Lines:** 26–35
**Severity:** HIGH

`needToCache()` delegates to `DataBaseHelp.isExpired(updateTime)`, which uses a hardcoded 2-hour TTL (`2 * 60 * 60 * 1000` ms). This determines whether the application re-fetches pre-start questions from the server. If the TTL logic is wrong or the `updateTime` field is not set correctly after a `saveQuestions()` call, the app will either:

- Always return `true` (always cache-miss), causing unnecessary network traffic and a potential failure to display questions if the network is unavailable.
- Always return `false` (always cache-hit), causing stale pre-start questions to be served to the operator indefinitely.

Neither path is tested. Specifically:
- No test verifies that a record saved less than 2 hours ago causes `needToCache()` to return `false`.
- No test verifies that a record saved more than 2 hours ago causes `needToCache()` to return `true`.
- No test verifies the edge case of `updateTime == 0` (new object, never saved — Realm default int value). `isExpired(0)` would compute `currentTime - 0`, which is always greater than 2 hours, so a freshly created but unsaved object would appear expired. No test confirms this is the intended behaviour.
- No test verifies the `updateTime > currentTime` branch in `DataBaseHelp.isExpired()` (which returns `false` — "not expired" — for a future timestamp, which could occur if the device clock is set forward then back).

---

#### A47-8 — HIGH: `getQuestionResultArray()` — deserialization failure returns empty list silently

**File:** `PreStartQuestionDb.java`
**Lines:** 37–51
**Severity:** HIGH

`getQuestionResultArray()` calls `GsonHelper.objectFromString(questions.get(0).prestartQuestionResultArray, PreStartQuestionResultArray.class)` (line 44). If the stored JSON is malformed, truncated, or from an incompatible schema version, `GsonHelper.objectFromString()` may return `null`. The method returns `null` to the caller (`PreStartCheckListPresenter`, line 46) without any fallback. The caller at line 46 does not appear to null-check before using the result. No test covers:

- A `null` return from `GsonHelper.objectFromString()` when JSON is malformed.
- An empty JSON object `{}` that deserialises to a `PreStartQuestionResultArray` with a null `arrayList`.
- A `prestartQuestionResultArray` field that is `null` in the database (never set).

The consequence of a null result propagating to the checklist presenter is that the pre-start checklist is displayed with no questions, which could give the false impression that the inspection is complete when no checks have been performed.

---

#### A47-9 — HIGH: `saveQuestions()` — no test for round-trip correctness

**File:** `PreStartQuestionDb.java`
**Lines:** 53–69
**Severity:** HIGH

`saveQuestions()` serialises `PreStartQuestionResultArray` to a JSON string via `GsonHelper.stringFromObjectNoPolicy()` and stores it in the `prestartQuestionResultArray` field. `getQuestionResultArray()` deserialises it back. There are no round-trip tests verifying that:

- A `PreStartQuestionResultArray` written by `saveQuestions()` is read back identically by `getQuestionResultArray()` for the same `equipmentId`.
- A `PreStartQuestionResultArray` with an empty `arrayList` survives the round-trip.
- A `PreStartQuestionResultArray` with a large list (boundary) survives without truncation.
- The upsert behaviour: a second call to `saveQuestions()` for the same `equipmentId` replaces (not duplicates) the existing record and the `updateTime` is refreshed.

---

#### A47-10 — MEDIUM: `needToCache()` — package-private visibility prevents external test access

**File:** `PreStartQuestionDb.java`
**Line:** 26
**Severity:** MEDIUM

`needToCache()` has package-private (`static`) visibility. Test classes in the standard `test/` directory structure would reside in a different package (`au.com.collectiveintelligence.fleetiq360.model` under the test source set). Java package-private access is scoped to the compilation unit's package, not the test source set in a different directory, so test code in the standard location cannot call `needToCache()` directly without reflection. This design decision makes the method structurally difficult to test. No test exercises it at all.

---

#### A47-11 — MEDIUM: `getQuestionResultArray()` — returns constructed empty object for cache miss but `null` for deserialisation failure; callers cannot distinguish

**File:** `PreStartQuestionDb.java`
**Lines:** 45–49
**Severity:** MEDIUM

When no record exists in the database (cache miss), the method returns a freshly constructed `PreStartQuestionResultArray` with an empty `arrayList` (lines 46–48). When a record exists but `GsonHelper.objectFromString()` returns `null` (deserialisation failure), the method returns `null`. These two cases (legitimate empty cache vs. corrupt data) produce different return values (`empty object` vs. `null`), but callers have no documented contract specifying which case produces which return value, and no test verifies the distinction or that callers handle `null` correctly.

---

#### A47-12 — MEDIUM: `saveQuestions()` — Realm transaction failure leaves no error signal to caller

**File:** `PreStartQuestionDb.java`
**Lines:** 53–69
**Severity:** MEDIUM

`saveQuestions()` returns `void`. `SafeRealm.Execute(Action)` (line 54) does not catch `RealmException` or other runtime exceptions that Realm may throw during `realm.executeTransaction()`. If the transaction fails (e.g., schema mismatch, closed Realm instance, disk full), the exception propagates to the caller with no opportunity for the caller to retry or alert the user. The pre-start question cache would then be silently absent, and `needToCache()` would return `true` again on the next call, leading to an infinite retry if the underlying cause persists. No test covers this failure path.

---

## File 3: RealmInt.java

### Reading Evidence

**Fully qualified class name:** `au.com.collectiveintelligence.fleetiq360.model.RealmInt`
**Extends:** `io.realm.RealmObject`

**Fields defined:**
| Name | Type | Visibility | Line |
|---|---|---|---|
| `data` | `int` | package-private | 9 |

**Methods defined:** None (no explicit methods; inherits `RealmObject` lifecycle methods).

**Constants defined:** None.

**No test file exists** for this class. Searched the entire repository for any reference to `RealmInt` in test files — zero matches. Additionally, a grep for `RealmInt` across all Java source files shows it is referenced *only* within its own definition file and nowhere else in the application codebase.

---

### Findings

#### A47-13 — LOW: `RealmInt` — dead code; class is defined but never referenced

**File:** `RealmInt.java`
**Lines:** 1–10
**Severity:** LOW

`RealmInt` is a Realm model class with a single `int data` field. A grep across the entire codebase finds zero references to this class outside of its own definition file. It is not used by any other class, not included in any query, and not returned from any method. It appears to be either a vestigial class from an earlier design or a placeholder that was never used. Dead Realm model classes still participate in the Realm schema and can cause schema migration issues if Realm's auto-migration does not account for their removal. No test verifies the class's intended usage or documents why it exists.

---

#### A47-14 — INFO: `RealmInt.data` field has no accessor methods and is package-private

**File:** `RealmInt.java`
**Line:** 9
**Severity:** INFO

The `data` field is package-private with no getter or setter. Realm recommends using standard JavaBean-style accessor methods for fields in `RealmObject` subclasses to allow Realm's bytecode weaving to work correctly. Direct field access on managed `RealmObject` instances can behave differently from accessor access. If this class is ever put into use, the field access pattern should be validated. No test currently exercises the field.

---

## Summary Table

| ID | Severity | File | Description |
|---|---|---|---|
| A47-1 | HIGH (project) | all | Zero automated test coverage in `app/` and `LibCommon/` modules |
| A47-2 | CRITICAL | `PreStartHistoryDb.java` | `hasPreStartDoneForToday()` — safety gate completely untested; false positive bypasses inspection requirement |
| A47-3 | CRITICAL | `PreStartHistoryDb.java` | `hasPreStartDoneForToday()` — midnight boundary and timezone change cases untested |
| A47-4 | HIGH | `PreStartHistoryDb.java` | `setPreStartDone()` — write path untested; Realm failure leaves no audit record |
| A47-5 | MEDIUM | `PreStartHistoryDb.java` | `hasPreStartDoneForToday()` — `SafeRealm` can return null `Boolean`; auto-unboxing NPE at call sites |
| A47-6 | MEDIUM | `PreStartHistoryDb.java` | `hasPreStartDoneForToday()` — `get(0)` on unordered results; non-deterministic with duplicate records |
| A47-7 | HIGH | `PreStartQuestionDb.java` | `needToCache()` — 2-hour TTL expiry logic completely untested |
| A47-8 | HIGH | `PreStartQuestionDb.java` | `getQuestionResultArray()` — JSON deserialisation failure returns null; caller can display empty checklist |
| A47-9 | HIGH | `PreStartQuestionDb.java` | `saveQuestions()` — no round-trip test; data corruption not detected |
| A47-10 | MEDIUM | `PreStartQuestionDb.java` | `needToCache()` — package-private; structurally untestable without reflection |
| A47-11 | MEDIUM | `PreStartQuestionDb.java` | `getQuestionResultArray()` — cache-miss and deserialisation-failure return values indistinguishable |
| A47-12 | MEDIUM | `PreStartQuestionDb.java` | `saveQuestions()` — Realm transaction failure uncaught; cache silently absent |
| A47-13 | LOW | `RealmInt.java` | Dead code — `RealmInt` is never referenced anywhere in the codebase |
| A47-14 | INFO | `RealmInt.java` | `data` field is package-private with no accessors; inconsistent with Realm best practices |
