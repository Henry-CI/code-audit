# Audit Pass 2 – Test Coverage
## Agent A14 — BleUtil.java, ShockEventService.java, ShockEventsDb.java
**Audit run:** 2026-02-26-01
**Date reviewed:** 2026-02-27

---

## PROJECT-WIDE FINDING (HIGH)

### A14-1 — Zero automated test coverage across app/ and LibCommon/ modules

**Severity:** HIGH

The `app/` and `LibCommon/` modules contain no test directories whatsoever. Confirming via filesystem search:

- `app/src/test/` — does not exist
- `app/src/androidTest/` — does not exist
- `LibCommon/src/test/` — does not exist
- `LibCommon/src/androidTest/` — does not exist

The only tests in the entire repository live in `LibImageloader/src/test/java/` (`ImageSizeTest.java` and `BaseImageDownloaderTest.java`), which test a third-party image-loading library unrelated to application logic.

All findings below are gaps against zero coverage — every method in the three assigned files is completely untested.

---

## File 1: BleUtil.java

**Fully qualified class name:**
`au.com.collectiveintelligence.fleetiq360.WebService.BLE.BleUtil`

**Methods (with line numbers and signatures):**

| Line | Signature |
|------|-----------|
| 24 | `public BleUtil()` |
| 43 | `public static BleTimeItem parseBleTime(byte[] data)` |
| 63 | `public static boolean isTimeSetSucceed(BleTimeItem bleTimeItem, BleTimeItem expectItem)` |
| 91 | `public static byte[] getTimeData()` |
| 127 | `public static boolean isTheSameByteArray(byte[] a1, byte[] a2)` |
| 134 | `static byte[] timezoneWithDstOffset(Calendar time)` |
| 151 | `public static String bytesToHexStr(byte[] bytes)` |
| 164 | `static public int unsignedByteToInt(byte b)` |
| 171 | `static public int unsignedBytesToInt(byte b0, byte b1)` |
| 178 | `static public int unsignedBytesToInt(byte b0, byte b1, byte b2, byte b3)` |
| 186 | `static public float bytesToFloat(byte b0, byte b1)` |
| 196 | `static public float bytesToFloat(byte b0, byte b1, byte b2, byte b3)` |
| 207 | `static public int unsignedToSigned(int unsigned, int size)` |
| 217 | `static public int intToSignedBits(int i, int size)` |
| 227 | `static private int getTypeLen(int formatType)` |
| 231 | `static public Integer getIntValue(byte[] data, int formatType)` |
| 234 | `static public Integer getIntValue(byte[] data, int formatType, int offset)` |

**Constants and types defined:**

| Name | Type | Line | Value |
|------|------|------|-------|
| `UPDATE_REASON_UNKNOWN` | `static byte` | 26 | `0` |
| `UPDATE_REASON_MANUAL` | `static byte` | 27 | `1` |
| `UPDATE_REASON_EXTERNAL_REF` | `static byte` | 28 | `(1 << 1)` |
| `UPDATE_REASON_TIME_ZONE_CHANGE` | `static byte` | 29 | `(1 << 2)` |
| `UPDATE_REASON_DAYLIGHT_SAVING` | `static byte` | 30 | `(1 << 3)` |
| `hexArray` | `private final static char[]` | 150 | `"0123456789ABCDEF"` |
| `BleTimeItem` | inner class | 33–42 | fields: year, month, day, hour, minute, second, dayOfWeek |

---

### A14-2 — `parseBleTime` null input not guarded

**Severity:** CRITICAL
**Location:** `BleUtil.java`, line 43–61

`parseBleTime(byte[] data)` dereferences `data.length` on line 48 with no null check. A null `data` argument causes an immediate `NullPointerException`. This method is called from the BLE data pipeline where BLE characteristic reads can return null data buffers. No test exists for the null case, the empty-array case, or the minimum-boundary case (exactly 10 bytes vs 9 bytes).

Missing test cases:
- `parseBleTime(null)` — should not throw
- `parseBleTime(new byte[0])` — should return empty BleTimeItem
- `parseBleTime(new byte[9])` — boundary: exactly one byte short (should return empty BleTimeItem)
- `parseBleTime(new byte[10])` — boundary: exactly the minimum valid length

---

### A14-3 — `isTimeSetSucceed` accepts null arguments without guard

**Severity:** HIGH
**Location:** `BleUtil.java`, line 63–89

`isTimeSetSucceed(BleTimeItem bleTimeItem, BleTimeItem expectItem)` dereferences both parameters directly on lines 65 and 69 without null checks. A null `bleTimeItem` or null `expectItem` causes `NullPointerException`. At call sites this method is invoked after `parseBleTime` returns, which can return a partially initialized `BleTimeItem` (all fields zero) rather than null, but callers from other contexts could pass null. No tests exist for any path through this method.

Missing test cases:
- `isTimeSetSucceed(null, validItem)` — should not throw
- `isTimeSetSucceed(validItem, null)` — should not throw
- Year/month/day individually at zero (returns false)
- All fields equal (returns true)
- All fields in `bleTimeItem` strictly less than `expectItem` (returns false)

---

### A14-4 — `getIntValue` offset boundary produces silent null, never tested

**Severity:** HIGH
**Location:** `BleUtil.java`, lines 231–262

`getIntValue(byte[] data, int formatType, int offset)` guards against out-of-bounds via `(offset + getTypeLen(formatType)) > data.length` returning null (line 236), but:

1. No test exercises the null-return path at all.
2. Callers in `parseBleTime` (lines 52–58) and `saveShockEvent` in `ShockEventService` (lines 118–119) receive `Integer` (boxed), and most callers unbox with `.longValue()` or direct cast — a null return from `getIntValue` causes `NullPointerException` at the call site.
3. `data` itself is not null-checked — passing null crashes before the bounds check.
4. A negative `offset` is never rejected; for most format types, a negative offset causes `(offset + typeLen)` to stay below `data.length`, passing the guard, then crashing on `data[offset]` with `ArrayIndexOutOfBoundsException`.

Missing test cases:
- Null `data` argument
- Negative `offset`
- `offset` exactly at boundary (last valid byte)
- `offset` one past boundary (should return null)
- All six `formatType` branches with valid data
- Unknown `formatType` (falls through to `return null`)

---

### A14-5 — `bytesToHexStr` null and empty inputs untested

**Severity:** HIGH
**Location:** `BleUtil.java`, lines 151–159

`bytesToHexStr(byte[] bytes)` dereferences `bytes.length` on line 152 with no null check — null input causes `NullPointerException`. The method is public and static and used in BLE logging paths. An empty byte array input (`new byte[0]`) should return an empty string but is untested. High-byte values (e.g., `0xFF`) should produce `"FF"` — the bitmask logic is untested.

Missing test cases:
- `bytesToHexStr(null)` — should not throw
- `bytesToHexStr(new byte[0])` — should return `""`
- Single-byte all-zeros: `{0x00}` → `"00"`
- Single-byte all-ones: `{(byte)0xFF}` → `"FF"`
- Multi-byte round-trip

---

### A14-6 — `isTheSameByteArray` partial null cases and length mismatch untested

**Severity:** MEDIUM
**Location:** `BleUtil.java`, lines 127–132

`isTheSameByteArray` correctly guards for both-null via a single null check on line 128, but null handling returns `false` for both `(null, null)` and `(null, nonNull)` — the semantics of `(null, null)` returning `false` rather than `true` is at least surprising and warrants a documented test. Additionally, arrays of different lengths and arrays with identical bytes-but-different-lengths are untested.

Missing test cases:
- `(null, null)` — returns false (semantically surprising, no test to document intent)
- `(null, nonNull)` — returns false
- `(nonNull, null)` — returns false
- Equal content, same length — returns true
- Equal content, different length — behavior depends on `ByteBuffer.compareTo`, untested
- Different content, same length — returns false

---

### A14-7 — `unsignedToSigned` operator precedence bug on size parameter, untested

**Severity:** HIGH
**Location:** `BleUtil.java`, lines 207–212

```java
if ((unsigned & (1 << size-1)) != 0) {
    unsigned = -1 * ((1 << size-1) - (unsigned & ((1 << size-1) - 1)));
}
```

Java operator precedence: `-` binds tighter than `<<`, so `1 << size-1` is parsed as `1 << (size-1)`. This is the intended behavior but is non-obvious. No tests exist to verify that any specific size value produces the correct signed interpretation, including the boundary sizes used in the codebase (size 4, 8, 12, 16, 24, 32). `size = 0` causes a shift-by-negative-one which in Java means shift by `(-1 & 31) = 31`, producing an unexpected result.

Missing test cases:
- `unsignedToSigned(0x80, 8)` → should be `-128`
- `unsignedToSigned(0x7F, 8)` → should be `127`
- `unsignedToSigned(0, 8)` → should be `0`
- `unsignedToSigned(0x0800, 12)` → negative 12-bit value
- `unsignedToSigned(x, 0)` — degenerate size
- `unsignedToSigned(x, 1)` — minimum meaningful size

---

### A14-8 — `intToSignedBits` untested entirely

**Severity:** MEDIUM
**Location:** `BleUtil.java`, lines 217–222

`intToSignedBits` is the inverse of `unsignedToSigned` and shares the same operator-precedence pattern. It is not called from any code in the three assigned files (grep confirms no callers within BLE package). If it is dead code, that should be documented; if it is live, it has zero test coverage.

Missing test cases:
- `intToSignedBits(-1, 8)` — negative input
- `intToSignedBits(0, 8)`
- `intToSignedBits(127, 8)` — max positive that fits
- `intToSignedBits(-128, 8)` — min negative that fits

---

### A14-9 — `timezoneWithDstOffset` package-private, untested, null not guarded

**Severity:** MEDIUM
**Location:** `BleUtil.java`, lines 134–148

`timezoneWithDstOffset(Calendar time)` does not null-check `time`. No tests verify timezone offset encoding, DST offset encoding, or the LITTLE_ENDIAN byte ordering of the result. The BLE specification requires precise encoding; a wrong byte order or sign error would silently corrupt the device's time-zone setting.

Missing test cases:
- Null `time` argument
- UTC+0:00 (timezone = 0, DST = 0)
- UTC+1:00 (timezone = 4 per spec)
- UTC-1:00 (timezone = -4 per spec, encoded as signed byte)
- DST active vs inactive
- Byte order verification of output

---

### A14-10 — `getTimeData` depends on system time and has no deterministic test path

**Severity:** MEDIUM
**Location:** `BleUtil.java`, lines 91–125

`getTimeData()` calls `Calendar.getInstance(TimeZone.getTimeZone("GMT"))` with no injectable clock. This makes the method non-deterministic and untestable in isolation. The Sunday/non-Sunday day-of-week conversion (lines 103–108) is particularly fragile — if the conversion logic is wrong on any specific day of the week, the device receives the wrong day. No test exists.

Missing test cases:
- Sunday input (dayOfWeek should encode as 7)
- Monday input (dayOfWeek should encode as 1)
- Saturday input (dayOfWeek should encode as 6)
- December (month = 12, verifying +1 offset from Calendar.MONTH)
- January (month = 1, verifying +1 offset from Calendar.MONTH)
- Output byte array length is exactly 10
- Round-trip: `getTimeData()` output parsed by `parseBleTime()` yields matching values

---

### A14-11 — `bytesToFloat` (both overloads) untested

**Severity:** MEDIUM
**Location:** `BleUtil.java`, lines 186–201

Both `bytesToFloat` overloads perform IEEE 754 short-float and 32-bit SFLOAT decoding. These rely on `unsignedToSigned` (which has its own operator precedence issue, finding A14-7) and `Math.pow`. No tests verify any specific byte input produces the expected float value, nor are negative mantissa, zero, or maximum values tested.

Missing test cases (2-byte overload):
- Zero mantissa, zero exponent → 0.0
- Positive mantissa, positive exponent
- Negative mantissa (requires sign extension)
- Max representable 12-bit mantissa

Missing test cases (4-byte overload):
- Zero value
- Positive and negative values
- Extreme exponent values (b3 byte as signed)

---

## File 2: ShockEventService.java

**Fully qualified class name:**
`au.com.collectiveintelligence.fleetiq360.WebService.BLE.ShockEventService`

**Extends:** `android.app.IntentService`

**Methods (with line numbers and signatures):**

| Line | Signature |
|------|-----------|
| 28 | `public ShockEventService()` |
| 33 | `protected void onHandleIntent(Intent intent)` |
| 55 | `private void onShockDataRead(String address, Intent intent)` |
| 71 | `private void uploadEvent()` |
| 102 | `public static void startService()` |
| 109 | `static void sendData(Intent intent)` |
| 117 | `private static void saveShockEvent(String address, byte[] data)` |
| 147 | `private static void showShockAlertIfNeeded(ShockEventsItem shockEventsItem)` |

**Constants and fields defined:**

| Name | Type | Line |
|------|------|------|
| `TAG` | `public static String` | 26 |
| `lastShockEventsItem` | `private static ShockEventsItem` | 115 |
| `IMPACT` | `public static final String` | 144 |
| `lastImpactEvent` | `public static ShockEventsItem` | 145 |

---

### A14-12 — `saveShockEvent` null `data` parameter causes NullPointerException

**Severity:** CRITICAL
**Location:** `ShockEventService.java`, lines 117–142

`saveShockEvent(String address, byte[] data)` passes `data` directly to `BleUtil.getIntValue(data, FORMAT_UINT32, 0)` on line 118 without a null check. `BleUtil.getIntValue` does not guard against null `data` (see A14-4). When the BLE stack delivers a characteristic read with null data (network error, Bluetooth disconnect mid-read), this causes an unhandled `NullPointerException`. The NPE occurs inside `startService()` loop-context, which is silently swallowed by `IntentService`, causing the shock event to be silently lost.

Additionally, if `data` is fewer than 8 bytes, the second `getIntValue` call at offset 4 for a UINT32 (4 bytes) returns null, and `mm != null ? mm : 0` correctly defaults to 0 — but this silent zero-magnitude path is untested.

Missing test cases:
- `saveShockEvent("AA:BB:CC:DD:EE:FF", null)` — should not throw
- `saveShockEvent("AA:BB:CC:DD:EE:FF", new byte[0])` — both values default to 0
- `saveShockEvent("AA:BB:CC:DD:EE:FF", new byte[4])` — tt valid, mm null (defaults to 0)
- `saveShockEvent("AA:BB:CC:DD:EE:FF", new byte[8])` — both valid

---

### A14-13 — Duplicate event suppression logic relies on mutable static state, untested

**Severity:** HIGH
**Location:** `ShockEventService.java`, lines 133–139

The duplicate-suppression logic uses the static field `lastShockEventsItem` (line 115). The de-duplication condition is:

```java
if ((lastShockEventsItem == null ||
        !lastShockEventsItem.time.equals(shockEventsItem.time) ||
        !lastShockEventsItem.mac_address.equals(shockEventsItem.mac_address)) &&
        !ShockEventsDb.alreadySaved(shockEventsItem)) {
    showShockAlertIfNeeded(shockEventsItem);
}
```

Problems with no test coverage:
1. `lastShockEventsItem.mac_address` is never null-checked — if `mac_address` is null, `.equals()` throws NPE.
2. The logic shows an alert when either `time` OR `mac_address` differs from the last event, meaning a different device can re-trigger an alert for the same timestamp, and the same device with a different timestamp always triggers — test needed to validate intent.
3. Static state persists across service invocations in the same process; no test verifies reset behavior between calls.

Missing test cases:
- First call (null lastShockEventsItem)
- Same event repeated — should not re-alert
- Different MAC, same time — should alert
- Same MAC, different time — should alert
- Null `mac_address` in stored event

---

### A14-14 — `onHandleIntent` null intent action branch dispatches upload unconditionally

**Severity:** HIGH
**Location:** `ShockEventService.java`, lines 33–53

When `intent.getAction()` returns null, `uploadEvent()` is called and then a 10-minute delayed restart is scheduled via `MyApplication.runLater`. No test verifies:
1. A null-action intent triggers upload (not data processing).
2. A non-matching action string is silently ignored (falls through the `else` to no-op after logging UUID).
3. The 10-minute restart timer is correctly set up.
4. The `intent` itself being null (line 34 — `intent.getAction()` — would throw NPE if `intent` is null, which `IntentService` should never do but is unverified).

Missing test cases:
- Intent with null action → uploadEvent path
- Intent with `ACTION_DATA_AVAILABLE` and valid extras → onShockDataRead path
- Intent with `ACTION_DATA_CHANGED` → onShockDataRead path
- Intent with unrecognized action → no-op

---

### A14-15 — `showShockAlertIfNeeded` threshold boundary condition untested

**Severity:** CRITICAL
**Location:** `ShockEventService.java`, lines 147–163

This method determines whether a forklift impact is severe enough to trigger a safety alert. The threshold comparison is:

```java
shockEventsItem.magnitude <= equipmentItem.impact_threshold
```

If `magnitude` equals exactly `impact_threshold`, no alert fires. No test verifies this boundary, nor the conditions immediately above and below threshold. Additionally:

1. The method is `private static` — it cannot be directly invoked in a test without reflection or restructuring.
2. `equipmentItem.impact_threshold <= 0` suppresses all alerts when threshold is zero or negative — this guard is untested.
3. `equipmentItem.alert_enabled` flag can suppress all alerts — interaction with threshold untested.
4. MAC address mismatch between equipment and event suppresses alert — untested.

Missing test cases (all at safety-critical level):
- `magnitude == impact_threshold` → no alert (boundary)
- `magnitude == impact_threshold + 1` → alert fires (boundary + 1)
- `magnitude == impact_threshold - 1` → no alert (boundary - 1)
- `impact_threshold == 0` → no alert even for large magnitude
- `impact_threshold < 0` → no alert
- `alert_enabled == false` → no alert regardless of magnitude
- MAC address mismatch → no alert
- `sessionResult == null` → no alert
- `equipmentItem == null` → no alert

---

### A14-16 — `uploadEvent` failure path silently discards events

**Severity:** HIGH
**Location:** `ShockEventService.java`, lines 71–99

On upload success (line 88), `ShockEventsDb.removeData(realm, parameter)` is called to purge uploaded events. On failure (line 94), only a log line is emitted — events are retained in the database for the next upload cycle. No test verifies:
1. Events are not removed from the database when the API call fails.
2. Events are correctly removed when the API call succeeds.
3. Partial success (API succeeds but `removeData` throws) leaves the database in a consistent state.
4. Empty database (zero events) exits early without calling the API.

Missing test cases:
- Empty `shockEventsDbs` → no API call made
- Successful API response → events deleted from DB
- Failed API response → events retained in DB
- `removeData` throws → behavior

---

### A14-17 — `startService` silently swallows all exceptions

**Severity:** MEDIUM
**Location:** `ShockEventService.java`, lines 102–107

```java
public static void startService() {
    try {
        MyApplication.getContext().startService(...);
    } catch (Exception ignored) {
    }
}
```

All exceptions, including `SecurityException` (if the app loses foreground permission), `IllegalStateException` (Android 8+ background service restriction), or `NullPointerException` (if context is null), are silently swallowed. This means the periodic upload heartbeat can silently stop working with no logging and no user notification. No test verifies that service start failures are detectable.

Missing test cases:
- `startService()` when context returns null
- `startService()` when `startService` throws `IllegalStateException`

---

## File 3: ShockEventsDb.java

**Fully qualified class name:**
`au.com.collectiveintelligence.fleetiq360.WebService.BLE.ShockEventsDb`

**Extends:** `io.realm.RealmObject`

**Methods (with line numbers and signatures):**

| Line | Signature |
|------|-----------|
| 19 | `static RealmResults<ShockEventsDb> readData(Realm realm)` |
| 23 | `static void removeData(Realm realm, SaveShockEventParameter parameter)` |
| 36 | `static boolean alreadySaved(final ShockEventsItem result)` |
| 46 | `static void saveData(final ShockEventsItem result)` |
| 68 | `private static RealmResults<ShockEventsDb> getMatchingEvents(Realm realm, Date time, String macAddress)` |

**Fields defined:**

| Name | Type | Line |
|------|------|------|
| `mac_address` | `public String` | 15 |
| `time` | `public Date` | 16 |
| `magnitude` | `public long` | 17 |

---

### A14-18 — `alreadySaved` null result parameter inconsistency

**Severity:** MEDIUM
**Location:** `ShockEventsDb.java`, lines 36–44

`alreadySaved` correctly returns `false` for a null `result` (line 37). However, inside the Realm callback it calls `getMatchingEvents(realm, result.time, result.mac_address)` — if `result.time` or `result.mac_address` are null, the Realm query on line 69 (`equalTo("time", time)` and `equalTo("mac_address", macAddress)`) may behave unexpectedly or throw a `RealmException`. No test covers:
- `result` is null (currently returns false — this path is tested implicitly by inspection but not by automated test)
- `result.time` is null
- `result.mac_address` is null
- `result.mac_address` is empty string

---

### A14-19 — `saveData` delete-then-create pattern has no duplicate guard before create

**Severity:** HIGH
**Location:** `ShockEventsDb.java`, lines 46–66

`saveData` deletes all matching events then creates a new one within a single Realm transaction. If the delete succeeds but `realm.createObject` fails (e.g., disk full, Realm schema violation), the transaction is rolled back but the in-memory state may be inconsistent. More importantly:

1. If `saveData` is called concurrently for the same `(time, mac_address)` pair (both BLE reads arrive simultaneously from two BLE devices with the same event), the delete-create interleaving could result in duplicate records.
2. `result.time` and `result.mac_address` are not validated before being stored — null values would create a Realm object with null fields, potentially breaking `getMatchingEvents` queries later.

Missing test cases:
- `saveData(null)` — should return without action (line 47 guards this, but untested)
- `saveData` with valid event → record exists in DB after call
- `saveData` with duplicate event → only one record exists
- `saveData` with null `result.time`
- `saveData` with null `result.mac_address`

---

### A14-20 — `removeData` date parsing can silently fail to match records

**Severity:** HIGH
**Location:** `ShockEventsDb.java`, lines 23–34

`removeData` converts `item.impact_time` (a server-formatted String) back to a `Date` using `ServerDateFormatter.parseDateTime(item.impact_time)`. If the format does not exactly match what `saveData` stored (which formats via `ServerDateFormatter.formatDateTime`), the `getMatchingEvents` query returns zero results and `deleteAllFromRealm` deletes nothing. The uploaded events remain in the database indefinitely, causing them to be re-uploaded on every subsequent cycle — a silent data integrity failure.

No test verifies:
- A round-trip `saveData` → `removeData` leaves the database empty
- Date format mismatch between save and remove
- `impact_time` is null or malformed string — `parseDateTime` return value for invalid input

---

### A14-21 — `readData` returns all records with no pagination or limit, untested

**Severity:** MEDIUM
**Location:** `ShockEventsDb.java`, lines 19–21

`readData` performs `realm.where(ShockEventsDb.class).findAll()` with no limit. If the device accumulates shock events faster than it can upload them (e.g., persistent network failure), the unbounded result set is loaded into memory and serialized into a single `SaveShockEventParameter` list in `uploadEvent`. No test verifies behavior under large record counts, and no test verifies that the query returns an empty result when the database is empty.

Missing test cases:
- `readData` on empty database → empty RealmResults
- `readData` on database with one record → size == 1
- `readData` on database with large number of records (stress test)

---

### A14-22 — `getMatchingEvents` dual-field query semantics untested

**Severity:** MEDIUM
**Location:** `ShockEventsDb.java`, lines 68–70

`getMatchingEvents` queries by both `time` and `mac_address`. No test verifies:
- Same time, different MAC → no match
- Same MAC, different time → no match
- Both match → correct records returned
- `time` is null (Realm behavior with null Date query parameter is undefined without test)
- `macAddress` is null (same issue)

---

## Summary Table

| ID | File | Severity | Description |
|----|------|----------|-------------|
| A14-1 | Project-wide | HIGH | Zero automated test coverage in app/ and LibCommon/ modules |
| A14-2 | BleUtil.java | CRITICAL | `parseBleTime` null input causes NPE |
| A14-3 | BleUtil.java | HIGH | `isTimeSetSucceed` null arguments cause NPE |
| A14-4 | BleUtil.java | HIGH | `getIntValue` null data, negative offset, callers unbox null Integer |
| A14-5 | BleUtil.java | HIGH | `bytesToHexStr` null input causes NPE |
| A14-6 | BleUtil.java | MEDIUM | `isTheSameByteArray` null-null semantics undocumented, untested |
| A14-7 | BleUtil.java | HIGH | `unsignedToSigned` operator precedence bug risk, all size values untested |
| A14-8 | BleUtil.java | MEDIUM | `intToSignedBits` entirely untested, possibly dead code |
| A14-9 | BleUtil.java | MEDIUM | `timezoneWithDstOffset` null not guarded, byte encoding untested |
| A14-10 | BleUtil.java | MEDIUM | `getTimeData` non-deterministic, day-of-week conversion untested |
| A14-11 | BleUtil.java | MEDIUM | Both `bytesToFloat` overloads entirely untested |
| A14-12 | ShockEventService.java | CRITICAL | `saveShockEvent` null data causes NPE in safety-critical path |
| A14-13 | ShockEventService.java | HIGH | Duplicate suppression relies on mutable static, null mac_address NPE |
| A14-14 | ShockEventService.java | HIGH | `onHandleIntent` intent routing paths untested |
| A14-15 | ShockEventService.java | CRITICAL | Alert threshold boundary untested — safety-critical |
| A14-16 | ShockEventService.java | HIGH | Upload failure silently retains events, no test for delete-on-success |
| A14-17 | ShockEventService.java | MEDIUM | `startService` swallows all exceptions silently |
| A14-18 | ShockEventsDb.java | MEDIUM | `alreadySaved` null field values produce undefined Realm query behavior |
| A14-19 | ShockEventsDb.java | HIGH | `saveData` delete-then-create has no duplicate guard, null fields untested |
| A14-20 | ShockEventsDb.java | HIGH | `removeData` date format mismatch causes silent re-upload loop |
| A14-21 | ShockEventsDb.java | MEDIUM | `readData` unbounded query, empty-DB path untested |
| A14-22 | ShockEventsDb.java | MEDIUM | `getMatchingEvents` dual-field query semantics untested |
