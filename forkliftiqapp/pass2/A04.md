# Audit Pass 2 – Test Coverage
**Agent:** A04
**Audit run:** 2026-02-26-01
**Files assigned:**
1. `LibCommon/src/main/java/com/yy/libcommon/ErrorDialog.java`
2. `LibCommon/src/main/java/com/yy/libcommon/FileManager.java`
3. `LibCommon/src/main/java/com/yy/libcommon/Font/AMButton.java`

---

## PROJECT-WIDE FINDING

### A04-1 · HIGH · Zero automated test coverage across app/ and LibCommon/ modules

No `test/` or `androidTest/` source sets exist under either `app/src/` or `LibCommon/src/`. Both modules contain only a `main/` source tree. No unit tests, no instrumented tests, and no test resources are present anywhere in the repository.

**Impact:** Every class, every method, and every error path in the entire application is unverified by automated means. Regressions, behavioral changes, and defects introduced during development have no automated safety net. Every file-specific finding below describes a gap that is a direct consequence of this project-wide absence of tests.

**Evidence:**
```
LibCommon/src/  →  main/   (only)
app/src/        →  main/   (only)
```

---

## File 1: ErrorDialog.java

### Reading Evidence

**Fully qualified class name:** `com.yy.libcommon.ErrorDialog`
**Superclass:** `com.yy.libcommon.BaseDialog` (extends `DialogFragment`)

**Methods (with line numbers and signatures):**

| Line | Signature |
|------|-----------|
| 31 | `public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState)` |
| 40 | `public static ErrorDialog newInstance(String title, String content, String buttonText)` |
| 60 | `public void setOnErrorCallback(OnErrorCallback callback)` |
| 65 | `protected void setupViews()` |
| 106 | `public void onDismiss(DialogInterface dialog)` |

**Inner types defined:**

| Line | Type |
|------|------|
| 113 | `public static class OnErrorCallback` |
| 114 | `public void onCloseButton()` (inside OnErrorCallback – no-op default) |
| 117 | `public void onDismiss()` (inside OnErrorCallback – no-op default) |

**Constants/fields:**

| Line | Field |
|------|-------|
| 19 | `private TextView mTitleTextView` |
| 20 | `private TextView mErrorText` |
| 21 | `private TextView mCloseButton` |
| 23 | `private String mTitle` |
| 24 | `private String mContent` |
| 25 | `private String mCloseButtonText` |
| 27 | `private OnErrorCallback mCallback` |

---

### Findings

#### A04-2 · HIGH · `newInstance` has no corresponding test file

There is no test file for `ErrorDialog`. The factory method `newInstance(String, String, String)` is the primary API surface for this class. All three parameters are optional (null-guarded), and the method creates and partially initialises a dialog fragment. No test exercises this method under any combination of inputs.

**Untested paths in `newInstance` (lines 40–58):**
- All three arguments non-null (happy path)
- All three arguments null (all fields remain at Java default `null`)
- Mixed null/non-null combinations (6 additional permutations)

#### A04-3 · MEDIUM · `setupViews` null-branch for `mContent` uses `setHint("")` instead of `setText`

At line 83, when `mContent` is null, the code calls `mErrorText.setHint("")` rather than `mErrorText.setText("")`. This is a probable logic error: the hint of an empty string is invisible and the text view will display whatever its XML default text is. Because there is no test, this defect has never been caught by automation.

**Untested error path:** `setupViews()` called after `newInstance(title, null, buttonText)`.

#### A04-4 · MEDIUM · `onDismiss` callback invocation is untested

At lines 106–111, `onDismiss` calls `mCallback.onDismiss()` when the callback is non-null. The two paths (callback set vs. not set) are both untested. Specifically:
- No test verifies that `mCallback.onDismiss()` is invoked when the dialog is dismissed programmatically.
- No test verifies that no NPE occurs when `mCallback` is null at dismissal time.

#### A04-5 · MEDIUM · Close-button click path and `OnErrorCallback.onCloseButton()` are untested

At lines 92–102, a click listener on `mCloseButton` calls `dismiss()` and, if the callback is non-null, calls `mCallback.onCloseButton()`. Both the callback-set and callback-null branches are untested. The `OnErrorCallback` class itself (`onCloseButton`, `onDismiss`) is never exercised.

#### A04-6 · LOW · `setOnErrorCallback` is untested

The setter at line 60 is trivial, but it is the only mechanism by which callers register for close/dismiss events. No test verifies that a callback registered via this method is subsequently invoked by `setupViews` or `onDismiss`.

---

## File 2: FileManager.java

### Reading Evidence

**Fully qualified class name:** `com.yy.libcommon.FileManager`
**Pattern:** Singleton utility class

**Methods (with line numbers and signatures):**

| Line | Signature |
|------|-----------|
| 31 | `public static FileManager instance()` |
| 38 | `public static Bitmap readBitmapFromPath(String path)` |
| 54 | `public static File createFilePath(String fileFullPath)` |
| 88 | `public static String getFileDir()` |
| 95 | `public static File createLocalImageFile(String fileName)` |
| 111 | `public static void copyFile(File sourceFile, File destFile)` |
| 147 | `public static void safeDeleteFile(Context context, final String path)` |
| 181 | `public static String getFileTypeString()` |
| 185 | `public static String getLocalFileFolder()` |
| 189 | `public static String existingLocalFilePath(int key, int fileType)` |
| 197 | `public static String getLocalFilePath(int key, int fileType)` |
| 207 | `public static File getLocalFileInstance(int key)` |
| 217 | `public static String getLocalFileDir()` |
| 226 | `public static boolean isFileExist(String filePath)` |

**Constants (via LibConfig, referenced at lines 186, 200–201, 209–210, 219–220):**

| Constant | Value |
|----------|-------|
| `LibConfig.BASE_DIRECTOY` | `"ForkIQ360"` (note: typo "DIRECTOY") |
| `LibConfig.IMAGE_DIRECTORY` | `"images"` |

**Fields:**

| Line | Field |
|------|-------|
| 27 | `private static FileManager ourInstance` (singleton instance) |

---

### Findings

#### A04-7 · HIGH · Singleton `instance()` is not thread-safe and is untested

At lines 31–36, `instance()` performs a non-synchronized null check on `ourInstance`. Under concurrent access, two threads can both observe `ourInstance == null` and each construct a separate instance, violating the singleton contract. No test exercises concurrent invocation, and no test even verifies single-threaded singleton identity across multiple calls.

#### A04-8 · HIGH · `copyFile` silently swallows all exceptions (lines 126–128)

The catch block at line 126 catches `Exception` but contains no body — not even a log statement. If the source file does not exist, if a permission error occurs, or if the channel transfer fails, the failure is entirely invisible. No test exercises the failure path, and no test verifies that a failure is correctly surfaced to callers.

**Untested paths:**
- Source file does not exist
- Destination path is not writable
- `sourceFile` argument is null
- `destFile` argument is null
- `transferFrom` partial write (source larger than available space)

#### A04-9 · HIGH · `readBitmapFromPath` silently deletes a file on decode failure and is untested

At lines 45–47, if `BitmapFactory.decodeFile` returns null (corrupt file, unsupported format, insufficient memory), the file is deleted without any notification to the caller. The return value is also null in this case, so callers receive a null bitmap with no indication that the file was deleted. No test exercises this path, and no test verifies the delete side effect.

**Untested paths:**
- `path` is null → returns null (line 41 guard)
- File does not exist → returns null (line 43 guard)
- File exists but is corrupt/undecodable → file is silently deleted, null returned
- `path` is empty string (`""`) → `File("")` is constructed; behaviour is filesystem-dependent and untested

#### A04-10 · HIGH · `safeDeleteFile` uses deprecated `ACTION_MEDIA_MOUNTED` broadcast on pre-KITKAT (line 161–162)

At lines 160–162, on devices running Android < 4.4 (KITKAT), the code broadcasts `ACTION_MEDIA_MOUNTED` with a hardcoded `file://` URI pointing to the root of external storage. This broadcast is a privileged system broadcast that should not be sent by third-party applications, and the pattern is a known security anti-pattern. No test exercises this branch, and no test verifies that the media scanner is correctly notified without triggering unintended side effects.

#### A04-11 · MEDIUM · `createFilePath` has multiple untested error paths

At lines 54–86:
- If `fileFullPath` is null → `new File(null)` throws `NullPointerException`; no null guard exists.
- `file.getParent()` returns null for a bare filename with no directory component (line 59 handles this, but returns the bare `File` without creating it).
- `fileDir.mkdirs()` fails silently (prints to stdout but does not propagate failure).
- `file.createNewFile()` IOException is caught and stack-traced but the method still returns the File object regardless of whether creation succeeded.
- No test verifies the behaviour when `mkdirs()` returns false.
- No test verifies the behaviour when `createNewFile()` throws.

#### A04-12 · MEDIUM · `createLocalImageFile` does not test the timestamp-based filename branch

At lines 95–109, when `fileName` is null, a timestamp-derived filename is generated using `SimpleDateFormat` without a `Locale` argument (line 101). This is a known Android lint warning — the default locale can produce unexpected characters in filenames on some devices. No test exercises the null-filename branch, and no test verifies that the generated filename is valid for filesystem use.

#### A04-13 · MEDIUM · `existingLocalFilePath` ignores `fileType` parameter

At lines 189–195, the `fileType` parameter is accepted but never used. The file lookup uses only `key`, always appending `.jpg` regardless of `fileType`. No test verifies this behaviour, and no test exercises the case where a caller passes a non-zero `fileType` expecting a different extension.

Similarly, `getLocalFilePath(int key, int fileType)` at lines 197–205 ignores `fileType` in the same way.

#### A04-14 · MEDIUM · `isFileExist` does not guard against null input

At lines 226–229, `isFileExist(String filePath)` passes `filePath` directly to `new File(filePath)`. If `filePath` is null, `new File(null)` throws a `NullPointerException`. No null guard exists, and no test exercises this path.

#### A04-15 · LOW · `getFileTypeString`, `getLocalFileFolder`, `getFileDir` are untested trivial accessors

These three methods are trivial one-liners returning constants or delegating to another static method. While individually low-risk, their complete absence from any test suite means no regression protection exists even at this trivial level.

#### A04-16 · LOW · `getLocalFileDir`, `getLocalFilePath`, `getLocalFileInstance` use `Environment.getExternalStorageDirectory()` without permission check, and are untested

All three methods (lines 207–224) call `Environment.getExternalStorageDirectory()` unconditionally. On Android 6.0+ (API 23), `READ_EXTERNAL_STORAGE` / `WRITE_EXTERNAL_STORAGE` are runtime permissions. If not granted, operations on these paths fail silently or throw. No test verifies the paths returned are valid or accessible at runtime, and no test exercises the denied-permission path.

---

## File 3: Font/AMButton.java

### Reading Evidence

**Fully qualified class name:** `com.yy.libcommon.Font.AMButton`
**Superclass:** `android.widget.Button`

**Methods (with line numbers and signatures):**

| Line | Signature |
|------|-----------|
| 17 | `public AMButton(Context context)` |
| 23 | `public AMButton(Context context, AttributeSet attrs)` |
| 29 | `public AMButton(Context context, AttributeSet attrs, int defStyle)` |
| 36 | `private void applyCustomFont(Context context, AttributeSet attrs)` |

**Constants/fields:** None defined directly; relies on `R.styleable.AMTextView` and `R.styleable.AMTextView_ttf_type` from the resource layer, and delegates font resolution to `FontCache.getTypeFace`.

---

### Findings

#### A04-17 · HIGH · `applyCustomFont` accesses `R.styleable.AMTextView` on an `AMButton`, and this is untested

At line 42, `applyCustomFont` calls `getContext().obtainStyledAttributes(attrs, R.styleable.AMTextView)`. The styled attribute set is named `AMTextView` but is being applied to a `Button` subclass. If the XML layout does not declare the `AMTextView` attribute namespace for this button, `a.getString(R.styleable.AMTextView_ttf_type)` will return null. The `TypedArray` returned by `obtainStyledAttributes` is also never recycled (no `a.recycle()` call), which is a resource leak. No test exercises any constructor of this class, and no test verifies the attribute resolution or the typeface application.

**Untested paths:**
- `attrs` is null → constructor at line 17, `applyCustomFont` bypasses styled-attribute block (line 41 guard), `typeface` remains null, `setTypeface` is never called — correct behaviour but untested.
- `attrs` non-null, `ttf_type` attribute absent → `getString` returns null → `FontCache.getTypeFace` returns the default font.
- `attrs` non-null, `ttf_type` is one of the recognised values (`"bold"`, `"light"`, `"medium"`, `"thin"`, `"untrathin"`) → correct font loaded, but no test verifies any of these branches.
- `attrs` non-null, `ttf_type` is an unrecognised string → falls through to the default font in `FontCache.getTypeFace`.
- `FontCache.getTypeFace` returns null (asset missing) → `typeface` is null at line 46, `setTypeface` is not called → button renders with system default font; no test verifies this fallback.

#### A04-18 · MEDIUM · `TypedArray` is never recycled in `applyCustomFont` (resource leak, line 42–44)

`obtainStyledAttributes` allocates a `TypedArray` that must be recycled by calling `a.recycle()` after use (Android framework requirement). The method at line 36–50 obtains the array at line 42 but never calls `a.recycle()`. This leaks memory on every inflation of an `AMButton` from XML. No test exists to detect this leak.

#### A04-19 · LOW · All three constructors delegate to `applyCustomFont` but none are individually tested

The three constructors at lines 17, 23, and 29 cover the three standard Android `View` constructor signatures. Each calls `applyCustomFont` with different arguments. No test instantiates `AMButton` via any of these constructors, so the delegation chain is entirely unverified.

#### A04-20 · INFO · Typo "untrathin" in `FontCache.getTypeFace` (line 55) affects `AMButton` font resolution

In `FontCache.getTypeFace` (a dependency of `AMButton`), the string comparison at line 55 checks for `"untrathin"` rather than `"ultrathin"`. Any layout that specifies `ttf_type="ultrathin"` will not match this branch and will fall through to the default font. Because there are no tests for either `AMButton` or `FontCache`, this defect is undetected by automation. (Reported here as it surfaces through `AMButton`'s call to `FontCache.getTypeFace`.)

---

## Summary Table

| ID | Severity | File | Description |
|----|----------|------|-------------|
| A04-1 | HIGH | Project-wide | Zero automated test coverage in app/ and LibCommon/ modules |
| A04-2 | HIGH | ErrorDialog.java | `newInstance` factory has no test for any input combination |
| A04-3 | MEDIUM | ErrorDialog.java | `setupViews` null-content branch uses `setHint("")` instead of `setText` — untested defect |
| A04-4 | MEDIUM | ErrorDialog.java | `onDismiss` callback invocation paths (callback set vs. null) untested |
| A04-5 | MEDIUM | ErrorDialog.java | Close-button click and `OnErrorCallback.onCloseButton()` untested |
| A04-6 | LOW | ErrorDialog.java | `setOnErrorCallback` setter untested |
| A04-7 | HIGH | FileManager.java | Singleton `instance()` not thread-safe and untested |
| A04-8 | HIGH | FileManager.java | `copyFile` silently swallows all exceptions with empty catch block |
| A04-9 | HIGH | FileManager.java | `readBitmapFromPath` silently deletes file on decode failure, untested |
| A04-10 | HIGH | FileManager.java | `safeDeleteFile` uses deprecated privileged broadcast on pre-KITKAT, untested |
| A04-11 | MEDIUM | FileManager.java | `createFilePath` null input causes NPE; failure paths untested |
| A04-12 | MEDIUM | FileManager.java | `createLocalImageFile` null-filename branch uses no-locale `SimpleDateFormat`, untested |
| A04-13 | MEDIUM | FileManager.java | `existingLocalFilePath` and `getLocalFilePath` ignore `fileType` parameter, untested |
| A04-14 | MEDIUM | FileManager.java | `isFileExist` has no null guard; NPE on null input, untested |
| A04-15 | LOW | FileManager.java | Trivial accessors `getFileTypeString`, `getLocalFileFolder`, `getFileDir` untested |
| A04-16 | LOW | FileManager.java | External storage path methods use `Environment.getExternalStorageDirectory()` without permission check, untested |
| A04-17 | HIGH | AMButton.java | `applyCustomFont` misuses `AMTextView` styled-attribute set on a Button; all branches untested |
| A04-18 | MEDIUM | AMButton.java | `TypedArray` resource leak — `a.recycle()` never called in `applyCustomFont` |
| A04-19 | LOW | AMButton.java | All three constructors untested |
| A04-20 | INFO | AMButton.java | Typo `"untrathin"` vs `"ultrathin"` in `FontCache.getTypeFace` means `AMButton` cannot load the ultrathin font variant |
