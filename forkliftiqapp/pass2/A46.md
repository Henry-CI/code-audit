# Audit Pass 2 — Agent A46
**Files:** LocationDb.java, ModelPrefs.java, MyCommonValue.java
**Audit run:** 2026-02-26-01
**Auditor:** A46

---

## PROJECT-WIDE FINDING (applies to all files)

### A46-1 | HIGH | Zero automated test coverage across app/ and LibCommon/

No `test/` or `androidTest/` directory exists under the `app/` module. The only test
directories found in the repository belong to third-party library modules
(`LibImageloader`, `LibImagePicker`, `LibPercentProgress`) that are not project code.
Every finding below describes a gap that cannot be caught by any automated means. All
defects must be discovered at runtime or through manual inspection. This is a project-wide
condition, not a file-specific one, and it amplifies the severity of every other finding
in this report.

---

## File 1: LocationDb.java

**Path:**
`/c/Projects/cig-audit/repos/forkliftiqapp/app/src/main/java/au/com/collectiveintelligence/fleetiq360/model/LocationDb.java`

### Reading Evidence

**Fully qualified class name:**
`au.com.collectiveintelligence.fleetiq360.model.LocationDb`
Extends: `io.realm.RealmObject`

**Fields / constants (all public):**

| Name | Type | Line | Notes |
|---|---|---|---|
| `TAG` | `static String` | 24 | Initialised to simple class name |
| `userKey` | `int` | 26 | Initialised inline from `WebData.instance().getUserId()` at field-declaration time |
| `unit_id` | `int` | 28 | Realm-persisted GPS unit identifier |
| `longitude` | `Double` | 29 | GPS coordinate (nullable boxed Double) |
| `latitude` | `Double` | 30 | GPS coordinate (nullable boxed Double) |
| `gps_time` | `String` | 31 | GPS timestamp, plain String |

**Methods:**

| Line | Visibility | Signature |
|---|---|---|
| 33 | `public static` | `ArrayList<LocationDb> readAllLocationToSync()` |
| 43 | `static` (package) | `RealmResults<LocationDb> readData(Realm realm)` |
| 47 | `public static` | `void removeData(SaveSingleGPSParameter saveSingleGPSParameter)` |
| 64 | `static` (package) | `void removeData(Realm realm, SaveMultipleGPSParameter parameter)` |
| 76 | `private static` | `RealmResults<LocationDb> getMatchingRecord(Realm realm, int unit_id)` |
| 81 | `public static` | `void uploadLocation()` |
| 112 | `public static` | `void saveNewLocation(SaveSingleGPSParameter saveSingleGPSParameter)` |

**No test file exists for this class.**

---

### Findings — LocationDb.java

#### A46-2 | HIGH | No test for `readAllLocationToSync()` returning an empty list

`readAllLocationToSync()` (line 33) delegates to `DataBaseHelp.getRealmQuery` and calls
`findAll()`. When the Realm database is empty the method returns an empty `ArrayList`.
Callers (e.g. `SyncService`) receive that empty list with no indication of whether the
read succeeded or the database was unavailable. There is no test that:

- seeds an empty Realm and asserts a non-null, zero-element list is returned;
- distinguishes between "no records" and a Realm initialisation failure (which would
  throw an unchecked exception propagated to the caller).

**Evidence:** Line 33-41. The method wraps `SafeRealm.Execute` which returns the result of
`func.Execute(realm)`; if `Realm.getDefaultInstance()` throws, the exception escapes
uncaught.

---

#### A46-3 | HIGH | No test for duplicate inserts via `saveNewLocation()`

`saveNewLocation()` (line 112) first deletes all existing records matching `unit_id` via
`getMatchingRecord` (line 118), then creates a new `LocationDb` object (line 124). This
delete-then-insert pattern is the mechanism that prevents duplicates. There is no test
verifying that:

- calling `saveNewLocation()` twice for the same `unit_id` results in exactly one record;
- calling `saveNewLocation()` for two different `unit_id` values results in two distinct
  records rather than one overwriting the other.

If `getMatchingRecord` or the delete transaction silently fails, stale GPS coordinates
accumulate in Realm and are uploaded to the server under the wrong unit ID.

**Evidence:** Lines 112-133.

---

#### A46-4 | MEDIUM | No test for `removeData(SaveSingleGPSParameter)` with null parameter

`removeData(SaveSingleGPSParameter)` (line 47) guards against a null argument with an
early return at line 48. There is no test asserting that passing `null` is silently
tolerated without side effects, nor that the Realm is left in a consistent state. The
guard is correct but unverified — a future refactor that reorders or removes the guard
has no regression protection.

**Evidence:** Lines 47-62.

---

#### A46-5 | MEDIUM | No test for `uploadLocation()` when the network call fails

`uploadLocation()` (line 81) reads all records, constructs a `SaveMultipleGPSParameter`,
calls `WebApi.sync().saveMultipleGPSLocation(...)`, and on success deletes the records
from Realm. The `onFailed` callback (line 104) logs the failure and takes no further
action — the records are retained for the next upload cycle. There is no test verifying
that:

- records are NOT deleted from Realm when the upload fails;
- records ARE deleted from Realm when the upload succeeds;
- `uploadLocation()` is a no-op (returns before network call) when the result set is
  empty (line 88-89).

An incorrect implementation could silently lose GPS data or cause infinite retry loops.

**Evidence:** Lines 81-110.

---

#### A46-6 | MEDIUM | No test for concurrent write safety in `saveNewLocation()`

`saveNewLocation()` is called from a background GPS location service. If two rapid GPS
fixes arrive before the first Realm transaction commits, both transactions may read the
same existing records via `getMatchingRecord`, and whichever transaction commits second
may attempt to delete records already deleted by the first. Realm's transactional
isolation should protect against corruption, but the app's behaviour under concurrent
invocations (record count, data integrity) is entirely untested.

**Evidence:** Lines 112-133; the outer `SafeRealm.Execute` at line 115 acquires a fresh
Realm instance per call; no mutex or serial executor is used.

---

#### A46-7 | MEDIUM | GPS coordinates stored in unencrypted Realm database — no encryption test

`latitude` and `longitude` fields (lines 29-30) are persisted as plaintext in the default
Realm database file. Realm supports an encryption key at initialisation time via
`RealmConfiguration.Builder.encryptionKey()`. There is no test (and no observable
configuration in `SafeRealm` at lines 7-10) confirming that the Realm instance is
opened with encryption enabled. On a non-rooted device this represents a MEDIUM risk; on
a rooted or compromised device, precise historical GPS tracks for every forklift unit are
readable by any process with storage access.

**Evidence:** `SafeRealm.Execute` at line 8 calls `Realm.getDefaultInstance()` with no
configuration object; `LocationDb` fields at lines 29-30.

---

#### A46-8 | LOW | `userKey` initialised at field-declaration time, not inside a transaction

`userKey` (line 26) is initialised with `WebData.instance().getUserId()` at the point the
Java class is loaded or when a `LocationDb` object is constructed outside a Realm
transaction. Realm requires that managed objects be created inside `realm.createObject()`
within a transaction. The `saveNewLocation` method correctly creates a `LocationDb` via
`realm.createObject(LocationDb.class)` (line 124) and then assigns fields, so this
declaration-time initialisation applies only to unmanaged instances. However, if the
field is read from an unmanaged instance before it is explicitly set, the `userKey` will
reflect whatever user was logged in at the time the default was evaluated — which may be
no user (returning `-1`). There is no test covering this edge case.

**Evidence:** Line 26 vs lines 119-128.

---

## File 2: ModelPrefs.java

**Path:**
`/c/Projects/cig-audit/repos/forkliftiqapp/app/src/main/java/au/com/collectiveintelligence/fleetiq360/model/ModelPrefs.java`

### Reading Evidence

**Fully qualified class name:**
`au.com.collectiveintelligence.fleetiq360.model.ModelPrefs`
Extends: `java.lang.Object` (implicitly)

**Fields / constants:** None declared. All methods are static; the class carries no
instance state.

**Methods:**

| Line | Visibility | Signature |
|---|---|---|
| 16 | `static` (package) | `SharedPreferences getPref()` |
| 22 | `public static` | `void saveInt(String key, int d)` |
| 26 | `public static` | `int readInt(String key)` |
| 31 | `public static` | `void deleteDataForKey(String key)` |
| 36 | `public static` | `void saveString(String key, String s)` |
| 40 | `public static` | `String readString(String key)` |
| 45 | `public static` | `void saveBoolean(String key, boolean s)` |
| 49 | `public static` | `boolean readBoolean(String key)` |
| 53 | `public static` | `void saveObject(String key, Object object)` |
| 61 | `public static` | `Object readObject(String key, Class<?> classType)` |

**No test file exists for this class.**

---

### Findings — ModelPrefs.java

#### A46-9 | CRITICAL | Bearer token stored in plaintext SharedPreferences — no test verifying token is cleared on logout

`WebData.setGetTokenResult()` (WebData.java line 91-93) calls
`ModelPrefs.saveObject(TOKEN_ITEM_KEY, result)`, which serialises the entire
`GetTokenResult` object (including the `value` field — the raw bearer token string, and
the `refreshToken` nested object) to JSON via `GsonHelper.stringFromObjectNoPolicy` and
writes it to the `"prefs"` SharedPreferences file using `Context.MODE_PRIVATE`.

On Android, `MODE_PRIVATE` files are stored at
`/data/data/<package>/shared_prefs/prefs.xml`. On rooted devices, emulators, or devices
exploited via backup extraction (`adb backup` on older Android versions), this file is
accessible in plaintext. The token grants full API access to the fleet management backend
for all vehicles managed by the company account.

`WebData.logout()` (line 108-110) calls only `CurrentUser.logout()`, which calls
`ModelPrefs.deleteDataForKey(CURRENT_USER_ID_KEY)` (CurrentUser.java line 126). The
`TOKEN_ITEM_KEY` (`"token_result"`) entry is **never removed** from SharedPreferences on
logout. The in-memory `getTokenResult` field on the `WebData` singleton is not cleared
either (there is no `getTokenResult = null` in the logout path). This means that after
logout:

1. The bearer token remains in `prefs.xml` on disk.
2. The next call to `getTokenString()` (line 117-122) reads the token back from
   SharedPreferences and reuses it, because `getTokenResult` is `null` after JVM garbage
   collection but the disk copy persists.
3. A second user logging in on the same device will make API calls authenticated with the
   previous user's token until a new token is fetched.

There is no test verifying that the token key is absent from SharedPreferences after
logout, and no test verifying that the in-memory singleton does not retain a stale token.

**Evidence:**
- `ModelPrefs.saveObject` at lines 53-59 (plaintext JSON serialisation).
- `WebData.setGetTokenResult` at WebData.java lines 91-93.
- `WebData.logout` / `CurrentUser.logout` — neither clears `TOKEN_ITEM_KEY`.
- `WebData.getTokenString` at lines 117-122 reads from SharedPreferences when memory
  field is null.

---

#### A46-10 | HIGH | No test that `readObject()` handles a missing or corrupt JSON value

`readObject()` (line 61-64) calls `getPref().getString(key, "")` and passes the result
directly to `GsonHelper.objectFromString`. If the stored value is an empty string (the
default), or if the JSON is malformed, the behaviour depends entirely on
`GsonHelper.objectFromString`. No null-safety or exception handling wraps this call. A
malformed or partially written SharedPreferences value (e.g., from an interrupted write)
will propagate a `JsonSyntaxException` or similar to the caller. The callers
(e.g., `WebData.getTokenString` at line 119) assume the return value is either a valid
object or `null` — they do not catch unchecked exceptions.

There is no test covering:
- `readObject` with an empty-string stored value returning `null` gracefully;
- `readObject` with a corrupt JSON string not throwing an unchecked exception to the
  caller.

**Evidence:** Lines 61-64; `WebData.getTokenString` line 119.

---

#### A46-11 | HIGH | `saveObject()` silently stores an empty string when `object` is null — no test

`saveObject()` (line 53-59) stores the string `""` when `object` is `null`. A subsequent
`readObject()` call for the same key will pass `""` to `GsonHelper.objectFromString`,
whose return value is implementation-defined (likely `null`, but not guaranteed). This
creates a semantic ambiguity: the caller cannot distinguish "key was never written" from
"null was explicitly saved". There is no test verifying:

- that `saveObject(key, null)` followed by `readObject(key, SomeClass.class)` returns
  `null` (not a default-constructed object or an exception);
- that `readObject` on a never-written key returns `null`.

**Evidence:** Lines 53-64.

---

#### A46-12 | MEDIUM | `commit()` used instead of `apply()` — blocking main-thread write, no test for failure

Every write method (`saveInt`, `saveString`, `saveBoolean`, `saveObject`, `deleteDataForKey`)
uses `.commit()` (lines 23, 33, 38, 58) rather than `.apply()`. `commit()` is a
synchronous disk write that blocks the calling thread. If any of these methods are called
from the main (UI) thread — which is likely given that `logout()` is triggered from UI
fragments — the write blocks the UI thread for the duration of the disk operation.
`commit()` also returns a boolean indicating success or failure; this return value is
discarded in every call site in `ModelPrefs`. There is no test verifying that write
failures are detected or handled.

**Evidence:** Lines 23, 33, 38, 45 (implicitly via `.commit()`), 58.

---

#### A46-13 | MEDIUM | `readInt()` returns 0 for missing keys — no test distinguishing "absent" from "stored zero"

`readInt(String key)` (line 26-28) returns `getPref().getInt(key, 0)`. Callers cannot
distinguish between a key that was never written and a key explicitly saved as `0`. For
`"last_session_id"` (WebData.java line 30-32), an absent key returns `0`, which is then
treated as a valid non-negative session ID, causing the temp-session counter to start at
`-1` rather than indicating an uninitialised state. There is no test confirming this
distinction or documenting the intended sentinel value.

**Evidence:** Lines 26-28; WebData.java lines 29-33.

---

## File 3: MyCommonValue.java

**Path:**
`/c/Projects/cig-audit/repos/forkliftiqapp/app/src/main/java/au/com/collectiveintelligence/fleetiq360/model/MyCommonValue.java`

### Reading Evidence

**Fully qualified class name:**
`au.com.collectiveintelligence.fleetiq360.model.MyCommonValue`
Extends: `java.lang.Object` (implicitly)

**Methods:** None. The class defines only static fields; it has no constructor, no
instance methods, and no static methods.

**Fields / constants (all public static):**

| Name | Type | Line | Initial value |
|---|---|---|---|
| `currentEquipmentItem` | `EquipmentItem` | 10 | `null` |
| `isCheckLocationPermissionDone` | `Boolean` | 11 | `false` |
| `companyName` | `String` | 13 | `""` |
| `companyContract` | `String` | 14 | `""` |
| `companyRole` | `String` | 15 | `""` |
| `companyenabled` | `String` | 16 | `""` |

**No test file exists for this class.**

---

### Findings — MyCommonValue.java

#### A46-14 | HIGH | Static session state is never cleared between operator sessions — no test

`MyCommonValue` is a bag of static (class-level) fields that survive for the lifetime of
the JVM process. When one operator logs out and a second operator logs in on the same
device without the app process being killed, the following state from the previous session
persists:

- `currentEquipmentItem` (line 10): retains the previous operator's last-active
  equipment item. Multiple callers dereference this field without null-checking:
  - `SessionActivity.java` line 42: `MyCommonValue.currentEquipmentItem.mac_address`
    — direct field access after a null check at line 37, but the null check only
    triggers a re-read from the database if the field is `null`; if it is non-null but
    belongs to the previous session it is used as-is.
  - `MyApplication.java` line 171: `MyCommonValue.currentEquipmentItem.id` — no null
    check; will throw `NullPointerException` if cleared, but leaves stale data in place
    if not cleared.
  - `EquipmentPrestartFragment.java` line 112, `UniversityGuideFragment.java` line 33,
    `JobsFragment.java` line 70: all access `.trained`, `.id` fields directly.

- `companyName`, `companyContract`, `companyRole`, `companyenabled` (lines 13-16):
  these fields appear to be written elsewhere but grep across the full codebase finds no
  write sites — they remain at their empty-string defaults for the entire run of the app.
  No code clears them on logout.

- `isCheckLocationPermissionDone` (line 11): if set to `true` during one session (by
  `FleetFragment.java` line 208), a new operator never re-triggers the location
  permission check. This is a logic error that masquerades as a test gap.

`WebData.logout()` / `CurrentUser.logout()` clear only the user ID preference and the
in-memory `CurrentUser.user` field. No code path sets `MyCommonValue.currentEquipmentItem`
to `null` or resets the company fields. There is no test verifying that any of these
static fields are in their default state after logout.

**Evidence:**
- `MyCommonValue.java` lines 10-16.
- `CurrentUser.logout()` at CurrentUser.java lines 125-128.
- `WebData.logout()` at WebData.java lines 108-110.
- Usages: EquipmentDriverAccessPresenter.java line 45, 48, 118-119, 277;
  FleetActivity.java line 269, 335; SessionActivity.java lines 37-42;
  FleetFragment.java lines 207-208; ShockEventService.java line 149;
  MyApplication.java line 171; DashboardFragment.java line 157;
  EquipmentConnectFragment.java lines 190, 214; EquipmentPrestartFragment.java line 112;
  EquipmentListFragment.java line 177; JobsFragment.java line 70;
  UniversityGuideFragment.java line 33.

---

#### A46-15 | HIGH | `currentEquipmentItem` is public and mutable — concurrent access entirely untested

`currentEquipmentItem` is a plain `public static` field with no synchronisation. It is
read and written from multiple components:

- Written in `EquipmentListFragment` (UI thread), `FleetActivity` (UI thread),
  `EquipmentDriverAccessPresenter` (may be background), `DashboardFragment` (UI thread).
- Read in `SessionActivity` (UI thread), `ShockEventService` (background BLE service
  thread), `MyApplication` (system callback thread), `EquipmentConnectFragment`,
  `EquipmentPrestartFragment`, `JobsFragment`, `UniversityGuideFragment`.

A background BLE event received in `ShockEventService` while the UI writes
`currentEquipmentItem` produces a data race. On the Java memory model, without
`volatile` or synchronisation, the background thread may see a stale or partially
constructed value. There is no test exercising concurrent access.

**Evidence:** `MyCommonValue.java` line 10 (`public static EquipmentItem`);
ShockEventService.java line 149; MyApplication.java line 171; multiple UI fragments.

---

#### A46-16 | MEDIUM | `isCheckLocationPermissionDone` flag is never reset — no test

`isCheckLocationPermissionDone` (line 11) is set to `true` by `FleetFragment` (line 208)
and never reset to `false` by any code path in the project. As a result, if the user
denies the location permission and then relaunches the app without the process being
killed, the permission check is skipped on the second launch. There is no test asserting
that the flag is reset to `false` after logout or at the start of a new session, and no
test verifying that permission is re-requested when it has been denied.

**Evidence:** `MyCommonValue.java` line 11; `FleetFragment.java` lines 207-208; grep
across the full codebase finds no other write to `isCheckLocationPermissionDone`.

---

#### A46-17 | LOW | `companyName`, `companyContract`, `companyRole`, `companyenabled` are declared but never written

These four string fields (lines 13-16) are declared `public static` with empty-string
defaults. A codebase-wide grep finds no write sites outside the class declaration itself.
They are also never read by any class other than `MyCommonValue.java` itself. The fields
appear to be dead code or placeholders for future integration. There is no test confirming
they remain empty-string defaults throughout the session, nor any documentation of their
intended use. If they are intended to carry company-level data loaded at login, the
missing write path is a functional defect, not merely a test gap.

**Evidence:** `MyCommonValue.java` lines 13-16; grep result: only one file contains
references to these fields.

---

## Summary Table

| ID | File | Severity | Title |
|---|---|---|---|
| A46-1 | Project-wide | HIGH | Zero automated test coverage in app/ and LibCommon/ |
| A46-2 | LocationDb.java | HIGH | No test for `readAllLocationToSync()` with empty database |
| A46-3 | LocationDb.java | HIGH | No test for duplicate-insert prevention in `saveNewLocation()` |
| A46-4 | LocationDb.java | MEDIUM | No test for null-parameter guard in `removeData()` |
| A46-5 | LocationDb.java | MEDIUM | No test for upload failure leaving records intact in `uploadLocation()` |
| A46-6 | LocationDb.java | MEDIUM | No test for concurrent invocation of `saveNewLocation()` |
| A46-7 | LocationDb.java | MEDIUM | GPS coordinates in unencrypted Realm — no encryption test |
| A46-8 | LocationDb.java | LOW | `userKey` initialised at field-declaration time — stale user risk untested |
| A46-9 | ModelPrefs.java | CRITICAL | Bearer token in plaintext SharedPreferences; not cleared on logout |
| A46-10 | ModelPrefs.java | HIGH | No test for `readObject()` with missing or corrupt JSON |
| A46-11 | ModelPrefs.java | HIGH | `saveObject(key, null)` stores empty string — ambiguous, untested |
| A46-12 | ModelPrefs.java | MEDIUM | `commit()` blocks UI thread; return value discarded, failure untested |
| A46-13 | ModelPrefs.java | MEDIUM | `readInt()` returns 0 for absent keys — no test distinguishing absent from zero |
| A46-14 | MyCommonValue.java | HIGH | Static session state never cleared between operator sessions |
| A46-15 | MyCommonValue.java | HIGH | `currentEquipmentItem` accessed from multiple threads without synchronisation |
| A46-16 | MyCommonValue.java | MEDIUM | `isCheckLocationPermissionDone` never reset — permission re-check skipped |
| A46-17 | MyCommonValue.java | LOW | `companyName/Contract/Role/enabled` declared but never written — dead code |
