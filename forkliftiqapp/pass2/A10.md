# Audit Pass 2 — Agent A10
**Audit run:** 2026-02-26-01
**Agent:** A10
**Files assigned:**
1. `LibCommon/src/main/java/com/yy/libcommon/Util.java`
2. `LibCommon/src/main/java/com/yy/libcommon/WebActivity.java`
3. `LibCommon/src/main/java/com/yy/libcommon/WebService/GsonHelper.java`

---

## PROJECT-WIDE FINDING

### A10-1 — HIGH: Zero automated test coverage across app/ and LibCommon/ modules

No `test/` or `androidTest/` directories exist under the `app/` or `LibCommon/` modules. The only test files in the entire repository are in third-party library modules (`LibImageloader` and `LibImagePicker`), which are not production application code. Every class, method, and logic path in `app/` and `LibCommon/` is entirely untested by automated means.

This is a project-wide structural gap. All file-specific findings below exist within this zero-coverage context. Any logic error, regression, or security vulnerability introduced into these modules would go undetected by the test suite.

**Affected modules:** `app/`, `LibCommon/`
**Severity:** HIGH

---

## File 1: `Util.java`

### Reading Evidence

**Fully qualified class name:** `com.yy.libcommon.Util`

**Constants defined:**
- Line 44: `public static final int MAX_UPLOAD_IMAGE_SIZE = 480`

**Methods (with line numbers and signatures):**

| Line | Signature |
|------|-----------|
| 46 | `public static ArrayList<String> arrayListFromStrings(String[] ar)` |
| 56 | `public static String generateDeviceId(Context pContext)` |
| 86 | `public static String colorToHexString(int color)` |
| 90 | `public static int dpToPx(int dp, Context pContext)` |
| 103 | `public static int dpToPx(float dp, Context pContext)` |
| 116 | `public static String getLastDigitSufix(int number)` |
| 126 | `public static String getRandomInstanceId()` |
| 134 | `public static String getRandomString()` |
| 150 | `public static int getRandomNumber()` |
| 168 | `public static boolean isStringEmpty(String input)` |
| 172 | `public static void setLayoutClickable(View view, boolean enabled)` |
| 190 | `public static Bitmap decodeFile(String path, int maxSize)` |
| 194 | `public static Bitmap decodeFile(File f, int maxSize)` |
| 236 | `public static byte[] preProcessBitmapToByteArray(String pathToOurFile)` |
| 257 | `public static Bitmap preProcessBitmap(Bitmap bitmap, ByteArrayOutputStream byteArrayOutputStream)` |
| 281 | `public static Bitmap decodeFileFixOrientation(String file)` |
| 309 | `public static String bigDecimalToPriceStr(BigDecimal bigDecimal)` |
| 313 | `public static boolean bigDecimalsAreTheSame(BigDecimal bd1, BigDecimal bd2)` |
| 340 | `public static boolean integersAreTheSame(Integer i1, Integer i2)` |
| 367 | `public static String getRealPathFromURI(Context context, Uri contentUri)` |

**No test file exists.** Confirmed: no `UtilTest.java` or equivalent exists anywhere in the repository's `app/` or `LibCommon/` test directories (those directories do not exist).

---

### Findings for `Util.java`

#### A10-2 — HIGH: `generateDeviceId` — no test for null WifiManager / null WifiInfo

**Lines 56–84**

The method calls `pContext.getSystemService(Context.WIFI_SERVICE)` and immediately dereferences the result without a null check:
```java
WifiManager wifiMan = (WifiManager) pContext.getSystemService(Context.WIFI_SERVICE);
WifiInfo wifiInf = wifiMan.getConnectionInfo();  // NPE if wifiMan is null
```
`getSystemService` can return `null` on certain devices or API levels. There is a `catch (NullPointerException e)` block further down (line 72) that only covers the `UUID` constructor call, not the earlier dereferences. A `NullPointerException` from `wifiMan.getConnectionInfo()` will propagate uncaught.

Additionally, there is no test for the path where `pContext` itself is `null`.

No test exercises any path through this method.

**Severity:** HIGH

---

#### A10-3 — HIGH: `generateDeviceId` — MAC address deprecated and returns constant on API 23+; UUID becomes deterministic collision

**Lines 56–84**

On Android 6.0+ (API 23+), `WifiInfo.getMacAddress()` returns the constant string `"02:00:00:00:00:00"` for privacy reasons. Combined with a fixed `ANDROID_ID`, every device on API 23+ will return the same UUID if `ANDROID_ID` is also the same (e.g., emulators or factory-reset devices sharing the same `ANDROID_ID`). There is no test exercising this scenario, so the collision behavior is undetected.

**Severity:** HIGH

---

#### A10-4 — MEDIUM: `isStringEmpty` — semantic inversion not tested; `null` input returns `false`

**Line 168–170**
```java
public static boolean isStringEmpty(String input){
    return (input != null && input.length() == 0);
}
```
The method returns `false` for `null` input, which is counterintuitive — callers expecting `null` to be treated as "empty" will receive incorrect results. No test verifies:
- `isStringEmpty(null)` returns `false` (surprising to most callers)
- `isStringEmpty("")` returns `true`
- `isStringEmpty(" ")` returns `false` (whitespace-only string treated as non-empty)
- `isStringEmpty("abc")` returns `false`

The name strongly implies that `null` should be considered empty, but the implementation does not do this. This divergence from the expected contract is untested and likely causes caller bugs.

**Severity:** MEDIUM

---

#### A10-5 — MEDIUM: `getRandomNumber` — off-by-one logic produces biased distribution; never tested

**Lines 150–166**
```java
randomInt = random.nextInt(_CHAR.length());  // 0..35
if (randomInt - 1 == -1) {
    return randomInt;         // returns 0 when randomInt == 0
} else {
    return randomInt - 1;     // returns 0..34 for randomInt 1..35
}
```
Index 0 can only be returned by the special case (`randomInt == 0`). All other indices are returned as `randomInt - 1`. The result range is 0..34, meaning the last character in `_CHAR` (index 35, the character `'0'`) can never be selected by `getRandomString`. The distribution is non-uniform and the character `'0'` is excluded. No test verifies the distribution or character-set coverage.

**Severity:** MEDIUM

---

#### A10-6 — MEDIUM: `decodeFile(File, int)` — null return on IOException not tested by callers; no test for non-existent file

**Lines 194–234**

The method returns `null` on `FileNotFoundException` or `IOException`. There is no test verifying:
- Behaviour when the file does not exist (returns `null`)
- Behaviour when `maxSize` is 0 or negative (division in scale calculation at line 212 could produce scale values of 0 or negative, causing `BitmapFactory` to fail)
- Behaviour when the file exists but is corrupt/unreadable
- The `FileInputStream` opened at line 220 is not closed if `BitmapFactory.decodeStream` throws a runtime exception; there is a resource-leak path untested

**Severity:** MEDIUM

---

#### A10-7 — HIGH: `preProcessBitmapToByteArray` — NullPointerException if BitmapFactory returns null; no test

**Lines 236–255**
```java
Bitmap bitmap = BitmapFactory.decodeFile(pathToOurFile);
// ...
int inWidth = bitmap.getWidth();  // NPE if bitmap is null
```
`BitmapFactory.decodeFile` returns `null` for an unrecognised format or an inaccessible path. There is no null check before accessing `bitmap.getWidth()`. Callers in `ImagePostRequest.java` and `ImagePostBackgroundTask.java` also pass results of `BitmapFactory.decodeFile` to `Util.preProcessBitmap` without null checks.

No test exercises the null-bitmap path.

**Severity:** HIGH

---

#### A10-8 — HIGH: `preProcessBitmap` — NullPointerException if bitmap argument is null; no test

**Lines 257–279**
```java
int inWidth = bitmap.getWidth();  // NPE if bitmap is null
```
The method accepts a `Bitmap` parameter but performs no null check before accessing it. `decodeFileFixOrientation` at line 284 passes `tb` (result of `BitmapFactory.decodeFile`) directly into `preProcessBitmap` without a null check; if `decodeFile` returns `null` (e.g., corrupt or missing file), a `NullPointerException` results. No test covers this path.

**Severity:** HIGH

---

#### A10-9 — MEDIUM: `decodeFileFixOrientation` — null bitmap from BitmapFactory passed unchecked to `preProcessBitmap`; no test

**Lines 281–306**
```java
Bitmap tb = BitmapFactory.decodeFile(file, opts);
Bitmap bm = preProcessBitmap(tb, null);  // tb may be null
```
`BitmapFactory.decodeFile` can return `null`. `preProcessBitmap` does not guard against a null `bitmap` argument (see A10-8). The method does guard the `ExifInterface` IOException (line 289–291) and returns `null`, but does not guard the preceding `preProcessBitmap` call. No test covers:
- Missing or corrupt file input
- A file path that does not exist
- A valid image with non-standard EXIF orientation values outside the four handled cases

**Severity:** MEDIUM

---

#### A10-10 — MEDIUM: `bigDecimalsAreTheSame` — asymmetric null-zero equivalence logic not tested

**Lines 313–338**

The method treats `null` as equivalent to `BigDecimal.ZERO` in some argument positions:
- `(null, ZERO)` → `true`
- `(ZERO, null)` → `true`
- `(null, non-zero)` → `false`
- `(non-zero, null)` → `false`

This null-zero equivalence is a non-obvious semantic choice with significant business impact (price comparisons). No test verifies:
- `(null, null)` → `true`
- `(null, ZERO)` → `true`
- `(ZERO, null)` → `true`
- `(null, non-zero)` → `false`
- `(ZERO, non-zero)` → `false`
- Two equal non-zero values → `true`
- Two different non-zero values → `false`
- Negative values

**Severity:** MEDIUM

---

#### A10-11 — MEDIUM: `integersAreTheSame` — same asymmetric null-zero equivalence as bigDecimalsAreTheSame; no test

**Lines 340–365**

Identical structural issue to A10-10. The method uses `i2.equals(0)` (line 348) which compares the Integer object value to the int literal `0` via autoboxing — this is correct but unusual and warrants verification. The use of `.equals()` for Integer comparison (not `==`) is correct, but the null-zero equivalence semantic is untested.

**Severity:** MEDIUM

---

#### A10-12 — HIGH: `getRealPathFromURI` — NullPointerException if query returns null cursor; no test

**Lines 367–382**
```java
cursor = context.getContentResolver().query(contentUri, proj, null, null, null);
int column_index = cursor.getColumnIndexOrThrow(...);  // NPE if cursor is null
cursor.moveToFirst();
return cursor.getString(column_index);  // no check that moveToFirst() returned true
```
`ContentResolver.query()` is documented to return `null` in some cases. The code dereferences `cursor` without a null check. Additionally, `cursor.moveToFirst()` returns `false` if the cursor is empty, but the return value is ignored; `cursor.getString(column_index)` would then return data from an invalid cursor position. No test covers:
- Null cursor returned from query
- Empty cursor (no results)
- URI that does not resolve to a file path

**Severity:** HIGH

---

#### A10-13 — LOW: `getLastDigitSufix` — boundary cases at 11, 12, 13 (English exceptions) not tested

**Lines 116–123**

The method correctly handles 11th, 12th, 13th via the `number < 20 ? number : number % 10` logic, but no test verifies these English ordinal exception cases:
- 11 → "th" (not "st")
- 12 → "th" (not "nd")
- 13 → "th" (not "rd")
- 111, 112, 113 (numbers > 100 with these suffixes)
- Negative numbers (e.g., `-1`: `(-1 < 20)` is true, switch case 1 is unreachable because `-1` is not a case)
- Zero

**Severity:** LOW

---

#### A10-14 — LOW: `arrayListFromStrings` — null array argument and empty array not tested

**Lines 46–53**

Passing a `null` array produces a `NullPointerException` in the for-each loop. Passing an array containing `null` elements silently adds `null` to the `ArrayList`. Neither path is tested.

**Severity:** LOW

---

#### A10-15 — LOW: `colorToHexString` — no test for alpha channel values; mask discards upper byte silently

**Line 86–88**
```java
return String.format("#%06X", 0xFFFFFFFF & color);
```
The mask `0xFFFFFFFF` is a no-op on a 32-bit `int` (all bits are already included), meaning the alpha channel is discarded by the `%06X` format specifier (which formats only 6 hex digits, i.e., 24 bits). A color with a non-opaque alpha channel will silently produce an incorrect result. No test verifies fully-opaque vs. transparent color input.

**Severity:** LOW

---

## File 2: `WebActivity.java`

### Reading Evidence

**Fully qualified class name:** `com.yy.libcommon.WebActivity`

**Superclass:** `com.yy.libcommon.BaseActivity`

**Constants defined:**
- Line 20: `static public final String URL_KEY = "com.webactivity.url"`

**Fields:**
- Line 15: `WebView webView`
- Line 16: `LineProgress line_progress_bar`
- Line 17: `String url` (declared but unused — the local variable at line 34 shadows it)
- Line 18: `View failed_text`

**Methods (with line numbers and signatures):**

| Line | Signature |
|------|-----------|
| 23 | `protected void onCreate(Bundle savedInstanceState)` |
| 32 | `void initWebView()` |
| 50 | `public void onProgressChanged(WebView view, int progress)` (anonymous inner class) |
| 60 | `public boolean shouldOverrideUrlLoading(WebView view, String url)` (anonymous inner class) |
| 66 | `public void onPageStarted(WebView view, String url, Bitmap favicon)` (anonymous inner class) |
| 71 | `public void onPageFinished(WebView view, String url)` (anonymous inner class) |
| 76 | `public void onReceivedError(WebView view, int errorCode, String description, String failingUrl)` (anonymous inner class) |

**No test file exists.**

---

### Findings for `WebActivity.java`

#### A10-16 — CRITICAL: `shouldOverrideUrlLoading` unconditionally returns `false`, loading all redirect URLs into the WebView without scheme validation; no test

**Lines 60–63**
```java
public boolean shouldOverrideUrlLoading(WebView view, String url){
    return false;
}
```
Returning `false` from `shouldOverrideUrlLoading` instructs the WebView to load every URL encountered during navigation — including redirects and any URL injected by the loaded page — inside the same WebView. Combined with JavaScript being enabled (line 43), this means:

1. If the server at the initial URL redirects to a `file:///` URL, the WebView will load local files from the device.
2. If the server redirects to a `javascript:` URL, the WebView may execute it.
3. If the server redirects to a `content://` URL, the WebView may expose content provider data.
4. If the URL passed via Intent is tampered with (see A10-17), the WebView will load whatever URL is provided without any scheme check.

The correct implementation should at minimum check that the URL scheme is `https` before returning `false`. No test verifies that dangerous schemes are refused.

**Severity:** CRITICAL

---

#### A10-17 — CRITICAL: URL loaded from Intent extra without any validation or sanitisation; no test

**Lines 34, 84**
```java
String url = getIntent().getStringExtra(URL_KEY);
// ... (no null check, no scheme check, no host check)
webView.loadUrl(url);
```
The URL is taken directly from an Intent extra and passed without modification to `webView.loadUrl()`. Because `WebActivity` is an Android Activity declared in the manifest (implicitly exportable or reachable via deep links), a malicious app or deep link could supply an arbitrary URL:
- `javascript:maliciousCode()` executed in the WebView context
- `file:///data/data/com.yy.libcommon/` to expose app-private storage
- `content://com.yy.libcommon.provider/` to read content providers

No test verifies:
- Null URL (causes `NullPointerException` in `webView.loadUrl(null)` or loads a blank page depending on API level)
- Empty string URL
- Non-http/https scheme URL
- URL pointing to a non-authorised host

**Severity:** CRITICAL

---

#### A10-18 — HIGH: JavaScript enabled with no Content Security Policy and no mixed-content restriction; no test

**Line 43**
```java
webView.getSettings().setJavaScriptEnabled(true);
```
JavaScript is enabled globally. There is no `WebSettings.setMixedContentMode()` call restricting mixed HTTP/HTTPS content, no `setAllowFileAccess(false)` call (default is `true` on older API levels), and no mechanism to restrict the JavaScript execution context to a known-safe origin. Combined with the unrestricted URL loading (A10-16, A10-17), this significantly expands the attack surface. No test verifies that JavaScript execution is restricted to trusted origins.

**Severity:** HIGH

---

#### A10-19 — HIGH: Instance field `url` (line 17) is declared but never assigned; shadowed by local variable; no test

**Lines 17, 34**
```java
String url;        // instance field, never assigned
// in initWebView():
String url = getIntent().getStringExtra(URL_KEY);  // local variable shadows field
```
The instance field `url` is never written. Any code that later references `this.url` (e.g., in a subclass or future modification) would receive `null`. The shadowing is a latent defect. No test exercises activity lifecycle scenarios (e.g., configuration change, `onSaveInstanceState`/`onRestoreInstanceState`) where the field-vs-local distinction matters.

**Severity:** HIGH

---

#### A10-20 — MEDIUM: `onReceivedError` shows a dialog but does not cancel the failed load; failed_text shown alongside the dialog; no test

**Lines 76–80**
```java
public void onReceivedError(WebView view, int errorCode, String description, String failingUrl) {
    line_progress_bar.setVisibility(View.GONE);
    failed_text.setVisibility(View.VISIBLE);
    showDialog("Error","Failed to load, please check your internet connection and retry.");
}
```
Both `failed_text` and a dialog are shown simultaneously. There is no call to `view.stopLoading()` to halt any pending load. The deprecated four-argument form of `onReceivedError` is used rather than the `WebResourceRequest` form introduced in API 23, meaning on API 23+ this callback only fires for main-frame errors; sub-resource errors are silently swallowed. No test exercises:
- Error code variations (DNS failure, SSL error, connection refused)
- Whether the error UI state is correctly cleared on retry or reload
- Whether the deprecated callback is reached on API 23+

**Severity:** MEDIUM

---

#### A10-21 — MEDIUM: `initWebView` — no test for null URL from Intent

**Line 34**
```java
String url = getIntent().getStringExtra(URL_KEY);
```
`getStringExtra` returns `null` if the key is absent. `webView.loadUrl(null)` is called at line 84. On current API levels this causes a `NullPointerException`. No test verifies behaviour when the Intent does not contain `URL_KEY`.

**Severity:** MEDIUM (see also A10-17 which covers the security dimension; this finding addresses the correctness/crash dimension)

---

## File 3: `GsonHelper.java`

### Reading Evidence

**Fully qualified class name:** `com.yy.libcommon.WebService.GsonHelper`

**Constants/types defined:** None

**Methods (with line numbers and signatures):**

| Line | Signature |
|------|-----------|
| 13 | `public static <T> T objectFromString(String data, Class<T> dataClass)` |
| 17 | `private static JSONObject fromObjectNoNamePolicy(Object object)` |
| 30 | `public static JSONObject fromObject(Object object)` |
| 43 | `public static String stringFromObjectNoPolicy(Object object)` |

**No test file exists.**

---

### Findings for `GsonHelper.java`

#### A10-22 — HIGH: `objectFromString` — no null/empty input guard; Gson returns null silently for null input; no test

**Lines 13–15**
```java
public static <T> T objectFromString(String data, Class<T> dataClass) {
    return new Gson().fromJson(data, dataClass);
}
```
`Gson.fromJson(null, Class)` returns `null`. `Gson.fromJson("", Class)` throws a `JsonSyntaxException`. Neither case is handled or documented. Callers in `SessionDb.java` (lines 42, 55, 87, 351, 411), `EquipmentDb.java` (line 36), `PreStartQuestionDb.java` (line 44), and `ModelPrefs.java` (line 63) all call this method and may receive `null` without expecting it, or crash on a `JsonSyntaxException`. No test exercises:
- `data = null` → returns `null` silently
- `data = ""` → throws `JsonSyntaxException`
- `data` = malformed JSON → throws `JsonSyntaxException`
- `dataClass = null` → throws `NullPointerException` inside Gson

**Severity:** HIGH

---

#### A10-23 — HIGH: `fromObject` and `fromObjectNoNamePolicy` — `JSONException` swallowed, method returns null; callers not tested

**Lines 17–28, 30–41**
```java
} catch (JSONException e) {
    e.printStackTrace();
    return null;
}
```
Both methods silently return `null` on `JSONException`. Callers of `fromObject` (`HttpClient.java` line 105) and callers of `stringFromObjectNoPolicy` (which internally calls `fromObjectNoNamePolicy`) receive `null` without any indication that serialisation failed. The `JSONException` can occur if Gson serialises a value that is not valid JSON (e.g., `Double.NaN`, `Double.POSITIVE_INFINITY`, or a circular reference). No test exercises:
- Object with NaN or Infinity double fields
- Null object argument
- Circular reference (would cause Gson stack overflow)

**Severity:** HIGH

---

#### A10-24 — MEDIUM: `stringFromObjectNoPolicy` — silently returns empty string on failure; callers cannot distinguish success from failure; no test

**Lines 43–51**
```java
public static String stringFromObjectNoPolicy(Object object) {
    JSONObject jsonObject = fromObjectNoNamePolicy(object);
    String s = "";
    try {
        s = Objects.requireNonNull(jsonObject).toString();
    } catch (Exception ignored) {
    }
    return s;
}
```
If `fromObjectNoNamePolicy` returns `null` (on `JSONException`), `Objects.requireNonNull` throws a `NullPointerException` which is caught by the broad `catch (Exception ignored)` and swallowed. The method returns `""`. Callers in `SessionDb.java`, `ModelPrefs.java`, `WebRequest.java`, and `PreStartQuestionDb.java` store or send this empty string as if it were valid serialised data. Persisting an empty string to the database in place of actual session data constitutes silent data corruption. No test verifies:
- Null object input → returns `""`
- Object that causes JSONException → returns `""`
- Valid object → returns correct JSON string

**Severity:** MEDIUM

---

#### A10-25 — MEDIUM: `fromObject` uses `UPPER_CAMEL_CASE` naming policy inconsistently with `fromObjectNoNamePolicy`; divergence not tested

**Lines 17–41**

The two serialisation paths apply different field naming policies:
- `fromObjectNoNamePolicy`: uses Gson default (camelCase)
- `fromObject`: uses `FieldNamingPolicy.UPPER_CAMEL_CASE` (PascalCase)

Both are used in the codebase. No test verifies that objects round-trip correctly through their respective serialisation method or that mixing the two methods (serialising with one, deserialising with the other) is detected and prevented. Silent field mismatches in the JSON would cause `objectFromString` to silently return objects with null fields.

**Severity:** MEDIUM

---

#### A10-26 — LOW: `objectFromString` — `dataClass` parameter accepts null without guard; Gson throws NPE internally; no test

**Lines 13–15**

If `dataClass` is `null`, Gson throws a `NullPointerException` internally with no meaningful message. The method has no guard and no documentation of this constraint. No test verifies the failure mode.

**Severity:** LOW

---

## Summary Table

| ID | File | Severity | Description |
|----|------|----------|-------------|
| A10-1 | Project-wide | HIGH | Zero automated test coverage in app/ and LibCommon/ |
| A10-2 | Util.java | HIGH | `generateDeviceId` — null WifiManager / WifiInfo dereference untested |
| A10-3 | Util.java | HIGH | `generateDeviceId` — MAC address returns constant on API 23+; UUID collisions untested |
| A10-4 | Util.java | MEDIUM | `isStringEmpty` — null returns false (counterintuitive); no tests |
| A10-5 | Util.java | MEDIUM | `getRandomNumber` — biased distribution excludes last character; no test |
| A10-6 | Util.java | MEDIUM | `decodeFile(File,int)` — null return and resource leak paths untested |
| A10-7 | Util.java | HIGH | `preProcessBitmapToByteArray` — NPE on null bitmap from BitmapFactory; no test |
| A10-8 | Util.java | HIGH | `preProcessBitmap` — NPE on null bitmap argument; no test |
| A10-9 | Util.java | MEDIUM | `decodeFileFixOrientation` — null bitmap passed to preProcessBitmap; no test |
| A10-10 | Util.java | MEDIUM | `bigDecimalsAreTheSame` — asymmetric null-zero equivalence untested |
| A10-11 | Util.java | MEDIUM | `integersAreTheSame` — same null-zero equivalence issue untested |
| A10-12 | Util.java | HIGH | `getRealPathFromURI` — null cursor and empty cursor dereference; no test |
| A10-13 | Util.java | LOW | `getLastDigitSufix` — boundary cases 11/12/13 and negatives not tested |
| A10-14 | Util.java | LOW | `arrayListFromStrings` — null array input causes NPE; no test |
| A10-15 | Util.java | LOW | `colorToHexString` — alpha channel silently truncated; no test |
| A10-16 | WebActivity.java | CRITICAL | `shouldOverrideUrlLoading` returns false unconditionally; all redirect schemes loaded without validation |
| A10-17 | WebActivity.java | CRITICAL | Intent URL loaded into WebView without null check, scheme check, or host validation |
| A10-18 | WebActivity.java | HIGH | JavaScript enabled with no CSP, no mixed-content restriction, no origin restriction |
| A10-19 | WebActivity.java | HIGH | Instance field `url` shadowed by local variable; always null; no lifecycle test |
| A10-20 | WebActivity.java | MEDIUM | `onReceivedError` uses deprecated signature; dual error UI shown; no stopLoading(); no test |
| A10-21 | WebActivity.java | MEDIUM | Null URL from Intent extra causes crash in `webView.loadUrl(null)`; no test |
| A10-22 | GsonHelper.java | HIGH | `objectFromString` — null/empty/malformed input not guarded; Gson throws or returns null; no test |
| A10-23 | GsonHelper.java | HIGH | `fromObject`/`fromObjectNoNamePolicy` — JSONException swallowed, null returned silently; no test |
| A10-24 | GsonHelper.java | MEDIUM | `stringFromObjectNoPolicy` — silent empty-string return on failure causes DB data corruption; no test |
| A10-25 | GsonHelper.java | MEDIUM | Inconsistent field naming policy between fromObject and fromObjectNoNamePolicy; round-trip untested |
| A10-26 | GsonHelper.java | LOW | `objectFromString` — null dataClass causes internal Gson NPE with no guard; no test |
