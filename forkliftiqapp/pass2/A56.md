# Audit Pass 2 — Agent A56
**Audit run:** 2026-02-26-01
**Agent:** A56
**Files assigned:**
1. `app/src/main/java/au/com/collectiveintelligence/fleetiq360/ui/activity/ProfileActivity.java`
2. `app/src/main/java/au/com/collectiveintelligence/fleetiq360/ui/activity/SessionActivity.java`
3. `app/src/main/java/au/com/collectiveintelligence/fleetiq360/ui/activity/SignupActivity.java`

---

## PROJECT-WIDE FINDING

### A56-1 — HIGH: Zero automated test coverage across app/ and LibCommon/ modules

No `test/` or `androidTest/` source sets exist anywhere under `app/src/` or `LibCommon/src/`. Exhaustive filesystem search (`find … -type d -name test`, `… -name androidTest`) returned no results for either module. The only test directories found in the entire repository belong to third-party library modules (`LibImageloader`, `LibImagePicker`, `LibPercentProgress`) and are unrelated to application logic.

**Impact:** Every class, method, and code path in the two primary modules — including authentication, session management, BLE device control, offline data handling, and user signup — executes in production with zero regression protection. Any defect introduced by refactoring or dependency updates is invisible until a user observes it in the field.

**Scope:** All source files in `app/` and `LibCommon/`. All subsequent per-file findings in this report are specific instances of this global gap.

---

## File 1: ProfileActivity.java

### Reading Evidence

**Fully qualified class name:** `au.com.collectiveintelligence.fleetiq360.ui.activity.ProfileActivity`

**Superclass:** `au.com.collectiveintelligence.fleetiq360.ui.common.FleetActivity` (which extends `com.yy.libcommon.BaseActivity`)

**Methods (with line numbers and signatures):**

| Line | Signature |
|------|-----------|
| 11 | `protected void onCreate(Bundle savedInstanceState)` |

**Fields / constants defined:** None declared in this class. All state is inherited from `FleetActivity`.

**Fragments launched:** `au.com.collectiveintelligence.fleetiq360.ui.fragment.ProfileFragment` (via `showFragmentWithoutStack`, line 15).

**No test file exists** for `ProfileActivity` or for `ProfileFragment` (confirmed by filesystem search above).

---

### Findings for ProfileActivity.java

#### A56-2 — LOW: `onCreate` has no test exercising fragment inflation or container validity

`onCreate` calls `showFragmentWithoutStack(R.id.fragment_container, …, new ProfileFragment())`. There is no test verifying:
- That `R.id.fragment_container` exists in `activity_profile.xml` (a layout mismatch would silently produce a blank screen rather than a crash on all SDK versions below 26).
- That `ProfileFragment` is successfully added to the back stack / fragment manager after launch.
- That the activity survives configuration change (rotation) without re-adding a duplicate fragment.

**Severity:** LOW — the activity is a thin shell. The risk is limited to incorrect display rather than data loss or security failure, but a rotation-duplication defect would be invisible without an instrumented test.

---

## File 2: SessionActivity.java

### Reading Evidence

**Fully qualified class name:** `au.com.collectiveintelligence.fleetiq360.ui.activity.SessionActivity`

**Superclass:** `au.com.collectiveintelligence.fleetiq360.ui.common.FleetActivity`

**Methods (with line numbers and signatures):**

| Line | Signature |
|------|-----------|
| 24 | `protected void onCreate(Bundle savedInstanceState)` |
| 76 | `public void onBackPressed()` |
| 90 | `public void onExitSessionActivity()` |
| 118 | `public void abortSession(final SessionResult sessionResult)` |

**Fields / constants defined:** None declared in this class. Inherits `connectingDevice` (boolean) and all other state from `FleetActivity`.

**Nested / anonymous types referenced:**
- `FleetActivity.AbortSessionCallback` (anonymous at lines 126–159)
- `YesNoDialog.Callback` (two anonymous instances: lines 97–113 and 144–158)
- `Runnable` (two anonymous: lines 50–56, 58–64)

**Static global state consumed:**
- `MyCommonValue.currentEquipmentItem` (read line 37, 42; written line 38 on the early-return path)
- `WebData.instance().getSessionResult()` (line 102, inside dialog callback)
- `SessionDb.readRunningSessionDb()` (line 30)
- `SessionDb.readRunningSession()` (line 31)
- `SessionDb.readRunningEquipmentItem()` (line 38)
- `BleController.instance().isDeviceSetupDone(address)` (line 44)
- `SessionDb.isEquipmentSetupDone(sessionResult.id)` (line 45)
- `SessionDb.isPreStartFinished(sessionResult.id)` (line 66)
- `FleetFragment.checkUsePreviousPreStart(…)` (line 69)

**No test file exists** for `SessionActivity` (confirmed by filesystem search).

---

### Findings for SessionActivity.java

#### A56-3 — HIGH: `onCreate` early-return on null `currentEquipmentItem` leaves activity in a blank, non-finishing state

Lines 37–40:
```java
if (MyCommonValue.currentEquipmentItem == null) {
    MyCommonValue.currentEquipmentItem = SessionDb.readRunningEquipmentItem();
    return;   // <-- activity remains open with no fragment and no finish()
}
```
After `readRunningEquipmentItem()` is called (which may itself return null if `readRunningSessionDb()` returns null or the equipment JSON is corrupt), the method returns without calling `finish()` and without loading any fragment. The user sees a blank `activity_common` layout with the screen-on flag set. There is no test exercising this path, and no test verifying that the activity either re-enters `onCreate` (e.g., via a broadcast) or finishes itself when the equipment item cannot be resolved.

This path is reachable in production whenever the app is restored from the background after the Realm database has been cleared or the session has expired mid-use.

**Severity:** HIGH — a running session is a safety-critical workflow (equipment authorisation). Leaving the activity alive but blank with the screen kept on while equipment state is undefined is a correctness failure in a safety context.

#### A56-4 — HIGH: `abortSession` retrieves `SessionResult` from `WebData.instance().getSessionResult()` inside a dialog callback, not from the already-validated local variable

`onExitSessionActivity()` (lines 90–116) creates a `YesNoDialog`. Inside its `onAcceptPress()` callback (line 102), it calls:
```java
final SessionResult sessionResult = WebData.instance().getSessionResult();
abortSession(sessionResult);
```
`WebData.getSessionResult()` delegates to `SessionDb.readRunningSession()`, which can return null if the session has ended between the time the dialog was shown and when the user taps "Proceed". `abortSession()` does guard for null at line 119, but the abort silently no-ops in that case — the session is not aborted, the screen-on flag is cleared (line 100), yet `finish()` is never called. There is no test for the race where the session ends (timeout, background sync, or another device) during the confirmation dialog.

**Severity:** HIGH — in a fleet management / safety system, a silently no-op abort leaves equipment state inconsistent between the server and the device.

#### A56-5 — HIGH: `onCreate` returns without `finish()` when `sessionDb` is null or `sessionResult` is null, but does call `finish()` on that same path correctly — inconsistency with the equipment-null path creates a dual early-return pattern with different semantics

Lines 32–35 (null session path):
```java
if (sessionDb == null || null == sessionResult) {
    finish();
    return;
}
```
Lines 37–40 (null equipment path):
```java
if (MyCommonValue.currentEquipmentItem == null) {
    MyCommonValue.currentEquipmentItem = SessionDb.readRunningEquipmentItem();
    return;   // no finish()
}
```
The two null-guard paths have different terminal actions. The first correctly finishes; the second does not. This asymmetry is almost certainly a defect introduced when the equipment-null branch was added or modified. Without tests for both paths, neither behaviour is formally specified and either can regress without notice.

**Severity:** HIGH — same safety rationale as A56-3; this is the direct root cause of that finding.

#### A56-6 — MEDIUM: `onBackPressed` uses typo method `findFramentByTag` (missing 'g') twice — no test catches a rename

Lines 77 and 81 both call `findFramentByTag(…)` (inherited from `FleetActivity` or its superclass). The method name is a typo for `findFragmentByTag`. This typo is consistent between call sites, but it means the method is coupled to a similarly misspelled declaration in the parent class. Any refactoring that corrects the spelling in the parent without updating both call sites here would silently break back-press handling during pre-start and equipment-connect flows. No test exercises the back-press path in either the prestart-visible or connect-visible state.

**Severity:** MEDIUM — back-press during a safety-critical pre-start check has no test; a compile-time rename would be caught, but an IDE refactor that misses this file would not.

#### A56-7 — MEDIUM: `onBackPressed` fragment-visibility logic is untested for all four combinations

`onBackPressed` (lines 76–88) checks:
1. `EquipmentPrestartFragment` is found AND not hidden → call `onExitSessionActivity()`
2. `EquipmentConnectFragment` is found AND not hidden → call `onExitSessionActivity()`
3. Neither → call `super.onBackPressed()`

Four distinct combinations exist (prestart visible, connect visible, neither visible, both simultaneously hidden). No test covers any combination. The "both simultaneously hidden" and "neither found" paths both route to `super.onBackPressed()`, which pops the fragment back stack; whether that is correct behaviour when `JobsFragment` is showing is unverified.

**Severity:** MEDIUM — incorrect back-press handling could allow a user to navigate out of a running session without triggering the abort confirmation dialog.

#### A56-8 — MEDIUM: `abortSession` retry loop is unbounded — no test for repeated network failures

`abortSession` (lines 118–161): on `onSessionStopFailed`, the dialog offers "Retry", which calls `abortSession(sessionResult)` recursively (line 147). There is no limit on retries and no test verifying behaviour after N consecutive failures. Repeated failures accumulate nested dialog instances if the user taps Retry before the previous dialog is fully dismissed; `show(getCurrentFragmentManager(), "confirm")` uses the same tag each time, so the manager will replace the previous dialog, but the retry lambda holds a strong reference to the enclosing activity, which could prevent GC during rapid retries with a destroyed activity.

**Severity:** MEDIUM — network-failure retry paths are exercised in the field but are entirely untested.

#### A56-9 — MEDIUM: `abortSession` `onSessionStopped` callback sets `connectingDevice = false` inside a `runLater` 800ms delay — no test for activity destruction during that window

Lines 129–136:
```java
MyApplication.runLater(new Runnable() {
    @Override
    public void run() {
        hideProgress();
        finish();
        connectingDevice = false;  // set after finish()
    }
}, 800);
```
`connectingDevice` is set to false after `finish()` is called. If the activity is destroyed during those 800ms (e.g., the user kills it from the recents screen), `connectingDevice` remains `true` in `FleetActivity`'s state, though since the activity is destroyed that specific instance is gone. However, `connectingDevice` is an instance field, so this is low risk for memory leaks but represents untested ordering. More importantly, `hideProgress()` and `finish()` are called on a possibly-destroyed activity. No test covers this timing window.

**Severity:** MEDIUM — timing defects in session teardown are not exercised.

#### A56-10 — INFO: `FLAG_KEEP_SCREEN_ON` is cleared in `onAcceptPress` but not in `onDeclinePress` or `onTimeOutDialog`

`onExitSessionActivity` lines 100 and 107–113: `getWindow().clearFlags(FLAG_KEEP_SCREEN_ON)` is called only in `onAcceptPress`. If the user declines or the dialog times out, the flag remains set, which is the correct behaviour (session is still running). However, the `onAbortSession.onSessionStopFailed` / decline path (line 151–154) calls `finish()` directly without clearing the flag. No test verifies that the screen-on flag is cleared in all paths that terminate the activity.

**Severity:** INFO — incorrect screen-on state is a UX issue, not a safety or data issue.

---

## File 3: SignupActivity.java

### Reading Evidence

**Fully qualified class name:** `au.com.collectiveintelligence.fleetiq360.ui.activity.SignupActivity`

**Superclass:** `au.com.collectiveintelligence.fleetiq360.ui.common.FleetActivity`

**Methods (with line numbers and signatures):**

| Line | Signature |
|------|-----------|
| 10 | `protected void onCreate(Bundle savedInstanceState)` |

**Fields / constants defined:** None declared in this class.

**Fragments launched:** `au.com.collectiveintelligence.fleetiq360.ui.fragment.SignupFragment` (via `showFragmentWithoutStack`, line 13), using layout container `R.id.login_framelayout_id`.

**No test file exists** for `SignupActivity` or `SignupFragment` (confirmed by filesystem search).

---

### Findings for SignupActivity.java

#### A56-11 — HIGH: Signup flow has zero test coverage — authentication entry point is entirely unverified

`SignupActivity` is the entry point for new user registration. It delegates all logic to `SignupFragment`, but neither the activity lifecycle nor the fragment's creation is tested. `FleetActivity.onCreate` calls `SyncService.startService()` and `checkEquipmentConnected()` before the subclass `onCreate` runs, meaning the signup screen triggers background BLE/sync operations on every launch. No test verifies:
- That `SyncService` and BLE checks do not interfere with signup form rendering.
- That the activity behaves correctly when launched without an authenticated session (i.e., when `WebData.instance().getUserId()` returns -1 and `SessionDb.readRunningSession()` returns null).
- That the fragment container `R.id.login_framelayout_id` exists in `activity_signup.xml` — a mismatch silently produces a blank screen.

**Severity:** HIGH — the registration pathway for new users is a security-relevant flow (account creation) with zero test coverage.

#### A56-12 — LOW: No test for configuration-change (rotation) behaviour causing duplicate `SignupFragment` instances

`onCreate` unconditionally calls `showFragmentWithoutStack(…, new SignupFragment())` without checking `savedInstanceState`. On a configuration change (device rotation), a new `SignupFragment` is added on top of the one the framework already restored, potentially duplicating the form and losing in-progress user input. No test exercises this path.

**Severity:** LOW — data loss limited to unsaved form input; no security or safety impact.

---

## Summary Table

| ID | File | Severity | Description |
|----|------|----------|-------------|
| A56-1 | Project-wide | HIGH | Zero automated test coverage in app/ and LibCommon/ |
| A56-2 | ProfileActivity | LOW | `onCreate` fragment inflation and container validity untested |
| A56-3 | SessionActivity | HIGH | Equipment-null early-return leaves activity blank without `finish()` |
| A56-4 | SessionActivity | HIGH | `abortSession` fetches `SessionResult` inside dialog callback — race with session expiry |
| A56-5 | SessionActivity | HIGH | Asymmetric null-guard paths — session-null calls `finish()`, equipment-null does not |
| A56-6 | SessionActivity | MEDIUM | Typo `findFramentByTag` in `onBackPressed` — rename-safe only if parent is also renamed |
| A56-7 | SessionActivity | MEDIUM | All four `onBackPressed` fragment-visibility combinations untested |
| A56-8 | SessionActivity | MEDIUM | Abort retry loop unbounded; no test for repeated network failures |
| A56-9 | SessionActivity | MEDIUM | `connectingDevice = false` set after `finish()` in 800ms delayed runnable; activity may be destroyed |
| A56-10 | SessionActivity | INFO | `FLAG_KEEP_SCREEN_ON` not cleared on all exit paths |
| A56-11 | SignupActivity | HIGH | Signup (authentication entry) flow has zero test coverage |
| A56-12 | SignupActivity | LOW | Rotation duplicates `SignupFragment` — no `savedInstanceState` guard |
