# Audit Pass 2 — Agent A50
**Audit run:** 2026-02-26-01
**Agent:** A50
**Files assigned:**
1. `app/src/main/java/au/com/collectiveintelligence/fleetiq360/presenter/EquipmentDriverAccessPresenter.java`
2. `app/src/main/java/au/com/collectiveintelligence/fleetiq360/presenter/EquipmentSelectForkPresenter.java`
3. `app/src/main/java/au/com/collectiveintelligence/fleetiq360/presenter/JobsPresenter.java`

---

## PROJECT-WIDE FINDING

### A50-1 [HIGH] Zero automated test coverage across app/ and LibCommon/ modules

No `test/` or `androidTest/` source sets exist under `app/src/` or `LibCommon/src/`. The only test directories in the repository are in third-party library modules (`LibImageloader`, `LibImagePicker`, `LibPercentProgress`), none of which cover application business logic. Every finding below describes a gap that exists with **zero** mitigating test coverage of any kind. All security-critical paths, offline fallback logic, and SSL overrides are shipped entirely without automated verification.

**Evidence:**
```
find forkliftiqapp -type d -name "test" -o -type d -name "androidTest"
# Results:
#   LibImageloader/src/test          (third-party library, not app code)
#   LibImagePicker/src/androidTest   (third-party library, not app code)
#   LibPercentProgress/src/androidTest (third-party library, not app code)
#
# app/src/test      — does not exist
# app/src/androidTest — does not exist
# LibCommon/src/test — does not exist
```

---

## File 1: EquipmentDriverAccessPresenter.java

### Reading Evidence

**Fully qualified class name:**
`au.com.collectiveintelligence.fleetiq360.presenter.EquipmentDriverAccessPresenter`

**Fields / instance variables:**
| Name | Type | Line |
|------|------|------|
| `ui` | `BaseFragment` | 38 |

**Methods (with line numbers and signatures):**
| Line | Visibility | Signature |
|------|------------|-----------|
| 40 | `public` | `EquipmentDriverAccessPresenter(BaseFragment ui)` |
| 44 | `public` | `void createAndSaveSession()` |
| 106 | `private` | `void startSession()` |
| 117 | `private` | `EquipmentItem getEquipmentItem(int unitId)` |
| 133 | `private` | `void onSessionNotStopped(final SessionResult sessionResult)` |
| 209 | `private` | `void deleteSession(final int sessionId)` |
| 237 | `private` | `void stopSession(SessionResult sessionResult)` |
| 275 | `private` | `void resumeSession(SessionResult result, EquipmentItem equipmentItem)` |
| 282 | `private` | `void onSessionSaved()` |

**Constants / imports of note:**
- `HttpsURLConnection.HTTP_BAD_REQUEST` (400) — explicit status code check, line 70
- `HttpsURLConnection.HTTP_BAD_GATEWAY` (502) — explicit status code check, line 84
- All other status codes fall through to the offline-grant `else` branch, lines 87–101

---

### Findings for EquipmentDriverAccessPresenter.java

#### A50-2 [CRITICAL] `createAndSaveSession()` offline fallback grants session access on any server error that is not 400 or 502

**Location:** `createAndSaveSession()`, lines 67–101

**Description:**
The `onFailed` callback dispatches on HTTP status code:
- `HTTP_BAD_REQUEST` (400) → display or parse a "session already running" message — no local grant.
- `HTTP_BAD_GATEWAY` (502) → display "equipment busy" error — no local grant.
- **All other codes** → fall into the `else` branch (lines 87–101), which constructs a synthetic `SessionResult` via `WebData.getTempSessionResult()`, saves it to the local database via `SessionDb.saveData(sessionResult, equipmentItem, true)`, and proceeds to start a full session (`startSession()`).

Status codes that fall into the else branch and therefore silently grant session access include, but are not limited to:
- **401 Unauthorized** — server is explicitly rejecting the bearer token as invalid or expired.
- **403 Forbidden** — server is explicitly denying this driver access to this piece of equipment.
- **404 Not Found** — endpoint missing.
- **500 Internal Server Error** — server fault.
- **503 Service Unavailable** — server overload/maintenance.
- Any network-layer error (e.g., `NoConnectionError`, certificate error reported as a `VolleyError` without a response) that produces a zero or negative status code.

A 401 or 403 from the server represents an explicit denial-of-access decision. Treating those codes as an "offline" condition and granting local access defeats server-side access control entirely. An attacker who can cause the server to return a 401 or 403 (or who can intercept the network and inject such a response) will trigger the offline fallback, creating a valid local session. Because `SyncService` later attempts to upload offline sessions, the attacker's local session may subsequently synchronise to the server if connectivity is restored and a different token becomes valid.

**There is no test that sends a mock 401, 403, 404, 500, or 503 and asserts that the fallback is NOT triggered.**

**Recommendation (for tracking only — do not fix in this pass):**
The `else` branch should be narrowed to network-level connectivity errors only (e.g., `NoConnectionError`, or status code <= 0 meaning no HTTP response was received). All HTTP responses with a well-formed status code — in particular 401 and 403 — should be treated as explicit server rejections and must not grant local access.

---

#### A50-3 [HIGH] Session creation logic has no test coverage — all branches untested

**Location:** `createAndSaveSession()`, lines 44–103

**Description:**
The method encapsulates the primary driver authorisation flow for forklift access. None of the following paths have any test:
- Successful session start (server returns 200 with `SessionResult`).
- `onFailed` with status 400 where the response body is valid JSON parseable to `SessionResult` → `onSessionNotStopped()`.
- `onFailed` with status 400 where JSON parsing throws an exception → fallback to `showErrDialog`.
- `onFailed` with status 502.
- `onFailed` with any other status (the offline grant path).

The `parameter.start_time` is set from `Calendar.getInstance().getTime()` before the network call, making it time-sensitive; there is no test verifying the timestamp format or that a clock-skew edge case is handled.

---

#### A50-4 [HIGH] `onSessionNotStopped()` branching logic has no test coverage

**Location:** `onSessionNotStopped()`, lines 133–207

**Description:**
This method controls what happens when a 400 response indicates a session is already running. It has three branches:
1. `SessionDb.isSessionAborted(sessionResult.id)` is true → show "Stop" dialog, which calls `deleteSession()`.
2. `equipmentItem == null` (session on a different piece of equipment) → show "Stop" dialog, which calls `stopSession()`.
3. `equipmentItem != null` (same equipment, resume path) → show "Continue/Stop" dialog; Accept calls `resumeSession()`, Decline calls `stopSession()`.

There is no test for any branch. In particular:
- No test verifies branch 1 when `isSessionAborted` returns true.
- No test verifies branch 2 (`equipmentItem == null`).
- No test verifies branch 3 (same equipment, resume vs. stop decision).
- No test verifies the `getEquipmentItem()` lookup that determines `equipmentItem`.

---

#### A50-5 [MEDIUM] `deleteSession()` failure path silently marks session as aborted in local DB without user notification of the underlying error

**Location:** `deleteSession()`, `onFailed` callback, lines 224–234

**Description:**
When `WebApi.async().deleteSession()` fails, the code calls `SessionDb.setSessionAborted(sessionId, true)` and then shows a success-like message ("session_stopped_can_start"). The user is not informed that the delete failed and was only recorded locally. There is no test that exercises the `onFailed` branch of `deleteSession()` and asserts that the local DB state is marked `abortedOffline=true` and that the UI message shown is appropriate.

---

#### A50-6 [MEDIUM] `stopSession()` offline fallback (`hasOfflineData` branch) has no test coverage

**Location:** `stopSession()`, lines 255–270

**Description:**
`stopSession()` is called from two dialog callbacks in `onSessionNotStopped()`. When the server call to end the session fails, the code checks `SessionDb.hasOfflineData(parameter.id)`. If true, it marks the session finished locally and proceeds as if stopped. If false, it shows an error. There is no test verifying either branch, and no test verifying the interaction between the `hasOfflineData` check and the actual offline data state in the database.

---

#### A50-7 [MEDIUM] `resumeSession()` has no test coverage

**Location:** `resumeSession()`, lines 275–280

**Description:**
`resumeSession()` saves session data to the local DB, sets `MyCommonValue.currentEquipmentItem`, and launches `SessionActivity`. There is no test verifying that it correctly restores state, that the `equipmentItem` passed in is stored, or that calling `startSession()` with a resumed session ID produces the correct intent extras.

---

#### A50-8 [LOW] `getEquipmentItem()` linear search has no edge-case tests

**Location:** `getEquipmentItem()`, lines 117–131

**Description:**
The method searches `EquipmentListFragment.getEquipmentResultArray.arrayList` linearly. There is no test for:
- `getEquipmentResultArray` is null (handled, returns null).
- `getEquipmentResultArray.arrayList` is null (handled, returns null).
- `arrayList` is empty (returns null — handled by caller, but untested).
- Multiple items with the same `id` (returns first match — untested).

---

#### A50-9 [LOW] `onSessionSaved()` posts a 10-second delayed `SyncService.startService()` with no test

**Location:** `onSessionSaved()`, lines 282–289

**Description:**
The 10-second delay before triggering `SyncService` is hardcoded with no test verifying the delay value, that the sync is actually triggered, or that it fires the correct number of times if `onSessionSaved()` is called multiple times in quick succession (potential for multiple concurrent syncs).

---

## File 2: EquipmentSelectForkPresenter.java

### Reading Evidence

**Fully qualified class name:**
`au.com.collectiveintelligence.fleetiq360.presenter.EquipmentSelectForkPresenter`

**Fields / instance variables:**
| Name | Type | Line |
|------|------|------|
| `ui` | `EquipmentListFragment` | 22 (public) |
| `uiCb` | `ShowResultCallBack` | 23 (private) |

**Inner interface:**
| Line | Name | Methods |
|------|------|---------|
| 75–77 | `ShowResultCallBack` | `void uiUpdateEquipmentList(GetEquipmentResultArray resultArray)` |

**Methods (with line numbers and signatures):**
| Line | Visibility | Signature |
|------|------------|-----------|
| 25 | `public` | `EquipmentSelectForkPresenter(EquipmentListFragment ui)` |
| 30 | `public` | `void getEquipmentList()` |
| 57 | `public` | `void showImage(String url, ImageView imageView)` |

**Key external call of note:**
- Line 71: `UserPhotoFragment.SSLCertificateHandler.nuke()` — called unconditionally on every image load.

---

### Findings for EquipmentSelectForkPresenter.java

#### A50-10 [CRITICAL] `showImage()` calls `SSLCertificateHandler.nuke()` unconditionally on every equipment image load, with no test verifying production TLS is not disabled

**Location:** `showImage()`, line 71

**Description:**
`UserPhotoFragment.SSLCertificateHandler.nuke()` (defined in `UserPhotoFragment.java`, lines 41–69) replaces the JVM-wide `SSLContext` and `HostnameVerifier` with implementations that:
- Accept any X.509 certificate regardless of issuer, expiry, or chain validity (`checkServerTrusted` is a no-op, `getAcceptedIssuers` returns an empty array).
- Approve any hostname for any SSL session (`HostnameVerifier.verify()` always returns `true`).

This call is made via `HttpsURLConnection.setDefaultSSLSocketFactory()` and `HttpsURLConnection.setDefaultHostnameVerifier()`, which are **process-wide static setters**. Once `nuke()` is called, **all** subsequent HTTPS connections in the process — including those made by the Volley HTTP client used for API calls (`WebApi`), authentication token exchange, session start/end, and pre-start submission — use the disabled trust store for the remainder of the process lifetime. There is no mechanism to restore the original trust manager.

The call is made every time a user navigates to the equipment selection screen and an image is displayed, which happens in normal application flow. This is not a debug-only or test-only code path.

**Impact:**
- All API traffic (session start, authentication bearer tokens, pre-start results, shock events, GPS locations) is vulnerable to man-in-the-middle attack after the first call to `showImage()`. An attacker on the same network can present a self-signed certificate and intercept or tamper with all subsequent HTTPS requests without any indication to the application.
- The `@SuppressLint("TrustAllX509TrustManager")` and `@SuppressLint("BadHostnameVerifier")` annotations confirm the developers are aware this is flagged by lint, and have suppressed the warnings rather than fixing the underlying issue.

**No test exists that:**
- Verifies `SSLCertificateHandler.nuke()` is not called in production builds.
- Verifies that the default SSL socket factory remains the system default after `showImage()` is called.
- Verifies that API calls made after `showImage()` use a valid certificate chain.

---

#### A50-11 [HIGH] `getEquipmentList()` failure path falls back to local DB without tests for either branch

**Location:** `getEquipmentList()`, lines 41–52

**Description:**
The `onFailed` callback reads the equipment list from `EquipmentDb.getEquipmentResultArray(usrId)`. If the local DB result is non-null, it silently uses stale data with no indication to the user that the network call failed. If the result is null, it shows an error dialog. There are no tests for:
- The success path (server returns list, `uiCb.uiUpdateEquipmentList()` is called, `EquipmentDb.saveEquipmentResultArray()` is called by `WebApi.getEquipmentList()`).
- The `onFailed` path where `EquipmentDb` returns non-null stale data.
- The `onFailed` path where `EquipmentDb` returns null (error dialog shown).
- Whether the stale data displayed to the user is correctly identified as potentially out of date (it is not — no indication is shown).

---

#### A50-12 [MEDIUM] `showImage()` has no test for null URL or null ImageView

**Location:** `showImage(String url, ImageView imageView)`, line 57

**Description:**
The method is called from UI code and receives a `url` that is sourced from `EquipmentItem` data returned from the server. There is no null check on `url` before passing it to `ImageLoader.getInstance().displayImage()`. The `DisplayImageOptions` builder sets `showImageForEmptyUri` (line 59) and `showImageOnFail` (line 60), which may handle an empty URI but may not handle a null URL. No test exercises this path. The `cancelDisplayTask` call on line 67 also takes `new ImageViewAware(imageView)` — a null `imageView` would produce a `NullPointerException` in `ImageViewAware`'s constructor.

---

#### A50-13 [LOW] `showImage()` rebuilds `DisplayImageOptions` on every call with no test for caching correctness

**Location:** `showImage()`, lines 58–65

**Description:**
A new `DisplayImageOptions` object is built from scratch on every invocation. For a list with many equipment items, this creates object allocation pressure. While likely not a crash risk, there is no test verifying that `cacheInMemory(true)` and `cacheOnDisk(true)` options are actually honoured by the `ImageLoader` or that stale cached images are not returned when the equipment list changes.

---

## File 3: JobsPresenter.java

### Reading Evidence

**Fully qualified class name:**
`au.com.collectiveintelligence.fleetiq360.presenter.JobsPresenter`

**Fields / instance variables:**
| Name | Type | Line |
|------|------|------|
| `ui` | `JobsFragment` | 29 (private) |
| `sessionResult` | `SessionResult` | 30 (private) |
| `startDate` | `LocalDateTime` | 31 (private) |
| `serverDateFormatter` | `ServerDateFormatter` | 33 (private) |
| `myHandler` | `Handler` | 35 (private) |
| `timerStopped` | `boolean` | 36 (private) |
| `timerRunnable` | `Runnable` (anonymous inner class) | 37–46 (private) |

**Import duplications:**
- `au.com.collectiveintelligence.fleetiq360.ui.application.MyApplication` is imported twice (lines 23 and 26).

**Methods (with line numbers and signatures):**
| Line | Visibility | Signature |
|------|------------|-----------|
| 48 | `private` | `void startTimer()` |
| 54 | `public` | `void stopTimer()` |
| 59 | `public` | `JobsPresenter(JobsFragment ui)` |
| 68 | `private` | `void setTimeText()` |
| 74 | `public` | `void saveSessionEnd()` |

---

### Findings for JobsPresenter.java

#### A50-14 [HIGH] `saveSessionEnd()` offline fallback grants a successful session end on any server failure when `hasOfflineData` is true, with no test coverage

**Location:** `saveSessionEnd()`, `onFailed` callback, lines 122–163

**Description:**
When the server call to end a session fails for any reason (network error, 401, 403, 500, timeout), the code checks `SessionDb.hasOfflineData(parameter.id)`. If true, it:
1. Calls `SessionDb.setSessionFinished(parameter.id, parameter.finish_time, true)` — marks the session as finished locally.
2. Calls `WebData.instance().onSessionEnded()` — stops the BLE connection.
3. Shows the "session_stopped" progress message.
4. Triggers the `YesNoDialog` asking the user to log out.

This mirrors the same structural problem as `EquipmentDriverAccessPresenter.createAndSaveSession()`: a 401 or 403 response from the server when closing the session is treated identically to a genuine network outage, allowing the session to be locally terminated and queued for sync. There is no test verifying that a 401/403 response on session end triggers an error rather than an offline commit.

---

#### A50-15 [HIGH] Constructor `JobsPresenter()` throws `NullPointerException` if no running session exists; untested

**Location:** `JobsPresenter(JobsFragment ui)`, lines 59–66

**Description:**
Line 62: `sessionResult = WebData.instance().getSessionResult()` calls `SessionDb.readRunningSession()`, which returns `null` if no running session is found.

Line 63: `startDate = LocalDateTime.fromDateFields(serverDateFormatter.parseDateTime(sessionResult.start_time))` — `sessionResult` is used without a null check. If `getSessionResult()` returns `null`, this line throws a `NullPointerException`, crashing the fragment before it is displayed.

Line 70 in `setTimeText()` also references `startDate` without a null guard.

There is no test verifying the constructor's behaviour when `getSessionResult()` returns null (e.g., after a session is cleared between screen transitions). The application appears to depend on a running session always existing when `JobsFragment` is created, but this invariant is not enforced by the constructor and is entirely untested.

---

#### A50-16 [MEDIUM] `saveSessionEnd()` duplicates `onFailed` handling code identically to `EquipmentDriverAccessPresenter.stopSession()` — both paths untested

**Location:** `saveSessionEnd()` lines 121–163; compare with `EquipmentDriverAccessPresenter.stopSession()` lines 255–270

**Description:**
The `onFailed` handling in `JobsPresenter.saveSessionEnd()` and `EquipmentDriverAccessPresenter.stopSession()` implement the same `hasOfflineData` branch logic independently. Both are untested. Changes to the offline session logic must be applied in multiple places, and without tests there is no way to verify that both implementations remain consistent.

---

#### A50-17 [MEDIUM] `saveSessionEnd()` `onFailed` branch shows success UI and triggers logout dialog even on server error

**Location:** `saveSessionEnd()`, `onFailed`, lines 127–157

**Description:**
When `hasOfflineData` is true and the server call fails, `ui.updateProgress(ui.getString(R.string.session_stopped))` is displayed — this is the same message shown on actual server success. The user sees no indication that a server error occurred, that the session end was only recorded locally, or that a subsequent sync is required. No test asserts the UI state shown on a failed server call with offline data.

---

#### A50-18 [MEDIUM] `setTimeText()` does not account for sessions lasting 24 hours or more

**Location:** `setTimeText()`, lines 68–72

**Description:**
The timer displays `%02d:%02d` for hours and minutes using `duration.getHours()`. The Joda-Time `Period.getHours()` field returns the hours component of the period, capped at the hours field (i.e., it does not overflow into days). For a session running longer than 23 hours 59 minutes, the displayed hours reset to zero. There is no test for sessions at the 24-hour boundary or beyond.

---

#### A50-19 [LOW] `timerRunnable` calls `setTimeText()` every 500ms but `setTimeText()` computes a full `Period` on every invocation; no test for timer drift or stop/restart correctness

**Location:** `timerRunnable`, lines 37–46; `startTimer()` lines 48–52; `stopTimer()` lines 54–57

**Description:**
- `stopTimer()` is public and can be called externally. `startTimer()` is private and is only called from the constructor. If `stopTimer()` is called and then the fragment is somehow reattached, the timer cannot be restarted.
- `myHandler.removeCallbacks(timerRunnable)` in `startTimer()` (line 49) guards against double-posting, but there is no test verifying the timer actually stops after `stopTimer()` is called, or that `timerStopped` is correctly read by the `Runnable` given potential race conditions with the main thread handler.

---

#### A50-20 [LOW] Duplicate import of `MyApplication` — dead code

**Location:** Lines 23 and 26

**Description:**
`au.com.collectiveintelligence.fleetiq360.ui.application.MyApplication` is imported twice. This is a compile-level warning that has been left unresolved, likely indicating the file was edited without automated import management. It has no runtime impact but indicates low code hygiene.

---

#### A50-21 [INFO] `saveSessionEnd()` `onSucceed` and `onFailed` (offline path) show identical logout dialogs with a 30-second timeout — no test verifies timeout triggers logout

**Location:** `saveSessionEnd()`, lines 92–114 and 132–154

**Description:**
Both the success and offline-fallback paths show a `YesNoDialog` with a 30-second `onTimeOutDialog` that calls `ui.logout()`. No test verifies the timer fires, that `ui.logout()` is actually invoked on timeout, or that the timeout value of 30 seconds is appropriate. This is a UX/safety concern rather than a security issue, but the absence of any test leaves the logout-on-timeout path completely unverified.

---

## Summary Table

| ID | Severity | File | Description |
|----|----------|------|-------------|
| A50-1 | HIGH | Project-wide | Zero automated test coverage in `app/` and `LibCommon/` |
| A50-2 | CRITICAL | EquipmentDriverAccessPresenter | Offline fallback grants local session on 401/403 and all non-400/502 errors |
| A50-3 | HIGH | EquipmentDriverAccessPresenter | `createAndSaveSession()` — all branches untested |
| A50-4 | HIGH | EquipmentDriverAccessPresenter | `onSessionNotStopped()` — all three dialog branches untested |
| A50-5 | MEDIUM | EquipmentDriverAccessPresenter | `deleteSession()` failure path silently marks aborted, shows misleading success message |
| A50-6 | MEDIUM | EquipmentDriverAccessPresenter | `stopSession()` offline fallback branch untested |
| A50-7 | MEDIUM | EquipmentDriverAccessPresenter | `resumeSession()` entirely untested |
| A50-8 | LOW | EquipmentDriverAccessPresenter | `getEquipmentItem()` edge cases (null list, duplicate IDs) untested |
| A50-9 | LOW | EquipmentDriverAccessPresenter | `onSessionSaved()` 10-second delay and sync trigger untested |
| A50-10 | CRITICAL | EquipmentSelectForkPresenter | `showImage()` calls `SSLCertificateHandler.nuke()` process-wide on every invocation; no test verifying TLS remains valid |
| A50-11 | HIGH | EquipmentSelectForkPresenter | `getEquipmentList()` both success and failure branches untested |
| A50-12 | MEDIUM | EquipmentSelectForkPresenter | `showImage()` null URL and null ImageView not tested |
| A50-13 | LOW | EquipmentSelectForkPresenter | `DisplayImageOptions` rebuilt on every call; cache correctness untested |
| A50-14 | HIGH | JobsPresenter | `saveSessionEnd()` offline fallback grants session end on 401/403; no test |
| A50-15 | HIGH | JobsPresenter | Constructor NPE when no running session exists; untested |
| A50-16 | MEDIUM | JobsPresenter | Duplicated `stopSession` offline logic across two presenters; both untested |
| A50-17 | MEDIUM | JobsPresenter | `saveSessionEnd()` offline failure shows identical success UI to server success |
| A50-18 | MEDIUM | JobsPresenter | `setTimeText()` does not handle sessions >= 24 hours; no boundary test |
| A50-19 | LOW | JobsPresenter | Timer stop/restart correctness and race condition untested |
| A50-20 | LOW | JobsPresenter | Duplicate `MyApplication` import — dead code |
| A50-21 | INFO | JobsPresenter | 30-second logout timeout on session-end dialog never tested |
