# Audit Pass 2 — Agent A49
**Audit run:** 2026-02-26-01
**Agent:** A49
**Files assigned:**
1. `app/src/main/java/au/com/collectiveintelligence/fleetiq360/model/SyncService.java`
2. `app/src/main/java/au/com/collectiveintelligence/fleetiq360/model/TakePhotoPathPrefs.java`
3. `app/src/main/java/au/com/collectiveintelligence/fleetiq360/model/UserInfoPrefs.java`

---

## PROJECT-WIDE FINDING — No Automated Test Coverage

**Severity: HIGH**

The `app/` and `LibCommon/` modules contain no test directories of any kind. There are no `src/test/` (JVM unit test) directories and no `src/androidTest/` (instrumentation test) directories in either module. This was confirmed by searching the repository tree. Third-party library submodules (`LibImageloader`, `LibImagePicker`, `LibPercentProgress`) have test scaffolding, but none of the application's own production code is covered by any automated test.

Consequences:
- Every behaviour described in the per-file findings below is entirely unverified by automation.
- Regressions in sync logic, data persistence, or preference access cannot be caught before release.
- The absence of tests does not make the code correct; it makes incorrect code invisible.

This finding applies to every source file in `app/` and `LibCommon/`. The per-file findings that follow identify specific gaps that are individually reportable even within this broader context.

---

## File 1 — SyncService.java

### Reading Evidence

**Fully qualified class name:** `au.com.collectiveintelligence.fleetiq360.model.SyncService`

**Superclass:** `android.app.IntentService`

**Fields / constants defined:**

| Name | Type | Line | Visibility |
|---|---|---|---|
| `TAG` | `static String` | 23 | private static |
| `webApi` | `WebApi` | 25 | private |

**Methods (all methods in the file):**

| Line | Signature |
|---|---|
| 27 | `public SyncService()` |
| 32 | `protected void onHandleIntent(Intent intent)` |
| 49 | `private void syncSession()` |
| 82 | `private void syncOfflineLocation()` |
| 98 | `private void deleteAbortedSession()` |
| 118 | `private void syncSessionItems()` |
| 157 | `public static void startService()` |

**Cross-referenced supporting classes read:**
- `SessionDb.java` — provides `removeSessionsToDelete()`, `readAllAbortedSessionsToSync()`, `readAllFinishedSessionsToSync()`, `setSessionSynced()`.
- `LocationDb.java` — provides `readAllLocationToSync()`, `uploadLocation()`.
- `WebApi.java` — provides `deleteSession()`, `syncSaveSession()`.
- `WebData.java` — provides `isAppInitialized()`, `getTokenString()`, `isSessionOffline()`.
- `MyApplication.java` — provides `runLater()`, `runOnMainThread()`, `getContext()`.
- `NetworkDetect.java` — provides `isNetworkConnected()`.

---

### Findings — SyncService.java

#### A49-1 [HIGH] — No test for sync failure leaving offline data in an inconsistent state

**Location:** `syncSessionItems()`, lines 118–155; `onHandleIntent()`, lines 32–47.

When `webApi.syncSaveSession()` fails (the `onFailed` callback at line 143), the code logs the failure and calls `startService()` to schedule a retry. However, `SessionDb.setSessionSynced()` is only called on success. On failure the session record in Realm retains its offline flags (`startedOffline`, `stoppedOffline`, `prestartOffline` all still `true`), so it will be re-queued in the next sync run. There is no test confirming:

1. That a failed sync leaves the Realm session record in exactly the same state it was in before the attempt (i.e., all offline flags unchanged).
2. That the retry actually occurs — that `startService()` is called — and with what delay.
3. That repeated failures do not lead to duplicate session creation on the server (the same negative-ID or real-ID session being posted again and again).
4. That a network failure mid-loop (e.g., first session succeeds, second fails) leaves already-synced records in the correct final state while leaving the failed record still pending.

No test exists for this code path. The session data involved records legally-required safety pre-start information for heavy equipment operations. Data inconsistency here is a compliance and safety risk.

#### A49-2 [HIGH] — No test verifying authentication token is valid before syncing

**Location:** `onHandleIntent()`, lines 32–47; `WebData.isAppInitialized()` (WebData.java lines 124–127).

`SyncService.onHandleIntent()` calls `WebApi.sync()` to obtain a `WebApi` instance and then immediately proceeds to sync. `WebApi.sync()` constructs a new `HttpClient` but performs no token validation. The HTTP client attaches the token via `WebData.getAuthHeader()`, which simply prepends "Bearer " to whatever token string is in `ModelPrefs` — including a null, an expired token, or an empty string.

`WebData.isAppInitialized()` is the only token check in the system and it is only consulted in `login()`, `register()`, and `resetPassword()` — not in any path exercised by `SyncService`. No test verifies:

1. That sync is aborted (or deferred) when no valid token exists.
2. That sync is aborted (or deferred) when the token has expired.
3. That a 401/403 response from the server during sync triggers re-authentication rather than silent failure.
4. That a "Bearer null" Authorization header is never sent to the server.

#### A49-3 [HIGH] — No test for retry logic — `startService()` rescheduling is untested

**Location:** `startService()`, lines 157–167; `onHandleIntent()`, lines 37–44.

There are two retry paths:
- **No network:** `onHandleIntent()` schedules a re-start in 10 seconds via `MyApplication.runLater()`, but then falls through and calls `syncSession()` immediately on line 46 regardless of connectivity. This means sync always runs even when the network check says it is unavailable.
- **Sync failure:** `onFailed` in `syncSessionItems()` calls `startService()`, which schedules a re-start in 5 seconds.

No test verifies:

1. That the no-network path reschedules correctly and does not proceed to sync.
2. That the fallthrough to `syncSession()` at line 46 even when no network is detected is the intended behaviour (it appears to be a bug — the intent appears to have been to `return` after scheduling the retry, but no `return` exists).
3. That `startService()` is actually called when `onFailed` fires.
4. That retry intervals are correct (10 s for connectivity, 5 s for API failure).
5. That repeated retries do not queue unbounded numbers of `startService` invocations via `runLater`.

#### A49-4 [HIGH] — No test for empty offline queue (zero-item sync run)

**Location:** `syncSessionItems()`, lines 118–155; `syncOfflineLocation()`, lines 82–96; `deleteAbortedSession()`, lines 98–116.

No test verifies the behaviour when the offline queues are empty:
- `readAllFinishedSessionsToSync()` returns an empty list — the `for` loop at line 121 executes zero iterations. This is correct, but untested.
- `readAllAbortedSessionsToSync()` returns an empty list — the `for` loop at line 100 executes zero iterations. Untested.
- `readAllLocationToSync()` returns an empty list — the size check at line 86 correctly skips the upload. Untested.

These are the normal steady-state paths (the device is online and all data has been previously synced). There is no test confirming this "nothing to do" path completes cleanly without throwing.

#### A49-5 [MEDIUM] — No test for aborted session with `sessionId <= 0` (offline-aborted before server-assigned ID)

**Location:** `deleteAbortedSession()`, lines 98–116; `SessionDb.abortedOffline` field.

The guard at line 101 (`sessionDb.abortedOffline && sessionDb.sessionId > 0`) means that sessions aborted while the device was offline with only a temporary negative ID are silently skipped — they are never sent to the server and are never cleaned up from Realm by this code path.

Separately, `removeSessionsToDelete()` is called first in `syncSession()`, but an aborted-offline session with `sessionId <= 0` has `abortedOffline = true` and `toDelete` depends on `canDeleteSessionDb()`. Tracing `canDeleteSessionDb()` (SessionDb.java line 280): for an aborted session where `aborted = true`, it returns `!abortedOffline || sessionId <= 0`. So when `abortedOffline = true` and `sessionId <= 0`, `canDeleteSessionDb()` returns `true`, meaning `toDelete` will be set and `removeSessionsToDelete()` will remove it. However, this only happens if `setToDeleteIfPossible()` has been called after the abort was set, and there is no test covering this entire cleanup chain end-to-end.

No test verifies that an offline-aborted session with no server ID is eventually removed from Realm without leaking.

#### A49-6 [MEDIUM] — No test for `deleteAbortedSession()` success path — `SessionDb` not marked deleted after server confirms

**Location:** `deleteAbortedSession()`, lines 98–116; `WebApi.deleteSession()` (WebApi.java lines 269–284).

`WebApi.deleteSession()` internally calls `SessionDb.setSessionAborted(sessionId, false)` on success (WebApi.java line 275), which resets `abortedOffline` to `false` and calls `setToDeleteIfPossible()`. However, `deleteAbortedSession()` in `SyncService` passes its own anonymous `WebListener` callbacks (lines 103–113) that only log; they do not call any Realm update themselves. The actual cleanup happens inside `WebApi.deleteSession()`'s internal listener. This layered callback structure is untested — no test confirms that after a successful delete-session API call the Realm record transitions to `toDelete = true` and is subsequently removed by `removeSessionsToDelete()` on the next sync run.

#### A49-7 [MEDIUM] — `Thread.sleep()` calls inside `syncSession()` make the service untimely interruptible — no test for interruption handling

**Location:** `syncSession()`, lines 49–80.

`syncSession()` contains four `Thread.sleep()` calls with hardcoded durations (2000 ms, 2000 ms, 1000 ms, 1000 ms) and one in `syncOfflineLocation()` (100 ms). Each catches `InterruptedException` and calls `e.printStackTrace()` only — the interrupted status is not restored and the sync sequence continues as if no interruption occurred. This means:

1. If the service's worker thread is interrupted (e.g., during system shutdown), the sync continues instead of stopping cleanly.
2. The hardcoded sleep durations are never validated against any business requirement.
3. No test covers the interrupted path to confirm safe shutdown behaviour.

Note: `IntentService` manages its own thread, but the thread can still be interrupted externally.

#### A49-8 [MEDIUM] — No test for `syncSessionItems()` when `getSessionResult()` returns null

**Location:** `syncSessionItems()`, lines 118–155; specifically line 123 (`if (null == sessionResult) continue`).

`getSessionResult()` in `SessionDb` deserialises `dataStr` via Gson. If `dataStr` is null, empty, or corrupt JSON, `GsonHelper.objectFromString()` returns null, and the code falls into the `continue` path, silently skipping that session. There is no test confirming:

1. That a corrupt `dataStr` results in a clean skip without exception.
2. That the skipped session is not removed from the offline queue, so it will be retried (or whether it will be skipped permanently).
3. That a null `sessionResult` alongside a non-null `dataStr` (i.e., a Gson parse failure) is distinguishable from a legitimately empty record.

#### A49-9 [LOW] — `webApi` field is initialised lazily inside `onHandleIntent()` but `SyncService` is a one-shot `IntentService` — lazy init is unnecessary and untested

**Location:** `onHandleIntent()`, lines 33–35.

`IntentService` creates a fresh service instance for each start intent in some Android configurations. The null-check `if (null == webApi)` at line 33 implies the instance may be reused, but `IntentService` guarantees `onHandleIntent` is called sequentially on a single background thread per service instance. In practice this null check is always true on first call and never true thereafter within one instance. The pattern is confusing and there is no test confirming that a reused `webApi` (if reuse were possible) does not hold stale state from a previous sync.

#### A49-10 [LOW] — No test for `startService()` throwing `IllegalStateException` silently

**Location:** `startService()`, lines 157–167; specifically line 162–163.

The `IllegalStateException` catch at line 163 silently suppresses the exception (marked `ignored`). On Android 8.0+ (API 26), starting a background service from a background process throws `IllegalStateException`. No test verifies:

1. That this exception is correctly caught and does not propagate.
2. That when this exception occurs, the sync is not silently abandoned without any retry.
3. Whether the "runLater" delay of 5000 ms is meaningful in this context (the app may be in the foreground by then).

#### A49-11 [INFO] — `syncSession()` always calls `syncSessionItems()` even when network is not available

**Location:** `onHandleIntent()`, lines 37–46; `syncSession()`, line 46.

The network unavailability check at line 37 schedules a retry via `runLater` but does not `return`. Execution continues to `syncSession()` at line 46, which in turn calls `syncSessionItems()`, `syncOfflineLocation()`, and `deleteAbortedSession()`. Each of these makes network API calls that will fail because there is no connectivity. The sync failure path then schedules another `startService()` retry, resulting in two scheduled retries instead of one. This appears to be an unintentional bug but could be a deliberate design choice; without a test, it is impossible to distinguish intent from defect.

---

## File 2 — TakePhotoPathPrefs.java

### Reading Evidence

**Fully qualified class name:** `au.com.collectiveintelligence.fleetiq360.model.TakePhotoPathPrefs`

**Superclass:** none (implicit `Object`)

**Fields / constants defined:**

| Name | Type | Line | Visibility |
|---|---|---|---|
| `KEY_0` | `private static String` | 14 | private static |
| `KEY_1` | `private static String` | 15 | private static |
| `KEY_2` | `private static String` | 16 | private static |
| `KEY_3` | `private static String` | 17 | private static |
| `keyArray` | `private static String[]` | 18 | private static |

**Methods:**

| Line | Signature |
|---|---|
| 21 | `static SharedPreferences getPref()` |
| 26 | `public static void saveObjectFromPosition(int position, String path)` |
| 38 | `public static int hasInvalidPhoto()` |
| 46 | `public static String getImagePathFromPosition(int position)` |
| 53 | `public static void clearImages()` |

---

### Findings — TakePhotoPathPrefs.java

#### A49-12 [MEDIUM] — No test for `saveObjectFromPosition()` with out-of-bounds position — silent no-op

**Location:** `saveObjectFromPosition()`, lines 26–36.

The method handles positions 0, 1, 2, and 3 via explicit `if/else if` branches. Any `position` value outside [0, 3] (negative values, or values >= 4) results in a complete no-op — no write, no exception, no log. The caller receives no indication that the write was discarded. There is no test for:

1. `position = -1` — silent failure.
2. `position = 4` — silent failure.
3. `position = Integer.MAX_VALUE` — silent failure.

A caller passing an off-by-one index would silently lose photo data with no diagnostic.

#### A49-13 [MEDIUM] — No test for `hasInvalidPhoto()` — boundary and mixed-state cases

**Location:** `hasInvalidPhoto()`, lines 38–45.

`hasInvalidPhoto()` iterates `keyArray` indices 0–3 and returns the first index where the stored string is `null`. It returns `-1` if all four are non-null. No test verifies:

1. All four slots null — returns `0` (the first null found).
2. All four slots populated — returns `-1`.
3. Slots 0 and 2 populated, slots 1 and 3 null — returns `1` (first null encountered in order).
4. Slot 3 null, all others populated — returns `3`.
5. Whether `hasInvalidPhoto()` correctly round-trips with `saveObjectFromPosition()` and `clearImages()`.

The method name suggests a boolean semantic ("has invalid photo?") but it returns an index. A caller testing `if (hasInvalidPhoto())` would misinterpret position `0` (a valid return meaning "slot 0 is missing") as `false` in a boolean context. This is not tested.

#### A49-14 [MEDIUM] — No test for `getImagePathFromPosition()` with boundary positions

**Location:** `getImagePathFromPosition()`, lines 46–51.

The method correctly guards `position >= 0 && position < 4`, returning `null` outside that range. No test verifies:

1. `position = -1` returns `null`.
2. `position = 4` returns `null`.
3. `position = 0` through `3` each return the correct stored value.
4. Return value when the key exists but was saved as the empty string `""` (distinct from null — `SharedPreferences.getString()` with a null default would return `""` only if stored as `""`).

#### A49-15 [MEDIUM] — No test for `clearImages()` — partial clear on commit failure is undetected

**Location:** `clearImages()`, lines 53–58.

`clearImages()` issues four separate `commit()` calls. `SharedPreferences.Editor.commit()` returns a `boolean` indicating success or failure, and all four return values are discarded. On a storage error, some keys may be removed and others not, leaving a partially-cleared state. No test verifies:

1. That all four keys are absent after `clearImages()` completes.
2. That the method is idempotent (calling it twice yields the same result).
3. Interaction with `hasInvalidPhoto()` immediately after `clearImages()` — all four slots should be null so `hasInvalidPhoto()` must return `0`.

Additionally, each `getPref()` call opens a new `SharedPreferences` reference, and each edit is a separate transaction. This is four writes where one `apply()` clearing all four at once would be atomic. This is not tested.

#### A49-16 [LOW] — No test that `saveObjectFromPosition()` uses `commit()` (synchronous) rather than `apply()` (asynchronous) — inconsistency with `clearImages()`

**Location:** Lines 29–35 (`saveObjectFromPosition()`), lines 54–57 (`clearImages()`).

Both methods use `commit()`. There is no test verifying that the synchronous write completes before any subsequent read operation — a test that writes a path via `saveObjectFromPosition()` and immediately reads it back via `getImagePathFromPosition()` would confirm the contract. Without it there is no documentation that the synchronous write is intentional (as opposed to `apply()`, which could race with an immediate read).

#### A49-17 [LOW] — Unused variable `s` in `saveObjectFromPosition()` at line 27

**Location:** `saveObjectFromPosition()`, line 27.

`String s = "";` is declared but never used. This is dead code. While not a test coverage gap per se, it has never been caught because there are no tests for this method and no static analysis is configured.

---

## File 3 — UserInfoPrefs.java

### Reading Evidence

**Fully qualified class name:** `au.com.collectiveintelligence.fleetiq360.model.UserInfoPrefs`

**Superclass:** `au.com.collectiveintelligence.fleetiq360.model.ModelPrefs`

**Fields / constants defined:**

| Name | Type | Line | Visibility |
|---|---|---|---|
| `TAG` | `private static String` | 14 | private static |
| `USER_INFO_PREFS_KEY` | `private static String` | 15 | private static |

**Methods:**

| Line | Signature |
|---|---|
| 16 | `static SharedPreferences getUserInfoPrefs()` |

**Note:** `UserInfoPrefs` inherits all public static methods from `ModelPrefs`: `saveInt`, `readInt`, `deleteDataForKey`, `saveString`, `readString`, `saveBoolean`, `readBoolean`, `saveObject`, `readObject`. Those methods write to the `"prefs"` SharedPreferences store, not to `"usrInfoPrefs"`.

---

### Findings — UserInfoPrefs.java

#### A49-18 [HIGH] — `getUserInfoPrefs()` is never called anywhere in the class — the `"usrInfoPrefs"` store is completely inaccessible

**Location:** `getUserInfoPrefs()`, lines 16–19; `USER_INFO_PREFS_KEY`, line 15.

`UserInfoPrefs.getUserInfoPrefs()` returns a `SharedPreferences` instance for the `"usrInfoPrefs"` store. However:

1. The method is package-private (`static` without `public`) and is never called within the class itself.
2. `USER_INFO_PREFS_KEY` is declared but never referenced.
3. All inherited methods (`saveString`, `readString`, etc.) from `ModelPrefs` read and write the base `"prefs"` store, not `"usrInfoPrefs"`.

This means any caller using `UserInfoPrefs.saveString(key, value)` is writing to the shared `"prefs"` store, not to the `"usrInfoPrefs"` store that the class declares. The segregated user-info preferences store is completely unreachable from outside the package without bypassing the class hierarchy. No test exists to confirm whether `UserInfoPrefs` ever writes to its own dedicated store, or whether any user-info data is correctly isolated.

This is likely an incomplete implementation — the class appears to have been scaffolded but the per-store read/write methods were never added.

#### A49-19 [MEDIUM] — No test that `UserInfoPrefs` write operations are correctly isolated from the base `ModelPrefs` store

**Location:** `UserInfoPrefs` class, lines 1–21; `ModelPrefs.java` (`getPref()` returning the `"prefs"` store).

Because `UserInfoPrefs` inherits `ModelPrefs` without overriding any read/write method, calling `UserInfoPrefs.saveString("foo", "bar")` writes to the `"prefs"` SharedPreferences file. A separate call to `ModelPrefs.saveString("foo", "baz")` would overwrite it. There is no test confirming that user-info data is stored in isolation from general model preferences, or that data intended for `"usrInfoPrefs"` does not collide with keys in `"prefs"`.

#### A49-20 [LOW] — `TAG` is declared but never used

**Location:** `UserInfoPrefs.java`, line 14.

`private static String TAG = UserInfoPrefs.class.getSimpleName();` is declared but never referenced. This is consistent with an incomplete class but in the absence of tests has gone unnoticed.

---

## Summary Table

| ID | Severity | File | Description |
|---|---|---|---|
| — | HIGH (project-wide) | all | Zero automated test coverage in `app/` and `LibCommon/` |
| A49-1 | HIGH | SyncService.java | No test for sync failure leaving offline data inconsistent |
| A49-2 | HIGH | SyncService.java | No test verifying token is valid before syncing |
| A49-3 | HIGH | SyncService.java | No test for retry logic and rescheduling correctness |
| A49-4 | HIGH | SyncService.java | No test for empty offline queue (zero-item sync) |
| A49-5 | MEDIUM | SyncService.java | No test for offline-aborted session with no server ID cleanup |
| A49-6 | MEDIUM | SyncService.java | No test for delete-aborted-session success path Realm transition |
| A49-7 | MEDIUM | SyncService.java | No test for interrupted sleep in sync sequence |
| A49-8 | MEDIUM | SyncService.java | No test for null `getSessionResult()` (corrupt Gson) skip path |
| A49-9 | LOW | SyncService.java | Unnecessary lazy `webApi` init — untested reuse assumptions |
| A49-10 | LOW | SyncService.java | No test that `IllegalStateException` suppression does not silently abandon sync |
| A49-11 | INFO | SyncService.java | `syncSession()` always called even when no-network detected — double retry scheduling |
| A49-12 | MEDIUM | TakePhotoPathPrefs.java | No test for out-of-bounds position in `saveObjectFromPosition()` — silent no-op |
| A49-13 | MEDIUM | TakePhotoPathPrefs.java | No test for `hasInvalidPhoto()` mixed and boundary states |
| A49-14 | MEDIUM | TakePhotoPathPrefs.java | No test for `getImagePathFromPosition()` boundary positions |
| A49-15 | MEDIUM | TakePhotoPathPrefs.java | No test for `clearImages()` — partial clear and idempotency |
| A49-16 | LOW | TakePhotoPathPrefs.java | No test confirming synchronous `commit()` contract for write-then-read |
| A49-17 | LOW | TakePhotoPathPrefs.java | Dead variable `s` in `saveObjectFromPosition()` — no static analysis |
| A49-18 | HIGH | UserInfoPrefs.java | `getUserInfoPrefs()` unreachable; `"usrInfoPrefs"` store never written — incomplete implementation |
| A49-19 | MEDIUM | UserInfoPrefs.java | No test confirming user-info data is isolated from base `ModelPrefs` store |
| A49-20 | LOW | UserInfoPrefs.java | Unused `TAG` field — dead code in incomplete class |
