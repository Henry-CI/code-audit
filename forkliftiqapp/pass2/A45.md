# Audit Pass 2 — Agent A45
**Audit run:** 2026-02-26-01
**Agent:** A45
**Files assigned:**
1. `app/src/main/java/au/com/collectiveintelligence/fleetiq360/model/CacheService.java`
2. `app/src/main/java/au/com/collectiveintelligence/fleetiq360/model/DataBaseHelp.java`
3. `app/src/main/java/au/com/collectiveintelligence/fleetiq360/model/EquipmentDb.java`

---

## PROJECT-WIDE FINDING

### A45-1 — HIGH: Zero automated test coverage across `app/` and `LibCommon/` modules

No `test/` or `androidTest/` directories exist under either `app/src/` or `LibCommon/src/`. The only test infrastructure in the repository lives in third-party library modules (`LibImageloader`, `LibImagePicker`, `LibPercentProgress`) that are not authored by the project team. Every class in the core application and common library modules — including all database helpers, network services, and business logic — is entirely untested by automated means. All findings below describe gaps where tests should exist but the absence is total, not partial.

**Evidence:** `find app/src -type d -name test` and `find app/src -type d -name androidTest` both return empty. Same result for `LibCommon/src`.

---

## Reading Evidence

### File 1: `CacheService.java`

**Fully qualified class name:** `au.com.collectiveintelligence.fleetiq360.model.CacheService`
**Superclass:** `android.app.IntentService`

**Fields / constants:**
| Name | Type | Line |
|---|---|---|
| `TAG` | `static String` | 18 |
| `webApi` | `WebApi` | 19 |

**Methods:**
| Line | Signature |
|---|---|
| 21 | `public CacheService()` |
| 26 | `protected void onHandleIntent(Intent intent)` |
| 76 | `public static void startService()` |

---

### File 2: `DataBaseHelp.java`

**Fully qualified class name:** `au.com.collectiveintelligence.fleetiq360.model.DataBaseHelp`
**Access:** package-private class

**Fields / constants:** none

**Methods:**
| Line | Signature |
|---|---|
| 9 | `static <E extends RealmModel> RealmQuery<E> getRealmQuery(Realm realm, Class<E> clazz)` |
| 13 | `static boolean isExpired(long updateTime)` |

**Constants used inline:**
- Cache TTL: `2 * 60 * 60 * 1000` ms (2 hours), hardcoded at line 19.

---

### File 3: `EquipmentDb.java`

**Fully qualified class name:** `au.com.collectiveintelligence.fleetiq360.model.EquipmentDb`
**Superclass:** `io.realm.RealmObject`

**Fields:**
| Name | Type | Line |
|---|---|---|
| `userId` | `int` | 12 |
| `updateTime` | `long` | 13 |
| `equipmentListStr` | `String` | 14 |

**Methods:**
| Line | Signature |
|---|---|
| 16 | `private boolean isExpired()` |
| 20 | `static boolean needToCache(final int userId)` |
| 30 | `public static GetEquipmentResultArray getEquipmentResultArray(final int userId)` |
| 45 | `public static void saveEquipmentResultArray(final int userId, final GetEquipmentResultArray getEquipmentResultArray)` |

---

## Cross-file context: `SafeRealm.java`

Reviewed to understand how `EquipmentDb` and `CacheService` interact with Realm.

**Fully qualified class name:** `au.com.collectiveintelligence.fleetiq360.model.SafeRealm`

**Methods:**
| Line | Signature |
|---|---|
| 7 | `public static void Execute(SafeRealm.Action action)` |
| 13 | `public static void executeTransaction(final SafeRealm.Action action)` |
| 24 | `public static <T> T Execute(SafeRealm.Func<T> func)` |

**Interfaces defined:** `Action` (line 31), `Func<T>` (line 35).

**Realm schema configuration (MyApplication.java line 68–72):**
```java
RealmConfiguration config = new RealmConfiguration.Builder()
        .schemaVersion(4)
        .deleteRealmIfMigrationNeeded()
        .build();
```

---

## Findings

---

### A45-2 — HIGH: `EquipmentDb.needToCache` — no test for concurrent Realm access

**File:** `EquipmentDb.java`, line 20–28

`needToCache` calls `SafeRealm.Execute` which opens a default Realm instance, executes the query lambda, then closes it (SafeRealm.java lines 24–29). Realm instances are thread-confined: a `Realm` object opened on one thread cannot be accessed from another. `CacheService.onHandleIntent` (a worker thread managed by `IntentService`) calls `EquipmentDb.needToCache` (line 32) and `EquipmentDb.getEquipmentResultArray` (line 48) in sequence. If either call is interleaved with a write from another thread (e.g., a network callback calling `saveEquipmentResultArray`), the behaviour is undefined and may produce a `io.realm.exceptions.RealmException` or silently stale data.

No test exists that:
- Opens two Realm operations simultaneously from different threads.
- Verifies that `needToCache` and `getEquipmentResultArray` produce consistent results under concurrent write load.
- Asserts that no `RealmException` is thrown when concurrent access occurs.

**Severity:** HIGH — concurrent database access in a background-service context with no test protection is a realistic failure path in production.

---

### A45-3 — HIGH: `EquipmentDb.getEquipmentResultArray` — no test for corrupted or unparseable `equipmentListStr`

**File:** `EquipmentDb.java`, line 30–43

When a record exists with a non-null `equipmentListStr`, the method delegates to `GsonHelper.objectFromString(equipments.get(0).equipmentListStr, GetEquipmentResultArray.class)` (line 36). `GsonHelper.objectFromString` calls `new Gson().fromJson(data, dataClass)` with no try/catch. If `equipmentListStr` is malformed JSON (e.g., truncated by a crash during `saveEquipmentResultArray`, or corrupted on disk), `Gson.fromJson` will throw a `JsonSyntaxException` (a `RuntimeException`). This exception propagates through `SafeRealm.Execute`, which also has no catch block, and will crash `CacheService.onHandleIntent` without any recovery.

No test exists for:
- A record present in Realm where `equipmentListStr` is malformed JSON.
- A record where `equipmentListStr` is an empty string `""`.
- A record where `equipmentListStr` is `null`.

**Severity:** HIGH — a single on-disk corruption causes an uncaught crash every time the background service runs until the data is cleared.

---

### A45-4 — HIGH: `EquipmentDb.saveEquipmentResultArray` — no test for `GsonHelper.stringFromObjectNoPolicy` returning empty string

**File:** `EquipmentDb.java`, line 45–56; `GsonHelper.java`, line 43–51

`saveEquipmentResultArray` stores the result of `GsonHelper.stringFromObjectNoPolicy(getEquipmentResultArray)` as `equipment.equipmentListStr`. `stringFromObjectNoPolicy` silently returns `""` when serialisation fails (it catches `Exception` and ignores it). If the input object fails serialisation, an empty string `""` is persisted to Realm without any indication of error. On the next call to `getEquipmentResultArray`, this empty string is passed to `Gson.fromJson`, which returns `null` for an empty string input, causing `getEquipmentResultArray` to return `null` instead of the expected array — despite a non-empty result-set existing in Realm.

No test exists for:
- Saving when serialisation fails, and verifying that `equipmentListStr` is not silently set to `""`.
- Reading back a record that has `equipmentListStr == ""` and verifying the return value.

**Severity:** HIGH — a silent write failure poisons the cache entry and causes downstream null-dereference hazards without any logged error.

---

### A45-5 — HIGH: Schema migration silently deletes all data — no test or documentation

**File:** `MyApplication.java`, lines 65–73 (cross-file context for `EquipmentDb`)

The Realm configuration uses `.deleteRealmIfMigrationNeeded()`. When the schema version is bumped, all data in every Realm table — including `EquipmentDb`, `PreStartQuestionDb`, `SessionDb`, and all other models — is silently deleted rather than migrated. This is an explicit design choice, but:

1. There is no test verifying that post-delete the app recovers correctly (re-caches equipment, re-fetches sessions, etc.).
2. There is no test verifying that a schema-version mismatch is detected at startup rather than at first use.
3. There is no test asserting that `EquipmentDb.getEquipmentResultArray` returns a valid empty array (not null) immediately after a migration-triggered delete.

**Severity:** HIGH — users who update the app lose all locally cached data and offline sessions without warning. The recovery path is untested.

---

### A45-6 — HIGH: `CacheService.onHandleIntent` — network callback results are ignored; no test for failure path side-effects

**File:** `CacheService.java`, lines 33–43

`webApi.getEquipmentList` is called with a `WebListener` whose `onSucceed` only logs and whose `onFailed` only logs. Neither callback calls `EquipmentDb.saveEquipmentResultArray`. Separately, the equipment list is then read back from the database on line 48 — but if this is the first run (nothing cached yet) and the network call has not yet completed (it is asynchronous), `getEquipmentResultArray` returns an empty `ArrayList`, and zero pre-start questions are cached. The result is that `CacheService` silently completes with no data cached, and no error is surfaced.

No test exists for:
- Verifying that equipment data is actually persisted after a successful `getEquipmentList` response.
- Verifying the behaviour when `needToCache` returns true but the network call fails.
- Verifying that pre-start question caching is skipped when the equipment list is empty due to a pending or failed network call.

**Severity:** HIGH — the cache miss on first launch is a silent failure with no recovery mechanism tested.

---

### A45-7 — MEDIUM: `DataBaseHelp.isExpired` — no test for boundary at exactly 2 hours

**File:** `DataBaseHelp.java`, lines 13–21

The expiry logic computes `du = currentTime - updateTime` and returns `du > de` where `de = 2 * 60 * 60 * 1000` (7200000 ms). The condition is strict greater-than, meaning a record updated exactly 2 hours ago is **not** considered expired (`du == de` returns false). This is a potential off-by-one in cache behaviour. No test exercises:
- `updateTime == currentTime - 7200000` (exactly at boundary — expect not expired).
- `updateTime == currentTime - 7200001` (one millisecond past — expect expired).
- `updateTime == currentTime - 7199999` (one millisecond before — expect not expired).
- `updateTime > currentTime` (future timestamp, lines 15–16 — returns `false`; no test for this branch).

**Severity:** MEDIUM — incorrect expiry decisions cause either unnecessary network requests or stale cache reads; the future-timestamp branch is particularly unexpected.

---

### A45-8 — MEDIUM: `DataBaseHelp.isExpired` — no test for future `updateTime`

**File:** `DataBaseHelp.java`, lines 15–16

If `updateTime > currentTime`, the method returns `false` (not expired). This can occur if the device clock is set forward and then corrected backward, leaving a persisted `updateTime` in the future. The result is that the cached record is permanently considered fresh until the wall clock catches up — potentially hours or days. No test covers this scenario.

**Severity:** MEDIUM — clock skew is a realistic condition on embedded devices (forklifts may have unreliable RTC batteries); this silent failure keeps stale data indefinitely.

---

### A45-9 — MEDIUM: `CacheService.onHandleIntent` — `Thread.sleep(100)` with swallowed `InterruptedException`

**File:** `CacheService.java`, lines 68–72

```java
try {
    Thread.sleep(100);
} catch (InterruptedException e) {
    e.printStackTrace();
}
```

The `InterruptedException` is caught and its stack trace printed, but the thread's interrupt flag is not restored (`Thread.currentThread().interrupt()` is not called). This means that if the `IntentService`'s worker thread is interrupted (e.g., during shutdown), the interruption is silently swallowed, and the thread continues executing instead of terminating. No test verifies that interruption during the sleep propagates correctly, nor is there a test for why this sleep exists at all (the comment is absent — the intent is presumably to let async network callbacks settle, which is itself a race condition).

**Severity:** MEDIUM — swallowing `InterruptedException` is a well-known concurrency defect; in a service context it can prevent clean shutdown.

---

### A45-10 — MEDIUM: `EquipmentDb.needToCache` — `equipments.get(0)` called without null guard after size check

**File:** `EquipmentDb.java`, line 25

```java
return equipments.size() == 0 || equipments.get(0).isExpired();
```

`RealmResults` from `findAll()` is never null in Realm 3.x+, so the `size() == 0` guard is appropriate. However, Realm `RealmResults` are live objects: between the `size()` check and `get(0)`, a concurrent transaction could delete the record, making `get(0)` return null or throw. This is a TOCTOU (time-of-check/time-of-use) race within a single `SafeRealm.Execute` call. No test exercises this window.

**Severity:** MEDIUM — this is the same concurrent-access risk as A45-2 but specifically within a single read lambda; worth noting separately as the fix differs (snapshot query vs. thread isolation).

---

### A45-11 — LOW: `CacheService` constructor passes wrong name to `super()`

**File:** `CacheService.java`, line 22

```java
public CacheService() {
    super(IntentService.class.getSimpleName());
}
```

The `IntentService` constructor parameter is a name string used for the worker thread. The conventional value is the subclass's own name (e.g., `CacheService.class.getSimpleName()` or the string literal `"CacheService"`). Passing `IntentService.class.getSimpleName()` names the thread `"IntentService"`, which makes log output and thread dumps misleading. No test verifies the thread name or flags this as an error (it does not affect functionality, but makes debugging harder).

**Severity:** LOW — no runtime impact, but degrades observability.

---

### A45-12 — LOW: `DataBaseHelp.getRealmQuery` — package-private and untested

**File:** `DataBaseHelp.java`, line 9

`getRealmQuery` is package-private and intended as a shared helper. It filters by `WebData.instance().getUserId()`, which is a singleton call. No test verifies:
- That the correct `userKey` value is used.
- That the method handles a null or uninitialized `WebData` instance.
- That the resulting query object is valid when passed to callers.

Since `DataBaseHelp` is package-private, it can only be tested via its callers or with a package-level test. Neither exists.

**Severity:** LOW — the helper is simple, but incorrect filtering by `userKey` would expose one user's data to another.

---

### A45-13 — LOW: `EquipmentDb.getEquipmentResultArray` — returns synthetic empty array when no record found, masking a "not cached" state

**File:** `EquipmentDb.java`, lines 38–41

When no `EquipmentDb` record exists for the given `userId`, the method returns a `GetEquipmentResultArray` with an empty `arrayList` rather than `null`. This makes it impossible for callers to distinguish between "cache is empty because the user has no equipment" and "cache has not been populated yet". In `CacheService.onHandleIntent` (line 49), the `resultArray != null && resultArray.arrayList != null` guard passes in both cases, and the loop body is simply skipped — silently. No test distinguishes these two states.

**Severity:** LOW — the current callers tolerate this, but the design choice eliminates a useful signal.

---

### A45-14 — INFO: `CacheService.startService` — 5-second delay hardcoded with no configurability

**File:** `CacheService.java`, line 82

`MyApplication.runLater(..., 5000)` hardcodes a 5-second startup delay. This value is not a named constant and is not configurable. In slow-start or low-memory scenarios, 5 seconds may be insufficient; in tests, it makes any integration test that depends on cache state require a 5-second wait. Extracting this as a named constant or making it injectable would improve testability.

**Severity:** INFO — suggestion only; no direct risk.

---

### A45-15 — INFO: `DataBaseHelp.isExpired` — 2-hour TTL is a magic number with no named constant

**File:** `DataBaseHelp.java`, line 19

```java
long de = 2 * 60 * 60 * 1000;
```

The cache TTL is embedded as a magic number. It is not a named constant, not configurable, and not documented. Should the TTL need to differ between environments (e.g., shorter in staging, longer for pre-start questions vs. equipment list), the value must be found and changed in multiple places. No test asserts the TTL value.

**Severity:** INFO — suggestion only.

---

## Summary Table

| ID | Severity | File | Description |
|---|---|---|---|
| A45-1 | HIGH | Project-wide | Zero automated test coverage in `app/` and `LibCommon/` modules |
| A45-2 | HIGH | EquipmentDb.java | No test for concurrent Realm access from CacheService worker thread |
| A45-3 | HIGH | EquipmentDb.java | No test for corrupted/malformed `equipmentListStr` causing uncaught `JsonSyntaxException` |
| A45-4 | HIGH | EquipmentDb.java | No test for `stringFromObjectNoPolicy` returning `""` silently poisoning the cache entry |
| A45-5 | HIGH | EquipmentDb.java (via MyApplication) | `deleteRealmIfMigrationNeeded` silently deletes all data; recovery path untested |
| A45-6 | HIGH | CacheService.java | Network callbacks do not persist data; async race with immediate DB read is untested |
| A45-7 | MEDIUM | DataBaseHelp.java | No boundary test for `isExpired` at exactly the 2-hour threshold |
| A45-8 | MEDIUM | DataBaseHelp.java | No test for future `updateTime` causing permanently stale cache |
| A45-9 | MEDIUM | CacheService.java | `InterruptedException` swallowed in `Thread.sleep`; interrupt flag not restored |
| A45-10 | MEDIUM | EquipmentDb.java | TOCTOU between `size()` check and `get(0)` under concurrent Realm writes |
| A45-11 | LOW | CacheService.java | Constructor passes `IntentService` class name instead of `CacheService` to `super()` |
| A45-12 | LOW | DataBaseHelp.java | `getRealmQuery` untested; incorrect `userKey` could expose cross-user data |
| A45-13 | LOW | EquipmentDb.java | Synthetic empty array return masks "not cached" vs "no equipment" states |
| A45-14 | INFO | CacheService.java | 5-second startup delay is a hardcoded magic number; hinders integration testing |
| A45-15 | INFO | DataBaseHelp.java | 2-hour TTL is a magic number with no named constant or configurability |
