# Pass 2 Audit — Agent A70
**Audit run:** 2026-02-26-01
**Assigned files:**
1. `app/src/main/java/au/com/collectiveintelligence/fleetiq360/util/CompanyDateFormatter.java`
2. `app/src/main/java/au/com/collectiveintelligence/fleetiq360/util/ComplianceAccepter.java`
3. `app/src/main/java/au/com/collectiveintelligence/fleetiq360/util/ServerDateFormatter.java`

---

## Project-Wide Finding: Zero Automated Test Coverage (HIGH)

**ID:** A70-1
**Severity:** HIGH
**Scope:** Project-wide — `app/` and `LibCommon/` modules

The `app/` and `LibCommon/` modules contain no test directories whatsoever. A glob search for `**/test/**/*.java` across the entire repository found only two test files, both in the third-party `LibImageloader/` module (`ImageSizeTest.java` and `BaseImageDownloaderTest.java`). Those tests cover library internals, not application code.

Every class in `app/src/main/java/` — including all three files assigned to this agent — has zero automated test coverage. No unit tests, no integration tests, and no instrumented Android tests exist for any application logic. This means:

- Regressions can be introduced without any automated detection.
- Security-relevant behaviour (compliance gating, date parsing used in access control decisions) is entirely unverified by tests.
- No test suite validates correct operation across releases.

All file-specific findings below exist against a backdrop of total absence of tests. Each finding describes what test coverage is missing; none of the gaps are mitigated by tests elsewhere in the project.

---

## File 1: CompanyDateFormatter.java

### Reading Evidence

**Fully qualified class name:** `au.com.collectiveintelligence.fleetiq360.util.CompanyDateFormatter`

**Fields defined:**
- `private SimpleDateFormat timeFormat` (line 10)
- `private SimpleDateFormat dateFormat` (line 11)
- `private SimpleDateFormat dateTimeFormat` (line 12)

**Methods (with line numbers and signatures):**
- `public CompanyDateFormatter(String companyDateTimeFormatPattern)` — line 14
- `public String formatTime(Date date)` — line 24
- `public String formatDate(Date date)` — line 28
- `public String formatDateTime(Date date)` — line 32
- `public Date parseDate(String date)` — line 36

**Constants defined:** None.

**Types imported:** `java.text.ParsePosition`, `java.text.SimpleDateFormat`, `java.util.Date`, `java.util.Locale`, `java.util.TimeZone`

### Findings

---

**ID:** A70-2
**Severity:** MEDIUM
**File:** `CompanyDateFormatter.java`
**Subject:** `parseDate()` has no null or empty-string guard

`parseDate(String date)` at line 36 passes its argument directly to `dateFormat.parse(date, new ParsePosition(0))` with no null check and no empty-string check. When `date` is `null`, `SimpleDateFormat.parse()` throws a `NullPointerException`. When `date` is an empty string or contains unparseable content, `parse()` returns `null` silently (because `ParsePosition` is used rather than the throwing overload), which propagates a silent `null` `Date` to all callers.

By contrast, `ServerDateFormatter.parseDate()` (see File 3 below) does include an explicit null/empty guard at lines 30-31. The asymmetry between the two sibling formatters suggests the guard was added reactively to `ServerDateFormatter` and was never back-ported to `CompanyDateFormatter`.

No test exercises: null input, empty-string input, a string that matches the wrong date pattern, or a string that is a partial match.

---

**ID:** A70-3
**Severity:** MEDIUM
**File:** `CompanyDateFormatter.java`
**Subject:** Constructor does not validate `companyDateTimeFormatPattern`; a null or malformed pattern causes a deferred crash

The constructor at line 14 accepts a `String companyDateTimeFormatPattern` from the caller (ultimately sourced from the server via `LoginItem.date_format`, with a fallback of `"MM/dd/yyyy"` set in `User`). It passes this string to three `SimpleDateFormat` constructors. If the pattern is `null`, `SimpleDateFormat` throws `NullPointerException`. If the pattern is syntactically invalid (e.g., contains an unquoted `'`), `SimpleDateFormat` throws `IllegalArgumentException`. Neither exception is caught or documented.

No test exercises: null pattern, empty pattern, pattern with illegal characters, or pattern whose `replace(" HH:mm:ss", "")` call produces a malformed residual pattern.

---

**ID:** A70-4
**Severity:** LOW
**File:** `CompanyDateFormatter.java`
**Subject:** All format/parse methods are untested for nominal paths

The following methods have no test exercising any code path, including the happy path:
- `formatTime(Date date)` — line 24
- `formatDate(Date date)` — line 28
- `formatDateTime(Date date)` — line 32
- `parseDate(String date)` — line 36

No test verifies that a round-trip `formatDate(parseDate(s))` returns the original string, or that `formatTime` produces `"HH:mm"` output, or that `formatDateTime` uses the company pattern.

---

**ID:** A70-5
**Severity:** LOW
**File:** `CompanyDateFormatter.java`
**Subject:** No test for timezone behaviour or DST transitions

The constructor captures `TimeZone.getDefault()` at construction time (lines 15-21). No test verifies behaviour when the device default timezone changes after the formatter is constructed, or when a formatted or parsed date straddles a DST transition. In DST-transition edge cases, `SimpleDateFormat` can produce ambiguous or incorrect results with the local timezone. There is no test confirming that the formatted output is stable across DST boundaries.

---

**ID:** A70-6
**Severity:** INFO
**File:** `CompanyDateFormatter.java`
**Subject:** `SimpleDateFormat` instances are not thread-safe; no test verifies single-threaded usage assumption

`SimpleDateFormat` is not thread-safe. The three formatters are instance fields shared across all calls on a given `CompanyDateFormatter` instance. If an instance is ever shared between threads (e.g., stored in a static field or a shared ViewModel), concurrent `format()` or `parse()` calls will produce corrupted results with no exception. No test verifies that usage is confined to a single thread, and no documentation notes the constraint.

---

## File 2: ComplianceAccepter.java

### Reading Evidence

**Fully qualified class name:** `au.com.collectiveintelligence.fleetiq360.util.ComplianceAccepter`

**Fields defined:**
- `private Context context` (line 20)
- `private User user` (line 21)

**Methods (with line numbers and signatures):**
- `public ComplianceAccepter(Context context)` — line 23
- `public void askForCompliance()` — line 28

**Constants defined:** None.

**Types imported:** `android.app.AlertDialog`, `android.content.Context`, `android.content.DialogInterface`, `android.content.Intent`, `au.com.collectiveintelligence.fleetiq360.R`, `au.com.collectiveintelligence.fleetiq360.WebService.WebApi`, `au.com.collectiveintelligence.fleetiq360.WebService.WebData`, `au.com.collectiveintelligence.fleetiq360.WebService.WebListener`, `au.com.collectiveintelligence.fleetiq360.WebService.webserviceclasses.parameters.UpdateUserParameter`, `au.com.collectiveintelligence.fleetiq360.WebService.webserviceclasses.results.CommonResult`, `au.com.collectiveintelligence.fleetiq360.ui.activity.LoginActivity`, `au.com.collectiveintelligence.fleetiq360.user.CurrentUser`, `au.com.collectiveintelligence.fleetiq360.user.User`, `java.util.Calendar`

### Findings

---

**ID:** A70-7
**Severity:** MEDIUM
**File:** `ComplianceAccepter.java`
**Subject:** Compliance check can be bypassed by manipulating the local Realm record

`askForCompliance()` at line 29 gates on `user.complianceIsValid()`, which (per `User.java` line 78-80) returns `true` if and only if `complianceDate != null`. The `User` object is hydrated from the local Realm database by `CurrentUser.get()` (called in the constructor at line 25). The `complianceDate` field in `UserRealmObject` is a plain `Date` field with no server-side integrity check performed at the point of reading.

The sequence is:
1. `UserRealmObject.complianceDate` is read from local Realm.
2. If it is non-null, `complianceIsValid()` returns `true` and the compliance dialog is never shown.
3. The server is never re-queried to confirm whether the stored date is authentic.

An attacker with device access (rooted device, ADB, or a Realm database editor) could write any non-null date into the Realm `complianceDate` field for the current user. On next app launch, `complianceIsValid()` returns `true`, the compliance dialog is suppressed, and no network call is made to the server. The user bypasses GDPR compliance acceptance without the server recording an accepted date.

The `updateUser` call at line 40 is fire-and-forget: `WebApi.async().updateUser(...)` passes a default `new WebListener<CommonResult>()` whose `onSucceed` and `onFailed` are empty no-ops (per `WebListener.java` lines 11-14). Even for legitimate accepts, there is no confirmation that the server recorded the event. If the call silently fails, the server has no record of acceptance while the local Realm record is marked as accepted.

No test verifies: that a pre-seeded Realm compliance date triggers bypass; that a network failure during `updateUser` is detected and handled; that the server is the source of truth for compliance status.

---

**ID:** A70-8
**Severity:** MEDIUM
**File:** `ComplianceAccepter.java`
**Subject:** `updateUser` network failure is silently swallowed; compliance acceptance may not reach the server

The `WebListener<CommonResult>` passed to `WebApi.async().updateUser()` at line 40 is a bare `new WebListener<CommonResult>()` with no overrides. Per `WebListener.java`, `onFailed()` is an empty method. If the network call fails (network unavailable, server error, timeout), the failure is discarded. The local Realm record shows `complianceDate` set (because `user.updateCompliance(...)` at line 37 wrote it before the network call), but the server has no record. There is no retry mechanism, no queue for deferred retry, and no notification to the user that their acceptance was not confirmed.

No test verifies: the `onFailed` path for `updateUser`; that a failure produces a visible error or a retry; that the compliance date is not written to Realm until server confirmation.

---

**ID:** A70-9
**Severity:** LOW
**File:** `ComplianceAccepter.java`
**Subject:** `CurrentUser.get()` can return null; constructor does not guard against it

`CurrentUser.get()` (line 26-29 of `CurrentUser.java`) returns `UserDb.get(ModelPrefs.readInt(CURRENT_USER_ID_KEY))`, which returns `null` if no user record matches the stored ID. The `ComplianceAccepter` constructor stores this result in `this.user` without a null check. When `askForCompliance()` is called, `user.complianceIsValid()` at line 29 throws `NullPointerException`.

This can occur if `ComplianceAccepter` is instantiated before a user is logged in, or after the Realm database is cleared or corrupted.

No test verifies: construction with no current user; `askForCompliance()` called when user is null.

---

**ID:** A70-10
**Severity:** LOW
**File:** `ComplianceAccepter.java`
**Subject:** `askForCompliance()` is entirely untested — all code paths lack test coverage

The following code paths within `askForCompliance()` have no test:
- The early return path when `complianceIsValid()` is true (line 29).
- The dialog display path when compliance is not valid (lines 31-51).
- The "Accept" button path: `updateCompliance()` call, `UpdateUserParameter` construction, `updateUser` API call (lines 37-40).
- The "Refuse" button path: `WebData.instance().logout()`, `startActivity(LoginActivity)` (lines 46-47).

---

## File 3: ServerDateFormatter.java

### Reading Evidence

**Fully qualified class name:** `au.com.collectiveintelligence.fleetiq360.util.ServerDateFormatter`

**Fields defined:**
- `private SimpleDateFormat dateFormat` (line 10)
- `private SimpleDateFormat dateTimeFormat` (line 11)

**Methods (with line numbers and signatures):**
- `public ServerDateFormatter()` — line 13
- `public String formatDate(Date date)` — line 21
- `public String formatDateTime(Date date)` — line 25
- `public Date parseDate(String date)` — line 29
- `public Date parseDateTime(String date)` — line 34

**Constants defined:** None. The timezone `"GMT"` (line 14), date pattern `"yyyy-MM-dd"` (line 15), and datetime pattern `"yyyy-MM-dd HH:mm:ss"` (line 17) are inline literals.

**Types imported:** `java.text.ParsePosition`, `java.text.SimpleDateFormat`, `java.util.Date`, `java.util.Locale`, `java.util.TimeZone`

### Findings

---

**ID:** A70-11
**Severity:** MEDIUM
**File:** `ServerDateFormatter.java`
**Subject:** `parseDateTime()` has no null or empty-string guard, unlike `parseDate()`

`parseDate(String date)` at line 29-31 explicitly checks `if (date == null || date.isEmpty()) return null` before parsing. `parseDateTime(String date)` at line 34-35 has no such guard: it passes the argument directly to `dateTimeFormat.parse(date, new ParsePosition(0))`.

Callers that pass `null` to `parseDateTime()` will receive a `NullPointerException` from `SimpleDateFormat.parse()`. Callers that pass an empty string will get a silent `null` return (which may itself cause a NullPointerException downstream). The asymmetry is clearly unintentional — the guard was written for `parseDate` and omitted from `parseDateTime`.

`ServerDateFormatter` is used in security-relevant contexts: `CurrentUser.createUser()` calls `dateFormatter.parseDate(loginItem.compliance_date)` and `dateFormatter.parseDate(loginItem.expirydt)`. If the server ever sends a datetime string where a date string is expected (or vice versa), the wrong method may be called on the unparseable value. No test covers the `parseDateTime(null)` path, the `parseDateTime("")` path, or a malformed datetime string.

---

**ID:** A70-12
**Severity:** MEDIUM
**File:** `ServerDateFormatter.java`
**Subject:** No test for invalid or malformed date/datetime strings

Both `parseDate()` and `parseDateTime()` use `SimpleDateFormat.parse(String, ParsePosition)`. This overload does not throw on parse failure; it returns `null` and advances the `ParsePosition` to indicate the failure point. The returned `null` propagates silently to callers.

No test verifies:
- `parseDate("not-a-date")` returns `null` and does not crash.
- `parseDateTime("not-a-datetime")` returns `null` and does not crash.
- `parseDate("2024-13-45")` (invalid month/day) — `SimpleDateFormat` with lenient mode (the default) will roll over the calendar rather than return `null`, producing a surprising but non-null result.
- `parseDate("2024-02-29")` in a non-leap year — lenient parsing will silently produce March 1.
- A datetime string with trailing garbage (e.g., `"2024-01-01 00:00:00Z"`) — `ParsePosition` stops at the `Z`, returning a `Date` for the portion parsed, not an error.

The default lenient parsing behaviour of `SimpleDateFormat` means malformed server responses can produce wrong but non-null `Date` objects that pass null checks and propagate incorrect values into compliance and expiry date fields.

---

**ID:** A70-13
**Severity:** LOW
**File:** `ServerDateFormatter.java`
**Subject:** `formatDate()` and `formatDateTime()` accept null `Date` without guard

`formatDate(Date date)` at line 21 and `formatDateTime(Date date)` at line 25 pass their arguments directly to `SimpleDateFormat.format()`. `SimpleDateFormat.format(null)` throws `NullPointerException`. In `ComplianceAccepter.java` line 39, `new ServerDateFormatter().formatDate(user.getComplianceDate())` is called immediately after `user.updateCompliance(Calendar.getInstance().getTime())`, so in that specific call site the date cannot be null. However, there is no guard in the method itself, and other callers could pass a null date without error.

No test verifies the null-date behaviour for either format method.

---

**ID:** A70-14
**Severity:** LOW
**File:** `ServerDateFormatter.java`
**Subject:** All methods untested — no test exercises any code path

The following methods have no test exercising any code path:
- `ServerDateFormatter()` constructor — timezone and pattern setup.
- `formatDate(Date date)` — no test for nominal output, null input, or epoch boundary.
- `formatDateTime(Date date)` — no test for nominal output, null input, or epoch boundary.
- `parseDate(String date)` — no test for valid input, null input, empty input, or malformed input.
- `parseDateTime(String date)` — no test for any input.

This is especially significant because `ServerDateFormatter` is used directly in authentication flow (`CurrentUser.createUser()`) and compliance flow (`ComplianceAccepter.askForCompliance()`). Incorrect date parsing in these paths can silently set `complianceDate` or `expiryDate` to `null` or to a wrong value, bypassing validity checks or producing incorrect UI display.

---

**ID:** A70-15
**Severity:** INFO
**File:** `ServerDateFormatter.java`
**Subject:** GMT timezone is hardcoded as a string literal; "GMT" and "UTC" have identical semantics but `TimeZone.getTimeZone("GMT")` silently falls back to GMT for unknown IDs

The timezone is set via `TimeZone.getTimeZone("GMT")` at line 14. `TimeZone.getTimeZone()` silently returns GMT for any unrecognised ID, meaning a typo (e.g., `"GTM"`) would compile and run without error but use an incorrect timezone. Using `TimeZone.getTimeZone("UTC")` or the constant from `java.time.ZoneOffset.UTC` would be more explicit and self-documenting. No test verifies that the formatter actually uses GMT/UTC for serialisation.

---

**ID:** A70-16
**Severity:** INFO
**File:** `ServerDateFormatter.java`
**Subject:** `SimpleDateFormat` is not thread-safe; concurrent use of a shared instance is unsafe

As with `CompanyDateFormatter`, `SimpleDateFormat` instances are not thread-safe. No test or documentation constrains how `ServerDateFormatter` instances are shared. `ServerDateFormatter` is instantiated inline at several call sites (e.g., `ComplianceAccepter` line 39, `CurrentUser.java` line 59, `User.java` lines 93 and 101), so sharing is not currently a problem at those sites. However, the absence of any note or test leaves the constraint undocumented and untested.

---

## Summary Table

| ID    | Severity | File                      | Subject                                                                 |
|-------|----------|---------------------------|-------------------------------------------------------------------------|
| A70-1 | HIGH     | Project-wide              | Zero automated test coverage in `app/` and `LibCommon/` modules         |
| A70-2 | MEDIUM   | CompanyDateFormatter.java | `parseDate()` has no null or empty-string guard                         |
| A70-3 | MEDIUM   | CompanyDateFormatter.java | Constructor does not validate pattern; null/illegal pattern causes crash |
| A70-4 | LOW      | CompanyDateFormatter.java | All format/parse methods untested for nominal paths                     |
| A70-5 | LOW      | CompanyDateFormatter.java | No test for timezone behaviour or DST transitions                       |
| A70-6 | INFO     | CompanyDateFormatter.java | `SimpleDateFormat` not thread-safe; constraint undocumented and untested |
| A70-7 | MEDIUM   | ComplianceAccepter.java   | Compliance check bypassable by manipulating local Realm record          |
| A70-8 | MEDIUM   | ComplianceAccepter.java   | `updateUser` network failure silently swallowed; acceptance may not reach server |
| A70-9 | LOW      | ComplianceAccepter.java   | `CurrentUser.get()` can return null; constructor has no guard           |
| A70-10| LOW      | ComplianceAccepter.java   | `askForCompliance()` entirely untested — all branches lack coverage     |
| A70-11| MEDIUM   | ServerDateFormatter.java  | `parseDateTime()` has no null/empty guard unlike `parseDate()`          |
| A70-12| MEDIUM   | ServerDateFormatter.java  | No test for invalid/malformed date or datetime strings                  |
| A70-13| LOW      | ServerDateFormatter.java  | `formatDate()` and `formatDateTime()` accept null Date without guard    |
| A70-14| LOW      | ServerDateFormatter.java  | All methods untested — no test exercises any code path                  |
| A70-15| INFO     | ServerDateFormatter.java  | GMT timezone as string literal; silent fallback masks typos             |
| A70-16| INFO     | ServerDateFormatter.java  | `SimpleDateFormat` not thread-safe; constraint undocumented and untested |
