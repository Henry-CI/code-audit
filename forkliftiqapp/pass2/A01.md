# Pass 2 Audit – Test Coverage
**Agent:** A01
**Audit Run:** 2026-02-26-01
**Files Assigned:**
1. `LibCommon/src/main/java/com/yy/libcommon/BaseActivity.java`
2. `LibCommon/src/main/java/com/yy/libcommon/BaseController.java`
3. `LibCommon/src/main/java/com/yy/libcommon/BaseDialog.java`

---

## PROJECT-WIDE FINDING

### A01-0 [HIGH] – Zero Automated Test Coverage Across Entire Project

No `src/test/` or `src/androidTest/` directories exist in any module (`app/`, `LibCommon/`, or any other module). There are zero JUnit, Espresso, Robolectric, or any other automated test files anywhere in the repository. Every source file in the project is completely untested. All subsequent findings in this report are therefore universal: no test exercises any code path in any assigned file.

**Scope:** Project-wide (all modules)
**Impact:** Regressions, behavioral defects, and security issues in any part of the codebase can ship undetected. There is no safety net for refactoring or bug fixes.

---

## Reading Evidence

### File 1: `BaseActivity.java`

**Fully qualified class name:** `com.yy.libcommon.BaseActivity`
**Extends:** `android.support.v7.app.AppCompatActivity`
**Implements:** `com.yy.libcommon.BaseController`, `FragmentInterface.FragmentHandle`

**Fields:**
- `private static final String TAG = "BaseActivity"` (line 30)
- `private Fragment mFragment` (line 31)
- `private FragmentManager manager` (line 32)
- `protected boolean isStarted = false` (line 33)
- `protected boolean isResumed = false` (line 34)
- `protected CustomProgressDialog mCustomProgressDialog` (line 37)
- `protected SubFragPermission subFragPermission` (line 38)

**Methods (with line numbers and signatures):**
| Line | Signature |
|------|-----------|
| 40 | `public int getScreenWidth()` |
| 48 | `public void backToHome()` |
| 56 | `@Override public void onBackPressed()` |
| 75 | `@Override public void addFragment(@IdRes int containerViewId, Fragment fragment, String tag)` |
| 83 | `public void addFragment(@IdRes int containerViewId, Fragment fragment, String tag, boolean addStack)` |
| 95 | `@Override public void hideFragment(String tag)` |
| 101 | `public void removeFragment(String tag)` |
| 107 | `public Fragment findFramentByTag(String tag)` |
| 113 | `@Override public Fragment showFragment(@IdRes int containerViewId, String tag, String className)` |
| 134 | `public Fragment showFragmentWithoutStack(@IdRes int containerViewId, String tag, Fragment fragment)` |
| 149 | `public Fragment showFragmentWithStack(@IdRes int containerViewId, String tag, Fragment fragment)` |
| 164 | `public void addFragmentWithAnimation(@AnimRes int enter, @AnimRes int exit, @AnimRes int popEnter, @AnimRes int popExit, @IdRes int containerViewId, Fragment fragment, String tag, boolean addStack)` |
| 180 | `@Override public void onRequestPermissionsResult(int requestCode, String permissions[], int[] grantResults)` |
| 186 | `public void showDialog(String title, String msg)` |
| 196 | `protected void initKeyboard()` |
| 202 | `void showKeyboard(final View view)` |
| 213 | `@Override public boolean onCreateOptionsMenu(Menu menu)` |
| 218 | `@Override public boolean onOptionsItemSelected(MenuItem item)` |
| 229 | `@Override protected void onSaveInstanceState(Bundle outState)` |
| 233 | `void onRecover(Bundle savedInstanceState)` |
| 238 | `@Override protected void onCreate(Bundle savedInstanceState)` |
| 254 | `public void hideKeyboard(View view)` |
| 260 | `@Override protected void onStart()` |
| 267 | `@Override protected void onResume()` |
| 275 | `@Override protected void onPause()` |
| 281 | `@Override protected void onStop()` |
| 287 | `@Override protected void onDestroy()` |
| 292 | `public void runLater(final Runnable runnable, long delayMillis)` |
| 306 | `public void setBestOrientation()` |
| 323 | `public SubFragPermission getSubFragPermission()` |
| 328 | `@Override public FragmentManager getCurrentFragmentManager()` |
| 332 | `public void showToast(String msg)` |
| 338 | `public void showDialog(String title, String msg, ErrorDialog.OnErrorCallback callback)` |
| 351 | `protected void showProgressDialog()` |
| 359 | `public void showProgress(String title, String message)` |
| 367 | `public void showSavingProgress()` |
| 375 | `public void showDeletingProgress()` |
| 384 | `public void showLoadingProgress()` |
| 393 | `public void updateProgress(String message)` |
| 399 | `public void hideProgress()` |

**Constants/Types defined:** None beyond the TAG string constant.

---

### File 2: `BaseController.java`

**Fully qualified class name:** `com.yy.libcommon.BaseController`
**Type:** `interface`

**Methods (with line numbers and signatures):**
| Line | Signature |
|------|-----------|
| 11 | `FragmentManager getCurrentFragmentManager()` |
| 12 | `boolean isDestroyed()` |
| 14 | `SubFragPermission getSubFragPermission()` |

**Commented-out (dead) method declarations (lines 16–22):**
- `void showProgress(String title, String message)`
- `void updateProgress(String message)`
- `void hideProgress()`
- `void showToast(String msg)`
- `boolean checkCameraPermissionWithRun(Runnable runnable)`
- `boolean checkFilePermissionWithRun(Runnable runnable)`
- `void requestCameraPermission()`
- `void requestFilePermission()`

**Constants/Types defined:** None.

---

### File 3: `BaseDialog.java`

**Fully qualified class name:** `com.yy.libcommon.BaseDialog`
**Extends:** `android.support.v4.app.DialogFragment`
**Implements:** `com.yy.libcommon.BaseController`

**Fields:**
- `protected ViewGroup mRootView` (line 26)
- `public IDialogGenericCallback mGenericCallback` (line 27)
- `public boolean isDestroyed = false` (line 28)
- `protected SubFragPermission subFragPermission` (line 30)

**Methods (with line numbers and signatures):**
| Line | Signature |
|------|-----------|
| 32 | `public int getScreenWidth()` |
| 39 | `public void showProgress(String title, String message)` |
| 45 | `public void showSavingProgress()` |
| 51 | `public void showDeletingProgress()` |
| 57 | `public void showLoadingProgress()` |
| 63 | `public void updateProgress(String message)` |
| 68 | `public void hideProgress()` |
| 74 | `public BaseActivity getBaseActivity()` |
| 80 | `@Override public void onDismiss(DialogInterface dialog)` |
| 88 | `public void showToast(String msg)` |
| 97 | `@Override public void onSaveInstanceState(Bundle outState)` |
| 102 | `@Override public void onActivityCreated(Bundle savedInstanceState)` |
| 112 | `@Override public void onDestroy()` |
| 121 | `@Override public void onDetach()` |
| 125 | `protected void setupViews()` |
| 130 | `@Override public void onPause()` |
| 135 | `@Override public void onResume()` |
| 141 | `@Override public void onStart()` |
| 146 | `@Override public void onStop()` |
| 153 | `public SubFragPermission getSubFragPermission()` |
| 159 | `@Override public boolean isDestroyed()` |
| 164 | `@Override public FragmentManager getCurrentFragmentManager()` |
| 168 | `public void hideKeyboard(View view)` |
| 174 | `public static void addFragment(FragmentManager fragmentManager, Fragment fragment, int container)` |
| 178 | `public static void addFragment(FragmentManager fragmentManager, Fragment fragment, int container, boolean backStack)` |
| 189 | `public static void removeFragment(FragmentManager fragmentManager, int container)` |
| 196 | `public void addFragment(Fragment fragment, int container)` |
| 201 | `public void addFragment(Fragment fragment, int container, boolean backStack)` |
| 211 | `public void removeSelfFromParent()` |

**Constants/Types defined:** None.

---

## Findings

### A01-1 [HIGH] – `BaseActivity.onRequestPermissionsResult` – Null dereference on `subFragPermission` with no test coverage

**File:** `BaseActivity.java`, line 180–183
**Method:** `onRequestPermissionsResult(int requestCode, String permissions[], int[] grantResults)`

`subFragPermission` is assigned in `onCreate` (line 245). However, there is no guard against `subFragPermission` being `null` before calling `subFragPermission.onRequestPermissionsResult(...)` at line 182. If the OS delivers a permission result before `onCreate` completes (e.g., during process resurrection or edge-case lifecycle ordering), or if a subclass fails to call `super.onCreate()`, a `NullPointerException` will crash the app at runtime. No test covers this path.

**Untested paths:**
- Normal permission result dispatch
- Permission result arriving when `subFragPermission` is null

---

### A01-2 [HIGH] – `BaseActivity.hideFragment` – Null dereference when fragment tag not found

**File:** `BaseActivity.java`, lines 95–100
**Method:** `hideFragment(String tag)`

`manager.findFragmentByTag(tag)` returns `null` if no fragment with the given tag is attached. The result is passed directly to `transaction.hide(pFragment)` at line 99 without a null check. Passing `null` to `FragmentTransaction.hide()` throws a `NullPointerException`. No test covers:
- The happy path (fragment found and hidden)
- The tag-not-found path (fragment is null)
- A null or empty `tag` argument

---

### A01-3 [HIGH] – `BaseActivity.removeFragment` – Null dereference when fragment tag not found

**File:** `BaseActivity.java`, lines 101–106
**Method:** `removeFragment(String tag)`

Same defect pattern as A01-2. `manager.findFragmentByTag(tag)` may return `null`, which is then passed to `transaction.remove(pFragment)` at line 105 without a null guard, resulting in a `NullPointerException`. No test covers:
- Normal removal
- Tag not found
- Null tag

---

### A01-4 [HIGH] – `BaseActivity.showFragment` – Exception catch blocks silently swallow errors; reflection-based instantiation untested

**File:** `BaseActivity.java`, lines 113–133
**Method:** `showFragment(@IdRes int containerViewId, String tag, String className)`

This method uses `Class.forName(className).newInstance()` (line 120) to dynamically instantiate a fragment by class name string. Three exception types are caught (`InstantiationException`, `IllegalAccessException`, `ClassNotFoundException`) and silently swallowed via `e.printStackTrace()` only (lines 122–128). After a failed instantiation, the method returns `null`, and callers receive no indication of failure. There is no test for:
- A valid class name that resolves correctly
- An invalid/misspelled class name (`ClassNotFoundException`)
- A class without a public no-arg constructor (`InstantiationException`)
- A class with a non-accessible constructor (`IllegalAccessException`)
- The branch where `pFragment != null` (show existing fragment path)

---

### A01-5 [MEDIUM] – `BaseActivity.runLater` – Exception silently swallowed in delayed Runnable

**File:** `BaseActivity.java`, lines 292–304
**Method:** `runLater(final Runnable runnable, long delayMillis)`

The `try/catch (Exception e)` block at lines 297–300 catches all exceptions thrown by `runnable.run()` and discards them without logging, rethrowing, or any other handling. This makes it impossible to diagnose failures in delayed operations at runtime. No test covers:
- Normal execution of the runnable
- Execution of a runnable that throws a checked or unchecked exception
- Zero or negative `delayMillis` boundary values

---

### A01-6 [MEDIUM] – `BaseActivity.hideKeyboard` – Null dereference when `InputMethodManager` is unavailable

**File:** `BaseActivity.java`, lines 254–257
**Method:** `hideKeyboard(View view)`

`getSystemService(Context.INPUT_METHOD_SERVICE)` can return `null` on unusual device configurations. The result is cast and immediately dereferenced at line 256 (`imm.hideSoftInputFromWindow(...)`) without a null check, causing a `NullPointerException`. Compare with `showKeyboard` (line 206), which does perform a null check (`if (imm != null)`). No test covers:
- Normal keyboard hiding
- `getSystemService` returning null
- A null `view` argument

---

### A01-7 [MEDIUM] – `BaseActivity.onBackPressed` – Commented-out confirmation dialog; back navigation behavior untested

**File:** `BaseActivity.java`, lines 56–72
**Method:** `onBackPressed()`

The original intent was to show a confirmation dialog before exiting (lines 57–66, now commented out). The current implementation unconditionally launches the home screen via an intent, bypassing normal back-stack behavior. This override means the user can never use the back button to navigate within the app from any BaseActivity subclass. No test verifies:
- That the home intent is constructed with the correct flags
- That the override prevents back-stack unwinding
- Any subclass-specific back-navigation behavior

---

### A01-8 [MEDIUM] – `BaseActivity.showProgressDialog` – Silent return when `mCustomProgressDialog` is null

**File:** `BaseActivity.java`, lines 351–357
**Method:** `showProgressDialog()`

The method returns silently (line 353–354) when `mCustomProgressDialog` is `null`. However, this method is always called after assigning `mCustomProgressDialog` in the `showProgress*` family of methods (lines 363, 371, 379, 388). If that invariant is ever violated, progress dialogs will silently fail to display, giving no feedback to the user during long operations. No test verifies:
- Normal display of the progress dialog
- The null guard branch
- That `mCustomProgressDialog` is always non-null when `showProgressDialog` is called from each caller

---

### A01-9 [MEDIUM] – `BaseActivity.updateProgress` – Null guard present but no test for either branch

**File:** `BaseActivity.java`, lines 393–397
**Method:** `updateProgress(String message)`

The method correctly checks `mCustomProgressDialog != null` before calling `updateProgress`. However, no test validates:
- The path where `mCustomProgressDialog` is not null and `updateProgress` is called successfully
- The path where `mCustomProgressDialog` is null and the call is silently skipped
- A null or empty `message` argument

---

### A01-10 [HIGH] – `BaseActivity` – All fragment management methods untested

**File:** `BaseActivity.java`
**Methods:** `addFragment` (×2, lines 75 and 83), `showFragmentWithoutStack` (line 134), `showFragmentWithStack` (line 149), `addFragmentWithAnimation` (line 164), `findFramentByTag` (line 107)

All fragment management methods that form the core navigation primitive of the application have zero test coverage. Missing test scenarios include:
- Adding a fragment to a valid container
- Replacing an existing fragment
- Back-stack behavior (`addStack = true` vs `false`)
- Animations being applied in `addFragmentWithAnimation`
- Finding a fragment by tag when it exists vs. when it does not

---

### A01-11 [HIGH] – `BaseController` – Interface contract allows commented-out methods to be silently dropped

**File:** `BaseController.java`, lines 16–22

Eight method declarations are commented out in the `BaseController` interface. These include `showProgress`, `updateProgress`, `hideProgress`, `showToast`, `checkCameraPermissionWithRun`, `checkFilePermissionWithRun`, `requestCameraPermission`, and `requestFilePermission`. If these were removed from the interface rather than properly deprecated, implementing classes (`BaseActivity`, `BaseDialog`) can diverge in behavior without the compiler enforcing contract consistency. No test verifies that implementations of `BaseController` consistently expose the expected surface area. The remaining three active interface methods have no contract tests whatsoever.

---

### A01-12 [HIGH] – `BaseDialog.getBaseActivity` – Unchecked cast; null not handled

**File:** `BaseDialog.java`, lines 74–76
**Method:** `getBaseActivity()`

`getActivity()` returns `null` if the fragment is not currently attached to an activity (e.g., after detachment or before attachment). The unchecked cast to `BaseActivity` would produce a `ClassCastException` if the hosting activity is not a `BaseActivity` subclass, and returning `null` to callers that do not check (e.g., a caller that chains directly) causes `NullPointerException`. All six `showProgress*`/`hideProgress`/`updateProgress` callers do check for `null`, but the cast itself is never tested. No test covers:
- Fragment not attached (getActivity returns null)
- Fragment hosted by a non-BaseActivity host

---

### A01-13 [HIGH] – `BaseDialog` – `isDestroyed` field shadows `Activity.isDestroyed()` method; boolean state management untested

**File:** `BaseDialog.java`, line 28
**Field:** `public boolean isDestroyed = false`

The field name `isDestroyed` shadows the inherited `Fragment.isDetached()` / `Activity.isDestroyed()` platform semantics. The field is set to `true` in `onDestroy` (line 117) and read in six guard conditions (lines 40, 46, 52, 58, 64, 69). However:
- The field is `public`, allowing external code to reset or corrupt it
- The field is not `volatile`, introducing a potential race condition if accessed from background threads (which `showProgress` callers often are)
- No test verifies that the field becomes `true` after `onDestroy`, or that the guard conditions correctly block calls after destruction

---

### A01-14 [MEDIUM] – `BaseDialog.onStop` – `subFragPermission.onDestroy()` called on stop, not just destroy; lifecycle symmetry untested

**File:** `BaseDialog.java`, lines 146–149
**Method:** `onStop()`

`subFragPermission.onDestroy()` is called inside `onStop()` (line 148). This is asymmetric with `onResume()`, which calls `subFragPermission.onActive()` (line 137). Calling the destroy lifecycle hook on every stop (rather than only in `onDestroy`) may prematurely tear down permission state, causing failures if the dialog is stopped and resumed (e.g., when another activity temporarily comes to the foreground). No test verifies:
- The stop/resume cycle leaving `subFragPermission` in a usable state
- Whether `onDestroy()` is idempotent when called multiple times via repeated stop/resume cycles

---

### A01-15 [MEDIUM] – `BaseDialog.hideKeyboard` – Null dereference risk; no test coverage

**File:** `BaseDialog.java`, lines 168–171
**Method:** `hideKeyboard(View view)`

`getContext().getSystemService(Context.INPUT_METHOD_SERVICE)` can return `null`. The result is immediately cast and dereferenced without a null check, causing a `NullPointerException`. Additionally, `getContext()` itself returns `null` when the fragment is not attached to a context. No test covers:
- Normal keyboard hiding
- `getContext()` returning null (detached fragment)
- `getSystemService()` returning null

---

### A01-16 [MEDIUM] – `BaseDialog.removeSelfFromParent` – Stale child fragment manager accessed after remove; no test

**File:** `BaseDialog.java`, lines 211–220
**Method:** `removeSelfFromParent()`

At line 218, `getChildFragmentManager().executePendingTransactions()` is called after `ft.remove(this)` has been committed (line 216). Calling `getChildFragmentManager()` on a fragment that has just been removed from its parent can result in `IllegalStateException` ("Fragment has been destroyed"). Additionally, the `getParentFragment() == null` check at line 213 means the method silently does nothing when the dialog has no parent fragment (e.g., if it was added directly to an activity). No test covers:
- Dialog with a parent fragment (removal succeeds)
- Dialog without a parent fragment (silent no-op)
- The `executePendingTransactions` call after self-removal

---

### A01-17 [MEDIUM] – `BaseDialog.onDismiss` – Callback invoked without null guard in `mGenericCallback`; field is public

**File:** `BaseDialog.java`, lines 80–86
**Method:** `onDismiss(DialogInterface dialog)`

`mGenericCallback` is a `public` field (line 27), meaning any external class can set it to `null` concurrently. The guard at line 83 checks `mGenericCallback != null` before calling `callBack()`, which is correct, but because the field is public and non-volatile, there is a TOCTOU (time-of-check/time-of-use) race condition if set to `null` between the check and the call from a different thread. No test covers:
- Dismiss with a non-null callback (callback is invoked)
- Dismiss with a null callback (no crash)
- Concurrent modification of `mGenericCallback` during dismiss

---

### A01-18 [LOW] – `BaseDialog.static removeFragment` – Null dereference when no fragment found at container ID

**File:** `BaseDialog.java`, lines 189–194
**Method:** `public static void removeFragment(FragmentManager fragmentManager, int container)`

`fragmentManager.findFragmentById(container)` returns `null` if no fragment is attached at the given container ID. The result is passed directly to `ft.remove(...)` (line 192) without a null guard, causing `NullPointerException`. No test covers:
- Removal when a fragment exists at the container
- Removal when no fragment is at the container

---

### A01-19 [LOW] – `BaseActivity.showToast` and `BaseDialog.showToast` – Null/empty message not validated; no test

**Files:** `BaseActivity.java` line 332; `BaseDialog.java` line 88
**Methods:** `showToast(String msg)` in both classes

Neither implementation validates whether `msg` is `null` or empty before passing it to `Toast.makeText()`. A null message will display an empty toast or potentially cause `NullPointerException` depending on the Android version. No test covers:
- A normal non-empty message
- A null message
- An empty string message

---

### A01-20 [LOW] – `BaseActivity` – Lifecycle state flags (`isStarted`, `isResumed`) are never tested for correctness

**File:** `BaseActivity.java`, lines 33–34, 262, 269–271, 277, 283
**Fields:** `protected boolean isStarted`, `protected boolean isResumed`

These flags are toggled across multiple lifecycle callbacks but have no test verifying that:
- `isStarted` is `true` after `onStart()` / `onResume()` and `false` after `onStop()`
- `isResumed` is `true` after `onResume()` and `false` after `onPause()`
- Initial values at construction are correct (`false`, `false`)
- The flags are correct after configuration changes (rotation)

---

### A01-21 [INFO] – `BaseActivity` – `findFramentByTag` contains a typo in the method name

**File:** `BaseActivity.java`, line 107
**Method:** `findFramentByTag(String tag)` (missing 'g' in "Fragment")

The method name is misspelled (`findFramentByTag` instead of `findFragmentByTag`). This is a maintainability issue and creates API surface with an awkward name that cannot be corrected without a breaking change to all callers. No test exists to even document the intended behavior of this method.

---

### A01-22 [INFO] – `BaseController` – Commented-out interface methods represent dead contract surface with no rationale documented

**File:** `BaseController.java`, lines 16–22

Eight method declarations are commented out with no explanation of why they were removed from the interface. This creates ambiguity about whether these are planned for future use, deprecated, or simply removed. No decision record, no test, and no deprecation annotation explains the intent.

---

## Summary Table

| ID | Severity | File | Method / Area | Description |
|----|----------|------|---------------|-------------|
| A01-0 | HIGH | Project-wide | All files | Zero automated test coverage in entire project |
| A01-1 | HIGH | BaseActivity.java | `onRequestPermissionsResult` | Null dereference on `subFragPermission` |
| A01-2 | HIGH | BaseActivity.java | `hideFragment` | Null dereference when tag not found |
| A01-3 | HIGH | BaseActivity.java | `removeFragment` | Null dereference when tag not found |
| A01-4 | HIGH | BaseActivity.java | `showFragment` | Silent swallow of reflection/instantiation errors |
| A01-5 | MEDIUM | BaseActivity.java | `runLater` | Silent swallow of all exceptions in delayed Runnable |
| A01-6 | MEDIUM | BaseActivity.java | `hideKeyboard` | Null dereference on IMM without null check |
| A01-7 | MEDIUM | BaseActivity.java | `onBackPressed` | Unconditional home navigation; commented-out dialog |
| A01-8 | MEDIUM | BaseActivity.java | `showProgressDialog` | Silent no-op when `mCustomProgressDialog` is null |
| A01-9 | MEDIUM | BaseActivity.java | `updateProgress` | Null guard untested for both branches |
| A01-10 | HIGH | BaseActivity.java | Fragment management methods | All navigation primitives have zero test coverage |
| A01-11 | HIGH | BaseController.java | Interface | Commented-out contract; no interface contract tests |
| A01-12 | HIGH | BaseDialog.java | `getBaseActivity` | Unchecked cast; null from `getActivity()` not tested |
| A01-13 | HIGH | BaseDialog.java | `isDestroyed` field | Public field, no volatile, shadows platform semantics |
| A01-14 | MEDIUM | BaseDialog.java | `onStop` | `subFragPermission.onDestroy()` called asymmetrically |
| A01-15 | MEDIUM | BaseDialog.java | `hideKeyboard` | Null dereference on context/IMM |
| A01-16 | MEDIUM | BaseDialog.java | `removeSelfFromParent` | Stale child FM after self-remove; silent no-op path |
| A01-17 | MEDIUM | BaseDialog.java | `onDismiss` | Public mutable callback field; TOCTOU race |
| A01-18 | LOW | BaseDialog.java | `static removeFragment` | Null dereference when no fragment at container ID |
| A01-19 | LOW | BaseActivity.java / BaseDialog.java | `showToast` | Null/empty message not validated |
| A01-20 | LOW | BaseActivity.java | `isStarted` / `isResumed` | Lifecycle state flags never tested |
| A01-21 | INFO | BaseActivity.java | `findFramentByTag` | Typo in method name |
| A01-22 | INFO | BaseController.java | Interface | Commented-out methods undocumented |
