# Pass 2 Audit – Agent A43
**Audit run:** 2026-02-26-01
**Agent:** A43
**Assigned files:**
1. `app/src/main/java/au/com/collectiveintelligence/fleetiq360/autoupdate/activity/ShowPackageAvailable.java`
2. `app/src/main/java/au/com/collectiveintelligence/fleetiq360/autoupdate/model/APKPackage.java`
3. `app/src/main/java/au/com/collectiveintelligence/fleetiq360/autoupdate/service/APKUpdateService.java`

---

## PROJECT-WIDE FINDING (applies to all files)

### A43-1 — CRITICAL: Zero automated test coverage across the entire project

**Severity:** HIGH (project-wide; elevated to top of report per audit instructions)

Neither the `app/` module nor the `LibCommon/` module contains any test directory. Confirmed:

- `app/src/test/` — does not exist
- `app/src/androidTest/` — does not exist
- `LibCommon/src/test/` — does not exist

Every finding below therefore represents not only a logical gap but a complete absence of any test harness. No unit tests, no integration tests, and no instrumented Android tests exist for any class in the codebase. Every method in all three assigned files is untested.

---

## File 1: ShowPackageAvailable.java

### Reading Evidence

**Fully qualified class name:**
`au.com.collectiveintelligence.fleetiq360.autoupdate.activity.ShowPackageAvailable`

**Superclass:** `android.app.Activity`

**Fields/Constants:**
| Name | Type | Line | Value |
|---|---|---|---|
| `TAG` | `static final String` | 40 | `ShowPackageAvailable.class.getCanonicalName()` |
| `PACKAGE_EXTRA` | `static final String` | 42 | `"apkPackage"` |
| `ANDROID_APK_MIME_TYPE` | `static final String` | 43 | `"application/vnd.android.package-archive"` |
| `service` | `APKUpdateService` | 45 | injected via factory in constructor |

**Methods:**
| Line | Signature |
|---|---|
| 47 | `public ShowPackageAvailable()` |
| 52 | `protected void onCreate(Bundle savedInstanceState)` |
| 59 | `protected void onStart()` |
| 88 | `private void alertNewPackageAvailable(final APKPackage apkPackage)` |
| 103 | `private boolean haveStoragePermission()` |
| 120 | `private void downloadAndInstall(final APKPackage apkPackage)` |
| 143 | `private void writeResponseBodyToDisk(final ResponseBody body, final File apkPackageFile) throws IOException` |
| 152 | `public boolean onKeyDown(int keyCode, KeyEvent event)` |
| 158 | `private void raiseNotificationPackageReadyToInstall(final File apkPackageFile)` |
| 174 | `public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults)` |

---

### A43-2 — CRITICAL: APK downloaded from server-controlled URL with no integrity check, no domain validation, and TLS verification disabled — no test verifies any of this

**File:** `ShowPackageAvailable.java` lines 120–141, `APKUpdateService.java` line 15, `OkHttpClientFactory.java` lines 16–24

**Severity:** CRITICAL

`downloadAndInstall()` calls `service.downloadPackage(apkPackage.getUrl())` where `apkPackage.getUrl()` is an arbitrary `String` returned by the server in the JSON body of `getLatestAvailableUpdate()`. The URL is accepted without:

1. **Domain allowlist check** — any URL the server returns is used verbatim. A compromised or MitM'd server can redirect the download to an attacker-controlled host.
2. **Scheme enforcement** — no check that the URL is `https://`; a plain `http://` URL would be accepted and downloaded without TLS.
3. **APK hash / signature verification** — after `writeResponseBodyToDisk()` completes, the file is immediately passed to `raiseNotificationPackageReadyToInstall()` without computing or comparing any checksum (SHA-256, MD5) against a server-supplied or pinned expected digest.
4. **TLS certificate validation is globally disabled** — `OkHttpClientFactory.getOkHttpClient()` installs `FakeX509TrustManager` (whose `checkServerTrusted()` is empty) and a `HostnameVerifier` that unconditionally returns `true` for every hostname. This means any attacker on the network can present a self-signed certificate and the client will accept it, rendering HTTPS transport useless.

No test exists to verify that:
- A URL on an untrusted domain is rejected.
- An `http://` URL is rejected.
- The downloaded APK's hash is verified before the install notification is raised.
- A hash mismatch causes the download to be aborted and the file deleted.

The combined effect of server-controlled URL, no integrity check, and disabled TLS certificate validation means a network attacker can deliver an arbitrary APK to the device and trigger an install prompt without any defense at any layer.

---

### A43-3 — CRITICAL: `downloadPackage()` uses Retrofit `@GET` with `@Url` — no test verifies SSRF / open-redirect prevention

**File:** `ShowPackageAvailable.java` line 122; `APKUpdateService.java` line 15

**Severity:** CRITICAL

The Retrofit endpoint `downloadPackage(@Url String packageUrl)` passes the server-supplied URL as the full request URL, bypassing the configured `baseUrl` entirely (this is how Retrofit's `@Url` annotation works). There is no code path that checks the URL against the configured `BuildConfig.BASE_URL` or any other trusted origin before issuing the HTTP request. No test:
- Provides a URL pointing to an internal network address (`192.168.x.x`, `10.x.x.x`, `file://`, `localhost`) and verifies it is rejected.
- Verifies that the requested URL host matches the application's configured server host.

---

### A43-4 — HIGH: `writeResponseBodyToDisk()` IOException is silently swallowed after partial write — no test for partial-download or disk-full scenario

**File:** `ShowPackageAvailable.java` lines 126–134

**Severity:** HIGH

In `downloadAndInstall()`, if `writeResponseBodyToDisk()` throws an `IOException` (e.g., disk full, storage unmounted mid-write, corrupted stream), the exception is caught at line 130, logged, and execution returns to the caller without:
- Deleting the partially-written APK file from external storage.
- Notifying the user that the download failed.
- Preventing a subsequent call from picking up the corrupt partial file.

The partial file remains on disk at the path derived from `apkPackage.getFileName()`. If the user later triggers a manual install of a file in the Downloads folder, the partial APK file is present. No test exercises this path.

---

### A43-5 — HIGH: `onResponse()` does not check HTTP status code before writing body — no test for non-200 response

**File:** `ShowPackageAvailable.java` lines 124–133

**Severity:** HIGH

`downloadAndInstall()` calls `writeResponseBodyToDisk(response.body(), apkPackageFile)` without first checking `response.isSuccessful()` or `response.code()`. If the server returns a 4xx or 5xx response, `response.body()` may be non-null (an error body) and its byte stream will be written to disk as though it were a valid APK. The corrupted file is then passed to `raiseNotificationPackageReadyToInstall()`, presenting an install prompt for a non-APK payload. No test exercises a non-200 download response.

---

### A43-6 — HIGH: `onResponse()` for `getLatestAvailableUpdate()` does not check HTTP status code — no test for non-200 response

**File:** `ShowPackageAvailable.java` lines 69–77

**Severity:** HIGH

In `onStart()`, the `Callback<APKPackage>.onResponse()` callback checks only whether `response.body()` is null, not whether `response.isSuccessful()`. On a 4xx or 5xx server response, Retrofit with a JSON converter typically produces a null body (deserialization fails), so the code proceeds to `LoginActivity`. However, this is converter-dependent; some error bodies could deserialize to a partial `APKPackage` object with a null or attacker-controlled `url` field, causing `alertNewPackageAvailable()` to be called with a malformed package. No test exercises a non-200 update-check response.

---

### A43-7 — HIGH: `onRequestPermissionsResult()` passes unvalidated `Serializable` extra as `APKPackage` — no test for null or malformed extra

**File:** `ShowPackageAvailable.java` lines 174–181

**Severity:** HIGH

`onRequestPermissionsResult()` calls `downloadAndInstall((APKPackage) getIntent().getSerializableExtra(PACKAGE_EXTRA))` without a null check on the result. If the `Intent` was not populated with `PACKAGE_EXTRA` (e.g., the activity was recreated after process death and the original intent had no extra), `downloadAndInstall(null)` is called. Inside `downloadAndInstall()`, `apkPackage.getUrl()` will throw a `NullPointerException` at line 122. No test covers:
- `PACKAGE_EXTRA` missing from the intent.
- `PACKAGE_EXTRA` present but holding a different `Serializable` type (ClassCastException).
- Permission granted after process recreation where the original `APKPackage` is no longer available.

---

### A43-8 — HIGH: `onRequestPermissionsResult()` permission-grant logic has an off-by-one boundary condition — no test

**File:** `ShowPackageAvailable.java` lines 176–179

**Severity:** HIGH

The guard condition is `grantResults.length <= 2`. This is intended to ensure both `WRITE_EXTERNAL_STORAGE` (index 0) and `READ_EXTERNAL_STORAGE` (index 1) are present. The correct boundary for checking two elements is `length < 2` (i.e., `length <= 1`). Using `<= 2` means a `grantResults` array of length exactly 2 causes the method to return without calling `downloadAndInstall()`, even when both permissions were granted. The download will silently never occur in this valid scenario. No test:
- Exercises `grantResults` with exactly 2 elements, both granted.
- Exercises `grantResults` with 1 element.
- Exercises `grantResults` with 0 elements.

---

### A43-9 — MEDIUM: `haveStoragePermission()` calls `requestPermissions()` but does not store the `APKPackage` in the intent — no test

**File:** `ShowPackageAvailable.java` lines 88–101, 103–118

**Severity:** MEDIUM

When `alertNewPackageAvailable()` detects missing storage permission, it calls `haveStoragePermission()` which invokes `ActivityCompat.requestPermissions()`. The `APKPackage` object is not stored anywhere (not put into the intent extra as `PACKAGE_EXTRA`, not stored as an instance field) before the permission dialog is displayed. When `onRequestPermissionsResult()` fires, it attempts to retrieve the package via `getIntent().getSerializableExtra(PACKAGE_EXTRA)`, which will be null because it was never stored. This is a functional defect compounding A43-7. No test traces the flow from `alertNewPackageAvailable()` through permission request and into `onRequestPermissionsResult()`.

---

### A43-10 — MEDIUM: `writeResponseBodyToDisk()` writes to world-readable external public Downloads directory — no test for path traversal via `getFileName()`

**File:** `ShowPackageAvailable.java` lines 125, 143–150

**Severity:** MEDIUM

The output file path is constructed as:
```
Environment.getExternalStoragePublicDirectory(DIRECTORY_DOWNLOADS) + "/" + apkPackage.getFileName()
```

`apkPackage.getFileName()` is a server-controlled string. If the server returns a `fileName` containing `../` sequences (e.g., `../../somefile.apk`), the resulting `File` object would resolve outside the Downloads directory, potentially overwriting files elsewhere on external storage. No path canonicalization or validation is performed. No test verifies that a `fileName` containing traversal characters is rejected.

---

### A43-11 — MEDIUM: `raiseNotificationPackageReadyToInstall()` uses deprecated `Notification.Builder` constructor and `Uri.fromFile()` without FileProvider — no test

**File:** `ShowPackageAvailable.java` lines 158–171

**Severity:** MEDIUM

- `Uri.fromFile(apkPackageFile)` is deprecated on Android 7.0+ (API 24+). On API 24+ this will throw a `FileUriExposedException` at the point where the `PendingIntent` is dispatched (when the user taps the notification), causing a crash. The correct approach is to use `FileProvider`. No test exercises the notification tap flow.
- `Notification.Builder(Context)` without a channel ID is deprecated on API 26+ and silently produces a notification that will not appear on Android 8.0+. No test verifies that a notification is actually delivered on current API levels.

---

### A43-12 — MEDIUM: No test for `onStart()` behavior when `BuildConfig.DEBUG` is false and service call is in-flight during `onStop()`/`onDestroy()`

**File:** `ShowPackageAvailable.java` lines 59–86

**Severity:** MEDIUM

The Retrofit `Call` enqueued in `onStart()` is not cancelled in `onStop()` or `onDestroy()`. If the activity is destroyed while the call is in-flight (e.g., user presses Back, system kills the process), the callback fires on a destroyed activity. The callbacks call `startActivity()` and `finish()` on a detached context, which will throw or silently fail. No call reference is retained, so cancellation is impossible. No test exercises activity destruction during a pending network call.

---

### A43-13 — LOW: `haveStoragePermission()` uses `Log.e()` for non-error informational messages — no test

**File:** `ShowPackageAvailable.java` lines 105, 110, 113

**Severity:** LOW

Lines 105, 110, and 113 use `Log.e()` (error level) for messages that are not errors: "You already have the permission" and "You have permission". This pollutes production error logs. No test verifies logging level appropriateness.

---

### A43-14 — INFO: `service` field is initialized in constructor rather than `onCreate()`, preventing dependency injection in tests

**File:** `ShowPackageAvailable.java` lines 47–49

**Severity:** INFO

`service = APKUpdateServiceFactory.getService()` is called from the constructor. Because Android `Activity` constructors cannot accept parameters, this wires a concrete `APKUpdateServiceFactory` dependency unconditionally. There is no seam (setter, overridable factory method, or `Intent`-based injection) allowing a test double to be supplied. This design decision is the root cause of why all network-dependent paths in this activity are structurally untestable without a running server.

---

## File 2: APKPackage.java

### Reading Evidence

**Fully qualified class name:**
`au.com.collectiveintelligence.fleetiq360.autoupdate.model.APKPackage`

**Implemented interfaces:** `java.io.Serializable`

**Fields:**
| Name | Type | Line |
|---|---|---|
| `name` | `String` | 7 |
| `fileName` | `String` | 8 |
| `url` | `String` | 9 |
| `major` | `int` | 10 |
| `minor` | `int` | 11 |
| `patch` | `int` | 12 |

**Methods:**
| Line | Signature |
|---|---|
| 14 | `public String getName()` |
| 18 | `public void setName(String name)` |
| 22 | `public String getFileName()` |
| 26 | `public void setFileName(String fileName)` |
| 30 | `public String getUrl()` |
| 34 | `public void setUrl(String url)` |
| 38 | `public int getMajor()` |
| 42 | `public void setMajor(int major)` |
| 46 | `public int getMinor()` |
| 50 | `public void setMinor(int minor)` |
| 54 | `public int getPatch()` |
| 58 | `public void setPatch(int patch)` |

---

### A43-15 — HIGH: `APKPackage` has no validation of `url` field — any string accepted including non-HTTPS and path-traversal filenames — no test

**File:** `APKPackage.java` lines 30–36

**Severity:** HIGH

`setUrl()` and `getUrl()` accept and return any arbitrary string with no validation. The model is deserialized directly from server JSON by Gson, which sets fields via reflection, bypassing even the setter. There is no:
- Validation that `url` is non-null.
- Validation that `url` uses the `https` scheme.
- Validation that `url` hostname matches the configured `BASE_URL`.
- Validation that `fileName` does not contain path-traversal sequences.

The model is the trust boundary between the server and the APK download code; it performs no sanitization at any layer. No test verifies that deserialization of a malformed server response produces a model whose fields are safe to use.

---

### A43-16 — MEDIUM: `APKPackage` has no version comparison logic and no `equals()`/`hashCode()` — no test

**File:** `APKPackage.java` lines 5–61

**Severity:** MEDIUM

The class exposes `major`, `minor`, and `patch` integer fields but provides no `isNewerThan()`, `compareTo()`, or similar method. Version comparison logic is therefore left to callers, which must reimplement it ad-hoc (with risk of incorrect comparison order). Additionally, the class implements `Serializable` but defines no `serialVersionUID`, which can cause `InvalidClassException` during deserialization if the class is ever changed. Neither issue has test coverage.

---

### A43-17 — LOW: `APKPackage` implements `Serializable` without `serialVersionUID` — no test for serialization compatibility

**File:** `APKPackage.java` line 5

**Severity:** LOW

No `private static final long serialVersionUID` field is declared. Java will auto-generate a `serialVersionUID` based on class structure at compile time. Any change to the class (added field, method rename, etc.) will produce a new auto-generated UID, breaking deserialization of any previously serialized `APKPackage` instances (e.g., saved in `Bundle`s across process death, or passed via `Intent` extra between activities across an app update). No test verifies serialization round-trip stability.

---

## File 3: APKUpdateService.java

### Reading Evidence

**Fully qualified class name:**
`au.com.collectiveintelligence.fleetiq360.autoupdate.service.APKUpdateService`

**Kind:** `interface`

**Annotations used:** `@GET`, `@Path`, `@Query`, `@Url` (all Retrofit 2 annotations)

**Methods:**
| Line | Signature |
|---|---|
| 13 | `Call<APKPackage> getLatestAvailableUpdate(@Path("pkgname") String pkgName, @Query("version") String version)` — HTTP: `GET rest/apk/{pkgname}/update?version=...` |
| 15 | `Call<ResponseBody> downloadPackage(@Url String packageUrl)` — HTTP: `GET <packageUrl>` (full URL override) |

**No fields or constants are defined.**

---

### A43-18 — CRITICAL: `downloadPackage()` accepts an arbitrary full URL via `@Url` with disabled TLS verification — no test verifies URL is constrained to trusted origin

**File:** `APKUpdateService.java` line 15; `OkHttpClientFactory.java` lines 13–34; `FakeX509TrustManager.java` lines 19–78

**Severity:** CRITICAL

The `@Url` Retrofit annotation causes the supplied string to completely replace the configured `baseUrl` for that request. Combined with the `OkHttpClientFactory` configuration:
- `FakeX509TrustManager` installs a trust manager whose `checkServerTrusted()` is a no-op (lines 31–34 of `FakeX509TrustManager.java`), accepting any certificate from any authority for any host.
- A `HostnameVerifier` that unconditionally returns `true` (lines 18–24 of `OkHttpClientFactory.java`), accepting any hostname regardless of the certificate presented.

The net effect is that `downloadPackage()` will make an HTTP GET to any URL supplied — including `http://`, `file://`, private IP ranges, or external attacker-controlled hosts — with no TLS validation, presenting the response bytes as a valid APK download. This interface has no defensive contract; any caller that passes an unvalidated URL from the server response produces a fully exploitable code path. No test:
- Verifies that `downloadPackage()` refuses a URL whose host differs from `BASE_URL`.
- Verifies that `downloadPackage()` refuses a non-HTTPS URL.
- Verifies that the OkHttpClient used by this service performs real certificate validation.

---

### A43-19 — HIGH: `getLatestAvailableUpdate()` uses `@Path("pkgname")` with no encoding constraint — no test for path injection

**File:** `APKUpdateService.java` line 13

**Severity:** HIGH

Retrofit's `@Path` annotation URL-encodes the parameter value by default, which mitigates the most obvious path injection. However, no test verifies:
- That a `pkgName` value containing special characters (`/`, `..`, `%2f`) is rejected or safely encoded before the request is sent.
- That a null `pkgName` or empty-string `pkgName` is handled (Retrofit would construct a path with an empty segment or throw at runtime).
- That a `version` query parameter containing special characters is handled safely.

---

### A43-20 — MEDIUM: `APKUpdateService` interface has no test verifying the endpoint contract (path, query parameters, HTTP method)

**File:** `APKUpdateService.java` lines 12–16

**Severity:** MEDIUM

Neither `getLatestAvailableUpdate()` nor `downloadPackage()` has any contract test (e.g., using `MockWebServer`) that verifies:
- The correct HTTP method is used (`GET`).
- The correct URL path is constructed for `getLatestAvailableUpdate()` (i.e., `rest/apk/app/update?version=...`).
- The `@Url` parameter in `downloadPackage()` is used as-is without modification.
- Response deserialization of `APKPackage` from a known JSON payload produces the expected field values.
- A `404` or `500` from `getLatestAvailableUpdate()` produces a non-null `Response` with a null body (or error body), not a Retrofit `onFailure()` call.

Without these, any refactoring of the Retrofit annotation (e.g., changing the path string) is undetected until production.

---

## Summary Table

| ID | File | Severity | Title |
|---|---|---|---|
| A43-1 | Project-wide | HIGH | Zero automated test coverage — no test directories exist |
| A43-2 | ShowPackageAvailable | CRITICAL | APK downloaded from server-controlled URL with no integrity check, no domain validation, TLS disabled |
| A43-3 | ShowPackageAvailable / APKUpdateService | CRITICAL | `downloadPackage()` open to SSRF via server-controlled `@Url` with no origin check |
| A43-4 | ShowPackageAvailable | HIGH | Partial write on IOException: corrupted APK file left on disk, no user notification |
| A43-5 | ShowPackageAvailable | HIGH | Download response HTTP status not checked before writing body to disk |
| A43-6 | ShowPackageAvailable | HIGH | Update-check response HTTP status not checked before acting on body |
| A43-7 | ShowPackageAvailable | HIGH | `onRequestPermissionsResult()` dereferences potentially null `getSerializableExtra()` |
| A43-8 | ShowPackageAvailable | HIGH | Off-by-one in `grantResults.length <= 2` guard silently skips download on valid 2-element result |
| A43-9 | ShowPackageAvailable | MEDIUM | `APKPackage` not saved before permission request; `onRequestPermissionsResult()` will always get null extra |
| A43-10 | ShowPackageAvailable | MEDIUM | `getFileName()` used in path construction without traversal sanitization |
| A43-11 | ShowPackageAvailable | MEDIUM | Deprecated `Uri.fromFile()` will throw `FileUriExposedException` on API 24+ |
| A43-12 | ShowPackageAvailable | MEDIUM | Retrofit Call not cancelled on activity destruction; callback fires on detached context |
| A43-13 | ShowPackageAvailable | LOW | `Log.e()` used for non-error informational messages |
| A43-14 | ShowPackageAvailable | INFO | `service` initialized in constructor; no injection seam for testing |
| A43-15 | APKPackage | HIGH | `url` and `fileName` fields accept any server-supplied string with no validation |
| A43-16 | APKPackage | MEDIUM | No version comparison logic; no `equals()`/`hashCode()` |
| A43-17 | APKPackage | LOW | `Serializable` without `serialVersionUID` — serialization compatibility fragile |
| A43-18 | APKUpdateService | CRITICAL | `downloadPackage(@Url)` with disabled TLS accepts any host/scheme — fully exploitable |
| A43-19 | APKUpdateService | HIGH | No test for `@Path` / `@Query` injection or null parameter handling |
| A43-20 | APKUpdateService | MEDIUM | No contract tests verifying endpoint paths, HTTP method, or response deserialization |
