# Audit Pass 2 — Agent A52
**Audit run:** 2026-02-26-01
**Assigned files:**
1. `app/src/main/java/au/com/collectiveintelligence/fleetiq360/session/SessionTimeouter.java`
2. `app/src/main/java/au/com/collectiveintelligence/fleetiq360/session/SessionTimeouterReceiver.java`
3. `app/src/main/java/au/com/collectiveintelligence/fleetiq360/ui/activity/ActionActivity.java`

---

## PROJECT-WIDE FINDING

### A52-1 — HIGH: Zero automated test coverage across app/ and LibCommon/ modules

No test directories exist under `app/src/test/`, `app/src/androidTest/`, `LibCommon/src/test/`, or `LibCommon/src/androidTest/`. The only test files in the repository are in the third-party `LibImageloader` module (two unit tests for `ImageSize` and `BaseImageDownloader`), which are unrelated to application logic.

Every class, method, and code path across the entire `app/` module — including session lifecycle management, credential handling, BLE connectivity, GPS data collection, and authentication — is completely untested. All findings below exist in a context where there are zero tests at all: not merely gaps in coverage, but a total absence of a test suite.

**Affected modules:** `app/`, `LibCommon/`
**Impact:** Regressions in session timeout, credential clearing, and authentication logic cannot be detected by CI. Security-sensitive paths (session end, forced logout) have no automated verification.

---

## File 1: SessionTimeouter.java

### Reading Evidence

**Fully qualified class name:** `au.com.collectiveintelligence.fleetiq360.session.SessionTimeouter`

**Fields and constants:**
| Line | Visibility | Type | Name |
|------|-----------|------|------|
| 27 | `private static` | `SessionTimeouter` | `instance` |
| 28 | `private` | `boolean` | `warningDisplayed` |
| 102 | `private static` | `HashMap<Activity, SessionTimeouterReceiver>` | `registrations` |

**Static initializer:**
| Line | Description |
|------|-------------|
| 104–106 | `static { registrations = new HashMap<>(); }` — initialises the registrations map |

**Methods:**
| Line | Visibility | Signature |
|------|-----------|-----------|
| 30 | `public static` | `getInstance() : SessionTimeouter` |
| 36 | `public` | `start(Context context) : void` |
| 42 | `public` | `cancel(Context context) : void` |
| 47 | `private` | `restart() : void` |
| 53 | `private` | `preEndSession() : void` |
| 62 | `package-private` | `endSession() : void` |
| 86 | `private` | `onSessionEnded() : void` |
| 108 | `public static` | `register(Activity activity) : void` |
| 114 | `public static` | `unregister(Activity activity) : void` |
| 120 | `package-private` | `showSessionTimeoutWarningDialog(Context context) : void` |
| 159 | `package-private static` | `showSessionTimeoutWarningDialog() : void` |
| 165 | `private static` | `getContext() : Context` |

---

### Findings

#### A52-2 — HIGH: No test verifying session ends after max_session_length expires

`SessionTimeouter.start()` (line 36) calls `preEndSession()` which calls `SessionResult.preEnd()` to calculate a finish time of `now + maxSessionLength` minutes (read from `CurrentUser.get().getMaxSessionLength()`). The `SessionTimeoutJobService` polls every 60 seconds and calls `endSession()` when `result.isFinished()` returns true (i.e. current time is past `finish_time`). There is no test that:

- Constructs a `SessionResult` with a known `start_time` and `max_session_length`
- Advances mock time past the session boundary
- Verifies that `endSession()` is called
- Verifies that `isFinished()` returns the correct value at the boundary (exactly at `finish_time`) and one millisecond before/after

The off-by-one in `isFinished()` (which uses strict `after()` rather than `>=`) and the 1-second buffer in `SessionDb.endSessions()` (line 229: `currentTime + 1000`) are untested edge cases in security-critical timeout logic.

**Location:** `SessionTimeouter.java:36–40`, `SessionTimeouter.java:62–84`; cross-reference `SessionResult.java:40–63`, `SessionTimeoutJobService.java:18–28`

---

#### A52-3 — HIGH: No test verifying endSession() triggers credential clearing

`endSession()` (line 62) calls `cancel()`, reads the unfinished session, calls `result.end()`, dispatches `saveSessionEnd()` to the web API, and on both success (line 72) and failure (line 78) calls `onSessionEnded()`. `onSessionEnded()` (line 86) iterates the `registrations` map, casts the first registered activity to `FleetActivity`, and calls `onSessionEnded()` on any `FleetFragment` instances.

**The critical gap:** `FleetFragment.onSessionEnded()` (line 285 of `FleetFragment.java`) is an empty stub with no implementation. The actual credential-clearing path — `WebData.instance().logout()` → `CurrentUser.logout()` (which nulls the user reference and deletes the `current_user_id` preference key) — is called only in `DashboardFragment.onSessionEnded()`, which overrides the stub. There is no test that:

- Confirms `DashboardFragment.onSessionEnded()` is reached when `SessionTimeouter.endSession()` fires
- Confirms `CurrentUser.logout()` is actually called (i.e. that `user` is nulled and `current_user_id` is deleted from `ModelPrefs`)
- Verifies that the `onFailed` path of `saveSessionEnd()` also triggers credential clearing (it does call `onSessionEnded()`, but the chain to `DashboardFragment` depends on UI state that is not tested)

If the registered activity at session end is not a `DashboardActivity` hosting a `DashboardFragment`, credentials will not be cleared. No test validates this assumption.

**Location:** `SessionTimeouter.java:62–100`, cross-reference `DashboardFragment.java:104`, `CurrentUser.java:125–128`

---

#### A52-4 — HIGH: Singleton instance never reset; no test for state after endSession()

`SessionTimeouter` uses a static singleton (`instance`, line 27) and a static `registrations` map (line 102). After `endSession()` completes, neither `instance` nor `registrations` is cleared. If the user re-authenticates after a session timeout without a process restart, the stale singleton retains `warningDisplayed = true` from a prior session, which would suppress the timeout warning on any subsequent session. There is no test covering:

- Calling `start()` after a previous `endSession()` and verifying `warningDisplayed` is correctly reset
- Verifying that `registrations` does not accumulate stale entries across session boundaries

**Location:** `SessionTimeouter.java:27–34`, `SessionTimeouter.java:36–44`

---

#### A52-5 — HIGH: No test for endSession() when registrations map is empty

`onSessionEnded()` (line 86–100) obtains an iterator over `registrations.keySet()` and returns early if `!activities.hasNext()` (line 88). This means that if `endSession()` fires — either via the countdown timer (line 154) or the job service — when no activity is registered (e.g. the app is backgrounded and all `FleetActivity` instances have called `unregister()` in `onPause()`), the credential-clearing chain is silently skipped. No test verifies:

- That a session timeout occurring while the app is backgrounded (registrations empty) still results in credentials being cleared
- That the next foreground event triggers the appropriate cleanup

**Location:** `SessionTimeouter.java:86–100`

---

#### A52-6 — MEDIUM: No test for showSessionTimeoutWarningDialog() countdown auto-dismiss path

`showSessionTimeoutWarningDialog(Context context)` (line 120) starts a 5-minute `CountDownTimer` (line 144). On `onFinish()` (line 152), it dismisses the dialog and calls `endSession()`. The `onTick()` handler (line 146) cancels the timer if `alert.isShowing() == false`. No test covers:

- The auto-dismiss path (timer expiry → `endSession()` called)
- The `onTick()` cancel path (dialog dismissed by means other than button press)
- The guard `if (warningDisplayed) return;` (line 121) preventing duplicate dialogs when the static and instance overloads are both triggered

**Location:** `SessionTimeouter.java:120–157`

---

#### A52-7 — MEDIUM: No test for restart() calling cancel() then start() atomically

`restart()` (line 47) calls `cancel(context)` then `start(context)` where `context` is obtained from `getContext()` (line 165), which itself iterates `registrations` and returns the first entry or `null`. If `registrations` is empty at the time the user presses "Continue" in the warning dialog, `restart()` passes `null` to both `cancel()` and `start()`. `SessionTimeoutJobService.cancel(null)` (line 46 of `SessionTimeoutJobService.java`) returns early for null context, but `start()` would similarly return early, meaning the session timer is silently abandoned without any error indication. No test covers the null-context path in `restart()`.

**Location:** `SessionTimeouter.java:47–51`, `SessionTimeouter.java:165–168`

---

#### A52-8 — MEDIUM: No test for getContext() returning null when registrations is empty

`getContext()` (line 165) returns `null` when `registrations` is empty. This value is used by `restart()` (line 48) and potentially any future caller without null-checking. The `cancel(Context)` and `start(Context)` methods in `SessionTimeoutJobService` both guard against null context, but `cancel(Context)` in `SessionTimeouter` itself (line 42) passes the context directly to `SessionTimeoutJobService.cancel()`. No test exercises the empty-registrations path to confirm all callers handle null correctly.

**Location:** `SessionTimeouter.java:165–168`

---

#### A52-9 — MEDIUM: No test verifying preEndSession() does nothing when no unfinished session exists

`preEndSession()` (line 53) reads from the DB and returns early if `result == null` (line 55). It then calls `result.preEnd()` (which sets `finish_time`) and fires a `saveSessionPreEnd` API call. No test covers:

- The null-return early exit (no session in DB)
- The path where `result` is non-null and `saveSessionPreEnd` is called — confirming the `finish_time` is set correctly relative to `maxSessionLength`
- A scenario where `CurrentUser.get()` returns null inside `preEnd()` → `getMaxSessionLength()` (this would throw a NullPointerException)

**Location:** `SessionTimeouter.java:53–60`, cross-reference `SessionResult.java:40–46`

---

#### A52-10 — LOW: Non-idiomatic singleton — no thread-safety; no test for concurrent getInstance() calls

`getInstance()` (line 30) is not synchronised. Two threads calling `getInstance()` simultaneously could each observe `instance == null` and create separate instances, violating singleton semantics. While Android's main-thread model makes concurrent access less likely, no test exercises concurrent access, and session timeout callbacks arrive from job service execution threads.

**Location:** `SessionTimeouter.java:30–34`

---

#### A52-11 — LOW: No test for register()/unregister() symmetry

`register()` (line 108) creates a new `SessionTimeouterReceiver`, registers it with the activity's `registerReceiver()`, and stores it in `registrations`. `unregister()` (line 114) removes the entry and calls `unregisterReceiver()`. No test verifies:

- Calling `unregister()` with an activity that was never registered (the null guard at line 116 handles this, but it is untested)
- Calling `register()` twice for the same activity (the second call would create a second receiver, put it in the map overwriting the first reference, and leak the first registered receiver — it would never be unregistered)

**Location:** `SessionTimeouter.java:108–118`

---

## File 2: SessionTimeouterReceiver.java

### Reading Evidence

**Fully qualified class name:** `au.com.collectiveintelligence.fleetiq360.session.SessionTimeouterReceiver`

**Visibility:** package-private (`class SessionTimeouterReceiver`, no `public` modifier)

**Fields:**
| Line | Visibility | Type | Name |
|------|-----------|------|------|
| 9 | `private` | `Context` | `context` |

**Methods:**
| Line | Visibility | Signature |
|------|-----------|-----------|
| 11 | `package-private` | `SessionTimeouterReceiver(Activity activity) : constructor` |
| 16 | `@Override public` | `onReceive(Context context, Intent intent) : void` |

---

### Findings

#### A52-12 — HIGH: Receiver registered with global (non-local) broadcast; no test verifying external apps cannot trigger premature session end

`SessionTimeouter.register()` (line 108–112 of `SessionTimeouter.java`) registers the receiver using `activity.registerReceiver()` with the intent action `"MyApplication.INTENT_DISPLAYERROR"`. This is the system-level `Context.registerReceiver()`, not `LocalBroadcastManager.registerReceiver()`. Any application on the device — or a background service — that sends a broadcast with action `"MyApplication.INTENT_DISPLAYERROR"` will trigger `onReceive()`, which calls `abortBroadcast()` and then `showSessionTimeoutWarningDialog()`.

The session timeout warning dialog, when its 5-minute countdown expires, calls `endSession()`, which terminates the active session and initiates the credential-clearing chain. A malicious or malfunctioning app on the same device can therefore:
1. Force the warning dialog to appear at any time during an active session
2. Exploit the 5-minute countdown to end the session without user interaction

There is no test verifying:
- That the receiver ignores broadcasts from outside the application
- That the `abortBroadcast()` call (line 17) actually prevents other receivers from seeing the intent in an ordered broadcast context (it has no effect in unordered broadcasts, which is the common case)
- That the action string is sufficiently namespaced to avoid accidental collision

Cross-reference with `FleetActivity.onResume()` (line 450): the `LocalBroadcastManager` is used correctly for shock events and BLE disconnect events, demonstrating that the developer was aware of local broadcasts. The use of global broadcast for the session timeout trigger is inconsistent and represents a security gap.

**Location:** `SessionTimeouterReceiver.java:16–19`; `SessionTimeouter.java:108–112`

---

#### A52-13 — MEDIUM: No test for onReceive() when SessionTimeouter has no registrations

`onReceive()` (line 16) calls `SessionTimeouter.getInstance().showSessionTimeoutWarningDialog(this.context)`. The instance-level `showSessionTimeoutWarningDialog(Context)` (line 120 of `SessionTimeouter.java`) uses the stored `context` field from the constructor (i.e. the activity passed at registration time). If the activity is destroyed after `unregister()` was not called (e.g. a crash or abnormal lifecycle transition), the stored context is a dangling reference to a destroyed activity. No test covers this path.

**Location:** `SessionTimeouterReceiver.java:16–19`

---

#### A52-14 — MEDIUM: abortBroadcast() is ineffective for unordered broadcasts; no test confirming intended isolation

`onReceive()` calls `abortBroadcast()` (line 17). This method only has an effect in ordered broadcasts (sent with `sendOrderedBroadcast()`). For standard broadcasts (sent with `sendBroadcast()`), `abortBroadcast()` is silently ignored. The intent action `"MyApplication.INTENT_DISPLAYERROR"` is used with `activity.registerReceiver()` without any `priority` or ordered broadcast requirement. No test verifies:

- That the broadcast triggering the receiver is indeed sent as an ordered broadcast
- That `abortBroadcast()` actually prevents other receivers from receiving the intent
- Behaviour when the broadcast is received as unordered

**Location:** `SessionTimeouterReceiver.java:17`

---

#### A52-15 — LOW: No test for constructor storing Activity as Context field

The constructor (line 11) accepts an `Activity` parameter and stores it as `Context context` (line 9). While `Activity` is a subtype of `Context`, retaining a reference to an `Activity` in a `BroadcastReceiver` field can prevent garbage collection if the receiver is not unregistered promptly. No test verifies that the context reference is released when `unregister()` is called.

**Location:** `SessionTimeouterReceiver.java:9–13`

---

## File 3: ActionActivity.java

### Reading Evidence

**Fully qualified class name:** `au.com.collectiveintelligence.fleetiq360.ui.activity.ActionActivity`

**Superclass:** `au.com.collectiveintelligence.fleetiq360.ui.common.FleetActivity`

**Fields:** None declared (all inherited from `FleetActivity` and `BaseActivity`).

**Constants:** None declared.

**Methods:**
| Line | Visibility | Signature |
|------|-----------|-----------|
| 12 | `@Override protected` | `onCreate(Bundle savedInstanceState) : void` |

---

### Findings

#### A52-16 — HIGH: No test for NullPointerException when "action" extra is absent

`onCreate()` (line 18–19) calls `getIntent().getStringExtra("action")` and immediately calls `.equals("setup")` on the result without a null check. If the activity is started without the `"action"` extra — for example via an implicit intent, a deep link, or by any code path that forgets to supply the extra — `getStringExtra()` returns `null`, and `.equals()` throws a `NullPointerException`, crashing the activity.

`ActionActivity` is declared in `AndroidManifest.xml` (lines 73–75) without `android:exported="false"`, which means it defaults to exported on API levels before 31 where no intent filter is present but the activity can still be started by other apps using an explicit component name. Even with `android:exported` defaulting to false on API 31+, internal callers can still start the activity without the extra. No test verifies:

- Behaviour when the `"action"` extra is null or absent
- Behaviour when the `"action"` extra is present but is an unrecognised value (neither `"setup"` nor `"report"` — both branches are skipped silently, resulting in a blank activity with no fragment)
- That all call sites always supply the `"action"` extra

**Location:** `ActionActivity.java:18–19`

---

#### A52-17 — MEDIUM: No test for unknown "action" value resulting in blank activity

`onCreate()` (lines 19–25) handles only `"setup"` and `"report"` using if/else-if with no else branch and no error handling. If any other string is passed as the `"action"` extra, the activity displays a blank screen (`activity_common` layout with no fragment). No test verifies:

- That an unrecognised action produces an appropriate error state
- That the activity handles future action values gracefully

**Location:** `ActionActivity.java:19–25`

---

#### A52-18 — MEDIUM: No test for ActionActivity lifecycle integration with SessionTimeouter

`ActionActivity` extends `FleetActivity`, which registers and unregisters with `SessionTimeouter` in `onResume()` / `onPause()`. `ActionActivity` does not override `onResume()` or `onPause()`, so session timeout events are processed during its lifecycle. No test verifies:

- That the session timeout warning dialog can appear correctly while `ActionActivity` is the foreground activity
- That pressing "Terminate" in the timeout dialog while `ActionActivity` is active correctly navigates away
- That `SetupEmailFragment` or `SavedReportFragment` correctly implement `onSessionEnded()` (both are shown by `ActionActivity` but neither's session-end behaviour is tested)

**Location:** `ActionActivity.java:10–27`; cross-reference `FleetActivity.java:441–459`

---

#### A52-19 — LOW: No test for SetupEmailFragment.createInstance(true) returning valid fragment

`onCreate()` (line 20) calls `SetupEmailFragment.createInstance(true)` with a boolean argument. No test verifies that this factory method produces a valid, fully initialised fragment when `true` is passed, or that the fragment correctly reflects the `isSetup = true` state in its UI.

**Location:** `ActionActivity.java:20–21`

---

#### A52-20 — INFO: ActionActivity has no onNewIntent() override; repeated starts are untested

`ActionActivity` does not override `onNewIntent()`. If started with `FLAG_ACTIVITY_SINGLE_TOP` or `FLAG_ACTIVITY_REORDER_TO_FRONT`, the activity will not process the new intent's `"action"` extra, retaining the fragment from the original launch. No test confirms intended behaviour for repeated or re-used starts.

**Location:** `ActionActivity.java:10–27`

---

## Summary Table

| ID | File | Severity | Title |
|----|------|----------|-------|
| A52-1 | project-wide | HIGH | Zero automated test coverage across app/ and LibCommon/ modules |
| A52-2 | SessionTimeouter.java | HIGH | No test verifying session ends after max_session_length expires |
| A52-3 | SessionTimeouter.java | HIGH | No test verifying endSession() triggers credential clearing |
| A52-4 | SessionTimeouter.java | HIGH | Singleton never reset; no test for state after endSession() |
| A52-5 | SessionTimeouter.java | HIGH | No test for endSession() when registrations map is empty |
| A52-6 | SessionTimeouter.java | MEDIUM | No test for warning dialog countdown auto-dismiss path |
| A52-7 | SessionTimeouter.java | MEDIUM | No test for restart() with null context from empty registrations |
| A52-8 | SessionTimeouter.java | MEDIUM | No test for getContext() returning null |
| A52-9 | SessionTimeouter.java | MEDIUM | No test for preEndSession() with no unfinished session |
| A52-10 | SessionTimeouter.java | LOW | Non-synchronised singleton; no test for concurrent getInstance() |
| A52-11 | SessionTimeouter.java | LOW | No test for register()/unregister() symmetry or double-register |
| A52-12 | SessionTimeouterReceiver.java | HIGH | Global broadcast receiver; no test that external apps cannot trigger premature session end |
| A52-13 | SessionTimeouterReceiver.java | MEDIUM | No test for onReceive() with destroyed activity context |
| A52-14 | SessionTimeouterReceiver.java | MEDIUM | abortBroadcast() ineffective for unordered broadcasts; untested |
| A52-15 | SessionTimeouterReceiver.java | LOW | No test for Activity context retention and release on unregister |
| A52-16 | ActionActivity.java | HIGH | NullPointerException when "action" extra is absent; untested |
| A52-17 | ActionActivity.java | MEDIUM | Blank activity on unknown "action" value; no error handling tested |
| A52-18 | ActionActivity.java | MEDIUM | No test for SessionTimeouter integration with ActionActivity lifecycle |
| A52-19 | ActionActivity.java | LOW | No test for SetupEmailFragment.createInstance(true) factory method |
| A52-20 | ActionActivity.java | INFO | No test for repeated/re-used starts without onNewIntent() override |
