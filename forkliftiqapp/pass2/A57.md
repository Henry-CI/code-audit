# Audit Pass 2 — Test Coverage
**Agent:** A57
**Audit run:** 2026-02-26-01
**Files assigned:**
1. `app/src/main/java/au/com/collectiveintelligence/fleetiq360/ui/adapter/AbsRecyclerAdapter.java`
2. `app/src/main/java/au/com/collectiveintelligence/fleetiq360/ui/adapter/PrestartCheckListAdapter.java`
3. `app/src/main/java/au/com/collectiveintelligence/fleetiq360/ui/adapter/SelectDriverAdapter.java`

---

## PROJECT-WIDE FINDING

### A57-1 — HIGH — Zero Automated Test Coverage Across app/ and LibCommon/ Modules

No test directory exists under `app/src/` or `LibCommon/src/`. A search of the repository confirms that only third-party library modules (`LibImageloader`, `LibImagePicker`, `LibPercentProgress`) carry any test files, and those are either stub `ApplicationTest` boilerplate or tests for the image-loader library itself. The `app/` module — which contains all application business logic, safety-critical presenters, adapters, fragments, and data models — has zero unit tests and zero instrumented tests.

**Impact:** Every finding below represents not just a gap in coverage, but a gap against a background of *total* absence. There is no regression safety net for any code change. Safety-critical workflows (forklift pre-start checklist, session management, driver selection) are entirely unverified by automated means.

**Evidence:**
- `glob **/test*/**/*.java` under the repo root returns only `LibImageloader` test files.
- `glob **/androidTest*/**/*.java` returns only `LibImagePicker` and `LibPercentProgress` stub files.
- No `app/src/test/` or `app/src/androidTest/` directory exists.

---

## File 1: AbsRecyclerAdapter.java

### Reading Evidence

**Fully qualified class name:**
`au.com.collectiveintelligence.fleetiq360.ui.adapter.AbsRecyclerAdapter<T>`

**Superclass / interfaces:**
- Extends `android.support.v7.widget.RecyclerView.Adapter<ViewHolder>`

**Fields / constants defined:**

| Field | Type | Line | Visibility |
|---|---|---|---|
| `context` | `Context` | 19 | private |
| `datas` | `List<T>` | 20 | private |
| `resId` | `int` | 21 | private |
| `onItemClickListener` | `OnItemClickListener` | 23 | private |

**Inner class — `MyViewHolder` (line 60):**

| Field | Type | Line | Visibility |
|---|---|---|---|
| `mapCache` | `Map<Integer, View>` | 62 | private |
| `layoutView` | `View` | 63 | private |

**Interface — `OnItemClickListener` (line 96):**

| Method | Signature |
|---|---|
| `onItemClick` | `void onItemClick(View v, int position)` |

**All methods with line numbers:**

| Line | Method | Signature |
|---|---|---|
| 25 | Constructor | `AbsRecyclerAdapter(Context context, int resId)` |
| 31 | `setDatas` | `public void setDatas(List<T> datas)` |
| 36 | `getDatas` | `public List<T> getDatas()` |
| 41 | `getItemCount` | `@Override public int getItemCount()` |
| 47 | `onCreateViewHolder` | `@NonNull @Override public MyViewHolder onCreateViewHolder(@NonNull ViewGroup parent, int viewType)` |
| 54 | `onBindViewHolder` | `@Override public void onBindViewHolder(@NonNull ViewHolder holder, int position)` |
| 58 | `bindDatas` | `public abstract void bindDatas(MyViewHolder holder, T data, int position)` |
| 65 | `MyViewHolder` constructor | `MyViewHolder(View layoutView)` |
| 72 | `getView` | `public View getView(int id)` |
| 84 | `onClick` | `@Override public void onClick(View v)` |
| 91 | `onLongClick` | `@Override public boolean onLongClick(View v)` |
| 100 | `setOnItemClickListener` | `public void setOnItemClickListener(OnItemClickListener onItemClickListener)` |

**Test file:** None. No corresponding test file exists anywhere in the repository.

---

### Findings — AbsRecyclerAdapter.java

### A57-2 — MEDIUM — `setDatas(null)` Causes NullPointerException at `getItemCount()`

**File:** `AbsRecyclerAdapter.java`, line 31–34 and line 41–43

```java
public void setDatas(List<T> datas) {
    this.datas = datas;          // null assignment accepted silently
    this.notifyDataSetChanged();
}

public int getItemCount() {
    return datas.size();         // NPE if datas is null
}
```

`setDatas` accepts a `null` argument without guard. If the caller passes `null` (e.g., from a failed network response that returns `null` instead of an empty list), the internal `datas` field becomes `null`. The next RecyclerView measure pass calls `getItemCount()`, which dereferences `datas.size()` and throws an uncaught `NullPointerException`, crashing the activity. No test covers this path.

**Severity:** MEDIUM — requires a caller to pass `null`, but this is a realistic error path given the app's network-first data loading pattern.

---

### A57-3 — MEDIUM — `onBindViewHolder` Has No Bounds Check; Out-of-Bounds Position Crashes at `datas.get(position)`

**File:** `AbsRecyclerAdapter.java`, line 54–56

```java
public void onBindViewHolder(@NonNull ViewHolder holder, int position) {
    bindDatas((MyViewHolder) holder, datas.get(position), position);
}
```

RecyclerView can call `onBindViewHolder` with a stale `position` after `notifyDataSetChanged()` is called from a click listener while a partial layout pass is in progress. If `datas` is concurrently replaced with a shorter list (via `setDatas`) between the RecyclerView scheduling a bind and executing it, `datas.get(position)` throws `IndexOutOfBoundsException`. No test exercises concurrent dataset replacement.

**Severity:** MEDIUM — requires a specific timing condition but is structurally unguarded.

---

### A57-4 — LOW — `getView()` Cache Returns `null` Without Warning When `findViewById` Fails

**File:** `AbsRecyclerAdapter.java` (inner class `MyViewHolder`), line 72–81

```java
public View getView(int id) {
    View view;
    if (mapCache.containsKey(id)) {
        view = mapCache.get(id);
    } else {
        view = layoutView.findViewById(id);
        mapCache.put(id, view);   // null stored if ID not found
    }
    return view;                  // null returned silently
}
```

If `id` does not exist in the inflated layout, `findViewById` returns `null`. That `null` is cached and returned to the caller. Every subclass caller immediately casts the result to a concrete view type (e.g., `(TextView) holder.getView(...)`), which succeeds with `null`, followed by a method call on the returned reference that throws `NullPointerException`. The cache also permanently stores the `null` for the same ID, meaning the error is sticky for the lifetime of the ViewHolder. No test verifies behavior when a view ID is absent.

**Severity:** LOW — only manifests when a layout resource is misconfigured, but the silent caching makes diagnosis difficult.

---

### A57-5 — LOW — `onLongClick` Always Returns `true` Without Test Verifying Intent

**File:** `AbsRecyclerAdapter.java`, line 91–93

```java
public boolean onLongClick(View v) {
    return true;
}
```

Returning `true` from `onLongClick` consumes the long-press event unconditionally. No subclass can override this behavior because `MyViewHolder` is a non-abstract inner class and `onLongClick` is not declared abstract. Any future requirement to surface long-press actions (e.g., for accessibility or context menus on the checklist) would be silently swallowed. No test documents the intended behavior or verifies the return value.

**Severity:** LOW — current behavior may be intentional, but it is undocumented and untested.

---

### A57-6 — INFO — `setDatas` Calls `notifyDataSetChanged()` Unconditionally; Diffing Never Tested

**File:** `AbsRecyclerAdapter.java`, line 31–34

`setDatas` always calls `notifyDataSetChanged()`, which triggers a full rebind of all visible items. For large lists (e.g., a long pre-start checklist) this discards animation state and scroll position. No `DiffUtil`-based replacement or incremental update method exists, and no test verifies that partial updates work correctly or that scroll position is preserved.

**Severity:** INFO — performance and UX concern with no direct functional risk.

---

## File 2: PrestartCheckListAdapter.java

### Reading Evidence

**Fully qualified class name:**
`au.com.collectiveintelligence.fleetiq360.ui.adapter.PrestartCheckListAdapter`

**Superclass:**
`AbsRecyclerAdapter<String>`

**Fields defined:**

| Field | Type | Line | Visibility |
|---|---|---|---|
| `presenter` | `PreStartCheckListPresenter` | 15 | private |
| `ui` | `EquipmentPrestartFragment` | 16 | private |

**All methods with line numbers:**

| Line | Method | Signature |
|---|---|---|
| 18 | `setPreStartCheckListPresenter` | `public void setPreStartCheckListPresenter(PreStartCheckListPresenter presenter, EquipmentPrestartFragment ui)` |
| 24 | Constructor | `public PrestartCheckListAdapter(Context context, int resId)` |
| 29 | `bindDatas` | `@Override public void bindDatas(MyViewHolder holder, String data, final int position)` |

**Imports / dependencies:**
- `AnswerItem` (`WebService.webserviceclasses.AnswerItem`) — `question_id: int`, `answer: String` (both public fields, no getters)
- `PreStartCheckListPresenter` — exposes `public HashMap<Integer, AnswerItem> mapAnswers`
- `EquipmentPrestartFragment` — exposes `public ArrayList<PreStartQuestionItem> qustionItemArrayList`
- `SegmentedGroup` from `info.hoang8f.android.segmented`
- `RadioButton` (Android widget)

**Key logic in `bindDatas` (lines 29–72):**
1. Line 35: `ui.qustionItemArrayList.get(position).id` — direct index access into the fragment's public list.
2. Lines 37–46: Anonymous `OnClickListener` for "NO" answer — creates `AnswerItem`, sets `answer = "NO"`, puts into `presenter.mapAnswers`.
3. Lines 49–58: Anonymous `OnClickListener` for "YES" answer — creates `AnswerItem`, sets `answer = "YES"`, puts into `presenter.mapAnswers`.
4. Line 60: `presenter.mapAnswers.get(question_id)` — retrieve existing answer for this question.
5. Lines 61–69: Restore radio button checked state from map, or clear if no answer recorded.
6. Line 71: `tv.setText(data)` — set question text.

**Test file:** None. No corresponding test file exists anywhere in the repository.

---

### Findings — PrestartCheckListAdapter.java

### A57-7 — HIGH — No Test for Empty `qustionItemArrayList`; `bindDatas` Crashes at Line 35

**File:** `PrestartCheckListAdapter.java`, line 35

```java
final int question_id = ui.qustionItemArrayList.get(position).id;
```

`bindDatas` is invoked by `AbsRecyclerAdapter.onBindViewHolder` for every item position that RecyclerView requests. If `ui.qustionItemArrayList` is empty (e.g., server returns an empty question array, or the network call fails and the offline cache returns an empty result), `getItemCount()` returns 0 from the inherited adapter and no bind should occur — *but* the two lists are not kept in sync by any shared owner. `setRecyclerViewdata` in `EquipmentPrestartFragment` (line 57) calls `myAdapter.setDatas(dataList)` and separately populates `qustionItemArrayList` in the same method. If `setDatas` triggers an immediate layout and bind before `qustionItemArrayList` has been updated, or if these lists diverge through any other path, `qustionItemArrayList.get(position)` throws `IndexOutOfBoundsException` during a safety-critical pre-start checklist operation.

No test exercises the empty-list path, the out-of-sync path, or the empty-server-result path.

**Severity:** HIGH — the pre-start checklist is a safety-critical workflow that determines whether an operator is cleared to use a forklift. A crash here prevents checklist completion.

---

### A57-8 — HIGH — No Test for Out-of-Bounds `position`; `qustionItemArrayList` and `datas` Can Diverge

**File:** `PrestartCheckListAdapter.java`, line 35; `AbsRecyclerAdapter.java`, line 55

```java
// AbsRecyclerAdapter.onBindViewHolder
bindDatas((MyViewHolder) holder, datas.get(position), position);

// PrestartCheckListAdapter.bindDatas
final int question_id = ui.qustionItemArrayList.get(position).id;
```

The adapter's data list (`datas`, containing `String` question text) and the fragment's `qustionItemArrayList` (containing `PreStartQuestionItem` objects) are maintained as two separate lists with no synchronization mechanism. `setDatas` (inherited) replaces `datas`; `qustionItemArrayList` is replaced separately in `EquipmentPrestartFragment.setRecyclerViewdata`. If these are ever updated in separate calls, or if one is updated and the other is not, `position` will be valid for `datas.get(position)` but invalid for `qustionItemArrayList.get(position)`, or vice versa. Both throw `IndexOutOfBoundsException`. The check in `EquipmentPrestartFragment.onMiddleButton` (line 136) that compares `presenter.mapAnswers.size() != qustionItemArrayList.size()` uses the fragment-side list, not the adapter list, which cannot detect this divergence.

No test verifies that these two lists remain in sync across all update paths.

**Severity:** HIGH — a diverged state means the adapter is writing `question_id` values from one list into answers keyed by values from another, silently corrupting the checklist answers submitted to the server.

---

### A57-9 — HIGH — No Test for Null `presenter` or Null `ui`; `setPreStartCheckListPresenter` Is Separate from Constructor

**File:** `PrestartCheckListAdapter.java`, lines 18–22 and 29–72

```java
public void setPreStartCheckListPresenter(PreStartCheckListPresenter presenter,
                                          EquipmentPrestartFragment ui) {
    this.presenter = presenter;
    this.ui = ui;
}
```

`presenter` and `ui` are initialized to `null` at declaration and only set via a separate setter call after construction. If `bindDatas` is invoked before `setPreStartCheckListPresenter` is called (e.g., RecyclerView triggers a bind immediately after `setAdapter` is called in `EquipmentPrestartFragment.initViews` line 78, before line 83 sets the presenter), both `presenter.mapAnswers` (line 43, 55, 60) and `ui.qustionItemArrayList` (line 35) will throw `NullPointerException`. No test covers the ordering dependency or the null state.

**Severity:** HIGH — `presenter` being null during `bindDatas` causes a crash during the safety-critical pre-start workflow. The construction/initialization order is enforced only by convention, not by type safety.

---

### A57-10 — HIGH — `answerItem.answer` Is Never Checked for Null; Crashes at `equalsIgnoreCase`

**File:** `PrestartCheckListAdapter.java`, line 62

```java
AnswerItem answerItem = presenter.mapAnswers.get(question_id);
if (answerItem != null) {
    if (answerItem.answer.equalsIgnoreCase("yes")) {   // NPE if answer is null
```

`AnswerItem.answer` is a public field with no constructor enforcement — the no-arg constructor `AnswerItem()` leaves `answer` as `null`. The `AnswerItem(JSONObject)` constructor only sets `answer` if `!jsonObject.isNull("answer")` (line 32 of `AnswerItem.java`), meaning a server response that includes `"answer": null` produces an `AnswerItem` with a `null` answer field. When `bindDatas` restores radio button state at line 62, it calls `answerItem.answer.equalsIgnoreCase("yes")` on this `null` field, throwing `NullPointerException`. No test covers a server-supplied null answer value.

**Severity:** HIGH — corrupted or unexpected server data triggers a crash during the checklist restoration step, which occurs every time the RecyclerView rebinds (e.g., on every `notifyDataSetChanged()` call, which happens on every radio button click at lines 44 and 57).

---

### A57-11 — MEDIUM — No Test for `notifyDataSetChanged()` Called Inside Click Listener Causing Reentrant Bind

**File:** `PrestartCheckListAdapter.java`, lines 44 and 57

```java
// Inside answerNo.setOnClickListener:
presenter.mapAnswers.put(question_id, item);
notifyDataSetChanged();

// Inside answerYes.setOnClickListener:
presenter.mapAnswers.put(question_id, item2);
notifyDataSetChanged();
```

`notifyDataSetChanged()` is called from within a click listener that is itself attached to a view inside `bindDatas`. Calling `notifyDataSetChanged()` from within a RecyclerView item's click callback schedules a full rebind. If the user taps rapidly or two click events are processed in the same frame, RecyclerView may call `bindDatas` again for the same position before the first invocation's anonymous listener references have been cleaned up, causing the old `question_id` capture to overwrite answers for a different position. No test exercises rapid or duplicate radio button taps.

**Severity:** MEDIUM — requires rapid user interaction, but the consequence is silently incorrect checklist answers being recorded.

---

### A57-12 — MEDIUM — `radioGroup.clearCheck()` Called on `SegmentedGroup` With No Test for Widget State After Repeated Binds

**File:** `PrestartCheckListAdapter.java`, line 68

```java
} else {
    radioGroup.clearCheck();
}
```

RecyclerView recycles ViewHolders. When `bindDatas` is called for a recycled holder, the `RadioButton` views inside it may retain checked state from a previously bound position. The `clearCheck()` call at line 68 is only reached when no answer is recorded in `mapAnswers` for the current `question_id`. If an answer *is* recorded, only one of `answerYes.setChecked(true)` or `answerNo.setChecked(true)` is called, but the *other* radio button is not explicitly unchecked. The `SegmentedGroup` is expected to manage mutual exclusion, but this is not verified. No test confirms that recycled holders with previously checked buttons render correctly for a new position.

**Severity:** MEDIUM — visually wrong checklist state can mislead the operator into believing a question has been answered when it has not, or vice versa.

---

### A57-13 — INFO — `presenter.mapAnswers` Is a Public Field; No Encapsulation Tested

**File:** `PrestartCheckListAdapter.java`, lines 43, 55, 60; `PreStartCheckListPresenter.java`, line 25

```java
// In PreStartCheckListPresenter:
public HashMap<Integer, AnswerItem> mapAnswers = new HashMap<>();

// In PrestartCheckListAdapter.bindDatas:
presenter.mapAnswers.put(question_id, item);
```

The adapter directly mutates the presenter's internal answer map via a public field. No accessor or method controls this mutation. Any component holding a reference to the presenter can corrupt the answer map without detection. No test verifies that the map is in a consistent state after multiple concurrent mutations.

**Severity:** INFO — architectural concern; direct risk is low in the current single-threaded UI context.

---

## File 3: SelectDriverAdapter.java

### Reading Evidence

**Fully qualified class name:**
`au.com.collectiveintelligence.fleetiq360.ui.adapter.SelectDriverAdapter`

**Superclass:**
`AbsRecyclerAdapter<User>`

**Fields defined:**

| Field | Type | Line | Visibility |
|---|---|---|---|
| `presenter` | `SelectDriverPresenter` | 11 | private |

**All methods with line numbers:**

| Line | Method | Signature |
|---|---|---|
| 13 | Constructor | `public SelectDriverAdapter(Context context, int resId, SelectDriverPresenter presenter)` |
| 19 | `bindDatas` | `@Override public void bindDatas(MyViewHolder holder, User item, int position)` |

**Key logic in `bindDatas` (lines 19–25):**
1. Line 20: `holder.getView(R.id.company_driver_item_text_id)` cast to `TextView`.
2. Line 21: `tv.setText(item.fullName())` — calls `User.fullName()` which formats `firstName + " " + lastName`.
3. Line 22: `holder.getView(R.id.company_driver_item_image_id)` cast to `ImageView`.
4. Line 24: `presenter.showImage(item.getPhotoUrl(), iv)` — delegates image loading to presenter.

**Test file:** None. No corresponding test file exists anywhere in the repository.

---

### Findings — SelectDriverAdapter.java

### A57-14 — MEDIUM — No Test for `item.fullName()` When `firstName` or `lastName` Is Null

**File:** `SelectDriverAdapter.java`, line 21; `User.java`, line 66–68

```java
// SelectDriverAdapter.bindDatas:
tv.setText(item.fullName());

// User.fullName():
public String fullName() {
    return String.format("%s %s", firstName, lastName);
}
```

`User.firstName` and `User.lastName` are set via constructor with no null guard. `String.format("%s %s", null, null)` returns `"null null"` — which is functionally wrong but does not throw. However, `item` itself could be null if the data list contains a null entry (no guard in `AbsRecyclerAdapter.onBindViewHolder`). No test covers a null `User` item, a `User` with null name fields, or a `User` with empty name fields.

**Severity:** MEDIUM — null `User` in the list crashes the UI; null name fields produce a display string of "null null" which is incorrect in a safety context where driver identification matters.

---

### A57-15 — LOW — No Test for `presenter.showImage()` With Null `photoUrl`

**File:** `SelectDriverAdapter.java`, line 24; `SelectDriverPresenter.java`, line 25–41

```java
presenter.showImage(item.getPhotoUrl(), iv);
```

`User.getPhotoUrl()` can return `null` (no null guard in the `User` constructor or getter). `SelectDriverPresenter.showImage` passes this URL directly to `ImageLoader.getInstance().displayImage(url, ...)`. The `DisplayImageOptions` builder sets `showImageForEmptyUri` and `showImageOnFail` fallback drawables — which handle empty URI and load failure respectively — but whether a `null` URL string is treated as "empty URI" or causes an exception in the `ImageLoader` library is untested. No test verifies null-URL behavior.

**Severity:** LOW — `ImageLoader` is a third-party library that likely handles null gracefully given `showImageForEmptyUri` is configured, but this is not verified in the project's own tests.

---

### A57-16 — LOW — `bindDatas` Has No Test for Null `presenter`

**File:** `SelectDriverAdapter.java`, lines 13–16 and 24

```java
public SelectDriverAdapter(Context context, int resId, SelectDriverPresenter presenter) {
    super(context, resId);
    this.presenter = presenter;   // null accepted silently
}
```

Unlike `PrestartCheckListAdapter`, `SelectDriverAdapter` receives `presenter` via constructor, which is better. However, `null` is accepted without guard. If the caller passes `null` (e.g., a fragment that creates the adapter before its own presenter is initialized), `bindDatas` calls `presenter.showImage(...)` at line 24 and throws `NullPointerException`. No test verifies behavior with a null presenter.

**Severity:** LOW — requires a caller error, and the failure is immediate and obvious at runtime rather than delayed.

---

## Summary Table

| ID | Severity | File | Description |
|---|---|---|---|
| A57-1 | HIGH | Project-wide | Zero automated test coverage in `app/` and `LibCommon/` modules |
| A57-2 | MEDIUM | AbsRecyclerAdapter | `setDatas(null)` causes NPE at `getItemCount()` |
| A57-3 | MEDIUM | AbsRecyclerAdapter | Out-of-bounds position during concurrent `setDatas` + bind |
| A57-4 | LOW | AbsRecyclerAdapter | `getView()` caches and returns null silently for missing view IDs |
| A57-5 | LOW | AbsRecyclerAdapter | `onLongClick` always returns `true`; no test documents intent |
| A57-6 | INFO | AbsRecyclerAdapter | `setDatas` uses full rebind; no diffing; scroll position not preserved |
| A57-7 | HIGH | PrestartCheckListAdapter | No test for empty `qustionItemArrayList`; crashes at `get(position)` |
| A57-8 | HIGH | PrestartCheckListAdapter | `datas` and `qustionItemArrayList` can diverge; silently corrupts answers |
| A57-9 | HIGH | PrestartCheckListAdapter | `presenter` and `ui` are null until `setPreStartCheckListPresenter()` is called |
| A57-10 | HIGH | PrestartCheckListAdapter | `answerItem.answer` not null-checked before `equalsIgnoreCase` |
| A57-11 | MEDIUM | PrestartCheckListAdapter | `notifyDataSetChanged()` inside click listener; reentrant bind risk |
| A57-12 | MEDIUM | PrestartCheckListAdapter | Recycled ViewHolder radio state not fully reset in all answer paths |
| A57-13 | INFO | PrestartCheckListAdapter | `presenter.mapAnswers` is a public field mutated directly by adapter |
| A57-14 | MEDIUM | SelectDriverAdapter | No test for null `User` item or null/empty name fields in `fullName()` |
| A57-15 | LOW | SelectDriverAdapter | `showImage()` with null `photoUrl` not verified |
| A57-16 | LOW | SelectDriverAdapter | Constructor accepts null `presenter` without guard |
