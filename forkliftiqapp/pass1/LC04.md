# Pass 1 Security Audit — Agent LC04
**Date:** 2026-02-27
**Repo:** forkliftiqapp
**Stack:** Android/Java

---

## Step 1 — Branch Verification

Command run: `git -C /c/Projects/cig-audit/repos/forkliftiqapp branch --show-current`
Result: `master`

**Discrepancy recorded:** Checklist specifies `Branch: main`. Actual branch is `master`. Branch confirmed as `master`; proceeding.

---

## Step 2 — Assigned Files

1. `LibCommon/src/main/java/com/yy/libcommon/ErrorDialog.java`
2. `LibCommon/src/main/java/com/yy/libcommon/FileManager.java`
3. `LibCommon/src/main/java/com/yy/libcommon/Font/AMButton.java`

---

## Step 3 — Reading Evidence

### File 1: ErrorDialog.java

**Fully qualified class name:** `com.yy.libcommon.ErrorDialog`
**Superclass:** `com.yy.libcommon.BaseDialog` (extends `DialogFragment`)

**Public methods (with line numbers):**

| Line | Signature |
|------|-----------|
| 31   | `public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState)` |
| 40   | `public static ErrorDialog newInstance(String title, String content, String buttonText)` |
| 60   | `public void setOnErrorCallback(OnErrorCallback callback)` |
| 65   | `protected void setupViews()` (overrides BaseDialog) |
| 106  | `public void onDismiss(DialogInterface dialog)` |

**Public inner class:** `OnErrorCallback` (line 113) — static class with two public methods:
- `public void onCloseButton()` (line 114)
- `public void onDismiss()` (line 117)

**Private fields:**
- `mTitleTextView` (TextView, line 19)
- `mErrorText` (TextView, line 20)
- `mCloseButton` (TextView, line 21)
- `mTitle` (String, line 23)
- `mContent` (String, line 24)
- `mCloseButtonText` (String, line 25)
- `mCallback` (OnErrorCallback, line 27)

**Android component type:** DialogFragment (via BaseDialog). Not an Activity, Service, BroadcastReceiver, or ContentProvider. Not exported in the manifest sense.

---

### File 2: FileManager.java

**Fully qualified class name:** `com.yy.libcommon.FileManager`

**Public methods (with line numbers):**

| Line | Signature |
|------|-----------|
| 31   | `public static FileManager instance()` |
| 38   | `public static Bitmap readBitmapFromPath(String path)` |
| 54   | `public static File createFilePath(String fileFullPath)` |
| 88   | `public static String getFileDir()` |
| 95   | `public static File createLocalImageFile(String fileName)` |
| 111  | `public static void copyFile(File sourceFile, File destFile)` |
| 147  | `public static void safeDeleteFile(Context context, final String path)` |
| 181  | `public static String getFileTypeString()` |
| 185  | `public static String getLocalFileFolder()` |
| 189  | `public static String existingLocalFilePath(int key, int fileType)` |
| 197  | `public static String getLocalFilePath(int key, int fileType)` |
| 207  | `public static File getLocalFileInstance(int key)` |
| 217  | `public static String getLocalFileDir()` |
| 226  | `public static boolean isFileExist(String filePath)` |

**Private fields:**
- `ourInstance` (static FileManager, line 27) — singleton instance

**Key constants resolved (via LibConfig.java):**
- `LibConfig.BASE_DIRECTOY` = `"ForkIQ360"` (note: typo "DIRECTOY" in constant name)
- `LibConfig.IMAGE_DIRECTORY` = `"images"`

Effective external storage path: `<ExternalStorageDirectory>/ForkIQ360/images/<key>.jpg`

---

### File 3: AMButton.java

**Fully qualified class name:** `com.yy.libcommon.Font.AMButton`
**Superclass:** `android.widget.Button`

**Public methods (with line numbers):**

| Line | Signature |
|------|-----------|
| 17   | `public AMButton(Context context)` |
| 23   | `public AMButton(Context context, AttributeSet attrs)` |
| 29   | `public AMButton(Context context, AttributeSet attrs, int defStyle)` |

**Private methods:**
- `private void applyCustomFont(Context context, AttributeSet attrs)` (line 36)

**Public fields:** None.

**Android component type:** Custom View (extends Button). Not an exported component.

---

## Step 4 — Checklist Section Review

### Section 1: Signing and Keystores

No signing or keystore logic is present in any of the three assigned files. This section is not applicable to these files.

No issues found — Section 1 (Signing and Keystores) [not applicable to assigned files].

---

### Section 2: Network Security

No network clients, HTTP/HTTPS calls, URL handling, SSL/TLS configuration, or API endpoint references are present in any of the three assigned files.

No issues found — Section 2 (Network Security) [not applicable to assigned files].

---

### Section 3: Data Storage

#### FINDING DS-01 — HIGH: Exclusive Use of External Storage for All Application Files

**File:** `FileManager.java`
**Lines:** 197–224

All three storage resolution methods (`getLocalFilePath`, `getLocalFileInstance`, `getLocalFileDir`) construct paths exclusively using `Environment.getExternalStorageDirectory()`:

```java
// Line 197–205
public static String getLocalFilePath(int key, int fileType){
    String s = Environment.getExternalStorageDirectory()
            + File.separator + LibConfig.BASE_DIRECTOY
            + File.separator + FileManager.getLocalFileFolder()
            + File.separator + key + FileManager.getFileTypeString();
    return s;
}

// Line 207–215
public static File getLocalFileInstance(int key){
    File newFile = new File(Environment.getExternalStorageDirectory()
            + File.separator + LibConfig.BASE_DIRECTOY
            + File.separator + FileManager.getLocalFileFolder()
            + File.separator + key + FileManager.getFileTypeString());
    return newFile;
}

// Line 217–224
public static String getLocalFileDir(){
    String s = Environment.getExternalStorageDirectory()
            + File.separator + LibConfig.BASE_DIRECTOY
            + File.separator + FileManager.getLocalFileFolder();
    return s;
}
```

Effective path: `/sdcard/ForkIQ360/images/<key>.jpg`

External storage (`Environment.getExternalStorageDirectory()`) is world-readable on Android versions prior to API 29 (Android 10). Any application with `READ_EXTERNAL_STORAGE` permission can read files at this path. Since this app is a forklift management application handling operator images or assignment photographs, storing such files in unprotected external storage exposes operator data to any co-installed app that holds the storage permission. The correct approach for Android API 29+ is `Context.getExternalFilesDir()` (scoped storage, not world-readable) or `Context.getFilesDir()` (internal storage).

**`Environment.getExternalStorageDirectory()` was deprecated in API 29 (Android 10).** Depending on the app's `targetSdkVersion`, this may also be a deprecated API finding.

**Severity:** High

---

#### FINDING DS-02 — MEDIUM: Deprecated `ACTION_MEDIA_MOUNTED` Broadcast on Pre-KitKat Path

**File:** `FileManager.java`
**Lines:** 160–162

```java
if(Build.VERSION.SDK_INT < Build.VERSION_CODES.KITKAT) {
    context.sendBroadcast(new Intent(Intent.ACTION_MEDIA_MOUNTED,
            Uri.parse("file://" + Environment.getExternalStorageDirectory())));
}
```

The `Intent.ACTION_MEDIA_MOUNTED` broadcast is guarded to pre-KitKat (API < 19) only. Android versions below KitKat are end-of-life. This code path is a legacy artifact and is functionally dead code on any currently supported device. The `file://` URI scheme can trigger StrictMode violations and in certain Android versions, when broadcast by a third-party app, causes a `SecurityException`. Although the runtime guard makes exploitation on modern devices impossible, the pattern itself is fragile. This is a low-severity maintenance concern; however, combined with DS-01, it reinforces that this file's storage strategy was designed for a pre-scoped-storage world.

**Severity:** Low (informational)

---

#### FINDING DS-03 — MEDIUM: Silent Exception Swallowing in copyFile

**File:** `FileManager.java`
**Lines:** 121–128

```java
try {
    source = new FileInputStream(sourceFile).getChannel();
    destination = new FileOutputStream(destFile).getChannel();
    destination.transferFrom(source, 0, source.size());
}
catch (Exception e){
    // empty catch block — no logging, no error propagation
}
```

The `copyFile` method silently swallows all exceptions (including `IOException`, `SecurityException`, and `OutOfMemoryError` promoted to `Exception`). A failed file copy produces no log output and returns no error signal to the caller. This prevents detection of storage failures, permission errors, or data corruption. While not directly a security vulnerability, silent failure during file operations can mask security-relevant conditions such as a failed write to a protected directory or a permissions exception triggered by a scoped-storage violation.

**Severity:** Medium (reliability/observability concern with security implications)

---

#### FINDING DS-04 — INFORMATIONAL: Unauthenticated Path Traversal Risk in readBitmapFromPath and createFilePath

**File:** `FileManager.java`
**Lines:** 38–52, 54–86

Both `readBitmapFromPath(String path)` and `createFilePath(String fileFullPath)` accept caller-supplied string paths with no canonicalization or validation:

```java
// Line 38–52
public static Bitmap readBitmapFromPath(String path){
    Bitmap mImageBitmap = null;
    if(path != null){
        File file = new File(path);
        if(file.exists()){
            mImageBitmap = BitmapFactory.decodeFile(path);
            ...
        }
    }
    return mImageBitmap;
}

// Line 54–86
public static File createFilePath(String fileFullPath) {
    File file = new File(fileFullPath);
    String dir = file.getParent();
    ...
    File fileDir = new File(dir);
    if(!fileDir.exists()){
        fileDir.mkdirs();
    }
    file.createNewFile();
    return file;
}
```

If paths originate from user input, network responses, or Intent extras without prior validation, an attacker who can influence the path string could read from or write to arbitrary locations on the filesystem accessible to the app process. The severity depends entirely on how callers supply the path argument. Without tracing all callers this is flagged as informational for Pass 1 — callers should be reviewed in Pass 2.

**Severity:** Informational (requires caller trace in subsequent pass)

---

#### ErrorDialog.java — Data Storage

The `ErrorDialog` class sets text on UI widgets (`mTitleTextView`, `mErrorText`, `mCloseButton`). It does not write to any file, SharedPreferences, database, or external storage. No data storage issues are present.

No issues found — Section 3 (Data Storage) for ErrorDialog.java.

---

#### AMButton.java — Data Storage

AMButton reads a font attribute from styled attributes and loads a typeface from `FontCache`. No file I/O, SharedPreferences, or external storage access is present.

No issues found — Section 3 (Data Storage) for AMButton.java.

---

### Section 4: Input and Intent Handling

#### FINDING IH-01 — INFORMATIONAL: Unvalidated String Inputs Rendered Directly in Dialog UI

**File:** `ErrorDialog.java`
**Lines:** 40–58, 74–90

`newInstance(String title, String content, String buttonText)` accepts arbitrary strings and sets them directly on TextViews with no sanitization:

```java
// Lines 44–56
if (title != null){ fragment.mTitle = title; }
if (content != null){ fragment.mContent = content; }
if (buttonText != null){ fragment.mCloseButtonText = buttonText; }

// Lines 74–90 (in setupViews)
mTitleTextView.setText(mTitle);
mErrorText.setText(mContent);
mCloseButton.setText(mCloseButtonText);
```

Android `TextView.setText()` with plain `String` input does not execute HTML or scripts, so there is no XSS risk. However, if these strings originate from a network response (e.g., a server-supplied error message from forkliftiqws), a compromised backend could inject misleading text into the error dialog (UI redressing). The severity depends on the origin of the strings passed to `newInstance`. Flagged as informational for Pass 1.

**Severity:** Informational (requires caller trace in subsequent pass)

---

#### AMButton.java — Input Handling

`AMButton.applyCustomFont` reads the `ttf_type` attribute from XML layout attributes. This is a compile-time layout attribute, not runtime user input. No unvalidated input handling concern.

No issues found — Section 4 (Input and Intent Handling) for AMButton.java.

---

### Section 5: Authentication and Session

No authentication logic, credential storage, session token handling, or login/logout operations are present in any of the three assigned files.

No issues found — Section 5 (Authentication and Session) [not applicable to assigned files].

---

### Section 6: Third-Party Libraries

No third-party library dependencies are imported or invoked in any of the three assigned files beyond standard Android SDK and Java standard library classes. `FontCache` is an internal class within the same library module.

No issues found — Section 6 (Third-Party Libraries) [not applicable to assigned files].

---

### Section 7: Google Play and Android Platform

#### FINDING GP-01 — MEDIUM: Use of Deprecated `Environment.getExternalStorageDirectory()` API

**File:** `FileManager.java`
**Lines:** 198–199, 208–210, 218–220

`Environment.getExternalStorageDirectory()` was deprecated in Android API 29 (Android 10). On devices running API 29+ with `targetSdkVersion >= 29`, scoped storage enforcement means this path may not be accessible without the `MANAGE_EXTERNAL_STORAGE` permission (which requires Play Store policy review and explicit user grant). Apps targeting API 30+ that use this method without declaring `MANAGE_EXTERNAL_STORAGE` will receive a `SecurityException` at runtime. This is a platform compatibility finding that compounds the security concern in DS-01.

**Severity:** Medium (deprecated API with runtime failure risk on modern Android)

---

#### FINDING GP-02 — LOW: `AsyncTask`-era Pattern / Singleton Without Thread Safety

**File:** `FileManager.java`
**Lines:** 27–36

The singleton is implemented without thread synchronization:

```java
private static FileManager ourInstance;

public static FileManager instance() {
    if(ourInstance == null){
        ourInstance = new FileManager();
    }
    return ourInstance;
}
```

This is a classic double-checked locking omission. In a multi-threaded environment (e.g., background threads calling `FileManager.instance()` concurrently), two instances could be created. This is a low-severity reliability concern rather than a direct security finding, but concurrent file operations without synchronization could produce interleaved writes or race conditions when both instances operate on the same external storage path.

**Severity:** Low

---

## Summary of Findings

| ID     | File             | Severity      | Summary |
|--------|------------------|---------------|---------|
| DS-01  | FileManager.java | High          | All file I/O routes to `Environment.getExternalStorageDirectory()` — world-readable on pre-API-29 devices; deprecated on API 29+. |
| DS-03  | FileManager.java | Medium        | Silent exception swallowing in `copyFile` masks storage failures and security-relevant errors. |
| GP-01  | FileManager.java | Medium        | Deprecated `Environment.getExternalStorageDirectory()` causes runtime `SecurityException` on API 30+ with scoped storage enforcement. |
| DS-02  | FileManager.java | Low           | Dead-code `ACTION_MEDIA_MOUNTED` broadcast on pre-KitKat path; `file://` URI scheme is fragile. |
| GP-02  | FileManager.java | Low           | Singleton `instance()` lacks thread synchronization — potential race condition on concurrent access. |
| DS-04  | FileManager.java | Informational | Caller-supplied paths in `readBitmapFromPath` and `createFilePath` not validated — path traversal risk depends on callers. |
| IH-01  | ErrorDialog.java | Informational | Dialog strings rendered without sanitization — UI redressing risk if strings originate from network. |

**Files with no findings:** `AMButton.java` — custom font-loading Button subclass. No security-relevant logic.

---

## Notes for Subsequent Passes

- **Callers of `FileManager.getLocalFilePath`, `getLocalFileInstance`, `getLocalFileDir`** should be audited to determine whether the app has already migrated any callers to scoped storage alternatives.
- **Callers of `FileManager.readBitmapFromPath` and `createFilePath`** should be traced to confirm path origins (network vs. internal).
- **Callers of `ErrorDialog.newInstance`** should be traced to confirm whether `content` or `title` strings can originate from forkliftiqws API responses.
- The typo `BASE_DIRECTOY` (missing 'R') in `LibConfig.java` is noted as a code quality observation.
