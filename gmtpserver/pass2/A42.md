# Pass 2: Test Coverage — A42
**Agent:** A42
**Branch verified:** master
**Files reviewed:** src/gmtp/codec/GMTPResponseEncoder.java, src/gmtp/configuration/ConfigurationManager.java, src/gmtp/configuration/DeniedPrefixesManager.java
**Test file read:** test/TestDataMessageHandler.java

---

## Reading Evidence

### src/gmtp/codec/GMTPResponseEncoder.java

**Class name:** `gmtp.codec.GMTPResponseEncoder` (package-private; extends `ProtocolEncoderAdapter`)

**Methods / constructors:**

| Name | Line |
|------|------|
| `encode(IoSession, Object, ProtocolEncoderOutput)` | 37 |
| `encodeMessageType(Type)` (private) | 60 |

**Constants and fields:**

| Name | Type | Line | Value |
|------|------|------|-------|
| `PDU_ID` | `static final short` | 23 | `0x0001` |
| `PDU_DATA` | `static final short` | 24 | `0x0002` |
| `PDU_ID_EXT` | `static final short` | 25 | `0x0003` |
| `PDU_DATA_EXT` | `static final short` | 26 | `0x0004` |
| `PDU_ACK` | `static final short` | 27 | `0x0005` |
| `PDU_ERROR` | `static final short` | 28 | `0x0006` |
| `PDU_CLOSED` | `static final short` | 30 | `0x0007` (@SuppressWarnings("unused")) |
| `PDU_PROTO_VER` | `static final short` | 31 | `0x0008` |
| `PDU_BEGIN_TRANSACTION` | `static final short` | 32 | `0x0009` |
| `PDU_END_TRANSACTION` | `static final short` | 33 | `0x000A` |
| `PDU_NAK` | `static final short` | 34 | `0x000D` |
| `logger` | `static Logger` | 35 | SLF4J logger |

**Inner types:** none

---

### src/gmtp/configuration/ConfigurationManager.java

**Class name:** `gmtp.configuration.ConfigurationManager` (public; extends `Thread`)

**Methods / constructors:**

| Name | Line |
|------|------|
| `ConfigurationManager(int sleepTime)` (constructor) | 28 |
| `ConfigurationManager()` (constructor) | 33 |
| `setRefreshInterval(int)` | 37 |
| `getConfiguration()` | 41 |
| `run()` (override) | 47 |
| `loadConfiguration()` | 89 |
| `setOutgoingDaemon(OutgoingMessageManager)` | 102 |
| `setOutgoingResenderDaemon(OutgoingMessageManager)` | 106 |

**Constants and fields:**

| Name | Type | Line | Notes |
|------|------|------|-------|
| `sleepTime` | `int` | 21 | default 10000 ms |
| `config` | `Configuration` | 22 | |
| `outgoingDaemon` | `OutgoingMessageManager` | 23 | |
| `outgoingResnderDaemon` | `OutgoingMessageManager` | 24 | (typo: Resnder) |
| `logger` | `static Logger` | 25 | SLF4J logger |
| `routingMap` | `XmlRoutingMap` | 26 | declared but never assigned |
| `confLoader` | `XmlConfigurationLoader` | 44 | instance field, initialised inline |

**Inner types:** none

---

### src/gmtp/configuration/DeniedPrefixesManager.java

**Class name:** `gmtp.configuration.DeniedPrefixesManager` (public; extends `Thread`)

**Methods / constructors:**

| Name | Line |
|------|------|
| `DeniedPrefixesManager(int sleepTime)` (constructor) | 31 |
| `DeniedPrefixesManager(Configuration config)` (constructor) | 36 |
| `setRefreshInterval(int)` | 42 |
| `run()` (override) | 48 |
| `loadConfiguration()` | 75 |
| `hasChanged()` | 88 |

**Constants and fields:**

| Name | Type | Line | Notes |
|------|------|------|-------|
| `sleepTime` | `int` | 24 | default 10000 ms |
| `config` | `Configuration` | 25 | |
| `logger` | `static Logger` | 26 | SLF4J logger |
| `serializer` | `static Serializer` | 27 | `new Persister()` |
| `prefixFile` | `File` | 28 | set in `setRefreshInterval` |
| `lastAccessed` | `long` | 29 | tracks file modification time |

**Inner types:** none

**Cross-class note:** `GMTPRouter.deniedPrefixes` (declared at `GMTPRouter.java:48`) is `public static HashMap<Integer, String>` — it has **no `volatile` modifier**. `DeniedPrefixesManager.loadConfiguration()` writes this field from a background thread; `GMTPMessageHandler` reads it from handler threads without any synchronisation.

---

## Findings

## A42-1 — GMTPResponseEncoder: encode() is completely untested

**Severity:** HIGH
**File:** src/gmtp/codec/GMTPResponseEncoder.java
**Description:** The single test file (`TestDataMessageHandler.java`) covers only `DataMessageHandler.sendAuthResponse()`. There are zero tests for `GMTPResponseEncoder`. The `encode()` method contains several failure paths that are never exercised: (1) a NullPointerException if `gmtpMsg.getMessage()` returns null (line 41, `length()` call, and line 54, `getBytes()` call); (2) a buffer overflow — the fixed capacity is 256 bytes and `setAutoExpand(false)` (line 47) means any message longer than the remaining buffer space will throw a `BufferOverflowException` at runtime; (3) a NullPointerException if the session attribute `"extVersion"` is absent (line 50, `equalsIgnoreCase()` on a null `extVersion`); (4) the `encodeMessageType()` private method throws `IllegalArgumentException` for unknown types but this is never tested. None of these paths are covered.
**Fix:** Create a dedicated `TestGMTPResponseEncoder` JUnit test class. Use a mock `IoSession` (e.g., via Mockito or Apache MINA's `DummySession`) and a mock/stub `ProtocolEncoderOutput`. Write tests for: a valid DATA message with `extVersion="0"`, a valid DATA_EXT message with `extVersion="1"`, a message whose payload exceeds 256 bytes to assert that a `BufferOverflowException` is thrown (and decide whether the buffer should auto-expand), a null `getMessage()` return to assert proper error handling, a null or absent `extVersion` session attribute, and each `GMTPMessage.Type` value including an unrecognised type to assert `IllegalArgumentException` from `encodeMessageType()`.

---

## A42-2 — GMTPResponseEncoder: encodeMessageType() untested for all message type variants

**Severity:** MEDIUM
**File:** src/gmtp/codec/GMTPResponseEncoder.java
**Description:** `encodeMessageType()` maps every `GMTPMessage.Type` enum value to a PDU constant. The `default` branch throws `IllegalArgumentException`. Because the method is private it is exercised only indirectly through `encode()`, and there are currently no tests for `encode()` at all. There is no test confirming the correct PDU short value is emitted for each type, nor a test confirming that an invalid/future enum value triggers the exception.
**Fix:** As part of the `TestGMTPResponseEncoder` test class recommended above, exercise each enum branch by calling `encode()` with a message of the corresponding type and inspecting the first two bytes of the resulting `IoBuffer` against the expected PDU constant. Add a test that passes an enum value that does not appear in the switch (if the enum is extended in future) or inject a mock to trigger the default branch, asserting `IllegalArgumentException`.

---

## A42-3 — ConfigurationManager: loadConfiguration() is completely untested

**Severity:** HIGH
**File:** src/gmtp/configuration/ConfigurationManager.java
**Description:** `loadConfiguration()` is the method that reads the application configuration from disk and makes it available to the rest of the server. It is never referenced in any test file. Failure paths include: the `XmlConfigurationLoader.load()` returning `false` (line 91), the loader throwing an exception (line 94), and the normal success path. There are no tests verifying that `getConfiguration()` returns a non-null, correctly-populated `Configuration` after a successful load, nor that it returns the previous configuration (or null) after a failed reload.
**Fix:** Create `TestConfigurationManager`. Use a temporary configuration file on the filesystem or a test double for `XmlConfigurationLoader`. Test: (a) successful load populates `config` and returns `true`; (b) `load()` returns `false` leaves `config` unchanged and method returns `false`; (c) loader throws an exception — method returns `false` and does not propagate; (d) `getConfiguration()` is null before the first successful load.

---

## A42-4 — ConfigurationManager: setRefreshInterval() and concurrent daemon setters untested

**Severity:** MEDIUM
**File:** src/gmtp/configuration/ConfigurationManager.java
**Description:** `setRefreshInterval()`, `setOutgoingDaemon()`, and `setOutgoingResenderDaemon()` are public API methods that control runtime behaviour of the manager thread. None are tested. `setRefreshInterval()` contains a conditional: if `sleepTime == 0` the interval is silently left unchanged (line 38) — this edge case is not verified. `setOutgoingDaemon()` and `setOutgoingResenderDaemon()` are `synchronized` but there are no tests to verify that concurrent calls from multiple threads do not cause data races on the unsynchronised reads of `outgoingDaemon` and `outgoingResnderDaemon` within `run()` (those reads are not synchronised).
**Fix:** Add unit tests for `setRefreshInterval()` covering zero and non-zero arguments. Add tests verifying that `setOutgoingDaemon()` and `setOutgoingResenderDaemon()` store and expose the correct reference. Add a concurrency test that calls the setters from multiple threads while `run()` is active (using a short `sleepTime`) and verifies no `NullPointerException` or stale-value exposure occurs. Consider making the `outgoingDaemon` and `outgoingResnderDaemon` reads in `run()` also `synchronized`.

---

## A42-5 — DeniedPrefixesManager: denied-prefix enforcement is completely untested

**Severity:** HIGH
**File:** src/gmtp/configuration/DeniedPrefixesManager.java
**Description:** `DeniedPrefixesManager` is a security control: it populates the `GMTPRouter.deniedPrefixes` map that `GMTPMessageHandler` consults to reject messages whose prefix is on the deny list. There are zero tests for this class. The following security-relevant scenarios are not covered: (1) a prefix that should be denied is correctly loaded and causes `containsValue()` to return true; (2) a prefix that is not in the file passes through; (3) an empty deny-prefix file results in an empty map rather than a null or a stale previous map; (4) a missing deny-prefix file (the `else` branch at line 83) — the map is left as-is, potentially retaining stale denied entries or remaining empty when it should not be; (5) a malformed XML file causing `serializer.read()` to throw; (6) `hasChanged()` returning the correct boolean when the file modification timestamp changes vs. stays the same.
**Fix:** Create `TestDeniedPrefixesManager`. Use a temporary directory with a controlled deny-prefix XML file. Test: (a) after `loadConfiguration()`, `GMTPRouter.deniedPrefixes` contains exactly the prefixes in the file; (b) a prefix in the file is denied (`containsValue()` returns true); (c) a prefix not in the file passes; (d) an empty file or file with zero entries results in an empty map; (e) a non-existent file leaves the map unchanged (document and test the intended behaviour explicitly); (f) a malformed file throws an expected exception; (g) `hasChanged()` returns false when the file has not been modified and true after it is touched.

---

## A42-6 — DeniedPrefixesManager: null prefix input to security check untested

**Severity:** MEDIUM
**File:** src/gmtp/configuration/DeniedPrefixesManager.java
**Description:** The security enforcement in `GMTPMessageHandler` calls `GMTPRouter.deniedPrefixes.containsValue(prefix)` where `prefix` is extracted from inbound message data. If `prefix` is null, `HashMap.containsValue(null)` will not throw but will match any null-valued entry in the map. There is no test verifying how a null prefix interacts with the deny-list, and there is no null guard in `DeniedPrefixesManager.loadConfiguration()` when building the map. The actual enforcement site is outside the three assigned files, but `DeniedPrefixesManager` owns the map population logic and no test exercises this path.
**Fix:** Add a test that loads a deny file containing a prefix entry and then queries `GMTPRouter.deniedPrefixes.containsValue(null)` to characterise and document the actual behaviour. If null should never be a valid prefix, add a null check in the map-population step in `loadConfiguration()` and a corresponding test that verifies null-valued entries are excluded.

---

## A42-7 — DeniedPrefixesManager: non-volatile static field race condition untested

**Severity:** HIGH
**File:** src/gmtp/configuration/DeniedPrefixesManager.java
**Description:** `GMTPRouter.deniedPrefixes` is declared `public static HashMap<Integer, String>` (GMTPRouter.java line 48) — it is neither `volatile` nor guarded by a `synchronized` block. `DeniedPrefixesManager.loadConfiguration()` assigns a completely new `HashMap` reference to this field from the background daemon thread (line 81). `GMTPMessageHandler` reads the field from I/O handler threads without any synchronisation. Under the Java Memory Model, handler threads are not guaranteed to see the updated reference or the updated map contents without a happens-before relationship. A handler thread may observe the old map, a partially-constructed map, or even a null reference (if the assignment is observed mid-write on a 32-bit JVM for a 64-bit reference). This is a data race with no test to detect it.
**Fix:** Declare `GMTPRouter.deniedPrefixes` as `volatile` to guarantee visibility of the reference assignment. Because `HashMap` is not thread-safe, either replace it with `ConcurrentHashMap` and update atomically, or wrap the assignment and all reads in `synchronized(GMTPRouter.class)` blocks. Write a concurrency test using `java.util.concurrent` primitives (e.g., `CountDownLatch`, multiple reader threads, one writer thread) that performs concurrent reads and writes and asserts no `NullPointerException`, no `ConcurrentModificationException`, and that all readers see the correct map after the write completes.

---

## A42-8 — DeniedPrefixesManager: reload race condition untested

**Severity:** MEDIUM
**File:** src/gmtp/configuration/DeniedPrefixesManager.java
**Description:** The `run()` loop calls `hasChanged()` and then `loadConfiguration()` as two separate, non-atomic steps (lines 54–58). Between the `hasChanged()` check and the `loadConfiguration()` call, the file could be modified again or deleted. There is no test verifying the behaviour when the file is removed or re-written between these two steps. An `Exception` from `loadConfiguration()` is swallowed by the catch at line 65 with only a log statement, leaving `GMTPRouter.deniedPrefixes` in whatever state it was before the failed reload, with no alert mechanism.
**Fix:** Add a test that simulates file deletion between `hasChanged()` and `loadConfiguration()` (using a test subclass or a dependency-injection seam on file access). Verify that: the exception is caught, the map retains its last-good state, and an appropriate error is logged. Additionally, consider adding an observable error counter or callback so that operations teams can be alerted when the reload repeatedly fails.

---

## Summary

| ID | Severity | Description |
|----|----------|-------------|
| A42-1 | HIGH | GMTPResponseEncoder.encode() is completely untested |
| A42-2 | MEDIUM | GMTPResponseEncoder.encodeMessageType() not verified for any type |
| A42-3 | HIGH | ConfigurationManager.loadConfiguration() is completely untested |
| A42-4 | MEDIUM | ConfigurationManager refresh interval and daemon setters untested |
| A42-5 | HIGH | DeniedPrefixesManager security enforcement completely untested |
| A42-6 | MEDIUM | Null prefix input to deny-list lookup untested |
| A42-7 | HIGH | Non-volatile static field GMTPRouter.deniedPrefixes race condition untested |
| A42-8 | MEDIUM | DeniedPrefixesManager reload race condition untested |
