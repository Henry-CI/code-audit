# Pass 2: Test Coverage — A48
**Agent:** A48
**Branch verified:** master (confirmed via .git/HEAD: `ref: refs/heads/master`)
**Files reviewed:**
- src/gmtp/outgoing/OutgoingMessageSender.java
- src/gmtp/telnet/TelnetMessageHandler.java
- src/gmtp/telnet/TelnetMessageStatus.java

**Test file read:** test/TestDataMessageHandler.java

---

## Reading Evidence

### OutgoingMessageSender.java

**Class name:** `OutgoingMessageSender` (extends `Thread`)
**Package:** `gmtp.outgoing`

**Fields and constants:**

| Name | Type | Line |
|------|------|------|
| `outgoingMessages` | `ConcurrentHashMap<String, LinkedHashMap<Long, OutgoingMessage>>` | 23 |
| `tempMessages` | `ConcurrentHashMap<String, LinkedHashMap<Long, OutgoingMessage>>` | 24 |
| `acceptor` | `final IoAcceptor` | 25 |
| `sessions` | `Map<Long, IoSession>` | 26 |
| `DELAY` | `static long` (value: 30000) | 27 |
| `logger` | `static org.slf4j.Logger` | 28 |
| `instance` | `static OutgoingMessageSender` | 29 |
| `lock` | `boolean` | 30 |

**Methods and constructors:**

| Name | Visibility | Line |
|------|------------|------|
| `getInstance()` | public static | 32 |
| `getInstance(IoAcceptor acceptor)` | public static | 39 |
| `getInstance(IoAcceptor acceptor, int delay)` | public static | 46 |
| `OutgoingMessageSender(IoAcceptor acceptor)` constructor | private | 53 |
| `OutgoingMessageSender(IoAcceptor acceptor, int delay)` constructor | private | 62 |
| `setDelay(int outgoingDelay)` | static (package-private) | 71 |
| `run()` | public (override) | 76 |
| `pause(Integer time)` | private | 105 |
| `sendNextMessage(IoSession session)` | private | 113 |
| `send(IoSession session)` | private | 142 |
| `add(OutgoingMessage msg)` | public | 170 |
| `clearCache(String gmtp_id)` | private | 190 |
| `clearBuffer(String gmtp_id)` | private | 196 |
| `removeFromQueue(OutgoingMessage msg)` | private | 202 |
| `fillQueue()` | private | 217 |
| `clearOutgoingQueue(String gmtp_id)` | public | 236 |
| `getCount()` | public | 243 |

---

### TelnetMessageHandler.java

**Class name:** `TelnetMessageHandler` (extends `IoHandlerAdapter`, package-private)
**Package:** `gmtp.telnet`

**Fields and constants:**

| Name | Type | Line |
|------|------|------|
| `logger` | `static Logger` | 27 |
| `gmtpIoAcceptor` | `IoAcceptor` | 28 |
| `STATUS` | `String` (value: "STATUS") | 29 |
| `USERNAME` | `String` (value: "USERNAME") | 30 |
| `TRY` | `String` (value: "TRY") | 31 |
| `username` | `final String` | 32 |
| `password` | `final String` | 33 |

**Methods and constructors:**

| Name | Visibility | Line |
|------|------------|------|
| `TelnetMessageHandler(IoAcceptor, String, String)` constructor | public | 35 |
| `exceptionCaught(IoSession, Throwable)` | public (override) | 45 |
| `sessionCreated(IoSession)` | public (override) | 50 |
| `sessionClosed(IoSession)` | public (override) | 59 |
| `messageReceived(IoSession, Object)` | public (override) | 64 |
| `checkAuthentification(String, String)` | private | 116 |
| `processTelnetMessage(String, IoSession, String)` | private | 124 |

**Commands handled in `processTelnetMessage` (via `TelnetMessagecommand` enum):**
QUIT, LIST, FIND, HELP, STATUS, SEND, BROADCAST, KILL, KILLALL

---

### TelnetMessageStatus.java

**Class name:** `TelnetMessageStatus`
**Package:** `gmtp.telnet`

**Fields and constants:**

| Name | Type | Line |
|------|------|------|
| `LOGIN` | `public static final int` (value: 0) | 13 |
| `PASSWORD` | `public static final int` (value: 1) | 14 |
| `LOGGED_IN` | `public static final int` (value: 2) | 15 |
| `num` | `private final int` | 16 |

**Methods and constructors:**

| Name | Visibility | Line |
|------|------------|------|
| `TelnetMessageStatus(int num)` constructor | private | 18 |
| `toInt()` | public | 22 |
| `valueOf(String s)` | public static | 26 |

---

## Grep Results (test/ directory)

Search for class names `OutgoingMessageSender`, `TelnetMessageHandler`, `TelnetMessageStatus`: **No matches found.**

Search for public method names from all three classes across the test directory: **No matches found** (the only hits were `DataMessageHandler.sendAuthResponse` calls unrelated to the three reviewed files).

The sole test file is `test/TestDataMessageHandler.java`, which contains one test method (`testSendAuthResponse`) covering `DataMessageHandler` only.

---

## Findings

## A48-1 — OutgoingMessageSender has no test coverage whatsoever

**Severity:** HIGH
**File:** src/gmtp/outgoing/OutgoingMessageSender.java
**Description:** The class `OutgoingMessageSender` — a singleton background thread responsible for dispatching all outgoing GMTP messages to connected IoSessions — has zero test coverage. No test file references the class or any of its methods. The following critical behaviours are completely untested: (1) `getInstance()` throwing when the daemon has not been started; (2) `getInstance(IoAcceptor)` and `getInstance(IoAcceptor, int)` correctly enforcing singleton semantics; (3) `add()` silently dropping messages when `lock == true`; (4) `fillQueue()` copying from `tempMessages` to `outgoingMessages` under the boolean lock; (5) `sendNextMessage()` and `send()` dispatching to the correct IoSession, including the early-return when `gmtp_id` is null or when the session is disconnected; (6) `clearOutgoingQueue()` and `getCount()` returning accurate state; (7) the `run()` loop behaviour, including what happens during `InterruptedException`. The `lock` field is a plain (non-volatile, non-atomic) boolean used across threads, which itself is a concurrency defect that tests would surface.
**Fix:** Write JUnit tests (with Mockito or a test-double IoAcceptor and IoSession) covering: singleton creation and the exception path; `add()` under both locked and unlocked states; `fillQueue()` copying semantics; `sendNextMessage()` with connected and disconnected sessions; `getCount()` before and after adds; and `clearOutgoingQueue()` removing the correct unit's buffer. Use `setDelay()` to configure a very short delay so the `run()` loop can be exercised without long sleeps.

---

## A48-2 — TelnetMessageHandler has no test coverage — authentication logic untested

**Severity:** HIGH
**File:** src/gmtp/telnet/TelnetMessageHandler.java
**Description:** The class `TelnetMessageHandler` is the management interface for the GMTP server and handles authentication followed by privileged administrative commands. It has zero test coverage. The authentication flow in `messageReceived()` is untested across all cases: (1) correct username and password granting LOGGED_IN status; (2) wrong password cycling back to LOGIN with a counter increment; (3) three failed attempts triggering `session.close(true)` and denying further access; (4) empty or null-derived username/password strings; (5) the `default` branch of the status switch writing "Invalid request status" and closing the session. Because the retry counter (`TRY`) is stored as a session attribute starting at `Integer` 0 and compared with `< 3`, an off-by-one or type-cast error could allow more than three attempts — this is not guarded by any test.
**Fix:** Write JUnit tests using mock IoSession objects (Mockito). Test cases must include: successful authentication transitions (LOGIN -> PASSWORD -> LOGGED_IN); failed password increments TRY counter and returns to LOGIN; third failure closes the session; correct username with wrong password is rejected; wrong username with correct password is rejected; empty string credentials are rejected; unexpected status value hits the default branch.

---

## A48-3 — TelnetMessageHandler command dispatch is entirely untested — command injection risk

**Severity:** HIGH
**File:** src/gmtp/telnet/TelnetMessageHandler.java
**Description:** The `processTelnetMessage()` method dispatches on `TelnetMessagecommand.valueOf(command)` where `command` is the raw first token of the telnet input string. If `valueOf()` throws (e.g., for an unrecognised command), the exception is caught in `messageReceived()` and written back to the session as `"Invalid command: " + e`, leaking internal exception detail to the telnet client. None of the nine commands (QUIT, LIST, FIND, HELP, STATUS, SEND, BROADCAST, KILL, KILLALL) are tested. Specific untested security-relevant paths include: (1) SEND writing an arbitrary `OutgoingMessage` to any connected GMTP unit based solely on a caller-supplied `gmtp_id` string — no authorisation check beyond the telnet password; (2) BROADCAST sending caller-controlled content to every connected unit; (3) KILL and KILLALL forcibly closing sessions, enabling denial-of-service from any authenticated telnet user; (4) the unknown-command path revealing exception detail.
**Fix:** Write JUnit/integration tests for every command branch. For SEND and BROADCAST, verify that the message content and target are correctly validated. For the unknown-command path, assert that only a safe, non-revealing error message is returned. For KILL/KILLALL, assert that the correct sessions are closed. Consider replacing raw exception string concatenation (`"Invalid command: " + e`) with a fixed error message to prevent information leakage.

---

## A48-4 — TelnetMessageStatus has no test coverage

**Severity:** MEDIUM
**File:** src/gmtp/telnet/TelnetMessageStatus.java
**Description:** `TelnetMessageStatus` is used directly by `TelnetMessageHandler` to drive the authentication state machine; its integer constants (`LOGIN=0`, `PASSWORD=1`, `LOGGED_IN=2`) are used in `switch` comparisons in `messageReceived()`. The class has no test coverage. The `valueOf(String)` factory method silently upper-cases input and throws `IllegalArgumentException` for unrecognised strings; this exception path is not tested. If `valueOf()` were called with an unrecognised status string in some future code path it would propagate uncaught, and there is currently no guard. Additionally, the `toInt()` method and the three constants are untested, meaning any accidental change to their values would not be detected.
**Fix:** Write JUnit tests covering: `valueOf("LOGIN")`, `valueOf("PASSWORD")`, `valueOf("LOGGED_IN")` (case-insensitive variants); `toInt()` returning the correct integer for each constructed instance; `valueOf()` throwing `IllegalArgumentException` for an invalid input; and assertions that the integer constant values match the expected integers (0, 1, 2).

---

## A48-5 — No negative authentication tests — brute-force / lockout boundary untested

**Severity:** HIGH
**File:** src/gmtp/telnet/TelnetMessageHandler.java
**Description:** The authentication lockout logic compares `(Integer) session.getAttribute(TRY) < 3`, meaning three failed password attempts (TRY values 0, 1, 2) are permitted before the session is closed on the fourth attempt. There are no tests that exercise this boundary, so it is impossible to verify whether the lockout fires after exactly 3 bad attempts or at some other count. Additionally, there is no test for: submitting an empty password string, submitting a password of only whitespace, or verifying that a session closed due to too many attempts cannot be re-used. The lack of a rate-limit or account lockout mechanism beyond the in-session counter is also undocumented and untested.
**Fix:** Add parameterised tests that submit 1, 2, 3, and 4 incorrect passwords and assert on whether the session remains open or is closed at each step. Test that exactly 3 failed attempts (not 2, not 4) trigger the close. Add a test that an empty string password is not accepted even if the configured password is also empty.

---

## A48-6 — No test for telnet command execution error paths (exception leakage)

**Severity:** MEDIUM
**File:** src/gmtp/telnet/TelnetMessageHandler.java
**Description:** In `messageReceived()` at line 102-104, any exception thrown by `processTelnetMessage()` is caught and written back verbatim to the session as `"Invalid command: " + e`. This means internal exception messages, stack-trace summaries, or class names from the server's runtime are sent to the telnet client. This is an information-disclosure risk. There is no test asserting that this path produces a safe, sanitised response rather than revealing internal details. In particular, `TelnetMessagecommand.valueOf()` will throw a `java.lang.IllegalArgumentException` with the message "No enum constant gmtp.telnet.TelnetMessagecommand.[input]", which includes the package path of the server and the raw user input reflected back.
**Fix:** Add a test that sends an unrecognised command string to a LOGGED_IN session and asserts that the response does not contain internal package names or exception class names. Separately, fix the production code to replace `"Invalid command: " + e` with a fixed safe string such as `"Unknown command"` and log the exception server-side only.

---

## Summary

| ID | Severity | Description |
|----|----------|-------------|
| A48-1 | HIGH | OutgoingMessageSender has no test coverage whatsoever |
| A48-2 | HIGH | TelnetMessageHandler authentication logic is entirely untested |
| A48-3 | HIGH | TelnetMessageHandler command dispatch is entirely untested — command injection risk |
| A48-4 | MEDIUM | TelnetMessageStatus has no test coverage |
| A48-5 | HIGH | No negative authentication tests — brute-force / lockout boundary untested |
| A48-6 | MEDIUM | No test for telnet command execution error paths (exception leakage) |
