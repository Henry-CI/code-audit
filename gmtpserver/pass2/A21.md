# Pass 2: Test Coverage — A21
**Agent:** A21
**Branch verified:** master
**Files reviewed:** src/codec/GMTPCodecFactory.java, src/codec/GMTPRequestDecoder.java, src/codec/GMTPResponseEncoder.java
**Test file read:** test/TestDataMessageHandler.java

---

## Reading Evidence

### GMTPCodecFactory.java

**Class name:** `codec.GMTPCodecFactory` (implements `org.apache.mina.filter.codec.ProtocolCodecFactory`)

**Constructors and methods (with line numbers):**

| Name | Line |
|------|------|
| `GMTPCodecFactory(boolean client)` — constructor | 22 |
| `GMTPCodecFactory(boolean client, HashMap<String, String> routingMap)` — constructor | 32 |
| `getEncoder(IoSession ioSession)` — public | 42 |
| `getDecoder(IoSession ioSession)` — public | 46 |

**Fields:**

| Name | Type | Line |
|------|------|------|
| `encoder` | `ProtocolEncoder` (private) | 19 |
| `decoder` | `ProtocolDecoder` (private) | 20 |

**Inner types / constants:** None.

**Notable logic:**
- When `client == true`, both `encoder` and `decoder` are set to `null`.
- When `client == false`, `encoder` is set to a new `GMTPResponseEncoder` and `decoder` to a new `GMTPRequestDecoder` (optionally with a `routingMap`).
- `getEncoder` and `getDecoder` return the fields directly, meaning a client-mode factory will return `null` from both methods, which could cause a NullPointerException in callers.

---

### GMTPRequestDecoder.java

**Class name:** `codec.GMTPRequestDecoder` (extends `org.apache.mina.filter.codec.CumulativeProtocolDecoder`)

**Constructors and methods (with line numbers):**

| Name | Line |
|------|------|
| `GMTPRequestDecoder(HashMap<String, String> routingMap)` — constructor (public) | 40 |
| `GMTPRequestDecoder()` — constructor (public) | 44 |
| `doDecode(IoSession session, IoBuffer in, ProtocolDecoderOutput out)` — protected, @Override | 48 |
| `decodeMessageType(int type)` — private | 111 |

**Constants (private static final short):**

| Name | Value |
|------|-------|
| `PDU_ID` | 0x0001 |
| `PDU_DATA` | 0x0002 |
| `PDU_ID_EXT` | 0x0003 |
| `PDU_DATA_EXT` | 0x0004 |
| `PDU_ACK` | 0x0005 |
| `PDU_ERROR` | 0x0006 |
| `PDU_CLOSED` | 0x0007 (unused, suppressed) |
| `PDU_PROTO_VER` | 0x0008 |
| `PDU_BEGIN_TRANSACTION` | 0x0009 |
| `PDU_END_TRANSACTION` | 0x000A |
| `PDU_NAK` | 0x000D |

**Fields:**

| Name | Type | Line |
|------|------|------|
| `logger` | `Logger` (private static) | 37 |
| `routingMap` | `HashMap<String, String>` (private) | 38 |

**Inner types:** None.

**Notable logic in `doDecode`:**
- Returns `false` (need more data) when `remaining < 4`.
- Reads 2-byte type then calls `decodeMessageType`.
- For extended types (`ID_EXT`, `DATA_EXT`, `ACK`): reads a 2-byte `dataId`, then 2-byte `dataLen`, then string.
- For standard types: reads 2-byte `dataLen`, then string.
- Uses `in.getString(in.remaining(), decoder)` — consumes ALL remaining bytes, not exactly `dataLen` bytes. This is a correctness bug regardless of test coverage.
- Resets position to `start` and returns `false` if insufficient data after the header.
- `decodeMessageType` maps `PDU_BEGIN_TRANSACTION` (0x0009) and `PDU_NAK` (0x000D) to no case — both fall through to the `default` branch and return `Type.ERROR`.

---

### GMTPResponseEncoder.java

**Class name:** `codec.GMTPResponseEncoder` (package-private; extends `org.apache.mina.filter.codec.ProtocolEncoderAdapter`)

**Constructors and methods (with line numbers):**

| Name | Line |
|------|------|
| (implicit no-arg constructor) | — |
| `encode(IoSession session, Object message, ProtocolEncoderOutput out)` — public | 37 |
| `encodeMessageType(Type type)` — private | 60 |

**Constants (private static final short):**

| Name | Value |
|------|-------|
| `PDU_ID` | 0x0001 |
| `PDU_DATA` | 0x0002 |
| `PDU_ID_EXT` | 0x0003 |
| `PDU_DATA_EXT` | 0x0004 |
| `PDU_ACK` | 0x0005 |
| `PDU_ERROR` | 0x0006 |
| `PDU_CLOSED` | 0x0007 (unused, suppressed) |
| `PDU_PROTO_VER` | 0x0008 |
| `PDU_BEGIN_TRANSACTION` | 0x0009 |
| `PDU_END_TRANSACTION` | 0x000A |
| `PDU_NAK` | 0x000D |

**Fields:**

| Name | Type | Line |
|------|------|------|
| `logger` | `Logger` (private static) | 35 |

**Inner types:** None.

**Notable logic in `encode`:**
- Casts `message` to `GMTPMessage` without instanceof guard — ClassCastException on wrong type.
- Retrieves `"extVersion"` session attribute; calls `equalsIgnoreCase("1")` on it directly — NullPointerException if the attribute is absent.
- Fixed `IoBuffer` capacity of 256 bytes with `autoExpand(false)` — `BufferOverflowException` for messages longer than ~250 bytes.
- `encodeMessageType` throws `IllegalArgumentException` for unrecognised types (e.g., `PROTOCOL_VERSION`, `END_TRANSACTION`, `BEGIN_TRANSACTION`).

---

## Findings

## A21-1 — GMTPCodecFactory: no tests whatsoever

**Severity:** HIGH
**File:** src/codec/GMTPCodecFactory.java
**Description:** There is exactly one test file in the entire test directory (`TestDataMessageHandler.java`) and it tests `DataMessageHandler.sendAuthResponse` only. `GMTPCodecFactory` is never imported, instantiated, or mentioned in any test. Both constructors and both public methods (`getEncoder`, `getDecoder`) are completely untested. The client-mode code path explicitly sets both encoder and decoder to `null` and then returns them from `getEncoder`/`getDecoder`. Any caller relying on the non-null contract of the `ProtocolCodecFactory` interface will receive a NullPointerException at runtime; this path has never been exercised by a test.
**Fix:** Create `TestGMTPCodecFactory` covering: (1) server-mode constructor instantiates a non-null encoder and decoder; (2) client-mode constructor instantiates null encoder and decoder and callers handle this gracefully (or document/fix the null-return contract); (3) the overloaded constructor with a `routingMap` passes the map through to the decoder; (4) `getEncoder`/`getDecoder` return the expected instances.

---

## A21-2 — GMTPRequestDecoder: no tests whatsoever

**Severity:** HIGH
**File:** src/codec/GMTPRequestDecoder.java
**Description:** `GMTPRequestDecoder` and its `doDecode` method are never referenced in any test. This is the primary inbound protocol parser for the server. Untested paths include: (a) every PDU type branch (ID, DATA, ID_EXT, DATA_EXT, ACK, ERROR, PROTOCOL_VERSION, END_TRANSACTION); (b) the `remaining < 4` early-return path; (c) the case where the header is present but payload data has not yet arrived (cumulative decode short-circuit); (d) the extended-packet path that reads a dataId before the length; (e) the standard-packet path; (f) any unknown PDU type code, which silently maps to `Type.ERROR`; (g) `PDU_BEGIN_TRANSACTION` (0x0009) and `PDU_NAK` (0x000D), which have no case in `decodeMessageType` and silently become `Type.ERROR`. Additionally, `in.getString(in.remaining(), decoder)` consumes all remaining buffer bytes rather than exactly `dataLen` bytes, meaning that in a cumulative-decode scenario with back-to-back PDUs, subsequent messages will be lost. This bug cannot be caught without a test.
**Fix:** Create `TestGMTPRequestDecoder` with an in-memory `IoBuffer` harness. Cover: each PDU type; fragmented delivery (header arrives, payload arrives in next call); back-to-back PDUs in one buffer (exposes the `remaining()` vs `dataLen` bug); zero-length payload; maximum-length payload (65535 bytes); unknown type code; `BEGIN_TRANSACTION` and `NAK` type codes; both constructors (with and without routingMap).

---

## A21-3 — GMTPResponseEncoder: no tests whatsoever

**Severity:** HIGH
**File:** src/codec/GMTPResponseEncoder.java
**Description:** `GMTPResponseEncoder` and its `encode` method are never referenced in any test. Untested paths include: (a) encoding each supported message type (ID, DATA, ID_EXT, DATA_EXT, ACK, NAK, ERROR); (b) the extended-version branch (`extVersion == "1"` writes `dataId`; any other value omits it); (c) `extVersion` session attribute absent — `session.getAttribute("extVersion")` returns `null`, and `null.equalsIgnoreCase("1")` throws `NullPointerException`; (d) message body exceeding the fixed 256-byte buffer with `autoExpand(false)` — throws `BufferOverflowException` silently dropping or corrupting the outbound frame; (e) an unsupported `Type` (e.g., `PROTOCOL_VERSION`, `END_TRANSACTION`) reaching `encodeMessageType` and throwing `IllegalArgumentException`; (f) `message` argument not being a `GMTPMessage` (ClassCastException).
**Fix:** Create `TestGMTPResponseEncoder` using a mock `IoSession` that supplies the `extVersion` attribute and a capturing `ProtocolEncoderOutput`. Cover: each message type in both standard and extended framing; absent/null `extVersion`; a payload of exactly 256 bytes and one of 257 bytes; an unsupported type; a non-GMTPMessage input.

---

## A21-4 — GMTPRequestDecoder: `doDecode` reads `in.remaining()` bytes instead of `dataLen` bytes

**Severity:** HIGH
**File:** src/codec/GMTPRequestDecoder.java
**Description:** On lines 80 and 96, `in.getString(in.remaining(), decoder)` consumes every remaining byte in the buffer, not the `dataLen` bytes declared in the PDU header. In a session where two PDUs arrive in the same TCP segment the second PDU's bytes are silently consumed as payload of the first message and the second `GMTPMessage` is never produced. This framing error is a security-relevant correctness bug: an attacker can craft input that causes the server to misparse subsequent messages. The bug is undetected because there are no decoder tests at all.
**Fix:** Replace `in.getString(in.remaining(), decoder)` with `in.getString(dataLen, decoder)` on both lines. Add regression tests that submit two back-to-back valid PDUs in a single `IoBuffer` and assert that `doDecode` emits two distinct `GMTPMessage` objects.

---

## A21-5 — GMTPResponseEncoder: NullPointerException when `extVersion` session attribute is absent

**Severity:** HIGH
**File:** src/codec/GMTPResponseEncoder.java
**Description:** Line 42 reads `(String) session.getAttribute("extVersion")` and line 50 immediately calls `.equalsIgnoreCase("1")` on the result without a null check. If the `extVersion` attribute has not been set on a session (e.g., during initial handshake, or if a client connects without completing protocol negotiation) the JVM throws a `NullPointerException` inside the MINA pipeline, which will close the session unexpectedly. This is an untested crash path.
**Fix:** Guard the attribute use: `if (extVersion != null && extVersion.equalsIgnoreCase("1"))`. Add a test that exercises `encode` with a session that has no `extVersion` attribute.

---

## A21-6 — GMTPResponseEncoder: fixed 256-byte buffer with autoExpand disabled causes BufferOverflowException

**Severity:** MEDIUM
**File:** src/codec/GMTPResponseEncoder.java
**Description:** Lines 45–47 allocate an `IoBuffer` of exactly 256 bytes and disable both `autoExpand` and `autoShrink`. The header consumes 4 bytes (type + length) or 6 bytes (type + dataId + length) in extended mode, leaving at most 250–252 bytes for the message body. Any `GMTPMessage` with a payload longer than this limit will throw a `BufferOverflowException` at line 54 (`buffer.put(gmtpMsg.getMessage().getBytes())`). The `length` field (line 41) is computed as a `short` from `getMessage().length()`, which also silently truncates any string longer than 32767 characters. Neither condition is tested.
**Fix:** Either enable `setAutoExpand(true)` or pre-compute the required buffer size from the actual message length. Add tests for payloads of length 0, 250, 251, 252, and 1000 bytes to verify correct framing and absence of buffer exceptions.

---

## A21-7 — GMTPRequestDecoder: `PDU_BEGIN_TRANSACTION` and `PDU_NAK` silently map to `Type.ERROR`

**Severity:** MEDIUM
**File:** src/codec/GMTPRequestDecoder.java
**Description:** The `decodeMessageType` switch on lines 114–133 has no cases for `PDU_BEGIN_TRANSACTION` (0x0009) or `PDU_NAK` (0x000D). Both fall through to `default: return Type.ERROR`. The corresponding constants are defined (lines 35–36) and `PDU_NAK` is actively used in `GMTPResponseEncoder`, indicating these PDU types are part of the protocol. Any inbound `BEGIN_TRANSACTION` or `NAK` PDU will be silently mis-typed as an error, producing incorrect application behaviour with no log warning. There are no tests that send these PDU type codes.
**Fix:** Add explicit `case PDU_BEGIN_TRANSACTION: return Type.BEGIN_TRANSACTION;` and `case PDU_NAK: return Type.NAK;` (or log and return a sentinel error type if these should never arrive inbound). Add unit tests for each PDU type code, including these two.

---

## A21-8 — GMTPCodecFactory: client-mode returns null encoder and decoder

**Severity:** MEDIUM
**File:** src/codec/GMTPCodecFactory.java
**Description:** When `GMTPCodecFactory` is constructed with `client == true` (lines 23–25), both `encoder` and `decoder` are set to `null`. `getEncoder` and `getDecoder` return those nulls. The `ProtocolCodecFactory` contract does not document null as a valid return value, and MINA's pipeline will dereference the return value, causing a `NullPointerException`. Even if client mode is intentionally unsupported, the silent null assignment is dangerous; there is no guard, no `UnsupportedOperationException`, and no test to document or verify the expected behaviour.
**Fix:** If client mode is genuinely unsupported, throw `UnsupportedOperationException` from both getters when constructed in client mode. If it is supported in the future, implement it. Add tests for both modes.

---

## Summary

| ID | Severity | Description |
|----|----------|-------------|
| A21-1 | HIGH | `GMTPCodecFactory` has zero test coverage across all constructors and methods |
| A21-2 | HIGH | `GMTPRequestDecoder` has zero test coverage; all decode paths are untested |
| A21-3 | HIGH | `GMTPResponseEncoder` has zero test coverage; all encode paths are untested |
| A21-4 | HIGH | `doDecode` reads `in.remaining()` instead of `dataLen` bytes, breaking multi-PDU streams |
| A21-5 | HIGH | `encode` throws `NullPointerException` when `extVersion` session attribute is absent |
| A21-6 | MEDIUM | Fixed 256-byte non-expanding buffer causes `BufferOverflowException` on large payloads |
| A21-7 | MEDIUM | `BEGIN_TRANSACTION` and `NAK` PDU types silently decoded as `ERROR` |
| A21-8 | MEDIUM | Client-mode factory silently returns null encoder/decoder, breaking MINA pipeline |
