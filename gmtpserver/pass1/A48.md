# Security Audit Pass 1 — Agent A48

**Date:** 2026-02-28
**Branch:** master (confirmed via `git rev-parse --abbrev-ref HEAD`)
**Assigned files:**
- `src/gmtp/outgoing/OutgoingMessageSender.java`
- `src/gmtp/telnet/TelnetMessageHandler.java`
- `src/gmtp/telnet/TelnetMessageStatus.java`

---

## Reading Evidence

### File 1: `src/gmtp/outgoing/OutgoingMessageSender.java`

**Fully qualified class name:** `gmtp.outgoing.OutgoingMessageSender`

**Extends / Implements:** `java.lang.Thread`

**Imports:**
- `java.util.LinkedHashMap`
- `java.util.Map`
- `java.util.Map.Entry`
- `java.util.concurrent.ConcurrentHashMap`
- `java.util.logging.Level`
- `java.util.logging.Logger`
- `org.apache.mina.core.service.IoAcceptor`
- `org.apache.mina.core.session.IoSession`
- `org.slf4j.LoggerFactory`

**Fields:**
| Modifier | Type | Name | Line |
|---|---|---|---|
| private | `ConcurrentHashMap<String, LinkedHashMap<Long, OutgoingMessage>>` | `outgoingMessages` | 23 |
| private | `ConcurrentHashMap<String, LinkedHashMap<Long, OutgoingMessage>>` | `tempMessages` | 24 |
| private final | `IoAcceptor` | `acceptor` | 25 |
| private | `Map<Long, IoSession>` | `sessions` | 26 |
| private static | `long` | `DELAY` | 27 |
| private static | `org.slf4j.Logger` | `logger` | 28 |
| private static | `OutgoingMessageSender` | `instance` | 29 |
| private | `boolean` | `lock` | 30 |

**Public methods:**
| Return type | Name | Parameters | Line |
|---|---|---|---|
| `static OutgoingMessageSender` | `getInstance` | `()` | 32 |
| `static OutgoingMessageSender` | `getInstance` | `(IoAcceptor acceptor)` | 39 |
| `static OutgoingMessageSender` | `getInstance` | `(IoAcceptor acceptor, int delay)` | 46 |
| `void` | `run` | `()` | 76 |
| `void` | `add` | `(OutgoingMessage msg)` | 170 |
| `void` | `clearOutgoingQueue` | `(String gmtp_id)` | 236 |
| `int` | `getCount` | `()` | 243 |

---

### File 2: `src/gmtp/telnet/TelnetMessageHandler.java`

**Fully qualified class name:** `gmtp.telnet.TelnetMessageHandler`

**Extends / Implements:** `org.apache.mina.core.service.IoHandlerAdapter`

**Imports:**
- `gmtp.GMTPMessage.Type`
- `gmtp.GMTPRouter`
- `gmtp.outgoing.OutgoingMessage`
- `gmtp.outgoing.OutgoingMessageSender`
- `java.util.Map`
- `java.util.Map.Entry`
- `java.util.logging.Level`
- `org.apache.mina.core.service.IoAcceptor`
- `org.apache.mina.core.service.IoHandlerAdapter`
- `org.apache.mina.core.service.IoServiceStatistics`
- `org.apache.mina.core.session.IoSession`
- `org.slf4j.Logger`
- `org.slf4j.LoggerFactory`

**Fields:**
| Modifier | Type | Name | Line |
|---|---|---|---|
| private static | `Logger` | `logger` | 27 |
| private | `IoAcceptor` | `gmtpIoAcceptor` | 28 |
| private | `String` | `STATUS` | 29 |
| private | `String` | `USERNAME` | 30 |
| private | `String` | `TRY` | 31 |
| private final | `String` | `username` | 32 |
| private final | `String` | `password` | 33 |

**Public methods:**
| Return type | Name | Parameters | Line |
|---|---|---|---|
| `TelnetMessageHandler` | (constructor) | `(IoAcceptor gmtpIoAcceptor, String username, String password)` | 35 |
| `void` | `exceptionCaught` | `(IoSession session, Throwable cause)` | 45 |
| `void` | `sessionCreated` | `(IoSession session)` | 50 |
| `void` | `sessionClosed` | `(IoSession session)` | 59 |
| `void` | `messageReceived` | `(IoSession session, Object message)` | 64 |

---

### File 3: `src/gmtp/telnet/TelnetMessageStatus.java`

**Fully qualified class name:** `gmtp.telnet.TelnetMessageStatus`

**Extends / Implements:** None

**Imports:** None

**Fields:**
| Modifier | Type | Name | Line |
|---|---|---|---|
| public static final | `int` | `LOGIN` | 13 |
| public static final | `int` | `PASSWORD` | 14 |
| public static final | `int` | `LOGGED_IN` | 15 |
| private final | `int` | `num` | 16 |

**Public methods:**
| Return type | Name | Parameters | Line |
|---|---|---|---|
| `TelnetMessageStatus` | (constructor) | `(int num)` — private | 18 |
| `int` | `toInt` | `()` | 22 |
| `static TelnetMessageStatus` | `valueOf` | `(String s)` | 26 |

---

## Checklist Results

### Telnet Interface Security

**Authentication before accepting commands:**
Authentication IS implemented via a state machine (`LOGIN` -> `PASSWORD` -> `LOGGED_IN`). Commands are gated behind `TelnetMessageStatus.LOGGED_IN`. No bypass was found in the state machine itself. PASS — but see Finding A48-1 for brute-force concern.

**Commands available — can an unauthenticated user modify server state?**
All destructive commands (`KILL`, `KILLALL`, `SEND`, `BROADCAST`) are behind authentication. PASS for command gating.

**Binding address — 0.0.0.0 vs localhost:**
`TelnetServer.java` line 49: `acceptor.bind(new InetSocketAddress(this.port))`. `InetSocketAddress(port)` with no host argument binds to `0.0.0.0` (all interfaces), exposing the Telnet interface to all network interfaces. FINDING — see A48-2.

**Command injection in Telnet command parsing:**
Command parsing uses `command.split(" ", 2)` then `TelnetMessagecommand.valueOf(cmd)`. The `valueOf` method only accepts known string literals and throws `IllegalArgumentException` for anything else. No `Runtime.exec()` or `ProcessBuilder` is involved. No classical command injection found. PASS.

However, the `SEND` and `BROADCAST` commands relay arbitrary user-supplied text directly to GMTP client sessions without any sanitisation. This is a content injection / protocol injection risk. See A48-3.

**Information disclosure:**
`STATUS` command (line 171-189) exposes session counts, throughput statistics, and outgoing queue depth over Telnet. This is operational information that should be behind authentication, which it is — gated by `LOGGED_IN`. PASS for auth gating, though information is sensitive.

**Server shutdown / reconfiguration via Telnet:**
`KILLALL` (line 255-268) closes every managed GMTP session. `KILL` (line 235-253) closes a named session. These are available to any authenticated Telnet user. This is significant operational risk but is behind authentication. Documented separately as A48-4 due to the broad destructive scope.

**Brute-force protection:**
Only 3 attempts are allowed (`TRY < 3`) before the session is closed. However, there is no rate limiting, IP banning, or lockout delay, so an attacker can reconnect immediately after being closed and try 3 more passwords. See A48-1.

### Outgoing Message Sender Security

**SSRF — destination host/port influenced by untrusted input:**
`OutgoingMessageSender` does not open outbound TCP sockets itself. It writes to existing `IoSession` objects that are already connected clients managed by Apache MINA's `IoAcceptor`. The sessions are established inbound, not outbound. No SSRF vector identified. PASS.

**Resource leaks — sockets/streams not closed on error paths:**
The class uses MINA `IoSession.write()` which is non-blocking and managed by MINA's I/O layer. No raw `Socket`, `InputStream`, or `OutputStream` is opened directly. No resource leak in the traditional sense. PASS.

**Connection timeout — can an outgoing connection hang indefinitely:**
Not applicable — no outbound connections are established by this class. PASS.

**Unbounded retry loops:**
`run()` (line 76) is `while(true)` with a `sleep(DELAY)` of 30 000 ms between iterations. This is a bounded polling loop with a fixed delay and is not an unbounded spin. PASS.

**Non-thread-safe singleton initialisation:**
The three `getInstance` overloads (lines 32, 39, 46) perform a check-then-act pattern without synchronisation: `if (instance == null) { instance = new ... }`. Under concurrent initialisation two threads could both observe `instance == null` and create two instances. See A48-5.

**Non-volatile / non-atomic `lock` field used for synchronisation:**
`lock` (line 30) is a plain `boolean` field used to coordinate between `add()` (which checks `lock`) and `fillQueue()` (which sets `lock = true` then `lock = false`). Because `lock` is not `volatile` and there is no `synchronized` block, changes made in `fillQueue()` (running in the sender thread) are not guaranteed to be visible to the thread calling `add()`. See A48-6.

### Error Handling

**Swallowed exceptions:**
- `OutgoingMessageSender.run()` line 80-82: `InterruptedException` is caught and logged, but the thread continues running without re-interrupting itself. This suppresses the interrupt signal and means the thread cannot be cleanly shut down. See A48-7.
- `TelnetMessageHandler.messageReceived()` lines 102-104: catches `Exception e` and writes the raw exception message to the Telnet session (`session.write("Invalid command: " + e)`). This leaks internal exception details to the connected user. See A48-8.

**Errors in Telnet handler crashing the main server:**
`exceptionCaught()` (line 45-47) in `TelnetMessageHandler` logs the error and does not rethrow. MINA's IoHandlerAdapter isolates session exceptions from the server process. PASS.

**Connection errors logged appropriately:**
Session exception logging is present in `exceptionCaught`. PASS.

### General Java Security

**Command injection (Runtime.exec / ProcessBuilder):**
No `Runtime.exec()` or `ProcessBuilder` usage found in any of the three files. PASS.

**Deserialization of untrusted data (ObjectInputStream.readObject):**
No `ObjectInputStream` usage found. PASS.

**SQL injection (string-concatenated JDBC queries):**
No JDBC or SQL present in these files. PASS.

**Path traversal in file operations:**
No file I/O in these files. PASS.

---

## Findings

## A48-1

**File:** src/gmtp/telnet/TelnetMessageHandler.java
**Line:** 79
**Severity:** Medium
**Category:** Security > Authentication — Brute-Force
**Description:** The Telnet login enforces a 3-attempt limit per session, but there is no connection rate limiting, delay penalty, or IP-level lockout. After the session is closed at the third failed attempt, an attacker can immediately reconnect and try 3 more passwords. Over time this allows unlimited password guessing at the speed the network allows.
**Evidence:**
```java
} else if ((Integer) session.getAttribute(TRY) < 3) {
    session.write("invalid credentials\n\rusername:\n\r");
    session.setAttribute(TRY, (Integer) session.getAttribute(TRY) + 1);
    session.setAttribute(STATUS, TelnetMessageStatus.LOGIN);
} else {
    session.write("Bye");
    session.close(true);
}
```
**Recommendation:** Add a configurable delay (e.g., exponential back-off) before prompting again after a failed attempt, and track failed attempts by source IP address across sessions to enforce a lockout threshold.

---

## A48-2

**File:** src/gmtp/telnet/TelnetServer.java
**Line:** 49
**Severity:** High
**Category:** Security > Network Exposure
**Description:** The Telnet server is bound to all network interfaces (`0.0.0.0`) because `new InetSocketAddress(port)` without a host argument binds to the wildcard address. The Telnet interface exposes destructive administrative commands (`KILL`, `KILLALL`, `SEND`, `BROADCAST`) and server statistics. Exposing it on all interfaces means it is reachable from any network the server host participates in, not just the loopback/management network.
**Evidence:**
```java
acceptor.bind(new InetSocketAddress(this.port));
```
**Recommendation:** Bind the Telnet acceptor exclusively to the loopback address or a dedicated management interface: `acceptor.bind(new InetSocketAddress("127.0.0.1", this.port))`. If remote management is required, enforce network-level restrictions (firewall, VPN) in addition to application authentication.

---

## A48-3

**File:** src/gmtp/telnet/TelnetMessageHandler.java
**Line:** 203, 225
**Severity:** Medium
**Category:** Security > Input Validation — Content/Protocol Injection
**Description:** The `SEND` and `BROADCAST` Telnet commands accept arbitrary text from the authenticated operator and write it verbatim into GMTP protocol messages that are delivered to connected field units. If the GMTP wire protocol uses delimiter or length-prefix framing, an operator could craft a message payload that contains embedded protocol control bytes or delimiters, potentially corrupting the session state of recipient devices or triggering unintended behaviour on those devices.
**Evidence:**
```java
// SEND command (line 203)
OutgoingMessage outgoing = new OutgoingMessage(Type.DATA, res[1].length(), res[1]);
// BROADCAST command (line 225)
OutgoingMessage outgoing = new OutgoingMessage(Type.DATA, arguments.length(), arguments);
```
**Recommendation:** Validate and sanitise the message body against the GMTP protocol's allowed character set and maximum length before constructing `OutgoingMessage` objects. Reject or escape any bytes that have special meaning in the GMTP framing layer.

---

## A48-4

**File:** src/gmtp/telnet/TelnetMessageHandler.java
**Line:** 255–268
**Severity:** High
**Category:** Security > Privilege / Destructive Operation
**Description:** The `KILLALL` command closes every managed GMTP session unconditionally when issued by any authenticated Telnet user. There is no confirmation step, no role separation between read-only operators and administrators, and no audit log entry. A single compromised Telnet credential (or an insider) can immediately disconnect all field units from the server. The `KILL` command similarly terminates individual sessions. These operations should be restricted to highly privileged roles and should be audited.
**Evidence:**
```java
case TelnetMessagecommand.KILLALL:
    for (Entry<Long, IoSession> sessionMap : sessions.entrySet()) {
        ...
        sessionMap.getValue().close(true);
        killed += "Session closed for " + gmtp_id + "\n\r";
    }
    session.write(killed);
    break;
```
**Recommendation:** Introduce role-based access control for Telnet commands, separating read-only commands (`LIST`, `FIND`, `STATUS`, `HELP`) from destructive ones (`KILL`, `KILLALL`, `SEND`, `BROADCAST`). Log every destructive command with the source IP and timestamp to a server-side audit log independent of the Telnet session.

---

## A48-5

**File:** src/gmtp/outgoing/OutgoingMessageSender.java
**Line:** 32–51
**Severity:** Low
**Category:** Security > Race Condition — Singleton Initialisation
**Description:** All three `getInstance` overloads use an unsynchronised check-then-act pattern to initialise the static `instance` field. Under concurrent access, two threads can both observe `instance == null` and each create a separate `OutgoingMessageSender` instance (and start a separate daemon thread). The second instance overwrites the first, leaving a leaked thread that holds a reference to the same `IoAcceptor` and also modifies shared state.
**Evidence:**
```java
public static OutgoingMessageSender getInstance(IoAcceptor acceptor) {
    if (instance == null) {
        instance = new OutgoingMessageSender(acceptor);
    }
    return instance;
}
```
**Recommendation:** Synchronise the singleton initialisation using `synchronized` on the class, or use the initialization-on-demand holder idiom, or declare `instance` as a `volatile` field and apply double-checked locking correctly.

---

## A48-6

**File:** src/gmtp/outgoing/OutgoingMessageSender.java
**Line:** 30, 171, 218–226
**Severity:** Medium
**Category:** Security > Concurrency — Visibility / Data Race
**Description:** The `lock` field is a plain `boolean` (non-`volatile`, non-`atomic`) used to coordinate between the producer thread calling `add()` and the sender thread calling `fillQueue()`. Because Java's memory model does not guarantee visibility of writes to non-`volatile` fields across threads without explicit synchronisation, the sender thread's writes to `lock` in `fillQueue()` may not be visible to threads calling `add()`. This means `add()` could proceed to modify `tempMessages` while `fillQueue()` is iterating over it, even though the author intended `lock = true` to prevent this. `ConcurrentHashMap` prevents a crash but the data race could cause messages to be silently dropped or incorrectly duplicated.
**Evidence:**
```java
private boolean lock = false;          // line 30 — non-volatile

public void add(OutgoingMessage msg) {
    if (lock == true) {                // line 171 — read may see stale value
        return;
    }
    ...
}

private void fillQueue() {
    lock = true;                       // line 218 — write not guaranteed visible
    ...
    lock = false;                      // line 226
}
```
**Recommendation:** Declare `lock` as `volatile boolean` so that writes in one thread are immediately visible to others, or replace it with an `AtomicBoolean`, or use `synchronized` blocks to guard both `fillQueue()` and the critical section of `add()`.

---

## A48-7

**File:** src/gmtp/outgoing/OutgoingMessageSender.java
**Line:** 80–82
**Severity:** Low
**Category:** Security > Error Handling — Interrupt Suppression
**Description:** The `run()` loop catches `InterruptedException` and logs it but does not re-interrupt the thread (`Thread.currentThread().interrupt()`). This swallows the interrupt signal, making it impossible for external code to stop the thread cleanly by interrupting it. The thread will continue running indefinitely, which prevents clean server shutdown.
**Evidence:**
```java
try {
    sleep(DELAY);
} catch (InterruptedException ex) {
    logger.error(ex.toString());
}
```
**Recommendation:** After logging, call `Thread.currentThread().interrupt()` to restore the interrupted status, or break out of the `while(true)` loop to allow the thread to terminate cleanly on interrupt.

---

## A48-8

**File:** src/gmtp/telnet/TelnetMessageHandler.java
**Line:** 102–104
**Severity:** Medium
**Category:** Security > Information Disclosure — Exception Leakage
**Description:** When a Telnet command causes an exception (for example, an unrecognised command name causing `IllegalArgumentException` from `TelnetMessagecommand.valueOf()`), the raw `Exception` object including its type and message is written directly to the Telnet session. This discloses internal class names, package structure, and implementation details to the connected user.
**Evidence:**
```java
} catch (Exception e) {
    session.write("Invalid command: " + e);
}
```
The `toString()` of an `IllegalArgumentException` produces output such as:
`Invalid command: java.lang.IllegalArgumentException: Unrecognized command: FOO`
**Recommendation:** Send a generic error message to the user (`session.write("Invalid command")`) and log the full exception server-side: `logger.warn("Invalid Telnet command from {}: {}", session.getAttribute("address"), e.getMessage())`.

---

## A48-9

**File:** src/gmtp/telnet/TelnetServer.java
**Line:** 52–56
**Severity:** Low
**Category:** Security > Availability — Unbounded Recursive Retry
**Description:** If `acceptor.bind()` throws `IOException` (e.g., port already in use), the `start()` method sleeps 5 seconds and then calls itself recursively. There is no bound on the number of recursive calls. If the port remains unavailable for an extended period the call stack will grow without bound and eventually throw a `StackOverflowError`. Although this is primarily an availability issue, a `StackOverflowError` is an `Error` not an `Exception` and will propagate unchecked, potentially crashing the thread responsible for starting the server.
**Evidence:**
```java
} catch (IOException ex) {
    logger.error(ex.getMessage());
    try {
        Thread.currentThread().sleep(5000);
        start();          // recursive call — no depth limit
        return true;
    } catch (InterruptedException ex1) {
        ...
    }
```
**Recommendation:** Replace the recursive call with an iterative retry loop with a configurable maximum attempt count, after which the method logs a fatal error and returns `false` (or throws).
