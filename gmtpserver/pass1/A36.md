# Security Audit — Pass 1 — Agent A36

**Branch verified:** master
**Files audited:**
- `src/gmtp/XmlConfigurationLoader.java`
- `src/gmtp/XmlDenied.java`
- `src/gmtp/XmlRoutes.java`

---

## Reading Evidence

### src/gmtp/XmlConfigurationLoader.java

**Fully qualified class name:** `gmtp.XmlConfigurationLoader`

**Interfaces implemented:** `configuration.ConfigurationLoader`

**Imports:**
- `configuration.Configuration`
- `configuration.ConfigurationLoader`
- `java.io.File`
- `java.io.IOException`
- `org.simpleframework.xml.Serializer`
- `org.simpleframework.xml.core.Persister`
- `org.slf4j.Logger`
- `org.slf4j.LoggerFactory`

**Fields:**
- `private String serverConfFilename` — line 23, default value `GMTPRouter.configPath + "/gmtpRouter.xml"`
- `private String routesFolder` — line 24, default value `GMTPRouter.configPath + "/routes"`
- `private String id` — line 25, `"1234"`
- `private int port` — line 26, `9494`
- `private int maxThread` — line 27, `256`
- `private Serializer serializer` — line 28, initialized as `new Persister()`
- `private Configuration configuration` — line 29
- `private static Logger logger` — line 30
- `private long lastAccessed` — line 31, `0`

**Public methods:**
- `XmlConfigurationLoader()` — constructor, line 33
- `XmlConfigurationLoader(String configFilename)` — constructor, line 36
- `boolean hasChanged()` throws IOException — line 40
- `boolean load()` throws Exception — line 47
- `String getConfigFolder()` — line 60
- `void setConfigFolder(String configFolder)` — line 64
- `Configuration getConfiguration()` — line 79

**Private methods:**
- `boolean generateConfiguration(File confFile)` — line 68

---

### src/gmtp/XmlDenied.java

**Fully qualified class name:** `gmtp.XmlDenied`

**Interfaces implemented / classes extended:** none (extends `Object` implicitly; annotated `@Root(name = "denied")`)

**Imports:**
- `java.util.HashMap`
- `org.simpleframework.xml.ElementMap`
- `org.simpleframework.xml.Root`
- `org.slf4j.Logger`
- `org.slf4j.LoggerFactory`

**Fields:**
- `@ElementMap(entry = "prefix", key = "id", attribute = true, inline = true) private HashMap<Integer, String> denied` — line 21
- `private Logger logger` — line 22

**Public methods:**
- `XmlDenied()` — constructor, line 24
- `XmlDenied(Integer id, String prefix)` — constructor, line 28
- `HashMap<Integer, String> getMap()` — line 33

---

### src/gmtp/XmlRoutes.java

**Fully qualified class name:** `gmtp.XmlRoutes`

**Access modifier:** package-private (`class XmlRoutes`, line 17)

**Interfaces implemented / classes extended:** none (annotated `@Root(name = "routes")`)

**Imports:**
- `java.util.HashMap`
- `java.util.Map`
- `org.simpleframework.xml.ElementMap`
- `org.simpleframework.xml.Root`

**Fields:**
- `@ElementMap(entry = "trigger", key = "pattern", attribute = true, inline = true) private Map<String, String> map` — line 20

**Public methods:**
- `XmlRoutes()` — constructor, line 22
- `XmlRoutes(String pattern, String command)` — constructor, line 26
- `Map<String, String> getMap()` — line 31

---

## Security Checklist Findings

### XML Parsing Security

**XXE injection (XML External Entity):**
The project uses Simple XML framework version **2.6.1** (confirmed in `nbproject/project.properties`: `file.reference.simple-xml-2.6.1.jar`). All three files use `org.simpleframework.xml.core.Persister` (directly instantiated with `new Persister()` in `XmlConfigurationLoader` line 28, and in `DeniedPrefixesManager`/`XmlRoutingMap`). Simple XML 2.6.1 uses an underlying SAX parser and **does not disable DTD processing or external entity resolution by default**. No custom `Strategy` or `Filter` is configured to harden the parser. There is no evidence anywhere in the codebase of calls to disable `XMLConstants.FEATURE_SECURE_PROCESSING`, `disallow-doctype-decl`, or `external-general-entities`. This means any XML file read by `Persister.read()` — including `gmtpRouter.xml`, `deniedPrefixes.xml`, and all route XML files in the `routes/` folder — is parsed with XXE enabled. **Finding raised as A36-1.**

**XML injection (writing user data into XML):**
The `generateConfiguration` method in `XmlConfigurationLoader` (line 68–77) calls `serializer.write(configuration, confFile)`. The data written (`id`, `port`, `maxThread`, `routesFolder`) originates from hard-coded class-level defaults, not from user-supplied input. No XML injection risk identified here.

---

### Configuration Loading Security

**Config file path controllability:**
`GMTPRouter.configPath` is set from a JVM system property `gmtpConfig` (GMTPRouter.java line 55: `System.getProperty("gmtpConfig")`). This is a startup parameter controlled by the process operator, not by network clients. However, `setConfigFolder(String configFolder)` (line 64) accepts any string and stores it directly as `serverConfFilename` without any validation or canonicalization. If any caller passes an externally influenced string, path traversal is possible. At present, no network-reachable caller is observed, but the setter is public and the absence of validation is a latent risk.

**Path traversal in config file loading:**
`XmlConfigurationLoader.load()` constructs `new File(serverConfFilename)` (line 49) and `DeniedPrefixesManager.loadConfiguration()` constructs `new File(GMTPRouter.configPath + "/" + config.getDeniedPrefixesFile())` where `getDeniedPrefixesFile()` returns a value from the XML config. If the XML config is tampered with (e.g., via the XXE write-back vector or a compromised config file), the `deniedPrefixesFile` value could contain `../` sequences to load an attacker-chosen file. **Finding raised as A36-2.**

**Sensitive data in XML config:**
`gmtpRouter.xml` contains database credentials in plaintext (`<dbUser>gmtp</dbUser>`, `<dbPass>gmtp-postgres</dbPass>`, `<telnetPassword>gmtp!telnet</telnetPassword>`). These are loaded by `XmlConfigurationLoader`/`Persister` and stored in the configuration object in memory. Credentials in XML config files are a security concern compared to environment variables or a secrets manager. **Finding raised as A36-3.**

---

### Denied Prefix Logic

**Case sensitivity bypass:**
In `GMTPMessageHandler.java` (line 121), the client-supplied prefix is extracted via `gmtpMsg.getMessage().substring(0, pos)` and compared via `GMTPRouter.deniedPrefixes.containsValue(prefix)` (line 124). `HashMap.containsValue` uses `String.equals()`, which is **case-sensitive**. If a denied prefix is stored as `"tms"` (as in `deniedPrefixes.xml` line 3), a client sending `"TMS_deviceid"` would not be blocked. **Finding raised as A36-4.**

**Off-by-one in prefix extraction:**
The prefix is extracted as `gmtpMsg.getMessage().substring(0, pos)` where `pos = gmtpMsg.getMessage().indexOf('_')` (line 120-121). If the message contains no underscore, `indexOf` returns -1, causing `substring(0, -1)` to throw a `StringIndexOutOfBoundsException`. The outer `if (!GMTPRouter.isEmpty(...))` guard on line 118 only checks for empty/null message, not for absence of the underscore delimiter. This would crash the handler rather than silently passing the connection, but it represents incorrect guard logic. This is an error-handling concern rather than a bypass; noted for completeness. Not raised as a separate finding as it results in an exception rather than a bypass.

**Bypass via null deniedPrefixes:**
In `GMTPRouter.java` lines 93-94, if the initial load of the denied prefixes fails, `deniedPrefixes` is set to a new empty `HashMap`. This is actually safe — no connection would be blocked, but no crash either. However, if the `DeniedPrefixesManager` fails to load the file during a reload (line 84: "No denied prefix file found"), `GMTPRouter.deniedPrefixes` retains its previous value (the `if (denyFile.exists())` branch simply logs and does nothing). If the file is deleted at runtime, the old blocklist stays in memory — the behaviour is acceptable but undocumented.

---

### Routing Logic

**Command injection via routes XML (critical):**
`XmlRoutes.getMap()` returns a `Map<String, String>` where the value is a command/script path (e.g., `/home/michel/test.sh` in `routes/all.xml`). This value is loaded without any validation. In `GMTPMessage.callFilter()` (lines 171–208), these values are passed directly to `ProcessBuilder` as the executable path:

```java
params.add(cds[i]);         // command from routes XML
params.add(gmtp_id);        // GMTP unit ID from network client
params.add(address);        // client address
params.add(msgStr);         // raw message string from network client
```

The route command path itself (`cds[i]`) comes from XML config and is operator-controlled, but `gmtp_id`, `address`, and `msgStr` are all **network-client-controlled** values passed as arguments to the subprocess. While `ProcessBuilder` with a list (rather than shell string concatenation) prevents shell word-splitting injection, the arguments are entirely unvalidated client data. Additionally, if a route XML file is compromised (e.g., via path traversal or XXE), an attacker could supply an arbitrary executable path. **Finding raised as A36-5.**

**Route destination validation:**
Routes contain file-system paths to scripts (not network addresses). No SSRF via network destination is directly observed — the routing does not construct URLs or TCP connections from route values. SSRF not applicable here.

**Unvalidated route patterns used as regex:**
In `GMTPMessage.checkFilter()` (line 224), the route pattern key is compiled directly as a `java.util.regex.Pattern`: `Pattern.compile(patStr)`. If the XML routes file contains a malformed or pathological regex (e.g., a ReDoS pattern like `(a+)+`), it could cause catastrophic backtracking against client-supplied `gmtp_id` or `msgStr`. Exception from bad patterns is caught and logged (line 237), preventing crash. ReDoS is a latent risk if route files are editable by lower-trust operators. Not raised as a separate finding given the operator-controlled nature of the config.

---

### Error Handling

**Swallowed exception in generateConfiguration:**
`XmlConfigurationLoader.generateConfiguration()` (lines 68–77) catches all `Exception` types, logs only at `DEBUG` level with string concatenation (`"Configuration error:" + e.getMessage()`), and returns `false`. The caller `load()` (line 52) calls `generateConfiguration(confFile)` but **does not check the return value**. If config file generation fails silently, `load()` proceeds to `serializer.read(XmlConfiguration.class, confFile)` on a non-existent file, which will throw an exception that propagates up — so the server does not continue with a missing config. However, the silent swallow of the generation failure at DEBUG level hides the root cause. **Finding raised as A36-6.**

**Missing or malformed config behavior:**
`XmlConfigurationLoader.load()` does propagate exceptions (declared `throws Exception`), and `ConfigurationManager.loadConfiguration()` catches and logs them at DEBUG level only (line 95: `logger.debug("Config Error: " + ex.getMessage())`). A malformed config produces only a DEBUG log entry, which may go unnoticed in production. **Finding raised as A36-7.**

---

### General Java Security

**Command injection / ProcessBuilder:** Covered under Routing Logic above (A36-5).

**Deserialization of untrusted data:** No `ObjectInputStream.readObject()` observed in the three assigned files or their direct XML-loading collaborators. Not applicable.

**SQL injection:** No JDBC queries present in the three assigned files. Not applicable.

**Runtime.exec():** Not used in the three assigned files. `ProcessBuilder` is used in `GMTPMessage.callFilter()` (out of scope for this agent, but triggered by `XmlRoutes` data; covered in A36-5).

---

## Findings

## A36-1

**File:** src/gmtp/XmlConfigurationLoader.java
**Line:** 28
**Severity:** High
**Category:** Security > XML Parsing > XXE Injection
**Description:** The Simple XML `Persister` is instantiated with default settings (`new Persister()`) and used to parse all XML configuration files (`gmtpRouter.xml`, `deniedPrefixes.xml`, and route files). Simple XML 2.6.1 does not disable DTD processing or external entity resolution in its default SAX configuration. Any of these XML files — if writable by a lower-privileged attacker or reachable via another vulnerability — could include an XXE payload that causes the server to read local files (e.g., `/etc/passwd`, private keys) or make outbound network requests, with the exfiltrated data returned through parsing errors or log output. The same `Persister()` pattern is repeated in `XmlRoutingMap` and `DeniedPrefixesManager`.
**Evidence:**
```java
// XmlConfigurationLoader.java line 28
private Serializer serializer = new Persister();

// load() line 54
configuration = serializer.read(XmlConfiguration.class, confFile);
```
**Recommendation:** Create a hardened SAX parser factory with `http://apache.org/xml/features/disallow-doctype-decl` set to `true` and pass it as a custom `DocumentProvider` or `Strategy` to `Persister`. Alternatively upgrade to a version of Simple XML that supports secure-processing flags, or replace with a JAXB/Jackson configuration that explicitly disables external entity processing (`XMLInputFactory.setProperty(XMLInputFactory.IS_SUPPORTING_EXTERNAL_ENTITIES, false)`).

---

## A36-2

**File:** src/gmtp/XmlConfigurationLoader.java
**Line:** 64–65
**Severity:** Medium
**Category:** Security > Configuration Loading > Path Traversal
**Description:** The public setter `setConfigFolder(String configFolder)` accepts any string and stores it directly as the config file path without canonicalization or validation. A caller passing a path containing `../` sequences could redirect config loading to an arbitrary file on the filesystem. Although no current network-reachable code path calls this setter, its public visibility means future callers or refactoring could introduce a traversal vector. Additionally, `getDeniedPrefixesFile()` in `XmlConfiguration` returns a value read from the XML itself; if that XML is tampered with, a `../` value in `<deniedPrefixesFile>` could direct the server to parse an attacker-chosen file as the denied-prefixes list.
**Evidence:**
```java
// XmlConfigurationLoader.java lines 64-65
public void setConfigFolder(String configFolder) {
    this.serverConfFilename = configFolder;
}
```
**Recommendation:** Validate and canonicalize all file paths before use. Use `File.getCanonicalPath()` and assert the result starts with the expected base directory. Remove the public setter if it is unused, or restrict its visibility.

---

## A36-3

**File:** src/gmtp/XmlConfigurationLoader.java
**Line:** 54
**Severity:** Medium
**Category:** Security > Configuration Loading > Credentials in Config File
**Description:** `XmlConfigurationLoader.load()` reads `gmtpRouter.xml`, which contains plaintext database passwords (`<dbPass>gmtp-postgres</dbPass>`, `<dbPassDefault>gmtp-postgres</dbPassDefault>`) and a plaintext telnet password (`<telnetPassword>gmtp!telnet</telnetPassword>`). Storing credentials in XML configuration files risks exposure through file system access, backups, version control history, or log output when the config is printed. The config is loaded into a `Configuration` object that may be logged or inspected.
**Evidence:**
```xml
<!-- gmtpRouter.xml lines 54, 62, 74 (representative config file) -->
<dbPass>gmtp-postgres</dbPass>
<dbPassDefault>gmtp-postgres</dbPassDefault>
<telnetPassword>gmtp!telnet</telnetPassword>
```
```java
// XmlConfigurationLoader.java line 54
configuration = serializer.read(XmlConfiguration.class, confFile);
```
**Recommendation:** Move credentials to environment variables or a secrets management system (e.g., HashiCorp Vault, OS keystore). The XML config should reference the variable name, not the value. At minimum, ensure the XML config file has restrictive filesystem permissions (owner-read-only) and is excluded from version control.

---

## A36-4

**File:** src/gmtp/XmlDenied.java
**Line:** 33–35
**Severity:** High
**Category:** Security > Denied Prefix Logic > Case Sensitivity Bypass
**Description:** `XmlDenied.getMap()` returns a `HashMap<Integer, String>` of denied prefixes. In `GMTPMessageHandler.java` (line 124), the blocklist check uses `GMTPRouter.deniedPrefixes.containsValue(prefix)`, where `prefix` is the raw, unmodified substring from the client message. `HashMap.containsValue` uses `String.equals()`, which is case-sensitive. A denied prefix entry of `"tms"` (as in the sample `deniedPrefixes.xml`) would not block a client sending `"TMS_deviceid"` or `"Tms_deviceid"`. An attacker knowing the denied prefix can trivially bypass the block by altering case.
**Evidence:**
```java
// XmlDenied.java line 33
public HashMap<Integer, String> getMap() {
    return denied;
}
```
```java
// GMTPMessageHandler.java line 124 (consumer of XmlDenied data)
if (GMTPRouter.deniedPrefixes.containsValue(prefix)) {
```
```xml
<!-- deniedPrefixes.xml line 3 -->
<prefix id="0" >tms</prefix>
```
**Recommendation:** Normalize the client-supplied prefix to a consistent case (e.g., `prefix.toLowerCase(Locale.ROOT)`) before comparison, and store denied prefixes in the same normalized form. Alternatively, iterate the map and use `equalsIgnoreCase` for each comparison.

---

## A36-5

**File:** src/gmtp/XmlRoutes.java
**Line:** 20, 31
**Severity:** High
**Category:** Security > Routing Logic > Unvalidated Command Execution Arguments
**Description:** `XmlRoutes` stores route values — arbitrary strings read from XML files in the `routes/` directory — as the "command" values in a `Map<String, String>`. These values are passed to `ProcessBuilder` in `GMTPMessage.callFilter()` (line 187) together with unsanitized, network-client-controlled arguments: the GMTP unit ID (`gmtp_id`), the client's remote address (`address`), and the raw message string (`msgStr`). While `ProcessBuilder` with a list prevents shell injection on the command token itself, the three arguments appended after the command path are completely unvalidated client data. A crafted `msgStr` containing null bytes, very long strings, or format strings could crash or exploit the target script. Furthermore, if an attacker can write or influence any XML file in the routes folder (e.g., via path traversal or XXE), they can specify an arbitrary executable. There is also no validation that route command values are absolute paths, exist on the filesystem, or point to executable files.
**Evidence:**
```java
// XmlRoutes.java line 20
@ElementMap(entry = "trigger", key = "pattern", attribute = true, inline = true)
private Map<String, String> map;

// XmlRoutes.java line 31
public Map<String, String> getMap() {
    return map;
}
```
```java
// GMTPMessage.java lines 182-189 (consumer of XmlRoutes data)
params.add(cds[i]);      // command path from routes XML
params.add(gmtp_id);     // client-supplied unit ID
params.add(address);     // client remote address
params.add(msgStr);      // raw client message
ProcessBuilder pb = new ProcessBuilder(params);
```
```xml
<!-- routes/all.xml line 2 (sample route value) -->
<trigger pattern="__EXAMPLE__">/home/michel/test.sh</trigger>
```
**Recommendation:** Validate route command values at load time: assert they are absolute paths, exist, are executable, and reside within an approved directory. Sanitize or reject network-supplied arguments (`gmtp_id`, `msgStr`) before passing to external processes — apply an allowlist of permitted characters. Log and alert on any route file modification. Consider whether the external script execution feature is necessary; if not, remove it.

---

## A36-6

**File:** src/gmtp/XmlConfigurationLoader.java
**Line:** 68–77
**Severity:** Low
**Category:** Security > Error Handling > Swallowed Exception
**Description:** `generateConfiguration()` catches all exceptions and logs only at `DEBUG` level using string concatenation (`"Configuration error:" + e.getMessage()`). The return value `false` is not checked by the caller (`load()` at line 52). If the initial config file cannot be written (e.g., due to permissions), the error is invisible at INFO/WARN/ERROR log levels, and the server then attempts to read the non-existent file, throwing a less informative exception. The root cause of the write failure is lost.
**Evidence:**
```java
// XmlConfigurationLoader.java lines 68-77
private boolean generateConfiguration(File confFile) {
    try {
        configuration = new XmlConfiguration(id, port, maxThread, routesFolder);
        serializer.write(configuration, confFile);
        return true;
    } catch (Exception e) {
        logger.debug("Configuration error:" + e.getMessage());
        return false;
    }
}
```
```java
// XmlConfigurationLoader.java line 52 — return value ignored
generateConfiguration(confFile);
```
**Recommendation:** Log the failure at ERROR level (not DEBUG), check the return value of `generateConfiguration`, and throw or propagate a meaningful exception if config generation fails, rather than proceeding with a potentially absent config file.

---

## A36-7

**File:** src/gmtp/XmlConfigurationLoader.java
**Line:** 47–58
**Severity:** Low
**Category:** Security > Error Handling > Insufficient Error Visibility
**Description:** `XmlConfigurationLoader.load()` declares `throws Exception`, propagating failures upward. However, its caller `ConfigurationManager.loadConfiguration()` catches all exceptions and logs only at `DEBUG` level (`logger.debug("Config Error: " + ex.getMessage())`). A malformed, missing, or malicious (e.g., XXE-injected) config file will silently fail to load in production environments where DEBUG logging is disabled, leaving the server in an unconfigured state without any visible ERROR or WARN log entry. The server may continue running with a null or stale configuration.
**Evidence:**
```java
// ConfigurationManager.java lines 89-99
public boolean loadConfiguration() {
    try {
        if (!confLoader.load()) {
            return false;
        }
    } catch (Exception ex) {
        logger.debug("Config Error: " + ex.getMessage());
        return false;
    }
    config = confLoader.getConfiguration();
    return true;
}
```
**Recommendation:** Log config-load failures at ERROR level. Consider throwing a fatal exception or halting startup if the primary configuration cannot be loaded, rather than returning `false` silently.
