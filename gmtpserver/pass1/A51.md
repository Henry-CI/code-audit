# Security Audit Pass 1 — Agent A51

**Date:** 2026-02-28
**Branch:** master (confirmed via `git rev-parse --abbrev-ref HEAD`)
**Auditor:** Agent A51

---

## Reading Evidence

### File 1: `src/gmtp/telnet/TelnetMessagecommand.java`

**Fully qualified class name:** `gmtp.telnet.TelnetMessagecommand`

**Imports:** None

**Fields:**
- `public static final int LIST = 0`
- `public static final int FIND = 1`
- `public static final int QUIT = 2`
- `public static final int BROADCAST = 3`
- `public static final int KILL = 4`
- `public static final int KILLALL = 5`
- `public static final int HELP = 6`
- `public static final int SEND = 7`
- `public static final int STATUS = 8`
- `private final int num`

**Interfaces implemented / classes extended:** None

**Public methods:**
- `public int toInt()` — line 28
- `public static TelnetMessagecommand valueOf(String s)` — line 32

**Private constructors:**
- `private TelnetMessagecommand(int num)` — line 24

---

### File 2: `src/gmtp/telnet/TelnetServer.java`

**Fully qualified class name:** `gmtp.telnet.TelnetServer`

**Imports:**
- `configuration.Configuration`
- `java.io.IOException`
- `java.net.InetSocketAddress`
- `java.util.logging.Level`
- `org.apache.mina.core.service.IoAcceptor`
- `org.apache.mina.filter.codec.ProtocolCodecFilter`
- `org.apache.mina.filter.codec.textline.TextLineCodecFactory`
- `org.apache.mina.filter.logging.LoggingFilter`
- `org.apache.mina.transport.socket.SocketAcceptor`
- `org.apache.mina.transport.socket.SocketSessionConfig`
- `org.apache.mina.transport.socket.nio.NioSocketAcceptor`
- `org.slf4j.Logger`
- `org.slf4j.LoggerFactory`
- `server.Server`

**Interfaces implemented:** `server.Server`

**Fields:**
- `public SocketAcceptor acceptor` — line 28
- `private int port = 1234` — line 29
- `private static Logger logger` — line 30
- `private static IoAcceptor gmtpAcceptor` — line 31

**Public methods:**
- `public TelnetServer(IoAcceptor gmtpAcceptor, Configuration config)` — constructor, line 33
- `public boolean start()` — line 47
- `public static IoAcceptor getGmtpAcceptor()` — line 65

---

### File 3: `src/router/RoutingMap.java`

**Fully qualified class name:** `router.RoutingMap`

**Imports:**
- `java.util.HashMap`

**This is an interface.**

**Interfaces implemented / classes extended:** None (is itself an interface)

**Public methods (interface declarations):**
- `public HashMap<String, String> getMap()` — line 15

---

### Supplementary reading: `TelnetMessageHandler.java` (referenced by TelnetServer, necessary for Telnet security analysis)

**Fully qualified class name:** `gmtp.telnet.TelnetMessageHandler`

**Imports:**
- `gmtp.GMTPMessage.Type`
- `gmtp.GMTPRouter`
- `gmtp.outgoing.OutgoingMessage`
- `gmtp.outgoing.OutgoingMessageSender`
- `java.util.Map`
- `java.util.Map.Entry`
- `java.util.logging.Level`
- `org.apache.mina.core.service.IoAcceptor`
- `org.apache.mina.core.service.IoHandlerAdapter`
- `org.apache.mina.core.service.IoServiceStatistics`
- `org.apache.mina.core.session.IoSession`
- `org.slf4j.Logger`
- `org.slf4j.LoggerFactory`

**Class modifier:** package-private (`class TelnetMessageHandler`, no `public`)

**Extends:** `IoHandlerAdapter`

**Fields:**
- `private static Logger logger` — line 27
- `private IoAcceptor gmtpIoAcceptor` — line 28
- `private String STATUS = "STATUS"` — line 29
- `private String USERNAME = "USERNAME"` — line 30
- `private String TRY = "TRY"` — line 31
- `private final String username` — line 32
- `private final String password` — line 33

**Public methods (overrides):**
- `public void exceptionCaught(IoSession session, Throwable cause)` — line 45
- `public void sessionCreated(IoSession session)` — line 50
- `public void sessionClosed(IoSession session)` — line 59
- `public void messageReceived(IoSession session, Object message)` — line 64

**Private methods:**
- `private boolean checkAuthentification(String username, String password)` — line 116
- `private void processTelnetMessage(String command, IoSession session, String arguments)` — line 124

---

### Supplementary reading: `XmlRoutingMap.java` (concrete implementation of `RoutingMap`)

**Fully qualified class name:** `gmtp.XmlRoutingMap`

**Implements:** `router.RoutingMap`

**Fields:**
- `private HashMap<String, String> map`
- `private String configFolder = "./routes"`
- `private Serializer serializer = new Persister()`
- `private static Logger logger`

**Public methods:**
- `public XmlRoutingMap(String folder)` — constructor, line 26
- `public void buildDefaultConfiguration()` — line 41
- `public HashMap<String, String> getMap()` — line 51

---

## Security Checklist Results

### Telnet Server Security

**Authentication — FOUND (partial):** `TelnetMessageHandler` implements a username/password challenge before accepting commands (`TelnetMessageStatus.LOGIN` -> `PASSWORD` -> `LOGGED_IN` flow). Authentication is present. However, see finding A51-1 (no IP restriction) and A51-2 (brute-force limit is weak/trivially reset).

**Bind address — ISSUE FOUND:** `acceptor.bind(new InetSocketAddress(this.port))` — no address is specified, which causes MINA to bind to `0.0.0.0` (all interfaces). See A51-1.

**Commands exposed — catalogued:**
| Command | Effect |
|---------|--------|
| LIST | Returns all connected GMTP session IDs |
| FIND [arg] | Returns session IDs containing arg |
| STATUS | Returns server throughput statistics and outgoing queue count |
| SEND [gmtp_id] [message] | Injects a DATA message into an active device session |
| BROADCAST [message] | Injects a DATA message into every active device session |
| KILL [gmtp_id] | Forcibly closes a device session |
| KILLALL | Forcibly closes all device sessions |
| QUIT | Closes the Telnet session |
| HELP | Prints command list |

**Dangerous commands — FOUND:** KILLALL terminates all connected device sessions (see A51-3). BROADCAST/SEND can inject arbitrary message content into device sessions (see A51-4).

**Command injection via Runtime.exec / ProcessBuilder — NOT FOUND:** No `Runtime.exec()` or `ProcessBuilder` usage in any of the three assigned files.

**Information disclosure via STATUS — FOUND:** The STATUS command exposes internal server metrics. See A51-5.

**Authentication bypass — NOT FOUND:** The state machine correctly gates all commands behind `TelnetMessageStatus.LOGGED_IN`. There is no path to `processTelnetMessage` without passing `checkAuthentification`.

**Brute-force protection — PARTIAL ISSUE:** The TRY counter allows 3 failed attempts but resets on every new TCP connection. See A51-2.

**Credential comparison — NOTE:** Credentials are compared with `.equals()` (not constant-time). Not a practical concern for a TCP management interface but noted.

### RoutingMap Security

**Thread safety — ISSUE FOUND:** `XmlRoutingMap.getMap()` returns the internal `HashMap<String,String>` directly with no synchronization. `HashMap` is not thread-safe. See A51-6.

**Injection/modification by untrusted input — NOT FOUND in assigned files:** The routing map is loaded from XML files at startup. There is no Telnet command that modifies the routing map at runtime. No untrusted input path to `putAll` or `put` on the map was found in the assigned files.

**SSRF — NOT DIRECTLY FOUND IN ASSIGNED FILES:** The `RoutingMap` interface itself only returns a `HashMap<String,String>`. Validation of route destinations would occur in the router/message handler code (outside assigned files). The map values are not validated within the assigned files.

**Routing table poisoning — NOT FOUND IN ASSIGNED FILES:** The XML loading in `XmlRoutingMap` reads only from a controlled filesystem folder. No runtime modification path exists in the assigned files.

**NullPointerException risk in XmlRoutingMap constructor — FOUND:** See A51-7.

### Error Handling

**Swallowed exceptions:**
- `TelnetServer.start()` catches `IOException`, logs only `ex.getMessage()`, and recursively retries — the stack trace is lost. See A51-8.
- `TelnetServer.start()` catches `InterruptedException` during the recursive retry sleep, logs it, and falls through — the thread interrupt status is not restored.
- `TelnetMessageHandler.exceptionCaught()` logs only `cause.getMessage()`, discarding the full stack trace (line 46).
- `TelnetMessageHandler.messageReceived()` catches all `Exception` and writes `"Invalid command: " + e` to the Telnet session (line 103) — this reveals internal exception details to the authenticated user, see A51-9.

**Malformed Telnet input crash risk:** `TelnetMessagecommand.valueOf()` throws `IllegalArgumentException` for unrecognised commands (line 62), which is caught by the broad `catch (Exception e)` in `messageReceived` (line 102) and written back to the session. The server does not crash; this is adequately handled.

**Routing failures — OUT OF SCOPE FOR ASSIGNED FILES.**

### General Java Security

**Runtime.exec() / ProcessBuilder — NOT FOUND** in assigned files.

**ObjectInputStream.readObject() deserialization — NOT FOUND** in assigned files.

**SQL injection — NOT FOUND** in assigned files. (SQL queries are present in `GMTPRouter.java` which is outside the assigned scope, but none exist in the three assigned files.)

**Path traversal — POSSIBLE ISSUE:** `XmlRoutingMap` constructs file paths using `configFolder` supplied from configuration. If the configuration value is attacker-controlled, path traversal is possible. See A51-10.

---

## Findings

## A51-1

**File:** C:/Projects/cig-audit/repos/gmtpserver/src/gmtp/telnet/TelnetServer.java
**Line:** 49
**Severity:** High
**Category:** Security > Network Exposure
**Description:** The Telnet management server binds to all network interfaces (`0.0.0.0`) because `InetSocketAddress` is constructed with only a port number and no explicit address. This exposes the management interface on every network interface of the host, including externally reachable interfaces, rather than restricting it to the loopback address (`127.0.0.1`). Any host that can reach the server's IP on the configured Telnet port can attempt to authenticate.
**Evidence:**
```java
acceptor.bind(new InetSocketAddress(this.port));
```
**Recommendation:** Bind the Telnet acceptor to the loopback address: `acceptor.bind(new InetSocketAddress("127.0.0.1", this.port))`, or make the bind address a configuration parameter that defaults to `127.0.0.1`.

---

## A51-2

**File:** C:/Projects/cig-audit/repos/gmtpserver/src/gmtp/telnet/TelnetMessageHandler.java
**Line:** 79
**Severity:** Medium
**Category:** Security > Authentication > Brute-Force Protection
**Description:** The failed-login counter (`TRY` session attribute) resets to zero on every new TCP connection because it is initialised in `sessionCreated`. An attacker can close and reopen the TCP connection after every 3 failed attempts to reset the counter, allowing an unlimited number of password attempts with no lockout. There is also no delay introduced between failed attempts.
**Evidence:**
```java
// sessionCreated — resets counter on every new connection:
session.setAttribute(TRY, 0);

// messageReceived — limit checked but trivially bypassed by reconnecting:
} else if ((Integer) session.getAttribute(TRY) < 3) {
    session.write("invalid credentials\n\rusername:\n\r");
    session.setAttribute(TRY, (Integer) session.getAttribute(TRY) + 1);
    session.setAttribute(STATUS, TelnetMessageStatus.LOGIN);
```
**Recommendation:** Track failed authentication attempts by source IP address in a server-wide (not session-scoped) data structure, implement a lockout or exponential back-off after a configurable number of failures, and add a mandatory delay after each failed attempt.

---

## A51-3

**File:** C:/Projects/cig-audit/repos/gmtpserver/src/gmtp/telnet/TelnetMessageHandler.java
**Line:** 255
**Severity:** High
**Category:** Security > Availability > Privileged Destructive Command
**Description:** The `KILLALL` command, accessible to any authenticated Telnet user, forcibly closes every active GMTP device session. This means a single Telnet login can disconnect all field devices from the server simultaneously, causing a complete service outage. There is no confirmation step, no rate limit, and no role separation — all authenticated Telnet users have the same destructive capability.
**Evidence:**
```java
case TelnetMessagecommand.KILLALL:
    String killed = "";
    for (Entry<Long, IoSession> sessionMap : sessions.entrySet()) {
        ...
        sessionMap.getValue().close(true);
        killed += "Session closed for " + gmtp_id + "\n\r";
    }
    session.write(killed);
    break;
```
**Recommendation:** Implement role-based access control for destructive commands (KILL, KILLALL). Require a secondary confirmation token or restrict these commands to a separate elevated role. Consider audit-logging every use of KILL/KILLALL with the source IP and authenticated username.

---

## A51-4

**File:** C:/Projects/cig-audit/repos/gmtpserver/src/gmtp/telnet/TelnetMessageHandler.java
**Line:** 203 and 225
**Severity:** High
**Category:** Security > Message Integrity > Arbitrary Message Injection
**Description:** The `SEND` and `BROADCAST` Telnet commands allow an authenticated Telnet operator to inject arbitrary DATA messages into active device sessions. The message content is taken verbatim from the Telnet command line with no content validation, length restriction, or sanitisation. Depending on how connected field devices interpret DATA messages, this could be used to issue unauthorised commands to devices, manipulate device state, or trigger device-side vulnerabilities.
**Evidence:**
```java
// SEND — arbitrary content from Telnet argument injected into device session:
OutgoingMessage outgoing = new OutgoingMessage(Type.DATA, res[1].length(), res[1]);
outgoing.setGmtp_id(res[0]);
outgoing.setDatabaseId(0);
sessionMap.getValue().write(outgoing);

// BROADCAST — same injection to all connected devices:
OutgoingMessage outgoing = new OutgoingMessage(Type.DATA, arguments.length(), arguments);
```
**Recommendation:** Define and enforce a whitelist of permitted message content or message types that may be injected via the Telnet interface. Log all injected messages including source IP, authenticated username, target device, and message content. Consider whether the Telnet interface should have any message-injection capability at all, or whether this path should be restricted to a separate, more tightly controlled administrative API.

---

## A51-5

**File:** C:/Projects/cig-audit/repos/gmtpserver/src/gmtp/telnet/TelnetMessageHandler.java
**Line:** 172–189
**Severity:** Low
**Category:** Security > Information Disclosure
**Description:** The `STATUS` command returns internal server operational metrics to any authenticated Telnet session, including current session count, cumulative session count, peak session count, read throughput, message throughput, and the current size of the outgoing message queue. While this is low risk on its own, this information aids an attacker in understanding server load and timing for targeted attacks. Access to this information should be considered in the context of the broad Telnet exposure (A51-1).
**Evidence:**
```java
String currentStats = " Current Number Sessions: \t\t" + this.gmtpIoAcceptor.getManagedSessionCount() + "\n\r";
currentStats += " Cumulative Managed Session Count: \t" + stats.getCumulativeManagedSessionCount() + "\n\r";
currentStats += " Largest Managed Session Count: \t" + stats.getLargestManagedSessionCount() + "\n\r";
currentStats += " Max bytes/sec: \t\t\t" + stats.getLargestReadBytesThroughput() + "\n\r";
currentStats += " Current bytes/sec:\t\t\t" + stats.getReadBytesThroughput() + "\n\r";
currentStats += " Max Messages/sec: \t\t\t" + stats.getLargestReadMessagesThroughput() + "\n\r";
currentStats += " Current Messages/sec:\t\t\t" + stats.getReadMessagesThroughput() + "\n\r";
currentStats += " Number of Messages in outgoing queue\t" + OutgoingMessageSender.getInstance().getCount() + "\n\r";
```
**Recommendation:** This is acceptable if the Telnet interface is properly network-restricted (see A51-1). If A51-1 is remediated, the severity of this finding drops further. No change required beyond fixing A51-1.

---

## A51-6

**File:** C:/Projects/cig-audit/repos/gmtpserver/src/gmtp/XmlRoutingMap.java
**Line:** 51
**Severity:** Medium
**Category:** Security > Thread Safety > Unsynchronized Shared Mutable State
**Description:** `XmlRoutingMap.getMap()` returns the internal `HashMap<String,String>` instance directly, with no defensive copy and no synchronisation. `HashMap` is not thread-safe. If the routing map is accessed concurrently from multiple threads (e.g., the MINA I/O thread pool handling incoming GMTP messages), simultaneous reads while a write is occurring (e.g., during a map rebuild/reload) can cause data corruption, infinite loops, or `ConcurrentModificationException`. Even if the map is only written during startup, returning the live internal reference allows callers to modify it without any protection.
**Evidence:**
```java
// XmlRoutingMap.java line 51:
public HashMap<String, String> getMap() {
    return map;
}

// RoutingMap interface line 15:
public HashMap<String, String> getMap();
```
**Recommendation:** Return `Collections.unmodifiableMap(map)` or a defensive copy. If the map can be reloaded at runtime, replace `HashMap` with `ConcurrentHashMap` and synchronise the reload operation. Change the return type in the `RoutingMap` interface to `Map<String,String>` to avoid exposing the concrete implementation.

---

## A51-7

**File:** C:/Projects/cig-audit/repos/gmtpserver/src/gmtp/XmlRoutingMap.java
**Line:** 31
**Severity:** Medium
**Category:** Security > Error Handling > NullPointerException / Crash
**Description:** In the `XmlRoutingMap` constructor, `confs.list()` returns `null` if `configFolder` does not denote a valid directory or an I/O error occurs. The result is immediately used in a `for` loop without a null check (`filename.length` on line 31), which will throw a `NullPointerException`. This will prevent the server from starting when the routes folder is missing or misconfigured, but more dangerously, if this path is ever reached at runtime during a reload, it could crash the reloading thread silently.
**Evidence:**
```java
File confs = new File(configFolder);
String filename[] = confs.list();   // returns null if not a directory or I/O error
map = new HashMap<String, String>();
for (int i = 0; i < filename.length; i++) {   // NullPointerException if filename is null
```
**Recommendation:** Check `filename` for null before the loop and throw a descriptive `IllegalArgumentException` or `IOException`. Also verify that `confs.isDirectory()` is true before calling `list()`.

---

## A51-8

**File:** C:/Projects/cig-audit/repos/gmtpserver/src/gmtp/telnet/TelnetServer.java
**Line:** 51–60
**Severity:** Low
**Category:** Security > Error Handling > Recursive Retry / Stack Overflow
**Description:** The `start()` method catches `IOException` from `acceptor.bind()` and recursively calls `start()` again after a 5-second sleep. If the bind repeatedly fails (e.g., the port is permanently unavailable), this recursion will continue indefinitely, eventually causing a `StackOverflowError`. Additionally, the `InterruptedException` caught on line 57 is not re-interrupted (`Thread.currentThread().interrupt()` is not called), discarding the interrupt signal and potentially preventing a clean shutdown.
**Evidence:**
```java
} catch (IOException ex) {
    logger.error(ex.getMessage());
    try {
        Thread.currentThread().sleep(5000);
        start();          // recursive call — unbounded depth
        return true;
    } catch (InterruptedException ex1) {
        logger.error("cannot sleep Thread {}", ex1);
        // interrupt flag NOT restored
    }
    return false;
}
```
**Recommendation:** Replace the recursive retry with an iterative loop with a maximum retry count. Restore the thread interrupt flag on `InterruptedException`: `Thread.currentThread().interrupt()`. Log the full exception stack trace, not only the message.

---

## A51-9

**File:** C:/Projects/cig-audit/repos/gmtpserver/src/gmtp/telnet/TelnetMessageHandler.java
**Line:** 103
**Severity:** Low
**Category:** Security > Information Disclosure > Internal Exception Details
**Description:** When an exception is caught during Telnet command processing, the full exception object (including class name and message) is written back to the Telnet client: `"Invalid command: " + e`. For expected errors such as an unrecognised command name, `TelnetMessagecommand.valueOf()` throws `IllegalArgumentException: Unrecognized command: X` — that message is directly exposed. For unexpected internal errors this could reveal class names, internal paths, or library version information.
**Evidence:**
```java
} catch (Exception e) {
    session.write("Invalid command: " + e);
}
```
**Recommendation:** Write only a generic error message to the session (e.g., `"Error: unrecognised or invalid command"`). Log the full exception server-side via the logger. Do not expose `e.toString()` or `e.getMessage()` to the remote client.

---

## A51-10

**File:** C:/Projects/cig-audit/repos/gmtpserver/src/gmtp/XmlRoutingMap.java
**Line:** 33
**Severity:** Low
**Category:** Security > Path Traversal
**Description:** The `configFolder` value is passed in from the `Configuration` object (ultimately from a configuration file read at startup) and is used to construct file paths without any canonicalisation or validation. If the configuration source were compromised or if the configuration file could be written by an untrusted party, a path traversal value (e.g., `../../etc`) could cause the routing map loader to read XML files from arbitrary locations on the filesystem.
**Evidence:**
```java
public XmlRoutingMap(String folder) throws Exception {
    configFolder = folder;
    File confs = new File(configFolder);
    ...
    File current = new File(confs.getAbsolutePath() + "/" + filename[i]);
    XmlRoutes routes = serializer.read(XmlRoutes.class, current);
```
**Recommendation:** Validate the `configFolder` path using `File.getCanonicalPath()` and verify it falls within an expected base directory before use. This is a defence-in-depth measure given the value comes from a startup configuration file rather than direct user input.

---

## A51-11

**File:** C:/Projects/cig-audit/repos/gmtpserver/src/gmtp/telnet/TelnetServer.java
**Line:** 28
**Severity:** Low
**Category:** Security > Encapsulation > Public Field
**Description:** The `acceptor` field is declared `public` rather than `private`. This allows any class in the application to directly access and manipulate the MINA `SocketAcceptor`, including calling `unbind()`, changing the handler, or modifying the filter chain, without going through any controlled API. This is a defence-in-depth concern.
**Evidence:**
```java
public SocketAcceptor acceptor;
```
**Recommendation:** Declare the field `private` and expose only the necessary operations via public methods.

---

## A51-12

**File:** C:/Projects/cig-audit/repos/gmtpserver/src/gmtp/telnet/TelnetServer.java
**Line:** 31 and 34
**Severity:** Low
**Category:** Security > Concurrency > Static Field Written in Constructor
**Description:** `gmtpAcceptor` is declared `private static` but is written in the instance constructor (`this.gmtpAcceptor = gmtpAcceptor`). If more than one `TelnetServer` instance were ever constructed (even accidentally), the static field would be overwritten by the last constructor call, silently changing the acceptor reference for all users of `getGmtpAcceptor()`. This is a latent correctness and security issue.
**Evidence:**
```java
private static IoAcceptor gmtpAcceptor;   // line 31

public TelnetServer(IoAcceptor gmtpAcceptor, Configuration config) {
    this.gmtpAcceptor = gmtpAcceptor;     // line 34 — writes instance param into static field
```
**Recommendation:** If only one instance is intended, use the Singleton pattern or make `gmtpAcceptor` an instance field. Remove the static keyword, or make the constructor enforce single-instantiation.

---

## Summary Table

| ID | File | Line | Severity | Category |
|----|------|------|----------|----------|
| A51-1 | TelnetServer.java | 49 | High | Network Exposure — binds to 0.0.0.0 |
| A51-2 | TelnetMessageHandler.java | 79 | Medium | Authentication — per-connection brute-force reset |
| A51-3 | TelnetMessageHandler.java | 255 | High | Availability — unauthenticated KILLALL |
| A51-4 | TelnetMessageHandler.java | 203, 225 | High | Message Integrity — arbitrary device message injection |
| A51-5 | TelnetMessageHandler.java | 172–189 | Low | Information Disclosure — server metrics |
| A51-6 | XmlRoutingMap.java | 51 | Medium | Thread Safety — unsynchronised HashMap returned by reference |
| A51-7 | XmlRoutingMap.java | 31 | Medium | Error Handling — NullPointerException on missing routes folder |
| A51-8 | TelnetServer.java | 51–60 | Low | Error Handling — unbounded recursive retry / lost interrupt |
| A51-9 | TelnetMessageHandler.java | 103 | Low | Information Disclosure — exception details sent to client |
| A51-10 | XmlRoutingMap.java | 33 | Low | Path Traversal — unvalidated configFolder |
| A51-11 | TelnetServer.java | 28 | Low | Encapsulation — public SocketAcceptor field |
| A51-12 | TelnetServer.java | 31, 34 | Low | Concurrency — static field written in constructor |
