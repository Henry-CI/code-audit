# Security Audit Pass 1 — Agent A33
**Date:** 2026-02-28
**Branch:** master (verified via `git rev-parse --abbrev-ref HEAD`)
**Files audited:**
- `src/gmtp/GMTPRouter.java`
- `src/gmtp/GMTPServer.java`
- `src/gmtp/XmlConfiguration.java`

---

## Reading Evidence

### gmtp.GMTPRouter

**Fully qualified class name:** `gmtp.GMTPRouter`

**Imports:**
- `configuration.Configuration`
- `ftp.FTPServer`
- `gmtp.configuration.ConfigurationManager`
- `gmtp.configuration.DeniedPrefixesManager`
- `java.io.IOException`
- `java.sql.*`
- `java.util.HashMap`
- `org.apache.commons.dbcp.ConnectionFactory`
- `org.apache.commons.dbcp.DriverManagerConnectionFactory`
- `org.apache.commons.dbcp.PoolableConnectionFactory`
- `org.apache.commons.dbcp.PoolingDriver`
- `org.apache.commons.pool.impl.GenericObjectPool`
- `org.apache.ftpserver.ftplet.FtpException`
- `org.apache.log4j.PropertyConfigurator`
- `org.slf4j.Logger`
- `org.slf4j.LoggerFactory`
- `router.RoutingMap`
- `server.Server`

**Fields:**
- `private static Configuration config` (line 27)
- `private static RoutingMap routingMap` (line 31)
- `private static Server gmtpServer` (line 35)
- `public static FTPServer ftpServer` (line 39)
- `public static Boolean manageFtpConnections = false` (line 40)
- `private static Logger logger` (line 44)
- `public static ConfigurationManager gmtpConfigManager` (line 45)
- `private static boolean dbIsInit = false` (line 46)
- `public static String configPath` (line 47)
- `public static HashMap<Integer, String> deniedPrefixes` (line 48)
- `public static DeniedPrefixesManager deniedPrefixesManager` (line 49)

**Public methods:**
- `public static void main(String[] args)` — line 51
- `public static void initDatabases(Configuration config)` — line 184
- `public static boolean isEmpty(String string)` — line 326
- `public static boolean isNotEmpty(String string)` — line 330

**Interfaces implemented / classes extended:** none (extends Object implicitly)

---

### gmtp.GMTPServer

**Fully qualified class name:** `gmtp.GMTPServer`

**Imports:**
- `gmtp.codec.GMTPCodecFactory`
- `configuration.Configuration`
- `gmtp.configuration.ConfigurationManager`
- `gmtp.outgoing.OutgoingMessage`
- `gmtp.outgoing.OutgoingMessageManager`
- `gmtp.telnet.TelnetServer`
- `java.io.IOException`
- `java.net.InetSocketAddress`
- `java.util.HashMap`
- `java.util.Map`
- `org.apache.mina.core.service.IoAcceptor`
- `org.apache.mina.core.session.IoSession`
- `org.apache.mina.filter.codec.ProtocolCodecFilter`
- `org.apache.mina.filter.executor.ExecutorFilter`
- `org.apache.mina.transport.socket.SocketAcceptor`
- `org.apache.mina.transport.socket.SocketSessionConfig`
- `org.apache.mina.transport.socket.nio.NioSocketAcceptor`
- `org.slf4j.Logger`
- `org.slf4j.LoggerFactory`
- `server.Server`

**Fields:**
- `private SocketAcceptor acceptor` (line 34)
- `private final int port` (line 35)
- `private HashMap<String, String> routingMap` (line 36)
- `private OutgoingMessageManager outgoingMessageManager` (line 37)
- `private OutgoingMessageManager outgoingMessageResendManager` (line 38)
- `private TelnetServer telnetServer` (line 39)
- `private static Logger logger` (line 40)
- `private final ConfigurationManager configManager` (line 41)
- `private final int WriteBufferSize = 1024` (line 43)

**Methods:**
- `GMTPServer(ConfigurationManager configManager, HashMap<String, String> routingMap)` — package-private constructor, line 45
- `public boolean start()` — line 92
- `private boolean startTelnetServer(Configuration config)` — line 133

**Interfaces implemented:** `server.Server`

---

### gmtp.XmlConfiguration

**Fully qualified class name:** `gmtp.XmlConfiguration`

**Imports:**
- `configuration.Configuration`
- `org.simpleframework.xml.Attribute`
- `org.simpleframework.xml.Element`
- `org.simpleframework.xml.Root`

**Fields (all private, XML-mapped via Simple XML Framework annotations):**
- `@Attribute private String id`
- `@Element private int port`
- `@Element private int ioThreads`
- `@Element private int maxWorkerThreads`
- `@Element private String routesFolder`
- `@Element private String deniedPrefixesFile`
- `@Element private boolean tcpNoDelay`
- `@Element private int outgoingDelay`
- `@Element private int reloadConfigInterval`
- `@Element private int outgoingInterval`
- `@Element private int outgoingResendInterval`
- `@Element private String dbHost`
- `@Element private String dbName`
- `@Element private int dbPort`
- `@Element private String dbUser`
- `@Element private String dbPass`
- `@Element private String dbHostDefault`
- `@Element private String dbNameDefault`
- `@Element private int dbPortDefault`
- `@Element private String dbUserDefault`
- `@Element private String dbPassDefault`
- `@Element private int telnetPort`
- `@Element private String telnetUser`
- `@Element private String telnetPassword`
- `@Element private Boolean manageFTP`
- `@Element private Integer ftpPort`
- `@Element private String ftpUserFile`
- `@Element private String ftpRoot`
- `@Element private Integer ftpMaxConnection`
- `@Element private String ftpServer`
- `@Element private String ftpPassivePorts`
- `@Element private String ftpExternalAddr`
- `@Element private String ftpimagetype`
- `@Element private int connectionPoolSize`

**Public methods:**
- `public XmlConfiguration()` — line 81 (no-arg constructor)
- `public XmlConfiguration(String id, int port, int maxWorkerThreads, String routesFolder)` — line 85
- `public int getIoThreads()` — line 92
- `public String getIdentity()` — line 96
- `public int getMaxThreads()` — line 100
- `public int getPort()` — line 104
- `public String getRoutesFolder()` — line 108
- `public String getDeniedPrefixesFile()` — line 112
- `public boolean getTcpNoDelay()` — line 116
- `public int getOutgoingDelay()` — line 120
- `public int getReloadConfigInterval()` — line 124
- `public int getOutgoingInterval()` — line 128
- `public int getOutgoingResendInterval()` — line 132
- `public String getDbHost()` — line 136
- `public String getDbName()` — line 140
- `public String getDbPass()` — line 144
- `public int getDbPort()` — line 148
- `public String getDbUser()` — line 152
- `public String getTelnetPassword()` — line 156
- `public int getTelnetPort()` — line 160
- `public String getTelnetUser()` — line 164
- `public String getDbHostDefault()` — line 168
- `public String getDbNameDefault()` — line 172
- `public String getDbPassDefault()` — line 176
- `public int getDbPortDefault()` — line 180
- `public String getDbUserDefault()` — line 184
- `public boolean manageFTP()` — line 188
- `public Integer getFtpPort()` — line 192
- `public String getFtpUserFile()` — line 196
- `public String getFtpRoot()` — line 200
- `public Integer getFtpMaxConnection()` — line 204
- `public String getFtpServer()` — line 208
- `public String getFtpPassivePorts()` — line 212
- `public String getFtpExternalAddr()` — line 216
- `public String getFtpimagetype()` — line 220
- `public int getConnectionPoolSize()` — line 224

**Interfaces implemented:** `configuration.Configuration`

---

## Checklist Review

### Server binding and network security

- **Binding interface (0.0.0.0):** `GMTPServer.start()` at line 94 calls `acceptor.bind(new InetSocketAddress(this.port))`. Using `InetSocketAddress(int port)` with only a port (no host) binds to the wildcard address `0.0.0.0`, meaning all network interfaces. No IP allowlisting is performed at the acceptor level. **Issue found — see A33-1.**
- **IP allowlisting / connection rate limiting:** No IP allowlisting or rate limiting is present anywhere in the three files. No MINA filter for IP-based access control is added to the filter chain. **Issue found — see A33-2.**
- **TLS/SSL:** The MINA filter chain in `GMTPServer` constructor adds only an `ExecutorFilter` and a `ProtocolCodecFilter`. There is no `SslFilter` added. All communication is plaintext TCP. **Issue found — see A33-3.**
- **Hardcoded ports or addresses:** No hardcoded ports or addresses were found in the three files; port is read from configuration. No issue.

### Configuration loading

- **Hardcoded credentials or secrets:** No hardcoded credentials in initialization code. Credentials are loaded from configuration XML. No issue in these files.
- **Config file path — user-controllable:** The `gmtpConfig` path is taken from a JVM system property (`System.getProperty("gmtpConfig")`) at line 55. An operator starting the process controls `-DgmtpConfig`. The path is used directly at line 63 (`PropertyConfigurator.configure(configPath + "/log4j.properties")`) without any validation or canonicalization. An operator-supplied path with path-traversal characters would be accepted. For a privileged operator this is a lower severity concern, but the code performs no sanitization. **Issue found — see A33-4.**
- **XXE injection in XML parsing:** `XmlConfiguration` uses the Simple XML Framework (SimpleXML) with `@Root`, `@Element`, `@Attribute` annotations. SimpleXML uses an underlying SAX/DOM parser. Whether XXE is enabled depends on the framework version and how the `Serializer` is instantiated (not visible in these three files). The risk exists if the XML parser is not configured to disable external entity resolution. This is noted as a concern to flag; the definitive instantiation is in `ConfigurationManager` (not audited here). **Partial concern — see A33-5.**
- **Path traversal in config file paths:** The `configPath` system property is used without normalization at line 63. See A33-4.

### Main entry point (GMTPRouter)

- **Command-line argument handling:** The `main` method at line 51 accepts `String[] args` but never uses `args`. Configuration is loaded from the system property `gmtpConfig`. No unsanitized command-line args are used. No issue.
- **Hardcoded secrets in main class:** None found. No issue.
- **Improper exception handling revealing sensitive info:** `loadConfiguration` at line 138 logs `ex.getMessage()` at DEBUG level. If the message contains a file path or DB credentials from the configuration system, those would appear in debug logs. Lower severity. **Issue found — see A33-6.**
- **Denied prefixes failure is silently swallowed:** At lines 88-95, a failure to load the denied prefix list results in an empty HashMap and a DEBUG-only log message ("Cannot load the denied customers"). This means that if the denied-customer file is missing or corrupted, all previously denied customers will be permitted to connect with no operator-visible warning. **Issue found — see A33-7.**

### Thread and concurrency safety

- **Shared mutable state without synchronization:** Several `public static` fields in `GMTPRouter` are written during startup and read by other threads without synchronization: `ftpServer` (line 39), `manageFtpConnections` (line 40), `gmtpConfigManager` (line 45), `configPath` (line 47), `deniedPrefixes` (line 48), `deniedPrefixesManager` (line 49). None of these are `volatile` or accessed via synchronized blocks. While most are written only once during startup, the Java Memory Model does not guarantee visibility without proper synchronization. **Issue found — see A33-8.**
- **`dbIsInit` flag — synchronization:** `setDBInitialized()` and `getDBInitialized()` are properly `synchronized`. However the polling loop at lines 167-174 calls `Thread.sleep(1000)` then reads the flag. The synchronized wrappers are correct, so this is acceptable. No issue.
- **Race condition in server initialization:** `loadConfiguration` polls `config` in a spin-sleep loop (lines 133-136) relying on `config` being a `static` field assigned by another thread with no `volatile` or synchronization. The Java Memory Model does not guarantee the writing thread's value will be seen. **Issue found — see A33-9.**

### Error handling

- **Swallowed exceptions during startup:**
  - `loadRoutingMap` at line 154 catches all `Exception` and returns `false` without logging the exception message or stack trace. The root cause of routing-map load failures is silently discarded. **Issue found — see A33-10.**
  - `initDatabases` at lines 309-311 logs `ex.getMessage()` at DEBUG level for exceptions thrown when reading the customers/branches table; this may suppress visibility of database errors in production (where DEBUG is often disabled). **Issue found — see A33-11.**
- **Startup failures leaking sensitive info:** `initDatabases` at lines 222 and 259 logs database host information at INFO/DEBUG level (`"Init database (host: " + dbhost + ")"`) which, while useful for diagnostics, could expose internal network topology in log files. **Issue found — see A33-12.**

### General Java security

- **Command injection (Runtime.exec / ProcessBuilder):** Not present in any of the three files. No issue.
- **Deserialization of untrusted data (ObjectInputStream.readObject):** Not present in any of the three files. No issue.
- **SQL injection:** In `initDatabases`, the queries at lines 229 and 268 are hard-coded string literals with no user input concatenated — they are safe static queries. No SQL injection risk in these three files.

### Additional findings

- **Credentials stored in plaintext XML:** `XmlConfiguration` stores `dbPass`, `dbPassDefault`, and `telnetPassword` as plaintext `@Element` fields (lines 42, 51, 58). There is no mention of encryption or masking. Any party with read access to the XML configuration file obtains full database credentials and the telnet admin password. **Issue found — see A33-13.**
- **Telnet admin interface with no mention of access control:** `GMTPServer` starts a `TelnetServer` unconditionally (line 87). The `TelnetServer` binds on `telnetPort` and accepts credentials from the plaintext XML configuration. There is no evidence of TLS on the telnet interface. Credentials and session data transit over the network in plaintext. **Issue found — see A33-14.**
- **`Runtime.getRuntime().halt(0)` in shutdown hook:** Line 122 calls `Runtime.getRuntime().halt(0)` which forcibly terminates the JVM, bypassing any remaining shutdown hooks and `finally` blocks. This prevents orderly cleanup and could leave resources in inconsistent state. It also prevents other shutdown hooks (e.g., security frameworks) from running. **Issue found — see A33-15.**

---

## Findings

## A33-1

**File:** src/gmtp/GMTPServer.java
**Line:** 94
**Severity:** High
**Category:** Security > Network Exposure
**Description:** The MINA acceptor is bound using `new InetSocketAddress(this.port)` which, when given only a port and no host, binds to the wildcard address `0.0.0.0`. This means the server accepts connections on all available network interfaces, including any public-facing ones, with no restriction at the network layer inside the application.
**Evidence:**
```java
acceptor.bind(new InetSocketAddress(this.port));
```
**Recommendation:** Bind to a specific interface address by passing both a host and a port: `new InetSocketAddress("127.0.0.1", this.port)` or a configurable bind address. If binding to all interfaces is required, supplement with an IP allowlist filter in the MINA filter chain.

---

## A33-2

**File:** src/gmtp/GMTPServer.java
**Line:** 54–55
**Severity:** High
**Category:** Security > Missing Access Control
**Description:** The MINA filter chain adds only an `ExecutorFilter` and a `ProtocolCodecFilter`. There is no IP allowlist filter, no connection-rate-limiting filter, and no authentication at the transport layer. Any host on any reachable network can open an unlimited number of connections to the server.
**Evidence:**
```java
acceptor.getFilterChain().addLast("executor", new ExecutorFilter(config.getMaxThreads()));
acceptor.getFilterChain().addLast("codec", new ProtocolCodecFilter(new GMTPCodecFactory(false, routingMap)));
```
**Recommendation:** Add an IP-based allowlist filter (e.g., a custom MINA `IoFilter` or firewall rules) and consider adding connection-rate limiting to prevent resource exhaustion attacks.

---

## A33-3

**File:** src/gmtp/GMTPServer.java
**Line:** 54–55
**Severity:** High
**Category:** Security > Missing Encryption (No TLS)
**Description:** The MINA filter chain does not include `SslFilter`. All data transmitted between clients and the server, including any authentication material and GMTP messages, is sent in plaintext over TCP. This allows network-level interception and man-in-the-middle attacks.
**Evidence:**
```java
acceptor.getFilterChain().addLast("executor", new ExecutorFilter(config.getMaxThreads()));
acceptor.getFilterChain().addLast("codec", new ProtocolCodecFilter(new GMTPCodecFactory(false, routingMap)));
// No SslFilter present
```
**Recommendation:** Add `org.apache.mina.filter.ssl.SslFilter` to the filter chain as the first filter, configured with a properly managed `SSLContext` loaded from a keystore.

---

## A33-4

**File:** src/gmtp/GMTPRouter.java
**Line:** 55, 63
**Severity:** Medium
**Category:** Security > Path Traversal / Unvalidated Input
**Description:** The configuration directory path is taken directly from the JVM system property `gmtpConfig` without any validation, canonicalization, or boundary check. The same unsanitized value is then used to construct the log4j configuration file path. An operator who can control JVM arguments could supply a path containing traversal sequences (e.g., `../../etc`) to redirect configuration loading to arbitrary filesystem locations.
**Evidence:**
```java
configPath = System.getProperty("gmtpConfig");
...
PropertyConfigurator.configure(configPath + "/log4j.properties");
```
**Recommendation:** Resolve `configPath` to a canonical path using `new File(configPath).getCanonicalPath()` and optionally verify it is within an expected base directory before use.

---

## A33-5

**File:** src/gmtp/XmlConfiguration.java
**Line:** 1–9
**Severity:** Medium
**Category:** Security > XML External Entity (XXE) Injection
**Description:** `XmlConfiguration` is deserialized from XML using the Simple XML Framework. Depending on the underlying SAX/DOM parser configuration used by the framework (set in `ConfigurationManager`, which is not among the audited files), external entity resolution may be enabled by default. If so, a maliciously crafted configuration XML file could use an external entity reference to read arbitrary files from the server filesystem or trigger server-side request forgery.
**Evidence:**
```java
@Root(name = "configuration")
public class XmlConfiguration implements Configuration {
    // deserialized from XML by ConfigurationManager using Simple XML Framework
```
**Recommendation:** Ensure the XML parser used by Simple XML is configured with `XMLInputFactory.IS_SUPPORTING_EXTERNAL_ENTITIES = false` and `XMLInputFactory.SUPPORT_DTD = false`, or use a framework version that disables external entity resolution by default.

---

## A33-6

**File:** src/gmtp/GMTPRouter.java
**Line:** 138
**Severity:** Low
**Category:** Security > Information Disclosure via Logging
**Description:** When configuration loading fails, the exception message is logged at DEBUG level. Exception messages from configuration or database initialization code may contain file paths, hostnames, or other sensitive environmental details. DEBUG logging is sometimes enabled in production for diagnostics.
**Evidence:**
```java
} catch (Exception ex) {
    logger.debug("Config Error: " + ex.getMessage());
    return false;
}
```
**Recommendation:** Log at WARN or ERROR level so the failure is always visible, but consider sanitizing or abbreviating the message to avoid leaking path or credential information. Use `logger.error("Config Error", ex)` to include the full stack trace at the appropriate level.

---

## A33-7

**File:** src/gmtp/GMTPRouter.java
**Line:** 88–95
**Severity:** High
**Category:** Security > Fail-Open Behavior (Security Control Bypass)
**Description:** If the denied-prefixes list fails to load (missing file, parse error, or any exception), the code silently substitutes an empty `HashMap` and logs only at DEBUG level. This means all customers that should be denied are permitted to connect. The failure of a security control (the customer deny-list) causes the system to fail open rather than fail closed, and operators may not be aware the deny-list is inactive.
**Evidence:**
```java
try {
    loadDeniedPrefixes();
} catch (Exception e) {
    // no big deal, just let the log know and create a empty hashMap
    // so we can get going
    deniedPrefixes = new HashMap<Integer, String>();
    logger.debug("Cannot load the denied customers");
}
```
**Recommendation:** Log at ERROR or WARN level so the failure is visible regardless of log level configuration. Consider whether the server should refuse to start or alert an operator when the deny-list cannot be loaded, rather than silently failing open.

---

## A33-8

**File:** src/gmtp/GMTPRouter.java
**Line:** 39–49
**Severity:** Medium
**Category:** Security > Thread Safety / Visibility
**Description:** Multiple `public static` fields (`ftpServer`, `manageFtpConnections`, `gmtpConfigManager`, `configPath`, `deniedPrefixes`, `deniedPrefixesManager`) are written by the main thread during startup and read by worker threads or daemon threads without being declared `volatile` and without synchronized access. The Java Memory Model does not guarantee that writes made by one thread are visible to other threads without a happens-before relationship established by synchronization or volatile semantics.
**Evidence:**
```java
public static FTPServer ftpServer;
public static Boolean manageFtpConnections = false;
public static ConfigurationManager gmtpConfigManager;
public static String configPath;
public static HashMap<Integer, String> deniedPrefixes;
public static DeniedPrefixesManager deniedPrefixesManager;
```
**Recommendation:** Declare these fields `volatile`, or access them through synchronized methods, or use `java.util.concurrent` atomic/concurrent types to ensure correct cross-thread visibility.

---

## A33-9

**File:** src/gmtp/GMTPRouter.java
**Line:** 27, 133–136
**Severity:** Medium
**Category:** Security > Thread Safety / Race Condition
**Description:** The `loadConfiguration` method polls the `static` field `config` in a spin-sleep loop. The field is assigned by a background thread (`ConfigurationManager`) but is not declared `volatile`. Without a `volatile` or `synchronized` guarantee, the polling thread may cache a stale `null` value indefinitely, or the assignment from the background thread may not be visible, leading to either an infinite loop or a missed update. The same unsynchronized field is then used throughout startup.
**Evidence:**
```java
private static Configuration config; // not volatile
...
while (config == null) {
    config = gmtpConfigManager.getConfiguration();
    Thread.currentThread().sleep(100);
}
```
**Recommendation:** Declare `config` as `volatile`, or use a `java.util.concurrent.atomic.AtomicReference`, or use a `CountDownLatch`/`Future` to signal when configuration is available.

---

## A33-10

**File:** src/gmtp/GMTPRouter.java
**Line:** 152–157
**Severity:** Medium
**Category:** Security > Error Handling / Information Loss
**Description:** The `loadRoutingMap` method catches all exceptions and returns `false` without logging the exception or its message. The root cause of a routing-map load failure is completely discarded, making it impossible to diagnose misconfigurations, file permission problems, or XML parse errors that could indicate a tampered or corrupted routing map.
**Evidence:**
```java
private static boolean loadRoutingMap(String folder) {
    try {
        routingMap = new XmlRoutingMap(folder);
    } catch (Exception ex) {
        return false;
    }
    return true;
}
```
**Recommendation:** Log the exception at ERROR level before returning false: `logger.error("Failed to load routing map from folder: {}", folder, ex);`

---

## A33-11

**File:** src/gmtp/GMTPRouter.java
**Line:** 309–311
**Severity:** Low
**Category:** Security > Error Handling / Insufficient Logging
**Description:** When reading the customers or branches table fails, the exception message is logged at DEBUG level before logging a generic error at ERROR level. In production environments where DEBUG is disabled, the specific cause of the database read failure will not be recorded, hindering incident response.
**Evidence:**
```java
} catch (Exception ex) {
    logger.debug(ex.getMessage());
    logger.error("Cannot read customers or branches table");
}
```
**Recommendation:** Log the full exception (including stack trace) at ERROR level: `logger.error("Cannot read customers or branches table", ex);`

---

## A33-12

**File:** src/gmtp/GMTPRouter.java
**Line:** 222, 259, 299
**Severity:** Low
**Category:** Security > Information Disclosure via Logging
**Description:** The `initDatabases` method logs internal database host addresses and database names at INFO level. Log files are frequently shipped to centralized logging infrastructure or third-party SIEM systems, and this information could be used to map internal network topology if logs are exposed.
**Evidence:**
```java
logger.debug("Init database (defaultDb :" + config.getDbNameDefault() + "): " + config.getDbHostDefault() + "\t OK");
...
logger.info("Init database (host: " + dbhost + ")(" + prefix + "): " + dbname + "\t OK");
...
logger.info("Init branched database (host: " + dbhost + ")(" + prefix + "): " + dbname + "\t OK");
```
**Recommendation:** Consider logging database host information at DEBUG level only, or mask/shorten host addresses in log output to reduce information exposure.

---

## A33-13

**File:** src/gmtp/XmlConfiguration.java
**Line:** 42, 51, 58
**Severity:** High
**Category:** Security > Plaintext Credentials in Configuration
**Description:** The XML configuration schema stores database passwords (`dbPass`, `dbPassDefault`) and the telnet admin password (`telnetPassword`) as plaintext XML elements. Any party with read access to the configuration file obtains full credentials for the primary database, the default database, and the administrative telnet interface.
**Evidence:**
```java
@Element
private String dbPass;       // line 42
...
@Element
private String dbPassDefault; // line 51
...
@Element
private String telnetPassword; // line 58
```
**Recommendation:** Use an external secrets manager (e.g., HashiCorp Vault, AWS Secrets Manager) or at minimum an encrypted credential store. Passwords should not be stored in plaintext in configuration files accessible on the filesystem. If file-based storage is required, encrypt the values and decrypt at runtime using a key stored separately (e.g., in an environment variable or hardware security module).

---

## A33-14

**File:** src/gmtp/GMTPServer.java
**Line:** 87–89, 133–136
**Severity:** High
**Category:** Security > Insecure Administrative Interface
**Description:** A `TelnetServer` is started unconditionally for every server instance. Telnet is an inherently insecure protocol: credentials and all session data are transmitted in plaintext. The telnet credentials (`telnetUser`, `telnetPassword`) are stored in plaintext XML (see A33-13). An attacker who can intercept network traffic between an administrator and the server will obtain admin credentials and can observe or replay administrative commands.
**Evidence:**
```java
if (!startTelnetServer(config)) {
    logger.error("Cannot start telnet server");
}
...
private boolean startTelnetServer(Configuration config) {
    telnetServer = new TelnetServer(acceptor, config);
    return telnetServer.start();
}
```
**Recommendation:** Replace the telnet administrative interface with an SSH-based interface (e.g., Apache MINA SSHD). If a telnet interface must be retained for compatibility, restrict it to loopback (`127.0.0.1`) only and document that it must not be exposed to any network.

---

## A33-15

**File:** src/gmtp/GMTPServer.java
**Line:** 122
**Severity:** Medium
**Category:** Security > Improper Shutdown / Resource Management
**Description:** The shutdown hook calls `Runtime.getRuntime().halt(0)`, which immediately terminates the JVM without executing any further shutdown hooks or `finally` blocks. This bypasses any security-related shutdown logic that may exist in other components (e.g., auditing frameworks, connection pool draining, or other registered shutdown hooks). It also prevents MINA from gracefully draining in-flight messages.
**Evidence:**
```java
Runtime.getRuntime().halt(0);
```
**Recommendation:** Replace `Runtime.getRuntime().halt(0)` with a normal return from the shutdown hook thread. The JVM will exit naturally once all non-daemon threads have completed and all shutdown hooks have run. If a forced exit is truly needed after the hook completes, use `System.exit(0)` which still runs remaining hooks, but note that `halt` from within a hook is almost never the correct pattern.
