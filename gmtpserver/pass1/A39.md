# Security Audit Pass 1 — Agent A39
**Date:** 2026-02-28
**Branch:** master (confirmed via `git rev-parse --abbrev-ref HEAD`)
**Assigned files:**
- `src/gmtp/XmlRoutingMap.java`
- `src/gmtp/codec/GMTPCodecFactory.java`
- `src/gmtp/codec/GMTPRequestDecoder.java`

---

## Reading Evidence

### 1. `gmtp.XmlRoutingMap`

**Fully qualified class name:** `gmtp.XmlRoutingMap`

**Implements:** `router.RoutingMap`

**Fields:**
- `private HashMap<String, String> map` (line 21)
- `private String configFolder = "./routes"` (line 22)
- `private Serializer serializer = new Persister()` (line 23)
- `private static Logger logger = LoggerFactory.getLogger(GMTPRouter.class)` (line 24)

**Public methods:**
| Return type | Name | Parameters | Line |
|---|---|---|---|
| (constructor) | `XmlRoutingMap` | `String folder` | 26 |
| `void` | `buildDefaultConfiguration` | none | 41 |
| `HashMap<String,String>` | `getMap` | none | 51 |

**Imports:**
- `java.io.File`
- `java.util.HashMap`
- `org.simpleframework.xml.Serializer`
- `org.simpleframework.xml.core.Persister`
- `org.slf4j.Logger`
- `org.slf4j.LoggerFactory`
- `router.RoutingMap`

---

### 2. `gmtp.codec.GMTPCodecFactory`

**Fully qualified class name:** `gmtp.codec.GMTPCodecFactory`

**Implements:** `org.apache.mina.filter.codec.ProtocolCodecFactory`

**Fields:**
- `private ProtocolEncoder encoder` (line 19)
- `private ProtocolDecoder decoder` (line 20)

**Public methods:**
| Return type | Name | Parameters | Line |
|---|---|---|---|
| (constructor) | `GMTPCodecFactory` | `boolean client` | 22 |
| (constructor) | `GMTPCodecFactory` | `boolean client, HashMap<String,String> routingMap` | 32 |
| `ProtocolEncoder` | `getEncoder` | `IoSession ioSession` | 42 |
| `ProtocolDecoder` | `getDecoder` | `IoSession ioSession` | 46 |

**Imports:**
- `java.util.HashMap`
- `org.apache.mina.core.session.IoSession`
- `org.apache.mina.filter.codec.ProtocolCodecFactory`
- `org.apache.mina.filter.codec.ProtocolDecoder`
- `org.apache.mina.filter.codec.ProtocolEncoder`

---

### 3. `gmtp.codec.GMTPRequestDecoder`

**Fully qualified class name:** `gmtp.codec.GMTPRequestDecoder`

**Extends:** `org.apache.mina.filter.codec.CumulativeProtocolDecoder`

**Fields:**
- `private static final short PDU_ID = 0x0001` (line 25)
- `private static final short PDU_DATA = 0x0002` (line 26)
- `private static final short PDU_ID_EXT = 0x0003` (line 27)
- `private static final short PDU_DATA_EXT = 0x0004` (line 28)
- `private static final short PDU_ACK = 0x0005` (line 29)
- `private static final short PDU_ERROR = 0x0006` (line 30)
- `private static final short PDU_CLOSED = 0x0007` (line 32, @SuppressWarnings("unused"))
- `private static final short PDU_PROTO_VER = 0x0008` (line 33)
- `private static final short PDU_BEGIN_TRANSACTION = 0x0009` (line 34)
- `private static final short PDU_END_TRANSACTION = 0x000A` (line 35)
- `private static final short PDU_NAK = 0x000D` (line 36)
- `private static Logger logger` (line 37)
- `private HashMap<String, String> routingMap = new HashMap<>()` (line 38)

**Public methods:**
| Return type | Name | Parameters | Line |
|---|---|---|---|
| (constructor) | `GMTPRequestDecoder` | `HashMap<String,String> routingMap` | 40 |
| (constructor) | `GMTPRequestDecoder` | none | 44 |
| `protected boolean` | `doDecode` | `IoSession, IoBuffer, ProtocolDecoderOutput` | 49 |
| `private Type` | `decodeMessageType` | `int type` | 113 |

**Imports:**
- `gmtp.GMTPMessage`
- `gmtp.GMTPMessage.Type`
- `java.nio.charset.Charset`
- `java.nio.charset.CharsetDecoder`
- `java.util.HashMap`
- `org.apache.mina.core.buffer.IoBuffer`
- `org.apache.mina.core.session.IoSession`
- `org.apache.mina.filter.codec.CumulativeProtocolDecoder`
- `org.apache.mina.filter.codec.ProtocolDecoderOutput`
- `org.slf4j.Logger`
- `org.slf4j.LoggerFactory`

---

## Checklist Evaluation

### Binary Protocol Decoder Security (GMTPRequestDecoder)

**Bounds check on message length fields:** ISSUE FOUND — see A39-1.
The decoder reads `dataLen` from the wire but then calls `in.getString(in.remaining(), decoder)` rather than `in.getString(dataLen, decoder)`. This means it consumes ALL remaining bytes in the cumulative buffer, not just `dataLen` bytes, silently overreading and making it impossible to frame subsequent messages correctly. Both the standard path (line 98) and the extended path (line 82) have this defect.

**Integer overflow in length arithmetic:** Not applicable — lengths are decoded as 16-bit big-endian unsigned values (max 65535). No arithmetic is performed that could overflow a Java int.

**Unbounded memory allocation based on attacker-controlled length fields:** ISSUE FOUND — see A39-2.
`dataLen` is a 16-bit field (max 65535 bytes). MINA's `CumulativeProtocolDecoder` will buffer incoming bytes until `in.remaining() >= dataLen`. An attacker can send a header with `dataLen = 65535` followed by no payload bytes. The server will accumulate up to 65535 bytes of heap-buffered data per connection before acting. With many concurrent connections this constitutes a denial-of-service memory amplification vector. There is no configured maximum.

**Negative length values:** Not present as a distinct risk here. `dataLen` is computed from two bytes using unsigned masking (`0xFF & in.get()`), so the resulting int is always in the range [0, 65535]. No negative values can occur.

**Partial/fragmented messages:** Handled correctly — `CumulativeProtocolDecoder` accumulates bytes and `doDecode` returns `false` when insufficient data is available, causing MINA to wait for more data.

**Malformed messages cause session close or infinite loop:** ISSUE FOUND — see A39-3.
`decodeMessageType` returns `Type.ERROR` for any unrecognised type code, including `PDU_BEGIN_TRANSACTION` (0x0009) which is defined as a constant but absent from the switch statement. A message with type `ERROR` or an unknown type is decoded and passed upstream rather than rejected and the session closed. More critically, the standard path only requires `in.remaining() >= 4` to begin parsing. If a malformed packet has a recognized type byte but incorrect structure (e.g., an extended-type packet with < 6 bytes available), the decoder reads past the type bytes into potentially absent ID/length bytes before hitting the `in.remaining() >= dataLen` guard — but MINA's `CumulativeProtocolDecoder` does not protect against reads of the intermediate fields (`idHigh`, `idLow`, `lengthHigh`, `lengthLow`) on lines 66-74. If fewer than 6 bytes are in the buffer when an extended type is detected, an `BufferUnderflowException` will be thrown. This exception propagates out of `doDecode`, is caught by MINA, and closes the session — so there is no infinite loop, but it means error handling for extended-type partial messages is by accident (exception) rather than by design.

### Routing Map Security (XmlRoutingMap)

**Thread safety:** ISSUE FOUND — see A39-4.
`XmlRoutingMap.map` is a plain `HashMap<String,String>`. The map is populated in the constructor (single thread, safe). `getMap()` returns the raw `HashMap` reference directly. In `GMTPCodecFactory`, the same `HashMap` instance is passed to a single shared `GMTPRequestDecoder` instance (not per-session). MINA's NIO acceptor dispatches I/O events across multiple threads via the `ExecutorFilter`. If any code path were to mutate the map (e.g., route reload), concurrent reads from different I/O threads combined with a write would cause `ConcurrentModificationException` or data corruption. Even without mutation, returning the mutable internal `HashMap` reference exposes it to external modification.

**Route poisoning (fraudulent insertion):** ISSUE FOUND — see A39-5.
`getMap()` returns the live, mutable `HashMap` reference (not a defensive copy or unmodifiable view). Any caller that receives this reference can insert, modify, or delete routing entries, potentially redirecting all subsequent messages.

**SSRF — are route destinations validated:** ISSUE FOUND (in downstream code, triggered by XmlRoutingMap configuration).
Route values loaded from XML files become the command arguments passed to `ProcessBuilder` in `GMTPMessage.callFilter()` (GMTPMessage.java line 187). The routing XML files are loaded from the filesystem without sanitising the command strings they contain. A malicious or tampered XML routing file can cause arbitrary OS command execution (see A39-6, reported under XmlRoutingMap because the root cause is there).

### Codec Factory Security (GMTPCodecFactory)

**Hardcoded protocol parameters:** No protocol version number, port, or other security-critical parameters are hardcoded inside `GMTPCodecFactory` itself — port and threads are pulled from configuration. No findings.

**Protocol downgrade attacks:** ISSUE FOUND — see A39-7.
When `GMTPCodecFactory` is constructed with `client = true`, both `encoder` and `decoder` are set to `null` (lines 24-25, 34-35). `getDecoder()` returns `null` in this case. The MINA framework will throw a `NullPointerException` if this factory is ever used for an actual client-side session, silently degrading to no protocol handling. There is no guard or exception at construction time to prevent this misconfiguration. Additionally, `GMTPRequestDecoder` does not enforce or validate any protocol version field (`PDU_PROTO_VER = 0x0008` is decoded only to `Type.PROTOCOL_VERSION` but there is no version check logic visible); a client could silently use a downgraded protocol.

**Shared decoder instance:** ISSUE FOUND — see A39-8.
`GMTPCodecFactory` constructs one `GMTPRequestDecoder` instance at factory-creation time and returns the same instance from every `getDecoder(IoSession)` call. `CumulativeProtocolDecoder` maintains per-session state internally (via the session's attribute map), so the stateless fields of `GMTPRequestDecoder` are safe. However, the `routingMap` `HashMap` field is shared across all sessions without synchronisation, compounding the thread-safety issue described in A39-4.

### Error Handling

**Swallowed exceptions in decoding:** No exceptions are explicitly caught and swallowed inside `doDecode`. Exceptions propagate to MINA, which closes the session. No finding.

**Buffer underflow/overflow:** Partially handled. The initial `if (in.remaining() >= 4)` guard prevents underflow for the type bytes. However, for extended-type messages, intermediate bytes (id and length fields, lines 66-74) are read without checking that at least 6 bytes remain, relying on a thrown exception rather than a defensive check. This is a design flaw (A39-3, above).

### General Java Security

**Command injection (Runtime.exec / ProcessBuilder):** ISSUE FOUND — see A39-6 (in `GMTPMessage.callFilter()`). The route command strings loaded from XML are split on commas and passed directly as `ProcessBuilder` arguments. While `ProcessBuilder` with a list avoids shell expansion, the command path itself (first element, `cds[i]`) is fully attacker-controlled if a routing file is tampered with, constituting an arbitrary code execution path.

**Deserialization of untrusted data (ObjectInputStream):** Not present in the three assigned files. No finding.

**SQL injection:** Not present in the three assigned files. No finding.

---

## Findings

## A39-1

**File:** src/gmtp/codec/GMTPRequestDecoder.java
**Line:** 82 and 98
**Severity:** High
**Category:** Security > Protocol Framing / Buffer Over-Read
**Description:** In both the extended-type path (line 82) and the standard-type path (line 98), the decoder calls `in.getString(in.remaining(), decoder)` — consuming ALL remaining bytes in the cumulative buffer — rather than `in.getString(dataLen, decoder)`. The wire-supplied `dataLen` field is checked only to confirm that at least that many bytes are present, but then discarded when actually reading the string. This means every message consumes the entire buffer, making it impossible to correctly frame subsequent messages in the same TCP stream. An attacker can exploit this to cause messages to bleed into one another, producing garbled `GMTPMessage` objects or skipping messages entirely.
**Evidence:**
```java
// Line 81-82 (extended path):
if (in.remaining() >= dataLen) {
    String msgStr = in.getString(in.remaining(), decoder);

// Line 97-98 (standard path):
if (in.remaining() >= dataLen) {
    String msgStr = in.getString(in.remaining(), decoder);
```
**Recommendation:** Replace `in.remaining()` with `dataLen` in both `getString` calls so that exactly `dataLen` bytes are consumed from the buffer per message, allowing subsequent messages to be decoded correctly.

---

## A39-2

**File:** src/gmtp/codec/GMTPRequestDecoder.java
**Line:** 77 and 93
**Severity:** Medium
**Category:** Security > Denial of Service / Unbounded Memory Allocation
**Description:** The 16-bit `dataLen` field (maximum 65535) is attacker-controlled. The `CumulativeProtocolDecoder` base class will accumulate up to `dataLen` bytes per session on the heap before `doDecode` can proceed. There is no configured upper bound on `dataLen`, no per-session accumulation cap, and no limit on concurrent sessions. An attacker can open many TCP connections, each sending a header with `dataLen = 0xFFFF` and then sending no further data, causing the server to hold up to 65535 bytes of heap-buffered data per connection indefinitely until the connection is closed. At scale this exhausts heap memory.
**Evidence:**
```java
int dataLen = (lengthHigh << 8) + lengthLow;
// ...
if (in.remaining() >= dataLen) {
```
No maximum value check is applied to `dataLen` before this guard.
**Recommendation:** Enforce a configurable maximum message length (e.g., 4096 or 8192 bytes). If `dataLen` exceeds this limit, close the session immediately rather than waiting for the data to arrive. Also consider configuring a maximum number of concurrent sessions at the `NioSocketAcceptor` level.

---

## A39-3

**File:** src/gmtp/codec/GMTPRequestDecoder.java
**Line:** 64-74
**Severity:** Medium
**Category:** Security > Error Handling / Missing Bounds Check on Extended Header
**Description:** When the decoded message type is `ID_EXT`, `DATA_EXT`, or `ACK`, the decoder enters the extended-type branch and immediately reads four additional bytes (two for ID, two for length) without first verifying that at least 6 bytes are available in the buffer (2 type bytes already consumed + 2 ID bytes + 2 length bytes). If a partial extended-type header arrives (e.g., only 4 or 5 bytes), `in.get()` will throw a `BufferUnderflowException`. The session is then closed by MINA's exception handler, which is the correct outcome, but the defence is entirely accidental — no explicit guard exists. This also means that the position is not reset to `start` before the exception propagates, so the partial header bytes cannot be retried correctly by the cumulative decoder.
**Evidence:**
```java
if(msgType == Type.ID_EXT || msgType == Type.DATA_EXT || msgType == Type.ACK)
{
    int idHigh = 0xFF & (int) in.get();   // line 66 — no remaining() check
    int idLow  = 0xFF & (int) in.get();   // line 67
    // ...
    int lengthHigh = 0xFF & (int) in.get(); // line 73
    int lengthLow  = 0xFF & (int) in.get(); // line 74
```
The outer guard on line 54 only ensures `in.remaining() >= 4`, not `>= 6`.
**Recommendation:** Before entering the extended-type branch, check `if (in.remaining() >= 6)` (or `>= 4` after consuming the type bytes, i.e., `in.remaining() >= 4` at the point of the inner reads). If insufficient bytes are available, reset `in.position(start)` and return `false` to allow the cumulative decoder to wait for more data, matching the pattern already used at lines 105-109.

---

## A39-4

**File:** src/gmtp/XmlRoutingMap.java
**Line:** 21 and 51
**Severity:** High
**Category:** Security > Thread Safety / Unsynchronised Shared State
**Description:** `XmlRoutingMap` stores the routing table as a plain `java.util.HashMap`. The `getMap()` method returns the live, internal `HashMap` reference. This reference is passed into `GMTPCodecFactory` and stored directly in the single shared `GMTPRequestDecoder` instance (see `GMTPCodecFactory` lines 38, 47). MINA's `ExecutorFilter` dispatches message-handling events across a thread pool. If the routing map is ever reloaded or modified (e.g., by a configuration manager or admin command) while I/O threads are iterating over it, a `ConcurrentModificationException` or silent data corruption will occur. Even without a reload, the mutable reference itself is unsafe to share without synchronisation.
**Evidence:**
```java
// XmlRoutingMap.java line 21, 51:
private HashMap<String, String> map;
// ...
public HashMap<String, String> getMap() {
    return map;  // returns mutable reference with no synchronisation
}

// GMTPCodecFactory.java line 38:
decoder = new GMTPRequestDecoder(routingMap);

// GMTPCodecFactory.java line 47:
public ProtocolDecoder getDecoder(IoSession ioSession) throws Exception {
    return decoder;  // same instance returned for every session
}
```
**Recommendation:** Return `Collections.unmodifiableMap(map)` from `getMap()`, or use `ConcurrentHashMap`. If live reload is ever supported, add explicit synchronisation (e.g., `ReadWriteLock`) around all reads and writes to the map.

---

## A39-5

**File:** src/gmtp/XmlRoutingMap.java
**Line:** 51-53
**Severity:** Medium
**Category:** Security > Routing Map Integrity / Mutable Reference Exposure
**Description:** `getMap()` returns the internal `HashMap` directly (not a defensive copy or unmodifiable view). Any caller that holds this reference can call `map.put()`, `map.remove()`, or `map.clear()` and permanently alter the routing table for all subsequent messages. While in the current codebase the primary caller is `GMTPRouter.startServer()` which passes it to `GMTPServer`, the design provides no protection against accidental or malicious modification by any future caller or by the multi-threaded MINA handler code.
**Evidence:**
```java
public HashMap<String, String> getMap() {
    return map;  // direct reference — callers can mutate routing state
}
```
**Recommendation:** Return `Collections.unmodifiableMap(map)` to prevent external mutation. If callers need a mutable copy, they should explicitly create one.

---

## A39-6

**File:** src/gmtp/XmlRoutingMap.java
**Line:** 34-35
**Severity:** Critical
**Category:** Security > Command Injection / Arbitrary OS Command Execution
**Description:** XML routing files are loaded from the `routes/` directory using Simple XML deserialization (line 34). The values in each XML `<trigger>` element become route "commands" stored in the `HashMap`. These command strings are later passed verbatim to `ProcessBuilder` in `GMTPMessage.callFilter()` (GMTPMessage.java lines 183-188). The command string is split on commas; each comma-delimited token becomes an element in the `ProcessBuilder` argument list, where the first token is the executable path. There is no validation, sanitisation, or allowlist check applied to these values at any point — neither when loading the XML nor when invoking the process. If an attacker can write to or replace any file in the `routes/` directory (via filesystem misconfiguration, FTP access via the co-located `FTPServer`, or any other path traversal), they can inject arbitrary OS commands that will be executed with the privileges of the JVM process.
**Evidence:**
```java
// XmlRoutingMap.java lines 34-35:
XmlRoutes routes = serializer.read(XmlRoutes.class, current);
map.putAll(routes.getMap());

// GMTPMessage.java lines 183-189 (downstream use):
params = new ArrayList<String>();
params.add(cds[i]);       // first token from route value = executable
params.add(gmtp_id);
params.add(address);
params.add(msgStr);
ProcessBuilder pb = new ProcessBuilder(params);
Process process = pb.start();
```
**Recommendation:** Maintain an allowlist of permitted executable paths and validate every route command value against it at load time. Reject and log any routing file containing values that do not match the allowlist. Additionally, restrict filesystem permissions on the `routes/` directory so that only the application owner can write to it. Consider signing or checksumming routing configuration files.

---

## A39-7

**File:** src/gmtp/codec/GMTPCodecFactory.java
**Line:** 22-29 and 32-39
**Severity:** Low
**Category:** Security > Codec Factory / Null Encoder-Decoder on Client Mode
**Description:** When `GMTPCodecFactory` is constructed with `client = true`, both `encoder` and `decoder` are set to `null`. `getDecoder()` will subsequently return `null` for every session using this factory. MINA will throw a `NullPointerException` at runtime rather than failing at construction time, making the misconfiguration invisible until a session is actually accepted. Furthermore, neither constructor validates the `client` flag against an expected role, meaning a server-side call could inadvertently pass `true` and disable all codec processing silently.
**Evidence:**
```java
public GMTPCodecFactory(boolean client) {
    if (client) {
        encoder = null;   // line 24
        decoder = null;   // line 25
    } else { ... }
}
```
**Recommendation:** Throw an `IllegalStateException` (or use separate factory classes) rather than storing `null` for encoder/decoder. If client-side codec is genuinely not needed, document the restriction clearly and add a runtime assertion in `getDecoder()` and `getEncoder()` that `null` is never returned when the factory is installed on a server-side acceptor.

---

## A39-8

**File:** src/gmtp/codec/GMTPCodecFactory.java
**Line:** 42-48
**Severity:** Medium
**Category:** Security > Thread Safety / Shared Decoder Instance Across Sessions
**Description:** `GMTPCodecFactory` creates a single `GMTPRequestDecoder` instance at construction time and returns that same instance from `getDecoder(IoSession)` regardless of which session is requesting it. MINA's `ProtocolCodecFactory` contract expects factories to return either stateless codec objects or per-session instances. `CumulativeProtocolDecoder` stores its session-specific accumulation buffer in the `IoSession` attribute map (correctly), so per-session framing state is safe. However, the `routingMap` `HashMap` field within `GMTPRequestDecoder` is shared across all sessions and, as noted in A39-4, is not thread-safe. Any future addition of instance state to `GMTPRequestDecoder` would introduce a race condition without the developer necessarily realising the decoder is shared.
**Evidence:**
```java
// Factory constructor (line 28/38): single instance created
decoder = new GMTPRequestDecoder(routingMap);

// getDecoder returns the same instance for all sessions:
public ProtocolDecoder getDecoder(IoSession ioSession) throws Exception {
    return decoder;  // line 47
}
```
**Recommendation:** Either create a new `GMTPRequestDecoder` instance per session in `getDecoder()`, or document explicitly that the decoder is intentionally shared and ensure all its fields are thread-safe (e.g., using `ConcurrentHashMap` for `routingMap`).

---

## A39-9

**File:** src/gmtp/XmlRoutingMap.java
**Line:** 29-31
**Severity:** Medium
**Category:** Security > Null Dereference / Missing Input Validation
**Description:** In the constructor, `confs.list()` (line 29) returns `null` if the path does not exist, is not a directory, or an I/O error occurs. The result is immediately dereferenced in the loop condition `filename.length` (line 31) without a null check. This causes a `NullPointerException` at startup if the configured routes folder is invalid. While the exception propagates and prevents the server from starting (so it is not a runtime exploitable crash), it produces a confusing error message with no guidance, and in any error-recovery path that recreates the routing map at runtime it would cause an unhandled exception.
**Evidence:**
```java
String filename[] = confs.list();   // line 29 — may return null
// ...
for (int i = 0; i < filename.length; i++) {  // line 31 — NullPointerException if null
```
**Recommendation:** Check `if (filename == null)` after `confs.list()` and throw an `IllegalArgumentException` or `IOException` with a descriptive message identifying the invalid directory path.

---

## Summary Table

| ID | File | Line | Severity | Category |
|---|---|---|---|---|
| A39-1 | GMTPRequestDecoder.java | 82, 98 | High | Protocol Framing / Buffer Over-Read |
| A39-2 | GMTPRequestDecoder.java | 77, 93 | Medium | Denial of Service / Unbounded Memory |
| A39-3 | GMTPRequestDecoder.java | 64-74 | Medium | Error Handling / Missing Bounds Check |
| A39-4 | XmlRoutingMap.java | 21, 51 | High | Thread Safety / Unsynchronised Shared State |
| A39-5 | XmlRoutingMap.java | 51-53 | Medium | Routing Map Integrity / Mutable Reference |
| A39-6 | XmlRoutingMap.java | 34-35 | Critical | Command Injection / Arbitrary OS Command Execution |
| A39-7 | GMTPCodecFactory.java | 22-29 | Low | Null Encoder-Decoder on Client Mode |
| A39-8 | GMTPCodecFactory.java | 42-48 | Medium | Thread Safety / Shared Decoder Instance |
| A39-9 | XmlRoutingMap.java | 29-31 | Medium | Null Dereference / Missing Input Validation |
