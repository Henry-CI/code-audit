# Security Audit Pass 1 — Agent A27

**Date:** 2026-02-28
**Branch:** master (confirmed via `git rev-parse --abbrev-ref HEAD`)
**Agent:** A27

---

## Reading Evidence

### File 1: `src/ftp/FTPServer.java`

**Fully qualified class name:** `ftp.FTPServer`

**Interfaces/superclasses:** None (plain class)

**Imports:**
- `gmtp.GMTPRouter`
- `java.io.File`
- `java.io.IOException`
- `java.util.*`
- `org.apache.commons.net.ftp.FTPClient`
- `org.apache.commons.net.ftp.FTPReply`
- `org.apache.ftpserver.ConnectionConfigFactory`
- `org.apache.ftpserver.DataConnectionConfiguration`
- `org.apache.ftpserver.DataConnectionConfigurationFactory`
- `org.apache.ftpserver.FtpServer`
- `org.apache.ftpserver.FtpServerFactory`
- `org.apache.ftpserver.ftplet.FtpException`
- `org.apache.ftpserver.ftplet.Ftplet`
- `org.apache.ftpserver.ftplet.UserManager`
- `org.apache.ftpserver.listener.ListenerFactory`
- `org.apache.ftpserver.usermanager.ClearTextPasswordEncryptor`
- `org.apache.ftpserver.usermanager.PropertiesUserManagerFactory`
- `org.apache.ftpserver.usermanager.impl.BaseUser`
- `org.slf4j.Logger`
- `org.slf4j.LoggerFactory`
- `org.apache.ftpserver.ftplet.Authority`
- `org.apache.ftpserver.usermanager.impl.WritePermission`

**Fields:**
- `private Logger logger` (instance)
- `private static FTPServer instance`
- `private static Integer PORT = 2221`
- `private static String USER_FILE = "ftpUsers.properties"`
- `private static String FTP_ROOT = "C:/FTP"`
- `private static Integer FTP_MAXCONNECTION = 1000`
- `public static String FTP_SERVER = "127.0.0.1"`
- `private static String FTP_PASSIVE_PORTS = "2221"`
- `private static String FTP_PASSIVE_EXTADDR = "59.167.250.84"`
- `private FtpServer server`
- `private UserManager userManager`
- `public static final HashMap<String, String> authorizedIps`
- `private final FtpServerFactory serverFactory`

**Public methods:**
| Return type | Name | Parameters | Line |
|---|---|---|---|
| (constructor, private) | `FTPServer` | `()` | 54 |
| `UserManager` | `getUserManager` | `()` | 135 |
| `FtpServer` | `getServer` | `()` | 139 |
| `Integer` | `getPort` | `()` | 143 |
| `static synchronized FTPServer` | `getInstance` | `()` | 147 |
| `void` | `addUser` | `(String name, String password)` | 154 |
| `void` | `createDiretory` | `(String name, String password)` | 165 |
| `void` | `changeWorkDirecotry` | `(String name)` | 219 |
| `void` | `removeUser` | `(String name)` | 226 |
| `synchronized void` | `addAuthorizedIP` | `(String gmtpId, String ip)` | 230 |
| `synchronized void` | `removeAuthorizedIP` | `(String gmtpId)` | 234 |
| `synchronized HashMap<String, String>` | `getAuthorizedIps` | `()` | 238 |

**Private methods:**
- `boolean checkDirectoryExists(String dirPath, FTPClient ftpClient)` — line 210

---

### File 2: `src/ftp/GMTPFplet.java`

**Fully qualified class name:** `ftp.GMTPFplet`

**Interfaces/superclasses:** `extends DefaultFtplet`

**Imports:**
- `gmtp.DataMessageHandler`
- `gmtp.BinaryfileBean`
- `gmtp.GMTPRouter`
- `gmtp.db.DbUtil`
- `java.io.FileInputStream`
- `java.io.IOException`
- `java.io.InputStream`
- `java.sql.Connection`
- `java.util.HashMap`
- `javax.sound.midi.MidiDevice`
- `org.apache.ftpserver.ftplet.DefaultFtplet`
- `org.apache.ftpserver.ftplet.FtpException`
- `org.apache.ftpserver.ftplet.FtpFile`
- `org.apache.ftpserver.ftplet.FtpRequest`
- `org.apache.ftpserver.ftplet.FtpSession`
- `org.apache.ftpserver.ftplet.FtpletResult`
- `org.slf4j.Logger`
- `org.slf4j.LoggerFactory`

**Fields:**
- `private Logger logger` (instance)

**Public methods:**
| Return type | Name | Parameters | Line |
|---|---|---|---|
| (constructor) | `GMTPFplet` | `()` | 34 |
| `FtpletResult` | `onConnect` | `(FtpSession session)` | 38 |
| `FtpletResult` | `onLogin` | `(FtpSession session, FtpRequest request)` | 62 |
| `FtpletResult` | `onUploadEnd` | `(FtpSession session, FtpRequest request)` | 104 |

---

### File 3: `src/gmtp/BinaryfileBean.java`

**Fully qualified class name:** `gmtp.BinaryfileBean`

**Interfaces/superclasses:** None

**Imports:**
- `java.io.InputStream`

**Fields:**
- `protected String gmtp_id`
- `protected int flen`
- `protected InputStream fis`
- `protected String fname`
- `protected String path`

**Public methods:**
| Return type | Name | Parameters | Line |
|---|---|---|---|
| `InputStream` | `getFis` | `()` | 21 |
| `String` | `getGmtp_id` | `()` | 25 |
| `int` | `getFlen` | `()` | 29 |
| `String` | `getFname` | `()` | 33 |
| `void` | `setFis` | `(InputStream fis)` | 37 |
| `void` | `setGmtp_id` | `(String gmtp_id)` | 41 |
| `void` | `setFlen` | `(int flen)` | 45 |
| `void` | `setFname` | `(String fname)` | 49 |
| `void` | `setPath` | `(String path)` | 53 |
| `String` | `getPath` | `()` | 57 |

---

## Checklist Results

### FTP Server Security

- **Anonymous access enabled?** Not configured explicitly; no anonymous user block found. The server relies on `ftpUsers.properties` for users, which at time of audit is empty (1-line blank file). No explicit anonymous-block configuration is applied. No finding, but see A27-6 regarding the empty properties file.
- **Hardcoded FTP credentials:** None hardcoded in Java source; credentials deferred to properties file.
- **Path traversal in FTP file access:** See A27-3 (filename from request concatenated into path without sanitisation).
- **FTP server bound to 0.0.0.0:** The `ListenerFactory` port is set but no bind address is set, so it binds to all interfaces (0.0.0.0). See A27-1.
- **Directory listing restrictions:** No explicit restriction on directory listing configured. DefaultFtplet does not restrict LIST/NLST. Low severity; no discrete finding raised beyond A27-1.
- **Apache FtpServer version:** `ClearTextPasswordEncryptor` is an API present since Apache FtpServer 1.0.x; project structure and API usage are consistent with version 1.0.6, which is end-of-life and has known CVEs. See A27-2.

### Authentication and Authorization

- **Missing authentication checks:** `onLogin` (GMTPFplet line 71–83) enforces IP-based allow-listing in addition to FTP credentials, which is a positive control. However, see A27-4 for a logic flaw in that check.
- **FTP users cannot escape chroot/home directory:** Apache FtpServer applies chroot by default for `BaseUser`. However, all users share a single `FTP_ROOT` until `changeWorkDirecotry` is called (see A27-5).
- **ftpUsers.properties reference:** File is loaded from a relative path `"ftpUsers.properties"` (line 40, 112). The file exists in the project root but is empty (blank). The password encryptor is `ClearTextPasswordEncryptor` — see A27-7.

### File Handling (BinaryfileBean / GMTPFplet.onUploadEnd)

- **Path traversal via user-controlled filename:** See A27-3.
- **Insecure temporary file creation:** Not present in these three files.
- **Unbounded file reads:** `BinaryfileBean.flen` is an `int` set from `ftpfile.getSize()` (GMTPFplet line 116), which truncates a `long` to `int`. Passed directly to `setBinaryStream(5, fis, size)` in `DbUtil.storeImage`. See A27-8.
- **File type validation — content vs extension only:** Only extension check (`fname.endsWith(...)`) at GMTPFplet line 111. No magic-byte/content-type validation. See A27-9.
- **File writes to sensitive locations:** No direct `FileWriter`/`FileOutputStream` in these files.

### FTP Protocol Handler (GMTPFplet)

- **Uploaded file content validation:** Extension-only check (A27-9). Content is passed directly to a stored procedure without further validation.
- **Command injection:** No `Runtime.exec()` or `ProcessBuilder` in these files. Not found.
- **Resource leaks:** The `InputStream fis` opened at GMTPFplet line 112 (`ftpfile.createInputStream(0)`) is stored in `BinaryfileBean` and consumed by `DbUtil.storeImage`. In the exception path (catch block, line 125–127), the stream is not closed. See A27-10.

### General Java Security

- **Command injection (Runtime.exec / ProcessBuilder):** Not found in any of the three files.
- **Deserialization (ObjectInputStream.readObject):** Not found.
- **SQL injection:** `DbUtil.storeImage` uses `CallableStatement` with parameterised binding. Not vulnerable. No finding.
- **Swallowed exceptions:** `onUploadEnd` catch block (line 125–127) catches all `Exception` and logs only at INFO level, discarding the full stack trace. See A27-11. Also, the constructor catch block (lines 98–101) calls `e.printStackTrace()` rather than using the logger, and continues — see A27-12.

---

## Findings

## A27-1

**File:** C:/Projects/cig-audit/repos/gmtpserver/src/ftp/FTPServer.java
**Line:** 106
**Severity:** Medium
**Category:** Security > Network Exposure
**Description:** The FTP listener is created without setting a bind address on `ListenerFactory`. Apache FtpServer defaults to binding on all network interfaces (0.0.0.0). The server is intended to serve embedded/IoT devices and is described as listening on an internal address, but it will accept connections on every interface present on the host, including external ones, unless a firewall rule prevents it. This widens the attack surface unnecessarily.
**Evidence:**
```java
factory.setPort(PORT);
factory.setDataConnectionConfiguration(connectionConfiguration);
serverFactory.addListener("default", factory.createListener());
```
No call to `factory.setServerAddress(...)` is present.
**Recommendation:** Call `factory.setServerAddress("127.0.0.1")` (or whatever internal interface is appropriate) so that the FTP server only accepts connections from the intended network segment.

---

## A27-2

**File:** C:/Projects/cig-audit/repos/gmtpserver/src/ftp/FTPServer.java
**Line:** 113
**Severity:** High
**Category:** Security > Vulnerable Dependency
**Description:** The code uses `ClearTextPasswordEncryptor`, an API available in Apache FtpServer 1.0.x. Apache FtpServer 1.0.6 (the last 1.0.x release) reached end-of-life and has not received security patches for over a decade. Known issues include denial-of-service vulnerabilities and lack of active maintenance. Running an EOL FTP server library exposes the application to unpatched CVEs.
**Evidence:**
```java
import org.apache.ftpserver.usermanager.ClearTextPasswordEncryptor;
...
userManagerFactory.setPasswordEncryptor(new ClearTextPasswordEncryptor());
```
**Recommendation:** Upgrade to a currently maintained FTP server library or replace the embedded FTP server with SFTP (e.g., Apache MINA SSHD), which is actively maintained and provides encryption in transit.

---

## A27-3

**File:** C:/Projects/cig-audit/repos/gmtpserver/src/ftp/GMTPFplet.java
**Line:** 110
**Severity:** High
**Category:** Security > Path Traversal
**Description:** The filename `fname` is taken directly from the FTP STOR command argument (`request.getArgument()`, line 107) and concatenated with the working directory path to construct the file path passed to `session.getFileSystemView().getFile(...)`. A malicious client can supply a filename containing `../` sequences (e.g., `../../etc/passwd`) to cause the server to open a file outside the intended FTP root. While Apache FtpServer's `FileSystemView` implementation may normalise some paths, the application itself performs no sanitisation, and the resulting `fpath + "/" + fname` string is then stored in `BinaryfileBean.path` and `BinaryfileBean.fname` and forwarded to the database stored procedure — meaning the raw traversal path reaches persistent storage.
**Evidence:**
```java
String fname = request.getArgument();                               // line 107 — user-controlled
String fpath = session.getFileSystemView().getWorkingDirectory().getAbsolutePath();
FtpFile ftpfile = session.getFileSystemView().getFile(fpath + "/" + fname);  // line 110
...
binaryfileBean.setFname(fname);   // line 117 — raw user input stored
binaryfileBean.setPath(fpath);    // line 118
```
**Recommendation:** Validate `fname` against a strict allowlist (e.g., alphanumeric characters, hyphens, underscores, and a single permitted extension). Reject any filename containing `/`, `\`, or `..`. Additionally verify that the resolved canonical path of the resulting `FtpFile` starts with the expected FTP root directory.

---

## A27-4

**File:** C:/Projects/cig-audit/repos/gmtpserver/src/ftp/GMTPFplet.java
**Line:** 77
**Severity:** Medium
**Category:** Security > Authentication Bypass
**Description:** The third branch of the IP authorization check in `onLogin` compares the authorized IP value for a user against the FTP username itself (`authorizedIps.get(ftpuser).equalsIgnoreCase(ftpuser)`). If, for any reason, a GMTP ID (username) is stored as its own authorized IP value in the `authorizedIps` map, any client — regardless of source IP — can connect using that username and be accepted. This is a logic flaw that can be exploited if data in the map is ever user-influenced or incorrectly populated, bypassing the IP-based access control entirely.
**Evidence:**
```java
} else if (authorizedIps.containsKey(ftpuser) && authorizedIps.get(ftpuser).equalsIgnoreCase(ftpuser)) {
    logger.info("Accepted connection from gmtp address: {}", ftpuser);
    return FtpletResult.DEFAULT;
}
```
**Recommendation:** Remove this branch or document with precision what scenario it is intended to handle. If the intent is to allow loopback connections identified by GMTP ID, use explicit IP matching against `"127.0.0.1"` or `"::1"` rather than comparing the IP value to the username.

---

## A27-5

**File:** C:/Projects/cig-audit/repos/gmtpserver/src/ftp/FTPServer.java
**Line:** 154–163
**Severity:** High
**Category:** Security > Insufficient Authorization / Directory Traversal
**Description:** `addUser` sets every new user's home directory to the single shared `FTP_ROOT` (e.g., `C:/FTP`) and grants `WritePermission`. Until `changeWorkDirecotry` is called for that user (a separate, non-atomic operation), all users share the same chroot root. A user can therefore read and overwrite files belonging to other GMTP devices within the same root. Furthermore, `changeWorkDirecotry` (line 219–224) constructs the per-user home directory by simple string concatenation: `FTP_ROOT + "/" + name`, where `name` is the FTP username supplied by the caller. If that name contains `..` components, the home directory can be set to a location outside `FTP_ROOT`.
**Evidence:**
```java
public void addUser(String name, String password) throws FtpException {
    ...
    user.setHomeDirectory(FTP_ROOT);   // shared root, no per-user isolation
    userManager.save(user);
}

public void changeWorkDirecotry(String name) throws FtpException {
    BaseUser user = (BaseUser) userManager.getUserByName(name);
    user.setHomeDirectory(FTP_ROOT + "/" + name);   // name not sanitised
    userManager.save(user);
}
```
**Recommendation:** Set the per-user home directory atomically at creation time rather than in a separate step. Sanitise `name` to ensure it contains no path separator characters or `..` sequences before concatenating it into a filesystem path.

---

## A27-6

**File:** C:/Projects/cig-audit/repos/gmtpserver/src/ftp/FTPServer.java
**Line:** 112
**Severity:** Medium
**Category:** Security > Configuration
**Description:** The `ftpUsers.properties` file is loaded from a relative path (`"ftpUsers.properties"`, the default value of `USER_FILE`). At audit time the file exists in the repository root but contains only a blank line — it is effectively empty. Apache FtpServer with an empty properties file will have no configured users, which means authentication is entirely dependent on the programmatic `addUser` calls at runtime. If the file is absent or empty at startup, the server may fall back to a default state that could permit anonymous access or cause unpredictable behaviour depending on the FtpServer version. The relative path also means the resolved file depends on the JVM working directory, which may differ between environments.
**Evidence:**
```java
private static String USER_FILE = "ftpUsers.properties";
...
userManagerFactory.setFile(new File(USER_FILE));
```
**Recommendation:** Use an absolute, explicitly configured path for the user file. Ensure the file is non-empty at startup (containing at minimum a disabled anonymous user entry) and fail-fast if the file is missing rather than continuing with a potentially insecure default state.

---

## A27-7

**File:** C:/Projects/cig-audit/repos/gmtpserver/src/ftp/FTPServer.java
**Line:** 113
**Severity:** High
**Category:** Security > Weak Credential Storage
**Description:** `ClearTextPasswordEncryptor` is explicitly configured, which means all FTP user passwords are stored in plain text in `ftpUsers.properties`. If the properties file is obtained by an attacker (e.g., through directory traversal, backup exposure, or repository leak), all FTP credentials are immediately compromised with no need for cracking.
**Evidence:**
```java
userManagerFactory.setPasswordEncryptor(new ClearTextPasswordEncryptor());
```
**Recommendation:** Replace `ClearTextPasswordEncryptor` with `SaltedPasswordEncryptor` (the Apache FtpServer built-in salted SHA hashing encryptor) or, better, migrate to a strong modern hashing algorithm (bcrypt, Argon2). Rotate any existing credentials stored in cleartext.

---

## A27-8

**File:** C:/Projects/cig-audit/repos/gmtpserver/src/ftp/GMTPFplet.java
**Line:** 116
**Severity:** Medium
**Category:** Security > Integer Truncation / Denial of Service
**Description:** `ftpfile.getSize()` returns a `long`. It is cast to `int` without bounds checking: `binaryfileBean.setFlen((int) ftpfile.getSize())`. `BinaryfileBean.flen` is an `int`. If a file larger than ~2 GB is uploaded, the cast silently truncates the value, producing a negative or incorrect length. This incorrect length is subsequently passed to `proc.setBinaryStream(5, fis, size)` in `DbUtil.storeImage`. A negative size may cause the JDBC driver to behave unpredictably or raise an error; an incorrectly small positive size will silently truncate the data stored in the database. A malicious client could craft uploads designed to exploit this truncation to corrupt stored binary data.
**Evidence:**
```java
binaryfileBean.setFlen((int) ftpfile.getSize());   // long -> int, no bounds check
```
And in `BinaryfileBean`:
```java
protected int flen;
```
**Recommendation:** Change `BinaryfileBean.flen` to `long`. Update `setFlen` / `getFlen` accordingly. Use `setBinaryStream(5, fis, (long) size)` (the JDBC 4.0 overload that accepts `long`). Add an explicit check that the file size does not exceed a configured maximum before processing.

---

## A27-9

**File:** C:/Projects/cig-audit/repos/gmtpserver/src/ftp/GMTPFplet.java
**Line:** 111
**Severity:** Medium
**Category:** Security > Insufficient Input Validation
**Description:** The only validation applied to an uploaded file before it is processed and stored is an extension check: `fname.endsWith(GMTPRouter.gmtpConfigManager.getConfiguration().getFtpimagetype())`. Extension-based validation is trivially bypassed by naming a malicious file with the expected extension (e.g., `evil.img` if `.img` is the configured type). No magic-byte validation, MIME type check, or structural parsing of the binary content is performed. The raw binary stream is forwarded directly to a stored procedure.
**Evidence:**
```java
if (ftpfile.isFile() && ftpfile.isReadable() && fname.endsWith(GMTPRouter.gmtpConfigManager.getConfiguration().getFtpimagetype())) {
    InputStream fis = ftpfile.createInputStream(0);
    ...
    DataMessageHandler.onImageMessage(binaryfileBean);
}
```
**Recommendation:** Implement content-based validation (magic byte verification appropriate to the expected firmware/image format) in addition to the extension check. Define and enforce a maximum permitted file size. Reject files that do not pass structural validation before passing data to downstream components.

---

## A27-10

**File:** C:/Projects/cig-audit/repos/gmtpserver/src/ftp/GMTPFplet.java
**Line:** 112 / 125–127
**Severity:** Medium
**Category:** Security > Resource Leak
**Description:** The `InputStream` opened via `ftpfile.createInputStream(0)` (line 112) is stored in `BinaryfileBean.fis`. In the normal path, it is consumed by `DbUtil.storeImage`, which closes the database connection but does not explicitly close the `InputStream`. In the exception path (catch block, lines 125–127), the stream is never closed at all. Repeated upload errors or failures in `DataMessageHandler.onImageMessage` will leak file descriptors and network resources, which can be exploited as a denial-of-service vector by causing repeated upload failures.
**Evidence:**
```java
InputStream fis = ftpfile.createInputStream(0);   // opened, line 112
binaryfileBean.setFis(fis);
...
} catch (Exception e) {
    logger.info("FTP file upload failed on " + gmtpId + " " + fname);
    // fis is never closed here
}
```
**Recommendation:** Wrap the `InputStream` in a try-with-resources block, or add a `finally` clause that closes `fis` after processing is complete (whether success or failure). Ensure `DbUtil.storeImage` also closes the stream it receives.

---

## A27-11

**File:** C:/Projects/cig-audit/repos/gmtpserver/src/ftp/GMTPFplet.java
**Line:** 125–127
**Severity:** Low
**Category:** Security > Swallowed Exception / Information Loss
**Description:** The catch block in `onUploadEnd` catches `Exception` (all exceptions) and logs only a generic INFO-level message without including the exception or its stack trace. This conceals the root cause of failures, making it impossible to distinguish between a network error, a database failure, a path traversal attempt, and an authentication error. It also means any security-relevant exception (e.g., a deliberate crash triggered by a malformed upload) is silently discarded.
**Evidence:**
```java
} catch (Exception e) {
    logger.info("FTP file upload failed on " + gmtpId + " " + fname);
}
```
**Recommendation:** Log at ERROR level and include the exception: `logger.error("FTP file upload failed on {} {}", gmtpId, fname, e)`. Consider distinguishing between expected and unexpected exception types rather than catching the root `Exception`.

---

## A27-12

**File:** C:/Projects/cig-audit/repos/gmtpserver/src/ftp/FTPServer.java
**Line:** 98–101
**Severity:** Low
**Category:** Security > Swallowed Exception / Information Leakage
**Description:** A configuration error during passive data connection setup is caught, `e.printStackTrace()` is called (writing to stdout/stderr rather than the structured logger), and execution continues. The server then starts with a potentially misconfigured data connection. Errors written to stderr may not appear in production log aggregation systems, making the misconfiguration invisible in monitoring. Continuing after a configuration exception also risks a partially initialised server accepting connections it cannot service correctly.
**Evidence:**
```java
} catch (Exception e) {
    e.printStackTrace();
    logger.info("Ftp Server configuration error");
}
```
**Recommendation:** Log the exception using the SLF4J logger at ERROR level with the full throwable: `logger.error("FTP passive data connection configuration error", e)`. Consider throwing a fatal error or aborting startup if a configuration step fails, rather than continuing with a degraded server.

---

## A27-13

**File:** C:/Projects/cig-audit/repos/gmtpserver/src/ftp/FTPServer.java
**Line:** 45
**Severity:** Medium
**Category:** Security > Information Disclosure / Hardcoded Infrastructure Address
**Description:** A public IP address (`59.167.250.84`) is hardcoded as the default passive external address `FTP_PASSIVE_EXTADDR`. This address is embedded in the version-controlled source code, disclosing production infrastructure details to anyone with repository access. It also represents a hard dependency on a specific IP that may change or be shared with other services.
**Evidence:**
```java
private static String FTP_PASSIVE_EXTADDR = "59.167.250.84";
```
**Recommendation:** Remove hardcoded IP addresses from source code. This value should be supplied exclusively through external configuration (config file or environment variable) with no default fallback in code. Treat the configuration file as a secret artifact, not committed to version control.

---

## A27-14

**File:** C:/Projects/cig-audit/repos/gmtpserver/src/ftp/GMTPFplet.java
**Line:** 66–67
**Severity:** Low
**Category:** Security > IP Parsing / Insufficient Input Validation
**Description:** The client IP address is extracted by splitting `session.getClientAddress().toString()` on `":"` and taking `parts[0]`. The `getClientAddress()` return value is a `java.net.InetSocketAddress`, whose `toString()` format is `"/ip:port"` for IPv4. This means `parts[0]` will be `"/ip"` (with a leading slash). The code compensates for this at line 71 by comparing against `"/" + server.FTP_SERVER`. However, for an IPv6 address the format is `"/[::1]:port"`, and splitting on `":"` produces multiple parts, causing `parts[0]` to be only a fragment of the address. The result is that IPv6 clients are never correctly matched against the authorized-IP map, potentially being incorrectly rejected or accepted (if the broken partial address coincidentally matches).
**Evidence:**
```java
String[] parts = session.getClientAddress().toString().split(":");
String ip = parts[0];
```
**Recommendation:** Use `((InetSocketAddress) session.getClientAddress()).getAddress().getHostAddress()` to obtain the IP string directly and correctly for both IPv4 and IPv6, rather than manually parsing the `toString()` output.

