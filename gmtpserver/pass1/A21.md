# Security Audit Pass 1 — Agent A21

**Branch verified:** master
**Date:** 2026-02-28
**Assigned files:**
- `src/codec/GMTPCodecFactory.java`
- `src/codec/GMTPRequestDecoder.java`
- `src/codec/GMTPResponseEncoder.java`

---

## Reading Evidence

### GMTPCodecFactory.java

**Fully qualified class name:** `codec.GMTPCodecFactory`

**Implements:** `org.apache.mina.filter.codec.ProtocolCodecFactory`

**Extends:** (none — implements interface only)

**Imports:**
- `java.util.HashMap`
- `org.apache.mina.core.session.IoSession`
- `org.apache.mina.filter.codec.ProtocolCodecFactory`
- `org.apache.mina.filter.codec.ProtocolDecoder`
- `org.apache.mina.filter.codec.ProtocolEncoder`

**Fields:**
- `private ProtocolEncoder encoder` (line 19)
- `private ProtocolDecoder decoder` (line 20)

**Public methods:**
- Constructor `GMTPCodecFactory(boolean client)` — line 22
- Constructor `GMTPCodecFactory(boolean client, HashMap<String, String> routingMap)` — line 32
- `public ProtocolEncoder getEncoder(IoSession ioSession) throws Exception` — line 42
- `public ProtocolDecoder getDecoder(IoSession ioSession) throws Exception` — line 46

---

### GMTPRequestDecoder.java

**Fully qualified class name:** `codec.GMTPRequestDecoder`

**Extends:** `org.apache.mina.filter.codec.CumulativeProtocolDecoder`

**Implements:** (none directly — inherited from CumulativeProtocolDecoder)

**Imports:**
- `gmtp.GMTPMessage`
- `gmtp.GMTPMessage.Type`
- `java.nio.charset.Charset`
- `java.nio.charset.CharsetDecoder`
- `java.util.HashMap`
- `org.apache.mina.core.buffer.IoBuffer`
- `org.apache.mina.core.session.IoSession`
- `org.apache.mina.filter.codec.CumulativeProtocolDecoder`
- `org.apache.mina.filter.codec.ProtocolDecoderOutput`
- `org.slf4j.Logger`
- `org.slf4j.LoggerFactory`

**Fields:**
- `private static final short PDU_ID = 0x0001` (line 25)
- `private static final short PDU_DATA = 0x0002` (line 26)
- `private static final short PDU_ID_EXT = 0x0003` (line 27)
- `private static final short PDU_DATA_EXT = 0x0004` (line 28)
- `private static final short PDU_ACK = 0x0005` (line 29)
- `private static final short PDU_ERROR = 0x0006` (line 30)
- `private static final short PDU_CLOSED = 0x0007` (line 32, unused)
- `private static final short PDU_PROTO_VER = 0x0008` (line 33)
- `private static final short PDU_BEGIN_TRANSACTION = 0x0009` (line 34)
- `private static final short PDU_END_TRANSACTION = 0x000A` (line 35)
- `private static final short PDU_NAK = 0x000D` (line 36)
- `private static Logger logger` (line 37)
- `private HashMap<String, String> routingMap` (line 38)

**Public methods:**
- Constructor `GMTPRequestDecoder(HashMap<String, String> routingMap)` — line 40
- Constructor `GMTPRequestDecoder()` — line 44
- `protected boolean doDecode(IoSession session, IoBuffer in, ProtocolDecoderOutput out) throws Exception` — line 48 (Override)

**Private methods:**
- `private Type decodeMessageType(int type)` — line 111

---

### GMTPResponseEncoder.java

**Fully qualified class name:** `codec.GMTPResponseEncoder`

**Extends:** `org.apache.mina.filter.codec.ProtocolEncoderAdapter`

**Implements:** (none directly — inherited)

**Imports:**
- `gmtp.GMTPMessage`
- `gmtp.GMTPMessage.Type`
- `java.io.ByteArrayOutputStream`
- `org.apache.mina.core.buffer.IoBuffer`
- `org.apache.mina.core.session.IoSession`
- `org.apache.mina.filter.codec.ProtocolEncoderAdapter`
- `org.apache.mina.filter.codec.ProtocolEncoderOutput`
- `org.slf4j.Logger`
- `org.slf4j.LoggerFactory`

**Fields:**
- `private static final short PDU_ID = 0x0001` (line 23)
- `private static final short PDU_DATA = 0x0002` (line 24)
- `private static final short PDU_ID_EXT = 0x0003` (line 25)
- `private static final short PDU_DATA_EXT = 0x0004` (line 26)
- `private static final short PDU_ACK = 0x0005` (line 27)
- `private static final short PDU_ERROR = 0x0006` (line 28)
- `private static final short PDU_CLOSED = 0x0007` (line 30, unused)
- `private static final short PDU_PROTO_VER = 0x0008` (line 31)
- `private static final short PDU_BEGIN_TRANSACTION = 0x0009` (line 32)
- `private static final short PDU_END_TRANSACTION = 0x000A` (line 33)
- `private static final short PDU_NAK = 0x000D` (line 34)
- `private static Logger logger` (line 35)

**Public methods:**
- `public void encode(IoSession session, Object message, ProtocolEncoderOutput out) throws Exception` — line 37

**Private methods:**
- `private int encodeMessageType(Type type)` — line 60

---

## Security Checklist Results

### Input Validation and Injection

**Bounds checks on message lengths:** ISSUE FOUND. The decoder reads `dataLen` from the wire but then calls `in.getString(in.remaining(), decoder)` instead of `in.getString(dataLen, decoder)`. The actual data read is always `in.remaining()`, ignoring the declared length. This means the length field is checked for framing purposes (to decide whether to proceed) but never actually used to limit how many bytes are consumed from the buffer. See finding A21-1.

**Integer overflow in length calculations:** No multiplication of length values occurs. The two bytes are combined with `(high << 8) + low`, which produces a value in [0, 65535]. No overflow possible in the combination itself for the decoder. In the encoder, `short length = (short) gmtpMsg.getMessage().length()` casts an `int` to `short`, which will silently truncate if the message is longer than 32767 characters. See finding A21-2.

**Decoder handles malformed/truncated input without crashing:** Partially. The outer `if (in.remaining() >= 4)` gate and the inner `if (in.remaining() >= dataLen)` gate allow the decoder to signal "not enough data yet" by returning false. However, for extended packet types (ID_EXT, DATA_EXT, ACK), the check `in.remaining() >= 4` is used for the outer gate but the extended header needs 6 bytes (2 type + 2 id + 2 length) before any data. Between reading the 2-byte type and attempting to read 4 more bytes (id + length), there is no intermediate bounds check. If `in.remaining()` is exactly 4 when the extended path is taken, `in.get()` calls for bytes 3–6 will throw a `BufferUnderflowException`. See finding A21-3.

**String operations with binary data:** The use of `Charset.forName("UTF-8").newDecoder()` is appropriate for text data. However, a new `CharsetDecoder` is instantiated on every call to `doDecode` (lines 77 and 93), which is inefficient but not a direct security issue. The decoder's default malformed-input and unmappable-character actions are REPORT (throw exception) for some JVM configurations, which could cause the MINA session to log an exception and potentially reset state unexpectedly — but this is minor and not directly exploitable.

**Buffer reads out of bounds:** ISSUE FOUND (same as A21-3 above — the extended-packet path reads beyond the 4-byte outer gate without rechecking remaining bytes).

### Resource Management

**Unbounded buffer allocation based on attacker-controlled length fields:** ISSUE FOUND. In the decoder, `in.getString(in.remaining(), decoder)` allocates a String backed by all remaining bytes in the cumulative buffer, not just `dataLen` bytes. An attacker who sends many bytes in one TCP segment can cause a large String allocation. Additionally, MINA's `CumulativeProtocolDecoder` accumulates all unprocessed bytes across calls; if `doDecode` keeps returning `false` (e.g., because length is never satisfied), the cumulative buffer grows without bound until the connection is dropped or memory is exhausted. No maximum message size is enforced. See finding A21-4.

**Denial-of-service via large packet:** ISSUE FOUND. Because `dataLen` can be up to 65535 (0xFFFF) and there is no maximum length check, an attacker can claim any length, keep the TCP connection open, and cause the server to buffer up to 65535 bytes per message indefinitely. No cap is imposed. See finding A21-4.

**Resources released on error paths:** The MINA framework handles `IoBuffer` lifecycle; no explicit `buffer.free()` calls are made in the encoder, which is consistent with MINA conventions. No additional resource leaks observed.

### Error Handling

**Swallowed exceptions:** No try/catch blocks are present in any of the three files. Exceptions propagate to the MINA framework, which will log them and close the session. This is acceptable behavior.

**Decoding errors cause connection closure:** Since no exceptions are caught internally, MINA's framework-level exception handling applies. This is the correct behavior for this framework.

### Cryptographic Issues

**Encoding/decoding without encryption:** The protocol transmits all data in plaintext over TCP. There is no TLS/SSL wrapping at the codec layer. Whether this is acceptable depends on the deployment context, but there is no encryption present in these files. See finding A21-5.

**Hardcoded keys or secrets:** No hardcoded cryptographic keys or secrets found.

### General Java Security

**Command injection (Runtime.exec / ProcessBuilder):** None found.

**Path traversal in file operations:** No file operations present.

**Deserialization of untrusted data (ObjectInputStream.readObject):** None found.

**SQL injection:** No JDBC or database operations present.

### Additional Issues Found During Review

**Null dereference in encoder:** `session.getAttribute("extVersion")` can return `null` if the attribute has not been set. The result is immediately passed to `extVersion.equalsIgnoreCase("1")` without a null check, which will throw a `NullPointerException` and crash the encoder for any session that has not had this attribute set. See finding A21-6.

**Shared encoder/decoder instances across sessions:** `GMTPCodecFactory` creates a single `encoder` and `decoder` instance at factory construction time and returns the same instance for every session via `getEncoder()` and `getDecoder()`. `GMTPResponseEncoder` is stateless, so sharing is safe. `GMTPRequestDecoder` extends `CumulativeProtocolDecoder`, which maintains per-call state — but MINA typically creates one codec factory per session in server mode, so this may be safe depending on how `GMTPCodecFactory` is instantiated. If a single factory instance is shared across all sessions (which is a common misconfiguration), the cumulative buffer state of `CumulativeProtocolDecoder` could be corrupted across concurrent sessions. See finding A21-7.

**Unknown message type silently mapped to ERROR:** In `decodeMessageType`, any unrecognised PDU type (including `PDU_BEGIN_TRANSACTION = 0x0009` and `PDU_NAK = 0x000D`, which are defined as constants but not in the switch) falls through to `return Type.ERROR`. This means a client can send arbitrary type bytes and the server will silently treat them as ERROR messages rather than rejecting the connection. This can mask protocol violations.

---

## Findings

## A21-1

**File:** src/codec/GMTPRequestDecoder.java
**Line:** 80, 96
**Severity:** High
**Category:** Security > Input Validation
**Description:** The declared message length field (`dataLen`) is read from the wire and used only to gate whether decoding proceeds (the `if (in.remaining() >= dataLen)` check), but it is never used to limit how many bytes are actually consumed. Both branches call `in.getString(in.remaining(), decoder)`, consuming all remaining bytes in the buffer rather than exactly `dataLen` bytes. This means the length field in the protocol is functionally ignored during data extraction, making it impossible to correctly frame multi-message streams. It also means if a sender appends extra bytes after a message, those bytes are silently consumed and lost, corrupting subsequent messages.
**Evidence:**
```java
// Line 79-80 (extended path)
if (in.remaining() >= dataLen) {
    String msgStr = in.getString(in.remaining(), decoder);  // should be dataLen, not in.remaining()

// Line 95-96 (standard path)
if (in.remaining() >= dataLen) {
    String msgStr = in.getString(in.remaining(), decoder);  // should be dataLen, not in.remaining()
```
**Recommendation:** Replace `in.getString(in.remaining(), decoder)` with `in.getString(dataLen, decoder)` in both branches so that exactly the declared number of bytes is consumed, preserving correct message framing.

---

## A21-2

**File:** src/codec/GMTPResponseEncoder.java
**Line:** 41
**Severity:** Medium
**Category:** Security > Input Validation
**Description:** The message length is calculated as `(short) gmtpMsg.getMessage().length()`. A Java `short` is a signed 16-bit integer with a maximum value of 32767. If the message string length exceeds 32767 characters, the cast silently truncates to a negative value. This corrupted length value is then written into the PDU header as a 2-byte field, causing the peer decoder to receive a wildly incorrect length. An attacker who can influence message content could potentially trigger this to corrupt framing on the wire.
**Evidence:**
```java
short length = (short) gmtpMsg.getMessage().length();  // line 41 — silent truncation above 32767
```
**Recommendation:** Add an explicit bounds check before the cast. If the message length exceeds the maximum expressible value (65535 for an unsigned 16-bit field, or 32767 for signed short), either reject the message or split it. Consider using an `int` internally and validating before encoding.

---

## A21-3

**File:** src/codec/GMTPRequestDecoder.java
**Line:** 53, 63-75
**Severity:** High
**Category:** Security > Input Validation
**Description:** The outer gate checks `in.remaining() >= 4` (line 53), sufficient for the standard 4-byte header (2-byte type + 2-byte length). However, when the extended packet path is taken (types ID_EXT, DATA_EXT, ACK), the code reads an additional 4 bytes (2-byte ID + 2-byte length) without first verifying that those bytes are available. If exactly 4 bytes are available and the message type indicates an extended packet, the four `in.get()` calls at lines 65–66 and 72–73 will throw a `BufferUnderflowException`. While MINA will catch this and close the session, it represents an unhandled crash path that an attacker can trigger with a crafted partial packet.
**Evidence:**
```java
if (in.remaining() >= 4) {          // line 53 — gate for 4 bytes
    ...
    if(msgType == Type.ID_EXT || msgType == Type.DATA_EXT || msgType == Type.ACK) {
        int idHigh = 0xFF & (int) in.get();   // line 65 — no bounds check for 2 extra ID bytes
        int idLow  = 0xFF & (int) in.get();   // line 66
        ...
        int lengthHigh = 0xFF & (int) in.get(); // line 72 — no bounds check for 2 length bytes
        int lengthLow  = 0xFF & (int) in.get(); // line 73
```
**Recommendation:** Change the outer gate to `in.remaining() >= 6` for extended packet types, or perform a secondary remaining check before reading the ID and length bytes. Rewind the position to `start` and return `false` rather than allowing a `BufferUnderflowException`.

---

## A21-4

**File:** src/codec/GMTPRequestDecoder.java
**Line:** 75, 79, 91, 95
**Severity:** High
**Category:** Security > Resource Management (Denial of Service)
**Description:** There is no upper bound enforced on the declared message length (`dataLen`). Since length is a 16-bit value read from the wire, it can be up to 65535. An attacker can send a PDU header declaring a very large `dataLen` and then keep the TCP connection open without sending the data. MINA's `CumulativeProtocolDecoder` will accumulate incoming bytes indefinitely waiting for `dataLen` bytes to arrive. Across many connections, this can exhaust server heap memory. Additionally, because the actual read uses `in.remaining()` rather than `dataLen` (see A21-1), a single large TCP segment causes an equally large String allocation.
**Evidence:**
```java
int dataLen = (lengthHigh << 8) + lengthLow;  // line 75 — up to 65535, no cap applied
...
if (in.remaining() >= dataLen) {               // line 79 — gates on declared length but no max check
    String msgStr = in.getString(in.remaining(), decoder);  // allocates string for all buffered bytes
```
**Recommendation:** Define a maximum allowable message size constant (e.g., `MAX_DATA_LEN = 8192`) and reject connections (close the session) that declare a length exceeding this value. This prevents both the buffering DoS and the large-allocation path.

---

## A21-5

**File:** src/codec/GMTPRequestDecoder.java, src/codec/GMTPResponseEncoder.java
**Line:** N/A (entire codec layer)
**Severity:** Medium
**Category:** Security > Cryptographic Issues
**Description:** All data — including message identifiers, payload content, and routing information — is transmitted in plaintext binary over TCP with no encryption or integrity protection. There is no TLS wrapping at the codec layer. An attacker with network access can read and modify all traffic in transit.
**Evidence:** No use of `SSLContext`, `SSLEngine`, or MINA's `SslFilter` anywhere in the codec classes. All writes use raw `IoBuffer.put*()` methods.
**Recommendation:** Configure a MINA `SslFilter` in the filter chain before the codec filter, or deploy the server behind a TLS termination proxy. At minimum, document that the protocol requires network-level confidentiality controls.

---

## A21-6

**File:** src/codec/GMTPResponseEncoder.java
**Line:** 42, 50
**Severity:** High
**Category:** Security > Error Handling / Null Dereference
**Description:** `session.getAttribute("extVersion")` returns `null` if the attribute has not been set on the session. The returned value is cast to `String` and then immediately dereferenced with `.equalsIgnoreCase("1")` at line 50 without a null check. This will throw a `NullPointerException` for any session that has not had `extVersion` set, crashing the encoder. An attacker who establishes a connection before the `extVersion` attribute is populated can exploit this to crash the encoding path for that session.
**Evidence:**
```java
String extVersion = (String) session.getAttribute("extVersion");  // line 42 — can return null
...
if(extVersion.equalsIgnoreCase("1")) {                            // line 50 — NPE if null
```
**Recommendation:** Add a null check: `if (extVersion != null && extVersion.equalsIgnoreCase("1"))`. Alternatively, use `"1".equals(extVersion)` which is null-safe.

---

## A21-7

**File:** src/codec/GMTPCodecFactory.java
**Line:** 19-20, 27-28, 37-38, 42-47
**Severity:** Medium
**Category:** Security > Resource Management / Thread Safety
**Description:** `GMTPCodecFactory` creates a single shared `encoder` and `decoder` instance at construction time and returns the same instance to every session that calls `getEncoder()` or `getDecoder()`. `CumulativeProtocolDecoder` (the parent of `GMTPRequestDecoder`) maintains cumulative byte buffer state. If a single `GMTPCodecFactory` instance is shared across multiple sessions (which is possible depending on how it is instantiated in the server bootstrap), two concurrent sessions will share the same `GMTPRequestDecoder` instance and therefore the same cumulative buffer. This will corrupt decoding state across sessions and could allow one session's data to bleed into another session's message stream.
**Evidence:**
```java
private ProtocolEncoder encoder;   // line 19 — single instance
private ProtocolDecoder decoder;   // line 20 — single instance

public GMTPCodecFactory(boolean client) {
    ...
    encoder = new GMTPResponseEncoder();  // line 27 — created once
    decoder = new GMTPRequestDecoder();   // line 28 — created once, shared
}

public ProtocolDecoder getDecoder(IoSession ioSession) throws Exception {
    return decoder;  // line 47 — same instance returned for every session
}
```
**Recommendation:** Create a new `GMTPRequestDecoder` (and optionally a new `GMTPResponseEncoder`) per call to `getDecoder()`/`getEncoder()`, or ensure that the factory itself is instantiated once per session at the server bootstrap level. Per the MINA documentation, codec factories should return a new codec instance per session, not a shared singleton.

---

## A21-8

**File:** src/codec/GMTPRequestDecoder.java
**Line:** 111-134
**Severity:** Low
**Category:** Security > Input Validation
**Description:** The PDU type constants `PDU_BEGIN_TRANSACTION (0x0009)` and `PDU_NAK (0x000D)` are defined in the class (lines 34 and 36) but are absent from the `decodeMessageType` switch statement. Any packet with these type codes falls through to the `default` case and is returned as `Type.ERROR`. This means an attacker can send a NAK packet and have it silently accepted and processed as an ERROR message rather than being rejected as an unknown type. Unrecognized protocol types should result in connection termination, not silent remapping.
**Evidence:**
```java
private static final short PDU_BEGIN_TRANSACTION = 0x0009;  // line 34 — defined
private static final short PDU_NAK = 0x000D;                // line 36 — defined
...
switch (type) {
    // PDU_BEGIN_TRANSACTION (0x0009) — missing from switch
    // PDU_NAK (0x000D) — missing from switch
    default:
        return Type.ERROR;   // line 131 — silently remapped
}
```
**Recommendation:** Add explicit cases for all defined PDU type constants. For truly unrecognized types, throw a `ProtocolDecoderException` or close the session rather than silently mapping to `Type.ERROR`.
