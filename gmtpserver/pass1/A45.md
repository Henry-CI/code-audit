# Security Audit Pass 1 — Agent A45

**Branch verified:** master
**Date:** 2026-02-28
**Files audited:**
- `src/gmtp/db/DbUtil.java`
- `src/gmtp/outgoing/OutgoingMessage.java`
- `src/gmtp/outgoing/OutgoingMessageManager.java`

---

## Reading Evidence

### File 1: `src/gmtp/db/DbUtil.java`

**Fully qualified class name:** `gmtp.db.DbUtil`

**Interfaces implemented / class extended:** None (plain class, no `extends`, no `implements`)

**Imports:**
- `gmtp.GMTPMessage.Type`
- `gmtp.outgoing.OutgoingMessage`
- `java.io.InputStream`
- `java.sql.*`
- `java.util.*`
- `org.slf4j.Logger`
- `org.slf4j.LoggerFactory`
- `javax.sql.DataSource` (imported but unused)

**Fields:**
- `private static Logger logger` (line 25)

**Public methods (all `public static`):**

| Return type | Name | Parameters | Line |
|---|---|---|---|
| `boolean` | `callSpCardExMessage` | `Connection con, String unitName, String cardID, String remoteIP, String time` | 27 |
| `void` | `callSpGenericGmtpDataMessage` | `Connection con, String unitName, String data` | 74 |
| `void` | `callSpIoMessage` | `Connection con, String unitName, String data0, String data1, String data2, int ioNo` | 98 |
| `void` | `callSpDriverIoMessage` | `Connection con, String unitName, String driverID, String data0, String data1, String data2, int ioNo` | 125 |
| `void` | `callSpDriverIoMessages` | `Connection con, String unitName, String driverID, String[] data` | 154 |
| `void` | `callSpEosMessage` | `Connection con, String unitName, String driverID, String mast, ArrayList<String> data` | 191 |
| `void` | `callSpPstatMessage` | `Connection con, String unitName, String driverID, ArrayList<String> data` | 234 |
| `void` | `callSpStartupMessage` | `Connection con, String unitName, String unitTimeStamp` | 277 |
| `void` | `callSpPosMessage` | `Connection con, String unitName, String driverID, ArrayList<Long> data` | 302 |
| `void` | `callSpQueryStat` | `Connection con, String unitName, String driverID, String[] data` | 338 |
| `void` | `callSpQueryMastStat` | `Connection con, String unitName, String driverID, String mast, String[] data` | 372 |
| `void` | `callSpDriverShockMessage` | `Connection con, String unitName, String driverID, String dataX, String dataY` | 411 |
| `void` | `callSpOperationalChecklistMessage` | `Connection con, String unitName, String driverId, int surveyId, int questionNo, int response` | 446 |
| `void` | `callSpOperationalChecklistWithTimesMessage` | `Connection con, String unitName, String driverId, String curTestCompletionTime, String prevTestCompletionTime, int questionNo, int response` | 476 |
| `void` | `callSpGpsfMessage` | `Connection con, String unitName, String coord0, String coord1, String coord2` | 513 |
| `void` | `callSpGpseMessage` | `Connection con, String unitName, String[] data` | 541 |
| `void` | `callSpKeepAliveMessage` | `Connection con, String unitName` | 592 |
| `void` | `callSpUpdateConnection` | `Connection con, String unitName, String unitAddress, boolean connected` | 616 |
| `void` | `callSpShockMessage` | `Connection con, String unitName, String dataX, String dataY` | 646 |
| `void` | `callSpVersionMessage` | `Connection con, String unitName, String currentVersion, String availableVersion` | 673 |
| `void` | `callSpSsMessage` | `Connection con, String unitName, String speedShieldMsg` | 700 |
| `void` | `callSpQueryCard` | `Connection con, String unitName, String driverId` | 726 |
| `void` | `callSpQueryConf` | `Connection con, String unitName, String shockThreshold, String shockPeriod` | 752 |
| `void` | `callSpSeatBeltMessage` | `Connection con, String unitName, String driverID` | 779 |
| `void` | `callSpJobListMessage` | `Connection con, String unitName, String driverId, int jobNo, int status, String message` | 805 |
| `void` | `callDexMessage` | `Connection con, String unitName, String report` | 834 |
| `void` | `callDexeMessage` | `Connection con, String unitName, String report` | 860 |
| `void` | `callSpGprmcMessage` | `Connection con, String unitName, String[] gps, String hdop, String io` | 886 |
| `LinkedHashMap<Long, OutgoingMessage>` | `getOutgoingMessages` | `Connection con, String unitName, String extVersion, Boolean ack` | 921 |
| `boolean` | `removeOutgoingMessage` | `Connection con, long outgoing_id` | 998 |
| `boolean` | `removeOutgoingMessageACK` | `Connection con, String unitName, int dataId` | 1020 |
| `boolean` | `updateOutgoingMessage` | `Connection con, long outgoing_id` | 1046 |
| `Connection` | `getConnection` | `String unitName` | 1069 |
| `void` | `storeImage` | `Connection con, InputStream fis, int size, String fname, String gmtpId, String path` | 1102 |

---

### File 2: `src/gmtp/outgoing/OutgoingMessage.java`

**Fully qualified class name:** `gmtp.outgoing.OutgoingMessage`

**Interfaces implemented / class extended:** `extends GMTPMessage`

**Imports:**
- `gmtp.GMTPMessage`
- `gmtp.db.DbUtil`
- `java.sql.SQLException`
- `org.slf4j.Logger`
- `org.slf4j.LoggerFactory`

**Fields:**
- `private long dbId` (line 19)
- `private static Logger logger` (line 20)

**Public methods:**

| Return type | Name | Parameters | Line |
|---|---|---|---|
| (constructor) | `OutgoingMessage` | `Type type, int dataLen, String msgStr` | 22 |
| (constructor) | `OutgoingMessage` | `Type type, int dataId, int dataLen, String msgStr` | 26 |
| `void` | `setDatabaseId` | `long id` | 30 |
| `long` | `getDatabaseId` | (none) | 34 |
| `void` | `remove` | (none) | 41 |
| `void` | `update` | (none) | 52 |

---

### File 3: `src/gmtp/outgoing/OutgoingMessageManager.java`

**Fully qualified class name:** `gmtp.outgoing.OutgoingMessageManager`

**Interfaces implemented / class extended:** `extends Thread`

**Imports:**
- `gmtp.GMTPRouter`
- `gmtp.db.DbUtil`
- `java.sql.SQLException`
- `java.util.HashMap`
- `java.util.Map`
- `java.util.Map.Entry`
- `java.sql.Connection`
- `java.util.*`
- `java.util.logging.Level`
- `org.apache.mina.core.future.WriteFuture`
- `org.apache.mina.core.service.IoAcceptor`
- `org.apache.mina.core.session.IoSession`
- `org.apache.mina.transport.socket.SocketSessionConfig`
- `org.slf4j.Logger`
- `org.slf4j.LoggerFactory`

**Fields:**
- `private int sleepTime` (line 29)
- `private static Logger logger` (line 30)
- `private IoAcceptor acceptor` (line 31)
- `private Map<Long, IoSession> sessions` (line 32)
- `private OutgoingMessageSender sender` (line 33)
- `private boolean ack` (line 34)

**Public methods:**

| Return type | Name | Parameters | Line |
|---|---|---|---|
| (constructor) | `OutgoingMessageManager` | `IoAcceptor acceptor` | 36 |
| (constructor) | `OutgoingMessageManager` | `IoAcceptor acceptor, int sleepTime` | 42 |
| (constructor) | `OutgoingMessageManager` | `IoAcceptor acceptor, int sleepTime, int delay` | 49 |
| `void` | `setRefreshInterval` | `int sleepTime` | 58 |
| `void` | `run` | (none) | 63 |
| `void` | `setDelay` | `int outgoingDelay` | 122 |
| `void` | `setTcpNoDelay` | `boolean tcpNoDelay` | 126 |
| `boolean` | `isAck` | (none) | 131 |
| `void` | `setAck` | `boolean ack` | 135 |

---

## Security Checklist Findings

### SQL Injection (CRITICAL priority)

Every stored procedure call throughout `DbUtil.java` uses `CallableStatement` with parameterized `?` placeholders and `.setString()`/`.setInt()`/`.setTimestamp()` bindings. The stored procedure invocations are safe.

The two direct SQL `SELECT` queries and the DML statements (`getOutgoingMessages`, `removeOutgoingMessage`, `removeOutgoingMessageACK`, `updateOutgoingMessage`) all use `PreparedStatement` with `?` placeholders.

**No first-order SQL injection found in the query execution layer.**

However, a second-order / log-injection concern exists and is documented below (finding A45-1). Additionally, a variable used to select the pool name is derived from untrusted input and documented as A45-2.

### Database Credential Handling

Credentials are sourced from a `Configuration` object loaded at startup in `GMTPRouter.java` (outside the audited files). The `DbUtil.java` file itself does not handle or log credentials directly. The DB URL is logged via `con.getMetaData().getURL()` in every stored-procedure call — see finding A45-3.

### Connection Pool Security — Exhaustion Vectors

`getConnection()` is called from `OutgoingMessage.remove()` and `OutgoingMessage.update()` without any guard or rate limiting. The `OutgoingMessageManager.run()` loop iterates over every managed session every polling cycle and calls `getOutgoingMessages()` which opens a connection per session. With a large number of connected sessions the pool can be exhausted — see finding A45-4.

`GenericObjectPool` has `setMaxActive()` called in `GMTPRouter` but no `setMaxWait()` or `setWhenExhaustedAction()` is visible, which means the pool blocks indefinitely by default when exhausted. This is not directly auditable from the three assigned files but is relevant context.

### Connection Pool Security — Connections Not Returned

Every method in `DbUtil.java` closes the `Connection` in a `finally` block via `con.close()`. This returns the connection to the DBCP pool. However, every method also places executable code after the `con.close()` call inside the same `finally` block (timing statements), and some methods include a `return` statement inside the `finally` block. A `return` inside `finally` is a serious issue — see finding A45-5.

`OutgoingMessage.remove()` and `OutgoingMessage.update()` obtain connections via `DbUtil.getConnection()` and pass them to `DbUtil.removeOutgoingMessage()` / `DbUtil.updateOutgoingMessage()`. Those methods close the connection in their own `finally` blocks, so resource handling is consistent.

### Outgoing Message Security

Outgoing message content (`message` column from the `outgoing` table) is read from the database and placed directly into an `OutgoingMessage` object. There is no validation or sanitisation of the content before it is queued and sent. This is addressed in finding A45-6.

No SSRF vector was identified: the destination of outgoing messages is determined by the active `IoSession` (a connected TCP session managed by MINA), not by any data read from an external or untrusted source.

No resource leaks were identified in the outgoing message path from the three files; MINA's `IoSession.write()` handles buffer lifecycle.

### Error Handling

`getOutgoingMessages()` has a `return outgoingMap` statement inside the `finally` block (line 994). This suppresses any `SQLException` thrown from the `try` block, because the `finally` return overrides the re-throw — see finding A45-5.

`removeOutgoingMessage()` (line 1016) and `updateOutgoingMessage()` (line 1064) and `removeOutgoingMessageACK()` (line 1039) all `return false` from within `finally`, which similarly suppresses any exception thrown or re-thrown from the `try`/`catch`. This means callers can never observe the exception — see finding A45-5.

SQL exceptions do not propagate to external clients: they are caught and re-thrown to the call chain, eventually being caught and logged in `OutgoingMessage.remove()` and `OutgoingMessage.update()` (lines 44 and 55 respectively). No raw SQL error messages are written back to connected devices.

`getOutgoingMessages()` reads `result.getString("message")` without a null check. If the column is `NULL` in the database, `getString()` returns `null` and the subsequent `message.length()` call on line 962 will throw a `NullPointerException` — see finding A45-7.

### General Java Security

No `Runtime.exec()`, `ProcessBuilder`, `ObjectInputStream.readObject()`, or file path operations were found in any of the three audited files. No path traversal or deserialization vectors are present.

---

## Findings

## A45-1

**File:** src/gmtp/db/DbUtil.java
**Line:** 51–56 (representative; pattern repeated throughout the file at lines 85, 112, 141, 177, 222, 263, 289, 325, 358–359, 397, 427, 461, 493, 527, 568, 603, 632, 659, 685, 713, 738, 765, 791, 820, 846, 872, 906)
**Severity:** Medium
**Category:** Security > Log Injection / Sensitive Data in Logs
**Description:** Every stored procedure method builds a log string that embeds externally-supplied data values — `unitName`, `cardID`, `remoteIP`, `driverID`, message content, GPS coordinates, etc. — by formatting them with `String.format()` using `%s` and then writing the result to the application log. If any of these values contain newline characters (`\n`, `\r`) or log-framework-specific escape sequences they can inject spurious log entries, forge audit records, or cause log-parsing tools to misinterpret the log stream. Additionally, `data` payloads such as DEX reports (`callDexMessage`, line 846) and speed-shield messages (`callSpSsMessage`, line 713) that contain arbitrary vehicle telemetry are logged verbatim.
**Evidence:**
```java
String logStr = "select sp_cardmessage( '%s', '%s', '%s', '%s' );";
logger.info(con.getMetaData().getURL() + " " + String.format(logStr, now, unitName, cardID, remoteIP));
```
```java
String logStr = "select sp_dex_message( '%s', '%s', '%s');";
logger.info(con.getMetaData().getURL() + " " + String.format(logStr, now, unitName, report));
```
**Recommendation:** Sanitise all externally-supplied string values before logging by stripping or escaping CR/LF characters. Consider using parameterised SLF4J logging (`logger.info("...", arg1, arg2)`) which prevents injection into the format string itself, and avoid logging large, arbitrary payloads such as full DEX reports or GPS data streams at INFO level in production.

---

## A45-2

**File:** src/gmtp/db/DbUtil.java
**Line:** 1083–1086
**Severity:** High
**Category:** Security > Connection Pool Manipulation via Untrusted Input
**Description:** The `getConnection()` method constructs the DBCP pool name by extracting a prefix from the `unitName` parameter — the portion of the string before the first underscore character. This `unitName` value is supplied from the network (it is the identifier authenticated by the device at session open time and stored in the MINA session attribute `gmtp_id`). A device that authenticates with a carefully chosen identifier (e.g., `defaultDb_anything`) can force the server to resolve any registered pool name, including `defaultDb` and `configDb`. If a client can register a new pool or cause a lookup of a non-existent pool name, it can trigger pool allocation or silent fallback to the default database, potentially leaking data from the wrong customer schema. There is no whitelist validation of the extracted prefix against the set of legitimately registered pool names.
**Evidence:**
```java
public static Connection getConnection(String unitName) {
    boolean useNamedDB = true;
    int pos = -1;
    if (unitName == null) {
        useNamedDB = false;
    } else {
        pos = unitName.indexOf('_');
        if (pos < 0) {
            useNamedDB = false;
        }
    }
    String prefix = "defaultDb";
    if (useNamedDB) {
        prefix = unitName.substring(0, pos);
    }
    try {
        Connection con = DriverManager.getConnection("jdbc:apache:commons:dbcp:" + prefix);
        return con;
    } catch (SQLException ex) {
        logger.warn("Cannot lookup Connection for prefix: " + prefix + ". Using default");
    }
    // falls back to defaultDb silently
```
**Recommendation:** Maintain an explicit allowlist (e.g., a `Set<String>`) of registered pool name prefixes that is populated at startup. Validate the extracted prefix against this allowlist before using it. If the prefix is not in the allowlist, either reject the connection outright or fall back to the default pool with an audit-level warning, not a silent INFO-level warn.

---

## A45-3

**File:** src/gmtp/db/DbUtil.java
**Line:** 52, 56, 85, 112, 141, 177, 222, 263, 289, 325, 359, 397, 427, 462, 494, 527, 568, 603, 632, 659, 686, 713, 738, 765, 791, 820, 846, 872, 906, 1113
**Severity:** Medium
**Category:** Security > Sensitive Data Exposure in Logs (Database URL)
**Description:** Every stored-procedure method calls `con.getMetaData().getURL()` and prepends the result to every INFO-level log line. The JDBC URL contains the database host, port, and database name (e.g., `jdbc:postgresql://10.0.0.5:5432/customer_db`). In environments where credentials are embedded in the JDBC URL — a common pattern with older DBCP configurations — the username and password would also be written to the log in plaintext on every single database call. Even without embedded credentials, logging the full URL on every operation exposes internal network topology to anyone with log access.
**Evidence:**
```java
logger.info(con.getMetaData().getURL() + " " + String.format(logStr, now, unitName, cardID, remoteIP));
```
**Recommendation:** Log the database URL only once at startup (at DEBUG level) and remove `con.getMetaData().getURL()` from per-call log statements. If the target database must be identified per call, use a pre-computed opaque label (e.g., the pool prefix string) rather than the full JDBC URL.

---

## A45-4

**File:** src/gmtp/outgoing/OutgoingMessageManager.java
**Line:** 63–102
**Severity:** High
**Category:** Security > Connection Pool Exhaustion (Denial of Service)
**Description:** The `run()` method iterates over every active MINA session on each polling cycle and calls `getOutgoingMessages()` for each session. `getOutgoingMessages()` calls `DbUtil.getConnection()` which draws a connection from the pool. If there are more active sessions than connections available in the pool (which is bounded by `config.getConnectionPoolSize()` in `GMTPRouter`), the calling thread blocks indefinitely waiting for a connection (Apache Commons DBCP `GenericObjectPool` default `whenExhaustedAction` is `BLOCK`). Because `OutgoingMessageManager` is a single thread processing all sessions sequentially, blocking on one session stalls delivery for all sessions. An attacker who can maintain a large number of simultaneous TCP connections to the server can trivially exhaust the pool and halt all outgoing message delivery.
**Evidence:**
```java
for (Entry<Long, IoSession> sessionMap : sessions.entrySet()) {
    IoSession session = sessionMap.getValue();
    ...
    Map<Long, OutgoingMessage> outgoingMsgs = getOutgoingMessages(gmtp_id, extVersion);
    ...
}
```
```java
private Map<Long, OutgoingMessage> getOutgoingMessages(String gmtp_id, String extVersion) {
    try {
        Connection con = DbUtil.getConnection(gmtp_id);
        LinkedHashMap<Long, OutgoingMessage> outgoingMap = DbUtil.getOutgoingMessages(con, gmtp_id, extVersion, ack);
        return outgoingMap;
    } catch (Exception ex) { ... }
}
```
**Recommendation:** Set a finite `maxWait` on the `GenericObjectPool` so that pool exhaustion results in a fast `NoSuchElementException` rather than indefinite blocking. Implement a maximum connection limit per session or per unit prefix. Consider using an asynchronous, bounded queue for outgoing queries rather than a blocking per-session fetch on every cycle.

---

## A45-5

**File:** src/gmtp/db/DbUtil.java
**Line:** 987–995, 1009–1017, 1032–1040, 1057–1065
**Severity:** High
**Category:** Security > Exception Suppression via `return` in `finally` Block
**Description:** Four methods (`getOutgoingMessages`, `removeOutgoingMessage`, `removeOutgoingMessageACK`, `updateOutgoingMessage`) place a `return` statement inside the `finally` block. In Java, a `return` in `finally` unconditionally overrides any exception that is being propagated out of the `try` or `catch` block. This means that even though the `catch` blocks call `throw e`, the exception is silently swallowed by the `return false` / `return outgoingMap` in `finally`. Callers receive a normal return value and have no way to detect that the database operation failed. This masks data-loss conditions: a failed delete of an outgoing message will silently succeed from the caller's perspective, causing the message to be re-delivered indefinitely.
**Evidence:**
```java
// getOutgoingMessages (lines 987-995)
} catch (SQLException e) {
    logger.warn("Could not get outgoings for {}", unitName);
    throw e;   // <-- this throw is suppressed
} finally {
    con.close();
    long stop = System.currentTimeMillis();
    logger.info("...");
    return outgoingMap;  // <-- overrides the throw above
}
```
```java
// removeOutgoingMessage (lines 1009-1017)
} catch (SQLException e) {
    logger.warn("Could not delete outgoing {}", outgoing_id);
    throw e;   // <-- this throw is suppressed
} finally {
    con.close();
    ...
    return false;  // <-- overrides the throw above
}
```
**Recommendation:** Remove all `return` statements from `finally` blocks. Place the `return` statement at the end of the `try` block (after the normal-path logic completes). The `finally` block should only contain cleanup code (`con.close()`). This allows exceptions from `catch` to propagate correctly to callers.

---

## A45-6

**File:** src/gmtp/db/DbUtil.java
**Line:** 961–977
**Severity:** Medium
**Category:** Security > Missing Output Validation on Outgoing Message Content
**Description:** The `getOutgoingMessages()` method reads the `message` column from the `outgoing` table and constructs `OutgoingMessage` objects that are subsequently sent over the network to connected devices. There is no validation or sanitisation of the message content before it is queued. Any party with write access to the `outgoing` table (including application-layer code from other components sharing the same database) could insert a message containing binary sequences, control characters, or protocol-level framing bytes that could corrupt or exploit the MINA codec on the receiving device or on the server's encode path. This is a second-order injection vector via the database.
**Evidence:**
```java
String message = result.getString("message");
int dataLen = message.length();
...
OutgoingMessage tmp = new OutgoingMessage(Type.DATA_EXT, msgId, dataLen, message);
tmp.setGmtp_id(unitName);
tmp.setDatabaseId(dbId);
outgoingMap.put(i, tmp);
```
**Recommendation:** Validate the retrieved message content against an expected character set or maximum length before constructing `OutgoingMessage`. At minimum, enforce a maximum message length and reject or sanitise messages containing null bytes or control characters outside the expected GMTP protocol range.

---

## A45-7

**File:** src/gmtp/db/DbUtil.java
**Line:** 961–962
**Severity:** Medium
**Category:** Security > Missing Null Check on Query Result (NullPointerException)
**Description:** `result.getString("message")` may return `null` if the `message` column contains a SQL NULL value. The immediately following call `message.length()` on line 962 will then throw a `NullPointerException`. This is an unhandled exception in the `try` block of `getOutgoingMessages()`. Due to the `return outgoingMap` in the `finally` block (see A45-5), the NPE is silently swallowed and the method returns a partial or empty map. A single NULL-valued row in the `outgoing` table will cause all subsequent rows in the same result set (for that session) to be silently skipped.
**Evidence:**
```java
String message = result.getString("message");
int dataLen = message.length();   // NPE if message is NULL
```
**Recommendation:** Add a null check after `result.getString("message")`. If `message` is null, either skip the row with a warning log entry or substitute an empty string, depending on the protocol requirements.

---

## A45-8

**File:** src/gmtp/db/DbUtil.java
**Line:** 411–443
**Severity:** Low
**Category:** Security > Variable Shadowing (Logic Error with Timing Measurement)
**Description:** In `callSpDriverShockMessage()`, a local variable `long start` is declared at line 413 (outer scope, initialised to `System.currentTimeMillis()`) and then re-declared as a second `long start` at line 422 inside the `try` block. The inner declaration shadows the outer one. The `finally` block at line 440 declares `long stop = System.currentTimeMillis()` and computes `stop - start`. Because the `start` in scope at that point is the outer-scope `start` (line 413), the timing measurement is correct by accident — but the intent is clearly confused. More importantly, the same shadowing pattern appears in `removeOutgoingMessage()` (outer `start` at line 999, inner `start` at line 1001), `removeOutgoingMessageACK()` (lines 1021, 1023), and `updateOutgoingMessage()` (lines 1047, 1049). In those methods the inner `start` captures the time after the `PreparedStatement` is prepared, so the reported duration excludes statement preparation time and is misleading in audit and performance logs. While this is primarily a correctness issue, misleading timing data in security-audit logs can obscure slow-query attacks.
**Evidence:**
```java
public static void callSpDriverShockMessage(...) throws SQLException {
    long start = System.currentTimeMillis();   // outer start (line 413)
    try {
        ...
        long start = System.currentTimeMillis(); // inner start shadows outer (line 422)
        proc.execute();
        long stop = System.currentTimeMillis();
        ...
    } catch (...) { throw e; }
    finally {
        con.close();
        long stop = System.currentTimeMillis();
        logger.info("... took " + (stop - start) + "msec!"); // uses outer start
    }
}
```
**Recommendation:** Remove the inner `long start` declarations. Use the single outer-scope `start` variable for all timing measurements within a method, ensuring it is initialised before any database operation to capture total elapsed time accurately.

---

## Checklist Summary

| Checklist Item | Outcome |
|---|---|
| SQL injection — direct queries | No issues found (all parameterized) |
| SQL injection — second-order | Finding A45-6 (unvalidated DB content sent to network) |
| Database credential handling — hardcoded | Not in audited files; credentials sourced from Configuration object |
| Database credential handling — logged | Finding A45-3 (DB URL logged on every call) |
| Connection pool exhaustion | Finding A45-4 |
| Connections not returned on error | No issue; `finally` blocks close connections consistently |
| Outgoing message content validation | Finding A45-6 |
| Outgoing message SSRF | No issue; destination is an established MINA session |
| Resource leaks in message handling | No issue found in audited files |
| Swallowed exceptions | Finding A45-5 (`return` in `finally` suppresses rethrown exceptions) |
| SQL exceptions to external clients | No issue; exceptions do not reach network layer |
| Missing null checks on query results | Finding A45-7 |
| Command injection (Runtime.exec / ProcessBuilder) | No issue found |
| Deserialization of untrusted data | No issue found |
| Path traversal | No issue found |
| Log injection | Finding A45-1 |
| Untrusted input influences pool selection | Finding A45-2 |
| Variable shadowing / misleading audit logs | Finding A45-8 |
