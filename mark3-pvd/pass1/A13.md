# Pass 1 Audit — A13
**Date:** 2026-02-28
**Branch:** master
**Auditor:** A13

---

## Step 4 — Reading Evidence

### File Pair 1: InternalRfid

**File paths:**
- `/c/Projects/cig-audit/repos/mark3-pvd/platform/internalrfid.h`
- `/c/Projects/cig-audit/repos/mark3-pvd/platform/internalrfid.cpp`

**Class name and base classes:**
- `EM070::InternalRfid` : `QObject`

**Q_OBJECT macro location:**
- `internalrfid.h` line 12

**Public methods (signature : line):**
- `explicit InternalRfid(QObject *parent = 0)` : h:14 / cpp:12
- `void setEnabled(bool enabled)` : h:15 / cpp:38

**Signals:**
- `void response()` : h:18
- `void cardData(quint64 wiegand, quint16 facility, quint32 number, QByteArray &readerOutput)` : h:19
- `void error(const QString &text)` : h:20

**Slots (private):**
- `void readData()` (connected to `QSerialPort::readyRead`) : h:23 / cpp:51
- `void parseData()` : h:24 / cpp:67

**`#include` directives (cpp):**
- `#include "internalrfid.h"` (cpp:1)
- `#include "wiegandrfid.h"` (cpp:2)
- `#include <QSerialPort>` (cpp:3)
- `#include <QDebug>` (cpp:4)
- `#include "seriallogger.h"` (cpp:5)

**`#include` directives (h):**
- `#include <QObject>` (h:4)

**Serial port configuration:**
- Port name default: `/dev/ttyS2` (macro `FILE_SERIAL_PORT`, cpp:7)
- Port name override: environment variable `QT_RFID_SERIAL_PORT` (cpp:16–18)
- Baud rate: `QSerialPort::Baud115200` (cpp:22)
- Data bits: `Data8` (cpp:23)
- Stop bits: `OneStop` (cpp:24)
- Parity: `NoParity` (cpp:25)
- Flow control: `NoFlowControl` (cpp:26)

**Member variables:**
- `QSerialPort *m_serialPort` : h:26
- `QByteArray m_receiver` : h:27

**Key macros:**
- `FILE_SERIAL_PORT "/dev/ttyS2"` (cpp:7)
- `RECEIVER_MAX_SIZE 128` (cpp:8)

---

### File Pair 2: InternalRtc

**File paths:**
- `/c/Projects/cig-audit/repos/mark3-pvd/platform/internalrtc.h`
- `/c/Projects/cig-audit/repos/mark3-pvd/platform/internalrtc.cpp`

**Class name and base classes:**
- `EM070::InternalRtc` — no base class, no Q_OBJECT, static-method-only utility class

**Q_OBJECT macro location:**
- None

**Public methods (signature : line):**
- `static void setRtcTime(QDateTime dateTime = QDateTime())` : h:11 / cpp:10
- `static void setSystemTime()` : h:12 / cpp:24
- `static quint64 euiAddress()` : h:13 / cpp:31

**Signals:** None

**Slots:** None

**`#include` directives (cpp):**
- `#include "internalrtc.h"` (cpp:1)
- `#include <QFile>` (cpp:2)
- `#include <QProcess>` (cpp:3)

**`#include` directives (h):**
- `#include <QDateTime>` (h:4)

**Serial port configuration:** N/A

**Member variables:** None (all static methods)

**Key macros:**
- `FILE_RTC_DEVICE "/dev/rtc1"` (cpp:5)
- `FILE_RTC_EUI "/sys/devices/platform/nuc970-i2c0/i2c-0/0-006f/eui"` (cpp:6)

---

### File Pair 3: ModemPort

**File paths:**
- `/c/Projects/cig-audit/repos/mark3-pvd/platform/modemport.h`
- `/c/Projects/cig-audit/repos/mark3-pvd/platform/modemport.cpp`

**Class name and base classes:**
- `EM070::ModemPort` : `QObject`

**Q_OBJECT macro location:**
- `modemport.h` line 11

**Public methods (signature : line):**
- `explicit ModemPort(QObject *parent = nullptr)` : h:14 / cpp:12
- `bool sendCmd(const QByteArray &cmd)` : h:15 / cpp:125
- `void resetModem()` : h:16 / cpp:50
- `void setEnabled(bool enable)` : h:17 / cpp:68
- `void setEcho(bool enable)` : h:18 (inline)
- `bool isWwx()` : h:19 (inline)
- `void setWwx(bool isWwx)` : h:20 (inline)

**Signals:**
- `void portStateChanged(bool open)` : h:23
- `void response(bool ok, const QByteArrayList &content)` : h:24

**Private slots/methods:**
- `void openPort()` : h:27 / cpp:90
- `void portError()` : h:28 / cpp:108
- `void readData()` : h:29 / cpp:139
- `void parseData(const QByteArray &line)` : h:30 / cpp:168

**`#include` directives (cpp):**
- `#include "modemport.h"` (cpp:1)
- `#include "seriallogger.h"` (cpp:2)
- `#include <QProcess>` (cpp:3)
- `#include <QDebug>` (cpp:4)
- `#include <QFile>` (cpp:5)

**`#include` directives (h):**
- `#include <QObject>` (h:4)
- `#include <QSerialPort>` (h:5)
- `#include <QTimer>` (h:6)

**Serial port configuration:**
- Port name default (arm): `/dev/ttyUSB3` (macro `FILE_MODEM_PORT`, cpp:8), fallback `/dev/ttyUSB2` (cpp:7)
- Port name override: environment variable `QT_MOBILE_SERIAL_PORT` (cpp:21–23)
- Non-arm default: hardcoded `"COM4"` (cpp:33)
- Baud rate: `QSerialPort::Baud115200` (cpp:35)
- Data bits: `Data8` (cpp:36)
- Stop bits: `OneStop` (cpp:37)
- Parity: `NoParity` (cpp:38)
- Flow control: `NoFlowControl` (cpp:39)

**Member variables:**
- `QSerialPort *m_serialPort` : h:32
- `QTimer *m_timer` : h:33
- `int m_tryTimes` : h:34
- `QByteArray m_receiver` : h:35
- `QByteArrayList m_response` : h:36
- `QByteArray m_cmdLine` : h:37
- `bool m_echo` : h:38
- `bool m_wwx` : h:39

**Key macros:**
- `FILE_MODEM_PORT_WWX "/dev/ttyUSB2"` (cpp:7)
- `FILE_MODEM_PORT "/dev/ttyUSB3"` (cpp:8)

---

## Step 5 — Security Review

---

### 1. Memory Safety

**A13-1** · MEDIUM · Memory Safety
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/platform/internalrfid.cpp:53-58`
**Description:** `readData()` appends all available serial bytes to `m_receiver` before checking the size: `m_receiver += m_serialPort->readAll()` (line 53), then checks `if (m_receiver.size() > RECEIVER_MAX_SIZE)` (line 55). This means the buffer is allowed to grow beyond the 128-byte limit before the overflow is detected and the buffer cleared. A malicious or malfunctioning RFID reader could deliver a single large burst that exceeds RECEIVER_MAX_SIZE before the check fires. The correct pattern is to enforce the limit before appending. The reserve(RECEIVER_MAX_SIZE) call (line 34) sets internal capacity only and does not prevent the QByteArray from growing past that size.

**A13-2** · LOW · Memory Safety
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/platform/modemport.cpp:164-165`
**Description:** The `readData()` loop accumulates trailing bytes (non-terminated line fragments) into `m_receiver` indefinitely: `m_receiver += ba.right(size)` (line 165). There is no length cap on `m_receiver` for the modem port. A modem that streams data without a line terminator (or a line that is never terminated) will grow `m_receiver` without bound, consuming heap memory and potentially causing an out-of-memory crash on the embedded target. The RFID receiver has an explicit maximum-size guard; the modem receiver does not.

---

### 2. Communication Security

**A13-3** · HIGH · Communication Security
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/platform/internalrtc.cpp:19-21`
**Description:** `setRtcTime()` constructs a shell command string and executes it via `QProcess::execute(cmd)` where `cmd` is assembled from a hardcoded string plus the hardcoded macro `FILE_RTC_DEVICE`. Although in this specific instance the path is a compile-time constant, the pattern of constructing a shell command string and passing it to `QProcess::execute` is dangerous. `QProcess::execute(QString)` on Qt interprets the argument through the shell on some platforms. If `FILE_RTC_DEVICE` were ever sourced from a configuration file or environment variable, shell injection would be directly possible. The same pattern appears in `setSystemTime()` (line 26) and in `resetModem()` via `QProcess::startDetached("/etc/pvd/mobile -r")` (modemport.cpp:61). See also A13-4 for `resetModem()`.

**A13-4** · HIGH · Communication Security
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/platform/modemport.cpp:61`
**Description:** `QProcess::startDetached("/etc/pvd/mobile -r")` launches an external binary using a hardcoded absolute path in a single-string form. The path `/etc/pvd/mobile` is writable only by root on a standard Linux system, but passing the command as a single string to `startDetached` invokes shell processing. If the path or arguments ever become configurable this is a direct command injection path. Additionally, the detached process is started with no handle retained — there is no way to determine whether it launched successfully or to manage its lifecycle.

Communication Security (TLS, credentials, hardcoded keys): no issues found in these three files. The modem port transmits AT commands over a local serial port (not a network socket), and no APN credentials or authentication tokens appear in these files.

---

### 3. Input Handling

**A13-5** · MEDIUM · Input Handling
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/platform/internalrfid.cpp:108-109`
**Description:** The final `else` branch of `parseData()` emits `cardData(0, 0, 0, log)` for any trimmed line longer than 3 bytes that does not match the `#6:`, `#8:`, or `#R` prefixes (line 108–109). This means arbitrary unrecognised data from the RFID serial port will propagate upward to callers as a card-read event with wiegand=0, facility=0, number=0. If the upstream handler treats a wiegand value of 0 as a valid card presentation (even an access-denied one), this produces phantom authentication attempts from noise, framing errors, or from a spoofed device injecting garbage. No validation is performed that the data represents a well-formed RFID response before emitting the signal.

**A13-6** · MEDIUM · Input Handling
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/platform/internalrfid.cpp:83-95`
**Description:** RFID tag facility and card number values are parsed from hex strings and subjected only to a non-zero check (`if (facility && number)`) before being passed to the authentication function `wiegandData()` and emitted on the `cardData` signal (lines 86–87, 93–94). There is no range validation: facility is extracted as `quint8` from a 2-hex-digit field for the `#6:` format (line 84), but for `#8:` format facility is `quint16` from a 4-hex-digit field (line 91) — a value of `0xFFFF` is accepted without question. No maximum value check, format canonicalisation, or replay-protection mechanism is present before these values are used in authentication decisions.

**A13-7** · LOW · Input Handling
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/platform/internalrfid.cpp:79`
**Description:** `qDebug() << "Read internal card data: " << ba` logs raw RFID serial data to the debug output. The `ba` value is a trimmed `QByteArray` received directly from the serial port with no sanitisation. On a system where debug output is aggregated into a log file or transmitted over a network interface, this constitutes unauthenticated external data reaching log sinks. If the logging subsystem performs any further string interpolation, this could become a log injection vector. The same raw data flows into `SerialLogger::log` via the `log` variable constructed at line 81.

**A13-8** · LOW · Input Handling
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/platform/modemport.cpp:170`
**Description:** `qDebug() << "ModemPort <" << line` logs the full content of every line received from the modem to debug output without any sanitisation. Modem responses can include operator-provided strings (e.g., SMS body text, network operator name in `+COPS` responses) that an adversary with influence over the modem link could craft to inject content into logs.

---

### 4. Build Security

Build Security: no issues found. Build security (compiler flags, .pro file, strip configuration) is outside the scope of the three file pairs assigned to this auditor. No relevant build configuration is present in the reviewed files.

---

### 5. Device and Firmware

**A13-9** · MEDIUM · Device and Firmware
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/platform/internalrfid.cpp:7`
**Description:** The RFID serial port path `/dev/ttyS2` is hardcoded as a compile-time macro (`FILE_SERIAL_PORT`). While an environment variable override (`QT_RFID_SERIAL_PORT`) is supported, the fallback is a fixed kernel device node. On a device where the hardware layout changes (different carrier board revision, updated device tree), firmware must be recompiled to update the port assignment. More critically, no validation is performed on the `QT_RFID_SERIAL_PORT` environment variable value before use — any string set in the environment is accepted as a port name, potentially redirecting the RFID driver to an unintended device.

**A13-10** · MEDIUM · Device and Firmware
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/platform/internalrfid.cpp:83-109`
**Description:** There is no anti-replay mechanism for RFID authentication events. The RFID reader emits `cardData` signals for every parsed tag read with no sequence number, timestamp comparison, or deduplication window. A captured Wiegand transmission replayed over the serial interface (or a stuck reader transmitting the same tag ID repeatedly) will generate repeated authentication attempts indistinguishable from legitimate access. This is a fundamental anti-replay gap in the RFID authentication path.

**A13-11** · LOW · Device and Firmware
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/platform/internalrtc.cpp:6`
**Description:** The EUI address is read from a sysfs path `/sys/devices/platform/nuc970-i2c0/i2c-0/0-006f/eui` hardcoded as a compile-time macro. The EUI is returned as a `quint64` with no validation that the value is non-zero or within the valid EUI-64 range. A return value of 0 (file missing, read error, or device not present) is silently returned to the caller with no error indication beyond the fact that 0 is returned. If the EUI is used as a device identifier for authentication or registration, a zero value could cause device identity confusion.

**A13-12** · INFO · Device and Firmware
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/platform/modemport.cpp:29`
**Description:** The line `//m_wwx = true;` is a commented-out assignment that would enable the WWX modem variant path. The fallback device selection logic (lines 26–31) silently selects the WWX port (`/dev/ttyUSB2`) when the primary port (`/dev/ttyUSB3`) does not exist, but sets `m_wwx = false` (the commented line that would set it true is disabled). This means the device type flag does not reflect the actual hardware in use when the fallback path is taken, potentially causing incorrect modem initialisation commands to be sent. This appears to be a deliberate or inadvertent uncommitted change with a safety-affecting consequence.

---

### 6. Qt-Specific Security

**A13-13** · HIGH · Qt-Specific Security
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/platform/internalrtc.cpp:19-21`
**Description:** `QProcess::execute(cmd)` is called with a `QString` assembled by concatenation (line 21). Qt's `QProcess::execute(const QString &command)` overload on Linux passes the command through `/bin/sh -c`, which means shell metacharacters in the string are interpreted. Although `FILE_RTC_DEVICE` is a compile-time constant here, using the single-string `QProcess::execute` form instead of the `QProcess::execute(program, arguments)` overload is an unsafe pattern. The same applies to `setSystemTime()` (line 27) and `resetModem()` in modemport.cpp (line 61). All three call sites should use the two-argument `QProcess` form with a separate argument list to prevent shell injection if any part of the path ever becomes runtime-configurable.

**A13-14** · INFO · Qt-Specific Security
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/platform/internalrfid.cpp:44,46`
**Description:** `m_serialPort->write("AT+LFID=ON\r")` and `m_serialPort->write("AT+LFID=OFF\r")` use string literals that are not `QStringLiteral`-wrapped (they are `const char*` literals passed to `QSerialPort::write(const char*)`). This is not a security vulnerability but is noted for completeness: there is no return-value check on `write()`, so a failed write (serial port closed or error state) is silently ignored. The `waitForBytesWritten(10)` call uses a 10-millisecond timeout with no handling of the return value, so command delivery failure goes undetected.
