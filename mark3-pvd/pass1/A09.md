# Pass 1 — A09 Security Audit
**Repository:** mark3-pvd
**Branch:** master (confirmed)
**Date:** 2026-02-28
**Auditor:** A09
**Files reviewed:** `comm/gmtpchat.h`, `comm/gmtpchat.cpp`, `comm/modemchat.h`, `comm/modemchat.cpp`

---

## Reading Evidence

### File Pair 1: gmtpchat

**File paths:**
- `/c/Projects/cig-audit/repos/mark3-pvd/comm/gmtpchat.h`
- `/c/Projects/cig-audit/repos/mark3-pvd/comm/gmtpchat.cpp`

**Class name and base classes:**
- `GmtpChat : public QObject`

**Q_OBJECT macro location:**
- `gmtpchat.h` line 16

**Public methods (signature : line number):**
- `explicit GmtpChat(ModemChat *parent)` — h:21 / cpp:22
- `void setPowerState(CIGCONF::PowerState state)` — h:22 / cpp:70
- `void connectServer()` — h:23 / cpp:85
- `void sendMessage(const QByteArray &msgData, Priority priority = NormalPriority)` — h:24 / cpp:195
- `void sendAck(quint16 msgId)` — h:25 / cpp:225
- `void clearGMTPMsgQueue()` — h:26 / cpp:489
- `bool sleeping()` — h:27 (inline)
- `void setEthernetState(bool up)` — h:28 (inline)
- `bool acksRemaining()` — h:29 (inline)

**Signals:**
- `void cmdReceived(const QByteArray &ba)` — h:32
- `void socketStateChanged(bool state)` — h:33
- `void allMessagesSent()` — h:34
- `void allAcksSent()` — h:35
- `void gmtpHotStartReconnect()` — h:36
- `void disconnectSocket()` — h:37

**Private slots (connected in constructor):**
- `void readToQueue()` — cpp:405
- `void writeQueue(bool recent)` — cpp:434
- `void onConnected()` — cpp:144
- `void onDisconnected()` — cpp:173
- `void reconnectServer()` — cpp:112
- `void readSocket()` — cpp:323
- `void writeSocket()` — cpp:242
- `void bytesWritten(qint64 bytes)` — cpp:308
- `void ackTimeout()` — cpp:496
- `QByteArray packedMessage(const QByteArray &msgData, PduType type, quint16 ackId)` — cpp:380
- `void setOnIgnitionOffDisconnect(bool state)` — cpp:516
- `void disconnectFromHost()` — cpp:525

**#include directives (gmtpchat.cpp):**
- `#include "gmtpchat.h"` — cpp:1
- `#include "app/globalconfigs.h"` — cpp:2
- `#include "comm/modemchat.h"` — cpp:3
- `#include "platform/seriallogger.h"` — cpp:4
- `#include <QFile>` — cpp:5
- `#include <QDir>` — cpp:6
- `#include <QTimer>` — cpp:7
- `#include <QDebug>` — cpp:8
- `#include <QProcess>` — cpp:9 (included but QProcess not used in this file)
- `#include <QMutex>` — cpp:10
- `#include <unistd.h>` — cpp:13 (ARM-only)

**#include directives (gmtpchat.h):**
- `#include "app/cigconfigs.h"` — h:4
- `#include <QObject>` — h:5
- `#include <QQueue>` — h:6
- `#include <QTcpSocket>` — h:7
- `#include <QFile>` — h:8
- `#include <QMutex>` — h:9

**Protocol constants and message types:**
- `MAX_MESSAGE_CNT 1000` — cpp:16
- `MAX_RETRIES 3` — cpp:17
- `DEF_MSOCKET_TIMEOUT (10000)` — cpp:18
- `MAX_GMTP_RECONNECT_CNT (20)` — cpp:19
- `GMTP_SERVER_CNT 3` — cigconfigs.h:19
- `DIR_GMTP_MSG "/mnt/sd"` — cigconfigs.h:76
- PDU type enum: `PduId=1, PduData=2, PduIdExt=3, PduDataExt=4, PduAck=5` — h:19
- Server address and port come from `gCfg->gmtpServerAddress(m_serverIndex)` / `gCfg->gmtpServerPort(m_serverIndex)` at runtime (configurable; not hardcoded in source)

**Member variables:**
- `ModemChat *m_modemChat` — h:53
- `QTcpSocket *m_tcpSocket` — h:54
- `QTimer *m_socketTimer` — h:55
- `QTimer *m_uploadTimer` — h:56
- `QTimer *m_ackTimer` — h:57
- `CIGCONF::PowerState m_powerState` — h:58
- `int m_serverIndex` — h:60
- `QList<quint32> m_gmtpFileIndexes` — h:61
- `QQueue<QByteArray> m_uploadMessages` — h:63
- `QQueue<QByteArray> m_recentMessages` — h:64
- `QQueue<QByteArray> m_ackMessages` — h:65
- `QByteArray m_sendingMessage` — h:67
- `QByteArray m_downloadMessage` — h:68
- `quint16 m_msgId` — h:70
- `quint16 m_ackId` — h:71
- `quint8 m_retryCount` — h:72
- `quint8 m_reconnectCount` — h:73
- `bool m_idSent` — h:74
- `bool m_connect` — h:75
- `bool m_ethState` — h:76
- `bool m_onIgnitionOffDisconnect` — h:77
- `QMutex m_mutexConnectToHost` — h:78
- `QMutex m_mutexWriteSocket` — h:79
- `QMutex m_mutexDisconnectFromHost` — h:80

---

### File Pair 2: modemchat

**File paths:**
- `/c/Projects/cig-audit/repos/mark3-pvd/comm/modemchat.h`
- `/c/Projects/cig-audit/repos/mark3-pvd/comm/modemchat.cpp`

**Class name and base classes:**
- `ModemChat : public QObject`

**Q_OBJECT macro location:**
- `modemchat.h` line 20

**Public methods (signature : line number):**
- `explicit ModemChat(EM070::ModemPort *modemPort)` — h:24 / cpp:24
- `void portStateChanged(bool open)` — h:25 / cpp:59
- `void setGnssEnabled(bool enable)` — h:26 / cpp:116
- `void rssiRefresh()` — h:27 / cpp:131
- `void qmiCheck()` — h:28 / cpp:140
- `void networkCheck()` — h:29 / cpp:170
- `void updateApn()` — h:30 / cpp:316
- `void detach(bool send = true)` — h:31 / cpp:335
- `void requestDetach()` — h:32 / cpp:198
- `const QByteArray &cgmi() const` — h:34 (inline)
- `const QByteArray &cgmm() const` — h:35 (inline)
- `const QByteArray &cgmr() const` — h:36 (inline)
- `const QByteArray &cgsn() const` — h:37 (inline)
- `const QByteArray &iccid() const` — h:38 (inline)
- `const QByteArray &rssi() const` — h:39 (inline)
- `const QByteArray &mobileOperator() const` — h:40 (inline)
- `const QByteArray &moni() const` — h:41 (inline)
- `NetworkState networkState() const` — h:42 (inline)
- `bool isEthernetReady() const` — h:43 (inline)

**Signals:**
- `void simError()` — h:46
- `void ethernetStateChanged(bool ready)` — h:47

**Private slots (connected in constructor):**
- `void sendChat(bool timeout = false)` — cpp:228
- `void popChat()` — cpp:247
- `void pushChat(const QByteArray &chat)` — cpp:254
- `void noResponse()` — cpp:260
- `void parseResponse(bool result, const QByteArrayList &content)` — cpp:363
- `void selectAPN()` — cpp:270
- `void updateEthernetState(bool connected)` — cpp:217
- `void reconnectNetwork()` — cpp:819
- `void onUqmiProcessComplete(int exitCode, QProcess::ExitStatus exitStatus)` — cpp:765
- `void onProcessTimeout()` — cpp:203
- `void resetReconnectFlag()` — cpp:841
- `int args(const QByteArrayList &content, QGenericArgument val1, ...)` — cpp:696

**#include directives (modemchat.cpp):**
- `#include "modemchat.h"` — cpp:1
- `#include "platform/modemport.h"` — cpp:2
- `#include "platform/seriallogger.h"` — cpp:3
- `#include "app/globalconfigs.h"` — cpp:4
- `#include <QTimer>` — cpp:5
- `#include <QDebug>` — cpp:6
- `#include <QProcess>` — cpp:7
- `#include <QStringList>` — cpp:8

**#include directives (modemchat.h):**
- `#include <QProcess>` — h:8
- `#include <QObject>` — h:9
- `#include <QQueue>` — h:10

**Protocol constants:**
- `RETRY_WAIT 500` — cpp:10
- `RETRIES_PER_SEC (1000 / RETRY_WAIT)` — cpp:11
- `ACK_TIMEOUT 3000` — cpp:13
- `RSSI_INTERVAL 10000` — cpp:13
- `QMI_INTERVAL 2000` — cpp:14
- `NETWORK_INTERVAL 2000` — cpp:15
- `NETWORK_TIMEOUT 90` — cpp:16
- `MONOGOTO_PREFIX_SIZE (5)` — cpp:17
- `MAX_QMI_FAILURE_COUNT (7)` — cpp:18
- `PROCESS_MAX_WAIT_TIMEOUT (10000)` — cpp:19
- `MAX_CGDCONT 5` — cpp:20
- Hardcoded APN strings in `selectAPN()`: `"vfinternet.au"`, `"telstra.internet"`, `"om2moptus"`, `"vfd1.korem2m.com"`, `"stream.co.uk"`, `"hologram"`, `"data.mono"` — cpp:278-304
- Hardcoded APN credentials: `apnUser="Kore"`, `apnPassword="Kore"` (Kore M2M) — cpp:287-288; `apnUser="default"`, `apnPassword="void"` (three UK carriers) — cpp:291-303

**Member variables:**
- `EM070::ModemPort *m_modemPort` — h:74
- `QTimer *m_ackTimer` — h:75
- `QTimer *m_tryTimer` — h:76
- `QTimer *m_rssiTimer` — h:77
- `QTimer *m_qmiTimer` — h:78
- `QTimer *m_qmiStateTimer` — h:79
- `QTimer *m_networkTimer` — h:80
- `int m_networkCounter` — h:81
- `QProcess *m_qmiStateProcess` — h:82
- `QQueue<QByteArray> m_chatCmds` — h:83
- `int m_tryTimes` — h:84
- `QByteArray m_cgmi, m_cgmm, m_cgmr, m_cgsn, m_iccid, m_rssi, m_operator, m_moni` — h:86-93
- `NetworkState m_networkState` — h:94
- `bool m_gprsDetach` — h:95
- `bool m_gnssEnabled` — h:96
- `bool m_ethernetState` — h:97
- `apnData m_apn` (struct: apn, apnUser, apnPassword) — h:98
- `bool m_isPdpAuthSupported` — h:99
- `bool m_startReconnect` — h:100
- `bool m_detachRequested` — h:101
- `int m_cgdcontCount` — h:102

---

## Security Review

### 1. Memory Safety

**A09-1** · MEDIUM · Memory Safety
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/comm/gmtpchat.cpp:313`
**Description:** In `bytesWritten()`, `BE_SHORT(m_sendingMessage[2], m_sendingMessage[3])` accesses indices 2 and 3 of `m_sendingMessage` without first verifying that the buffer is at least 4 bytes long. If `m_sendingMessage` is empty or shorter than 4 bytes at the time this slot fires (a possible race condition given QueuedConnection across threads or after the `//m_sendingMessage.clear()` comment at line 315 was removed), this is an out-of-bounds read on a `QByteArray`. The same pattern occurs at `writeSocket()` line 279 (`m_sendingMessage[0]`, `m_sendingMessage[1]`) and line 292 (`m_sendingMessage[2]`, `m_sendingMessage[3]`) without a size guard.

**A09-2** · MEDIUM · Memory Safety
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/comm/gmtpchat.cpp:357`
**Description:** In `readSocket()`, when a `PduAck` is received, `BE_SHORT(m_sendingMessage[0], m_sendingMessage[1])` is accessed at line 357 without checking whether `m_sendingMessage` is non-empty. The guard at line 500 (`ackTimeout`) checks `!m_sendingMessage.isEmpty()` before access, but the `readSocket()` PduAck branch at line 357 has no such guard, creating a potential out-of-bounds read if `m_sendingMessage` was cleared between the ACK being sent and the response being parsed.

**A09-3** · LOW · Memory Safety
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/comm/gmtpchat.cpp:65`
**Description:** In the constructor, GMTP file indexes are parsed with `name.mid(7, 8).toUInt()`. If a filesystem entry in `DIR_GMTP_MSG` matches the `gmtpmsg*.txt` pattern but has a non-numeric 8-character field, `toUInt()` silently returns 0. This could lead to silent collision on index 0 and corrupt or overwrite the `gmtpmsg00000000.txt` queue file. No validation of the parsed index value is performed.

### 2. Communication Security

**A09-4** · CRITICAL · Communication Security
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/comm/gmtpchat.h:7` / `/c/Projects/cig-audit/repos/mark3-pvd/comm/gmtpchat.cpp:24`
**Description:** The GMTP connection uses a plain `QTcpSocket` (not `QSslSocket`). There is no TLS anywhere in `gmtpchat.h` or `gmtpchat.cpp`. All GMTP traffic — including the device identity PDU (`PduIdExt` containing `gCfg->gmtpId()`), proximity events, GPS position, driver IDs, and server commands — is transmitted in cleartext over the cellular network. This is a safety-critical finding: an attacker able to intercept cellular traffic can read driver identifiers, forge server commands (including `CMD_IDAUTH`, `CMD_IDDENY`, `CMD_SHTD`, `CMD_REBOOT`), and inject arbitrary command payloads that will be forwarded via the `cmdReceived` signal.

**A09-5** · HIGH · Communication Security
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/comm/gmtpchat.cpp:98` / `103-104`
**Description:** Server address and port are read from `gCfg->gmtpServerAddress(m_serverIndex)` and `gCfg->gmtpServerPort(m_serverIndex)` at runtime. While not hardcoded in these source files directly, the `GlobalConfigs` struct stores them in a config block that is provisioned over the plaintext GMTP connection itself (via `CMD_HOST`/`CMD_PORT` commands). Because the transport is unauthenticated and unencrypted (see A09-4), these can be changed to point the device to an attacker-controlled server via a man-in-the-middle injection. There is no certificate pinning or any server authentication mechanism.

**A09-6** · HIGH · Communication Security
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/comm/modemchat.cpp:287-288`
**Description:** Hardcoded APN credentials for the Kore M2M network are present in source: `apnUser = "Kore"`, `apnPassword = "Kore"`. These credentials are embedded in firmware and will appear in all deployed units using SIM cards with ICCID prefix `893144`. While APN credentials are carrier-issued and broadly known, their presence in source means they cannot be rotated per-unit or per-deployment without a firmware update.

**A09-7** · MEDIUM · Communication Security
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/comm/modemchat.cpp:291-303`
**Description:** Hardcoded APN credentials `apnUser = "default"`, `apnPassword = "void"` are used for three separate ICCID prefixes (`894450`, `894620`, `891223`) all routing through `stream.co.uk`. These credentials are embedded in firmware. Same rotation risk as A09-6.

**A09-8** · MEDIUM · Communication Security
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/comm/gmtpchat.cpp:163`
**Description:** The GMTP registration PDU sends `gCfg->gmtpId()` as the device identity in plaintext in the first message after TCP connection. This device identifier is transmitted without any challenge-response authentication or MAC. A server receiving this message has no way to verify that the connecting device is genuine. Combined with the lack of TLS (A09-4), this means a device ID can be trivially replayed or spoofed.

### 3. Input Handling

**A09-9** · HIGH · Input Handling
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/comm/gmtpchat.cpp:340`
**Description:** In `readSocket()`, `dataSize` is read from bytes 4-5 of the received TCP stream as a `quint16` (max 65535 bytes). The check at line 342 (`if (ba.size() < 6 + dataSize)`) handles partial reads correctly by buffering. However, there is no upper-bound validation on `dataSize` before buffering — a server (or attacker) can send a PDU advertising a `dataSize` of 65535 bytes, causing the device to accumulate up to 65535 + 6 bytes into `m_downloadMessage` before processing. Additionally, there is no limit on how many partial-read accumulations can occur: if a sender repeatedly sends 5-byte fragments, `m_downloadMessage` can grow indefinitely. This is a potential denial-of-service via memory exhaustion.

**A09-10** · MEDIUM · Input Handling
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/comm/gmtpchat.cpp:348`
**Description:** The `cmdReceived` signal emits `ba.mid(6, dataSize)` directly to the application layer without any content validation. The receiving code (not in scope for this file pair, but visible from the signal name `cmdReceived`) is expected to parse this as an AT-style command. If `dataSize` is 0, an empty `QByteArray` is emitted. There is no check that the payload conforms to the expected command format before emission. This passes the full responsibility for input validation to the signal consumer with no defensive filtering at the protocol boundary.

**A09-11** · MEDIUM · Input Handling
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/comm/gmtpchat.cpp:371-372`
**Description:** In `readSocket()`, the `else` branch at line 371 handles unknown PDU types by advancing the buffer by a single byte (`ba.remove(0, 1)`). This byte-by-byte scan is a performance concern on long malformed streams, but more critically it means a malformed or attacker-controlled stream can cause the socket handler to loop for the full length of the received buffer, processing one byte at a time, potentially stalling the Qt event loop for non-trivial data volumes.

**A09-12** · MEDIUM · Input Handling
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/comm/modemchat.cpp:667`
**Description:** The `+CGEV:` handler processes unsolicited modem notifications. The event string is taken directly from modem serial output (`echo.mid(7)`) and logged. The check `echo.mid(7).toUpper().contains(QByteArray("DETACH").toUpper())` is a case-insensitive substring search, which is safe for this specific path. However, the broader `parseResponse()` function at line 363 treats the entire first element of `content` as a trusted command echo without sanitising it before using it in comparisons. If the modem's serial output can be manipulated (e.g., via a rogue modem firmware or hardware attack), the logic branches in `parseResponse()` can be driven in unintended ways, including injecting AT commands via `pushChat()`.

**A09-13** · LOW · Input Handling
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/comm/modemchat.cpp:749`
**Description:** In the `args()` function, the boolean-type branch at line 749 contains a logic inversion: the condition is `if (val >= 0 || val <= 1)` but should almost certainly be `if (val >= 0 && val <= 1)`. The `||` operator makes this condition always true for any integer value (since every integer is either >= 0 or <= 1), meaning the range check is ineffective. An AT response providing a value such as `255` for a boolean field would be silently accepted and stored.

### 4. Build Security

**A09-14** · HIGH · Build Security
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/mk3.pro`
**Description:** The project file contains no compiler security hardening flags. The following flags are absent: `-fstack-protector-strong` (stack smashing protection), `-D_FORTIFY_SOURCE=2` (stdlib buffer overflow detection), `-fPIE`/`-pie` (ASLR support for the executable), and `-Wformat -Wformat-security` (format string vulnerability warnings). On an ARM embedded Linux target running safety-critical vehicle proximity detection software, the absence of all these mitigations leaves the device without standard exploit-mitigation defences.

**A09-15** · MEDIUM · Build Security
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/comm/gmtpchat.cpp:148` and multiple locations
**Description:** `qDebug()` calls are present throughout both files (e.g., `qDebug() << "GMTP Connected"` at gmtpchat.cpp:148, and multiple `qDebug()`/`qWarning()` calls in modemchat.cpp). These emit server addresses, APN credentials, uqmi command output, and network state to the debug output at runtime. If debug output is enabled in a production build (Qt does not strip `qDebug` unless `QT_NO_DEBUG_OUTPUT` is defined or `CONFIG += release` suppresses it), this information is accessible on the device's serial console. The `.pro` file does not define `QT_NO_DEBUG_OUTPUT` or `QT_NO_WARNING_OUTPUT`.

**A09-16** · MEDIUM · Build Security
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/comm/modemchat.cpp:836`
**Description:** APN credentials (`m_apn.apn`, `m_apn.apnUser`, `m_apn.apnPassword`) are logged via `qDebug()` at the `reconnectNetwork()` function: `qDebug() << "[ModemChat] Executing reconnect command with APN:" << m_apn.apn << m_apn.apnUser << m_apn.apnPassword`. If debug output is enabled on a production device, this logs credentials to the serial console in cleartext.

### 5. Device and Firmware

**A09-17** · HIGH · Device and Firmware
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/comm/modemchat.cpp:270-313`
**Description:** The `selectAPN()` function contains a hardcoded mapping of SIM ICCID prefixes to APN names and credentials. This mapping is baked into firmware and cannot be updated without a full firmware release. Adding a new carrier or rotating credentials requires a firmware build and OTA update. More critically, ICCID prefix matching (6 or 5 digits) is the sole criterion for selecting the APN and credentials — there is no fallback validation and an incorrect match (e.g., if a future SIM ICCID collides with a prefix) would silently apply the wrong APN and credentials.

**A09-18** · MEDIUM · Device and Firmware
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/comm/modemchat.cpp:160`
**Description:** The `uqmi` process is launched with a hardcoded device path `/dev/cdc-wdm0`. This path is not configurable and is embedded in the binary. On a device where this path does not exist or has been redirected, the process launch fails silently (a warning is logged but execution continues). There is no integrity check that the device at this path is the expected QMI modem interface.

**A09-19** · INFO · Device and Firmware
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/app/cigconfigs.h:76`
**Description:** GMTP message persistence uses `/mnt/sd` (the SD card) as `DIR_GMTP_MSG`. GMTP messages queued to disk (in `gmtpmsg*.txt` files) contain raw application-layer payload data. These files are plaintext and unencrypted. If the SD card is physically removed from a deployed unit, an attacker can read the pending GMTP message queue, which may include proximity events, driver IDs, GPS positions, and other operational data.

### 6. Qt-Specific Security

**A09-20** · HIGH · Qt-Specific Security
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/comm/modemchat.cpp:820-838`
**Description:** `reconnectNetwork()` constructs a `QProcess` launch of `sh -x /etc/ci/qmi_reconnect` with APN name, username, and password passed as command-line arguments (`arguments << m_apn.apn`, `<< m_apn.apnUser`, `<< m_apn.apnPassword`). The APN values ultimately derive from `gCfg->apn()`, `gCfg->apnUser()`, `gCfg->apnPassword()` when the mode is non-auto (modemchat.cpp:309-311), and these are set via the GMTP `CMD_*` command channel which is unauthenticated and unencrypted. If an attacker can inject a command over the GMTP channel to set the APN fields to values containing shell metacharacters, those characters are passed as arguments to `sh`. While `QProcess` with a `QStringList` arguments list does not invoke the shell for argument splitting (preventing shell injection via the argument list itself), the script `/etc/ci/qmi_reconnect` receives them as `$1`, `$2`, `$3` positional parameters. If that script uses these parameters in an unquoted shell expansion (which is a common scripting error), shell injection becomes possible. The `-x` flag passed to `sh` also enables verbose tracing, which will echo all expanded commands including credentials to the shell's stderr.

**A09-21** · MEDIUM · Qt-Specific Security
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/comm/modemchat.cpp:209`
**Description:** `QProcess::startDetached("killall uqmi")` is called in `onProcessTimeout()` and `onUqmiProcessComplete()` on error paths. `startDetached` with a plain string invokes the system shell. The command string is a fixed literal (`"killall uqmi"`) and is not constructed from user-controlled data, so there is no injection risk here; however, `QProcess::startDetached(const QString &command)` (the single-string overload) passes the command through the shell, which is a less safe API than the `(program, args)` overload. This is flagged as a pattern to watch.

**A09-22** · LOW · Qt-Specific Security
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/comm/gmtpchat.cpp:9`
**Description:** `#include <QProcess>` is present in `gmtpchat.cpp` but `QProcess` is not used anywhere in that file. This is dead code / unnecessary include. While not a security vulnerability in isolation, it widens the apparent attack surface and may confuse future reviewers into expecting QProcess usage.

---

## Summary Table

| ID | Severity | Category | File |
|----|----------|----------|------|
| A09-1 | MEDIUM | Memory Safety | gmtpchat.cpp:279,292,313 |
| A09-2 | MEDIUM | Memory Safety | gmtpchat.cpp:357 |
| A09-3 | LOW | Memory Safety | gmtpchat.cpp:65 |
| A09-4 | CRITICAL | Communication Security | gmtpchat.h:7 / gmtpchat.cpp:24 |
| A09-5 | HIGH | Communication Security | gmtpchat.cpp:98,103-104 |
| A09-6 | HIGH | Communication Security | modemchat.cpp:287-288 |
| A09-7 | MEDIUM | Communication Security | modemchat.cpp:291-303 |
| A09-8 | MEDIUM | Communication Security | gmtpchat.cpp:163 |
| A09-9 | HIGH | Input Handling | gmtpchat.cpp:340 |
| A09-10 | MEDIUM | Input Handling | gmtpchat.cpp:348 |
| A09-11 | MEDIUM | Input Handling | gmtpchat.cpp:371-372 |
| A09-12 | MEDIUM | Input Handling | modemchat.cpp:667 |
| A09-13 | LOW | Input Handling | modemchat.cpp:749 |
| A09-14 | HIGH | Build Security | mk3.pro |
| A09-15 | MEDIUM | Build Security | gmtpchat.cpp:148 / modemchat.cpp (multiple) |
| A09-16 | MEDIUM | Build Security | modemchat.cpp:836 |
| A09-17 | HIGH | Device and Firmware | modemchat.cpp:270-313 |
| A09-18 | MEDIUM | Device and Firmware | modemchat.cpp:160 |
| A09-19 | INFO | Device and Firmware | cigconfigs.h:76 |
| A09-20 | HIGH | Qt-Specific Security | modemchat.cpp:820-838 |
| A09-21 | MEDIUM | Qt-Specific Security | modemchat.cpp:209 |
| A09-22 | LOW | Qt-Specific Security | gmtpchat.cpp:9 |
