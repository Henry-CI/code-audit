# Pass 1 Audit — A11
**Auditor:** A11
**Date:** 2026-02-28
**Branch:** master
**Repo:** /c/Projects/cig-audit/repos/mark3-pvd

---

## Step 4 — Reading Evidence

### File Pair 1: aescrypto

**File paths:**
- `/c/Projects/cig-audit/repos/mark3-pvd/platform/aescrypto.h`
- `/c/Projects/cig-audit/repos/mark3-pvd/platform/aescrypto.cpp`

**Class name and base classes:**
- `AesCrypto` (no base class; plain C++ class, not a QObject)
- Namespace: `EM070`

**Public methods (with signature and line number):**
- `static QByteArray encrypt(const QByteArray &in)` — aescrypto.h:16, aescrypto.cpp:150
- `static QByteArray descrypt(const QByteArray &in)` — aescrypto.h:17, aescrypto.cpp:156

**Private methods:**
- `bool enableMtp()` — aescrypto.h:20, aescrypto.cpp:20
- `QByteArray aes(const QByteArray &in, bool encrypt)` — aescrypto.h:21, aescrypto.cpp:63

**Signals:** none
**Slots:** none
**Q_OBJECT macro:** not present

**#include directives (aescrypto.cpp):**
- `#include "aescrypto.h"` — line 1
- `#include <unistd.h>` — line 3 (ARM only, inside `#ifdef __arm__`)
- `#include <linux/if_alg.h>` — line 4 (ARM only)
- `#include <sys/socket.h>` — line 5 (ARM only)
- `#include <QDebug>` — line 7

**#include directives (aescrypto.h):**
- `#include <QByteArray>` — line 4

**Cryptographic constants:**
- Cipher algorithm: `"cbc(aes)"` — aescrypto.cpp:79
- IV size: 16 bytes (set via `iv->ivlen = 16`) — aescrypto.cpp:123
- Hardcoded IV value: `\x3d\xaf\xba\x42\x9d\x9e\xb4\x30\xb4\x22\xda\x80\x2c\x9f\xac\x41` — aescrypto.cpp:124
- Key source: hardware MTP (Manufacturing Test Protection) key via `ALG_USE_MTP_KEY` socket option — aescrypto.cpp:86
- Key size: determined by hardware MTP; not set in source
- Block cipher mode: CBC

**Member variables:**
- `static bool m_mtpEnabled` — aescrypto.h:22, aescrypto.cpp:18

---

### File Pair 2: blecentral

**File paths:**
- `/c/Projects/cig-audit/repos/mark3-pvd/platform/blecentral.h`
- `/c/Projects/cig-audit/repos/mark3-pvd/platform/blecentral.cpp`

**Classes and base classes:**
- `CharacteristicInfo : public QObject` — blecentral.h:13
- `DescriptorInfo : public QObject` — blecentral.h:31
- `BleCentral : public QObject` — blecentral.h:45
- Namespace: `EM070`

**Q_OBJECT macro locations:**
- `CharacteristicInfo` — blecentral.h:15
- `DescriptorInfo` — blecentral.h:32
- `BleCentral` — blecentral.h:47

**Public methods of BleCentral (with signature and line number):**
- `explicit BleCentral(QObject *parent = nullptr)` — blecentral.h:51, blecentral.cpp:14
- `~BleCentral()` — blecentral.h:52, blecentral.cpp:42
- `void setEnabled(bool enable)` — blecentral.h:54, blecentral.cpp:74
- `void setPeripheralAddress(const quint64 &address)` — blecentral.h:56, blecentral.cpp:54
- `void setAuthorizationCode(const quint128 &uuid, const QByteArray &code)` — blecentral.h:57, blecentral.cpp:68
- `State state() const` — blecentral.h:59
- `QByteArrayList servicesUuid() const` — blecentral.h:61, blecentral.cpp:303
- `QByteArrayList characteristicsUuid() const` — blecentral.h:62, blecentral.cpp:312
- `QByteArrayList descriptionsUuid() const` — blecentral.h:63, blecentral.cpp:321
- `bool readCharacteristic(const quint128 &uuid)` — blecentral.h:65, blecentral.cpp:350
- `bool writeCharacteristic(const quint128 &uuid, const QByteArray &ba)` — blecentral.h:66, blecentral.cpp:364
- `bool readDescriptor(const quint128 &uuid)` — blecentral.h:67, blecentral.cpp:378
- `bool writeDescriptor(const quint128 &uuid, const QByteArray &ba)` — blecentral.h:68, blecentral.cpp:396

**Signals of BleCentral:**
- `void accessible(bool yes)` — blecentral.h:71
- `void error(QBluetoothDeviceDiscoveryAgent::Error newError)` — blecentral.h:74
- `void error(QLowEnergyController::Error newError)` — blecentral.h:77
- `void error(QLowEnergyService::ServiceError newError)` — blecentral.h:80
- `void characteristicChanged(const quint128 &uuid, const QByteArray &newValue)` — blecentral.h:81
- `void characteristicRead(const quint128 &uuid, const QByteArray &value)` — blecentral.h:82
- `void characteristicWritten(const quint128 &uuid, const QByteArray &newValue)` — blecentral.h:83
- `void descriptorRead(const quint128 &uuid, const QByteArray &value)` — blecentral.h:84
- `void descriptorWritten(const quint128 &uuid, const QByteArray &newValue)` — blecentral.h:85

**Private slots/methods of BleCentral:**
- `const DescriptorInfo *descriptionInfo(const quint128 &uuid)` — blecentral.h:88, blecentral.cpp:330
- `const CharacteristicInfo *characteristicInfo(const quint128 &uuid)` — blecentral.h:89, blecentral.cpp:340
- `void startDeviceDiscovery()` — blecentral.h:91, blecentral.cpp:101
- `void connectToDevice()` — blecentral.h:92, blecentral.cpp:143
- `void addDevice(const QBluetoothDeviceInfo &)` — blecentral.h:95, blecentral.cpp:110
- `void deviceDiscoveryFinished()` — blecentral.h:96, blecentral.cpp:125
- `void deviceDiscoveryError(QBluetoothDeviceDiscoveryAgent::Error)` — blecentral.h:97, blecentral.cpp:136
- `void deviceConnected()` — blecentral.h:100, blecentral.cpp:181
- `void deviceDisconnected()` — blecentral.h:101, blecentral.cpp:196
- `void addService(const QBluetoothUuid &newService)` — blecentral.h:102, blecentral.cpp:205
- `void serviceDiscoveryFinished()` — blecentral.h:103, blecentral.cpp:246
- `void serviceStateChanged(QLowEnergyService::ServiceState newState)` — blecentral.h:106, blecentral.cpp:257

**#include directives (blecentral.cpp):**
- `#include "blecentral.h"` — line 1
- `#include "seriallogger.h"` — line 2
- `#include <QTimer>` — line 3
- `#include <QDebug>` — line 4
- `#include <QLowEnergyConnectionParameters>` — line 5

**#include directives (blecentral.h):**
- `#include <QObject>` — line 4
- `#include <QBluetoothDeviceDiscoveryAgent>` — line 5
- `#include <QBluetoothDeviceInfo>` — line 6
- `#include <QLowEnergyController>` — line 7

**Member variables of BleCentral:**
- `QTimer *m_discoveryTimer` — blecentral.h:108
- `QTimer *m_reconnectTimer` — blecentral.h:109
- `QBluetoothDeviceInfo m_device` — blecentral.h:111
- `QBluetoothDeviceDiscoveryAgent *m_discoveryAgent` — blecentral.h:112
- `QLowEnergyController *m_controller` — blecentral.h:113
- `QList<QLowEnergyService *> m_services` — blecentral.h:115
- `QList<CharacteristicInfo *> m_charInfos` — blecentral.h:116
- `QList<DescriptorInfo *> m_descInfos` — blecentral.h:117
- `QBluetoothAddress m_previousAddress` — blecentral.h:119
- `QBluetoothAddress m_peripheralAddress` — blecentral.h:120
- `QBluetoothUuid m_authUuid` — blecentral.h:121
- `QByteArray m_authCode` — blecentral.h:122
- `State m_state` — blecentral.h:124
- `int m_serviceIndex` — blecentral.h:125

---

## Step 5 — Security Review

---

**A11-1** · CRITICAL · Communication Security
**File:** `platform/aescrypto.cpp:124`
**Description:** A hardcoded, static IV (`\x3d\xaf\xba\x42\x9d\x9e\xb4\x30\xb4\x22\xda\x80\x2c\x9f\xac\x41`) is embedded as a string literal in source. The same 16-byte value is passed to every single encrypt and decrypt operation via `memcpy(iv->iv, ...)`. In CBC mode, reusing an identical IV for all encryptions eliminates the semantic security of the cipher: two plaintexts that share a common prefix will produce identical ciphertext prefixes, making traffic analysis and pattern recognition trivially possible. An attacker who can observe multiple ciphertext blocks encrypted with the same key and IV can also mount chosen-plaintext attacks. A unique, cryptographically random IV must be generated per operation (e.g., via `/dev/urandom` or the kernel's `getrandom()` syscall) and transmitted alongside the ciphertext.

---

**A11-2** · HIGH · Memory Safety
**File:** `platform/aescrypto.cpp:32`
**Description:** `::strcpy((char *) sa.salg_type, "skcipher")` is called unconditionally on the `salg_type` field of a `struct sockaddr_alg`. The field `salg_type` is declared in `<linux/if_alg.h>` as `__u8 salg_type[14]`. The string `"skcipher"` is 8 characters plus a null terminator (9 bytes), which fits within 14 bytes in this instance — however the same pattern is repeated for `salg_name` at line 33 with the value `"mtp"` and again at line 78 with `"cbc(aes)"`. While the current string literals fit, the use of `strcpy` into fixed-size kernel struct fields is inherently unsafe: any future change to the algorithm name string without updating a paired length check would overflow the destination buffer without warning. No bounds checking exists. The bounded alternative `strncpy` with the exact field size should be used for all such copies.

---

**A11-3** · HIGH · Memory Safety
**File:** `platform/aescrypto.cpp:78`
**Description:** `::strcpy((char *) sa.salg_name, "cbc(aes)")` writes into `sockaddr_alg.salg_name`, which is declared as `__u8 salg_name[64]` in `<linux/if_alg.h>`. The current literal fits, but the function also copies into `salg_type` (14-byte field) at line 77 using the same unchecked `strcpy` pattern. Combining with the same issue in `enableMtp()`, there are four total `strcpy` calls into kernel struct fields across the two functions (lines 32, 33, 77, 78), all without bounds checking. These should all be replaced with `strncpy` specifying the exact field sizes.

---

**A11-4** · HIGH · Memory Safety
**File:** `platform/aescrypto.cpp:131-141`
**Description:** The return values of `sendmsg(tfd, &msg, MSG_MORE)` and `read(tfd, ba.data() + i, 1024)` are never checked within the processing loop (lines 134–135) or in the tail read (lines 140–141). If `sendmsg` returns an error (e.g., due to a kernel-side failure or partial send) or `read` returns fewer bytes than requested, the code continues silently and writes into the output buffer `ba` at the current offset as though a full 1024 bytes were returned. This results in a partially zeroed or stale output buffer being returned to callers as if it were valid ciphertext or plaintext, corrupting the result without any error indication to higher layers.

---

**A11-5** · MEDIUM · Memory Safety
**File:** `platform/aescrypto.cpp:99`
**Description:** The control message buffer `cbuf` is declared as `char cbuf[CMSG_SPACE(4) + CMSG_SPACE(20)]`. The second CMSG entry sets `cmsg->cmsg_len = CMSG_LEN(20)` at line 121, where the 20-byte data region holds a 4-byte `ivlen` field plus 16 bytes of IV data. The `CMSG_SPACE(20)` allocation provides space for the ancillary data header plus 20 bytes of payload, which matches correctly. However, the `af_alg_iv` struct layout is `{ __u32 ivlen; __u8 iv[0]; }` — the actual IV data begins at `iv->iv` which is at offset 4 within the CMSG payload. The total CMSG payload consumed is 4 (ivlen) + 16 (iv data) = 20 bytes, which exactly fills the allocated space with no margin. If the kernel's `CMSG_SPACE` macro pads differently than expected, or if `ivlen` is set to a value larger than 16 in a future change without adjusting the buffer allocation, a stack buffer overflow occurs in the control message region.

---

**A11-6** · MEDIUM · Communication Security
**File:** `platform/aescrypto.cpp:63-148`
**Description:** The `aes()` function is conditionally compiled: the entire implementation, including all socket setup, key configuration, and encrypt/decrypt logic, is wrapped in `#ifdef __arm__`. On non-ARM platforms (e.g., x86 development machines, CI build environments, or any non-ARM target that might be used for testing), the function returns an empty `QByteArray` unconditionally. This means that any code path relying on encryption or decryption silently receives empty output on non-ARM builds with no error signal. If test environments or development machines do not use ARM, encryption is silently bypassed and data that should be protected is transmitted or stored in plaintext. There is no fallback software AES implementation or error indication on these platforms.

---

**A11-7** · MEDIUM · Communication Security
**File:** `platform/blecentral.cpp:165`
**Description:** `QLowEnergyController::createCentral(m_device)` is called with no security mode configured on the resulting controller. The Qt BLE API defaults to `QLowEnergyController::UnconnectedState` and uses unauthenticated, unencrypted connections at the BLE link layer unless a security mode is explicitly requested (e.g., `QBluetoothSocket::ManPageSecurity` or through pairing). The codebase then proceeds to write an authorization code to a specific characteristic (blecentral.cpp:275: `service->writeCharacteristic(characteristic, m_authCode)`) over this unauthenticated BLE link. Without BLE link-layer encryption and authentication (pairing/bonding), the authorization code is transmitted in plaintext over the radio and is trivially interceptable by any nearby BLE sniffer.

---

**A11-8** · MEDIUM · Communication Security
**File:** `platform/blecentral.cpp:68-72`
**Description:** The authorization code (`m_authCode`) is stored as a plain `QByteArray` member variable for the lifetime of the `BleCentral` object. It is set via `setAuthorizationCode()` and retained indefinitely. If the `BleCentral` object persists between connections (e.g., across reconnect cycles), the authorization credential remains in heap memory for the entire session. There is no zeroing or explicit clearing of `m_authCode` after use in `serviceStateChanged()` or in the destructor. On an embedded Linux device with physical access, a memory dump could recover the authorization code.

---

**A11-9** · LOW · Qt-Specific Security
**File:** `platform/blecentral.cpp:274-275`
**Description:** When a characteristic's UUID matches `m_authUuid`, the code immediately writes `m_authCode` to that characteristic without any additional validation of service context, connection security state, or confirmation that the peripheral is the expected trusted device. The target device is selected solely by BLE MAC address match (blecentral.cpp:117: `info.address() == m_peripheralAddress`). A rogue BLE device that spoofs the expected MAC address and advertises the expected service UUID with the authorization characteristic would receive the authorization code. BLE MAC address matching does not constitute authentication of the peripheral.

---

**A11-10** · LOW · Build Security
**File:** `platform/aescrypto.cpp:50`
**Description:** `qDebug() << "AesCrypto: MTP Status Error: " << status;` logs the raw MTP hardware status register value to debug output. If `qDebug` output is active in production builds (which is the default unless `QT_NO_DEBUG_OUTPUT` is defined at build time or the message handler is suppressed), this leaks internal hardware state information. The status bits include flags that describe the state of the hardware cryptographic module. While not a direct key disclosure, this information assists an attacker in profiling the hardware environment. This should be verified against the production build configuration.

---

**A11-11** · INFO · Memory Safety
**File:** `platform/blecentral.cpp:42-52`
**Description:** The destructor explicitly calls `delete m_discoveryAgent` and `delete m_controller` (raw pointers) followed by `qDeleteAll()` on the three lists, then manually calls `.clear()` on each list. This is correct and consistent cleanup. It is noted as a pattern, not a defect: the class uses raw Qt parent-child ownership for some objects and manual deletion for others, which is a potential maintenance risk if the ownership model changes. No use-after-free was found in the current code.

---

1. Memory Safety: findings A11-2, A11-3, A11-4, A11-5 above.
2. Communication Security: findings A11-1, A11-6, A11-7, A11-8 above.
3. Input Handling: no issues found.
4. Build Security: finding A11-10 above.
5. Device and Firmware: no issues found.
6. Qt-Specific Security: finding A11-9 above.
