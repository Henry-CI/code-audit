# Pass 1 — Security Audit: A03
**Auditor:** A03
**Date:** 2026-02-28
**Branch:** master
**Scope:** `app/backgroundworker.h`, `app/backgroundworker.cpp`, `app/checklist.h`, `app/checklist.cpp`

---

## Step 4 — Reading Evidence

### File pair 1: backgroundworker.h / backgroundworker.cpp

**File paths:**
- `/c/Projects/cig-audit/repos/mark3-pvd/app/backgroundworker.h`
- `/c/Projects/cig-audit/repos/mark3-pvd/app/backgroundworker.cpp`

**Classes:**

`OtaWorker : public QObject`
- Q_OBJECT at line 40 (backgroundworker.h)
- Public methods:
  - `explicit OtaWorker(QObject *parent = nullptr)` — line 42
  - `void unpack()` — line 43
- Public member variables:
  - `QAtomicInteger<quint32> m_isRunning` — line 45
- Signals:
  - `void sendGmtpMessage(CIGCONF::GmtpMessage msg, const QByteArray &extra = QByteArray())` — line 48
  - `void started()` — line 49
  - `void ready()` — line 50
  - `void failed()` — line 51
- Private member variables:
  - `QMutex m_mutex` — line 58

`BackgroundWorker : public QObject`
- Q_OBJECT at line 64 (backgroundworker.h)
- Public methods:
  - `explicit BackgroundWorker(QObject *parent = nullptr)` — line 68
  - `void setUI(Dialog *ui)` — line 69
  - `bool networkStatus()` — line 70
- Signals (line 79–97):
  - `void powerStateChanged(CIGCONF::PowerState state)`
  - `void reboot()`
  - `void lockScreen(CIGCONF::MaintLockedCode code, bool remote)`
  - `void ambertImpactScreen()`
  - `void cardAuthorised(bool yes, quint64 id)`
  - `void updateStatusInfo(...)`
  - `void cmdMsgReceived(CIGCONF::BroadcastMessage m)`
  - `void onDemandStarted(quint32 start, quint32 end, quint64 id, CIGCONF::OnDemandCmdSrc)`
  - `void onDemandExtended(quint32 start, quint32 end, quint64 id, CIGCONF::OnDemandCmdSrc)`
  - `void onDemandEnded(quint32 end, quint64 id, CIGCONF::OnDemandCmdSrc)`
  - `void sigLanguageChanged()`
  - `void cmdLogin(quint64 id)`
  - `void unpackOta()`
  - `void cameraSettingsUpdated()`
- Private member variables (lines 142–192): raw pointers to EM070 platform objects, comm objects, timers, and config state

**#includes (backgroundworker.cpp):** `backgroundworker.h`, `utils/logger.h`, `platform/blecentral.h`, `platform/canbus.h`, `platform/gnssreceiver.h`, `platform/internalrtc.h`, `platform/modemport.h`, `platform/powersupply.h`, `platform/pwmbacklight.h`, `platform/pwmbeeper.h`, `platform/seriallogger.h`, `platform/userport.h`, `comm/bleexpansion.h`, `comm/bleinputhandler.h`, `comm/canmonitor.h`, `comm/canexpansion.h`, `comm/canstatehandler.h`, `comm/modemchat.h`, `comm/gmtpchat.h`, `comm/ntpsync.h`, `comm/ftpclient.h`, `app/globalconfigs.h`, `ui/dialog.h`, `mytranslator.h`, `<QApplication>`, `<QProcess>`, `<QFileInfo>`, `<QDebug>`, `<QLoggingCategory>`, `<QNetworkConfiguration>`, `<QFile>`, `<QStorageInfo>`, `<QThread>`, `<algorithm>`, `<math.h>`, `utils/zlib.h`, `<fcntl.h>`, conditionally `<unistd.h>`

---

### File pair 2: checklist.h / checklist.cpp

**File paths:**
- `/c/Projects/cig-audit/repos/mark3-pvd/app/checklist.h`
- `/c/Projects/cig-audit/repos/mark3-pvd/app/checklist.cpp`

**Class:** `Checklist` — no base class, no Q_OBJECT

**Public methods:**
- `Checklist()` — constructor, line 23 (h) / line 9 (cpp)
- `static bool isValidCheckItem(const CheckItem &item)` — line 25 (h)
- `void readChecklist()` — line 27 (h)
- `void saveChecklist()` — line 29 (h)
- `void clear()` — line 30 (h)
- `void shuffleChecklist()` — line 31 (h)
- `const CheckItem & checkItem(int index, bool query = false) const` — line 34 (h)
- `bool setCheckItem(int index, const CheckItem &item)` — line 35 (h)
- `quint32 checksum() const` — line 36 (h)

**Private methods:**
- `bool readChecklist50()` — line 39 (h)
- `bool readChecklist100()` — line 40 (h)
- `quint8 copyAllRandomPreop(CheckItem *randomPreop)` — line 41 (h)

**Private member variables:**
- `CheckItem m_checkItems[CHECKLIST_MAX_IDX]` — line 43 (h), CHECKLIST_MAX_IDX = 32
- `CheckItem m_checkItems_shuffled[CHECKLIST_MAX_IDX]` — line 44 (h)
- `bool m_dirty` — line 45 (h)
- `bool m_isShuffled` — line 46 (h)

**Inner struct CheckItem** (lines 9–21, h):
- Union of bitfield (qId:31, doNotRandomize:1) / quint32 questionId
- `CIGCONF::ChecklistType type`
- `quint8 questionLen`
- `char question[CHECKLIST_QUESTION_LEN_100+1]` = `char question[101]`

**Signals/Slots:** None (no Q_OBJECT)

**#includes (checklist.cpp):** `checklist.h`, `<QFile>`, `<QSaveFile>`, `<QDataStream>`, `<QTime>`, `app/globalconfigs.h`, `<algorithm>`

---

## Step 5 — Security Review

### 1. Memory Safety

**A03-1** · MEDIUM · Memory Safety
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/app/backgroundworker.cpp:1148`
**Description:** `qstrcpy(item.question, args.at(argIndex).constData())` is called without verifying the destination buffer size beyond the `questionLen` check. The check on line 1145 (`item.questionLen > CHECKLIST_QUESTION_LEN_100`) validates the `size()` of the QByteArray, but `qstrcpy` copies until the null terminator of the source C-string. If the source data from `args.at(argIndex)` contains embedded null bytes before its reported length, or if Qt's `QByteArray::size()` and `constData()` mismatch expectations, the behavior could diverge. More critically, `qstrcpy` is an unbounded copy function equivalent to `strcpy` — if the preceding length check is ever bypassed or miscounted (e.g. due to off-by-one in the split), the 101-byte `question` buffer can overflow. The bounded alternative `qstrncpy` or `memcpy` with the validated length should be used.

**A03-2** · MEDIUM · Memory Safety
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/app/backgroundworker.cpp:59-60`
**Description:** `static const int CHUNK_SIZE = ZLIB_BUF_SZ;` where `ZLIB_BUF_SZ = 500*1024 = 512000 bytes`. The variable `char out[CHUNK_SIZE]` is declared as a stack-allocated array of 500 KB inside `streamUncompress()`. On an embedded ARM device with limited stack space this allocation is extremely large and risks a stack overflow, particularly because this function is called in a loop from `OtaWorker::unpack()` (lines 221–226). Stack overflows on embedded devices can lead to silent data corruption or crashes.

**A03-3** · LOW · Memory Safety
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/app/checklist.cpp:219`
**Description:** `std::rotate(&randomPreop[0], &randomPreop[rotateNum], &randomPreop[numberOfRandomPreop-1])` — the third argument is `numberOfRandomPreop - 1` rather than `numberOfRandomPreop`. For an array segment of length `n`, `std::rotate` end-iterator should point one past the last element, i.e. `&randomPreop[numberOfRandomPreop]`. Using `numberOfRandomPreop - 1` excludes the last element from the rotation. While not a buffer overread, this is a logic defect in safety-critical checklist ordering that could result in one question never being rotated, weakening the randomisation guarantee.

**A03-4** · LOW · Memory Safety
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/app/checklist.cpp:222-223`
**Description:** In `shuffleChecklist()`, `randomPreopIndex` is incremented without bounds checking: `m_checkItems_shuffled[n] = randomPreop[randomPreopIndex++]`. The array `randomPreop` has `CHECKLIST_MAX_IDX` (32) elements and was populated with `numberOfRandomPreop` items. The loop over `m_checkItems_shuffled` runs up to `CHECKLIST_MAX_IDX` iterations. If `doNotRandomize` is 0 for more slots than `numberOfRandomPreop` items were copied, `randomPreopIndex` will exceed `numberOfRandomPreop` and access uninitialized memory in `randomPreop` beyond the populated range.

**A03-5** · LOW · Memory Safety
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/app/checklist.cpp:54-55`
**Description:** In `readChecklist50()`, `stream.readRawData(m_checkItems[index].question, CHECKLIST_QUESTION_LEN)` always reads exactly `CHECKLIST_QUESTION_LEN` (50) bytes into the buffer. The buffer `question` is `CHECKLIST_QUESTION_LEN_100 + 1` (101) bytes, so the capacity is sufficient. However, immediately after, `m_checkItems[index].question[len] = 0` places a null terminator at offset `len`, where `len` has been validated only to be `<= CHECKLIST_QUESTION_LEN` (50). The maximum valid index for the null write is 50, which is within the 101-byte buffer. This is safe, but the logic relies on `readRawData` always reading exactly 50 bytes; if the stream is truncated, the remainder of the buffer is left with stale data and the `len`-offset null terminator may not be at the end of actual content. No check is made on the return value of `readRawData`.

**A03-6** · INFO · Memory Safety
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/app/backgroundworker.cpp:187-188`
**Description:** The OTA firmware header is parsed using direct `reinterpret_cast` pointer arithmetic against a raw `QByteArray` buffer: `*(reinterpret_cast<const quint32 *>(ba.constData()))` and `*(reinterpret_cast<const quint32 *>(ba.constData() + 4))`. The file size is checked to be at least 8 bytes (line 173) before this read occurs, so an underflow is not possible here. This is noted as an INFO item because pointer aliasing via reinterpret_cast violates strict aliasing rules in C++ and could in principle result in undefined behaviour on some compilers, but in practice Qt's `QByteArray` provides contiguous storage and this is a common embedded pattern.

---

### 2. Communication Security

**A03-7** · HIGH · Communication Security
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/app/backgroundworker.cpp:567-586`
**Description:** The `CMD_FTPF` command handler constructs an FTP URL from network-supplied content (lines 571–584). The URL scheme is hardcoded as `"ftp"` — an unencrypted, cleartext protocol. FTP transmits credentials (username and password, provided in `args.at(2)` and `args.at(3)`) and file data in plaintext. On a vehicle proximity detection device, firmware update files and any associated credentials are transmitted without confidentiality or integrity protection. An attacker with network access can intercept FTP credentials or inject a malicious firmware image. SFTP or FTPS should be used instead.

**A03-8** · MEDIUM · Communication Security
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/app/backgroundworker.cpp:643`
**Description:** `QProcess::startDetached("/etc/pvd/sdcard -format")` — the path `/etc/pvd/sdcard` is hardcoded. While the command itself is hardcoded and not user-controllable, the hardcoded path to the SD card format script is a device-specific configuration detail that is baked into firmware and cannot be changed without a firmware update. This is an INFO-level concern for maintainability but also a LOW security concern if an attacker can replace the `/etc/pvd/sdcard` binary (implying filesystem write access).

**A03-9** · MEDIUM · Communication Security
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/app/backgroundworker.cpp:1663-1667`
**Description:** The `CMD_WIFI` query handler returns the Wi-Fi network password in cleartext over the serial user port: `network.pw.constData()` is included in the `^WIFI:` response string. Wi-Fi passwords stored in configuration and transmitted over the serial RS-232 accessory port are exposed in plaintext. Any party with access to the serial port (e.g. via the RS-232 accessory interface) can retrieve all stored Wi-Fi credentials.

---

### 3. Input Handling

**A03-10** · HIGH · Input Handling
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/app/backgroundworker.cpp:1405-1411`
**Description:** In the `CMD_CANCFG` handler, a shell command string is constructed using `QStringLiteral` with `arg()` substitutions (line 1405): `QStringLiteral("/bin/sh -c \"/bin/sed -i 's,.*set can%1.*,/home/bin/ip link set can%1 up type can bitrate %2,' /etc/pvd/can\"").arg(CanBus::CAN1).arg(baudRate)`. The value `CanBus::CAN1` is a compile-time constant so it is safe. However, the constructed command is passed to `QProcess::start(cmd)` as a single string (line 1407) rather than as a list of arguments. This invokes the shell with the full command string. While `baudRate` is validated to be a numeric `quint32 <= 1000000` (lines 1401–1403), using `QProcess::start()` with a shell-interpolated string introduces shell-injection risk if the validation is ever loosened or bypassed. The pattern of constructing shell command strings and executing them via `/bin/sh -c` should be replaced with explicit argument lists to `QProcess`.

**A03-11** · MEDIUM · Input Handling
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/app/backgroundworker.cpp:1804`
**Description:** `CMD_MDMAT` passes network-received `content` directly to `m_modemPort->sendCmd(content)` without any sanitisation or validation of the content (line 1804). This command relays arbitrary AT commands directly to the modem hardware. An attacker who can send a GMTP `MDMAT` command (i.e., any server-side entity or a man-in-the-middle on the GMTP channel) can issue arbitrary AT commands to the modem, including commands that change APN settings, disable the modem, or exfiltrate SIM information.

**A03-12** · MEDIUM · Input Handling
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/app/backgroundworker.cpp:444`
**Description:** `qDebug() << "LEADER CMD < " << ba;` at the entry of `parseLeaderCmd()` logs the full contents of every received command — including those received from the GMTP server (remote commands) — to the debug output. Since `ba` can contain arbitrary data from the network, this is an information-disclosure risk if debug output is accessible in production builds and a format-string concern if `qDebug` with `<<` is ever changed to a printf-style call. In the current form the `<<` operator is safe against format strings, but logging raw network data to a debug channel in a production device is inadvisable.

**A03-13** · LOW · Input Handling
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/app/checklist.cpp:34,77`
**Description:** The number of checklist items to parse is calculated as `int num = ba.size() / CHECKLIST_ITEM_SIZE` (and `/ CHECKLIST_ITEM_SIZE_100`). If the file contains more entries than `CHECKLIST_MAX_IDX`, the loop will attempt to process them all, but the index validation `if (!index || index > CHECKLIST_MAX_IDX) break;` will terminate the loop early on any out-of-range index. This is adequate but the total iteration bound is not explicitly capped at `CHECKLIST_MAX_IDX`, so a malformed or oversized checklist file causes the loop to iterate up to `ba.size() / item_size` times before a termination condition is hit. For large files this wastes time; more importantly, it means the file size is not validated against a maximum before parsing begins.

**A03-14** · LOW · Input Handling
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/app/checklist.cpp:238-242`
**Description:** `Checklist::checkItem(int index, bool query)` does not perform bounds-checking on `index`. The method accesses `m_checkItems[index]` and `m_checkItems_shuffled[index]` directly (lines 240–241) without verifying `0 <= index < CHECKLIST_MAX_IDX`. While `setCheckItem` does check bounds, all call sites of `checkItem` are responsible for ensuring a valid index. A call with an out-of-range index results in undefined behaviour (array out-of-bounds access).

---

### 4. Build Security

Build security (compiler flags, `.pro` file) is not applicable to the `.cpp` and `.h` files in scope for this assignment. No inline security-relevant build flags or conditional compilation anomalies beyond the `UNIT_TEST` guards (which are acceptable) were observed.

---

### 5. Device and Firmware

**A03-15** · HIGH · Device and Firmware
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/app/backgroundworker.cpp:189`
**Description:** The OTA firmware integrity check (`OtaWorker::unpack()`) uses only a CRC-16 (lines 236–244) and a 16-bit magic value embedded in the firmware header to validate that a downloaded firmware image is authentic before writing it to `/home/FleetFocusOTA`. CRC-16 detects accidental corruption but provides no cryptographic authenticity guarantee. An attacker who can place a file at `FILE_FLEETMS_FW` (the FTP download location) can craft a malicious firmware image with a matching CRC-16 and magic value. There is no firmware signing or cryptographic hash verification. For a safety-critical proximity detection device, firmware authenticity must be verified with a cryptographic signature before installation.

**A03-16** · MEDIUM · Device and Firmware
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/app/backgroundworker.cpp:198,202,205,254`
**Description:** OTA firmware update writes to hardcoded paths: `/home/FleetFocus`, `/home/FleetFocusOTA`, `/home/FleetFocusTemp`. These paths are embedded in the firmware binary. If the `/home` filesystem is writable by unprivileged processes or accessible via the FTP download mechanism, a malicious actor could pre-place files at these paths to interfere with the update logic (e.g. pre-existing `/home/FleetFocusOTA` triggers a FOTA failure alert, as seen in `checkFotaFail()` at line 3319). The hardcoded deployment paths also prevent environment separation.

**A03-17** · LOW · Device and Firmware
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/app/backgroundworker.cpp:1350-1370`
**Description:** `CMD_DEBUG` allows a remote GMTP command to enable verbose debug output (including CAN SPN debug data) and set internal debug mode levels. There is no authentication check specific to this command beyond the general GMTP session being established. Enabling debug mode on a production device via a remote command can expose internal device state and increase attack surface. Debug commands that alter device behaviour should be disabled or require elevated authentication in production firmware.

---

### 6. Qt-Specific Security

**A03-18** · HIGH · Qt-Specific Security
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/app/backgroundworker.cpp:227,241`
**Description:** `QProcess::execute("sh", QStringList() << "-c" << "echo 1 > /proc/sys/vm/drop_caches")` is called twice inside `OtaWorker::unpack()` — once in the decompression loop (line 227) and once in the CRC verification loop (line 241). This spawns a shell process (`sh -c`) that writes to a Linux kernel pseudo-file. Although the command string itself is a hardcoded literal and not attacker-controlled, spawning a shell inside a firmware update loop on an embedded device is an unusual pattern and creates an attack surface if the `PATH` or shell environment is tampered with. More significantly, `QProcess::execute` blocks the calling thread; in the OTA thread context this is acceptable but interacts poorly with the `QMutex` held throughout `unpack()`.

**A03-19** · HIGH · Qt-Specific Security
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/app/backgroundworker.cpp:3161-3165`
**Description:** `QProcess::execute("/etc/pvd/kill_udhcpc_wwan0")` and `QProcess::execute("udhcpc -b -p /var/run/dhcp_wwan0_pid -i wwan0")` are called with hardcoded command strings (not via argument lists). The second call, `"udhcpc -b ..."`, passes a single string to `QProcess::execute`, which on Qt uses the shell to parse it. If the `PATH` environment is attacker-influenced, or if shell metacharacters can be introduced into these strings, command injection is possible. The correct form is `QProcess::execute("udhcpc", QStringList() << "-b" << ...)`.

**A03-20** · MEDIUM · Qt-Specific Security
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/app/backgroundworker.cpp:1612`
**Description:** `QProcess::startDetached("/etc/pvd/ramdisk")` is invoked by `CMD_DBGRAM`, a remote GMTP command. The command is a debug/diagnostic function that can be triggered remotely without additional authentication. `startDetached` launches the process in a detached state and the calling application has no visibility into its success or output. If `/etc/pvd/ramdisk` can be replaced or if the command has unintended side effects, this provides a remote code execution vector for authenticated GMTP server sessions.

**A03-21** · LOW · Qt-Specific Security
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/app/backgroundworker.cpp:57-58`
**Description:** The `streamUncompress` function uses `static bool headerSkipped = false` and the `z_stream strm` is initialised by checking `strm.state == nullptr` (line 63). These are function-level statics, which means they persist across calls and are not thread-safe without synchronisation. `streamUncompress` is called from `OtaWorker::unpack()`, which runs in a dedicated thread (`m_otaThread`). If `unpack()` is ever invoked concurrently (the `QMutex` in `OtaWorker` protects against this, but the static is global to all calls), the static state could be corrupted between calls. The use of static local variables for streaming state in what is logically a per-call operation is a design fragility.

---

## Summary of Findings

| ID | Severity | Category |
|---|---|---|
| A03-1 | MEDIUM | Memory Safety — qstrcpy without bounded copy |
| A03-2 | MEDIUM | Memory Safety — 500 KB stack allocation in embedded loop |
| A03-3 | LOW | Memory Safety — off-by-one in std::rotate end iterator |
| A03-4 | LOW | Memory Safety — randomPreopIndex unbounded in shuffleChecklist |
| A03-5 | LOW | Memory Safety — readRawData return value not checked |
| A03-6 | INFO | Memory Safety — reinterpret_cast aliasing (accepted embedded pattern) |
| A03-7 | HIGH | Communication Security — FTP used for firmware update (plaintext, no integrity) |
| A03-8 | MEDIUM | Communication Security — Wi-Fi password returned in plaintext over serial |
| A03-9 | MEDIUM | Communication Security — hardcoded paths to network config scripts |
| A03-10 | HIGH | Input Handling — shell command constructed with arg() and executed via /bin/sh |
| A03-11 | MEDIUM | Input Handling — arbitrary AT commands forwarded to modem via MDMAT |
| A03-12 | MEDIUM | Input Handling — raw network data logged via qDebug in production |
| A03-13 | LOW | Input Handling — checklist file size not bounded before parse loop |
| A03-14 | LOW | Input Handling — checkItem() has no bounds check on index parameter |
| A03-15 | HIGH | Device and Firmware — OTA authenticated only by CRC-16, no cryptographic signing |
| A03-16 | MEDIUM | Device and Firmware — OTA writes to hardcoded /home paths |
| A03-17 | LOW | Device and Firmware — CMD_DEBUG remotely enables debug mode without elevated auth |
| A03-18 | HIGH | Qt-Specific Security — QProcess spawning shell inside OTA update loop |
| A03-19 | HIGH | Qt-Specific Security — QProcess::execute with single-string shell commands |
| A03-20 | MEDIUM | Qt-Specific Security — CMD_DBGRAM triggers QProcess::startDetached remotely |
| A03-21 | LOW | Qt-Specific Security — static local variables in streamUncompress not thread-safe by design |
