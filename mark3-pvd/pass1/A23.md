# Pass 1 Audit — A23
**Date:** 2026-02-28
**Auditor:** A23
**Branch:** master (confirmed)

---

## Reading Evidence

### File Set 1 — PreopScreenOverlay

**Files:**
- `/c/Projects/cig-audit/repos/mark3-pvd/ui/preopscreenoverlay.h`
- `/c/Projects/cig-audit/repos/mark3-pvd/ui/preopscreenoverlay.cpp`
- `/c/Projects/cig-audit/repos/mark3-pvd/ui/preopscreenoverlay.ui`

**Class:** `PreopScreenOverlay` extends `QDialog`

**Q_OBJECT macro:** Line 12 of `preopscreenoverlay.h`

**Public methods:**
- `explicit PreopScreenOverlay(QWidget *parent = 0)` — constructor (line 15, .h)
- `~PreopScreenOverlay()` — destructor (line 16, .h)
- `void onUpdatePreopTimer(QString time)` — updates the timer label (line 18, .h)

**Signals:** None declared.

**Slots:** None declared.

**#include directives (.h):**
- `<QDialog>`

**#include directives (.cpp):**
- `"preopscreenoverlay.h"`
- `"ui_preopscreenoverlay.h"`

**Member variables:**
- `Ui::PreopScreenOverlay *ui` (private)

**UI widgets (.ui):**
- `PreopScreenOverlay` — `QDialog`, 800x50
- `lblPreopTimer` — `QLabel`, displays "Time Remaining: 00:00:00"

**Notes:**
- `onUpdatePreopTimer` appends externally-supplied `time` string directly to a label (line 13, .cpp). The `time` parameter is a `QString` passed by value with no validation or length check before display. The overlay has no close/dismiss button in the UI file; it is a thin 50px-high strip. No dismiss action is present in the widget itself; dismissal must be managed by the parent.

---

### File Set 2 — SupervisorDialog

**Files:**
- `/c/Projects/cig-audit/repos/mark3-pvd/ui/supervisordialog.h`
- `/c/Projects/cig-audit/repos/mark3-pvd/ui/supervisordialog.cpp`
- `/c/Projects/cig-audit/repos/mark3-pvd/ui/supervisordialog.ui`

**Class:** `SupervisorDialog` extends `QDialog`

**Q_OBJECT macro:** Line 17 of `supervisordialog.h`

**Public methods:**
- `explicit SupervisorDialog(QWidget *parent = nullptr)` — constructor (line 20, .h)
- `~SupervisorDialog()` — destructor (line 21, .h)
- `void setMasterOptions(CIGCONF::MasterId m)` — configures button visibility based on master permissions bitmask (line 23, .h / line 172, .cpp)
- `void setTransportOptions()` — sets transport-mode button visibility (line 24, .h / line 202, .cpp)

**Signals:**
- `void startMasterSession()` — emitted to trigger a master-level unlock session (line 32, .h)
- `void startMaintenanceSession()` — emitted to trigger a maintenance session (line 33, .h)
- `void onVORUpdate()` — emitted after VOR status toggle (line 34, .h)

**Private slots:**
- `void onUnlkVehicle()` — handles Unlock Vehicle button click (line 52, .h / line 88, .cpp)
- `void onNormalDriverAccess()` — handles Normal Driver Access button click (line 53, .h / line 106, .cpp)
- `void onActivateVOR()` — performs VOR toggle after confirmation (line 54, .h / line 144, .cpp)
- `void openConfirmationDialog()` — shows VOR confirmation dialog (line 55, .h / line 126, .cpp)
- `void on_btnMaintenanceMode_clicked()` — handles Maintenance Mode button click (line 56, .h / line 211, .cpp)

**Protected methods:**
- `void showEvent(QShowEvent *event = 0)` — resets UI labels and starts inactivity timer (line 49, .h / line 52, .cpp)

**Private methods:**
- `bool debounce()` — returns false if last press was within 200ms (line 37, .h / line 155, .cpp)
- `void reset()` — clears last press timestamp and resets UI (line 38, .h / line 166, .cpp)

**#include directives (.h):**
- `"app/cigconfigs.h"`
- `<QDialog>`
- `<QTimer>`

**#include directives (.cpp):**
- `"supervisordialog.h"`
- `"ui_supervisordialog.h"`
- `"app/globalconfigs.h"`
- `"ui/vorconfirmationdialog.h"`
- `"ui/warningdialog.h"`

**Member variables:**
- `Ui::SupervisorDialog *ui` (private)
- `QTimer *m_timer` — inactivity auto-close timer, 10000ms (private)
- `QTimer *m_resetTimer` — button-label reset timer, 2000ms (private)
- `quint32 m_lastPress` — timestamp of last button press for debounce (private)
- `CIGCONF::MasterId m_master` — identity and permissions of the current master user (private)
- `VORConfirmationDialog *m_vorConfirmationDialog` (private)
- `WarningDialog *m_maintWarningDialog` (private)
- `WarningDialog *m_warningDialog` (private)

**UI widgets (.ui):**
- `SupervisorDialog` — `QDialog`, 800x480
- `btnActivateVOR` — `QPushButton`, "Activate VOR"
- `btnUnlkVehicle` — `QPushButton`, "Unlock Vehicle"
- `btnNormalDriver` — `QPushButton`, "Normal Driver Access"
- `lblUnlock` — `QLabel` (empty)
- `labelMsg` — `QLabel`, "Supervisor Menu"
- `btnHide` — `QPushButton`, "QUIT"
- `btnMaintenanceMode` — `QPushButton`, "Maintenance Mode"
- `labelDriver` — `QLabel`, "Driver"
- `labelLastSession` — `QLabel`, "Last Session"
- `labelStart` — `QLabel`, "Start"
- `labelEnd` — `QLabel`, "End"

**Macros:**
- `NO_ACTIVITY_TIME 10000` (line 7, .cpp)
- `RESET_TIME 2000` (line 8, .cpp)
- `UNIT_TEST` conditional friend class `TestDialog` (lines 26–28, .h)

---

### File Set 3 — UnlockedDialog

**Files:**
- `/c/Projects/cig-audit/repos/mark3-pvd/ui/unlockeddialog.h`
- `/c/Projects/cig-audit/repos/mark3-pvd/ui/unlockeddialog.cpp`
- `/c/Projects/cig-audit/repos/mark3-pvd/ui/unlockeddialog.ui`

**Class:** `UnlockedDialog` extends `QDialog`

**Q_OBJECT macro:** Line 12 of `unlockeddialog.h`

**Public enum:**
- `Mode { UnlockNoChecklist, UnlockChecklist, UnlockOnly }` (line 15, .h)

**Public methods:**
- `explicit UnlockedDialog(QWidget *parent = 0)` — constructor (line 17, .h)
- `~UnlockedDialog()` — destructor (line 18, .h)
- `void setMode(Mode m)` — configures labels and visibility based on unlock scenario (line 20, .h / line 23, .cpp)
- `void languageChanged()` — updates "OK" label text for language changes (line 21, .h / line 42, .cpp)

**Signals:** None declared.

**Slots:** None declared (btnOk connected directly to `accept()` via lambda in constructor, line 15, .cpp).

**#include directives (.h):**
- `<QDialog>`

**#include directives (.cpp):**
- `"unlockeddialog.h"`
- `"ui_unlockeddialog.h"`
- `"app/globalconfigs.h"`

**Member variables:**
- `Ui::UnlockedDialog *ui` (private)

**UI widgets (.ui):**
- `UnlockedDialog` — `QDialog`, 800x480, white background
- `labelWarning` — `QLabel`, warning icon pixmap
- `btnOk` — `QPushButton`, no text (icon-only OK button)
- `label_3` — `QLabel`, "OK" text label overlaid on button area
- `labelLocked` — `QLabel`, "Machine unlocked"
- `labelTip` — `QLabel`, "Operational check list required\nPress OK to continue"

**Macros:**
- `UNIT_TEST` conditional friend class `TestDialog` (lines 23–25, .h)

---

## Security Review

### 1. Memory Safety

No unsafe C string functions (`strcpy`, `strcat`, `sprintf`, `gets`) are present in the three assigned files. No raw `new` without a corresponding `delete` in the same scope — `ui` pointers are deleted in destructors, and `QTimer`/dialog children are Qt-parented. No `memcpy` or `memmove` calls. No array index access in the assigned files. No integer overflow in buffer size calculations.

Memory Safety: no issues found.

---

### 2. Communication Security

The three assigned files do not contain any direct network communication, TLS configuration, server addresses, hardcoded credentials, or encryption keys. The `GMTP_UNLK` message is emitted from `dialog.cpp` (not in scope), not from these files directly. Within scope, no communication issues exist.

Communication Security: no issues found.

---

### 3. Input Handling

**A23-1** · LOW · Input Handling
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/ui/preopscreenoverlay.cpp:13`
**Description:** `onUpdatePreopTimer(QString time)` concatenates the `time` parameter directly into a `QLabel` with no length validation: `ui->lblPreopTimer->setText(tr("Time Remaining") + ": " + time)`. If the caller passes an arbitrarily long string (e.g., from a corrupt or attacker-influenced timer value), the label will display it in full. While Qt's `QLabel` will not overflow memory on a long string, very long input can cause unexpected UI layout behaviour on a constrained embedded display, potentially obscuring safety-critical proximity alert indicators. The `time` string should be validated to a reasonable length (e.g., HH:MM:SS format) before display.

---

### 4. Build Security

Build Security: no issues found in the assigned files. (Build configuration is assessed against the `.pro` file, which is not in scope for this assignment.)

---

### 5. Device and Firmware — Supervisor Access and Unlock Safety

**A23-2** · HIGH · Device and Firmware — Supervisor Access
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/ui/supervisordialog.cpp:106-124`
**Description:** In `onNormalDriverAccess()`, when the second-press confirmation condition is met, the code calls `m_warningDialog->open()`, immediately followed by `emit startMasterSession()` and `accept()` on the same lines (113–115). The `emit startMasterSession()` fires unconditionally without waiting for the user to acknowledge the `m_warningDialog`. The signal `startMasterSession` is connected in `dialog.cpp` (line 176) to `postLogin()`, which performs the full unlock sequence including setting the relay output and sending `GMTP_UNLK` to the server. The warning dialog's `accepted` signal is also connected to emit `startMasterSession()` (constructor lines 33–36). This means `startMasterSession` is emitted twice for Normal Driver Access: once immediately (before the warning dialog is confirmed), and once when the warning dialog is accepted. This results in the unlock/login flow being triggered before the operator has acknowledged the warning. The double-emission may also cause a double-login condition in `postLogin()`. Compare with `onUnlkVehicle()` (lines 88–104) and `on_btnMaintenanceMode_clicked()` (lines 211–229), which do not have this pattern — they rely entirely on the warning dialog's `accepted` signal and do not emit the session signal unconditionally.

**A23-3** · HIGH · Device and Firmware — Supervisor Access
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/ui/supervisordialog.cpp:88-104`
**Description:** In `onUnlkVehicle()`, the confirmation step relies solely on matching the button label text against the translated string `tr("Confirm?")` (line 93). This is a fragile security gate: if a translation file contains an incorrect or empty string for "Confirm?", or if `showEvent()` is called between the two presses (which it is — line 97 calls `showEvent()` on the first press, resetting the button text to "Unlock Vehicle"), the logic is reset correctly. However, the entire confirmation mechanism is based on UI widget text state rather than an explicit boolean flag. A race between the `m_resetTimer` (2000ms) expiry (calling `reset()` → `showEvent()`) and rapid double-press is the only protection. The debounce window is 200ms, while the reset window is 2000ms; if a user presses twice within 200ms–2000ms, the label will read "Confirm?" and the unlock will proceed. There is no cryptographic or server-side verification that this supervisor is still authorized at the moment of unlock: the authorization check (`containsMasterId`) happens at card swipe time in `dialog.cpp`, and by the time the supervisor menu is shown and the unlock button pressed, no re-verification occurs.

**A23-4** · MEDIUM · Device and Firmware — Unlock Not Server-Verified at Point of Action
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/ui/supervisordialog.cpp:88-104` and `/c/Projects/cig-audit/repos/mark3-pvd/ui/unlockeddialog.cpp:23-40`
**Description:** The supervisor unlock action (`onUnlkVehicle` and `onNormalDriverAccess`) emits `startMasterSession()` which triggers `postLogin()` in `dialog.cpp`. Within `postLogin()`, `GMTP_UNLK` is sent to the server (line 508, `dialog.cpp`) after the relay output has already been set (implicit in `postLogin`). The `UnlockedDialog` is shown as a notification screen only — pressing OK on `UnlockedDialog` simply calls `accept()` (line 15, `unlockeddialog.cpp`), which is connected to `onUnlockedDialogAccepted` in `dialog.cpp`. The local unlock relay is set before server acknowledgment of the `GMTP_UNLK` message. If server connectivity is lost at the moment of unlock, the equipment is physically unlocked without confirmed server-side logging. This is an audit/compliance gap: the unlock state is not synchronized with the server before granting physical access.

**A23-5** · MEDIUM · Device and Firmware — Unlock Dismissal Not Independently Logged
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/ui/unlockeddialog.cpp:15`
**Description:** `UnlockedDialog` presents the user with a confirmation screen after unlock. The OK button is connected directly to `QDialog::accept()` via a lambda, with no logging, no timestamp, and no GMTP message emitted at the moment of dismissal. The unlock screen presents three different modes (`UnlockOnly`, `UnlockChecklist`, `UnlockNoChecklist`) but the act of the operator pressing OK — acknowledging the machine is unlocked — is not separately recorded or reported. An operator could press OK immediately without reading the safety warning, and there is no audit trail of when the unlock acknowledgment occurred.

**A23-6** · MEDIUM · Device and Firmware — VOR Toggle Authenticated Locally Only
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/ui/supervisordialog.cpp:144-153`
**Description:** `onActivateVOR()` modifies VOR (Vehicle Off Road / restriction) status by calling `gCfg->setConvor()` and `gCfg->saveConfigs()` locally, then emits `onVORUpdate()` (which causes a logout in `dialog.cpp` line 182). The VOR state is a safety-critical parameter for a proximity detection device — enabling or disabling it affects whether the system alerts to proximity hazards. The change is persisted to local configuration and the server is notified via `GMTP_CONVOR` (handled elsewhere), but there is no server-side authorization check at the moment of toggle: if the device is offline, the VOR status is changed locally with no server record or rejection mechanism. The `m_master.id` used to identify who made the change is set at menu-open time and is not re-validated at the moment of the VOR change.

---

### 6. Qt-Specific Security

**A23-7** · MEDIUM · Qt-Specific Security — Debug Output Leaks Sensitive Identifiers
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/ui/supervisordialog.cpp:112`
**Description:** `onNormalDriverAccess()` contains `qDebug() << "current driver id " << gCfg->currentDriverId()` which logs the current driver's identifier to the debug output unconditionally. On a production embedded device, if Qt debug output is not completely suppressed (e.g., via `QT_NO_DEBUG_OUTPUT` compile flag or `qInstallMessageHandler` discard), this emits the driver identifier to stderr or a system log. Driver identifiers are personally identifying data and their exposure in debug logs is a privacy and security concern.

**A23-8** · MEDIUM · Qt-Specific Security — Debug Output Leaks Master ID and Permission Bitmask
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/ui/supervisordialog.cpp:174-176`
**Description:** `setMasterOptions()` contains a `qDebug()` call that logs both the master user's ID (in hex) and the permission option bitmask: `qDebug() << QString("setMasterOptions(): id=0x%1; option=0x%2").arg(m.id, 0, 16).arg(m.option, 0, 16)`. This is called every time a master card is swiped, logging the credential identifier and its permissions. If debug output reaches a log file or serial console accessible outside the device, this constitutes exposure of access credential identifiers and capability information to anyone with physical or remote access to device logs.

**A23-9** · LOW · Qt-Specific Security — UNIT_TEST Friend Class Exposes Private State
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/ui/supervisordialog.h:26-28` and `/c/Projects/cig-audit/repos/mark3-pvd/ui/unlockeddialog.h:23-25`
**Description:** Both `SupervisorDialog` and `UnlockedDialog` declare `friend class TestDialog` under `#ifdef UNIT_TEST`. If a build is accidentally produced with `UNIT_TEST` defined in a production or field firmware image, `TestDialog` gains full access to all private members of both classes, including `m_master` (which holds the master user ID and permission bitmask) and the ability to call private slots directly, bypassing the two-press confirmation mechanism. This is a defence-in-depth concern: the `UNIT_TEST` flag should be verified to be absent in all production build configurations.

**A23-10** · LOW · Qt-Specific Security — Debounce Uses `quint32` Clock with Potential Overflow on Non-ARM Builds
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/ui/supervisordialog.cpp:155-163`
**Description:** `debounce()` computes `now - m_lastPress` using `quint32` arithmetic from `gCfg->clockTime()`. On ARM builds, `clockTime()` returns a `quint64` millisecond value from `CLOCK_MONOTONIC` (line 548–555, `globalconfigs.h`). However, `m_lastPress` is declared as `quint32` in `supervisordialog.h` (line 42), meaning the 64-bit value is silently truncated. After approximately 49.7 days of device uptime, the truncated `quint32` will wrap around to zero, causing `now - m_lastPress` to appear as a large positive number regardless of actual elapsed time, effectively disabling the debounce for a brief window. During this window, a user could double-tap in under 200ms without the debounce suppressing the second press. On non-ARM builds `clockTime()` always returns 0 (line 553, `globalconfigs.h`), meaning `now - m_lastPress` is always 0, so `debounce()` always returns false and every button press is suppressed after the first press until `reset()` is called by the timer. This makes the supervisor menu unusable in non-ARM test builds, which may mask integration test failures.
