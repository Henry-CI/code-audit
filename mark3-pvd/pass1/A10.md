# Pass 1 Audit — A10
**Auditor:** A10
**Date:** 2026-02-28
**Branch:** master
**Repo:** /c/Projects/cig-audit/repos/mark3-pvd

---

## STEP 4 — READING EVIDENCE

---

### File: `/c/Projects/cig-audit/repos/mark3-pvd/comm/ntpsync.h`

**Class:** `NtpSync` extends `QObject`

**Q_OBJECT macro:** Line 12

**Public methods:**
- `explicit NtpSync(ModemChat *parent)` — line 14
- `void connectServer()` — line 15
- `void abortConnection()` — line 16

**Signals:**
- `void synchronized(bool yes)` — line 19

**Slots (private, connected via lambda/connect):**
- `void writeSocket()` — line 22 (private)
- `void readSocket()` — line 23 (private)

**Member variables:**
- `ModemChat *m_modemChat` — line 25
- `QUdpSocket *m_udpSocket` — line 26
- `QTimer *m_timer` — line 27
- `int m_syncTimes` — line 29

**#include directives:**
- `<QObject>` — line 4
- `<QUdpSocket>` — line 5

**NTP server addresses defined:** None hardcoded in this file. Server address retrieved at runtime from `gCfg->timeServerAddress()`.

---

### File: `/c/Projects/cig-audit/repos/mark3-pvd/comm/ntpsync.cpp`

**Class:** `NtpSync` (implementation)

**#include directives:**
- `"ntpsync.h"` — line 1
- `"platform/internalrtc.h"` — line 2
- `"platform/seriallogger.h"` — line 3
- `"comm/modemchat.h"` — line 4
- `"app/globalconfigs.h"` — line 5
- `<QTimer>` — line 6
- `<QDateTime>` — line 7

**Macros defined:**
- `#define EPOCH_DIFF  0x83aa7e80UL` — line 9 (NTP epoch offset: seconds from 1900 to Unix epoch 1970)

**NTP server addresses defined:** No hardcoded NTP server address in this file. Address sourced from `gCfg->timeServerAddress()` at lines 47, 50, 62.

**Key operations in `readSocket()` (lines 70–106):**
- Reads UDP datagram with `m_udpSocket->readAll()` — line 74
- Validates minimum size of 48 bytes — line 75
- Extracts `ts1` (Reference Timestamp) at bytes 32–35 and `ts2` (Transmit Timestamp) at bytes 40–43 using `BE_INT` macro — lines 78–79
- Checks that `ts2 - ts1 > 300` and returns early if so — line 81
- Subtracts `EPOCH_DIFF` from `ts2` — line 84
- Validates resulting `QDateTime` is valid and year >= 2019 — lines 87–88
- Calls `EM070::InternalRtc::setRtcTime(dt)` directly — line 99
- Sets last time server update and time error in global config — lines 101–102
- Emits `synchronized(true)` — line 103

---

### File: `/c/Projects/cig-audit/repos/mark3-pvd/main.cpp`

**Class:** None (free functions + `main`)

**#include directives:**
- `<QApplication>` — line 1
- `<QDateTime>` — line 2
- `<QThread>` — line 3
- `<QFile>` — line 4
- `<QDebug>` — line 5
- `<QTranslator>` — line 6
- `<QProcess>` — line 7
- `"utils/logger.h"` — line 8
- `"ui/keyfilter.h"` — line 9
- `"ui/dialog.h"` — line 10
- `"app/backgroundworker.h"` — line 11
- `"mytranslator.h"` — line 12
- `<sys/mman.h>` — line 13

**Free functions:**
- `void hideBootProgress()` — line 24
- `void configureCrashLogging()` — line 38
- `int main(int argc, char *argv[])` — line 71

**Conditional compilation / debug macros:**
- `#define CONSTRAINED_MEMORY_TEST` — commented out, line 17
- `#ifdef __arm__` guards around DPI and boot progress — lines 73, 26

**Command-line arguments processed:**
- `argc` and `argv` are passed directly to `QApplication a(argc, argv)` — line 78. No application-specific command-line argument parsing is performed beyond Qt's own handling.

**QProcess calls (hardcoded shell commands):**
- `QProcess::startDetached("/mnt/sd/app_monitor")` — line 68 (inside commented-out `configureCrashLogging()`)
- `QProcess::execute("/bin/sh", QStringList() << "-c" << "echo 37 > /sys/class/gpio/export")` — line 109
- `QProcess::execute("/bin/sh", QStringList() << "-c" << "echo \"high\" > /sys/class/gpio/gpio37/direction")` — line 110
- `QProcess::execute("/bin/sh", QStringList() << "-c" << "echo 0 > /sys/class/gpio/gpio37/value")` — line 111
- `QProcess::execute("/bin/sh", QStringList() << "-c" << "echo 39 > /sys/class/gpio/export")` — line 114
- `QProcess::execute("/bin/sh", QStringList() << "-c" << "echo \"high\" > /sys/class/gpio/gpio39/direction")` — line 115

**Shell script written to filesystem by `configureCrashLogging()`:** Lines 46–62 (currently commented out at line 101).

**Member variables:** None (no class).

---

### File: `/c/Projects/cig-audit/repos/mark3-pvd/mytranslator.h`

**Class:** None (free functions + extern)

**#include directives:**
- `<QtGlobal>` — line 4

**Public functions declared:**
- `void loadLocalLanguage(void)` — line 15
- `void updateLocalLanguage(const QString &arg1)` — line 16
- `QString getCurrentLanguage(void)` — line 17
- `int queryLanguage(void)` — line 18
- `int setLanguage(int local)` — line 19
- `void removeTranslator()` — line 20

**Global extern:** `extern QTranslator mTranslator` — line 14

**Constants:**
- `const QString langEnglish = "EN"` — line 11
- `const QString langSpanish = "ES"` — line 12

**Q_OBJECT macro:** Not present.

---

### File: `/c/Projects/cig-audit/repos/mark3-pvd/mytranslator.cpp`

**Class:** None (free function implementations)

**#include directives:**
- `<QApplication>` — line 1
- `<QFile>` — line 2
- `<QDebug>` — line 3
- `<QTranslator>` — line 4
- `"mytranslator.h"` — line 5

**Constants:**
- `const QString localFile = "local.dat"` — line 7 (relative path, no directory prefix)
- `const QString langFile = ":/lang.dat"` — line 8 (Qt resource path)

**Key operations:**
- `loadLocalLanguage()`: Opens `local.dat` (relative path) to read language code, opens embedded `:/lang.dat` resource to find corresponding translation filename, calls `mTranslator.load(filename)` where `filename` comes from the resource file — lines 15–68.
- `updateLocalLanguage()`: Same resource lookup pattern, writes the selected language code to `local.dat` — lines 74–126.
- `getCurrentLanguage()`: Same lookup, returns matched language code string — lines 132–165.
- `queryLanguage()` / `setLanguage()`: Thin wrappers around `getCurrentLanguage()` / `updateLocalLanguage()` — lines 167–188.
- `removeTranslator()`: Removes installed translator — lines 190–198.

---

## STEP 5 — SECURITY REVIEW

---

### 1. Memory Safety

**A10-1** · MEDIUM · Memory Safety
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/utils/bytearray.h:25`
**Description:** `ByteArray::asprintf()` calls `vsnprintf(nullptr, 0, ...)` to determine the required size, then calls `vsprintf(ba.data(), cformat, ap)` using a second `va_list` invocation on a `va_list` that has already been consumed by the first call. After `vsnprintf` exhausts `ap`, the second `va_start` is never called before `vsprintf`. This is undefined behaviour: the second variadic call reads from a stack frame that may have been corrupted or advanced past the arguments. The result is a potential heap buffer overflow or write of garbage data. The comment in the code itself flags this function as "not recommended". This file is referenced by `ntpsync.cpp` transitively through `bytearray.h`.

**A10-2** · MEDIUM · Memory Safety
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/utils/bytearray.h:7`
**Description:** The `BE_INT` macro does not cast `c1` (the most-significant byte) to `(uchar)` before the left shift of 24 bits. The other three arguments are explicitly cast: `(uchar)(c2) << 16`, `(uchar)(c3) << 8`, `(uchar)(c4)`. When `c1` is a signed `char` (as would be the case when indexing into a `QByteArray` whose `operator[]` returns `char`), a value with the high bit set (e.g., `0x80`–`0xFF`) is sign-extended to a negative `int` before the 24-bit left shift. Shifting a negative value left is undefined behaviour in C++ prior to C++20. In practice on ARM this produces an incorrect `quint32` result, silently corrupting the NTP transmit-timestamp extraction at `ntpsync.cpp:78–79` and potentially causing the device to set its RTC to a wrong time.

**A10-3** · LOW · Memory Safety
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/app/globalconfigs.h:422`
**Description:** `setTimeServerAddress()` checks `addr.size() < SERVER_ADDR_LEN` (33) before calling `qstrcpy(m_configs.timeServerAddress, addr.constData())`. The check uses `<` (strictly less than) rather than `<=`, so it permits a `QByteArray` of length 32 with no null terminator to be passed. `qstrcpy` copies until the null terminator in `addr.constData()`, which Qt guarantees to append, so the copy itself is safe. However, the intent appears to be to allow up to 32 character hostnames; the off-by-one in the guard is a latent confusion risk and could become a one-byte overflow if the pattern is copied elsewhere without the Qt null-terminator guarantee.

---

### 2. Communication Security

**A10-4** · HIGH · Communication Security
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/comm/ntpsync.cpp:50`
**Description:** NTP time synchronisation is performed over unauthenticated UDP (port 123, SNTPv3). There is no use of NTS (Network Time Security, RFC 8915) or any message authentication code. An on-path attacker or a local network attacker capable of spoofing UDP packets can respond to the NTP request with an arbitrary timestamp. Because the synchronised time is applied directly to the device RTC (`InternalRtc::setRtcTime`) and propagated to safety-critical timestamps (proximity event logs, on-demand command timestamps, maintenance records via `gCfg->setLastTimeServerUpdate`), a time-injection attack can corrupt audit trails, replay expired credentials, or cause safety-critical time-window logic to behave incorrectly. The protocol provides no confidentiality or integrity protection by design.

**A10-5** · INFO · Communication Security
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/comm/ntpsync.cpp:47,50,62`
**Description:** The NTP server address is not hardcoded in source; it is read at runtime from `gCfg->timeServerAddress()` which is ultimately stored in a config struct (`m_configs.timeServerAddress`, a 33-byte char array). This is the correct pattern. However, the default value of this field (what is stored when no configuration has been provided) is not visible in the files assigned to this auditor and should be reviewed by the auditor assigned to the config initialisation code to confirm no default NTP server address is hardcoded there.

---

### 3. Input Handling

**A10-6** · MEDIUM · Input Handling
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/comm/ntpsync.cpp:81`
**Description:** The NTP response validation check at line 81 is logically inverted relative to its stated purpose. The comment at line 32 notes the NTP timestamp fields (`ts1` = Reference Timestamp, `ts2` = Transmit Timestamp). The check `if (ts2 - ts1 > 300) return;` is intended to reject responses where the server's internal processing delay exceeds 300 seconds, discarding implausible responses. However, `ts1` and `ts2` are `quint32` (unsigned 32-bit). If `ts2 < ts1` (which can legitimately occur if the server's reference time is ahead of its transmit time due to clock steps), the subtraction wraps around to a very large positive value and the response is incorrectly discarded. More critically, the check discards responses with large inter-timestamp gaps but does not validate that `ts2` itself falls within any reasonable range relative to the device's current clock before subtracting `EPOCH_DIFF` and applying it to the RTC. A spoofed response with a valid-looking 300-second window but a completely wrong base time will pass validation.

**A10-7** · MEDIUM · Input Handling
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/comm/ntpsync.cpp:84,86,87`
**Description:** After subtracting `EPOCH_DIFF` from `ts2` (converting NTP epoch to Unix epoch), the code constructs a `QDateTime` and only checks `dt.isValid()` and `dt.date().year() < 2019`. This year-floor check provides minimal protection against time injection. A spoofed NTP response can set the device clock to any year from 2019 to 2106 (the limit of `quint32` Unix time). There is no upper-bound check, no check against the device's current clock to limit the magnitude of a step adjustment, and no plausibility check against GPS-derived time if available. The NTP-synchronised time is applied unconditionally to the RTC and to safety-critical timestamps.

**A10-8** · LOW · Input Handling
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/mytranslator.cpp:35`
**Description:** `loadLocalLanguage()` reads a language code from `local.dat` using `in.readLine()` with no length limit on the line. `QTextStream::readLine()` by default reads an unbounded line. While Qt stores this in a `QString` (heap-managed, no stack overflow risk), an extremely large `local.dat` file will cause the entire first line to be read into memory, then compared against language entries in the resource file. This is a minor denial-of-service risk if the file is writable by an attacker; the device could be caused to allocate excessive memory during startup.

**A10-9** · LOW · Input Handling
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/mytranslator.cpp:35,37`
**Description:** `loadLocalLanguage()` reads the translation filename from the embedded Qt resource file `:/lang.dat` (line 35: `filename = list[1]`) and passes it directly to `mTranslator.load(filename)` (line 37/94). The resource file `:/lang.dat` is compiled into the binary and is not attacker-controlled in normal deployment. However, if the resource file's format is ever changed to include an absolute path or if the build process were compromised to inject a malicious `lang.dat`, the `QTranslator::load()` call would follow that path. This is a build-supply-chain concern rather than a runtime vulnerability, and is rated LOW because the resource is embedded.

---

### 4. Build Security

Build Security: no issues found in the files assigned to this auditor. The `.pro` file was not assigned; compiler hardening flags cannot be assessed from these files alone.

---

### 5. Device and Firmware

**A10-10** · MEDIUM · Device and Firmware
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/main.cpp:38–68`
**Description:** `configureCrashLogging()` writes a shell script to `/mnt/sd/app_monitor` and then executes it with `QProcess::startDetached("/mnt/sd/app_monitor")`. The script is written to the SD card filesystem, which may be writable by other processes or even accessible via the physical card. If an attacker replaces `/mnt/sd/app_monitor` between the write and the `startDetached` call (TOCTOU), or if the SD card is removed and tampered with, arbitrary code will be executed as the application user on next crash detection. This function is currently called only when uncommented (line 101 is commented out), but the code path is present in the source and could be re-enabled.

**A10-11** · LOW · Device and Firmware
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/main.cpp:99`
**Description:** `qsrand(QDateTime::currentSecsSinceEpoch())` seeds Qt's legacy random number generator with the current Unix timestamp. This is a predictable seed: an attacker who knows the approximate boot time (e.g., from observing device power-on or NTP log entries) can predict the sequence generated by subsequent `qrand()` calls. If `qrand()` is used anywhere in security-sensitive contexts (session token generation, nonce generation), this is a HIGH finding. The seed predictability should be assessed in conjunction with the files that consume `qrand()`.

**A10-12** · LOW · Device and Firmware
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/comm/ntpsync.cpp:99`
**Description:** `EM070::InternalRtc::setRtcTime(dt)` is called unconditionally once the NTP response passes the minimal validation checks described in A10-6 and A10-7. There is no rate limiting, no step-change threshold, and no confirmation from a second source before writing to the hardware RTC. This means a single valid-looking spoofed UDP packet is sufficient to alter the device's hardware clock, which is used for safety-critical proximity event timestamping.

---

### 6. Qt-Specific Security

**A10-13** · LOW · Qt-Specific Security
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/main.cpp:109–115`
**Description:** Five `QProcess::execute()` calls use `/bin/sh -c` with shell-interpolated strings to export and configure GPIO pins. The strings are fully hardcoded literals with no user-supplied or network-supplied content, so there is no injection risk from these specific calls. However, the pattern of using `QProcess::execute("/bin/sh", QStringList() << "-c" << <string>)` is inherently fragile: if any future developer substitutes a variable into the shell string, it immediately becomes a command injection vulnerability. Direct file I/O to the sysfs paths (e.g., `QFile::write`) would be safer and avoid spawning a shell.

**A10-14** · INFO · Qt-Specific Security
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/comm/ntpsync.h:26`
**Description:** `m_udpSocket` is a `QUdpSocket*` allocated with `new QUdpSocket(this)` in the constructor; Qt parent-child ownership ensures it will be deleted when the `NtpSync` object is destroyed. This is the standard Qt RAII pattern and there is no leak. Noted for completeness.

---

## Summary Table

| ID     | Severity | Category                | File                                      |
|--------|----------|-------------------------|-------------------------------------------|
| A10-1  | MEDIUM   | Memory Safety           | utils/bytearray.h:25                      |
| A10-2  | MEDIUM   | Memory Safety           | utils/bytearray.h:7                       |
| A10-3  | LOW      | Memory Safety           | app/globalconfigs.h:422                   |
| A10-4  | HIGH     | Communication Security  | comm/ntpsync.cpp:50                       |
| A10-5  | INFO     | Communication Security  | comm/ntpsync.cpp:47,50,62                 |
| A10-6  | MEDIUM   | Input Handling          | comm/ntpsync.cpp:81                       |
| A10-7  | MEDIUM   | Input Handling          | comm/ntpsync.cpp:84,86,87                 |
| A10-8  | LOW      | Input Handling          | mytranslator.cpp:35                       |
| A10-9  | LOW      | Input Handling          | mytranslator.cpp:35,37                    |
| A10-10 | MEDIUM   | Device and Firmware     | main.cpp:38–68                            |
| A10-11 | LOW      | Device and Firmware     | main.cpp:99                               |
| A10-12 | LOW      | Device and Firmware     | comm/ntpsync.cpp:99                       |
| A10-13 | LOW      | Qt-Specific Security    | main.cpp:109–115                          |
| A10-14 | INFO     | Qt-Specific Security    | comm/ntpsync.h:26                         |
