# Pass 1 Security Audit — A12
**Auditor:** A12
**Date:** 2026-02-28
**Branch:** master (confirmed)
**Files reviewed:**
- `platform/canbus.h`
- `platform/canbus.cpp`
- `platform/gnssreceiver.h`
- `platform/gnssreceiver.cpp`

---

## STEP 4 — READING EVIDENCE

### canbus.h / canbus.cpp

**File paths:**
- `/c/Projects/cig-audit/repos/mark3-pvd/platform/canbus.h`
- `/c/Projects/cig-audit/repos/mark3-pvd/platform/canbus.cpp`

**Class name and base classes:**
- `EM070::CanBus` : public `QObject`

**Q_OBJECT macro location:**
- `canbus.h` line 14

**Every public method with signature and line number (canbus.h):**
- Line 25: `explicit CanBus(CanDeviceId id = CAN1, QObject *parent = nullptr)`
- Line 26: `~CanBus()`
- Line 28: `void initialize()`
- Line 30: `void setXferEnabled(bool enable)`
- Line 31: `bool isXferEnabled() const`
- Line 33: `void setPower(bool on)`
- Line 34: `bool isEnabled() const`
- Line 36: `bool setBaudRate(int baudRate)`
- Line 37: `int baudRate() const`
- Line 39: `void addRequest(quint32 id, const QByteArray &ba, quint32 interval)`
- Line 40: `QList<Request> getRequests()`
- Line 41: `void clearRequests()`
- Line 43: `void addFilter(quint32 identifier)`
- Line 44: `void clearFilters()`
- Line 45: `void applyFilters()`
- Line 47: `void writeFrameDirect(quint32 id, const QByteArray &ba)`
- Line 49: `void removeRequests(quint32 id)`

**Protected methods:**
- Line 58 (canbus.h): `void sendRequest()`

**Private methods:**
- Line 61 (canbus.h): `void readFrame()`
- Line 62 (canbus.h): `void handleError(QCanBusDevice::CanBusError error)`

**Signals (canbus.h):**
- Line 54: `void error(QCanBusDevice::CanBusError canBusError)`
- Line 55: `void read(quint32 identifier, const QByteArray &ba)`

**Slots:** None explicitly declared (readFrame and handleError connected via lambda/signal-slot in initialize())

**#include directives (canbus.h):**
- `<QObject>`
- `<QCanBusDevice>`
- `<QCanBusFrame>`
- `<QQueue>`
- `<QTimer>`

**#include directives (canbus.cpp):**
- `"canbus.h"`
- `"platform/seriallogger.h"`
- `<QCanBus>`
- `<QMetaObject>`
- `<QProcess>`
- `<QTimerEvent>`
- `<QTimer>`
- `<QDebug>`
- `<QFile>`
- `<QDateTime>`

**Protocol constants / defines (canbus.cpp):**
- `REQUEST_TIMER  100` (line 14) — polling interval in milliseconds
- `CANBUS_DEBUG   0` (line 15) — debug flag

**Member variables (canbus.h):**
- `QCanBusDevice *m_canBusDevice` — pointer to Qt CAN bus device
- `CanDeviceId m_canDeviceId` — enum CAN1/CAN2
- `bool m_powerOn`
- `bool m_xferEnabled`
- `int m_baudRate`
- `QList<Request> m_requests`
- `QList<quint32> m_filterIds`
- `QQueue<QCanBusFrame> m_requestQueue`
- `QTimer *m_timer`
- `qint64 m_lastReportedError`

**Nested struct (canbus.h):**
- `Request { QCanBusFrame frame; quint32 interval; qint32 timer; }`

**Enum (canbus.h):**
- `CanDeviceId { CAN2, CAN1 }` — note: CAN2=0, CAN1=1 (reversed from natural order per schematic comment)

---

### gnssreceiver.h / gnssreceiver.cpp

**File paths:**
- `/c/Projects/cig-audit/repos/mark3-pvd/platform/gnssreceiver.h`
- `/c/Projects/cig-audit/repos/mark3-pvd/platform/gnssreceiver.cpp`

**Class name and base classes:**
- `EM070::GnssReceiver` : public `QObject`

**Q_OBJECT macro location:**
- `gnssreceiver.h` line 15

**Every public method with signature and line number (gnssreceiver.h):**
- Line 17: `explicit GnssReceiver(QObject *parent = nullptr)`
- Line 18: `void portStateChanged(bool open)`
- Line 19: `void reset()`
- Line 20: `void changeUpdateTime()`
- Line 22: `quint8 satelliteCount() const`
- Line 23: `qint32 latitude() const`
- Line 24: `qint32 longitude() const`
- Line 25: `qint32 lastLatitude() const`
- Line 26: `qint32 lastLongitude() const`
- Line 27: `qint16 speed() const`
- Line 28: `qint16 course() const`
- Line 29: `quint32 distance() const`
- Line 30: `quint32 sumOfDistance() const`
- Line 31: `quint32 altitude() const`
- Line 32: `bool locked() const`
- Line 33: `quint32 hpe() const` — inline, converts HDOP to accuracy estimate
- Line 34: `quint32 hdop() const`
- Line 35: `qint64 age()`
- Line 36: `quint8 warn() const`
- Line 37: `void setWarn(quint8 n)`
- Line 38: `quint8 quality() const`
- Line 39: `void setQuality(quint8 n)`
- Line 40: `quint16 markerCnt() const`
- Line 41: `void setMarkerCnt(quint16 n)`
- Line 42: `quint32 pathLatitude(int n)`
- Line 43: `void setPathLatitude(int n, quint32 lat)`
- Line 44: `quint32 pathLongitude(int n)`
- Line 45: `void setPathLongitude(int n, quint32 lon)`
- Line 46: `void gpsDebugPrint()`
- Line 47: `bool inPoly2(const CIGCONF::gpsPosStruct *gpsPos, const CIGCONF::polygonStruct *polygon)`
- Line 48: `bool pointInPolygon(int polyCorners, CIGCONF::position me, CIGCONF::position *points)`
- Line 49: `double degrees2radians(double degrees)`

**Protected methods:**
- Line 51 (gnssreceiver.h): `void timerEvent(QTimerEvent *)`

**Private methods:**
- Line 57 (gnssreceiver.h): `void readData()`
- Line 58 (gnssreceiver.h): `void parseData(const QByteArray &ba)`
- Line 59 (gnssreceiver.h): `void cumulateDistance()`
- Line 60 (gnssreceiver.h): `static quint32 calculateDistance(qint32 lat1, qint32 lng1, qint32 lat2, qint32 lng2)`

**Signals (gnssreceiver.h):**
- Line 54: `void sendGmtpMessage(CIGCONF::GmtpMessage msg, const QByteArray &extra = QByteArray())`

**Slots:** `readData()` connected to `QSerialPort::readyRead` (gnssreceiver.cpp line 39)

**#include directives (gnssreceiver.h):**
- `"app/cigconfigs.h"`
- `<QObject>`

**#include directives (gnssreceiver.cpp):**
- `"gnssreceiver.h"`
- `"app/globalconfigs.h"`
- `"platform/seriallogger.h"`
- `<QFile>`
- `<QSerialPort>`
- `<QTimerEvent>`
- `<QDebug>`
- `<QtMath>`
- `<math.h>`

**GNSS/GPS message format constants (gnssreceiver.cpp):**
- `FILE_GNSS_PORT  "/dev/ttyUSB1"` (line 11) — hardcoded serial port path
- `EARTH_R  6371000UL` (line 13) — earth radius in metres
- `MAX_POINTS (8)` (gnssreceiver.h line 7) — path point buffer size
- NMEA sentence types parsed: `GPGGA` (line 107), `GPRMC` (line 129)

**Member variables (gnssreceiver.h):**
- `quint16 m_markerCnt`
- `CIGCONF::gpsPosStruct m_path[MAX_POINTS]` — fixed array of 8 GPS path points
- `QSerialPort *m_serialPort`
- `QByteArray m_receiver` — serial receive buffer, reserved at 512 bytes
- `int m_timerId`
- `bool m_locked`
- `quint8 m_warn`
- `quint8 m_quality`
- `quint8 m_satelliteCount`
- `qint32 m_latitude`
- `qint32 m_longitude`
- `qint32 m_lastLatitude`
- `qint32 m_lastLongitude`
- `qint16 m_speed`
- `qint16 m_course`
- `quint32 m_distance`
- `quint16 m_hdop`
- `quint32 m_sumOfDistance`
- `quint32 m_diffDistance`
- `quint32 m_lastPos`
- `qint64 m_lastReport`
- `quint32 m_altitude`
- `bool m_positionValid`
- `qint64 m_timestamp`

---

## STEP 5 — SECURITY REVIEW

---

### 1. Memory Safety

**A12-1** · HIGH · Memory Safety
**File:** `platform/gnssreceiver.cpp:261`
**Description:** `m_path[m_markerCnt]` is written in `cumulateDistance()` without a bounds check before the write. `m_markerCnt` is incremented at lines 255 and 263, and the array `m_path` has exactly `MAX_POINTS` (8) elements. The check `if (m_markerCnt == MAX_POINTS)` at line 267 fires a GMTP message but does NOT stop further increments — after the message is sent, `cumulateDistance()` continues to be called (it is invoked on every GPGGA message while `m_warn == 'A'`), so on subsequent GPS fixes `m_markerCnt` equals 8 or higher and the write at line 261 `m_path[m_markerCnt].longitude = m_longitude` indexes past the end of the 8-element array. This is an out-of-bounds write producing undefined behaviour and potential memory corruption.

**A12-2** · MEDIUM · Memory Safety
**File:** `platform/gnssreceiver.cpp:97-98`
**Description:** `m_receiver` is a `QByteArray` pre-reserved to 512 bytes. In `readData()`, when a partial NMEA sentence spans a serial read boundary, the trailing bytes are appended to `m_receiver` at line 98 (`m_receiver += ba.right(size)`). There is no check on the total accumulated length of `m_receiver` before appending. A sender that transmits a very long line without a `\r` or `\n` terminator — possible if the serial input is tampered with or the GNSS module malfunctions — will cause `m_receiver` to grow without bound, consuming heap memory. This is a slow-path denial-of-service / heap exhaustion path.

**A12-3** · LOW · Memory Safety
**File:** `platform/gnssreceiver.cpp:116`
**Description:** `bas[8].toFloat() * 100` is assigned to `m_hdop` which is declared as `quint16`. The NMEA GPGGA HDOP field is a floating-point string. If a malformed or spoofed GPGGA sentence supplies a value greater than 655.35 the multiplication produces a value exceeding `UINT16_MAX` (65535), causing silent integer truncation on assignment. The downstream check `m_hdop >= 5000` at line 137 used to reject bad fixes could then be bypassed if the truncated value falls below 5000.

---

### 2. Communication Security

**A12-4** · INFO · Communication Security
**File:** `platform/canbus.cpp:40`
**Description:** The CAN bus device is created using Qt's `socketcan` plugin. CAN bus carries no authentication or encryption at the protocol level. Any device on the same physical CAN bus can inject frames with arbitrary IDs. The application accepts all frames passing the configured filter without any message authentication code or sequence number check. This is an inherent CAN bus limitation, but the absence of any in-software authentication layer means a rogue CAN node can inject spoofed vehicle data. Documented here for completeness as a known architectural constraint.

**A12-5** · INFO · Communication Security
**File:** `platform/gnssreceiver.cpp:11`
**Description:** GNSS data is received over a serial port (`/dev/ttyUSB1`) from the GNSS module. There is no authentication of the GNSS data stream. A hardware-level attacker with access to the serial bus could inject arbitrary NMEA sentences. The application applies only a satellite-count and HDOP quality gate before accepting position data as valid. There is no GNSS spoofing detection (e.g., sudden large position jumps, unexpected signal levels). Given this is a proximity detection safety device, GNSS spoofing is a meaningful threat; the current implementation has no countermeasure.

---

### 3. Input Handling

**A12-6** · HIGH · Input Handling
**File:** `platform/gnssreceiver.cpp:104`
**Description:** In `parseData()`, `bas[0]` is accessed unconditionally at line 104 without first checking that `bas` is non-empty. `ba.split(',')` on an empty `QByteArray` returns a list with one empty element, so this does not crash in that case. However, `bas[6]` is accessed at line 110 inside the `GPGGA` branch only after checking `size >= 8`, and `bas[8]` at line 116 is also within that guard. In the `GPRMC` branch at line 129 the check is `size > 8` (strictly greater than 8) meaning `bas[8]` at line 161 is valid. However, `bas[2].at(0)` at line 132 is called after only `size > 8` is confirmed — this accesses element 2 which is within bounds, but `at(0)` on an empty `QByteArray` (if field 2 of the NMEA sentence is empty) will trigger an assertion failure or undefined behaviour. A GPRMC sentence with an empty status field (`,, ,`) would reach line 132 and call `at(0)` on an empty byte array.

**A12-7** · MEDIUM · Input Handling
**File:** `platform/gnssreceiver.cpp:143-152`
**Description:** Latitude and longitude are parsed from NMEA fields using `left()`, `mid()`, `toInt()`, and `toFloat()` without validating field lengths. For latitude (GPGGA/GPRMC `ddmm.mmmmm` format), `bas[3].left(2).toInt()` assumes at least 2 characters are present, and `bas[3].mid(2, 7).toFloat()` assumes at least 9 characters. If a spoofed or malformed NMEA sentence supplies a shorter field, `left(2)` or `mid(2,7)` silently return shorter strings and `toInt()`/`toFloat()` parse whatever is there. No range validation is applied to the resulting `latitude` value before it is stored in `m_latitude` and used in safety-critical geofencing logic. A valid geographic latitude in `qint32` scaled units should be in the range -900000000 to 900000000 — values outside this range are not rejected.

**A12-8** · MEDIUM · Input Handling
**File:** `platform/canbus.cpp:133-148`
**Description:** In `setPower()`, shell commands are built using `QStringLiteral("...").arg(m_canDeviceId)` and `QStringLiteral("...").arg(m_baudRate)`. `m_canDeviceId` is an enum (values 0 or 1), so injection via that field is not possible. However, `m_baudRate` is an `int` supplied by callers via `setBaudRate(int baudRate)`. There is no validation that `m_baudRate` is a legitimate CAN baud rate value (e.g., 125000, 250000, 500000, 1000000) before it is interpolated into the shell command at line 144: `/home/bin/ip link set up can%1 type can bitrate %2`. An integer value cannot carry shell metacharacters since Qt's `arg()` formats it numerically, so direct shell injection is not possible here. However, an extremely large or negative baud rate will produce an invalid `ip link` command without any diagnostic, and the failure is silently swallowed — the function returns without signalling the error to the caller.

**A12-9** · LOW · Input Handling
**File:** `platform/gnssreceiver.cpp:107`
**Description:** The NMEA sentence type is checked by comparing the first field `bas[0]` (after splitting on `,`) against string literals `"GPGGA"` and `"GPRMC"`. There is no NMEA checksum validation anywhere in `parseData()` or `readData()`. NMEA 0183 sentences include an optional `*HH` checksum at the end of each sentence. The code does not strip or verify this checksum before parsing numeric fields. A corrupted transmission or injected sentence with a wrong checksum will be silently accepted. Checksum validation would reject single-bit errors and trivial injection attempts at the serial layer.

---

### 4. Build Security

Build Security: no issues found in the files under review. The `.pro` file was not assigned to this auditor; compiler flag analysis is deferred to the auditor assigned to the build configuration files.

---

### 5. Device and Firmware

**A12-10** · MEDIUM · Device and Firmware
**File:** `platform/gnssreceiver.cpp:11`
**Description:** The GNSS serial port path `"/dev/ttyUSB1"` is hardcoded as a compile-time `#define`. A runtime override is provided via the environment variable `QT_NMEA_SERIAL_PORT` (lines 24-26). Reading a device path from an unauthenticated environment variable in production firmware allows an attacker with process-level access to redirect the GNSS input to an attacker-controlled file or device, feeding arbitrary NMEA sentences to the parser. On an embedded device where the environment is set from a configuration script, this is an elevated risk if that script is world-writable.

**A12-11** · HIGH · Device and Firmware
**File:** `platform/gnssreceiver.cpp:258-265`
**Description:** GPS path waypoints (`m_path[]`) are written to the fixed array in `cumulateDistance()` using `m_markerCnt` as the index, which is incremented every time the cumulative distance exceeds the configured `gpsDistanceMark()` threshold. The `gpsDistanceMark()` value comes from `gCfg` (global configuration), which is received from a server according to the checklist description of this device class. If a server or configuration file supplies a very small `gpsDistanceMark` value (e.g., 0 or 1 metre), the counter increments on every GPS fix and the out-of-bounds write described in A12-1 is triggered rapidly. A safety-critical parameter (distance marking threshold) received from an external source without a minimum-value floor directly enables a memory corruption path.

**A12-12** · MEDIUM · Device and Firmware
**File:** `platform/gnssreceiver.cpp:272-310`
**Description:** Geofence polygon vertices are read from `gCfg->polygon(polygon)` and `gCfg->polygonNPoints(polygon)` inside the geofencing loop in `cumulateDistance()`. The polygon data originates from server-supplied configuration. The loop iterates `i` from 0 to `polyCorners-1` and writes into `points[i]` where `points` is a fixed-size stack array `CIGCONF::position points[MAX_POLY_POINTS]` (line 277). If the server supplies a `polygonNPoints` value larger than `MAX_POLY_POINTS`, the loop at line 289 writes past the end of the stack-allocated `points` array, causing a stack buffer overflow. There is no check that `polyCorners <= MAX_POLY_POINTS` before the loop begins.

---

### 6. Qt-Specific Security

**A12-13** · MEDIUM · Qt-Specific Security
**File:** `platform/canbus.cpp:124-148`
**Description:** `QProcess` is used in `setPower()` to invoke `ifconfig` and `/home/bin/ip link set`. The `QProcess::start()` call at line 134 passes the full command as a single string (not a program + argument list). When `QProcess::start()` receives a single string, Qt splits it on spaces — this is the "shell-style" single-string form. While `m_canDeviceId` (an enum integer) and `m_baudRate` (an integer) cannot carry shell metacharacters, the use of `QProcess::start(QString)` with a constructed command string rather than `QProcess::start(QString program, QStringList args)` is a maintainability risk: if a future refactor introduces a string-typed parameter (e.g., a configurable interface name), the single-string invocation form does not provide the argument isolation that the two-argument form provides.

**A12-14** · LOW · Qt-Specific Security
**File:** `platform/canbus.cpp:30-32`
**Description:** The destructor `CanBus::~CanBus()` manually calls `delete m_canBusDevice` after a null check. `m_canBusDevice` is created with `QCanBus::instance()->createDevice()` in `initialize()` but is also passed `this` as the parent at construction in some Qt patterns. If `m_canBusDevice` was created with a parent, Qt's object tree will also attempt to delete it, resulting in a double-free. Inspection of line 40 shows `createDevice()` is called without passing a parent, so the object is unparented and the manual delete is the sole deletion path. This is currently safe, but the pattern is fragile: if `initialize()` is ever refactored to pass a parent, a double-free would be introduced silently.

---

## Summary of Findings

| ID | Severity | Category | File |
|---|---|---|---|
| A12-1 | HIGH | Memory Safety | `platform/gnssreceiver.cpp:261` |
| A12-2 | MEDIUM | Memory Safety | `platform/gnssreceiver.cpp:97-98` |
| A12-3 | LOW | Memory Safety | `platform/gnssreceiver.cpp:116` |
| A12-4 | INFO | Communication Security | `platform/canbus.cpp:40` |
| A12-5 | INFO | Communication Security | `platform/gnssreceiver.cpp:11` |
| A12-6 | HIGH | Input Handling | `platform/gnssreceiver.cpp:104` |
| A12-7 | MEDIUM | Input Handling | `platform/gnssreceiver.cpp:143-152` |
| A12-8 | MEDIUM | Input Handling | `platform/canbus.cpp:133-148` |
| A12-9 | LOW | Input Handling | `platform/gnssreceiver.cpp:107` |
| A12-10 | MEDIUM | Device and Firmware | `platform/gnssreceiver.cpp:11` |
| A12-11 | HIGH | Device and Firmware | `platform/gnssreceiver.cpp:258-265` |
| A12-12 | MEDIUM | Device and Firmware | `platform/gnssreceiver.cpp:272-310` |
| A12-13 | MEDIUM | Qt-Specific Security | `platform/canbus.cpp:124-148` |
| A12-14 | LOW | Qt-Specific Security | `platform/canbus.cpp:30-32` |
