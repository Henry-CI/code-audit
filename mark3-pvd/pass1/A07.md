# Pass 1 Audit — A07
**Auditor:** A07
**Date:** 2026-02-28
**Branch:** master
**Files reviewed:**
- `/c/Projects/cig-audit/repos/mark3-pvd/comm/canexpansion.h`
- `/c/Projects/cig-audit/repos/mark3-pvd/comm/canexpansion.cpp`
- `/c/Projects/cig-audit/repos/mark3-pvd/comm/canmonitor.h`
- `/c/Projects/cig-audit/repos/mark3-pvd/comm/canmonitor.cpp`

---

## Step 4 — Reading Evidence

### File Pair 1: canexpansion.h / canexpansion.cpp

**File paths:**
- `/c/Projects/cig-audit/repos/mark3-pvd/comm/canexpansion.h`
- `/c/Projects/cig-audit/repos/mark3-pvd/comm/canexpansion.cpp`

**Class name and base classes:**
- `CanExpansion : public QObject`

**Q_OBJECT macro location:**
- `canexpansion.h` line 23

**Every #include directive:**

canexpansion.h:
- `app/cigconfigs.h`
- `<QObject>`
- `<QFile>`
- `<QMap>`
- `<QVector>`
- `<QByteArray>`
- `<QQueue>`
- `<QTimer>`

canexpansion.cpp:
- `canexpansion.h`
- `platform/canbus.h`
- `app/globalconfigs.h`
- `platform/seriallogger.h`
- `platform/gnssreceiver.h`
- `platform/powersupply.h`
- `<QApplication>`
- `<QTimer>`
- `<QDateTime>`
- `<QFile>`
- `<QDebug>`
- `<QDataStream>`

**Every public method with signature and line number:**

canexpansion.h:
- `explicit CanExpansion(EM070::CanBus *canBus, EM070::PowerSupply *ps)` — line 42
- `void setEnabled(bool enable)` — line 44
- `const QByteArray &deviceName() const` — line 46
- `const QByteArray &bleVersion() const` — line 47
- `const QByteArray &mainVersion() const` — line 48
- `const QByteArray &manufacture() const` — line 49
- `const QByteArray &modelNumber() const` — line 50
- `bool relayOutput(CIGCONF::BleExpansionRelay relay) const` — line 52
- `void setRelayOutput(CIGCONF::BleExpansionRelay relay, bool state)` — line 55
- `quint16 relayTimeout(CIGCONF::BleExpansionRelay relay) const` — line 57
- `void setRelayTimeout(CIGCONF::BleExpansionRelay relay, quint16 timeout_in_sec)` — line 60
- `void setCurrentTime(quint32 time)` — line 62
- `bool digitalInput(CIGCONF::BleExpansionDI di) const` — line 64
- `void setShockThreshold(quint32 threshold)` — line 66
- `void setShockPeriod(quint32 period)` — line 67
- `bool isShockQueueEmpty()` — line 69
- `ShockEvent shockEvent()` — line 70
- `bool generateShockMessage(bool force)` — line 72
- `void setGnssReceiver(EM070::GnssReceiver* gnss)` — line 74

**Every signal:**
- `void inputStateChanged(CIGCONF::BleExpansionDI input, bool state)` — line 77
- `void shockOccurred()` — line 78
- `void amberImpactOccurred()` — line 79
- `void redImpactOccurred()` — line 80
- `void accessible(bool yes)` — line 81
- `void expModInfo(QByteArray mainVersion)` — line 82
- `void inactiveNotification(bool inactive, quint32 secs)` — line 83
- `void relayStateChanged(bool relay1, bool relay2)` — line 84

**Every slot (private):**
- `void initialise()` (connected to `m_initTimer` timeout) — line 89
- `void readCanFrame(quint32 id, const QByteArray &ba)` (connected to `CanBus::read`) — line 128
- `void packetHandler()` — line 249
- `void writeFrame()` — line 231
- `void timeout()` (connected to `m_timer` timeout) — line 162

**CAN message IDs / protocol constants defined (canexpansion.cpp):**
- `MK3_ID 0x3C1` — CAN identifier for expmod <-> MK3 comms (line 43)
- `SLIP_END 0xC0`, `SLIP_ESC 0xDB`, `SLIP_ESC_END 0xDC`, `SLIP_ESC_ESC 0xDD` — SLIP framing bytes
- `FROM_MK3_HEADER 0x01`, `TO_MK3_HEADER 0x81` — packet direction headers
- `CMD_WRITE_FLAG 0x8000`
- CMD_DEVICE_NAME (1001), CMD_BLE_FWVER (8), CMD_MAIN_FWVER (10), CMD_MFR_NAME (1002), CMD_MODEL_NUMBER (1003), CMD_RTC_TIME (26)
- CMD_DIGIN_STATE0..3 (31,35,39,43), CMD_RELAY_RESET (48), CMD_RELAY_STATE0 (50), CMD_RELAY_TIMEOUT0 (52), CMD_RELAY_STATE1 (54), CMD_RELAY_TIMEOUT1 (56)
- CMD_SHOCK_COUNT (75), CMD_SHOCK_PEEK (78), CMD_SHOCK_POP (80), CMD_SHOCK_THRESHOLD (82), CMD_SHOCK_PERIOD (84), CMD_SHOCK_MAGMAX (86), CMD_SHOCK_NOTIFY (1004)
- `MAX_BUFFER_SIZE 256` — maximum RX/TX buffer size (line 41)
- `REDIMPACT_SHOCKMSG_TIME 3`, `REDIMPACT_COUNTER_OFF (-1)`

**Every member variable (canexpansion.h):**
- `EM070::CanBus *m_canBus`
- `EM070::PowerSupply *m_powerSupply`
- `EM070::GnssReceiver *m_gnssReceiver`
- `QTimer *m_timer`
- `QTimer *m_initTimer`
- `QByteArray m_rx`
- `QByteArray m_tx`
- `bool m_active`
- `bool m_lastActive`
- `quint32 m_inactiveCount`
- `QByteArray m_deviceName`
- `QByteArray m_bleVersion`
- `QByteArray m_mainVersion`
- `QByteArray m_manufacture`
- `QByteArray m_modelNumber`
- `bool m_digitalInput[4]`
- `bool m_outputRelay[2]`
- `quint16 m_outputRelayTimeout[2]`
- `quint32 m_shockThreshold`
- `quint32 m_shockPeriod`
- `qint32 m_redImpactCounter`
- `quint32 m_shockTimestamp`
- `ShockEvent m_shockEvent1`
- `QQueue<ShockEvent> m_shockEvents`

---

### File Pair 2: canmonitor.h / canmonitor.cpp

**File paths:**
- `/c/Projects/cig-audit/repos/mark3-pvd/comm/canmonitor.h`
- `/c/Projects/cig-audit/repos/mark3-pvd/comm/canmonitor.cpp`

**Class name and base classes:**
- `CanMonitor : public QObject`

**Q_OBJECT macro location:**
- `canmonitor.h` line 18

**Every #include directive:**

canmonitor.h:
- `app/cigconfigs.h`
- `<QObject>`
- `<QFile>`
- `<QMap>`
- `<QVector>`

canmonitor.cpp:
- `canmonitor.h`
- `platform/canbus.h`
- `app/globalconfigs.h`
- `platform/seriallogger.h`
- `<QApplication>`
- `<QTimer>`
- `<QDateTime>`
- `<QTime>`
- `<QFile>`
- `<QDebug>`
- `<QtEndian>`

**Every public method with signature and line number (canmonitor.h):**
- `explicit CanMonitor(EM070::CanBus *canBus)` — line 20
- `bool readCanConfig()` — line 22
- `bool readOldCanConfig()` — line 23
- `void saveCanConfig()` — line 24
- `void calculateCanCrc()` — line 25
- `quint32 canCrc32() const` — line 28
- `void setEnabled(bool enable)` — line 30
- `void clearCanConfig()` — line 32
- `QByteArray canBusConfig() const` — line 33
- `bool setCanBusConfig(const QByteArray &config)` — line 34
- `QByteArray canPgnConfig() const` — line 35
- `bool setCanPgnConfig(const QByteArray &config)` — line 36
- `QByteArray canSpnConfig() const` — line 37
- `bool setCanSpnConfig(const QByteArray &config)` — line 38
- `QByteArray canAttConfig() const` — line 39
- `bool setCanAttConfig(const QByteArray &config)` — line 40
- `QByteArray canLinConfig() const` — line 41
- `bool setCanLinConfig(const QByteArray &config)` — line 42
- `QByteArray canBydConfig() const` — line 43
- `bool setCanBydConfig(const QByteArray &config)` — line 44
- `QByteArray canLin2Config() const` — line 45
- `bool setCanLin2Config(const QByteArray &config)` — line 46
- `bool isXferEnabled() const` — line 48
- `QByteArray attributeName(quint8 index) const` — line 49
- `CIGCONF::CanAttributeType attributeType(quint8 index) const` — line 50
- `void setVdiAccess(bool access, bool inhibit)` — line 52
- `void enableVdi(bool enable)` — line 53

**Every signal:**
- `void resetCanStates(bool resetLast)` — line 60
- `void stateUpdated(quint8 index, quint32 state)` — line 61

**Every slot (private, connected via constructor):**
- `void updateBusConfig()` (connected to `m_timer` timeout) — line 1301
- `void updateRequests()` (connected to `m_timer` timeout) — line 1313
- `void readCanFrame(quint32 id, const QByteArray &ba)` (connected to `CanBus::read`) — line 1369
- `void perfTimer()` (connected to `m_perfTimer` timeout, conditional on `PERF_MON`) — line 101

**CAN message IDs / protocol constants defined (canmonitor.cpp):**
- `CAN_CONF_FILE_OLD "cancfg.dat"`, `CAN_CONF_FILE "cancfgnew.dat"`
- `LIN_CANID_OFFSET 0x10`, `LIN_ADDR_OFFSET 0x4000`
- `BYD_CANID_XOR 0x380`, `BYD_ADDR_OFFSET 0x0B000000`
- `UPDATE_DEFER 3000` — timer delay before applying config changes
- Rule name pattern constants: RULE_SEAT_U/L, RULE_TRAC_U/L, RULE_HYDR_U/L, RULE_HYDL_U/L, RULE_HRS_U/L, RULE_BACD_U/L, RULE_BLAN_U/L

**Every member variable (canmonitor.h):**
- `EM070::CanBus *m_canBus`
- `QTimer *m_timer`
- `QFile m_file`
- `quint32 m_canCrc32`
- `bool m_enabled`
- `BusConfig m_busConfig`
- `PgnConfig m_pgnConfigs[CAN_MAX_PGN_IDX]` — 10 entries
- `SpnConfig m_spnConfigs[CAN_MAX_SPN_IDX]` — 20 entries
- `AttConfig m_attConfigs[CAN_MAX_ATT_IDX]` — 15 entries
- `QMap<quint8, quint8> m_attrToSpn`
- `quint32 m_spnState[CAN_MAX_SPN_IDX]` — 20 entries
- `quint32 m_perfCounter`
- `QTimer *m_perfTimer`
- `bool m_vdiAccess`
- `bool m_vdiInhibit`

---

## Step 5 — Security Review

### 1. Memory Safety

**A07-1** · HIGH · Memory Safety
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/comm/canexpansion.cpp:158-159`
**Description:** The receive buffer `m_rx` is allowed to grow unboundedly from CAN frame data before the overflow guard at line 158 is checked. The guard truncates to the last `MAX_BUFFER_SIZE` (256) bytes using `m_rx.right(MAX_BUFFER_SIZE)`, which silently discards leading data rather than preventing overflow. An attacker who can inject a continuous stream of CAN frames with id `0x3C1` and no SLIP_END byte can cause `m_rx` to grow to an arbitrarily large size before truncation, consuming device heap memory. Over repeated cycles this produces unbounded heap growth. The correct fix is to refuse new data once the limit is reached, not to trim after the fact.

**A07-2** · HIGH · Memory Safety
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/comm/canexpansion.cpp:225-226`
**Description:** The transmit buffer `m_tx` has the same post-hoc truncation pattern as `m_rx`. After `sendPacket` appends a new SLIP-encoded command to `m_tx`, it checks `if (m_tx.size() > MAX_BUFFER_SIZE)` and discards the beginning of the buffer. This silently corrupts in-flight commands rather than rejecting the write. A rapid sequence of `setRelayOutput`, `setRelayTimeout`, `setCurrentTime`, etc. calls can cause valid command packets to be silently dropped or fragmented.

**A07-3** · MEDIUM · Memory Safety
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/comm/canexpansion.cpp:76`
**Description:** `memset(&m_shockEvent1, 0, sizeof(ShockEvent))` is used in the constructor and in `generateShockMessage` (line 588) to zero the `ShockEvent` struct. `ShockEvent` contains a `bool isIgnitionOn` member and several `quint` fields. Using `memset` to zero a struct that contains `bool` members is technically implementation-defined (zero is a valid false representation on all current targets, but this is not guaranteed by the C++ standard). More importantly, if `ShockEvent` is ever extended with a non-POD member, the `memset` calls at lines 76 and 588 will silently corrupt those members. This is a latent safety risk in safety-critical shock event handling.

**A07-4** · MEDIUM · Memory Safety
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/comm/canexpansion.cpp:64`
**Description:** `digitalInput(CIGCONF::BleExpansionDI di)` computes the array index as `di - CIGCONF::BleExpDI1` with no bounds check. `BleExpDI1` through `BleExpDI4` are enum values 0–3, and `m_digitalInput` has size 4. If a caller passes any value outside this range (or a future enum value is added), this produces an out-of-bounds array access. The member is also never written by `readCanFrame` or `packetHandler` — the `inputStateChanged` signal is emitted instead of updating `m_digitalInput`, making `digitalInput()` always return uninitialized memory (the array is not initialized in the constructor or with `memset`). This is a logic and memory safety issue.

**A07-5** · MEDIUM · Memory Safety
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/comm/canmonitor.cpp:400`
**Description:** `qstrcpy(config.CanSignalInfo.canAtt[i].name, attConfig.name)` in `calculateCanCrc()`. Although `attConfig.name` is bounded by `CAN_ATT_NAME_LEN` (10 bytes) and the destination `canAtt[i].name` is also declared with `CAN_ATT_NAME_LEN` characters (cigconfigs.h line 233), `qstrcpy` does no bounds checking. If the source `attConfig.name` is ever not null-terminated within its 10-byte field (possible if binary config data is loaded via `memcpy` from a file without strict validation), this produces a stack buffer overread/overwrite. `qstrncpy` with an explicit length would be the safe equivalent.

**A07-6** · MEDIUM · Memory Safety
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/comm/canmonitor.cpp:818`
**Description:** `qstrcpy(attribute.name, name.constData())` in `setCanAttConfig()`. The `name` `QByteArray` is checked at line 772 (`name.size() >= CAN_ATT_NAME_LEN` returns false), meaning a name of exactly `CAN_ATT_NAME_LEN - 1` bytes (9 bytes) is accepted. However `qstrcpy` copies the null terminator too, so a 9-byte input will write 10 bytes including the null, which exactly fits. If the check at line 772 ever changes to `>` instead of `>=`, or if `CAN_ATT_NAME_LEN` is reduced without updating the check, an off-by-one overflow occurs. The use of `qstrcpy` rather than `qstrncpy` leaves no margin for error. Additionally, the `name` field of `AttConfig` is `char[CAN_ATT_NAME_LEN]` and there is no guarantee it is null-terminated when read back from a binary file via `memcpy`.

**A07-7** · LOW · Memory Safety
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/comm/canmonitor.cpp:449-458`
**Description:** In `childSpnIndexes()`, `spnIndexes[config.siblingIndex]` is written using `siblingIndex` as the array index into `spnIndexes[CAN_MAX_LINK_IDX]` (size 8). `siblingIndex` is a `quint8` loaded from the config file via `memcpy` with no range check at read time. A corrupted or malicious config file can set `siblingIndex` to a value 8–255, causing an out-of-bounds write to the stack-allocated `spnIndexes` array. The call at line 936 `spnConfig.siblingIndex = childSpnIndexes(pgnIndex).size()` does bound the newly-set value, but existing entries in the config file are not re-validated.

---

### 2. Communication Security

**A07-8** · HIGH · Communication Security
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/comm/canexpansion.cpp:43`
**Description:** The CAN identifier `MK3_ID 0x3C1` is hardcoded and is the sole authentication mechanism for the expansion module communication channel. The SLIP protocol over CAN has no message authentication code, no sequence number, and no replay protection. Any device on the same CAN bus that sends frames with id `0x3C1` using the `TO_MK3_HEADER (0x81)` direction byte will be accepted as a legitimate expansion module and can inject arbitrary commands including relay state changes (`CMD_RELAY_STATE0`, `CMD_RELAY_STATE1`) and shock threshold manipulation (`CMD_SHOCK_THRESHOLD`). This is a spoofing risk on the CAN bus.

**A07-9** · MEDIUM · Communication Security
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/comm/canexpansion.cpp:251`
**Description:** The `packetHandler()` state machine uses a `static` local variable `sm` and `shocks_read` to track protocol state. Static locals are shared across all invocations of `packetHandler()`, which is called from the slot `readCanFrame`. Because `CanExpansion` may have only one instance, this is not an immediate multi-instance issue, but a reset of the `m_rx` buffer (line 149) does not reset `sm`, meaning an attacker who sends a valid `CMD_MODEL_NUMBER` response at any time can reset the device into full re-initialization (re-sending shock threshold, relay states, etc.) without going through the intended handshake order.

**A07-10** · MEDIUM · Communication Security
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/comm/canmonitor.cpp:15-16`
**Description:** CAN configuration is persisted to plaintext binary files `cancfg.dat` / `cancfgnew.dat` with only a CRC32 integrity check (not an HMAC or cryptographic signature). CRC32 is not collision-resistant — an attacker with filesystem write access can craft a replacement config file with an identical CRC32, injecting arbitrary CAN PGN/SPN configuration. This could alter which vehicle CAN signals are used for safety-critical decisions (seat sensor, traction control, hydraulics).

---

### 3. Input Handling

**A07-11** · HIGH · Input Handling
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/comm/canexpansion.cpp:353-354`
**Description:** In `packetHandler()`, the `CMD_DIGIN_STATE0` through `CMD_DIGIN_STATE3` cases check `m_rx.size() < 12` before reading, but only a single `quint8 state` value is actually read via `QDataStream`. A check of `< 12` implies a 12-byte minimum but the actual data consumed is 4 bytes (1 header + 2 cmd bytes + 1 state byte). The minimum-size check is inconsistent with actual data consumption. This is not immediately exploitable given QDataStream's read will not crash on a short buffer, but it indicates an unchecked assumption about the protocol message layout that could mask truncated or malformed messages.

**A07-12** · HIGH · Input Handling
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/comm/canexpansion.cpp:608-661`
**Description:** `popShockEvent()` checks `ba.size() >= 8` before reading, but only reads 8 bytes (`quint32 timestamp` + `quint32 magnitude`) via `QDataStream`. The function then proceeds to use the parsed `event.magnitude` directly to trigger safety-critical signals (`amberImpactOccurred()`, `redImpactOccurred()`) and to compare against `m_shockThreshold`. There is no upper-bound check on `event.magnitude`: a spoofed CAN frame from another node on the bus (see A07-8) can inject an arbitrarily large magnitude value, causing false red/amber impact alerts. There is also no validation of `event.timestamp`: a zero or very large timestamp could interfere with the shock deduplication logic in `generateShockMessage()`.

**A07-13** · MEDIUM · Input Handling
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/comm/canmonitor.cpp:1538`
**Description:** In `updateSpnState()`, the expression `(1U << spnConfig.width) - 1` is used to compute a bit mask. `spnConfig.width` is a `quint8` (0–255). If `width` equals 32, the shift `1U << 32` is undefined behavior in C++ (left-shifting a 32-bit value by its bit width). If `width` is 0, the result is `(1U << 0) - 1 = 0`, producing a zero mask that silently discards all data bits. `width` comes from a config file that is only protected by CRC32, so a tampered config can inject a `width` of 32 or greater. The fix is to clamp `spnConfig.width` to the range 1–31 before use in this expression.

**A07-14** · MEDIUM · Input Handling
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/comm/canmonitor.cpp:1579-1586`
**Description:** In the BCD decode branch (`case 'b'`) of `updateSpnState()`, `digits = spnConfig.width / 4`. The loop `for (quint8 i=0; i<sizeof(spnData); ++i)` iterates 4 times (sizeof `quint32`). The subsequent trimming loop `for (quint8 i=2*sizeof(spnData)-digits; i>0; --i)` relies on `digits` being `<= 2*sizeof(spnData)` (i.e., `<= 8`). If `spnConfig.width` is 0, `digits` is 0 and the trim loop counter is `2*4 - 0 = 8`, which may trim too many digits. If `width > 32`, `digits > 8` and the subtraction `2*4 - digits` underflows (wrapping to a large positive number for unsigned `quint8`), causing the trim loop to divide `spnState` by 10 hundreds of times, always producing 0. This silent data corruption affects the vehicle hours/BAC data derived from CAN.

**A07-15** · MEDIUM · Input Handling
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/comm/canmonitor.cpp:1508`
**Description:** In `updateState()`, the `CanAttributeCount`/`CanAttributeTime` case computes `spnStates |= m_spnState[j] << j`. The loop variable `j` iterates up to `CAN_MAX_SPN_IDX` (20). When `j >= 32`, the shift `m_spnState[j] << j` is undefined behavior on 32-bit systems (shifting a 32-bit value by 32 or more). An attacker who controls CAN configuration (see A07-10) can arrange for a `spnMask` bit to be set at position 31 or beyond, triggering this undefined behavior and potentially causing unpredictable safety-critical state evaluation.

**A07-16** · LOW · Input Handling
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/comm/canmonitor.cpp:1282-1283`
**Description:** In `createRequest()` for the `LindeExtended` protocol, `quint16 addr = spnConfig.spn` truncates a `quint64` SPN address field to 16 bits. If the config was set via `setCanLinConfig` the value is bounded to `0xffff - LIN_ADDR_OFFSET`, but if loaded from a binary file via `memcpy` (where `spnConfig.spn` is a full `quint64`), a value with upper bits set will be silently truncated. This could cause the device to poll the wrong CAN address for sensor data.

---

### 4. Build Security

Build Security: no issues found in the reviewed source files. (The `.pro` build file is not within the assigned file set for this auditor; compiler flags are not visible in these files.)

---

### 5. Device and Firmware

**A07-17** · HIGH · Device and Firmware
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/comm/canexpansion.cpp:319-320`
**Description:** Shock detection thresholds are loaded from `gCfg->shockThreshold()` and `gCfg->shockPeriod()` and written to the expansion module over CAN via `setShockThreshold()` and `setShockPeriod()`. There is no range validation applied to these values before they are sent. A configuration that sets `shockThreshold` to `0xFFFFFFFF` would suppress all shock alerts (no impact would ever exceed the threshold), and a `shockPeriod` of 0 or very large value would break the shock event timing. Because these are safety-critical thresholds for a vehicle proximity/impact detection device, values received from a remote configuration source must be validated against a safe operating range before being applied.

**A07-18** · MEDIUM · Device and Firmware
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/comm/canexpansion.cpp:637-643`
**Description:** The amber impact threshold is computed inline as `gCfg->shockRedImpact() / 2`. There is no separate amber threshold configuration — it is always half the red impact threshold. If `gCfg->shockRedImpact()` returns 1 (minimum valid value), the amber threshold is 0, meaning every shock above zero triggers an amber alert. If it returns 0 (disabled), the division and the amber alert check are guarded at line 637 (`gCfg->shockRedImpact()` used as a boolean). The implicit coupling of amber to red thresholds and the absence of an independently validated amber threshold is a safety-critical design issue.

**A07-19** · MEDIUM · Device and Firmware
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/comm/canmonitor.cpp:1600-1613`
**Description:** `initVdi()` hardcodes the VDI (Vehicle Data Interface) CAN configuration by calling `setCanLinConfig` and `setCanAttConfig` with string literals. The CAN identifiers (`195`, `295`), offsets, widths, and attribute names (`SEAT`, `TRACK`, `HYDR`, `HRSS0`) are baked into firmware. Any change to the VDI hardware interface requires a firmware update. More critically, these hardcoded values bypass the CRC-validated configuration file mechanism, meaning VDI mode operates with a fixed, unverifiable configuration that cannot be audited through the same channel as standard CAN configuration.

---

### 6. Qt-Specific Security

**A07-20** · MEDIUM · Qt-Specific Security
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/comm/canexpansion.cpp:659`
**Description:** `qDebug() << "EXPMOD Shock" << event.timestamp << event.magnitude;` at line 659 logs shock event data including timestamp and magnitude unconditionally on every received shock event. `qDebug()` output is active in both debug and release builds unless explicitly disabled at compile time (`QT_NO_DEBUG_OUTPUT` or `qt_configure_warnings`). Shock event data (timestamps, magnitudes) may be logged to a serial console or other output that is accessible in a deployed device. This leaks operational telemetry that could be used by an attacker to understand the device's sensitivity thresholds and timing.

**A07-21** · MEDIUM · Qt-Specific Security
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/comm/canmonitor.cpp:415`
**Description:** `qDebug() << "CAN Config CRC: " << m_canCrc32;` logs the CAN configuration CRC32 value unconditionally every time `calculateCanCrc()` is called. An attacker monitoring the serial output gains the exact CRC32 needed to craft a replacement `cancfgnew.dat` file with the same checksum but altered safety-critical configuration (see A07-10). Logging the CRC value externally removes any practical security value the integrity check might otherwise provide.

**A07-22** · LOW · Qt-Specific Security
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/comm/canmonitor.cpp:1522`
**Description:** `qDebug() << "CAN Name/State:" << attr.name << attState;` logs CAN attribute names and their computed state values on every state change. This fires on every CAN frame that changes a monitored attribute. Depending on the serial logger configuration, this may produce high-volume diagnostic output in production firmware that exposes vehicle operational state (seat occupancy, traction, hydraulic state) to anyone with serial console access.

---

## Summary of Findings

| ID | Severity | Category |
|----|----------|----------|
| A07-1 | HIGH | Memory Safety — unbounded RX buffer growth before truncation |
| A07-2 | HIGH | Memory Safety — unbounded TX buffer truncation corrupts commands |
| A07-3 | MEDIUM | Memory Safety — memset on struct with bool; latent risk if extended |
| A07-4 | MEDIUM | Memory Safety — uninitialized m_digitalInput array; no bounds check on enum index |
| A07-5 | MEDIUM | Memory Safety — qstrcpy without bounds on attConfig.name in calculateCanCrc |
| A07-6 | MEDIUM | Memory Safety — qstrcpy without bounds in setCanAttConfig; off-by-one risk |
| A07-7 | LOW | Memory Safety — unvalidated siblingIndex from config file used as array index |
| A07-8 | HIGH | Communication Security — no CAN message authentication; relay/threshold spoofable |
| A07-9 | MEDIUM | Communication Security — static state machine variable allows out-of-order injection |
| A07-10 | MEDIUM | Communication Security — CRC32-only integrity on config file; not collision-resistant |
| A07-11 | HIGH | Input Handling — inconsistent size check in DIGIN packet handler |
| A07-12 | HIGH | Input Handling — no upper-bound validation on shock magnitude before safety signal |
| A07-13 | MEDIUM | Input Handling — undefined behavior when spnConfig.width >= 32 in bit shift |
| A07-14 | MEDIUM | Input Handling — BCD decode loop underflow when width is 0 or >32 |
| A07-15 | MEDIUM | Input Handling — undefined shift by >= 32 in spnStates computation |
| A07-16 | LOW | Input Handling — quint64 spn address silently truncated to quint16 for LindeExtended |
| A07-17 | HIGH | Device and Firmware — no range validation on shock threshold/period before applying |
| A07-18 | MEDIUM | Device and Firmware — amber impact threshold implicitly derived; no independent validation |
| A07-19 | MEDIUM | Device and Firmware — VDI CAN config hardcoded, bypasses validated config file |
| A07-20 | MEDIUM | Qt-Specific Security — qDebug logs shock telemetry unconditionally in production |
| A07-21 | MEDIUM | Qt-Specific Security — qDebug logs CAN config CRC, undermines integrity check |
| A07-22 | LOW | Qt-Specific Security — qDebug logs vehicle operational state on every CAN state change |
