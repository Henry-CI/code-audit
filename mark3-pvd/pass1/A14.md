# Pass 1 Audit — A14
**Auditor:** A14
**Date:** 2026-02-28
**Branch:** master (confirmed)
**Files reviewed:**
- `/c/Projects/cig-audit/repos/mark3-pvd/platform/powersupply.h`
- `/c/Projects/cig-audit/repos/mark3-pvd/platform/powersupply.cpp`
- `/c/Projects/cig-audit/repos/mark3-pvd/platform/pwmbacklight.h`
- `/c/Projects/cig-audit/repos/mark3-pvd/platform/pwmbacklight.cpp`
- `/c/Projects/cig-audit/repos/mark3-pvd/platform/pwmbeeper.h`
- `/c/Projects/cig-audit/repos/mark3-pvd/platform/pwmbeeper.cpp`

---

## STEP 4 — READING EVIDENCE

### powersupply.h / powersupply.cpp

**File paths:**
- `/c/Projects/cig-audit/repos/mark3-pvd/platform/powersupply.h`
- `/c/Projects/cig-audit/repos/mark3-pvd/platform/powersupply.cpp`

**Class name and base classes:**
- `EM070::PowerSupply` : `QObject`

**Q_OBJECT macro location:**
- `powersupply.h` line 14

**Every public method with signature and line number:**
- `explicit PowerSupply(QObject *parent = nullptr)` — h:19
- `bool isIgnitionOn() const` — h:21
- `bool isPowerGood() const` — h:23
- `bool isBatteryAvailable() const` — h:24
- `ChargeState chargeState() const` — h:25
- `ChargeFault chargeFault() const` — h:26
- `quint16 voltage() const` — h:27
- `qint16 current() const` — h:28
- `quint16 temperature() const` — h:29
- `quint16 remainingCapacity() const` — h:30
- `quint16 designCapacity() const` — h:31
- `quint16 timeToEmpty() const` — h:32
- `quint16 timeToFull() const` — h:33
- `static void reboot()` — h:35
- `static void poweroff()` — h:36
- `static void setBlankMode(BlankMode mode)` — h:37
- `static void setTouchPower(bool on)` — h:38
- `static void charge(bool enable)` — h:39
- `static void setBatteryEnabled(bool enable)` — h:40

**Signals:**
- `void ignitionStateChanged(bool on)` — h:43
- `void batteryStatusRead(bool avail, int state, int fault, quint16 voltage, qint16 current, quint16 temp, quint16 remainingCapacity)` — h:44

**Slots (private):**
- `void readIgnitionState()` — h:47 (connected to QSocketNotifier::activated)
- `void readChargerStatus()` — h:48 (connected to QTimer::timeout)
- `void readGaugeStatus()` — h:49 (called from readChargerStatus)

**#include directives (powersupply.h):**
- `<QObject>` — h:4
- `<QFile>` — h:5

**#include directives (powersupply.cpp):**
- `"powersupply.h"` — cpp:1
- `<QEventLoop>` — cpp:2
- `<QProcess>` — cpp:3
- `<QSocketNotifier>` — cpp:4
- `<QTimer>` — cpp:5
- `<QDebug>` — cpp:6

**Hardware register / sysfs paths defined (powersupply.cpp):**
- `FILE_IGNITION` = `/sys/devices/platform/nuc970-gpio.0/gpio/gpio225/value` — cpp:10
- `FILE_FB_BLANK` = `/sys/devices/platform/nuc970-lcd/graphics/fb0/blank` — cpp:11
- `FILE_TOUCH_POWER` = `/sys/touchscreen/power_state` — cpp:12
- `FILE_CHARGE_EN` = `/sys/class/gpio/gpio160/value` — cpp:13
- `FILE_BATFET_DISABLE` = `/sys/devices/platform/nuc970-i2c0/i2c-0/0-006b/power_supply/bq24190-charger/f_batfet_disable` — cpp:14
- `FILE_PG_STAT` = `/sys/devices/platform/nuc970-i2c0/i2c-0/0-006b/power_supply/bq24190-charger/f_pg_stat` — cpp:15
- `FILE_VSYS_STAT` = `/sys/devices/platform/nuc970-i2c0/i2c-0/0-006b/power_supply/bq24190-charger/f_vsys_stat` — cpp:16
- `FILE_CHRG_STAT` = `/sys/devices/platform/nuc970-i2c0/i2c-0/0-006b/power_supply/bq24190-charger/f_chrg_stat` — cpp:17
- `FILE_CHRG_FAULT` = `/sys/devices/platform/nuc970-i2c0/i2c-0/0-006b/power_supply/bq24190-charger/f_chrg_fault` — cpp:18
- `FILE_NTC_FAULT` = `/sys/devices/platform/nuc970-i2c0/i2c-0/0-006b/power_supply/bq24190-charger/f_ntc_fault` — cpp:19
- `FILE_GAUGE_REGS` = `/sys/devices/platform/nuc970-i2c0/i2c-0/0-0055/show_regs` — cpp:20

**Member variables:**
- `QFile m_ignitionFile` — h:51
- `QSocketNotifier *m_notifier` — h:52
- `QTimer *m_timer` — h:53
- `bool m_ignitionOn` — h:55
- `bool m_powerGood` — h:56
- `bool m_batteryAvailable` — h:57
- `ChargeState m_chargeState` — h:58
- `ChargeFault m_chargeFault` — h:59
- `quint16 m_voltage` — h:60 (in mV)
- `qint16 m_current` — h:61 (in mA)
- `quint16 m_temperature` — h:62 (in Celsius)
- `quint16 m_remainingCapacity` — h:63 (in %)
- `quint16 m_designCapacity` — h:64 (in mAH)
- `quint16 m_timeToEmpty` — h:65 (in minutes)
- `quint16 m_timeToFull` — h:66 (in minutes)

---

### pwmbacklight.h / pwmbacklight.cpp

**File paths:**
- `/c/Projects/cig-audit/repos/mark3-pvd/platform/pwmbacklight.h`
- `/c/Projects/cig-audit/repos/mark3-pvd/platform/pwmbacklight.cpp`

**Class name and base classes:**
- `EM070::PwmBacklight` : `QObject`

**Q_OBJECT macro location:**
- `pwmbacklight.h` line 13

**Every public method with signature and line number:**
- `explicit PwmBacklight(QObject *parent = nullptr)` — h:16
- `~PwmBacklight()` — h:17
- `void setAutoBrightness(bool enable)` — h:18
- `bool isAutoBrightness() const` — h:19
- `static quint8 brightness()` — h:21
- `static void setBrightness(quint8 val)` — h:22

**Signals:**
- `void luxRead(int lux)` — h:25

**Slots (protected / private):**
- `void timerEvent(QTimerEvent *)` — h:28 (protected, Qt event override)
- `void parse(int lux)` — h:31 (private)
- `void adjust(int lux)` — h:32 (private)
- `int readLux()` — h:33 (private)

**#include directives (pwmbacklight.h):**
- `<QObject>` — h:4
- `<QFile>` — h:5
- `<QQueue>` — h:6
- `<QMap>` — h:7

**#include directives (pwmbacklight.cpp):**
- `"pwmbacklight.h"` — cpp:1
- `<QTimerEvent>` — cpp:2
- `<QFile>` — cpp:3
- `<QDebug>` — cpp:4

**Hardware register / sysfs paths defined (pwmbacklight.cpp):**
- `FILE_BRIGHTNESS` = `/sys/devices/platform/pwm-backlight.0/backlight/pwm-backlight.0/brightness` — cpp:6
- `FILE_ALS_POWER` = `/sys/devices/platform/nuc970-i2c0/i2c-0/0-0044/power_state` — cpp:7
- `FILE_ALS_RANGE` = `/sys/devices/platform/nuc970-i2c0/i2c-0/0-0044/range` — cpp:8
- `FILE_ALS_LUX` = `/sys/devices/platform/nuc970-i2c0/i2c-0/0-0044/lux` — cpp:9

**Macros:**
- `TIMER_INTERVAL` = 250 — cpp:11
- `TWO_SECONDS` = 7 — cpp:12
- `THREE_SECONDS` = 11 — cpp:13
- `MAX_QUEUE_SIZE` = 20 — cpp:15
- `X1P1(v)` = `(v) * 333 >> 8` — cpp:17
- `X1P2(v)` = `(v) * 333 >> 8` — cpp:18

**Member variables:**
- `QFile m_alsPowerFile` — h:36
- `QFile m_alsLuxFile` — h:37
- `QMap<int, int> m_brightnessMap` — h:38
- `QQueue<int> m_luxQueue` — h:39
- `bool m_autoBrightness` — h:40
- `int m_timerId` — h:41
- `State m_state` — h:42
- `quint8 m_stateCount` — h:43
- `int m_currentLux` — h:44

---

### pwmbeeper.h / pwmbeeper.cpp

**File paths:**
- `/c/Projects/cig-audit/repos/mark3-pvd/platform/pwmbeeper.h`
- `/c/Projects/cig-audit/repos/mark3-pvd/platform/pwmbeeper.cpp`

**Class name and base classes:**
- `EM070::PwmBeeper` : `QObject`

**Q_OBJECT macro location:**
- `pwmbeeper.h` line 13

**Every public method with signature and line number:**
- `explicit PwmBeeper(bool autoDelete = false, QObject *parent = nullptr)` — h:18
- `~PwmBeeper()` — h:19
- `void setFrequency(quint16 frequency)` — h:20
- `void beep(quint16 milliseconds)` — h:21
- `void beep(quint16 frequency, quint16 milliseconds)` — h:22
- `void beep(qint16 count, quint16 msecOn, quint16 msecOff)` — h:23
- `void stop()` — h:24

**Signals:** None.

**Slots (private):**
- `void timeout()` — h:27 (connected to QTimer::timeout)
- `void setBeep(bool on)` — h:28 (private helper)

**#include directives (pwmbeeper.h):**
- `<QObject>` — h:4
- `<QFile>` — h:5

**#include directives (pwmbeeper.cpp):**
- `"pwmbeeper.h"` — cpp:1
- `<linux/input.h>` (guarded by `#ifdef __arm__`) — cpp:3
- `<QTimer>` — cpp:5
- `<QDebug>` — cpp:6

**Hardware device path defined (pwmbeeper.cpp):**
- `FILE_BEEPER` = `/dev/input/event3` — cpp:8

**Member variables:**
- `QTimer *m_timerOn` — h:30
- `QTimer *m_timerOff` — h:31
- `QFile m_file` — h:32
- `bool m_autoDelete` — h:33
- `quint16 m_frequency` — h:34
- `bool m_beeping` — h:35
- `qint16 m_count` — h:36
- `quint16 m_msecOn` — h:37
- `quint16 m_msecOff` — h:38

---

## STEP 5 — SECURITY REVIEW

### 1. Memory Safety

**powersupply.cpp — gauge data parsed with no array bounds check**

`readGaugeStatus()` at line 143 splits a single line read from sysfs into a `QByteArrayList` and then directly indexes `args[0]` through `args[6]` (lines 145, 154, 158, 163, 166, 170, 174) without first verifying that `args.size() >= 7`. If the kernel driver or the sysfs file returns a line with fewer than seven comma-separated fields — due to a partial read, driver bug, or filesystem error — any of these accesses will index out of bounds on a `QByteArrayList`, which in Qt invokes undefined behaviour (the operator[] on QList performs no bounds check in release builds). On an embedded device running without address-space layout randomisation and without a stack protector (see Section 4), this is an exploitable crash vector.

**powersupply.cpp — temperature calculation can produce a signed integer underflow stored in an unsigned type**

At line 160:
```cpp
m_temperature = (value - 2732) / 10;
```
`value` is `int`, `m_temperature` is `quint16`. If the gauge returns a raw temperature below 2732 (i.e., below 273.2 K, which is physically impossible but possible if the sensor faults or returns 0), `(value - 2732)` is negative, the division truncates toward zero to a negative `int`, and assigning that to a `quint16` wraps to a large positive number (e.g., -10 / 10 = -1, stored as 65535). This corrupted temperature is then emitted in the `batteryStatusRead` signal and may affect safety-critical charge logic or UI display.

**pwmbacklight.cpp — integer overflow in lux threshold macros for large lux values**

At lines 17–18:
```cpp
#define X1P1(v)     ((v) * 333 >> 8)
#define X1P2(v)     ((v) * 333 >> 8)
```
Both macros multiply `v` (an `int`) by 333 before shifting. For `v` = `m_currentLux` which is of type `int` and is populated from `ba.toInt()` on sensor data read from sysfs, the ALS sensor range is documented as up to 4000 lux. `4000 * 333 = 1,332,000` which fits in a 32-bit `int`. However, the sysfs read is uncapped: if the sensor or a faulty driver returns a value larger than approximately 6,442,450 (0x62B3_D2), the multiplication overflows a 32-bit signed integer, producing a negative or wrapped result. The macros are used in `parse()` (lines 139, 146) to make brightness change decisions; overflow would cause the thresholds to compare incorrectly, potentially causing the backlight to flicker rapidly or lock at an extreme brightness.

**pwmbacklight.cpp — `brightness()` return value truncation**

At line 188, `ba.toUInt()` returns an `uint` but the function return type is `quint8`. If the sysfs brightness file contains a value greater than 255, the implicit truncation silently discards the upper bits. This is a minor data integrity issue.

**pwmbeeper.cpp — `m_count` signed/unsigned mismatch with potential infinite loop**

`m_count` is declared `qint16` (h:36). `beep(qint16 count, ...)` accepts a signed count. In `timeout()` at line 53, the decrement `--m_count` followed by `if (--m_count > 0)` is correct for positive values, but callers passing `count = 0` or a negative value will cause the decrement to wrap around (`qint16` wraps from -32768 to 32767 on underflow) and the beeper will continue indefinitely since `m_count` will never reach 0 from a large positive value. The `beep(quint16 milliseconds)` overload at line 84–87 calls `beep(1, milliseconds, 0)` with `count = 1` (safe), but the three-argument overload `beep(qint16 count, ...)` is public and can be called with 0 or negative values from any caller.

**Finding:**

**A14-1** · HIGH · Memory Safety
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/platform/powersupply.cpp:143`
**Description:** `readGaugeStatus()` indexes `args[0]` through `args[6]` on the result of `ba.split(',')` without first checking that `args.size() >= 7`. A sysfs read returning fewer than seven comma-separated fields — due to a driver error, partial read, or filesystem fault — will cause an out-of-bounds access on `QByteArrayList`. In a Qt release build, `QList::operator[]` does not bounds-check, producing undefined behaviour. On this embedded target (no ASLR, no stack protector per `.pro` file), this is a crash or memory-corruption vector in safety-critical power management code.

**A14-2** · MEDIUM · Memory Safety
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/platform/powersupply.cpp:160`
**Description:** The temperature calculation `(value - 2732) / 10` produces a negative `int` when `value` is less than 2732 (any sensor fault or zero return). Assigning this negative `int` to `quint16 m_temperature` wraps to a large positive value (e.g., -1 becomes 65535). This corrupted temperature value is emitted in the `batteryStatusRead` signal and may propagate into charge control decisions or UI alerts.

**A14-3** · MEDIUM · Memory Safety
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/platform/pwmbacklight.cpp:17`
**Description:** The `X1P1` and `X1P2` macros multiply an unclamped `int lux` value by 333 before bit-shifting. The lux value originates from `ba.toInt()` on sysfs data with no upper-bound clamp applied. If the sensor or a buggy driver returns a value above approximately 6,442,450, the multiplication overflows a signed 32-bit integer, producing a negative or wrapped threshold. This causes the brightness change logic in `parse()` to behave incorrectly, with potential for rapid backlight oscillation or lockout.

**A14-4** · LOW · Memory Safety
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/platform/pwmbeeper.cpp:53`
**Description:** `m_count` is `qint16` and is decremented in `timeout()` without validating that it was initially positive. Calling the public `beep(qint16 count, quint16 msecOn, quint16 msecOff)` with `count <= 0` causes the decrement to wrap a value of 0 to 32767 (signed 16-bit underflow), creating a near-infinite beep sequence that cannot be stopped without calling `stop()` explicitly. This is a resource exhaustion / device annoyance issue rather than a safety-critical crash, but the signed type should be validated at entry.

---

### 2. Communication Security

No network or communication logic is present in these three file pairs. All hardware interaction is via local sysfs/devfs paths.

Communication Security: no issues found.

---

### 3. Input Handling

**pwmbeeper.cpp — device file path controlled by environment variable without sanitisation**

At lines 19–23:
```cpp
QByteArray event = qgetenv("QT_BUZZER_EVENT");
if (!event.isEmpty())
    m_file.setFileName(QString::fromUtf8(event));
else
    m_file.setFileName(QStringLiteral(FILE_BEEPER));
```
The beeper device file path is taken directly from the `QT_BUZZER_EVENT` environment variable with no validation or sanitisation. On an embedded Linux device, environment variables can be set by any process with the same UID as the application (or by a parent process). An attacker or misconfigured process that can set this variable could redirect the beeper writes to an arbitrary device file or path, including `/dev/sda`, `/proc/sysrq-trigger`, or other sensitive device nodes. This is a path injection issue at the hardware access layer.

**powersupply.cpp — `QProcess::execute` with fixed arguments (no injection)**

`reboot()` at line 205 and `poweroff()` at line 211 call `QProcess::execute("/etc/pvd/reboot")` and `QProcess::execute("/etc/pvd/reboot -p")` respectively. These use literal string arguments with no user-controlled or network-received data in the command string, so there is no command injection vector here. However, see the Qt-Specific section for notes on `QProcess::execute` blocking the event loop.

**Finding:**

**A14-5** · HIGH · Input Handling
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/platform/pwmbeeper.cpp:19`
**Description:** The hardware device path used for beeper writes is read directly from the `QT_BUZZER_EVENT` environment variable and converted to a `QString` without any sanitisation, path prefix validation, or allowlist check. Any process or attacker that can set this environment variable before application launch can redirect the binary `input_event` structure writes to an arbitrary device file or path, potentially targeting sensitive device nodes such as `/proc/sysrq-trigger` or raw block devices. The environment variable should be ignored in production builds, or validated against a strict allowlist of permitted device paths.

---

### 4. Build Security

The `mk3.pro` file was reviewed. It contains no `-fstack-protector-strong`, no `-D_FORTIFY_SOURCE=2`, no `-fPIE`/`-pie`, and no `-Wformat -Wformat-security` flags. No `QMAKE_CXXFLAGS` security hardening entries are present at all.

**A14-6** · HIGH · Build Security
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/mk3.pro:1`
**Description:** The project file defines no compiler security hardening flags. Missing entirely: `-fstack-protector-strong` (stack overflow detection), `-D_FORTIFY_SOURCE=2` (standard library buffer overflow detection), `-fPIE`/`-pie` (position-independent executable for ASLR support), and `-Wformat -Wformat-security` (format string vulnerability detection). On an embedded device with direct hardware access, safety-critical charging logic, and no apparent OS-level hardening, the absence of these flags means that memory safety bugs (such as A14-1 above) have no compile-time or runtime mitigation.

---

### 5. Device and Firmware

**powersupply.cpp — `QProcess::execute` blocks the event loop during reboot/poweroff sequence**

`PowerSupply::reboot()` (line 205) and `PowerSupply::poweroff()` (line 211) use `QProcess::execute()`, which is a blocking call. The reboot script comment (lines 187–202) notes the script "costs around a couple seconds" and includes a `sleep` loop of up to 30 seconds waiting for `/dev/ttyUSB0` to disappear. Blocking `QProcess::execute()` during this time freezes the Qt event loop entirely. For a safety-critical proximity detection device, freezing the event loop means no proximity alerts, no UI updates, and no signal processing for the duration of the script. This is a safety-critical availability concern.

**powersupply.cpp — charge control logic based on unclamped gauge data**

At lines 148–151:
```cpp
if (m_voltage < 4100 || m_remainingCapacity < 99)
    charge(true);
else if (m_voltage > 4300 || m_remainingCapacity == 100)
    charge(false);
```
The `m_voltage` and `m_remainingCapacity` values come directly from the sysfs `show_regs` file, parsed without range validation. As noted in A14-1, if fewer fields than expected are returned, `m_voltage` retains its previous value or default (0), which is less than 4100 mV — causing `charge(true)` to be called unconditionally. Additionally, `m_remainingCapacity` is `quint16` but semantically a percentage (0–100); no clamping to 100 is enforced. A driver returning a value above 100 would cause neither charge-enable nor charge-disable condition to trigger from the capacity side, relying entirely on the voltage threshold.

**A14-7** · HIGH · Device and Firmware
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/platform/powersupply.cpp:205`
**Description:** Both `reboot()` and `poweroff()` call `QProcess::execute()`, which blocks the calling thread until the spawned script exits. The script comment indicates an up-to-30-second wait loop. During this period the Qt event loop is completely frozen: no proximity alerts can be processed, no BLE or CAN events are handled, and no UI updates occur. For a vehicle proximity detection device this represents a safety-critical availability gap — the device appears operational but is unresponsive during a safety-relevant transition.

**A14-8** · MEDIUM · Device and Firmware
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/platform/powersupply.cpp:148`
**Description:** Battery charge control decisions at lines 148–151 use `m_voltage` and `m_remainingCapacity` values that are populated by parsing sysfs gauge data without range validation. If the sysfs read returns fewer fields than expected (see A14-1), `m_voltage` defaults to 0 mV, unconditionally triggering `charge(true)`. Additionally, `m_remainingCapacity` is typed as `quint16` with no clamping to the valid 0–100% range; values above 100 returned by a faulty driver bypass the capacity-based charge-disable condition.

---

### 6. Qt-Specific Security

**powersupply.cpp — `QProcess::execute` with a string containing a space (shell argument splitting)**

At line 211:
```cpp
QProcess::execute("/etc/pvd/reboot -p");
```
`QProcess::execute(const QString &)` with a single string argument performs shell-style argument splitting: it splits the string on whitespace and treats the first token as the program and subsequent tokens as arguments. This is Qt's documented behaviour for this overload. The `-p` argument is a literal string, so there is no injection risk here. However, this overload is deprecated in Qt 5 and its argument-splitting behaviour is a known source of bugs when paths contain spaces. This is a code quality note.

**powersupply.cpp — `QProcess` include present but only `QProcess::execute` (static) is used**

`<QProcess>` is included (cpp:3) and two `QProcess::execute` calls exist. No `QProcess` instance is created and no process output is read. No shell metacharacter injection risk from user/network data. No issue beyond A14-7.

**pwmbacklight.h — include guard mismatch**

`pwmbacklight.h` opens with:
```cpp
#ifndef PWMBACKLIGHT_H
#define BRIGHTNESS_H
```
The `#ifndef` guard checks `PWMBACKLIGHT_H` but the `#define` defines `BRIGHTNESS_H`. These do not match: if `pwmbacklight.h` is included twice (directly and transitively), the `#ifndef PWMBACKLIGHT_H` guard will pass on the second inclusion because `PWMBACKLIGHT_H` was never defined, but `BRIGHTNESS_H` will already be defined, so the `#define BRIGHTNESS_H` line will be silently skipped. The net result is that the entire header will be re-processed on the second inclusion, causing duplicate class definition errors at compile time. This is a build correctness defect.

**A14-9** · LOW · Qt-Specific Security
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/platform/pwmbacklight.h:1`
**Description:** The include guard is mismatched: `#ifndef PWMBACKLIGHT_H` (line 1) guards entry but the macro defined is `BRIGHTNESS_H` (line 2), not `PWMBACKLIGHT_H`. This means the guard does not protect against double-inclusion: a second `#include "pwmbacklight.h"` in the same translation unit will re-enter the header (since `PWMBACKLIGHT_H` was never defined), causing a duplicate class definition compile error. While this is currently masked because the header is likely included only once per translation unit, it is a latent defect that will fail silently under refactoring.

**A14-10** · INFO · Qt-Specific Security
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/platform/powersupply.cpp:211`
**Description:** `QProcess::execute("/etc/pvd/reboot -p")` uses the single-string overload of `QProcess::execute` which performs internal whitespace-based argument splitting. This overload is deprecated in Qt 5.15+ in favour of the `(program, arguments)` form. No injection risk exists with the current literal string, but the use of this deprecated overload should be noted for maintainability.

---

## Summary of Findings

| ID | Severity | Category | Location |
|----|----------|----------|----------|
| A14-1 | HIGH | Memory Safety | powersupply.cpp:143 |
| A14-2 | MEDIUM | Memory Safety | powersupply.cpp:160 |
| A14-3 | MEDIUM | Memory Safety | pwmbacklight.cpp:17 |
| A14-4 | LOW | Memory Safety | pwmbeeper.cpp:53 |
| A14-5 | HIGH | Input Handling | pwmbeeper.cpp:19 |
| A14-6 | HIGH | Build Security | mk3.pro:1 |
| A14-7 | HIGH | Device and Firmware | powersupply.cpp:205 |
| A14-8 | MEDIUM | Device and Firmware | powersupply.cpp:148 |
| A14-9 | LOW | Qt-Specific Security | pwmbacklight.h:1 |
| A14-10 | INFO | Qt-Specific Security | powersupply.cpp:211 |
