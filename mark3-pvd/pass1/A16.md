# Pass 1 Audit — A16
**Auditor:** A16
**Date:** 2026-02-28
**Branch:** master (verified)
**Repository:** mark3-pvd

---

## Step 4 — Reading Evidence

### File Pair 1: wiegandrfid.h / wiegandrfid.cpp

**File paths:**
- `/c/Projects/cig-audit/repos/mark3-pvd/platform/wiegandrfid.h`
- `/c/Projects/cig-audit/repos/mark3-pvd/platform/wiegandrfid.cpp`

**Class name and base classes:**
- `EM070::WiegandRfid` — inherits `QObject`

**Q_OBJECT macro location:**
- `wiegandrfid.h` line 12

**Every public method (signature and line number):**
- `explicit WiegandRfid(QObject *parent = 0)` — constructor, `.h` line 14 / `.cpp` line 11
- `void setEnabled(bool enable)` — `.h` line 15 / `.cpp` line 106
- `static quint64 wiegandData(quint8 facility, quint32 number)` — `.h` line 17 / `.cpp` line 111

**Signals:**
- `void cardData(quint64 wiegand, quint16 facility, quint32 number, QByteArray &readerOutput)` — `.h` line 20
- `void error(const QString &text)` — `.h` line 21

**Slots:**
- None declared explicitly; `activated()` is a private method connected via signal in constructor.

**Private methods:**
- `void activated()` — `.h` line 24 / `.cpp` line 24

**Member variables:**
- `QFile m_cardReadyFile` — `.h` line 26
- `QSocketNotifier *m_notifier` — `.h` line 27

**#include directives (wiegandrfid.h):**
- `<QFile>`

**#include directives (wiegandrfid.cpp):**
- `"wiegandrfid.h"`
- `<QSocketNotifier>`
- `<QDebug>`

**Wiegand protocol constants:**
- `FILE_CARD_READY` = `/sys/devices/platform/wiegand-gpio.0/card_ready` — `.cpp` line 5
- `FILE_CARD_DATA`  = `/sys/devices/platform/wiegand-gpio.0/card_data` — `.cpp` line 6
- `FILE_RAW_DATA`   = `/sys/devices/platform/wiegand-gpio.0/raw_data` — `.cpp` line 7
- 34-bit format handled at `.cpp` line 67 (bit strip: `~((quint64)1<<33)`, right-shift 1)
- 37-bit format commented out at `.cpp` lines 83–96 (strip bit 36, shift 1)
- 26-bit lower bound check at `.cpp` line 98 (`bits >= 26`)
- Wiegand-26 parity logic (12-bit even leading, 12-bit odd trailing) at `.cpp` lines 145–162
- Wiegand-42 format for `number > 65535` at `.cpp` lines 131–140

---

### File Pair 2: wifi.h / wifi.cpp

**File paths:**
- `/c/Projects/cig-audit/repos/mark3-pvd/platform/wifi.h`
- `/c/Projects/cig-audit/repos/mark3-pvd/platform/wifi.cpp`

**Class name and base classes:**
- `EM070::Wifi` — inherits `QObject`

**Q_OBJECT macro location:**
- `wifi.h` line 23

**Every public method (signature and line number):**
- `explicit Wifi(EM070::UserPort *userPort)` — `.h` line 26 / `.cpp` line 16
- `~Wifi()` — `.h` line 27 (inline empty)
- `void writeConf()` — `.h` line 29 / `.cpp` line 46
- `void restart()` — `.h` line 30 / `.cpp` line 82
- `bool status()` — `.h` line 32 (inline)
- `bool startPositioning()` — `.h` line 34 / `.cpp` line 191
- `void parseResponse(const QByteArray &ba)` — `.h` line 36 / `.cpp` line 211
- `QList<CIGCONF::AccessPoint> accessPoints()` — `.h` line 38 (inline)
- `void setCellularState(bool state)` — `.h` line 40 / `.cpp` line 146
- `void setPowerState(CIGCONF::PowerState state)` — `.h` line 42 / `.cpp` line 297

**Signals:**
- `void ethernetStateChanged(bool ready)` — `.h` line 46
- `void wifiReconnectionFailed()` — `.h` line 47
- `void wifiScanFinished(QList<CIGCONF::AccessPoint> list)` — `.h` line 48

**Private methods:**
- `void attemptReconnectToWifi()` — `.h` line 51 / `.cpp` line 153
- `void checkStatus()` — `.h` line 52 / `.cpp` line 96
- `void scanAccessPoints()` — `.h` line 53 / `.cpp` line 250
- `void scanFinished(int exitCode, QProcess::ExitStatus exitStatus)` — `.h` line 54 / `.cpp` line 266

**Member variables:**
- `EM070::UserPort *m_userPort` — `.h` line 56
- `QNetworkConfigurationManager *m_configurationManager` — `.h` line 58
- `bool m_status` — `.h` line 59
- `bool m_wifiStatus` — `.h` line 60
- `bool m_cellularStatus` — `.h` line 61
- `QTimer *m_posTimer` — `.h` line 63
- `QTimer *m_reconnectTimer` — `.h` line 64
- `QProcess *m_ps` — `.h` line 66
- `QList<CIGCONF::AccessPoint> m_accessPoints` — `.h` line 68
- `CIGCONF::PowerState m_powerState` — `.h` line 69

**#include directives (wifi.h):**
- `"../app/cigconfigs.h"`
- `<QObject>`
- `<QByteArray>`
- `<QList>` (twice)
- `<QProcess>`
- `<QNetworkConfigurationManager>`
- `<QTimer>`

**#include directives (wifi.cpp):**
- `"wifi.h"`
- `"seriallogger.h"`
- `"platform/userport.h"`
- `"../app/globalconfigs.h"`
- `<QDebug>`
- `<QSaveFile>`
- `<QNetworkConfiguration>`
- `<QTextStream>`

**WiFi configuration parameters (from wifi.cpp and cigconfigs.h):**
- `WIFI_CONF_FILE` = `/etc/wpa_supplicant.conf` — `cigconfigs.h` line 57
- `WIFI_MAX_NETWORKS` = 10 — `cigconfigs.h` line 56
- `SCAN_WATCHDOG` = 300000 ms — `wifi.cpp` line 13
- `RECONNECT_TIMEOUT` = 210000 ms — `wifi.cpp` line 14
- Password length validation: empty / < 8 / > 63 triggers `key_mgmt=NONE` — `wifi.cpp` lines 65–68
- Password in range [8,63] writes `psk=` in plaintext — `wifi.cpp` lines 70–74

**Related configuration file:**
- `netcfg.json` (listed in `mk3.qrc` and `mk3.pro` DISTFILES) contains `"ssid": "cigSecureConnect"` and `"password": "P@ssMK3!"`. It is embedded in the Qt resource bundle at compile time but is not read by wifi.cpp; no source code reference to `netcfg.json` was found in any `.cpp` or `.h` file. The file is committed to git history.

---

## Step 5 — Security Review

### 1. Memory Safety

**wiegandrfid.cpp — `bas.first()` / `bas.last()` called without empty-list guard:**
`activated()` reads a line from a kernel sysfs file, splits it on `,`, and immediately calls `bas.first()` (line 45) and `bas.last()` (line 46) without checking that the resulting list is non-empty. If the sysfs file returns a blank line or a line with no comma, `QByteArrayList::first()` and `last()` on an empty list are undefined behaviour in older Qt versions and cause an assertion failure / crash in debug builds. The same pattern repeats at lines 63–64. This is sourced from a kernel driver sysfs interface, so the data is not directly attacker-controlled, but a malfunctioning or emulated device could present malformed input.

**wiegandrfid.cpp — `quint16 facility` type truncation (line 45):**
`bas.first().toUInt()` returns an unsigned int (up to 32 bits). The result is stored in `quint16 facility`. If the card data value exceeds 65535, silent truncation occurs before being passed to `wiegandData()` whose parameter is `quint8`, producing a second truncation. Neither truncation is checked or flagged.

**wiegandrfid.cpp — `number` parameter narrowed from `quint32` to `quint8` in `wiegandData` call:**
`wiegandData(facility, number)` is declared as `wiegandData(quint8 facility, quint32 number)`. At line 45, `facility` is stored as `quint16` and then passed as a `quint8` parameter — a narrowing implicit conversion with no explicit check, silent data loss if facility > 255.

**No raw `new` without RAII issues identified** — `m_notifier` is parented to `this` (Qt ownership).

### 2. Communication Security

**wifi.cpp — WiFi plaintext credential storage in wpa_supplicant.conf:**
`writeConf()` (lines 46–80) writes the PSK for each configured network as a plaintext string (`psk="<password>"`) directly into `/etc/wpa_supplicant.conf`. The wpa_supplicant.conf format supports hashed PSK (a 256-bit hex string produced by `wpa_passphrase`). Writing the plaintext passphrase means the credential is readable by any process with filesystem access to `/etc/wpa_supplicant.conf`.

**wifi.cpp — Open network accepted without operator warning:**
`writeConf()` at lines 65–68 silently falls through to `key_mgmt=NONE` (no encryption, open network) whenever the configured password is empty, shorter than 8 characters, or longer than 63 characters. There is no log entry, no user warning, and no refusal to connect. A misconfigured or blank password causes the device to connect to an open network without any security. This is not a "graceful fallback" — it is a silent security downgrade.

**wifi.cpp — `netcfg.json` credentials committed to version control:**
The file `netcfg.json` at the repository root contains a plaintext WiFi SSID (`cigSecureConnect`) and password (`P@ssMK3!`). The file is tracked by git (committed in at least two historical commits) and is bundled into the Qt resource file (`mk3.qrc` line 29), meaning the credential is compiled into the firmware binary. Even if the credential represents a provisioning network that is rotated post-deployment, committing it to the repository exposes it to all repository collaborators and any CI/CD system with repo access.

**wifi.cpp — No TLS configuration present:**
The `Wifi` class uses `QNetworkConfigurationManager` for network state monitoring only. There is no `QNetworkAccessManager`, `QSslSocket`, or TLS setup visible in these files. TLS configuration for outbound connections is handled elsewhere in the codebase (e.g., `gmtpchat.cpp`). No `QSslSocket::setPeerVerifyMode(QSslSocket::VerifyNone)` was found in `wifi.cpp` or `wiegandrfid.cpp`.

### 3. Input Handling

**wifi.cpp — Unvalidated PID from filesystem used in shell kill command (line 165–167):**
In `attemptReconnectToWifi()`, the content of `/var/run/dhcp_wlan0_pid` is read with `readAll()`, trimmed, and inserted directly into a `kill` command string using `QString::arg()`:
```cpp
QString pid = dhcpPidFile.readAll().trimmed();
QProcess::startDetached(QString("kill -USR2 %1").arg(pid));
```
There is no validation that `pid` contains only digits. If the PID file contains a value such as `1; rm -rf /home` (possible if the PID file path is writable by an attacker or if a symlink attack is feasible), the shell would execute the injected command because `QProcess::startDetached` with a single string argument invokes the shell. However, the actual risk depends on filesystem permissions for `/var/run/dhcp_wlan0_pid` on the embedded Linux target.

**wifi.cpp — Shell meta-character injection in `scanAccessPoints()` (line 261):**
`m_ps->start("/bin/sh -c \"iw wlan0 scan | grep ...\"")` passes a shell command as a single string to `QProcess::start()`. The interface name `wlan0` is hardcoded so no injection is possible here, but using `/bin/sh -c` with a composite string is a pattern that is unsafe if any variable portion is ever introduced.

**wiegandrfid.cpp — Wiegand card data logged via qDebug without sanitisation (lines 42, 60, 74, 99):**
Raw card data (facility code and card number) is emitted to debug output. In a production build where `QT_NO_DEBUG_OUTPUT` is not defined, this exposes credential data (card numbers) via the debug channel. See Build Security section.

**wiegandrfid.cpp — Empty `bas` list not checked before `.first()` / `.last()` (lines 45–46, 63–64):**
See Memory Safety section. In the input handling context: if the kernel sysfs driver returns an unexpected format (no comma, empty string), the split produces a one-element list where `first()` and `last()` return the same element, leading to `facility == number`, which then fails the `if (facility && number)` gate at line 47. This is a silent misparse rather than a crash in the one-element case, but the zero-element case remains unsafe.

### 4. Build Security

**mk3.pro — No security compiler flags present:**
The `mk3.pro` file contains no `-fstack-protector-strong`, `-D_FORTIFY_SOURCE=2`, `-fPIE`/`-pie`, or `-Wformat -Wformat-security` flags. The `DEFINES` block contains only `TEST_MODE=0` and `QT_DEPRECATED_WARNINGS`. No `-w` suppression flag is present (positive finding). No `QMAKE_STRIP` or explicit `CONFIG += release` stripping configuration was found, meaning debug symbols may be present in production firmware builds.

**wiegandrfid.cpp — Sensitive data in qDebug output (lines 42, 60, 74, 99):**
Card facility codes and card numbers are printed via `qDebug()`. Unless `QT_NO_DEBUG_OUTPUT` is defined at compile time for production builds (which is not enforced in `mk3.pro`), these statements will execute in firmware and expose credential data via any accessible debug console or serial logger.

### 5. Device and Firmware

**netcfg.json — WiFi credentials committed to git and compiled into firmware:**
`netcfg.json` contains plaintext credentials (`"password": "P@ssMK3!"`, `"ssid": "cigSecureConnect"`) and is included in `mk3.qrc`, causing it to be compiled directly into the firmware binary as a Qt resource. The file is tracked in git history (commits `5fdc821`, `2adcd83`). Any party with repository access can extract the credential. Any party with access to the firmware binary can extract it using `strings` or Qt resource extraction tools. This is a provisioning or default network credential that should not be in version control or compiled into firmware.

**wiegandrfid.cpp — No authentication on Wiegand protocol:**
Wiegand is an unencrypted, unauthenticated protocol. Card UIDs (facility + number, or raw 26/34/37-bit data) are transmitted in cleartext on the wire and are trivially cloneable with commodity RFID hardware (e.g., Proxmark, HID cloners). The `cardData` signal produced by `WiegandRfid::activated()` flows directly to `Dialog::onCardSwiped()`, which calls `login(wiegand)`, and the Wiegand data value is the sole credential used to authenticate a driver or supervisor (`containsDriverId`, `containsMasterId`, `containsSuperId`). There is no secondary factor, no replay protection, and no challenge-response. Any Wiegand card cloner can impersonate any enrolled user.

### 6. Qt-Specific Security

**wifi.cpp — QProcess used with shell invocation for scan command (line 261):**
`m_ps->start("/bin/sh -c \"iw wlan0 scan | grep ...\"")` starts a shell subprocess. Using `QProcess::start()` with a single string causes Qt to invoke the system shell (`/bin/sh -c`) to parse the command. The safer pattern is `QProcess::start(program, QStringList args)` which avoids shell interpretation entirely. As currently written, any future modification that introduces variable input into this command string would create a shell injection vulnerability.

**wifi.cpp — QProcess::startDetached used with dynamically-constructed command strings (lines 90, 92, 166, 167):**
`QProcess::startDetached(QString(...).arg(pid))` and `QProcess::startDetached("killall -SIGHUP wpa_supplicant")` are called with single-string arguments, meaning they execute via the shell. The `pid` value at lines 166–167 is read from a file and not validated before insertion into the command string. See Input Handling finding above.

**wifi.cpp — No QSslSocket or QNetworkAccessManager TLS configuration in these files:**
`QSslSocket::setPeerVerifyMode(QSslSocket::VerifyNone)` is not present in `wifi.cpp` or `wiegandrfid.cpp`. No TLS disabling was observed in the assigned files.

---

## Findings

**A16-1** · CRITICAL · Device and Firmware
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/netcfg.json:2`
**Description:** The file `netcfg.json` contains a plaintext WiFi password (`P@ssMK3!`) and SSID (`cigSecureConnect`) committed to the git repository and compiled into the firmware binary via `mk3.qrc`. The credential appears in at least two git commits (`5fdc821`, `2adcd83`) and is permanently in repository history. Any person with repository read access or access to a firmware binary can extract the credential using `strings` or Qt resource tools. Provisioning credentials must not be committed to version control or baked into firmware; they should be injected at device provisioning time and stored in a protected location on the device.

**A16-2** · HIGH · Communication Security
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/platform/wifi.cpp:65`
**Description:** `writeConf()` silently writes `key_mgmt=NONE` (open/unencrypted network) to the wpa_supplicant configuration whenever the configured WiFi password is empty, shorter than 8 characters, or longer than 63 characters. There is no user-visible warning, no log entry via `SerialLogger`, and no refusal to configure the network. This means a device with a blank or short WiFi password will silently connect to an open network without encryption, exposing all WiFi traffic to passive interception. WPA2 or WPA3 should be enforced as a minimum, with a configuration rejection or explicit operator acknowledgment required for open-network connections.

**A16-3** · HIGH · Communication Security
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/platform/wifi.cpp:73`
**Description:** `writeConf()` writes WiFi passphrases as plaintext strings (`psk="<password>"`) in `/etc/wpa_supplicant.conf`. The wpa_supplicant configuration format supports a pre-computed 256-bit hex PSK (as produced by the `wpa_passphrase` tool), which avoids storing the cleartext passphrase on the filesystem. Writing plaintext credentials means they are readable by any process with access to the configuration file and are visible in any filesystem dump or backup.

**A16-4** · HIGH · Device and Firmware
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/platform/wiegandrfid.cpp:24`
**Description:** Wiegand is a legacy unencrypted, unauthenticated protocol. The raw card UID (facility code and card number, or a 26/34-bit value) transmitted over Wiegand is trivially cloneable with commodity RFID hardware. The `cardData` signal from `WiegandRfid::activated()` flows directly to `Dialog::login()` where the Wiegand value is the sole credential used to authenticate drivers and supervisors against the enrolled ID lists (`containsDriverId`, `containsMasterId`, `containsSuperId`). No secondary authentication factor, no replay protection, and no challenge-response mechanism is present. An attacker with a Wiegand cloner can read any enrolled card at close range and replay it to gain vehicle access or supervisor privileges.

**A16-5** · MEDIUM · Input Handling
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/platform/wifi.cpp:165`
**Description:** In `attemptReconnectToWifi()`, the content of `/var/run/dhcp_wlan0_pid` is read with `readAll().trimmed()` and inserted without validation into shell `kill` commands via `QProcess::startDetached(QString("kill -USR2 %1").arg(pid))`. No check is performed to verify that the content is a numeric PID. If the PID file is writable by a lower-privileged process or subject to a symlink attack, an attacker could inject arbitrary shell arguments. `QProcess::startDetached()` with a single string argument invokes the system shell, making injection possible. The PID value should be validated to contain only digits before use, and the `QProcess::startDetached(program, args)` overload should be used to avoid shell interpretation.

**A16-6** · MEDIUM · Memory Safety
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/platform/wiegandrfid.cpp:45`
**Description:** `activated()` splits the sysfs card data line on `,` (line 43) and immediately calls `bas.first()` (line 45) and `bas.last()` (line 46) without verifying the list is non-empty. The same pattern occurs at lines 63–64 for raw card data. If the kernel driver returns a blank line, an empty file, or a line containing no comma, `QByteArrayList::first()` / `last()` on an empty list is undefined behaviour. While the sysfs interface is kernel-controlled, a malfunctioning driver or emulated hardware could trigger this path. A guard checking `bas.size() >= 2` (or at minimum `!bas.isEmpty()`) is required before accessing list elements.

**A16-7** · MEDIUM · Input Handling
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/platform/wifi.cpp:261`
**Description:** `scanAccessPoints()` starts a WiFi scan by passing a single composite shell command string to `QProcess::start()`: `m_ps->start("/bin/sh -c \"iw wlan0 scan | grep ...\"")`. This invokes `/bin/sh` to interpret the command string. Although no variable input is currently interpolated into the command, this pattern is inherently unsafe: any future change that introduces a variable (e.g., a configurable interface name) would create a shell command injection vulnerability. The preferred pattern is `QProcess::start(program, QStringList{"-c", command})` which keeps the argument as a single shell string without further shell expansion, or better, use the argument-list overload of `QProcess::start` with a fixed program and arguments.

**A16-8** · MEDIUM · Build Security
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/mk3.pro:1`
**Description:** The project file contains no security-hardening compiler flags: `-fstack-protector-strong`, `-D_FORTIFY_SOURCE=2`, `-fPIE`/`-pie`, or `-Wformat -Wformat-security` are all absent. On an embedded Linux ARM target, the absence of stack canaries (`-fstack-protector-strong`) means stack buffer overflows will not be detected at runtime. The absence of `-D_FORTIFY_SOURCE=2` removes compile-time and runtime bounds checking for standard library buffer functions. These flags should be added to the `QMAKE_CXXFLAGS` and `QMAKE_LFLAGS` in `mk3.pro`.

**A16-9** · LOW · Build Security
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/platform/wiegandrfid.cpp:42`
**Description:** `activated()` emits raw card data (card number, facility code) via `qDebug()` at lines 42, 60, 74, and 99. The `mk3.pro` file does not define `QT_NO_DEBUG_OUTPUT` or enforce `CONFIG += release` to suppress debug output. In a production firmware build where debug output is not suppressed, card credential data is written to the debug channel, which may be accessible via the serial console (`seriallogger.cpp` is present in the build). Card numbers should not appear in production logs.

**A16-10** · LOW · Memory Safety
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/platform/wiegandrfid.cpp:45`
**Description:** `bas.first().toUInt()` returns an unsigned int, which is stored in `quint16 facility` (line 45), then passed to `wiegandData(quint8 facility, quint32 number)` where it is implicitly narrowed again to `quint8`. Facility codes above 255 are silently truncated without any check or log entry. Similarly, the `quint16 facility` variable at line 45 is declared to hold a facility value, but the signal `cardData` emits it as `quint16` (line 20), while `wiegandData` accepts only `quint8`. These silent truncations could cause enrolled card IDs to be mismatched in edge cases with high facility codes, potentially either denying access to valid cards or — depending on how IDs are compared — matching a different enrolled card.
