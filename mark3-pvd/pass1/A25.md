# Pass 1 Audit — A25
**Auditor:** A25
**Date:** 2026-02-28
**Branch:** master

---

## Reading Evidence

### `/c/Projects/cig-audit/repos/mark3-pvd/ui/warningdialog.h`
- **Class:** `WarningDialog` : `QDialog`
- **Q_OBJECT:** line 14
- **Includes:** `<QDialog>` (line 4)
- **Public methods:**
  - `explicit WarningDialog(WarningDialogType type, QWidget *parent = 0)` — line 17
  - `~WarningDialog()` — line 18
- **Private methods:**
  - `QString showVorWarning()` — line 24
  - `QString showTransportWarning()` — line 25
  - `QString showMaintenanceWarning()` — line 26
- **Protected methods (event overrides):**
  - `void hideEvent(QHideEvent *)` — line 29
  - `void showEvent(QShowEvent *event = 0)` — line 30
- **Member variables:**
  - `Ui::WarningDialog *ui` — line 21
  - `QTimer *m_timer` — line 22
  - `WarningDialogType m_type` — line 23
- **Signals:** none
- **Slots:** none (connections use lambdas/direct method pointers)
- **Enum (file scope):** `WarningDialogType {VOR, Transport, Maintenance}` — line 10

---

### `/c/Projects/cig-audit/repos/mark3-pvd/ui/warningdialog.cpp`
- **Includes:**
  - `"warningdialog.h"` — line 1
  - `"ui_warningdialog.h"` — line 2
  - `<QTimer>` — line 3
- **Constructor** (line 5): allocates `ui` and `m_timer`, connects `btnACK::clicked` to `accept`, connects `m_timer::timeout` to `reject`, sets timer single-shot.
- **showEvent** (line 18): dispatches to type-specific warning builder, sets HTML into `textEdit`, starts 45-second timer.
- **showTransportWarning / showVorWarning / showMaintenanceWarning** (lines 47, 84, 120): build static HTML strings from hardcoded translated text.
- **hideEvent** (line 156): stops the timer.
- **Destructor** (line 161): `delete ui`.

---

### `/c/Projects/cig-audit/repos/mark3-pvd/ui/warningdialog.ui`
- UI class: `WarningDialog` based on `QDialog`, 800x480
- Widgets: `QLabel labelWarning`, `QPushButton btnACK`, `QTextEdit textEdit`
- `textEdit` property `readOnly=true`, `textInteractionFlags=Qt::NoTextInteraction`
- No external connections, no dynamic content slots.

---

### `/c/Projects/cig-audit/repos/mark3-pvd/utils/barcode128.h`
- **Class `BarcodeChar`** (line 7): no base class
  - **Q_OBJECT:** absent
  - Public constructors: default (line 10), copy (line 17), parameterised `(int, QString, QString)` (line 24)
  - `BarcodeChar &operator=(const BarcodeChar &other)` — line 31
  - Private members: `int m_value`, `QString m_name`, `QString m_pattern`
  - `friend class Barcode128` — line 44
- **Class `Barcode128`** (line 47): no base class
  - **Q_OBJECT:** absent
  - **Includes:** `<QPixmap>` (line 4), `<QMap>` (line 5)
  - Public methods:
    - `Barcode128(const QString &info, int height = 100, int sizeMult = 2)` — line 50
    - `~Barcode128()` — line 51
    - `static int width(const QString &info, int sizeMult)` — line 52
    - `QPixmap pixmap()` — line 54
  - Private methods:
    - `void initChar(int value, const QString &name, const QString &pattern)` — line 57
    - `void initChars()` — line 58
    - `void encodeChar(const BarcodeChar &ch)` — line 59
    - `void drawBlackVerticalLineAtPos()` — line 60
    - `void drawEmptyVerticalLineAtPos()` — line 61
  - Member variables:
    - `QMap<int, BarcodeChar> m_valueToChar` — line 63
    - `QMap<QString, BarcodeChar> m_nameToChar` — line 64
    - `QImage *m_image` — line 66
    - `int m_pos` — line 67
    - `int m_sizeMult` — line 68
  - Macros: `START_CODE 104`, `END_CODE 106`, `MODULO_VAL 103`

---

### `/c/Projects/cig-audit/repos/mark3-pvd/utils/barcode128.cpp`
- **Includes:** `"barcode128.h"` (line 1), `<QImage>` (line 2), `<QDebug>` (line 3)
- Constructor (line 9): calls `width()` to size image, draws 15 leading quiet-zone columns, encodes START_CODE, iterates over every QChar in `info` encoding each, accumulates checksum, encodes checksum and STOP characters, draws 15 trailing quiet-zone columns.
- `width()` (line 320): returns `(info.length() * 11 + 13 + 11 + 11) * sizeMult + 30`

---

### `/c/Projects/cig-audit/repos/mark3-pvd/utils/bytearray.h`
- **Class `ByteArray`** (line 13): no base class, no Q_OBJECT
- **Includes:** `<QByteArray>` (line 4)
- **Macros:**
  - `LE_INT(c1,c2,c3,c4)` — line 6: `(c4) << 24 | (uchar)(c3) << 16 | (uchar)(c2) << 8 | (uchar)(c1)`
  - `BE_INT(c1,c2,c3,c4)` — line 7: `(c1) << 24 | (uchar)(c2) << 16 | (uchar)(c3) << 8 | (uchar)(c4)`
  - `LE_SHORT(c1,c2)` — line 8: `(c2) << 8 | (uchar)(c1)`
  - `BE_SHORT(c1,c2)` — line 9: `(c1) << 8 | (uchar)(c2)`
  - `BE_LONG(c1..c8)` — line 11: `((((quint64)BE_INT(c1,c2,c3,c4))<<32) | (quint32)BE_INT(c5,c6,c7,c8))`
- **Static methods:**
  - `static QByteArray asprintf(const char *cformat, ...)` — line 16
  - `static int sscanf(const QByteArray &ba, const char *cformat, ...)` — line 30
- **Member variables:** none (pure static utility class)

---

## Security Review

### 1. Memory Safety

**A25-1** · CRITICAL · Memory Safety
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/utils/bytearray.h:25`
**Description:** `ByteArray::asprintf` calls `va_end(ap)` at line 22 after the first `vsnprintf` call, then calls `vsprintf(ba.data(), cformat, ap)` at line 25 using the same `va_list` after it has already been ended. Accessing a `va_list` after `va_end` is undefined behaviour in C++. The second varargs call must use a separately initialised `va_list` (i.e. call `va_start` again, or use `va_copy`). Additionally, `vsprintf` is used for the second call instead of `vsnprintf`, meaning there is no bounds check on the write into `ba.data()` even though the buffer was sized to exactly the output of the first dry-run. Any mismatch (e.g. a format argument that changes between calls on certain platforms or if `size` calculation is off by one for the null terminator) will write one byte past the allocated buffer.

**A25-2** · HIGH · Memory Safety
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/utils/bytearray.h:6`
**Description:** In the `LE_INT` and `BE_INT` macros, the first argument (`c4` in `LE_INT`, `c1` in `BE_INT`) is shifted left by 24 bits without first being cast to an unsigned 32-bit type. If the argument is of type `int` or `char` and its value has bit 7 set, the shift produces a signed integer overflow, which is undefined behaviour in C++. Only the remaining arguments are cast to `uchar` before their shifts. The fix is to cast the first argument to `quint32` before the shift, consistent with how the other arguments are handled.

**A25-3** · HIGH · Memory Safety
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/utils/bytearray.h:11`
**Description:** In the `BE_LONG` macro, the high 32-bit word is cast to `quint64` before shifting left by 32, which is correct. However, the low 32-bit word is cast to `quint32` before being OR'd in: `(quint32)BE_INT(c5,c6,c7,c8)`. If `BE_INT` produces a negative `int` value, casting to `quint32` before OR'ing into a `quint64` will zero-extend correctly on most platforms, but the reliance on implementation-defined signed-to-unsigned conversion is fragile. More critically, if a caller passes the result of `BE_LONG` into a context expecting a signed type, the high bit silently produces a negative value. This is a latent data-integrity defect in binary protocol parsing.

**A25-4** · HIGH · Memory Safety
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/utils/barcode128.cpp:322`
**Description:** `Barcode128::width()` computes `(info.length() * 11 + 13 + 11 + 11) * sizeMult + 30`. `info.length()` returns `int`. For a string of approximately 195 million characters, `info.length() * 11` overflows a 32-bit signed integer. With `sizeMult = 2` the overflow threshold is approximately 97 million characters. There is no maximum-length check on `info` anywhere before this calculation or before the `new QImage(width(info, sizeMult), height, ...)` allocation. An attacker or misconfigured server supplying an oversized barcode string can trigger integer overflow leading to a very small (or negative) image allocation, followed by out-of-bounds pixel writes in the draw loop. On an embedded device with limited memory this can corrupt adjacent heap memory.

**A25-5** · MEDIUM · Memory Safety
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/utils/barcode128.cpp:28`
**Description:** The checksum accumulation `checksum += ch.m_value * (++i)` uses `int` arithmetic with no upper bound on the loop counter `i` or on `info.length()`. For a very long input string, `ch.m_value * i` (max character value 102, no length limit) will eventually overflow `int`. While the 45-second timer in the UI implies barcodes are generated from device-local data, the lack of any length guard is an input validation defect.

### 2. Communication Security

Communication Security: no issues found.

### 3. Input Handling

**A25-6** · HIGH · Input Handling
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/utils/bytearray.h:16`
**Description:** `ByteArray::asprintf` accepts a caller-supplied format string (`cformat`) which is passed directly to `vsnprintf` and `vsprintf`. Although the method is labelled "not recommended" in a comment, it is a public static method available throughout the codebase. If any call site passes a format string derived from network-received or configuration-file data rather than a string literal, this is a format-string vulnerability allowing arbitrary memory read and write. The method provides no mechanism to enforce that the format string is a literal.

**A25-7** · MEDIUM · Input Handling
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/utils/barcode128.cpp:26`
**Description:** When a character from `info` is not present in `m_nameToChar`, `QMap::operator[]` inserts and returns a default-constructed `BarcodeChar` with `m_value = -1` and `m_pattern = "1111111"`. The encoding loop silently encodes this invalid character without any error, warning, or rejection of the input. The invalid `m_value = -1` is then included in the checksum calculation. There is no validation that `info` contains only characters supported by the selected Code 128 variant (Code B, for `START_CODE == 104`), and no length limit is enforced before the barcode image is allocated.

### 4. Build Security

Build Security: no issues found in the files assigned to this auditor. (Build configuration files were not part of this assignment.)

### 5. Device and Firmware

**A25-8** · HIGH · Device and Firmware — Warning Dismissal Safety
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/ui/warningdialog.cpp:43`
**Description:** The warning dialog shown for safety-critical mode changes (VOR mode, Transport mode, Maintenance mode) is connected via `m_timer` to automatically call `reject()` after 45 seconds (`m_timer->start(45000)`). `reject()` dismisses the dialog with a rejected result, which in Qt's modal dialog model allows the parent application to continue. An operator who does not acknowledge the safety warning — whether by inattention, incapacitation, or deliberate bypass by simply waiting — will have the dialog dismissed automatically after 45 seconds. For a safety-critical warning on a vehicle proximity detection device, auto-dismissal without acknowledgement creates a hazard scenario: the device continues into the restricted operating mode (VOR, transport, maintenance) without the operator having read or acknowledged the warning. The `reject` path is also reachable programmatically if any other widget or event triggers rejection. The `accept` path (acknowledgement button) should be the only path to dismissal.

### 6. Qt-Specific Security

**A25-9** · MEDIUM · Qt-Specific Security
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/ui/warningdialog.h:30`
**Description:** `showEvent` is declared as `void showEvent(QShowEvent *event = 0)` with a default null pointer argument. The Qt virtual override `QWidget::showEvent(QShowEvent *)` does not have a default argument. Adding a default argument to a virtual override is legal C++ but creates a discrepancy: if the dialog is ever shown through a base-class pointer (`QWidget *w = dialog; w->show()`), the base-class virtual dispatch still calls the derived implementation correctly, but the default-argument annotation is misleading and can cause confusion. More concretely, the implementation immediately calls `Q_UNUSED(event)` and ignores the event pointer entirely, meaning the method never passes the event to `QDialog::showEvent()`. Failing to call the base class `showEvent` prevents Qt from performing its standard show-event handling (geometry restoration, activation, etc.), which can produce unexpected UI behaviour in some deployment scenarios.

---
