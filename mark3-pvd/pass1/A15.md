# A15 — Pass 1 Security Audit
**Files:** `platform/seriallogger.h`, `platform/seriallogger.cpp`, `platform/userport.h`, `platform/userport.cpp`
**Branch:** master
**Date:** 2026-02-28

---

## Reading Evidence

### File Pair 1: SerialLogger

**File paths:**
- `/c/Projects/cig-audit/repos/mark3-pvd/platform/seriallogger.h`
- `/c/Projects/cig-audit/repos/mark3-pvd/platform/seriallogger.cpp`

**Class name and base classes:**
- `SerialLogger` — no base class; plain C++ class (no QObject inheritance)

**Public methods (signature and line number):**
- `static void log(const QByteArray &message)` — seriallogger.h:9 / seriallogger.cpp:15
- `static void setSerialPort(EM070::UserPort *serial)` — seriallogger.h:10 / seriallogger.cpp:10

**Signals and slots:** None (class does not use Q_OBJECT)

**#include directives:**
- seriallogger.h:4 — `#include "userport.h"`
- seriallogger.cpp:1 — `#include "seriallogger.h"`
- seriallogger.cpp:2 — `#include <QDateTime>`
- seriallogger.cpp:3 — `#include <QFile>`

**Q_OBJECT macro:** Not present in either file.

**Log file paths and serial port paths defined:**
- `SERIAL_LOG_FILE` defined as `"/mnt/sd/sl.log"` at seriallogger.cpp:6
- `ENABLE_SL_FILE` defined as `0` at seriallogger.cpp:5 (file logging is compiled-in but disabled at runtime by preprocessor)

**Member variables:**
- `static EM070::UserPort *m_serial` — seriallogger.h:13 / seriallogger.cpp:8 (static, initialised to 0)

---

### File Pair 2: UserPort

**File paths:**
- `/c/Projects/cig-audit/repos/mark3-pvd/platform/userport.h`
- `/c/Projects/cig-audit/repos/mark3-pvd/platform/userport.cpp`

**Class name and base classes:**
- `EM070::UserPort` — inherits `QObject`

**Public methods (signature and line number):**
- `explicit UserPort(QObject *parent = nullptr)` — userport.h:15 / userport.cpp:15
- `void response(const QByteArray &ba)` — userport.h:16 / userport.cpp:78
- `void setBaudRate(QSerialPort::BaudRate baudRate)` — userport.h:18 / userport.cpp:88

**Signals:**
- `void cmdReceived(const QByteArray &ba)` — userport.h:21
  - Emitted from: userport.cpp:49 (TEST_MODE stdin path), userport.cpp:63 (serial port newline path)

**Slots:** None declared. `readData()` is a private method connected as a slot via `connect()` at userport.cpp:42.

**#include directives:**
- userport.h:4 — `#include <QObject>`
- userport.h:5 — `#include <QSerialPort>`
- userport.cpp:1 — `#include "userport.h"`
- userport.cpp:2 — `#include "app/globalconfigs.h"`
- userport.cpp:3 — `#include <QDebug>`
- userport.cpp:8 (TEST_MODE block) — `#include <QSocketNotifier>`
- userport.cpp:9 (TEST_MODE block) — `#include <iostream>`

**Q_OBJECT macro:** userport.h:13

**Log file paths and serial port paths defined:**
- `FILE_USER_PORT` defined as `"/dev/ttyS1"` at userport.cpp:5

**Member variables:**
- `QSerialPort *m_serialPort` — userport.h:26 (raw pointer, owned by QObject parent)
- `QByteArray m_receiver` — userport.h:27 (accumulation buffer for incoming serial data)

---

## Security Review

### 1. Memory Safety

**A15-1** · MEDIUM · Memory Safety
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/platform/userport.cpp:40`
**Description:** `m_receiver.reserve(256)` pre-allocates 256 bytes, but the buffer is grown unboundedly. In `readData()` (lines 58–75), every byte received that is not `\r`, `\n`, or `\b` is appended to `m_receiver` with `m_receiver += c` (line 73). There is no maximum size check before appending. A peer or attacker that sends a continuous stream of bytes without a newline terminator will cause `m_receiver` to grow without limit, consuming heap memory until the device crashes or the Qt allocator throws. On an embedded device with limited RAM this is a denial-of-service vulnerability. The `reserve(256)` call sets an initial capacity hint only; it does not enforce a cap on the `QByteArray` size.

**A15-2** · LOW · Memory Safety
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/platform/userport.cpp:10`
**Description:** `notifier` (TEST_MODE block, line 10) is declared as a raw file-scope pointer `QSocketNotifier *notifier` with no initialisation to `nullptr`. If `TEST_MODE` is compiled in and the `UserPort` constructor is called but `m_serialPort->open()` fails and returns early (line 34–37), the `notifier = new QSocketNotifier(...)` line (line 45) is never reached, leaving the pointer uninitialised. Any other TEST_MODE code that later reads `notifier` would access an indeterminate pointer. (The QObject parent mechanism would prevent the leak itself, but the uninitialised-pointer state is a latent hazard.)

### 2. Communication Security

**A15-3** · HIGH · Communication Security
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/platform/seriallogger.cpp:6` / `app/backgroundworker.cpp:2669` / `comm/modemchat.cpp:425,430`
**Description:** The serial logger writes sensitive device identifiers to the serial port (and optionally to a log file) unconditionally and permanently in production builds. Confirmed sensitive items logged by callers of `SerialLogger::log()` include:
- The device EUI (Extended Unique Identifier) at `backgroundworker.cpp:2669`: `"[RTC:INFO] Original EUI(Extended Unique Identifier) " + originalEuiAddress`
- The modem IMEI at `modemchat.cpp:425`: `"[MODEM:CGSN] IMEI=" + m_cgsn`
- The SIM ICCID at `modemchat.cpp:430`: `"[MODEM:ICCID] ICCID=" + m_iccid`

These are permanent device identifiers. Logging them to a user-accessible serial port exposes them to anyone with physical access to the RS-232 connector, and (if `ENABLE_SL_FILE` is ever enabled) persists them in plaintext on the SD card. IMEI and ICCID in particular are regulated identifiers that can facilitate SIM cloning or device tracking.

**A15-4** · MEDIUM · Communication Security
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/platform/seriallogger.cpp:18–29`
**Description:** The file logging path (`ENABLE_SL_FILE`) opens the log file at `/mnt/sd/sl.log` with `QFile::WriteOnly` and no rotation, size limit, or age limit. If this flag is enabled (it is currently `0` but is a compile-time switch that could be re-enabled for a field debug build), the log file will grow without bound for the lifetime of the device. On an embedded system with a fixed-size SD card, this is an unbounded disk consumption (DoS) vulnerability. Additionally, the file is opened with `WriteOnly` only — no explicit permission bits are set, meaning the file will be created with the process umask permissions, which may be world-readable.

**A15-5** · MEDIUM · Communication Security
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/platform/gnssreceiver.cpp:109,131`
**Description:** When `gCfg->GPSMsgLogEn()` returns true, raw GPGGA and GPRMC NMEA sentences are forwarded to `SerialLogger::log()` and consequently to the serial port. GPGGA contains latitude, longitude, altitude, fix quality, and satellite count. GPRMC contains latitude, longitude, speed, and course. This is a continuous stream of precise location data being output on a user-accessible port. The logging is gated by a configuration flag, but if that flag is set in a deployed configuration the device leaks real-time location to anyone monitoring the serial port.

### 3. Input Handling

**A15-6** · HIGH · Input Handling
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/platform/seriallogger.cpp:17`
**Description:** Log injection via newline characters in the `msg` argument. The `log()` function prepends a timestamp and passes the result directly to `m_serial->response(ba)` without sanitising the content of `msg`. All callers pass messages that are largely static strings or controlled numeric values, but several callers pass data originating from external sources — notably `modemchat.cpp:488` logs raw modem AT command response data (`ba`) from `[MODEM:CGDCONT?]`, and `bleexpansion.cpp:392–416` / `canexpansion.cpp:274–316` log device name, BLE version, firmware version, manufacturer, and model strings read from peripheral hardware. If any of these external strings contain `\r\n` sequences, they will inject spurious log lines that could confuse a human reading the serial log or a log parser, potentially causing misattribution of log entries (log forging). There is no stripping of embedded newlines from logged external data anywhere in the pipeline.

**A15-7** · LOW · Input Handling
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/platform/userport.cpp:18–20`
**Description:** The serial port device name is read from the environment variable `QT_USER_SERIAL_PORT` via `qgetenv()` and used directly to set the serial port name via `m_serialPort->setPortName(QString::fromUtf8(portName))`. No validation is performed on the value — it is not checked for path-traversal characters, excessive length, or valid device name format. On a desktop or test host this could be used to redirect the port to an arbitrary device path. On the production embedded target this is lower risk as environment variables are set by the system, but it is nonetheless unvalidated external input used to select a device resource.

### 4. Build Security

**A15-8** · MEDIUM · Build Security
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/mk3.pro`
**Description:** The `.pro` file defines no compiler security hardening flags. The following flags are absent:
- `-fstack-protector-strong` — no stack buffer overflow protection
- `-D_FORTIFY_SOURCE=2` — no standard library buffer overflow detection
- `-fPIE` / `-pie` — no position-independent executable (ASLR support)
- `-Wformat -Wformat-security` — no compile-time format string vulnerability detection

On an embedded ARM device running Linux, the absence of `-fstack-protector-strong` and `-D_FORTIFY_SOURCE=2` means that stack smashing and several classes of buffer overflows will not be caught at runtime. Given that this is a safety-critical proximity detection device, the lack of these mitigations is a meaningful risk.

**A15-9** · LOW · Build Security
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/platform/userport.cpp:7–11` and `/c/Projects/cig-audit/repos/mark3-pvd/mk3.pro:6`
**Description:** `TEST_MODE` is controlled by `DEFINES += "TEST_MODE=0"` in `mk3.pro`. When `TEST_MODE=1`, a `QSocketNotifier` on stdin is created that reads from standard input and emits `cmdReceived` — effectively a backdoor command interface via stdin. The `response()` function also calls `qDebug("%s", ba.constData())` in TEST_MODE. While TEST_MODE is currently set to 0 in the production `.pro` file, the mechanism exists in production source and would be enabled by a single `.pro` edit or a build override. There is no build-time guard to prevent accidental or deliberate TEST_MODE=1 production builds (e.g. no `static_assert` or `#error` in a release configuration).

### 5. Device and Firmware

**A15-10** · MEDIUM · Device and Firmware
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/platform/seriallogger.cpp:5–6`
**Description:** `ENABLE_SL_FILE` is a preprocessor `#define` set to `0`. This is a compile-time toggle, not a runtime configuration or a build-configuration flag passed via the `.pro` file's `DEFINES`. A developer can enable file-based logging of all serial log output (including IMEI, ICCID, EUI, GPS coordinates, modem state, proximity events) simply by changing this single line in the source file. Because the flag is in a `.cpp` file rather than governed by a build profile (e.g., `CONFIG(debug, debug|release)`), there is no structural barrier to accidentally shipping a firmware build with file logging enabled. The `/mnt/sd/sl.log` path on the SD card would then accumulate all sensitive log data in plaintext on removable media.

**A15-11** · INFO · Device and Firmware
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/platform/userport.cpp:5`
**Description:** The production serial port device path `/dev/ttyS1` is hardcoded via `FILE_USER_PORT`. This is consistent with a fixed embedded hardware platform, but it means that if the hardware UART assignment ever changes, a source code change and firmware rebuild is required. This is an observation rather than a finding, but it is noted for completeness.

### 6. Qt-Specific Security

**A15-12** · LOW · Qt-Specific Security
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/platform/userport.cpp:56`
**Description:** `m_serialPort->readAll()` is called in `readData()` with no size limit. `QSerialPort::readAll()` reads all available bytes in the OS receive buffer in a single call. On a serial port this is generally bounded by the OS buffer size, but combined with the unbounded `m_receiver` accumulation identified in A15-1, a connected device sending data faster than it is consumed could result in large allocations in both the OS buffer and `m_receiver`. This is a Qt-specific manifestation of the unbounded buffer issue.

**A15-13** · INFO · Qt-Specific Security
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/platform/userport.cpp:83–85`
**Description:** In TEST_MODE, `response()` calls `qDebug("%s", ba.constData())`. The format string is a literal `"%s"` — this is the correct safe form. No format string vulnerability is present here. Noted for completeness: if this were `qDebug(ba.constData())` it would be a format string vulnerability, but the literal format string is used correctly.
