# Pass 1 Security Audit — A26
**Repository:** mark3-pvd
**Branch:** master
**Auditor:** A26
**Date:** 2026-02-28

---

## Reading Evidence

### File: `/c/Projects/cig-audit/repos/mark3-pvd/utils/logger.h`

**Class:** `Logger` — no base class (not a QObject)

**Public methods:**
- `static Logger* instance()` — line 13
- `void close()` — line 14
- `void setLogThreshold(LogLevel level)` — line 15
- `LogLevel logThreshold() const` — line 16
- `void log(LogLevel level, const QString &message)` — line 17

**Protected methods:**
- `Logger()` — line 20 (constructor)
- `virtual ~Logger()` — line 21 (destructor)
- `static void logMessageHandler(QtMsgType type, const QMessageLogContext &context, const QString &msg)` — line 22

**Signals:** none
**Slots:** none

**#include directives:**
- `<QMutex>` — line 4
- `<QFile>` — line 5
- `<QTextStream>` — line 6

**Q_OBJECT macro:** not present

**Member variables (private):**
- `static Logger *m_instance` — line 25
- `static QMutex m_mutex` — line 26
- `QFile m_file` — line 28
- `QTextStream m_outStream` — line 29
- `LogLevel m_logThreshold` — line 30
- `QtMessageHandler m_oldHandler` — line 31

**Enum defined at file scope:**
- `LogLevel { LogDebug, LogInfo, LogWarning, LogCritical, LogFatal, LogNone }` — line 8

---

### File: `/c/Projects/cig-audit/repos/mark3-pvd/utils/logger.cpp`

**Class:** `Logger` (implementation of logger.h)

**#include directives:**
- `"logger.h"` — line 1
- `<QCoreApplication>` — line 3
- `<QMutexLocker>` — line 4
- `<QDateTime>` — line 5
- `<QDir>` — line 6

**Macro defined:**
- `#define LOG_FILE_DIR "/mnt/sd"` — line 8

**Static member initializations:**
- `Logger* Logger::m_instance = nullptr` — line 10
- `QMutex Logger::m_mutex` — line 11

**Method implementations:**
- `Logger::Logger()` constructor — lines 13–44
- `Logger::~Logger()` destructor — lines 46–52
- `Logger* Logger::instance()` (singleton, non-thread-safe) — lines 54–59
- `void Logger::close()` — lines 61–68
- `void Logger::setLogThreshold(LogLevel level)` — lines 70–73
- `LogLevel Logger::logThreshold() const` — lines 75–78
- `void Logger::log(LogLevel level, const QString &msg)` — lines 80–115
- `void Logger::logMessageHandler(QtMsgType type, const QMessageLogContext &context, const QString &msg)` — lines 117–147

**Key observations in constructor (lines 13–44):**
- Log file directory hardcoded to `/mnt/sd` (line 8)
- Log file name constructed as `"log" + yyyy.MM.dd + ".txt"` (lines 16–18)
- Log rotation: keeps 7 files, removes oldest when count >= 7 (lines 20–24)
- Platform guard: on ARM, writes to `/mnt/sd/log<date>.txt`; otherwise writes to `log.txt` (lines 29–33)
- File opened with `QIODevice::ReadWrite | QIODevice::Append` (line 35)
- Qt message handler installed via `qInstallMessageHandler` (line 43)

**Key observations in `log()` (lines 80–115):**
- Message received as `const QString &msg`
- Output assembled by QString concatenation only; no `printf`-style format string used
- Writes to `m_outStream` via `<<` operator (line 114)
- Protected by `QMutexLocker` (line 85)

---

### File: `/c/Projects/cig-audit/repos/mark3-pvd/utils/zconf.h`

**Purpose:** zlib configuration header
**#include directives (conditional):**
- `<stddef.h>` — line 254 (when STDC defined, for `size_t`)
- `<limits.h>` — line 420 (when !Z_SOLO && STDC, for `UINT_MAX`)
- `<sys/types.h>` — line 446 (when STDC && !Z_SOLO, for `off_t`)
- `<stdarg.h>` — line 452 (when STDC || Z_HAVE_STDARG_H && !Z_SOLO, for `va_list`)
- `<stddef.h>` — line 458 (when _WIN32 && !Z_SOLO, for `wchar_t`)
- `<unistd.h>` — line 484 (when Z_HAVE_UNISTD_H && !Z_SOLO, for `SEEK_*`, `off_t`)
- `<windows.h>` — line 354 (when ZLIB_WINAPI)

**No Q_OBJECT macro. No class definitions. No methods.**

**Key type definitions:**
- `Byte` = `unsigned char`
- `uInt` = `unsigned int`
- `uLong` = `unsigned long`
- `Bytef`, `charf`, `intf`, `uIntf`, `uLongf` — FAR-qualified variants
- `voidpc`, `voidpf`, `voidp`
- `z_crc_t` — `Z_U4` or `unsigned long`
- `z_size_t` — `size_t` or `unsigned long`
- `z_off_t` — `off_t` or `long`
- `z_off64_t` — `off64_t`, `__int64`, or `z_off_t`

---

### File: `/c/Projects/cig-audit/repos/mark3-pvd/utils/zlib.h`

**Purpose:** zlib compression library public API header

**zlib version defined:**
- `ZLIB_VERSION "1.3.1"` — line 40
- `ZLIB_VERNUM 0x1310` — line 41
- `ZLIB_VER_MAJOR 1`, `ZLIB_VER_MINOR 3`, `ZLIB_VER_REVISION 1`, `ZLIB_VER_SUBREVISION 0` — lines 42–45
- File header comment: "version 1.3.1, January 22nd, 2024" — line 2

**#include directives:**
- `"zconf.h"` — line 34

**Major API functions declared:**
- `zlibVersion(void)` — line 220
- `deflate(z_streamp strm, int flush)` — line 250
- `deflateEnd(z_streamp strm)` — line 363
- `inflate(z_streamp strm, int flush)` — line 401
- `inflateEnd(z_streamp strm)` — line 521
- `deflateSetDictionary(z_streamp strm, const Bytef *dictionary, uInt dictLength)` — line 611
- `deflateGetDictionary(z_streamp strm, Bytef *dictionary, uInt *dictLength)` — line 655
- `deflateCopy(z_streamp dest, z_streamp source)` — line 677
- `deflateReset(z_streamp strm)` — line 695
- (additional advanced functions continue beyond line 695: deflateParams, deflateTune, deflateBound, deflatePending, deflatePrime, deflateSetHeader, deflateInit2_, inflateSetDictionary, inflateGetDictionary, inflateSync, inflateSyncPoint, inflateReset, inflateReset2, inflatePrime, inflateMark, inflateGetHeader, inflateBack, inflateBackEnd, zlibCompileFlags, compress, compress2, compressBound, uncompress, uncompress2, gz* family, adler32*, crc32*, zError)

**Key structs:**
- `z_stream` / `z_stream_s` — lines 86–106
- `gz_header` / `gz_header_s` — lines 114–129

**No Q_OBJECT macro. No C++ class definitions.**

---

## Security Review

### 1. Memory Safety

**A26-1** · LOW · Memory Safety
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/utils/logger.cpp:54`
**Description:** The `instance()` singleton factory is not thread-safe. It performs a null check on `m_instance` and then assigns it without holding `m_mutex`. If two threads call `instance()` concurrently before initialization completes, both may evaluate `!m_instance` as true and construct two `Logger` objects, causing a double-construction race and a memory leak of one instance. In a Qt embedded application where threads may call `qDebug()` or `qWarning()` before the logger is fully initialized, this is a realistic race. The `QMutexLocker` guard is only applied inside `log()`, not in `instance()`.

No unsafe C string functions (`strcpy`, `strcat`, `sprintf`, `gets`) are present in logger.cpp or logger.h. No raw `new` without delete is present beyond the intentional singleton pattern (which does have a matching `delete` in `close()`). No `memcpy` or `memmove` calls. No buffer size calculations from external data.

---

### 2. Communication Security

No network communication, TLS configuration, certificate handling, hardcoded server addresses, API keys, or encryption keys appear in the four assigned files. zlib is a compression library; its presence does not itself represent a communication security issue.

Communication Security: no issues found in these four files.

---

### 3. Input Handling

**A26-2** · INFO · Input Handling
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/utils/logger.cpp:80`
**Description:** The `log()` method accepts the message as a `const QString &msg` and concatenates it via `output += msg` (line 113), then writes it to a `QTextStream` using the `<<` operator (line 114). This is safe — no `printf`-style format string is used, so there is no format string vulnerability. The Qt message handler (`logMessageHandler`) similarly passes the already-formatted `msg` string directly to `log()` without treating it as a format string. This is documented here as a positive finding: the implementation is safe with respect to format string injection.

No deserialization, no network input parsing, and no configuration file parsing are present in these four files.

---

### 4. Build Security

Build Security: no issues found in the assigned files. (The `.pro` file is not among the assigned files for this auditor; build flag coverage is assigned elsewhere.)

---

### 5. Device and Firmware

**A26-3** · MEDIUM · Device and Firmware
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/utils/logger.cpp:8`
**Description:** The log file directory is hardcoded as `/mnt/sd` via a compile-time `#define LOG_FILE_DIR "/mnt/sd"`. This is a mount point for what is presumed to be a removable SD card. If the SD card is absent, unmounted, or full, `m_file.open()` will fail silently (the constructor returns without error at line 36), and all subsequent calls to `log()` are silently discarded. There is no fallback logging destination (e.g. stderr, syslog, or internal flash), no alert to the application, and no error reported to the caller. On an embedded proximity-detection device where logs are the primary post-incident diagnostic tool, silent log loss is a safety concern.

**A26-4** · LOW · Device and Firmware
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/utils/logger.cpp:22`
**Description:** The log rotation logic at lines 22–24 removes the oldest log file only when the count reaches 7 and the newest file name differs from today's file name. The condition `logs.size() >= 7 && logs.last() != fileName` means that if the SD card fills up within a single day (i.e., `logs.last() == fileName`), no rotation occurs and the current log file continues to grow unboundedly until the filesystem is full. On an embedded device with a small SD card, a verbose logging run (e.g. during an extended event or fault condition) could exhaust available disk space within a single calendar day, causing the SD card to fill completely. This could affect other filesystem operations on the device.

**A26-5** · INFO · Device and Firmware
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/utils/logger.cpp:29`
**Description:** The platform guard `#ifdef __arm__` at lines 29–33 directs ARM builds to log to the SD card at `/mnt/sd/log<date>.txt` and non-ARM (development/CI) builds to log to `log.txt` in the current working directory. The development log path is relative, meaning it will be created in whatever the current working directory is when the process starts. On developer workstations this is benign, but if a non-ARM build were ever deployed to a device this could result in log files scattered in unexpected locations.

**A26-6** · INFO · Device and Firmware — zlib version
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/utils/zlib.h:40`
**Description:** The bundled zlib headers declare version 1.3.1 (released January 22, 2024). This is the most recent release of zlib as of the audit date. It is not subject to CVE-2022-37434 (fixed in 1.2.12) or CVE-2023-45853 (fixed in 1.3.1). No known CVEs apply to this version. Recorded for completeness.

---

### 6. Qt-Specific Security

**A26-7** · MEDIUM · Qt-Specific Security
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/utils/logger.cpp:35`
**Description:** The log file is opened with `QIODevice::ReadWrite | QIODevice::Append` (line 35). The `ReadWrite` flag grants both read and write access to the file descriptor. For a write-only append log, `QIODevice::WriteOnly | QIODevice::Append` would be sufficient and would follow the principle of least privilege. Using `ReadWrite` unnecessarily broadens the file access mode, which on a multi-process embedded Linux system could allow another thread or process sharing the file descriptor (e.g. via `fork`) to seek and read previously written log entries, including any sensitive operational data logged by higher-level application code.

**A26-8** · LOW · Qt-Specific Security
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/utils/logger.h:22`
**Description:** The `Logger` class does not use the `Q_OBJECT` macro and therefore is not a `QObject`. The `logMessageHandler` is a plain static function installed via `qInstallMessageHandler`. This is architecturally acceptable, but the class destructor restores the previous message handler (`qInstallMessageHandler(m_oldHandler)` at line 51 of logger.cpp). If `Logger::close()` is called from one thread while another thread is in the middle of dispatching a Qt message through the installed handler, there is a TOCTOU window where the handler pointer has been replaced but an in-flight call is still executing against the now-deleted `Logger` instance. This is a use-after-free risk in multi-threaded applications.
