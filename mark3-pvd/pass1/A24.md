# Pass 1 Audit — A24
**Auditor:** A24
**Date:** 2026-02-28
**Branch:** master (confirmed)
**Files reviewed:**
- `ui/unlockreasondialog.h` / `.cpp` / `.ui`
- `ui/vorconfirmationdialog.h` / `.cpp` / `.ui`
- `ui/vorwarningdialog.h` / `.cpp` / `.ui`

---

## Step 4 — Reading Evidence

### File Set 1: UnlockReasonDialog

**File paths:**
- `/c/Projects/cig-audit/repos/mark3-pvd/ui/unlockreasondialog.h`
- `/c/Projects/cig-audit/repos/mark3-pvd/ui/unlockreasondialog.cpp`
- `/c/Projects/cig-audit/repos/mark3-pvd/ui/unlockreasondialog.ui`

**Class:** `UnlockReasonDialog` extends `QDialog`

**Q_OBJECT:** `unlockreasondialog.h` line 13

**Public methods:**
- `explicit UnlockReasonDialog(QWidget *parent = 0)` — h:16, cpp:5
- `~UnlockReasonDialog()` — h:17, cpp:34
- `QString getReason()` — h:18, cpp:45
- `void languageChanged(void)` — h:19, cpp:50

**Signals:** none declared beyond inherited QDialog signals (accept/reject/finished)

**Slots:**
- `setReason()` (private) — cpp:39

**Includes:**
- h: `<QDialog>`, `<QString>`
- cpp: `"unlockreasondialog.h"`, `"ui_unlockreasondialog.h"`, `<QPushButton>`

**Member variables:**
- `Ui::UnlockReasonDialog *ui` (private)
- `QString m_reason` (private)

**UI widgets:**
- `QLabel lblHeaderText` — header label
- `QPushButton btnDone` — "BACK" button, triggers `reject()`
- `QGroupBox groupBox` — "Red Impact" group containing:
  - `QPushButton btnRedImpact_R1` through `btnRedImpact_R10` (10 preset reason buttons)
- `QGroupBox groupBox_2` — "Preop Checklist Timeout" group containing:
  - `QPushButton btnCheckLockout_R1`, `btnCheckLockout_R2`
- `QGroupBox groupBox_3` — "Preop Checklist Failed" group containing:
  - `QPushButton btnCheckTimeOut_R1`, `btnCheckTimeOut_R2`

**Behaviour:** All 14 reason buttons connect to `setReason()` which reads `sender()->text()` and stores it in `m_reason`, then emits `accept()`. No free-text entry widget is present in this dialog; free-text is handled by the parent `CommentDialog` (`ui/commentdialog.cpp`), where `pteMessageBox` (a `QPlainTextEdit`) is capped at `MAX_CHARACTER = 100` characters (defined in `ui/commentdialog.h:13`).

---

### File Set 2: VORConfirmationDialog

**File paths:**
- `/c/Projects/cig-audit/repos/mark3-pvd/ui/vorconfirmationdialog.h`
- `/c/Projects/cig-audit/repos/mark3-pvd/ui/vorconfirmationdialog.cpp`
- `/c/Projects/cig-audit/repos/mark3-pvd/ui/vorconfirmationdialog.ui`

**Class:** `VORConfirmationDialog` extends `QDialog`

**Q_OBJECT:** `vorconfirmationdialog.h` line 12

**Public methods:**
- `explicit VORConfirmationDialog(QWidget *parent = 0)` — h:15, cpp:6
- `~VORConfirmationDialog()` — h:16, cpp:30
- `void isBeingTurnOn(bool on)` — h:18, cpp:35

**Signals:** none (uses inherited `accepted`, `rejected`, `finished`)

**Slots (protected):**
- `void hideEvent(QHideEvent *)` — cpp:25
- `void showEvent(QShowEvent *event = 0)` — cpp:19

**Includes:**
- h: `<QDialog>`
- cpp: `"vorconfirmationdialog.h"`, `"ui_vorconfirmationdialog.h"`, `"../mytranslator.h"`, `<QTimer>`

**Member variables:**
- `Ui::VORConfirmationDialog *ui` (private)
- `QTimer *m_timer` (private)

**UI widgets:**
- `QLabel label`, `QLabel label_2` — background gradient labels
- `QPushButton btnCancel` — "CANCEL", triggers `reject()`
- `QPushButton btnTurnOn` — "TURN ON"/"TURN OFF", triggers `accept()`
- `QLabel lblNotif` — notification text
- `QLabel lblCornfirm` — confirmation question text (note: typo in widget name "Cornfirm")
- `QLabel lblOn` — "ON" or "OFF" label (displayed in red)

**Behaviour:** Dialog auto-rejects after 10 seconds via `m_timer` started in `showEvent`. `isBeingTurnOn(bool on)` configures labels: when `on=false` (VOR currently off, about to turn on), shows "turn ON"; when `on=true` (VOR currently on, about to turn off), shows "turn OFF". Language-dependent text differences for English vs other languages (English branch shows an incomplete sentence for the confirmation label — "Please confirm that you want to turn VOR mode" — missing "ON" or "OFF").

---

### File Set 3: VORWarningDialog

**File paths:**
- `/c/Projects/cig-audit/repos/mark3-pvd/ui/vorwarningdialog.h`
- `/c/Projects/cig-audit/repos/mark3-pvd/ui/vorwarningdialog.cpp`
- `/c/Projects/cig-audit/repos/mark3-pvd/ui/vorwarningdialog.ui`

**Class:** `VORWarningDialog` extends `QDialog`

**Q_OBJECT:** `vorwarningdialog.h` line 12

**Public methods:**
- `explicit VORWarningDialog(QWidget *parent = 0)` — h:15, cpp:5
- `~VORWarningDialog()` — h:16, cpp:66

**Signals:** none (uses inherited `accepted`, `rejected`)

**Slots (protected):**
- `void hideEvent(QHideEvent *)` — cpp:61
- `void showEvent(QShowEvent *event = 0)` — cpp:17

**Includes:**
- h: `<QDialog>`
- cpp: `"vorwarningdialog.h"`, `"ui_vorwarningdialog.h"`, `<QTimer>`

**Member variables:**
- `Ui::VORWarningDialog *ui` (private)
- `QTimer *m_timer` (private)

**UI widgets:**
- `QLabel labelWarning` — "WARNING" heading
- `QPushButton btnACK` — "ACKNOWLEDGE", triggers `accept()`
- `QTextEdit textEdit` — read-only rich-text area displaying the VOR warning text (`textInteractionFlags: Qt::NoTextInteraction`)

**Behaviour:** On `showEvent`, builds HTML string from translated text segments and sets it on the read-only `QTextEdit`. Timer fires after 30 seconds and calls `reject()`. If the user presses "ACKNOWLEDGE" (`accept()`), the caller in `dialog.cpp:183` calls `openMenuDialog()`, allowing VOR-mode access for masters and tech IDs. If the timer fires and the dialog is `reject()`ed, there is no further action connected in `dialog.cpp` — the dialog silently closes.

---

## Step 5 — Security Review

### 1. Memory Safety

The `setReason()` method in `UnlockReasonDialog` (cpp:41) uses a C-style cast:

```cpp
m_reason = ((QPushButton *)sender())->text();
```

`sender()` is cast from `QObject*` to `QPushButton*` using a C-style cast, bypassing Qt's safe `qobject_cast<>`. If the slot were ever connected to a non-`QPushButton` signal source, this is a type-unsafe access. In this code all connects are explicitly to `QPushButton::clicked`, so the runtime risk is low, but it is a code quality / future-maintenance risk.

No unsafe C string functions (`strcpy`, `sprintf`, `gets`) are used in the three dialog files themselves.

However, the unlock reason string is ultimately passed through `ByteArray::asprintf` (defined in `utils/bytearray.h`) at `backgroundworker.cpp:2346`. That function calls `va_end(ap)` on line 21 of `bytearray.h`, then uses the invalidated `ap` variable with `vsprintf` on line 25 — this is undefined behaviour per C and C++ standards. On most architectures this happens to work because `va_end` is a no-op, but it is formally undefined, and on some ABI implementations (e.g. ARM with AAPCS) it can corrupt state.

---

**A24-1** · HIGH · Memory Safety
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/utils/bytearray.h:21-25`
**Description:** `ByteArray::asprintf` calls `va_end(ap)` on line 21 then passes the now-invalidated `va_list ap` to `vsprintf` on line 25 without calling `va_start` or `va_copy` again. Reuse of a `va_list` after `va_end` is undefined behaviour per the C and C++ standards. This function is used to serialize the unlock reason string for network transmission (`backgroundworker.cpp:2346`) and VOR status messages (`backgroundworker.cpp:2389-2393`). On ARM embedded targets with certain ABIs this can produce garbled output or memory corruption. The fix is to call `va_copy` before `va_end` and use the copy in `vsprintf`, or restructure to avoid the double pass.

---

**A24-2** · LOW · Memory Safety
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/ui/unlockreasondialog.cpp:41`
**Description:** `setReason()` uses a C-style cast `((QPushButton *)sender())->text()` rather than `qobject_cast<QPushButton*>(sender())`. A C-style cast bypasses Qt's runtime type checking. Although all current signal connections in this file are from `QPushButton::clicked`, future maintenance connecting a non-`QPushButton` signal to this slot would silently produce a type-unsafe pointer dereference. `qobject_cast` would return `nullptr` and allow safe handling.

---

### 2. Communication Security

The unlock reason string (`m_reason` / `m_unlkMessage`) is transmitted to the server via the `GMTP_UNLK` message formatted in `backgroundworker.cpp:2340-2347`:

```cpp
ba = ByteArray::asprintf("UNLK=%llX,%X,%X,%llX,%X,%s,%X",
                         gCfg->unlockId(),
                         gCfg->timestamp(),
                         gCfg->maintCode(),
                         gCfg->maintDriverId(),
                         gCfg->maintTimestamp(),
                         gCfg->UnlkReasonString().toLatin1().data(),
                         gCfg->UnlkOption());
```

The VOR state is transmitted via `GMTP_CONVOR` (`backgroundworker.cpp:2388-2393`) triggered whenever `convorStatusChanged` fires (`backgroundworker.cpp:311`). The transmission protocol (GMTP) and whether TLS is used is outside the scope of the assigned files; those were reviewed by other auditors (noted in prior pass1 reports). No hardcoded keys, server addresses, or plaintext credential issues are introduced by the three dialog files themselves.

Communication Security: no issues found in the assigned dialog files. The `ByteArray::asprintf` UB noted above (A24-1) affects the integrity of transmitted UNLK and CONVOR messages.

---

### 3. Input Handling

**Unlock reason (free-text path):** The `UnlockReasonDialog` itself presents only fixed preset buttons — there is no free-text entry in this dialog. The companion `CommentDialog` (`ui/commentdialog.cpp`) wraps `UnlockReasonDialog` and provides a `QPlainTextEdit` (`pteMessageBox`). Character input is capped at `MAX_CHARACTER = 100` in `commentdialog.h:13` and enforced in `commentdialog.cpp:115`. The reason string from the preset buttons is injected into the same text box (`commentdialog.cpp:210`), so all values ultimately pass through `MAX_CHARACTER` enforcement via the on-screen keyboard path.

However, the preset button text is set in `languageChanged()` via `ui->btnRedImpact_R1->setText(tr("..."))`. The `tr()` call passes strings through Qt's translation system. If a translation file were loaded with adversarially long translations for these strings, the 100-character cap in `commentdialog.cpp:115` only applies when the user types character-by-character through the on-screen keyboard. When `onUnlkReasonSelected()` fires (`commentdialog.cpp:205-211`), it calls `insertText(selectedvalue)` without applying the 100-character limit. A translated button label longer than 100 characters would bypass the cap.

---

**A24-3** · MEDIUM · Input Handling
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/ui/commentdialog.cpp:205-211`
**Description:** When a preset unlock reason is selected via `UnlockReasonDialog`, `onUnlkReasonSelected()` directly calls `ui->pteMessageBox->textCursor().insertText(selectedvalue)` without checking the `MAX_CHARACTER` (100) limit that is enforced for on-screen keyboard input. If a translation file provides a button label longer than 100 characters, the reason string stored in `gCfg->setUnlkReasonString()` and subsequently transmitted in the `GMTP_UNLK` message can exceed the expected limit. This may cause truncation or misparse at the server if it applies a fixed-length field assumption, and interacts with the `%s` format specifier in `ByteArray::asprintf` at `backgroundworker.cpp:2346`.

---

**A24-4** · LOW · Input Handling
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/ui/vorconfirmationdialog.cpp:40-43` and `49-52`
**Description:** In `isBeingTurnOn()`, the English language branch (`!lang.compare(langEnglish, ...)`) sets `lblCornfirm` to the incomplete sentence "Please confirm that you want to turn VOR mode" — omitting "ON" or "OFF". This is a display logic defect: the English-language operator sees an ambiguous confirmation message ("turn VOR mode" with no direction stated), while the `lblOn` label shows "ON" or "OFF" separately. An operator may confirm the wrong action. Note: both branches (lines 40-43 and 49-52) produce the same incomplete sentence for English, making the "TURN ON" / "TURN OFF" distinction on `btnTurnOn` the only direction indicator visible to an English-speaking operator — this is a UI/safety concern for a vehicle tag-out operation.

---

### 4. Build Security

Build Security: no issues found in the assigned dialog files. Build flags are governed by the `.pro` file, outside this assignment's scope.

---

### 5. Device and Firmware

**VOR safety parameters:** VOR mode enables/disables vehicle access entirely. There are no VOR threshold calculations in the assigned files — VOR is a binary flag (`convorStatus()`). The threshold and timing parameters that control proximity detection are outside the scope of these dialog files. The VOR confirmation dialog enforces a 10-second auto-reject timeout (hardcoded at `vorconfirmationdialog.cpp:22`). The VOR warning dialog enforces a 30-second auto-reject timeout (hardcoded at `vorwarningdialog.cpp:57`).

---

**A24-5** · MEDIUM · Device and Firmware
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/ui/vorwarningdialog.cpp:13` and `57`
**Description:** The `VORWarningDialog` timer fires after 30 seconds and calls `reject()`. In `dialog.cpp:183`, only the `accepted` signal of `VORWarningDialog` is connected (`connect(m_vorwarningDialog, &VORWarningDialog::accepted, this, &Dialog::openMenuDialog)`). There is no handler for the `rejected` signal. When the 30-second timer elapses and the dialog is dismissed via `reject()`, the dialog closes silently and the waiting master/tech card presentation is abandoned with no further action. This means a VOR-mode vehicle can be accessed by a master/tech who presents their card but fails to press "ACKNOWLEDGE" within 30 seconds — the device returns to an idle locked state, which is safe. However, the absence of any timeout event handler means there is no audit record that the warning was displayed and auto-dismissed without acknowledgement. This gap in the audit trail may be a compliance concern for safety-regulated deployments.

---

**A24-6** · LOW · Device and Firmware
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/ui/vorconfirmationdialog.cpp:22`
**Description:** The VOR confirmation dialog auto-rejects after 10 seconds (hardcoded `m_timer->start(10000)`). This value is not configurable. While auto-reject (rather than auto-accept) is the safe default, the 10-second duration is hardcoded in firmware and cannot be adjusted without a firmware update. This is the safer of the two possible failure modes (auto-reject preserves the locked state), but the hardcoded nature of safety-relevant timing parameters is noted for completeness.

---

### 6. Qt-Specific Security

No `QProcess`, `QSettings`, `eval()`, or `QSslSocket` usage is present in any of the three dialog files. `QTimer` usage is standard and correct. Memory management follows the Qt parent-child ownership pattern (`new QTimer(this)`, `new Ui::...`), with explicit `delete ui` in all three destructors — consistent with Qt convention.

Qt-Specific Security: no issues found.

---

## Summary of Findings

| ID | Severity | Category | Location |
|---|---|---|---|
| A24-1 | HIGH | Memory Safety | `utils/bytearray.h:25` — `va_list` used after `va_end` (UB), affects UNLK and CONVOR message serialization |
| A24-2 | LOW | Memory Safety | `ui/unlockreasondialog.cpp:41` — C-style cast instead of `qobject_cast` |
| A24-3 | MEDIUM | Input Handling | `ui/commentdialog.cpp:210` — preset reason bypass of `MAX_CHARACTER` limit |
| A24-4 | LOW | Input Handling | `ui/vorconfirmationdialog.cpp:40-52` — ambiguous English confirmation label for VOR toggle direction |
| A24-5 | MEDIUM | Device and Firmware | `ui/vorwarningdialog.cpp:57` — timer auto-dismiss produces no audit trail entry |
| A24-6 | LOW | Device and Firmware | `ui/vorconfirmationdialog.cpp:22` — VOR confirmation timeout hardcoded, not configurable |
