# Pass 1 Security Audit — A08
**Auditor:** A08
**Date:** 2026-02-28
**Branch:** master
**Repo:** /c/Projects/cig-audit/repos/mark3-pvd

---

## Reading Evidence

### File Pair 1: canstatehandler

**File paths:**
- `/c/Projects/cig-audit/repos/mark3-pvd/comm/canstatehandler.h`
- `/c/Projects/cig-audit/repos/mark3-pvd/comm/canstatehandler.cpp`

**Class name and base classes:**
- `CanStateHandler : public QObject`

**Q_OBJECT macro location:**
- `canstatehandler.h` line 12

**Every public method with signature and line number:**
- `explicit CanStateHandler(CanMonitor *canMonitor)` — h:16 / cpp:14
- `void updateIdleTimer()` — h:17 / cpp:91
- `QByteArray canStates(DigitalFormat format, bool autoReset)` — h:18 / cpp:117
- `void resetStates(bool resetLast)` — h:19 / cpp:73

**Every signal:**
- `void idleTimeout()` — h:22

**Every slot (Qt connect targets, private methods connected via signal/slot):**
- `void updateState(quint8 index, quint32 state)` — cpp:24 (connected to `CanMonitor::stateUpdated`)
- `void resetStates(bool resetLast)` — cpp:73 (connected to `CanMonitor::resetCanStates`)

**Every #include directive:**
- `canstatehandler.h`: `"app/cigconfigs.h"`, `<QObject>`
- `canstatehandler.cpp`: `"canstatehandler.h"`, `"comm/canmonitor.h"`, `"app/globalconfigs.h"`, `"platform/seriallogger.h"`, `<QTimer>`, `<QDebug>`

**Every member variable:**
- `CanState m_canStates[CAN_MAX_ATT_IDX]` — h:47 (fixed array of 15 `CanState` structs)
- `CanMonitor *m_canMonitor` — h:49 (raw pointer, owned by parent QObject)
- `QTimer *m_timer` — h:50 (raw pointer, conditionally allocated/deleted)

**Nested struct CanState (private):**
- `quint32 state`
- `union { struct { quint32 sessionOnTime, sessionOffTime, usageOnTime, usageOffTime } time; struct { quint32 sessionRisings, sessionFallings, usageRisings, usageFallings } count; }`
- `quint64 clock`

---

### File Pair 2: ftpclient

**File paths:**
- `/c/Projects/cig-audit/repos/mark3-pvd/comm/ftpclient.h`
- `/c/Projects/cig-audit/repos/mark3-pvd/comm/ftpclient.cpp`

**Class name and base classes:**
- `FtpClient : public QObject`

**Q_OBJECT macro location:**
- `ftpclient.h` line 15

**Every public method with signature and line number:**
- `explicit FtpClient(BackgroundWorker *parent)` — h:17 / cpp:18
- `void download(const QUrl &url)` — h:18 / cpp:31
- `void startTransfer()` — h:19 / cpp:46
- `void writeQueue()` — h:21 / cpp:119
- `void readQueue()` — h:22 / cpp:144
- `void setPowerState(CIGCONF::PowerState state)` — h:24 / cpp:109

**Every signal:**
- `void fileUpdated(const QString &fileName)` — h:27
- `void sendGmtpMessage(CIGCONF::GmtpMessage msg, const QByteArray &extra)` — h:28
- `void nextTransfer()` — h:29 (also used as internal trigger; connected to `startTransfer()`)

**Private methods (slots via connect):**
- `void readData()` — cpp:173 (connected to `QNetworkReply::readyRead`)
- `void downloadFinished()` — cpp:197 (connected to `QNetworkReply::finished`)
- `void setReport(CIGCONF::FtpErrorCode errorCode)` — cpp:273
- `void popQueue()` — cpp:166

**Every #include directive:**
- `ftpclient.h`: `"app/cigconfigs.h"`, `<QObject>`, `<QUrl>`, `<QSaveFile>`, `<QQueue>`
- `ftpclient.cpp`: `"ftpclient.h"`, `"app/backgroundworker.h"`, `"app/globalconfigs.h"`, `"platform/seriallogger.h"`, `<QNetworkAccessManager>`, `<QNetworkReply>`, `<QFile>`, `<QFileInfo>`, `<unistd.h>` (ARM only)

**Preprocessor macros defined in ftpclient.cpp:**
- `MAX_FILE_SIZE (16 * 1024 * 1024)` — cpp:14
- `FTP_QUEUE_FILE "/home/ftpqueue.txt"` — cpp:15
- `FTP_RETRIES 5` — cpp:17

**Every member variable:**
- `BackgroundWorker *m_worker` — h:37 (raw pointer, parent)
- `QNetworkAccessManager *m_manager` — h:38 (raw pointer, parented to this)
- `QUrl m_url` — h:39
- `QSaveFile m_file` — h:40
- `quint32 m_fileSize` — h:41
- `bool m_transferInProgress` — h:43
- `QQueue<QUrl> m_queue` — h:45
- `quint32 m_retries` — h:46
- `bool m_queueFile` — h:47
- `CIGCONF::PowerState m_powerState` — h:48

---

## Security Review

### 1. Memory Safety

**A08-1** · HIGH · Memory Safety
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/utils/bytearray.h:25`
**Description:** `ByteArray::asprintf()` calls `vsnprintf` with a null buffer to compute the required size, then calls `vsprintf` (unbounded) to write into the allocated buffer. The second `va_list ap` is already exhausted after the first `vsnprintf` call — `va_end` is called on line 21 and `va_start` is never called again before the `vsprintf` on line 25. This is undefined behaviour: the second `vsprintf` uses a spent `va_list`. Depending on the platform ABI, the output may be truncated, the buffer may be overflowed, or the stack may be corrupted. This function is called in both `canstatehandler.cpp` and `ftpclient.cpp` for all formatted CAN state and FTP monitoring messages. The correct fix is to call `va_start`/`va_end` a second time around the `vsprintf` call, or to use `vsnprintf` with the known size.

**A08-2** · MEDIUM · Memory Safety
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/comm/canstatehandler.cpp:44`
**Description:** The time delta computation `quint32 delta = (clock - cs.clock) / 100` casts the result of a `quint64` subtraction to `quint32` without bounds checking. `clock` and `cs.clock` are both `quint64`. If `cs.clock` is uninitialised or zero (e.g. on first call before any reset, or if `DEPENDS_ON_TRIGGER` is defined and `cs.clock` has not been set), the subtraction yields a very large 64-bit value. Dividing by 100 and truncating to `quint32` silently discards the upper 32 bits. The resulting delta is then added to `sessionOnTime`/`sessionOffTime`/`usageOnTime`/`usageOffTime` without any overflow check, meaning the 32-bit accumulators can wrap to zero, corrupting usage time records — which are safety-relevant (operator working-time data).

**A08-3** · MEDIUM · Memory Safety
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/comm/canstatehandler.cpp:67`
**Description:** The idle timer is started with `m_timer->start(gCfg->idleTimeout() * 1000)`. `idleTimeout()` returns `quint16` (max 65535 seconds). Multiplying `quint16` by the integer literal `1000` is evaluated as a signed `int` multiplication on most platforms, giving a maximum value of approximately 65,535,000 ms (about 65 million). This fits within a 32-bit signed int, so no overflow occurs in the worst case; however the multiplication is implicitly widened, which is reliant on platform int width. The same pattern occurs at line 114. This is a low-severity concern but warrants an explicit cast to `quint32` before the multiplication.

**A08-4** · LOW · Memory Safety
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/comm/ftpclient.cpp:179`
**Description:** `m_fileSize` is assigned from `reply->header(QNetworkRequest::ContentLengthHeader).toUInt()`. The `Content-Length` header value arrives from the remote FTP server over an unauthenticated, plaintext channel (see A08-6). An attacker who can intercept or spoof the server response can set this header to zero, bypassing the `MAX_FILE_SIZE` guard on line 180 entirely. When `m_fileSize` is zero the check `m_file.size() == m_fileSize` at line 212 is evaluated as zero-equals-zero only if no data was written, but the comment on line 178 notes this is already known to be unreliable. The actual downloaded size is then bounded only by the per-read check at line 191, which is a secondary defence.

### 2. Communication Security

**A08-5** · CRITICAL · Communication Security
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/app/backgroundworker.cpp:576`
**Description:** The FTP URL scheme is hardcoded as `"ftp"` (`url.setScheme("ftp")`). The device downloads firmware updates (`FILE_FLEETMS_FW` = `/mnt/sd/FleetIQ360App`), driver ID lists, master ID lists, technician ID lists, checklist files, and login screen images over plain, unencrypted FTP. FTP transmits all data — including the FTP username and password (lines 579–580, received as plaintext from the GMTP server command) — in cleartext on the wire. Any attacker with network access can observe credentials, intercept and replace downloaded files (including firmware), and inject arbitrary content. FTPS or SFTP must be used instead.

**A08-6** · CRITICAL · Communication Security — Firmware Update via Plaintext FTP
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/comm/ftpclient.cpp:83`
**Description:** The file `FILE_FLEETMS_FW` (`/mnt/sd/FleetIQ360App`) is explicitly handled as a known file name in `startTransfer()` and is processed as a firmware update in `backgroundworker.cpp`'s `updateSelf()` function. This firmware is downloaded over plain FTP with no transport security. The only integrity check applied after download is a 16-bit CRC (`crc16`), which is neither cryptographically secure nor sufficient to prevent a malicious firmware image from passing validation. An attacker who can perform a man-in-the-middle attack on the FTP session can replace the firmware image with a tampered binary that passes the CRC check. There is no cryptographic signature verification. This constitutes a complete remote code execution vector on the physical device.

**A08-7** · HIGH · Communication Security
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/comm/ftpclient.cpp:70`
**Description:** The `SerialLogger::log` call on line 70 logs `"[FTP:START] Starting file transfer: " + fileName`. The `fileName` value is derived from the server-supplied URL path without sanitisation. Similarly, lines 71, 89, 96, 206, 208, 252, 256, 258, and 259 embed the file name or the full file path into GMTP monitoring messages using `ByteArray::asprintf` with a string-concatenation format rather than a `%s` placeholder. The resulting format string is constructed from partially server-controlled data. While `ByteArray::asprintf` takes a `const char *cformat`, the pattern `ByteArray::asprintf("FTPF_XFER_START," + fileName.toLatin1() + ",%d", m_retries)` concatenates a runtime string into the format argument position. If `fileName` contains `%` characters, those will be interpreted as format specifiers, constituting a format string vulnerability in the context of the underlying `vsnprintf`/`vsprintf` calls.

**A08-8** · HIGH · Communication Security
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/comm/ftpclient.cpp:15`
**Description:** The FTP queue persistence file is hardcoded to `/home/ftpqueue.txt`. This file stores FTP URLs including embedded credentials (username and password are part of the `QUrl` serialised with `url.toString()` on line 131). These credentials are written to the filesystem in plaintext. If the device's filesystem is accessible (e.g. via a physical interface or another process), the FTP credentials can be extracted from this file.

**A08-9** · MEDIUM · Communication Security
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/comm/ftpclient.cpp:131`
**Description:** `file.write(url.toString().toLatin1() + '\n')` serialises the full `QUrl` — including scheme, username, password, host, port, and path — to the queue file. Qt's `QUrl::toString()` includes the password in the output by default (`QUrl::FullyEncoded`). FTP credentials are therefore stored in plaintext on the device filesystem between power cycles.

### 3. Input Handling

**A08-10** · HIGH · Input Handling
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/comm/ftpclient.cpp:68`
**Description:** The `fileName` used to select the local destination file path is derived from `m_url.fileName()` (line 68), where the URL originates from a remote GMTP server command. The matching logic (lines 73–90) compares the URL file name against a whitelist of known file names. However, if none of the known file names match, the fallback on line 88 constructs the destination path as `"/mnt/sd/" + fileName`. If `fileName` contains path-traversal sequences (e.g. `../home/dlist.txt`), `QSaveFile::setFileName` will resolve the path outside `/mnt/sd/`. A server-controlled (or intercepted) GMTP command can therefore write arbitrary content to arbitrary locations in the device filesystem. `QFileInfo::fileName()` on the URL strips directory components in most cases, but this is not explicit sanitisation and should not be relied upon as a security control.

**A08-11** · MEDIUM · Input Handling
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/comm/ftpclient.cpp:144`
**Description:** `readQueue()` reads URLs from `/home/ftpqueue.txt` one line at a time with `file.readLine()`. There is no maximum line length enforced: `QFile::readLine()` without a `maxlen` argument will read until a newline or EOF, with no bound on how much memory it may allocate. A maliciously crafted or corrupted queue file with a very long line (no newline until EOF) will cause unbounded heap allocation. In an embedded environment with constrained RAM, this can cause an out-of-memory condition leading to device crash.

**A08-12** · MEDIUM · Input Handling
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/comm/ftpclient.cpp:148`
**Description:** The `readQueue()` loop uses `while (1)` and breaks only on an empty line. If the queue file is malformed and contains no empty lines and no EOF-triggered empty read, the loop condition depends entirely on `file.readLine()` returning an empty string at EOF, which it does — but the loop provides no explicit defence against a corrupted file with no terminating newline. More critically, there is no validation that the lines read are valid FTP URLs before they are enqueued. Malformed or malicious URL strings are silently enqueued as `QUrl` objects and later passed to `QNetworkAccessManager::get()`. Qt's `QNetworkAccessManager` will reject non-HTTP/FTP schemes, but no explicit scheme validation is performed before enqueue.

**A08-13** · LOW · Input Handling
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/comm/canstatehandler.cpp:26`
**Description:** The `updateState` slot validates the `index` parameter against `CAN_MAX_ATT_IDX` (value 15) with a bounds check on line 26. This is correct. However, the `state` parameter (a `quint32`) is accepted without any range validation. It is stored directly in `cs.state` and compared for equality to determine edge direction. For `CanAttributeTime` type, the truthiness of `state` controls which accumulator is incremented. No upper bound is enforced on the `state` value. If the CAN bus delivers unexpected state values this is handled correctly for the existing logic, but it is noted for completeness.

### 4. Build Security

**A08-14** · HIGH · Build Security
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/mk3.pro`
**Description:** The project file contains no compiler security hardening flags. There is no `-fstack-protector-strong`, no `-D_FORTIFY_SOURCE=2`, no `-fPIE`/`-pie`, and no `-Wformat -Wformat-security`. On an embedded Linux ARM device with these flags absent, buffer overflows and format string vulnerabilities (see A08-1, A08-7) have no compile-time or runtime detection. The only security-related define present is `QT_DEPRECATED_WARNINGS`.

**A08-15** · MEDIUM · Build Security
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/mk3.pro`
**Description:** The project file does not set `CONFIG += release` nor include `QMAKE_STRIP` directives. There is no evidence that debug symbols are stripped from the production build. Debug symbols in a deployed embedded firmware binary expose internal function names, data structure layouts, and source file paths to physical attackers who can read the firmware image.

**A08-16** · LOW · Build Security
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/comm/ftpclient.cpp:157`
**Description:** `qDebug() << "Could not remove " << file.fileName()` leaks the internal filesystem path of the queue file to any debug output channel that is active in the production build. The queue file path (`/home/ftpqueue.txt`) is also hardcoded in the macro. If debug output reaches a serial console or log aggregator accessible to untrusted parties, internal filesystem layout is disclosed.

### 5. Device and Firmware

**A08-17** · CRITICAL · Device and Firmware
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/comm/ftpclient.cpp:83` and `/c/Projects/cig-audit/repos/mark3-pvd/app/backgroundworker.cpp:244`
**Description:** Firmware updates are delivered via plain FTP (`FILE_FLEETMS_FW` = `/mnt/sd/FleetIQ360App`) and integrity is verified only by a 16-bit CRC stored in the first 8 bytes of the firmware image (`magic & 0xffff`, backgroundworker.cpp line 244). A 16-bit CRC provides 65536 possible values and can be trivially brute-forced or preimage-attacked. There is no cryptographic signature (RSA, ECDSA, or similar) on the firmware image, no secure hash (SHA-256 or equivalent), and no chain of trust. An attacker who intercepts the FTP transfer (trivial given the plaintext protocol) can produce a malicious firmware image that passes the CRC check. This allows persistent, undetected compromise of the device firmware.

**A08-18** · HIGH · Device and Firmware
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/app/cigconfigs.h:64–73`
**Description:** Multiple sensitive file paths are hardcoded as compile-time macros: `FILE_DRIVER_IDS` (`/home/dlist.txt`), `FILE_MASTER_IDS` (`/home/mlist.txt`), `FILE_TECH_IDS` (`/home/tlist.txt`), `FILE_CHECKLIST` (`/home/PREOP.TXT`), `FILE_CHECKLIST_100` (`/home/PREOP100.TXT`), `FILE_FLEETMS_FW` (`/mnt/sd/FleetIQ360App`), and `FILE_LOGIN_SCREEN` (`/home/login.png`). These paths are all downloaded via FTP and written directly to the live filesystem without intermediate staging in an isolated directory. An attacker with FTP-level access (which requires only intercepting a GMTP command) can overwrite driver ID lists and checklist files, directly affecting who is permitted to operate the vehicle and what safety checks are enforced.

**A08-19** · MEDIUM · Device and Firmware
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/app/backgroundworker.cpp:151`
**Description:** `qDebug() << "OTA Update"` is present in the firmware update path. If the debug build is used in production (no `CONFIG += release` is enforced — see A08-15), debug output includes internal state information about the update process. Additionally, the firmware update function reads the firmware magic value from the first 8 bytes of the downloaded file and uses it to validate size and derive the CRC. The validation relies on the magic value `0x43490000` — this constant is visible in source and constitutes partial disclosure of the firmware image format, lowering the barrier for crafting a malicious image.

### 6. Qt-Specific Security

**A08-20** · MEDIUM · Qt-Specific Security
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/comm/ftpclient.cpp:103`
**Description:** `QNetworkAccessManager::get(QNetworkRequest(m_url))` is used to initiate FTP downloads. No `QSslConfiguration` is set and no TLS/SSL is configured on the `QNetworkAccessManager`. Qt's `QNetworkAccessManager` supports the `ftp://` scheme but does not perform any TLS wrapping for it, confirming the plaintext FTP finding in A08-5. There is no call to `QNetworkRequest::setSslConfiguration` or any equivalent, and no peer certificate verification logic anywhere in the FTP client.

**A08-21** · LOW · Qt-Specific Security
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/comm/ftpclient.cpp:175`
**Description:** `readData()` and `downloadFinished()` retrieve the sender `QNetworkReply` via `qobject_cast<QNetworkReply *>(sender())`. If either slot is ever invoked directly (not via a signal) or connected to a non-`QNetworkReply` sender, `qobject_cast` returns null and the subsequent `reply->header(...)` or `reply->error()` dereference will crash the device. No null check is performed on the result of `qobject_cast` in either function.

---

## Summary Table

| ID | Severity | Category | Location |
|----|----------|----------|----------|
| A08-1 | HIGH | Memory Safety | `utils/bytearray.h:25` |
| A08-2 | MEDIUM | Memory Safety | `comm/canstatehandler.cpp:44` |
| A08-3 | MEDIUM | Memory Safety | `comm/canstatehandler.cpp:67` |
| A08-4 | LOW | Memory Safety | `comm/ftpclient.cpp:179` |
| A08-5 | CRITICAL | Communication Security | `app/backgroundworker.cpp:576` |
| A08-6 | CRITICAL | Communication Security | `comm/ftpclient.cpp:83` |
| A08-7 | HIGH | Communication Security | `comm/ftpclient.cpp:70` |
| A08-8 | HIGH | Communication Security | `comm/ftpclient.cpp:15` |
| A08-9 | MEDIUM | Communication Security | `comm/ftpclient.cpp:131` |
| A08-10 | HIGH | Input Handling | `comm/ftpclient.cpp:68` |
| A08-11 | MEDIUM | Input Handling | `comm/ftpclient.cpp:144` |
| A08-12 | MEDIUM | Input Handling | `comm/ftpclient.cpp:148` |
| A08-13 | LOW | Input Handling | `comm/canstatehandler.cpp:26` |
| A08-14 | HIGH | Build Security | `mk3.pro` |
| A08-15 | MEDIUM | Build Security | `mk3.pro` |
| A08-16 | LOW | Build Security | `comm/ftpclient.cpp:157` |
| A08-17 | CRITICAL | Device and Firmware | `comm/ftpclient.cpp:83` |
| A08-18 | HIGH | Device and Firmware | `app/cigconfigs.h:64` |
| A08-19 | MEDIUM | Device and Firmware | `app/backgroundworker.cpp:151` |
| A08-20 | MEDIUM | Qt-Specific Security | `comm/ftpclient.cpp:103` |
| A08-21 | LOW | Qt-Specific Security | `comm/ftpclient.cpp:175` |
