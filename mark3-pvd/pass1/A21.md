# Pass 1 — Auditor A21
**Date:** 2026-02-28
**Branch:** master
**Files reviewed:** ui/lockeddialog.h, ui/lockeddialog.cpp, ui/lockeddialog.ui, ui/messagedialog.h, ui/messagedialog.cpp, ui/messagedialog.ui, ui/onScreenKeyboard.h, ui/onScreenKeyboard.cpp, ui/onScreenKeyboard.ui

---

## Step 4 — Reading Evidence

### File Set 1: lockeddialog

**File paths:**
- `/c/Projects/cig-audit/repos/mark3-pvd/ui/lockeddialog.h`
- `/c/Projects/cig-audit/repos/mark3-pvd/ui/lockeddialog.cpp`
- `/c/Projects/cig-audit/repos/mark3-pvd/ui/lockeddialog.ui`

**Class name and base classes:**
- `LockedDialog : public QDialog`

**Q_OBJECT macro location:**
- `lockeddialog.h:15`

**#include directives:**
- `lockeddialog.h`: `app/globalconfigs.h`, `app/cigconfigs.h`, `<QDialog>`, `<QTimer>`
- `lockeddialog.cpp`: `lockeddialog.h`, `ui_lockeddialog.h`, `platform/pwmbeeper.h`, `platform/seriallogger.h`

**Public methods (with line numbers):**
- `explicit LockedDialog(QWidget *parent = 0)` — h:18
- `~LockedDialog()` — h:19
- `void setLockedReason(CIGCONF::MaintLockedCode lockedCode)` — h:20
- `void languageChanged(void)` — h:21
- `void setTimeRemaining(quint32 secs)` — h:22
- `void clearTimerText()` — h:23
- `void stopTimer()` — h:24
- `void startTimer()` — h:25

**Signals:**
- `void fullLockoutTimerEnded(bool on1, bool on2)` — h:32
- `void beeperOn()` — h:33

**Protected method:**
- `void mouseReleaseEvent(QMouseEvent *) {accept();}` — h:36

**Private methods:**
- `void updateFullLock()` — h:40
- `void fullLockStart()` — h:41

**Member variables:**
- `Ui::LockedDialog *ui` — h:39
- `QTimer *m_fullLockTimer` — h:43
- `quint32 m_timeCntr` — h:44

**UNIT_TEST friend:**
- `friend class TestDialog` — h:28 (conditional on UNIT_TEST)

**UI widgets (lockeddialog.ui):**
- `QDialog` named `LockedDialog` — 800x480
- `QLabel` named `labelReason` — displays locked reason text
- `QLabel` named `label_3` — displays "Machine locked"
- `QLabel` named `label` — displays `not-allowed.png` icon
- `QLabel` named `lblLockOutTime` — displays countdown timer text

---

### File Set 2: messagedialog

**File paths:**
- `/c/Projects/cig-audit/repos/mark3-pvd/ui/messagedialog.h`
- `/c/Projects/cig-audit/repos/mark3-pvd/ui/messagedialog.cpp`
- `/c/Projects/cig-audit/repos/mark3-pvd/ui/messagedialog.ui`

**Class name and base classes:**
- `MessageDialog : public QDialog`

**Q_OBJECT macro location:**
- `messagedialog.h:15`

**#include directives:**
- `messagedialog.h`: `<QDialog>`
- `messagedialog.cpp`: `messagedialog.h`, `ui_messagedialog.h`, `<QMovie>`, `<QTimer>`, `<QDebug>`

**Public methods (with line numbers):**
- `explicit MessageDialog(QWidget *parent = 0)` — h:29
- `~MessageDialog()` — h:30
- `void openWithMessage(MessageType type)` — h:31 (inline: calls `setMessageType(type); open()`)
- `void setMessageType(MessageType type)` — h:33 / cpp:42
- `MessageType messageType() const` — h:34 (inline getter)

**Enum `MessageType`:**
- `NoMessage`, `ExpansionConnecting`, `WaitForAuthorised`, `NotAuthorised`, `OnDemandNotAuthorised`, `PowerOff`, `Reboot`, `VehicleOutOfService` — h:18–27

**Protected method:**
- `void hideEvent(QHideEvent *)` — h:37 / cpp:35

**Member variables:**
- `Ui::MessageDialog *ui` — h:40
- `QTimer *m_timer` — h:42
- `QMovie *m_movie` — h:43
- `MessageType m_messageType` — h:44

**Timing constants (messagedialog.cpp):**
- `WAIT_AUTH_TIME 10000` (10 s) — cpp:7
- `NOT_AUTH_TIME 5000` (5 s) — cpp:8

**UI widgets (messagedialog.ui):**
- `QDialog` named `MessageDialog` — 800x480
- `QLabel` named `labelMsg` — message text display
- `QLabel` named `labelMovie` — animated GIF / pixmap display
- `QPushButton` named `btn` — Cancel button
- `QLabel` named `labelUpper` — upper background area
- `QLabel` named `labelLower` — lower background area

---

### File Set 3: onScreenKeyboard

**File paths:**
- `/c/Projects/cig-audit/repos/mark3-pvd/ui/onScreenKeyboard.h`
- `/c/Projects/cig-audit/repos/mark3-pvd/ui/onScreenKeyboard.cpp`
- `/c/Projects/cig-audit/repos/mark3-pvd/ui/onScreenKeyboard.ui`

**Class name and base classes:**
- `onScreenKeyboard : public QWidget`

**Q_OBJECT macro location:**
- `onScreenKeyboard.h:13`

**#include directives:**
- `onScreenKeyboard.h`: `<QWidget>`, `<QtGui>`, `<QPushButton>`
- `onScreenKeyboard.cpp`: `onScreenKeyboard.h`, `ui_onScreenKeyboard.h`, `<QtGui>`

**Public methods (with line numbers):**
- `explicit onScreenKeyboard(QWidget *parent = 0)` — h:20
- `~onScreenKeyboard()` — cpp:102
- `void setInitialText(QString str)` — h:24 / cpp:56
- `void languageChanged(void)` — h:25 / cpp:248
- `QPushButton *enterButton` — h:22 (public member, not method)

**Enums:**
- `KeyToggleState { Normal, Upper, Lower }` — h:17
- `CaseButton { AllButtons, CapsButton, ShiftButton, SymbolButton }` — h:18
- `CtrlButton { None, Backspace, Delete }` — h:19

**Signals:**
- `void updateText(QString str, CtrlButton ctrl)` — h:36
- `void onScreenKeyboardClose()` — h:37

**Private slots:**
- `void keyboardHandler()` — h:28 / cpp:61
- `void on_btnShift_clicked(bool checked)` — h:29 / cpp:113
- `void on_btnEnter_clicked()` — h:30 / cpp:184
- `void on_btnBack_clicked()` — h:31 / cpp:192
- `void on_btnCaps_toggled(bool checked)` — h:32 / cpp:197
- `void on_btnHideKeyboard_clicked()` — h:33 / cpp:202
- `void on_btnDelete_clicked()` — h:34 / cpp:243

**Protected method:**
- `void closeEvent(QCloseEvent *event)` — h:40 / cpp:107

**Private methods:**
- `void toggle()` — h:43 / cpp:145
- `QString dualCharCase(QString ch, int toggleState)` — h:44 / cpp:127
- `QString singleCharCase(QString ch, int toggleState)` — h:45 / cpp:119
- `void setCaseButton(CaseButton btn, bool set)` — h:46 / cpp:209

**Member variables:**
- `Ui::onScreenKeyboard *ui` — h:47
- `QString outputText` — h:48
- `QString m_capsStylesheet` — h:49
- `QString m_symbolStylesheet` — h:50
- `QString m_shiftStylesheet` — h:51

**UI widgets (onScreenKeyboard.ui):**
- `QWidget` named `onScreenKeyboard` — 800x310, NonModal, windowOpacity=50.0
- Full QWERTY layout: `QPushButton` named `Button{a-z}`, `Button{0-9}`, `space`
- Control buttons: `btnShift` (checkable), `btnCaps` (checkable), `btnBack`, `btnDelete`, `btnEnter`, `btnHideKeyboard`

---

## Step 5 — Security Review

### 1. Memory Safety

**A21-1 · HIGH · Memory Safety**
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/ui/lockeddialog.cpp:87`
**Description:** `m_timeCntr` is declared as `quint32` (unsigned 32-bit). In `updateFullLock()`, the condition is `if (!m_timeCntr--)`. When `m_timeCntr` is 0 at the start of a tick, the post-decrement wraps to `0xFFFFFFFF` (4,294,967,295) before the zero-check fires, and the branch is taken correctly. However, if `fullLockoutTimeout()` returns 0, `m_timeCntr` is initialised to 0 and the very first tick immediately wraps, causing the timer to fire `fullLockoutTimerEnded(false, false)` (relay cut-off) immediately. The comment at cpp:86 acknowledges this: "This will immediately close both relays if Timeout Parameter is zero." The issue is that this is a safety-critical control path: a zero value from a server-supplied configuration causes immediate shutdown of both relays. There is no guard at the call site in `startTimer()` (cpp:26) to prevent starting the full-lockout countdown when the server supplies 0 — the condition `gCfg->fullLockoutEnable() && !m_fullLockTimer->isActive()` does not exclude a zero timeout. If the lock-enable flag is set but timeout is zero, entering the locked state immediately triggers relay cut-off on the next 1-second tick, regardless of operator presence. This is a safety-critical integer edge-case that conflates "no countdown" with "instant shutdown."

**A21-2 · LOW · Memory Safety**
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/ui/onScreenKeyboard.cpp:63`
**Description:** In `keyboardHandler()`, the sender is obtained via `QPushButton *button = (QPushButton *)sender()` using a C-style cast rather than `qobject_cast<QPushButton *>`. If a non-QPushButton object were ever connected to this slot (e.g. through accidental re-use), the unchecked cast would produce a dangling pointer dereference on the subsequent `button->text()` call at cpp:65. The risk is low in this codebase since all connections are explicitly to button widgets, but the pattern is unsafe.

### 2. Communication Security

Communication Security: no issues found within the three assigned files. All message content set in `MessageDialog::setMessageType()` is composed exclusively from `tr()` string literals embedded in the firmware — no content is received from the network and rendered into the dialog. The lock state itself is propagated via `gCfg->maintCode()` and `screenLocked()` signals; the actual server-synchronisation logic is outside the scope of the assigned files.

### 3. Input Handling

**A21-3 · HIGH · Input Handling**
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/ui/onScreenKeyboard.cpp:66`
**Description:** In `keyboardHandler()`, button text is read directly from the widget with `button->text()`, then that raw text is emitted via the `updateText` signal. If the text property of a button is ever sourced from a translated string that resolves to multi-character sequences (or later from a network-supplied language resource), there is no maximum-length validation before the output is assembled. More concretely, the condition at cpp:76 — `else if (inputText == "\\") { outputText = ui->Buttonr->text(); }` — reads the label from `Buttonr` (the letter key) and assigns it as the keyboard output for the backslash character. If the case state of `Buttonr` were ever unexpected, this would silently emit the wrong character. While the immediate impact is a functional bug rather than a direct security vulnerability, the pattern of reading output from widget state rather than a canonical data structure means the output is implicitly trusted to match expectations with no assertion or validation.

**A21-4 · MEDIUM · Input Handling**
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/ui/onScreenKeyboard.cpp:186`
**Description:** The `on_btnEnter_clicked()` handler clears `outputText` to an empty string (`outputText=""`) before closing the keyboard. However, `outputText` is a persistent `QString` member variable. Qt's `QString` does not guarantee that internal buffer memory is zeroed on assignment of an empty string — the previous character data may remain in heap memory. For a general text-input keyboard this is low risk, but `onScreenKeyboard` is used via `CommentDialog` for entry of free-text notes. If an operator has previously typed a sensitive comment (e.g., an unlock reason or incident note), the characters remain recoverable from process memory after the keyboard is dismissed. A secure wipe (e.g., `outputText.fill(QChar(0)); outputText.clear()`) should be applied before closing. The same concern applies to the `QString` local variable `inputText` at cpp:65, which holds individual keystrokes and is left for GC without zeroing.

**A21-5 · MEDIUM · Input Handling**
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/ui/onScreenKeyboard.cpp:66`
**Description:** `keyboardHandler()` calls `QString::split()` with the deprecated overload `QString::SkipEmptyParts` (the non-namespaced form deprecated since Qt 5.14). While not a direct security issue, use of deprecated API indicates code that has not been maintained against current Qt security recommendations and may break without warning on Qt version upgrades on the embedded platform.

### 4. Build Security

Build Security: no issues found within the assigned files. Build flag analysis was covered by other auditors reviewing the `.pro` file; no build-related constructs were observed in the three assigned source pairs.

### 5. Device and Firmware

**A21-6 · CRITICAL · Device and Firmware**
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/ui/lockeddialog.h:36`
**Description:** `LockedDialog::mouseReleaseEvent` is implemented inline in the header as `{accept();}`. This causes any touch or mouse click anywhere on the lock screen to emit the `QDialog::accepted()` signal and dismiss the dialog. In `dialog.cpp:112`, `LockedDialog::accepted` is connected to `Dialog::onPinCode()`, which opens the PIN entry dialog. The design intent is that tapping the lock screen opens the PIN dialog, which is the correct next step. However, the lock screen itself offers no visual affordance for this (no "tap to enter PIN" instruction), and more importantly: the `accepted()` signal triggers unconditionally for any touch event, including swipe-away gestures, accidental contact, or tool-assisted input injection. There is no interstitial check on locked state before transitioning to PIN entry. An operator who does not know the PIN can still dismiss the locked state if they can cause the PIN dialog's `accepted()` signal to fire through any means — the lock-state machine transitions entirely on UI signal emission rather than on verified server-side confirmation. The `m_locked` flag is client-side; it is set at startup from `gCfg->maintCode()` (a local config value) and cleared in `onProcessUnlock()` after PIN flow. If the device were to lose power and restart while `gCfg->maintCode()` had been locally altered, the lock could be bypassed. The safety-critical relay control (`setRelayOut`) is gated on multiple checks deeper in `postLogin()`, so a full bypass is not trivially achievable — but the lock screen UI boundary itself provides weaker protection than its safety-critical context demands.

**A21-7 · HIGH · Device and Firmware**
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/ui/lockeddialog.cpp:79`
**Description:** `fullLockStart()` reads the full-lockout timeout directly from `gCfg->fullLockoutTimeout()` and assigns it to `m_timeCntr` (a `quint32`). This value is sourced from the server via `backgroundworker.cpp` GMTP message handling and is stored in `m_configs` without an observed upper-bound validation in the assigned files. A server-supplied value of `0` causes instant relay cutoff on the next timer tick (see A21-1). A server-supplied value of `0xFFFFFFFF` (4,294,967,295) would cause a countdown lasting approximately 136 years, effectively making the full-lockout feature permanently inoperative. Neither boundary is validated before use in the safety-critical shutdown path.

### 6. Qt-Specific Security

**A21-8 · MEDIUM · Qt-Specific Security**
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/ui/pindialog.ui:505`
**Description:** The PIN entry `QLineEdit` in `PinDialog` uses `QLineEdit::PasswordEchoOnEdit` as its echo mode. This mode displays characters briefly as they are typed before replacing them with masking characters, in contrast to `QLineEdit::Password` which masks immediately. On an embedded touchscreen device without shoulder-surfing mitigation, briefly displayed PIN characters are visible to bystanders. For a vehicle-proximity safety device used in industrial or mining environments where multiple operators may be nearby, this is a meaningful credential exposure risk. The echo mode should be `QLineEdit::Password`. Note: this file (`pindialog.ui`) is included here because it is the credential-entry component directly coupled to the `LockedDialog` flow examined in this review.

**A21-9 · LOW · Qt-Specific Security**
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/ui/onScreenKeyboard.ui:26`
**Description:** The `onScreenKeyboard` widget has `windowOpacity` set to `50.000000000000000` in its `.ui` file. An opacity of 50 (interpreted by Qt as a ratio — effectively this would be applied as the literal double value, but Qt's `setWindowOpacity` takes 0.0–1.0) may be a malformed value from the designer. If Qt interprets this as `50.0` and clamps it to `1.0` (fully opaque), the effect is benign. If the platform interprets the raw value differently, the keyboard could appear fully transparent, making entered characters invisible to the user while still processing input — a usability and potential security concern. This should be verified against the target Qt version's behaviour and set explicitly to `1.0` (fully opaque) for a credential-entry component.
