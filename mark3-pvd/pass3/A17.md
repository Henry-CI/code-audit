# Pass 3 Agent A17 — Documentation

**Audit run:** 2026-02-28-01
**Branch:** master
**Files reviewed:**
- `platform/userport.h` / `platform/userport.cpp`
- `platform/wiegandrfid.h` / `platform/wiegandrfid.cpp`
- `platform/wifi.h` / `platform/wifi.cpp`

---

## Reading Evidence

### `platform/userport.h` — Class `EM070::UserPort`

**Class:** `EM070::UserPort` (extends `QObject`)

**Public methods:**

| Line | Method |
|------|--------|
| 15 | `explicit UserPort(QObject *parent = nullptr)` |
| 16 | `void response(const QByteArray &ba)` |
| 18 | `void setBaudRate(QSerialPort::BaudRate baudRate)` |

**Signals:**

| Line | Signal |
|------|--------|
| 21 | `void cmdReceived(const QByteArray &ba)` |

**Private methods:** `readData()`

**Private members:** `m_serialPort` (`QSerialPort*`), `m_receiver` (`QByteArray`)

**Types / enums / constants defined in header:** none (uses `QSerialPort::BaudRate` from Qt)

**Macro in .cpp:** `FILE_USER_PORT` = `"/dev/ttyS1"`

---

### `platform/wiegandrfid.h` — Class `EM070::WiegandRfid`

**Class:** `EM070::WiegandRfid` (extends `QObject`)

**Public methods:**

| Line | Method |
|------|--------|
| 14 | `explicit WiegandRfid(QObject *parent = 0)` |
| 15 | `void setEnabled(bool enable)` |
| 17 | `static quint64 wiegandData(quint8 facility, quint32 number)` |

**Signals:**

| Line | Signal |
|------|--------|
| 20 | `void cardData(quint64 wiegand, quint16 facility, quint32 number, QByteArray &readerOutput)` |
| 21 | `void error(const QString &text)` |

**Private methods:** `activated()`

**Private members:** `m_cardReadyFile` (`QFile`), `m_notifier` (`QSocketNotifier*`)

**Types / enums / constants defined in header:** none

**Macros in .cpp:**
- `FILE_CARD_READY` = `"/sys/devices/platform/wiegand-gpio.0/card_ready"`
- `FILE_CARD_DATA`  = `"/sys/devices/platform/wiegand-gpio.0/card_data"`
- `FILE_RAW_DATA`   = `"/sys/devices/platform/wiegand-gpio.0/raw_data"`

---

### `platform/wifi.h` — Class `EM070::Wifi`

**Class:** `EM070::Wifi` (extends `QObject`)

**Public methods:**

| Line | Method |
|------|--------|
| 26 | `explicit Wifi(EM070::UserPort *userPort)` |
| 27 | `~Wifi() {}` |
| 29 | `void writeConf()` |
| 30 | `void restart()` |
| 32 | `bool status()` (inline getter) |
| 34 | `bool startPositioning()` |
| 36 | `void parseResponse(const QByteArray &ba)` |
| 38 | `QList<CIGCONF::AccessPoint> accessPoints()` (inline getter) |
| 40 | `void setCellularState(bool state)` |
| 42 | `void setPowerState(CIGCONF::PowerState state)` |

**Signals:**

| Line | Signal |
|------|--------|
| 46 | `void ethernetStateChanged(bool ready)` |
| 47 | `void wifiReconnectionFailed()` |
| 48 | `void wifiScanFinished(QList<CIGCONF::AccessPoint> list)` |

**Private methods:** `attemptReconnectToWifi()`, `checkStatus()`, `scanAccessPoints()`, `scanFinished(int, QProcess::ExitStatus)`

**Private members:** `m_userPort`, `m_configurationManager`, `m_status`, `m_wifiStatus`, `m_cellularStatus`, `m_posTimer`, `m_reconnectTimer`, `m_ps`, `m_accessPoints`, `m_powerState`

**Types used from `CIGCONF`:** `CIGCONF::AccessPoint`, `CIGCONF::PowerState`, `CIGCONF::WifiNetwork` (in .cpp)

**Macros in .cpp:**
- `SCAN_WATCHDOG` = `300000` ms (5 minutes)
- `RECONNECT_TIMEOUT` = `210000` ms (3.5 minutes)

---

## Documentation Check per Method

### `EM070::UserPort`

| Method | Doc comment? | Accurate? | Params/return described? |
|--------|-------------|-----------|--------------------------|
| `UserPort(QObject *parent)` | No | — | — |
| `response(const QByteArray &ba)` | No | — | — |
| `setBaudRate(QSerialPort::BaudRate baudRate)` | No | — | — |
| Signal: `cmdReceived(const QByteArray &ba)` | No | — | — |

No doc comments exist anywhere in `userport.h` or `userport.cpp`.

### `EM070::WiegandRfid`

| Method | Doc comment? | Accurate? | Params/return described? |
|--------|-------------|-----------|--------------------------|
| `WiegandRfid(QObject *parent)` | No | — | — |
| `setEnabled(bool enable)` | No | — | — |
| `static wiegandData(quint8 facility, quint32 number)` | No (block comment inside body only) | — | — |
| Signal: `cardData(quint64, quint16, quint32, QByteArray&)` | No | — | — |
| Signal: `error(const QString &text)` | No | — | — |

The only comment in `wiegandrfid.cpp` is an internal block comment inside `wiegandData()` (lines 113–122) that partially explains the encoding algorithm; it is not a doc comment above the declaration and does not describe parameters or return value.

### `EM070::Wifi`

| Method | Doc comment? | Accurate? | Params/return described? |
|--------|-------------|-----------|--------------------------|
| `Wifi(EM070::UserPort *userPort)` | No | — | — |
| `~Wifi()` | No | — | — |
| `writeConf()` | No | — | — |
| `restart()` | No | — | — |
| `status()` | No | — | — |
| `startPositioning()` | No | — | — |
| `parseResponse(const QByteArray &ba)` | No | — | — |
| `accessPoints()` | No | — | — |
| `setCellularState(bool state)` | No | — | — |
| `setPowerState(CIGCONF::PowerState state)` | No | — | — |
| Signal: `ethernetStateChanged(bool ready)` | No | — | — |
| Signal: `wifiReconnectionFailed()` | No | — | — |
| Signal: `wifiScanFinished(...)` | No | — | — |

No doc comments exist anywhere in `wifi.h` or `wifi.cpp`.

---

## Findings

**A17-1** · HIGH · No documentation on WiegandRfid constructor

**Description:** `WiegandRfid::WiegandRfid(QObject *parent)` has no doc comment. The constructor opens the sysfs `card_ready` file and registers an exception-mode `QSocketNotifier`. If the file cannot be opened the object is silently left in a non-functional state (`m_notifier` is never initialised), yet the caller has no way to detect this failure. Without documentation, callers do not know the object may be partially constructed, what sysfs path is required, or that they must not call `setEnabled()` on a failed instance (which would dereference a null `m_notifier`).

**Fix:** Add a doc comment above the declaration in `wiegandrfid.h` describing the sysfs dependency, the silent-failure behaviour on missing hardware, and that callers should guard against a non-functional instance. Also add a `bool isValid()` accessor (or throw / use a factory) so callers can detect construction failure.

---

**A17-2** · HIGH · No documentation on `WiegandRfid::setEnabled(bool enable)`

**Description:** `setEnabled()` enables or disables the `QSocketNotifier` that fires on RFID card presentation, directly gating whether vehicle-access authentication events are delivered. No doc comment exists. The name `setEnabled` is generic and does not convey that disabling it suppresses all card reads; a caller who misuses this could silently disable access control.

**Fix:** Add a doc comment stating that `enable = false` suppresses all RFID card-read notifications, that calling this on a construction-failed instance will crash (null pointer dereference on `m_notifier`), and under what conditions callers are expected to disable the reader.

---

**A17-3** · HIGH · No documentation on `static WiegandRfid::wiegandData(quint8 facility, quint32 number)`

**Description:** `wiegandData()` is the sole function that converts facility/card-number pairs into the canonical Wiegand credential integer used throughout the access-control system. It handles three distinct encoding formats (Wiegand-26, Wiegand-42, and an unimplemented path for numbers > 99999) with parity bit computation. There is a partial inline comment inside the function body that describes some edge-case behaviour but does not appear above the declaration, does not document parameters, does not document the return value, and does not warn that numbers > 99999 produce only a `qCritical` log and return `0`. This is a security-relevant function: incorrect or undocumented encoding rules can cause legitimate credentials to be silently rejected or two distinct credentials to map to the same integer.

**Fix:** Add a doc comment above the declaration in `wiegandrfid.h` that: (a) describes `facility` (8-bit site code) and `number` (card number, valid range 1–99999); (b) documents the return value as the packed Wiegand integer including parity bits; (c) explicitly states the unimplemented range (number > 99999) returns `0` and logs a critical error; (d) references the encoding specification URL already present in the body comment.

---

**A17-4** · HIGH · No documentation on `cardData` signal

**Description:** The `cardData` signal carries the raw authentication credential (`quint64 wiegand`, `quint16 facility`, `quint32 number`, `QByteArray &readerOutput`). The relationship between the four parameters is non-obvious: `wiegand` is the computed canonical value from `wiegandData()`, while `facility`/`number` are the raw decoded fields, and `readerOutput` is the raw byte string read from sysfs. When `facility == 0 && number == 0` (raw-data fall-through path for ≥ 26-bit cards), `wiegand` carries the verbatim raw integer rather than the computed canonical value. No documentation exists to explain this dual-mode emission, which is security-relevant: a consumer that always passes `wiegand` to the access-control lookup will behave differently from one that uses `facility`/`number`.

**Fix:** Add a doc comment above the signal declaration describing each parameter, the conditions under which `facility` and `number` may both be zero, and how the `wiegand` value is populated in each case.

---

**A17-5** · HIGH · No documentation on `error` signal (WiegandRfid)

**Description:** The `error` signal is emitted when a card swipe produces bit-count data but cannot be decoded into a recognised credential (bit count < 26, or the 34-bit path yields facility == 0 or number == 0). The `text` parameter actually carries the raw sysfs byte string (`ba`), not a human-readable error description. No documentation exists. A consumer expecting `text` to be a human-readable message string (as the parameter name implies) may log or display raw binary data, and critically may not connect this signal to a denied-access handler.

**Fix:** Add a doc comment clarifying that `text` is the raw sysfs data that could not be parsed, not a descriptive string, and that this signal indicates a card presentation that could not be authenticated.

---

**A17-6** · LOW · No documentation on `UserPort::response(const QByteArray &ba)`

**Description:** `response()` writes `ba` directly to the serial port. There is no doc comment describing what type of data is expected, whether the port must be open, or the echo behaviour controlled by `gCfg->isRs232AccessoryActive()` that interacts with input echoing in `readData()`. The behaviour when the port is closed is silently a no-op.

**Fix:** Add a doc comment describing the parameter, the silent no-op when the port is closed, and the dependency on the accessory-active state for echo behaviour.

---

**A17-7** · LOW · No documentation on `UserPort::setBaudRate(QSerialPort::BaudRate baudRate)`

**Description:** `setBaudRate()` delegates directly to `QSerialPort::setBaudRate()`. No doc comment exists. While the method is simple, it is called by `Wifi::startPositioning()` to switch between 9600 baud (Xpico-240 positioning mode) and 115200 baud (normal mode). Without documentation the coupling between `UserPort` baud rate changes and the Wifi positioning subsystem is invisible to maintainers.

**Fix:** Add an INFO-level doc comment noting the expected callers and valid baud rate values in this system context.

---

**A17-8** · LOW · No documentation on `UserPort::cmdReceived` signal

**Description:** `cmdReceived` is emitted when a CR or LF terminates an incoming line on the serial port. The emitted `QByteArray` does not include the terminator. Backspace handling (`\b`) has already been applied. No doc comment exists describing the line-termination rule, the backspace pre-processing, or what protocol is expected on the serial port.

**Fix:** Add a doc comment describing when the signal fires, that the terminator is stripped, that backspace editing has already been applied, and the expected serial protocol context.

---

**A17-9** · LOW · No documentation on `Wifi::writeConf()`

**Description:** `writeConf()` writes `wpa_supplicant.conf` to `WIFI_CONF_FILE`. It silently skips networks with empty SSIDs, SSIDs longer than 32 characters, and treats passwords shorter than 8 or longer than 63 characters as open (no authentication) networks. The silent open-network fallback is a security-relevant behaviour: a misconfigured password causes the device to associate with the named SSID using no encryption rather than refusing to configure the network. No documentation exists.

**Fix:** Add a doc comment describing the file written, the SSID length constraints, and explicitly noting that an out-of-range password causes the network to be written as `key_mgmt=NONE` (open).

---

**A17-10** · LOW · No documentation on `Wifi::restart()`

**Description:** `restart()` either sends SIGHUP to a running `wpa_supplicant` process (triggering a re-read of config) or starts a new `wpa_supplicant` instance. It has no return value and provides no indication of success or failure. No doc comment exists describing the side effects, the dependency on `wpa_supplicant` being installed, the hardcoded interface name `wlan0`, or the 3-second blocking wait on `ps`.

**Fix:** Add a doc comment describing both code paths, the 3-second synchronous block, and the hardcoded interface assumption.

---

**A17-11** · LOW · No documentation on `Wifi::startPositioning()`

**Description:** `startPositioning()` starts or stops WiFi-based positioning depending on configuration. It returns `true` when positioning is started and `false` when stopped, but no doc comment exists. The method also has the side effect of changing the `UserPort` baud rate, which affects unrelated serial communication. This cross-subsystem side effect is invisible without documentation.

**Fix:** Add a doc comment describing the return value semantics, the baud-rate side effect, and the dependency on global configuration values `wifiPos()` and `wifiPosInterval()`.

---

**A17-12** · LOW · No documentation on `Wifi::parseResponse(const QByteArray &ba)`

**Description:** `parseResponse()` is only active when `wifiPosSource == WifiPosXpico240`. For all other sources it returns immediately. The method parses a fixed-offset binary/text frame from the Xpico-240 device: SSID at bytes 0–31, MAC at bytes 33–49, channel at bytes 51–53, RSSI at bytes 55–58. A `'>'` byte in position 0 signals end-of-scan. None of this protocol detail is documented. Callers from other subsystems will not know this method is a no-op for non-Xpico sources.

**Fix:** Add a doc comment describing the Xpico-240 frame format, the end-of-scan sentinel, and the condition under which the method is a no-op.

---

**A17-13** · LOW · No documentation on `Wifi::setCellularState(bool state)`

**Description:** `setCellularState()` updates `m_cellularStatus` and, when the reconnect timer is not already running, starts a 3.5-minute reconnect timer. The interaction between cellular state and WiFi reconnect logic is not obvious, and the timer start side effect is undocumented.

**Fix:** Add a doc comment explaining that this informs the WiFi subsystem whether cellular is available (so that WiFi reconnection urgency changes), and that it arms the reconnect timer as a side effect.

---

**A17-14** · LOW · No documentation on `Wifi::setPowerState(CIGCONF::PowerState state)`

**Description:** `setPowerState()` sets `m_powerState`. When not in `NormalPowerState`, `checkStatus()` returns immediately, effectively disabling all WiFi connection monitoring. This has an operational impact (the device stops reacting to WiFi drops during non-normal power states) that is entirely undocumented.

**Fix:** Add a doc comment stating that non-normal power states suppress WiFi status monitoring, and referencing the `CIGCONF::PowerState` enum values.

---

**A17-15** · LOW · No documentation on `Wifi` signals

**Description:** None of the three signals (`ethernetStateChanged`, `wifiReconnectionFailed`, `wifiScanFinished`) have doc comments. In particular: (a) `ethernetStateChanged` carries a `bool ready` but the signal name says "ethernet" while the implementation monitors `wlan0` — callers may be confused about when this fires for wired vs wireless; (b) `wifiReconnectionFailed` is defined but never emitted in the current implementation (the reconnect body is entirely commented out); (c) `wifiScanFinished` is defined but also never emitted anywhere in the implementation.

**Fix:** Add doc comments for each signal. Mark `wifiReconnectionFailed` and `wifiScanFinished` as currently unused/unimplemented. Clarify that `ethernetStateChanged` tracks WiFi (`wlan0`) state only despite the name.

---

**A17-16** · INFO · `Wifi::status()` inline getter undocumented and misleading

**Description:** `status()` returns `m_status`, which is initialised to `false` in the constructor and never updated anywhere in the implementation. It therefore always returns `false`. No doc comment exists. The field `m_wifiStatus` is separately used to track actual WiFi connection state. The existence of a permanently-false `status()` alongside a meaningful `m_wifiStatus` is a documentation gap that is also indicative of a stale API surface.

**Fix:** Add a doc comment noting that this accessor reflects `m_status` (not `m_wifiStatus`). Investigate whether `m_status` is intended to represent something distinct; if not, mark it as deprecated.

---

**A17-17** · INFO · `Wifi::accessPoints()` inline getter undocumented

**Description:** `accessPoints()` returns the last scanned list of `CIGCONF::AccessPoint`. No doc comment exists describing when the list is populated, its relationship to the `wifiScanFinished` signal, or whether it may be empty before the first scan completes.

**Fix:** Add a brief doc comment stating that the list is populated after the first successful scan and may be empty until then.

---

## Summary Table

| ID | Severity | File | Symbol | Issue |
|----|----------|------|--------|-------|
| A17-1 | HIGH | `wiegandrfid.h:14` | `WiegandRfid::WiegandRfid()` | No documentation; silent construction failure leaves null `m_notifier` |
| A17-2 | HIGH | `wiegandrfid.h:15` | `WiegandRfid::setEnabled()` | No documentation; disables all RFID auth events; null-ptr crash risk |
| A17-3 | HIGH | `wiegandrfid.h:17` | `WiegandRfid::wiegandData()` | No documentation on security-critical credential encoding; silent zero return for invalid input |
| A17-4 | HIGH | `wiegandrfid.h:20` | Signal `cardData` | No documentation; dual-mode emission (parsed vs raw) undescribed |
| A17-5 | HIGH | `wiegandrfid.h:21` | Signal `error` | No documentation; parameter carries raw binary, not a message string |
| A17-6 | LOW | `userport.h:16` | `UserPort::response()` | No documentation; silent no-op and echo behaviour undescribed |
| A17-7 | LOW | `userport.h:18` | `UserPort::setBaudRate()` | No documentation; cross-subsystem baud-rate coupling invisible |
| A17-8 | LOW | `userport.h:21` | Signal `cmdReceived` | No documentation; termination/backspace processing undescribed |
| A17-9 | LOW | `wifi.h:29` | `Wifi::writeConf()` | No documentation; silent open-network fallback for bad passwords |
| A17-10 | LOW | `wifi.h:30` | `Wifi::restart()` | No documentation; blocking wait and hardcoded interface undescribed |
| A17-11 | LOW | `wifi.h:34` | `Wifi::startPositioning()` | No documentation; return value and baud-rate side effect undescribed |
| A17-12 | LOW | `wifi.h:36` | `Wifi::parseResponse()` | No documentation; Xpico-240 frame format and no-op condition undescribed |
| A17-13 | LOW | `wifi.h:40` | `Wifi::setCellularState()` | No documentation; timer side effect undescribed |
| A17-14 | LOW | `wifi.h:42` | `Wifi::setPowerState()` | No documentation; suppression of WiFi monitoring undescribed |
| A17-15 | LOW | `wifi.h:46–48` | Signals `ethernetStateChanged`, `wifiReconnectionFailed`, `wifiScanFinished` | No documentation; two signals never emitted; misleading signal name |
| A17-16 | INFO | `wifi.h:32` | `Wifi::status()` | No documentation; returns permanently-false `m_status` |
| A17-17 | INFO | `wifi.h:38` | `Wifi::accessPoints()` | No documentation; population timing undescribed |

**Total findings: 17**
- HIGH: 5 (all in `WiegandRfid`, the security-critical RFID authentication class)
- LOW: 10 (spread across `UserPort` and `Wifi`)
- INFO: 2 (trivial getters in `Wifi`)
