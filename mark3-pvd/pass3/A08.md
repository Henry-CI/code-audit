# Pass 3 Agent A08 — Documentation

**Audit run:** 2026-02-28-01
**Branch:** master
**Files reviewed:**
- `comm/canmonitor.h` (150 lines)
- `comm/canmonitor.cpp` (1657 lines)
- `comm/canstatehandler.h` (53 lines)
- `comm/canstatehandler.cpp` (207 lines)

---

## Reading Evidence

### canmonitor.h / canmonitor.cpp

**Class:** `CanMonitor` (inherits `QObject`)

**Public methods — header line numbers:**

| Line | Method / Inline |
|------|----------------|
| 20 | `explicit CanMonitor(EM070::CanBus *canBus)` |
| 22 | `bool readCanConfig()` |
| 23 | `bool readOldCanConfig()` |
| 24 | `void saveCanConfig()` |
| 25 | `void calculateCanCrc()` |
| 28 | `quint32 canCrc32() const` (inline getter) |
| 30 | `void setEnabled(bool enable)` |
| 32 | `void clearCanConfig()` |
| 33 | `QByteArray canBusConfig() const` |
| 34 | `bool setCanBusConfig(const QByteArray &config)` |
| 35 | `QByteArray canPgnConfig() const` |
| 36 | `bool setCanPgnConfig(const QByteArray &config)` |
| 37 | `QByteArray canSpnConfig() const` |
| 38 | `bool setCanSpnConfig(const QByteArray &config)` |
| 39 | `QByteArray canAttConfig() const` |
| 40 | `bool setCanAttConfig(const QByteArray &config)` |
| 41 | `QByteArray canLinConfig() const` |
| 42 | `bool setCanLinConfig(const QByteArray &config)` |
| 43 | `QByteArray canBydConfig() const` |
| 44 | `bool setCanBydConfig(const QByteArray &config)` |
| 45 | `QByteArray canLin2Config() const` |
| 46 | `bool setCanLin2Config(const QByteArray &config)` |
| 48 | `bool isXferEnabled() const` (inline getter) |
| 49 | `QByteArray attributeName(quint8 index) const` (inline getter) |
| 50 | `CIGCONF::CanAttributeType attributeType(quint8 index) const` (inline getter) |
| 52 | `void setVdiAccess(bool access, bool inhibit)` |
| 53 | `void enableVdi(bool enable)` |

**Signals:**

| Line | Signal |
|------|--------|
| 60 | `void resetCanStates(bool resetLast)` |
| 61 | `void stateUpdated(quint8 index, quint32 state)` |

**Private structs (internal types):**

| Name | Purpose |
|------|---------|
| `BusConfig` | CAN bus configuration (protocol, baud rate, extended, enabled) |
| `PgnConfig` | PGN descriptor (extended, pgn, priority, sourceAddress, pollingX10ms) |
| `SpnConfig` | SPN descriptor (pgnIndex, siblingIndex, spn, response mask, width, offset, opcode, operand) |
| `AttConfig` | Named attribute config (name, type, spn index/op union, spnMask/spnIndex2 union, spnState) |

**Enums/constants:** None defined in this file. Uses `CIGCONF::CanProtocol`, `CIGCONF::CanAttributeType`, and constants `CAN_ATT_NAME_LEN`, `CAN_MAX_PGN_IDX`, `CAN_MAX_SPN_IDX`, `CAN_MAX_ATT_IDX`, `CAN_MAX_LINK_IDX` from `cigconfigs.h`.

**File-scope compile-time constants (canmonitor.cpp):**

| Macro | Value |
|-------|-------|
| `CAN_CONF_FILE_OLD` | `"cancfg.dat"` |
| `CAN_CONF_FILE` | `"cancfgnew.dat"` |
| `UPDATE_DEFER` | `3000` (ms) |
| `RULE_*_RATE` | Polling rates for named attributes (2000 ms or 60000 ms) |
| `LIN_CANID_OFFSET` | `0x10` |
| `LIN_ADDR_OFFSET` | `0x4000` |
| `BYD_CANID_XOR` | `0x380` |
| `BYD_ADDR_OFFSET` | `0x0B000000` |

---

### canstatehandler.h / canstatehandler.cpp

**Class:** `CanStateHandler` (inherits `QObject`)

**Public enum:**

| Line | Name | Enumerators |
|------|------|-------------|
| 14 | `DigitalFormat` | `SessionFormat`, `UsageFormat`, `OnDemandFormat` |

**Public methods — header line numbers:**

| Line | Method |
|------|--------|
| 16 | `explicit CanStateHandler(CanMonitor *canMonitor)` |
| 17 | `void updateIdleTimer()` |
| 18 | `QByteArray canStates(DigitalFormat format, bool autoReset)` |
| 19 | `void resetStates(bool resetLast)` |

**Signals:**

| Line | Signal |
|------|--------|
| 22 | `void idleTimeout()` |

**Private struct:**

| Name | Fields |
|------|--------|
| `CanState` | `state`, union `time` (`sessionOnTime`, `sessionOffTime`, `usageOnTime`, `usageOffTime`) / `count` (`sessionRisings`, `sessionFallings`, `usageRisings`, `usageFallings`), `clock` |

---

## Documentation Checks

### CanMonitor — public methods

1. **`CanMonitor(EM070::CanBus *canBus)`** — No doc comment. Constructor wires up CAN bus read slot, deferred-update timer, and calls `readCanConfig()` with fallback to `clearCanConfig()`+`saveCanConfig()`. Non-trivial initialization; not documented.

2. **`readCanConfig()`** — No doc comment. Reads `cancfgnew.dat` (versions 1 or 2) or falls back to old format. Validates CRC32. Handles VDI mode shortcut. Non-trivial; no description of return value or side effects.

3. **`readOldCanConfig()`** — No doc comment. Reads legacy `cancfg.dat` format and up-converts `SpnConfig0` to the current `SpnConfig`. Return value semantics (true = success, false = size/CRC failure) undocumented.

4. **`saveCanConfig()`** — No doc comment. Serializes all config structs with a CIG-format CRC and a file-level CRC32 to `cancfgnew.dat`. This is a write to persistent storage affecting device behaviour; no documentation.

5. **`calculateCanCrc()`** — Has inline implementation comment block (commented-out code showing alternative struct-based approach) but **no explanatory doc comment**. The function computes `m_canCrc32` differently depending on whether the protocol is `Linde1202` (XOR of individual CRCs) or anything else (CRC over a `CigCanConfig`). The distinction is significant and undocumented.

6. **`canCrc32() const`** — Has a trailing inline comment `// for CIG CAN format CRC` on line 27. Acceptable as a minimal descriptor for a trivial getter. No parameter/return description needed.

7. **`setEnabled(bool enable)`** — No doc comment. When `enable` is false, powers down the CAN bus and zeroes SPN state. When `enable` is true, only activates bus if `m_busConfig.enabled` is also true. The conditional logic is not obvious; undocumented.

8. **`clearCanConfig()`** — No doc comment. Zeroes all config tables, resets to default LindeExtended/250kbps/enabled settings, starts deferred-update timer, emits `resetCanStates(true)`. Has a single inline comment `// CMD_CLRCAN:` which is an AT-command tag, not a description.

9. **`canBusConfig() const`** — Has inline comment showing the response format `"^CANCFG: ..."` inside the implementation. No doc comment in header. Format string documents what is returned but only if you read the .cpp.

10. **`setCanBusConfig(const QByteArray &config)`** — Implementation has inline comment `// "<can_type>,<baud_rate>,<id_size>,<tx_enable>"`. No header doc comment. Validates protocol (0–4), baud rate (0–1,000,000), etc. Return value meaning (true = applied, false = parse error) is undocumented.

11. **`canPgnConfig() const`** — Implementation has inline comment showing response format. No header doc comment.

12. **`setCanPgnConfig(const QByteArray &config)`** — Implementation has inline comment for format. No header doc comment. Also silently rejects calls when protocol is not J1939 or LindeExtended; this rejection is undocumented.

13. **`canSpnConfig() const`** — Implementation has inline comment. No header doc comment.

14. **`setCanSpnConfig(const QByteArray &config)`** — Implementation has inline comment. No header doc comment. Protocol restriction (J1939/LindeExtended only) undocumented.

15. **`canAttConfig() const`** — Implementation has inline comment (note: comment says `^CANSPN:` but function emits `^CANATT:`). No header doc comment.

16. **`setCanAttConfig(const QByteArray &config)`** — Implementation has inline comment. No header doc comment. Protocol restriction (J1939, LindeExtended, BydCan, Linde1202) undocumented.

17. **`canLinConfig() const`** — Implementation has inline comment. No header doc comment.

18. **`setCanLinConfig(const QByteArray &config)`** — Implementation has inline comment. No header doc comment. Protocol restriction (LindeExtended only) undocumented.

19. **`canBydConfig() const`** — Implementation has inline comment. No header doc comment.

20. **`setCanBydConfig(const QByteArray &config)`** — Implementation has inline comment. No header doc comment. Protocol restriction (BydCan only) undocumented.

21. **`canLin2Config() const`** — Implementation has inline comment. No header doc comment.

22. **`setCanLin2Config(const QByteArray &config)`** — Implementation has inline comment (contains a stray trailing `"` at end of comment on line 1099). No header doc comment. Protocol restriction (Linde1202 only) undocumented.

23. **`isXferEnabled() const`** — No doc comment; trivial inline getter. INFO severity.

24. **`attributeName(quint8 index) const`** — No doc comment; unchecked index — passing `index >= CAN_MAX_ATT_IDX` causes undefined behaviour. No bounds documentation.

25. **`attributeType(quint8 index) const`** — Same issue as `attributeName`.

26. **`setVdiAccess(bool access, bool inhibit)`** — No doc comment. Controls VDI node access by writing byte 0x05, 0x01, or 0x00 to CAN ID 0x215 at 1 Hz. Both parameters (`access`, `inhibit`) are undescribed. Safety-relevant (controls physical access).

27. **`enableVdi(bool enable)`** — No doc comment. `enable=true` calls `initVdi()` which hard-codes a full CAN config; `enable=false` wipes config via `clearCanConfig()`. Significant side effects; undocumented.

### CanMonitor — signals

28. **`resetCanStates(bool resetLast)`** — No doc comment. `resetLast` distinguishes between a full reset (including Last-type attributes) and a partial reset. Callers need to know this distinction; it is undocumented.

29. **`stateUpdated(quint8 index, quint32 state)`** — No doc comment. Emitted when a monitored SPN attribute changes. `index` is the attribute index (0-based), `state` is the computed attribute state. Undocumented.

### CanStateHandler — public methods

30. **`CanStateHandler(CanMonitor *canMonitor)`** — No doc comment. Connects `stateUpdated` and `resetCanStates` signals, calls `resetStates(true)`.

31. **`updateIdleTimer()`** — Has inline comment inside the implementation (`/* per spec., 64 means input is CAN SEAT state... */`) but no header doc comment. The method is re-evaluated from config each call: it creates or destroys the idle timer and may start it immediately. The comment references a spec but the spec is not identified. No header doc comment.

32. **`canStates(DigitalFormat format, bool autoReset)`** — No doc comment. Returns a formatted byte string of all active CAN attribute states. The `format` parameter controls which counters/times are included and their scope. The `autoReset` parameter causes destructive zeroing of session or usage counters. The destructive nature of `autoReset` is not documented anywhere.

33. **`resetStates(bool resetLast)`** — Has an inline comment on line 19 in the header: `// once CAN rules is changed or disabled, reset all states`. This is the only doc comment present across all four files. However, the comment does not explain that `resetLast=false` preserves `CanAttributeLast`, `CanAttributeLast2`, and `CanAttributeTime` entries. The parameter semantics are under-described.

### CanStateHandler — signals

34. **`idleTimeout()`** — No doc comment. Emitted by a single-shot timer when the SEAT-type CAN input has been in the configured polarity for `idleTimeout()` seconds. Undocumented.

---

## Findings

**A08-1** · LOW · No doc comment on `CanMonitor` constructor
**Description:** The constructor (`canmonitor.h` line 20) performs non-trivial initialization: it connects CAN bus read and timer signals, sets defaults, and attempts to load configuration from persistent storage with a fallback write. None of this is described. A maintainer cannot determine expected usage or what preconditions `canBus` must satisfy.
**Fix:** Add a doc comment explaining the constructor's behaviour, the ownership of `canBus` (parent is set to `canBus`), and the fact that configuration is loaded immediately.

---

**A08-2** · LOW · No doc comment on `readCanConfig()` / `readOldCanConfig()`
**Description:** Both methods (`canmonitor.h` lines 22–23) read binary configuration files, validate a CRC32, and up-convert older formats. The return value (`true` on success, `false` on file-not-found, size mismatch, or CRC failure) is not documented. The VDI-mode shortcut in `readCanConfig()` (which bypasses file reading entirely) is also not described.
**Fix:** Add doc comments to each method documenting the return value, the file names consulted, the CRC check, and the VDI-mode shortcut.

---

**A08-3** · LOW · No doc comment on `saveCanConfig()`
**Description:** `saveCanConfig()` (`canmonitor.h` line 24) serialises all four config tables plus the CIG CRC and a file-level CRC32 to `cancfgnew.dat`. The function has no header doc comment and no inline description of what it writes or any failure conditions (e.g. `qCritical` on `open` failure, but no return value).
**Fix:** Add a doc comment describing what is written, when the caller should invoke this method, and note that failures are logged but silently swallowed.

---

**A08-4** · LOW · No doc comment on `calculateCanCrc()`
**Description:** `calculateCanCrc()` (`canmonitor.h` line 25) computes `m_canCrc32` using two distinct algorithms: for `Linde1202`, it XORs four independent CRC32 values; for all other protocols, it converts to a `CigCanConfig` struct and CRCs that. This behavioural fork is undocumented. The commented-out code in the implementation adds confusion rather than clarity.
**Fix:** Add a doc comment stating the two code paths and why they differ. Remove or clearly explain the commented-out dead code.

---

**A08-5** · LOW · No doc comment on `setEnabled(bool enable)`
**Description:** `setEnabled()` (`canmonitor.h` line 30) controls CAN bus power and transfer enable. When `enable=false` it always powers down; when `enable=true` it only powers up if `m_busConfig.enabled` is also true. This conditional makes the method more than a simple toggle, but it has no doc comment. A caller setting `enable=true` after a config change that disabled the bus will see silent no-operation.
**Fix:** Add a doc comment describing the power/xfer state machine and the dependency on `m_busConfig.enabled`.

---

**A08-6** · LOW · No doc comment on `clearCanConfig()`
**Description:** `clearCanConfig()` (`canmonitor.h` line 32) zeroes all config tables, then unconditionally resets defaults (`LindeExtended`, 250 kbps, enabled), starts the deferred-update timer, and emits `resetCanStates(true)`. The inline comment `// CMD_CLRCAN:` is an AT-command reference, not a description. The side effects on the running CAN bus are not documented.
**Fix:** Add a doc comment stating that all config is zeroed and default values are restored, and that this will eventually reconfigure the live bus.

---

**A08-7** · MEDIUM · Inaccurate inline comment in `canAttConfig()` implementation
**Description:** `canAttConfig()` (`canmonitor.cpp` line 707) contains the comment `// "^CANSPN: <att_index>,<name>,<type>,<spn_index>,<spn_mask>,<spn_state>[,<opcode>]"`. The response prefix is `^CANATT:`, not `^CANSPN:`. This is a copy-paste error. A developer relying on this comment to understand the wire protocol will be misled.
**Fix:** Correct the comment to read `// "^CANATT: <att_index>,<name>,<type>,<spn_index>,<spn_mask>,<spn_state>[,<opcode>]"`.

---

**A08-8** · LOW · No doc comments on the entire `setCanXxxConfig` / `canXxxConfig` family (10 methods)
**Description:** The ten getter/setter pairs (`canBusConfig`, `setCanBusConfig`, `canPgnConfig`, `setCanPgnConfig`, `canSpnConfig`, `setCanSpnConfig`, `canAttConfig`, `setCanAttConfig`, `canLinConfig`, `setCanLinConfig`, `canBydConfig`, `setCanBydConfig`, `canLin2Config`, `setCanLin2Config`, lines 33–46) each have inline format-string comments only inside the `.cpp` file. The header declares them with no documentation at all. Critically, each setter silently returns `false` when the current protocol does not match — this protocol restriction is not documented anywhere accessible from the header.
**Fix:** Add a brief doc comment to each pair in the header describing the expected format, the return value, and any protocol precondition. Moving or duplicating the existing format comments from the `.cpp` to the header would satisfy this.

---

**A08-9** · LOW · No doc comment on `setVdiAccess(bool access, bool inhibit)`
**Description:** `setVdiAccess()` (`canmonitor.h` line 52) is a safety-relevant method that controls physical machine access via the VDI CAN node (CAN ID 0x215). The two boolean parameters interact: `access=true, inhibit=true` → byte 0x05; `access=true, inhibit=false` → byte 0x01; otherwise → byte 0x00. This three-state output is entirely undocumented. The method is a no-op outside VDI mode, which is also undocumented.
**Fix:** Add a doc comment describing the VDI-mode precondition, the meaning of each parameter, the resulting CAN message byte values, and the periodic 1 Hz transmission.

---

**A08-10** · LOW · No doc comment on `enableVdi(bool enable)`
**Description:** `enableVdi()` (`canmonitor.h` line 53) calls `initVdi()` on enable (hard-coding a fixed set of CAN channel, PGN, SPN, and attribute configurations) or `clearCanConfig()` on disable. Calling this method with `enable=true` destroys any previously loaded configuration. This destructive side effect is not documented.
**Fix:** Add a doc comment describing the VDI hard-coded config applied on `enable=true` and the config wipe on `enable=false`.

---

**A08-11** · LOW · Undocumented bounds requirement on `attributeName()` and `attributeType()` inline getters
**Description:** Both inline getters (`canmonitor.h` lines 49–50) directly index `m_attConfigs[index]` without bounds checking. Passing `index >= CAN_MAX_ATT_IDX` produces undefined behaviour. There is no doc comment warning callers of the precondition, and no assertion in the implementation. `CanStateHandler` calls both from a loop bounded by `CAN_MAX_ATT_IDX`, so the immediate risk is low, but the interface is silently unsafe.
**Fix:** Add a doc comment stating the precondition `index < CAN_MAX_ATT_IDX`. Consider adding a bounds assertion in the implementation.

---

**A08-12** · LOW · No doc comment on `resetCanStates` signal; `resetLast` parameter semantics undocumented
**Description:** The `resetCanStates(bool resetLast)` signal (`canmonitor.h` line 60) is emitted in two contexts: from `clearCanConfig()` with `resetLast=true` (full reset) and potentially with `resetLast=false` (partial reset preserving certain attribute types). The slot `CanStateHandler::resetStates` treats the parameter to preserve `CanAttributeLast`, `CanAttributeLast2`, and `CanAttributeTime` entries when false. This semantics is visible only by cross-referencing the slot implementation; neither the signal nor the slot declaration has any documentation.
**Fix:** Add a doc comment to the signal declaration, and expand the existing minimal comment on `resetStates()` in `canstatehandler.h` to describe the `resetLast` parameter.

---

**A08-13** · LOW · No doc comment on `canStates()` and the destructive `autoReset` parameter
**Description:** `canStates(DigitalFormat format, bool autoReset)` (`canstatehandler.h` line 18) serialises accumulated CAN attribute states. When `autoReset=true`, it **zeroes** the session or usage counters/times immediately after sampling. This destructive behaviour means a second call to `canStates` for the same format will return different data. There is no doc comment warning callers that the call mutates state.
**Fix:** Add a doc comment to the declaration describing the three `DigitalFormat` values, the effect of `autoReset=true` (zeroing of accumulated counters/times for the selected scope), and the return format.

---

**A08-14** · LOW · No doc comment on `updateIdleTimer()`
**Description:** `updateIdleTimer()` (`canstatehandler.h` line 17) checks whether idle-timeout is configured and creates, destroys, or starts a single-shot timer accordingly. The inline comment inside the implementation references "per spec., 64 means input is CAN SEAT state" but names no spec document. The method is called externally after config changes, but there is no doc comment explaining when a caller should invoke it.
**Fix:** Add a doc comment stating that this must be called whenever idle-timeout configuration changes, and identify or remove the unnamed spec reference.

---

**A08-15** · INFO · Stray trailing double-quote in `setCanLin2Config` implementation comment
**Description:** `canmonitor.cpp` line 1099 reads:
```cpp
// "<spn_index>,<rsp_id>,<req_id>,<addr>,<rsp_frame>,<rsp_mask>,<width>,<offset>,<opcode>,<operand>""
```
There is an extra `"` at the end of the format string comment. This is a cosmetic defect but can cause confusion when using the comment as a copy-paste template for test code.
**Fix:** Remove the trailing `"` character from the comment.

---

## Summary Table

| ID | Severity | Location | Title |
|----|----------|----------|-------|
| A08-1 | LOW | `canmonitor.h:20` | No doc comment on `CanMonitor` constructor |
| A08-2 | LOW | `canmonitor.h:22-23` | No doc comment on `readCanConfig()` / `readOldCanConfig()` |
| A08-3 | LOW | `canmonitor.h:24` | No doc comment on `saveCanConfig()` |
| A08-4 | LOW | `canmonitor.h:25` | No doc comment on `calculateCanCrc()` |
| A08-5 | LOW | `canmonitor.h:30` | No doc comment on `setEnabled()` |
| A08-6 | LOW | `canmonitor.h:32` | No doc comment on `clearCanConfig()` |
| A08-7 | MEDIUM | `canmonitor.cpp:707` | `canAttConfig()` comment says `^CANSPN:` instead of `^CANATT:` |
| A08-8 | LOW | `canmonitor.h:33-46` | No header doc comments on 10 `canXxxConfig` / `setCanXxxConfig` methods |
| A08-9 | LOW | `canmonitor.h:52` | No doc comment on `setVdiAccess()` |
| A08-10 | LOW | `canmonitor.h:53` | No doc comment on `enableVdi()` |
| A08-11 | LOW | `canmonitor.h:49-50` | No bounds precondition documented on `attributeName()` / `attributeType()` |
| A08-12 | LOW | `canmonitor.h:60` | `resetCanStates` signal `resetLast` parameter undocumented |
| A08-13 | LOW | `canstatehandler.h:18` | Destructive `autoReset` parameter in `canStates()` undocumented |
| A08-14 | LOW | `canstatehandler.h:17` | No doc comment on `updateIdleTimer()` |
| A08-15 | INFO | `canmonitor.cpp:1099` | Stray trailing `"` in `setCanLin2Config` format comment |

**Total findings: 15** (1 MEDIUM, 13 LOW, 1 INFO)
