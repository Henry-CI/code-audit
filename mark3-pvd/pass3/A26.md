# Pass 3 Agent A26 — Documentation

**Audit run:** 2026-02-28-01
**Branch:** master
**Repo root:** C:/Projects/cig-audit/repos/mark3-pvd

---

## Reading Evidence

### `ui/warningdialog.h` + `ui/warningdialog.cpp`

**Class:** `WarningDialog` (extends `QDialog`)

**Enum defined:**
- `WarningDialogType` (line 10, warningdialog.h) — values: `VOR`, `Transport`, `Maintenance`

**Public methods (warningdialog.h):**

| Line | Method | Doc comment present |
|------|--------|---------------------|
| 17 | `explicit WarningDialog(WarningDialogType type, QWidget *parent = 0)` | No |
| 18 | `~WarningDialog()` | No |

**Protected methods (warningdialog.h):**

| Line | Method | Doc comment present |
|------|--------|---------------------|
| 29 | `void hideEvent(QHideEvent *)` | No |
| 30 | `void showEvent(QShowEvent *event = 0)` | No |

**Private methods (warningdialog.h):**

| Line | Method | Doc comment present |
|------|--------|---------------------|
| 24 | `QString showVorWarning()` | No |
| 25 | `QString showTransportWarning()` | No |
| 26 | `QString showMaintenanceWarning()` | No |

**Signals:** None declared.
**Slots:** None explicitly declared (uses `QDialog::accept` and `QDialog::reject` via `connect`).

**Implementation notes:**
- Constructor connects `btnACK` clicked to `accept()`, and a QTimer timeout to `reject()`.
- `showEvent` starts a 45-second auto-dismiss timer (`m_timer->start(45000)`).
- `hideEvent` stops the timer.
- The three private `show*Warning()` methods each return an HTML string containing safety-critical warning text.
- The `WarningDialogType` enum controls which message is shown.

---

### `utils/barcode128.h` + `utils/barcode128.cpp`

**Classes:** `BarcodeChar`, `Barcode128`

**Macros/constants defined (barcode128.cpp):**
- `START_CODE 104` — selects Code B (uppercase + lowercase + digits)
- `END_CODE 106`
- `MODULO_VAL 103`

**`BarcodeChar` public methods (barcode128.h):**

| Line | Method | Doc comment present |
|------|--------|---------------------|
| 10 | `BarcodeChar()` (default ctor) | No |
| 17 | `BarcodeChar(const BarcodeChar &other)` (copy ctor) | No |
| 24 | `BarcodeChar(int value, QString name, QString pattern)` (value ctor) | No |
| 31 | `BarcodeChar &operator=(const BarcodeChar &other)` | No |

**`Barcode128` public methods (barcode128.h):**

| Line | Method | Doc comment present |
|------|--------|---------------------|
| 50 | `Barcode128(const QString &info, int height = 100, int sizeMult = 2)` | No |
| 51 | `~Barcode128()` | No |
| 52 | `static int width(const QString &info, int sizeMult)` | No |
| 54 | `QPixmap pixmap()` | No |

**Signals/Slots:** None.
**Types/Enums:** None beyond the two classes.

**Implementation notes:**
- Constructor builds the barcode image into a `QImage` at construction time; `pixmap()` converts it.
- `width()` uses a fixed formula: `(info.length() * 11 + 13 + 11 + 11) * sizeMult + 30`. The magic numbers (11 modules per data char, 13 for start, 11 for checksum, 11 for stop, 30 for quiet zones) are undocumented.
- The `#define START_CODE 104` chooses Code B; there is a comment in Chinese noting type A/B/C, but no English explanation.
- The `.cpp` file has an inline comment `// 103 for type A (大写+数字), 104 for type B (大小写+数字), 105 for type C (数字)` on line 5 — this is the only documentation present for the mode selection.
- `initChars()` is gated on `START_CODE` via `#if`/`#elif`; the `#else` block is a stub with `// todo type c`.

---

### `utils/bytearray.h` (header-only)

**Class:** `ByteArray`

**Macros defined (lines 6–11):**
- `LE_INT(c1, c2, c3, c4)` — little-endian 32-bit integer assembly
- `BE_INT(c1, c2, c3, c4)` — big-endian 32-bit integer assembly
- `LE_SHORT(c1, c2)` — little-endian 16-bit integer assembly
- `BE_SHORT(c1, c2)` — big-endian 16-bit integer assembly
- `BE_LONG(c1, c2, c3, c4, c5, c6, c7, c8)` — big-endian 64-bit integer assembly

**`ByteArray` public static methods:**

| Line | Method | Doc comment present |
|------|--------|---------------------|
| 16 | `static QByteArray asprintf(const char *cformat, ...)` | Partial (inline comment line 15: "actually, do not recommend as not type safe") |
| 30 | `static int sscanf(const QByteArray &ba, const char *cformat, ...)` | Partial (inline comment line 29: "not recommend too") |

**Implementation notes — previously identified UB in `asprintf`:**
- Line 20: `va_start(ap, cformat)` is called to size the output.
- Line 21: `va_end(ap)` terminates the first va_list traversal.
- Line 25: `vsprintf(ba.data(), cformat, ap)` is called with `ap` **after** `va_end` — this is undefined behaviour (UB) per C standard; `va_list` must be re-initialized with `va_start` before reuse.
- The comment on line 15 says only "do not recommend as not type safe". The UB is **not documented or warned about**.
- The macros perform left-shift operations; `LE_INT` casts `c1` without `(uchar)`, meaning a signed `char` first argument would invoke UB via a left-shift of a negative value. This is also undocumented.
- `sscanf` uses `vsscanf` without a corresponding second `va_start`, but `va_end` is called at line 36 after the single `va_start` at line 33 — the `sscanf` variant does not re-use `ap` after `va_end`, so it does not share the same UB as `asprintf`.

---

### `utils/logger.h` + `utils/logger.cpp`

**Class:** `Logger` (singleton)

**Enum defined:**
- `LogLevel` (line 8, logger.h) — values: `LogDebug`, `LogInfo`, `LogWarning`, `LogCritical`, `LogFatal`, `LogNone`

**Public methods (logger.h):**

| Line | Method | Doc comment present |
|------|--------|---------------------|
| 13 | `static Logger* instance()` | No |
| 14 | `void close()` | No |
| 15 | `void setLogThreshold(LogLevel level)` | No |
| 16 | `LogLevel logThreshold() const` | No |
| 17 | `void log(LogLevel level, const QString &message)` | No |

**Protected methods (logger.h):**

| Line | Method | Doc comment present |
|------|--------|---------------------|
| 21 | `virtual ~Logger()` | No |
| 22 | `static void logMessageHandler(QtMsgType type, const QMessageLogContext &context, const QString &msg)` | No |

**Signals/Slots:** None.

**Implementation notes:**
- `instance()` is a non-thread-safe singleton (no mutex on construction, though `m_mutex` is used inside `log()`).
- `close()` deletes the singleton and sets `m_instance` to `nullptr`.
- Constructor opens a dated log file under `/mnt/sd` on ARM, `log.txt` otherwise; retains 7 days of logs.
- `logMessageHandler` is installed as the global Qt message handler, routing `qDebug`/`qWarning`/etc. to the file. On `QtFatalMsg` it calls `QCoreApplication::quit()`.
- The `log()` method is mutex-protected; `instance()` is not.
- The `#define LOG_FILE_DIR "/mnt/sd"` hardcodes the SD card path with no documentation.

---

### `utils/zconf.h` (third-party zlib 1.3.1)

Standard upstream zlib configuration header. No project-specific additions, modifications, or custom code were detected. The file matches the canonical zlib 1.3.1 release. No findings required.

---

### `utils/zlib.h` (third-party zlib 1.3.1)

Standard upstream zlib public interface header (version 1.3.1, January 22, 2024). No project-specific additions, modifications, or custom code were detected. No findings required.

---

## Findings

**A26-1** · LOW · `WarningDialog` constructor undocumented — safety-critical behaviour not described

**Description:** `WarningDialog::WarningDialog(WarningDialogType type, QWidget *parent)` has no doc comment. The constructor establishes a 45-second auto-dismiss timer (visible only in `showEvent`, not here) and connects the ACK button to `accept()`. The `type` parameter controls which legal/safety warning message is shown (VOR, Transport, or Maintenance). Because this dialog is displayed when a restricted operational mode is activated, developers unfamiliar with the code may not realise the dialog auto-dismisses (calling `reject()`) after 45 seconds, which has safety implications: the warning disappears even without operator acknowledgement.

**Fix:** Add a doc comment above the declaration in `warningdialog.h` that describes: (1) the `type` parameter and its effect on message content; (2) the auto-dismiss behaviour and its 45-second timeout; (3) that `accept` is returned when ACK is pressed and `reject` when the timer fires.

---

**A26-2** · LOW · `showEvent` timer start behaviour undocumented

**Description:** `WarningDialog::showEvent` is overridden to populate warning text and start the 45-second auto-dismiss timer. There is no doc comment on either the declaration (line 30, `warningdialog.h`) or in the implementation. The timer behaviour — that the dialog will auto-close even without user interaction — is a non-obvious side effect of `showEvent`.

**Fix:** Add a comment above the `showEvent` declaration explaining that it initialises the displayed warning message (based on `m_type`) and starts the auto-dismiss timer.

---

**A26-3** · LOW · `hideEvent` timer stop behaviour undocumented

**Description:** `WarningDialog::hideEvent` (line 29, `warningdialog.h`) stops the auto-dismiss timer. This pairing with `showEvent` is not obvious from the declaration. No comment exists.

**Fix:** Add a comment above the declaration noting that `hideEvent` stops the auto-dismiss timer to prevent spurious `reject()` calls if the dialog is hidden by other means.

---

**A26-4** · LOW · `Barcode128` constructor: magic numbers and encoding selection undocumented

**Description:** `Barcode128::Barcode128(const QString &info, int height, int sizeMult)` (line 50, `barcode128.h`) has no doc comment. The implementation hardcodes `START_CODE 104` (Code B) via a preprocessor define. The `height` and `sizeMult` parameters have no description. More critically, the encoding type (Code A / Code B / Code C) is controlled by a compile-time `#define` that can only be found in the `.cpp` file; this is not mentioned anywhere in the header or in any English comment.

**Fix:** Add a doc comment describing: `info` as the string to encode (Code B: printable ASCII); `height` as image height in pixels; `sizeMult` as the pixel width multiplier per module; and a note that the encoding type is fixed at compile time via `START_CODE` in `barcode128.cpp`.

---

**A26-5** · LOW · `Barcode128::width()` formula undocumented

**Description:** The static method `width(const QString &info, int sizeMult)` (line 52, `barcode128.h`) returns the pixel width required for a barcode image. The formula `(info.length() * 11 + 13 + 11 + 11) * sizeMult + 30` contains five magic numbers: 11 (modules per Code B character), 13 (start symbol modules), 11 (checksum character modules), 11 (stop symbol modules including termination bar), and 30 (quiet zone pixels — 15 each side). None of these are explained anywhere.

**Fix:** Add a doc comment above the declaration and/or a block comment in the implementation explaining each term in the width formula, referencing the Code 128 specification.

---

**A26-6** · HIGH · `ByteArray::asprintf` — undefined behaviour not documented; existing comment is misleading

**Description:** `ByteArray::asprintf` (line 16, `bytearray.h`) contains a critical undefined-behaviour bug: `va_end(ap)` is called on line 21 after the sizing call to `vsnprintf`, and then `vsprintf` is called on line 25 using the same `ap` without a second `va_start`. Per the C standard (C11 §7.16.1), using a `va_list` after `va_end` is undefined behaviour. The existing comment ("actually, do not recommend as not type safe") is inaccurate — the primary hazard is UB causing potential stack corruption, wrong output, or a crash, not merely type safety. Any caller that passes this function a format string with arguments may receive silently corrupted output or a crash, with no runtime indication.

**Fix:** At minimum, add a prominent warning comment directly above the function body describing the UB (use of `ap` after `va_end`) and directing callers to use `QString::asprintf` or `QByteArray::asprintf` (Qt 5.5+) instead. In a proper fix, the function body should re-initialize `ap` with a second `va_start` before the `vsprintf` call. Consider deprecating or removing this method entirely.

---

**A26-7** · MEDIUM · `ByteArray` macro `LE_INT` — missing cast on first argument creates latent sign-extension UB

**Description:** The macros `LE_INT`, `BE_INT`, `LE_SHORT`, and `BE_SHORT` (lines 6–9, `bytearray.h`) cast all arguments except the first (`c1`) with `(uchar)`. For `LE_INT`, the first operand `(c1)` is placed in the least-significant byte position via bitwise OR and is not shifted; however, for `BE_INT` and `BE_SHORT`, `c1` is left-shifted. If `c1` is a signed `char` holding a value above 0x7F, the left-shift of a negative integer is undefined behaviour (C++14 §5.8/2). None of the macros document their expected argument types or warn about this hazard. `BE_LONG` compounds this by deferring to `BE_INT`.

**Fix:** Add a comment block above these macros documenting that all arguments must be of type `unsigned char` (or be explicitly cast to `uchar` at the call site). Alternatively, add explicit `(uchar)` casts to all first arguments to eliminate the UB at the source.

---

**A26-8** · LOW · `Logger::instance()` — singleton thread-safety and lifetime not documented

**Description:** `Logger::instance()` (line 13, `logger.h`) has no doc comment. The implementation performs a non-atomic check-then-act on `m_instance` without holding `m_mutex`. While `log()` itself is mutex-protected, concurrent first calls to `instance()` from multiple threads could construct two `Logger` objects (double construction, double handler registration). The intended usage pattern — call `instance()` once from the main thread before spawning worker threads — is not documented anywhere.

**Fix:** Add a doc comment stating that `instance()` is not thread-safe for construction and must be called from the main thread before any threads that may call `log()` are started. Also document that `close()` must not be called while other threads may still be logging.

---

**A26-9** · LOW · `Logger::close()` — destruction semantics not documented

**Description:** `Logger::close()` (line 14, `logger.h`) deletes the singleton instance and resets `m_instance` to `nullptr`. This also restores the previous Qt message handler. There is no doc comment. Callers cannot know from the header that: (1) calling `close()` invalidates all subsequent `log()` calls (the file will not be open); (2) any queued Qt messages after `close()` will be silently dropped; (3) calling `instance()` after `close()` creates a new Logger instance with a fresh log file.

**Fix:** Add a doc comment noting that `close()` permanently shuts down the logger singleton, restores the previous Qt message handler, and that calling `instance()` afterwards will reopen/recreate the log file.

---

**A26-10** · LOW · `Logger::log()` — threshold semantics and thread-safety not documented

**Description:** `Logger::log(LogLevel level, const QString &message)` (line 17, `logger.h`) has no doc comment. The implementation silently discards messages below `m_logThreshold` and silently discards all messages if the log file is not open. The method is mutex-protected, but this is not stated in the header. Callers cannot know from the API contract that messages may be silently dropped.

**Fix:** Add a doc comment explaining: that messages with `level < logThreshold()` are silently discarded; that the method is thread-safe; and that if the log file failed to open at construction time, all calls are no-ops.

---

**A26-11** · INFO · `Logger::setLogThreshold()` / `logThreshold()` — no doc comment

**Description:** `setLogThreshold(LogLevel level)` (line 15) and `logThreshold() const` (line 16) in `logger.h` have no doc comments. These are simple setter/getter methods for the minimum logging level. The relationship between `LogLevel` enum values and their relative severity ordering is not documented.

**Fix:** Add a brief comment above the setter noting that only messages at or above `level` will be written to file, and documenting that the enum is ordered lowest-to-highest from `LogDebug` to `LogFatal`.

---

**A26-12** · INFO · `BarcodeChar` constructors — no doc comments

**Description:** The three constructors of `BarcodeChar` (default, copy, value-initialising) at lines 10, 17, and 24 of `barcode128.h` have no doc comments. As an internal helper class (`Barcode128` is declared `friend`), this is low severity, but the value constructor's parameter semantics (`value` = numeric Code 128 value, `name` = character name key, `pattern` = module width string of '1' and '0' characters) are not obvious.

**Fix:** Add a brief comment to the value constructor explaining the three parameters, particularly that `pattern` is a string of `'1'`s (bar) and `'0'`s (space) representing module widths in the Code 128 specification.

---

**A26-13** · INFO · `WarningDialog` private warning-message methods — no doc comments

**Description:** `showVorWarning()`, `showTransportWarning()`, and `showMaintenanceWarning()` (lines 24–26, `warningdialog.h`) are private methods with no doc comments. Each returns a complete HTML-formatted safety warning string. The return type `QString` and the HTML nature of the returned content are undocumented at the declaration site.

**Fix:** Add a single-line comment above each private method noting that it returns an HTML-formatted warning string for the respective mode. This aids maintainers who may need to update the warning text.

---

## Summary Table

| ID | Severity | Title |
|----|----------|-------|
| A26-1 | LOW | `WarningDialog` constructor undocumented — safety-critical auto-dismiss behaviour |
| A26-2 | LOW | `showEvent` timer-start behaviour undocumented |
| A26-3 | LOW | `hideEvent` timer-stop behaviour undocumented |
| A26-4 | LOW | `Barcode128` constructor: encoding type and parameter semantics undocumented |
| A26-5 | LOW | `Barcode128::width()` formula magic numbers undocumented |
| A26-6 | HIGH | `ByteArray::asprintf` — UB not documented; existing comment is misleading |
| A26-7 | MEDIUM | `ByteArray` endian macros — missing cast on first argument not warned about |
| A26-8 | LOW | `Logger::instance()` — singleton thread-safety and lifetime not documented |
| A26-9 | LOW | `Logger::close()` — destruction and re-creation semantics not documented |
| A26-10 | LOW | `Logger::log()` — silent-discard behaviour and thread-safety not documented |
| A26-11 | INFO | `Logger::setLogThreshold()` / `logThreshold()` — no doc comments |
| A26-12 | INFO | `BarcodeChar` value constructor parameters undocumented |
| A26-13 | INFO | `WarningDialog` private warning-message methods — no doc comments |
