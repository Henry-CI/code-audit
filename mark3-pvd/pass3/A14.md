# Pass 3 Agent A14 — Documentation

**Audit run:** 2026-02-28-01
**Branch:** master
**Files reviewed:**
- `platform/internalrfid.h`
- `platform/internalrfid.cpp`
- `platform/internalrtc.h`
- `platform/internalrtc.cpp`

---

## Reading Evidence

### `platform/internalrfid.h` — Class `EM070::InternalRfid`

**Class:** `EM070::InternalRfid` (inherits `QObject`)

**Public methods:**

| Line | Method | Doc comment present? |
|------|--------|----------------------|
| 14 | `explicit InternalRfid(QObject *parent = 0)` | No |
| 15 | `void setEnabled(bool enabled)` | No |

**Signals:**

| Line | Signal | Doc comment present? |
|------|--------|----------------------|
| 18 | `void response()` | No |
| 19 | `void cardData(quint64 wiegand, quint16 facility, quint32 number, QByteArray &readerOutput)` | No |
| 20 | `void error(const QString &text)` | No |

**Private methods (for implementation reference):**

| Line | Method |
|------|--------|
| 23 | `void readData()` |
| 24 | `void parseData()` |

**Types, enums, constants:** None defined in this header. The `.cpp` file defines:
- `FILE_SERIAL_PORT` — `"/dev/ttyS2"` (macro, line 7)
- `RECEIVER_MAX_SIZE` — `128` (macro, line 8)

---

### `platform/internalrtc.h` — Class `EM070::InternalRtc`

**Class:** `EM070::InternalRtc` (plain class, no QObject)

**Public methods:**

| Line | Method | Doc comment present? |
|------|--------|----------------------|
| 11 | `static void setRtcTime(QDateTime dateTime = QDateTime())` | No |
| 12 | `static void setSystemTime()` | Partial — inline comment only: `// no need to call this as which will be done on OS booting` |
| 13 | `static quint64 euiAddress()` | No |

**Signals/Slots:** None — class does not inherit QObject.

**Types, enums, constants:** None defined in this header. The `.cpp` file defines:
- `FILE_RTC_DEVICE` — `"/dev/rtc1"` (macro, line 5)
- `FILE_RTC_EUI` — `"/sys/devices/platform/nuc970-i2c0/i2c-0/0-006f/eui"` (macro, line 6)

---

## Documentation Findings

---

**A14-1** · HIGH · No documentation on `InternalRfid` constructor

**Description:** The constructor `InternalRfid(QObject *parent)` has no doc comment of any kind. The implementation is non-trivial: it reads the environment variable `QT_RFID_SERIAL_PORT` to optionally override the default serial port, configures the serial port at 115200 8N1, opens it for read/write, and connects the `readyRead` signal to the internal `readData` slot. The override mechanism via `QT_RFID_SERIAL_PORT` is particularly important for testing and deployment but is completely undocumented. Callers have no indication of what happens on construction failure (the port failing to open is silently swallowed after a `qCritical` log), nor that a post-construction check on port state may be necessary before relying on RFID reads.

**Fix:** Add a doc comment above the declaration explaining: (a) that the constructor opens and configures the serial port, (b) that the port name can be overridden via the `QT_RFID_SERIAL_PORT` environment variable, and (c) that if the port fails to open the object remains partially constructed and no signals will be emitted.

---

**A14-2** · HIGH · No documentation on `setEnabled(bool enabled)`

**Description:** `setEnabled` is the sole control surface for enabling or disabling RFID card reads. It transmits the AT command `AT+LFID=ON` or `AT+LFID=OFF` to the EM070 hardware module. There is no doc comment describing the parameter, the effect, the AT command protocol used, or the silent no-op behaviour when the serial port is not open. In an authentication system, enabling/disabling the RFID reader is a security-critical operation; an undocumented no-op when the port is closed could lead a caller to believe RFID is disabled when it is not (or vice versa).

**Fix:** Add a doc comment describing: (a) that `true` sends `AT+LFID=ON` and `false` sends `AT+LFID=OFF`, (b) that the method silently does nothing if the serial port is not open, and (c) the 10 ms blocking write wait.

---

**A14-3** · HIGH · No documentation on `cardData` signal

**Description:** `cardData(quint64 wiegand, quint16 facility, quint32 number, QByteArray &readerOutput)` is the primary signal carrying authenticated card identity information. It is emitted with different semantics depending on which card format was parsed:
- For `#6:` (26-bit Wiegand): `facility` is 8-bit (read into `quint8`, then widened), `number` is 16-bit.
- For `#8:` (34-bit Wiegand): `facility` is 16-bit, `number` is 16-bit (note: parsed into `quint32` but only 4 hex digits are read).
- For `#R:` raw Wiegand: `facility` and `number` are both 0; only `wiegand` carries data.
- For any other non-empty line: `wiegand`, `facility`, and `number` are all 0.

None of this is documented. Consumers of this signal cannot reliably distinguish these cases from the signal signature alone, which is a correctness and security risk.

**Fix:** Add a doc comment to the signal declaration in the header describing each parameter, the three distinct emission modes (26-bit, 34-bit, raw), the meaning of zero values for `facility`/`number` in the raw case, and the `readerOutput` parameter content (raw log bytes including `\r\n`).

---

**A14-4** · MEDIUM · No documentation on `response()` signal

**Description:** The `response()` signal is emitted when the string `"OK"` is received from the serial port. There is no doc comment explaining when this signal fires, what it means (acknowledgement of an AT command), or how callers are expected to use it in relation to `setEnabled()`. Without documentation, a caller cannot know whether to wait for this signal after calling `setEnabled()` or whether it serves another purpose.

**Fix:** Add a doc comment clarifying that `response()` is emitted when the hardware module responds with `"OK"`, typically as an acknowledgement of an AT command such as `AT+LFID=ON/OFF`.

---

**A14-5** · MEDIUM · No documentation on `error()` signal

**Description:** The `error(const QString &text)` signal is emitted when a non-empty card data line is received but cannot be successfully parsed (e.g. zero facility or number in a `#6:`/`#8:` record, unparseable hex in a `#R:` record). The `text` parameter carries the raw trimmed line from the hardware. There is no documentation describing when the signal fires, what `text` contains, or the distinction between a parse error and a hardware fault. This is relevant to security because repeated `error()` emissions could indicate tampering or a malfunctioning RFID module.

**Fix:** Add a doc comment clarifying that `error()` is emitted on parse failures, that `text` contains the raw hardware response line, and that it is not emitted for serial port I/O errors (those are logged via `qCritical`/`qWarning`).

---

**A14-6** · HIGH · No documentation on `setRtcTime(QDateTime dateTime)`

**Description:** `setRtcTime` performs two distinct privileged operations: (1) on ARM targets it calls `::stime()` to set the POSIX system clock (a privileged syscall), and (2) unconditionally it calls `hwclock -w -f /dev/rtc1` via `QProcess::execute()` to write the hardware RTC. The default parameter (`QDateTime()`) is an invalid `QDateTime`, meaning calling `setRtcTime()` with no argument skips the system clock update but still writes the hardware RTC from the current system time. This default-argument behaviour is subtle and potentially dangerous — a caller passing an invalid datetime does not set the system time yet does write back to the RTC. None of this is documented.

**Fix:** Add a doc comment describing: (a) what `setRtcTime` does with a valid vs. invalid (default) `QDateTime`, (b) that it calls `::stime()` on ARM, (c) that it always runs `hwclock -w` to sync the hardware RTC regardless of whether the datetime argument was valid, and (d) that elevated system privileges are required.

---

**A14-7** · LOW · Inaccurate/incomplete inline comment on `setSystemTime()`

**Description:** The sole documentation for `setSystemTime()` is the inline comment `// no need to call this as which will be done on OS booting`. This comment is grammatically malformed ("as which will be done") and is incomplete: it describes a usage constraint but says nothing about what the method actually does (reads the hardware RTC at `/dev/rtc1` via `hwclock -s` and sets the system clock from it). The comment also does not state whether the method is safe to call manually at runtime or whether calling it outside of boot could cause problems.

**Fix:** Replace the malformed inline comment with a proper doc comment explaining that this method reads `/dev/rtc1` via `hwclock -s` to synchronise the system clock to the hardware RTC, and that it is normally invoked automatically at boot. Clarify whether runtime calls are safe.

---

**A14-8** · HIGH · No documentation on `euiAddress()`

**Description:** `euiAddress()` reads the device's EUI-64 hardware identifier from the sysfs path `/sys/devices/platform/nuc970-i2c0/i2c-0/0-006f/eui`. This value is a globally unique device identity used for authentication and fleet tracking. The method returns `0` on any failure (file not found, read error, or hex parse failure). A return value of `0` is indistinguishable from a genuine parse result of zero and could silently propagate an invalid device identity through the system. There is no documentation on the method, its return value, the failure modes, or the security significance of the result.

**Fix:** Add a doc comment explaining: (a) that the returned value is the device EUI-64 address read from the RTC module via sysfs, (b) that `0` is returned on any failure (file not open, empty or non-hex content), (c) that callers must validate the return value is non-zero before using it for identity purposes, and (d) the sysfs path dependency.

---

## Summary Table

| ID | Severity | File | Subject |
|----|----------|------|---------|
| A14-1 | HIGH | `internalrfid.h:14` | `InternalRfid` constructor undocumented; silent failure mode and env-var override not described |
| A14-2 | HIGH | `internalrfid.h:15` | `setEnabled()` undocumented; silent no-op and AT command protocol not described |
| A14-3 | HIGH | `internalrfid.h:19` | `cardData` signal undocumented; three distinct emission modes with different parameter semantics |
| A14-4 | MEDIUM | `internalrfid.h:18` | `response()` signal undocumented; purpose and relationship to AT commands not described |
| A14-5 | MEDIUM | `internalrfid.h:20` | `error()` signal undocumented; trigger conditions and parameter content not described |
| A14-6 | HIGH | `internalrtc.h:11` | `setRtcTime()` undocumented; privileged syscall, RTC write, and default-argument behaviour not described |
| A14-7 | LOW | `internalrtc.h:12` | `setSystemTime()` has only a grammatically malformed, incomplete inline comment |
| A14-8 | HIGH | `internalrtc.h:13` | `euiAddress()` undocumented; failure returns 0 indistinguishable from valid zero; security-critical identity value |
