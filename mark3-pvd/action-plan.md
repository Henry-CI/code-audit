# Action Plan — mark3-pvd
**Branch:** master
**Audit date:** 2026-02-28
**Audit run:** 2026-02-28-01

## Summary

| Severity | Count |
|---|---|
| CRITICAL | 64 |
| HIGH | 509 |
| MEDIUM | 784 |
| LOW | 872 |
| INFO | 230 |

---

## Pass 1 — Security Findings

# Pass 1 Audit — A01
**Auditor:** A01
**Date:** 2026-02-28
**Branch:** master (confirmed via `git rev-parse --abbrev-ref HEAD`)
**Repo:** /c/Projects/cig-audit/repos/mark3-pvd

---

## File Inventory Note

`bitbucket-pipelines.yml` does not exist in this repository. The Bitbucket Pipelines subsection of the Communication Security checklist cannot be evaluated from a pipeline file. This absence is recorded here as required.

---

## Reading Evidence

### /c/Projects/cig-audit/repos/mark3-pvd/.gitignore

Rules and patterns (every line):

| Line | Pattern | Effect |
|------|---------|--------|
| 1 | `Makefile` | Ignores any file named `Makefile` |
| 2 | `FleetFocus` | Ignores the compiled binary named `FleetFocus` |
| 3 | `.*` | Ignores all dot-files (hidden files) |
| 4 | *(blank)* | — |
| 5 | `/tmp` | Ignores the `/tmp` directory at repo root |
| 6 | *(blank)* | — |
| 7 | `!.gitignore` | Exception: explicitly un-ignores `.gitignore` itself |
| 8 | `*.bak` | Ignores all `.bak` backup files |

---

### /c/Projects/cig-audit/repos/mark3-pvd/netcfg.json

Every key-value pair:

| Key | Value |
|-----|-------|
| `password` | `P@ssMK3!` |
| `ssid` | `cigSecureConnect` |

This file contains a Wi-Fi SSID and a plaintext Wi-Fi password committed directly to version control.

---

### /c/Projects/cig-audit/repos/mark3-pvd/run_tests

Every command and its purpose:

| Command / Element | Purpose |
|-------------------|---------|
| `#!/bin/sh` | Shebang — executes script with `/bin/sh` |
| `./FleetFocus` | Launches the compiled `FleetFocus` test binary from the current working directory |
| `\| awk '...'` | Pipes all output from `FleetFocus` into `awk` for colour-coded filtering |
| `/PASS/ {print "\033[32m" $0 "\033[0m"}` | Lines matching `PASS` are printed in green |
| `/FAIL/ {print "\033[31m" $0 "\033[0m"}` | Lines matching `FAIL` are printed in red |
| `/DEBUG/ {print $0}` | Lines matching `DEBUG` are printed as-is (comment notes yellow colouring from handler) |
| `/WARN/ {print $0}` | Lines matching `WARN` are printed as-is (comment notes magenta colouring from handler) |
| `!/PASS\|FAIL\|DEBUG\|WARN/ {print $0}` | All other lines are printed unchanged |

The script exists to run the test binary and produce human-readable, colour-coded pass/fail output. It does not perform any network operations, write to files, or handle user input.

---

## Security Review

### 1. Memory Safety

The three assigned files (`.gitignore`, `netcfg.json`, `run_tests`) contain no C++ source code. There are no buffer operations, pointer operations, string function calls, or memory allocations to evaluate in these files.

Memory Safety: no issues found.

---

### 2. Communication Security

**Bitbucket Pipelines:** `bitbucket-pipelines.yml` does not exist in this repository. No pipeline credentials or secret handling can be evaluated from that file.

The `netcfg.json` file contains a hardcoded Wi-Fi password committed to version control. See finding A01-1.

---

### 3. Input Handling

The `run_tests` script passes the raw output stream of `FleetFocus` through `awk` pattern matching. The `awk` script does not accept any external user input; it only reads from the binary's stdout. No injection vectors are present in the script itself.

The `netcfg.json` file is a static configuration file with two string fields. No parsing logic is visible in the assigned files.

Input Handling: no issues found in assigned files.

---

### 4. Build Security

The `.gitignore` file excludes the compiled binary `FleetFocus` and `Makefile` from version control, which is expected practice. No `.pro` file was assigned; compiler security flags cannot be assessed from these three files.

Build Security: no issues found in assigned files.

---

### 5. Device and Firmware

The `netcfg.json` file contains a provisioning-class credential (Wi-Fi password) committed directly to the repository. See finding A01-1. No `.pem`, `.crt`, `.key`, or `.p12` files were found among the assigned files.

The `.gitignore` rule `.*` suppresses all hidden files from version control. This means any sensitive hidden files (e.g., `.env`, `.npmrc`, SSH keys dropped into the repo root) would be silently excluded rather than explicitly blocked, which is a weak form of credential hygiene — the exclusion relies on the file being hidden rather than on explicit denial of known secret file patterns.

---

### 6. Qt-Specific Security

The assigned files contain no Qt source code, no `QProcess`, `QSettings`, `QSslSocket`, or QML usage.

Qt-Specific Security: no issues found in assigned files.

---

## Findings

**A01-1** · HIGH · Communication Security — Hardcoded Credential in Version Control
**File:** `netcfg.json:2`
**Description:** The file `netcfg.json` is committed to the repository and contains a plaintext Wi-Fi password (`P@ssMK3!`) and SSID (`cigSecureConnect`). Any person with read access to the repository (including all historical clones) has permanent access to this credential. On an embedded proximity-detection device this Wi-Fi credential is likely a production network password; exposure allows an attacker to join the device network, intercept or inject proximity events, and potentially pivot to other devices on the same segment. The credential cannot be rotated without a code change and another commit. The file should be removed from version control, added to `.gitignore`, and the password rotated immediately. Credentials should be injected at provisioning time or read from a secrets management system, not stored in the repository.

**A01-2** · LOW · Build Security — Weak .gitignore Credential Hygiene
**File:** `.gitignore:3`
**Description:** The rule `.*` excludes all dot-files from version control. While this prevents accidental commit of many hidden files, it relies on sensitive files being named with a leading dot rather than on explicit deny-listing of known secret file patterns (e.g., `*.pem`, `*.key`, `*.p12`, `.env`, `credentials.json`). If a developer places a credential file in the repo root with a non-hidden name (as already happened with `netcfg.json`), this rule provides no protection. The `.gitignore` should be augmented with explicit patterns for known credential and key file types to provide defence-in-depth.

**A01-3** · INFO · Communication Security — bitbucket-pipelines.yml Absent
**File:** *(file does not exist)*
**Description:** `bitbucket-pipelines.yml` is not present in this repository. It is not possible to verify whether CI/CD pipeline secrets (firmware signing keys, deployment credentials, device registration keys) are stored as Bitbucket repository variables rather than hardcoded in the pipeline definition. If a CI/CD pipeline exists for this project using an external configuration or a different CI system, that configuration should be reviewed separately.
# A02 — Build Configuration Security Audit
**Auditor:** Pass 1 A02
**Date:** 2026-02-28
**Branch:** master
**Files reviewed:** `mk3.pro`, `mk3-test.pro`

---

## Reading Evidence

### mk3.pro

**TARGET:** `FleetFocus`
**TEMPLATE:** `app`

**SOURCES:**
- `main.cpp`
- `mytranslator.cpp`
- `platform/internalrfid.cpp`
- `platform/wiegandrfid.cpp`
- `platform/pwmbeeper.cpp`
- `platform/pwmbacklight.cpp`
- `platform/internalrtc.cpp`
- `platform/powersupply.cpp`
- `platform/blecentral.cpp`
- `app/globalconfigs.cpp`
- `ui/amberimpactalertdialog.cpp`
- `ui/languagedialog.cpp`
- `ui/onScreenKeyboard.cpp`
- `ui/broadcastuidialog.cpp`
- `ui/pindialog.cpp`
- `ui/authoriseddialog.cpp`
- `ui/checkstartdialog.cpp`
- `ui/checkquestiondialog.cpp`
- `ui/checkconfirmationdialog.cpp`
- `ui/checkcompleteddialog.cpp`
- `ui/lockeddialog.cpp`
- `ui/supervisordialog.cpp`
- `ui/unlockeddialog.cpp`
- `ui/warningdialog.cpp`
- `utils/logger.cpp`
- `platform/canbus.cpp`
- `app/checklist.cpp`
- `app/driverlist.cpp`
- `app/crctable.cpp`
- `platform/gnssreceiver.cpp`
- `comm/canmonitor.cpp`
- `comm/canstatehandler.cpp`
- `comm/bleexpansion.cpp`
- `comm/bleexpansionuuid.cpp`
- `comm/bleinputhandler.cpp`
- `platform/modemport.cpp`
- `comm/modemchat.cpp`
- `app/backgroundworker.cpp`
- `platform/userport.cpp`
- `comm/gmtpchat.cpp`
- `comm/ntpsync.cpp`
- `ui/messagedialog.cpp`
- `ui/dialog.cpp`
- `comm/ftpclient.cpp`
- `platform/seriallogger.cpp`
- `platform/aescrypto.cpp`
- `comm/canexpansion.cpp`
- `ui/keyfilter.cpp`
- `ui/informationdialog.cpp`
- `utils/barcode128.cpp`
- `ui/ondemanddialog.cpp`
- `ui/optionalcheckconfirmationdialog.cpp`
- `platform/wifi.cpp`
- `ui/vorwarningdialog.cpp`
- `ui/vorconfirmationdialog.cpp`
- `ui/commentdialog.cpp`
- `ui/preopscreenoverlay.cpp`
- `ui/unlockreasondialog.cpp`

**HEADERS:**
- `mytranslator.h`
- `platform/internalrfid.h`
- `platform/wiegandrfid.h`
- `platform/pwmbeeper.h`
- `platform/pwmbacklight.h`
- `platform/internalrtc.h`
- `platform/powersupply.h`
- `ui/amberimpactalertdialog.h`
- `ui/languagedialog.h`
- `ui/onScreenKeyboard.h`
- `ui/supervisordialog.h`
- `ui/broadcastuidialog.h`
- `ui/warningdialog.h`
- `utils/logger.h` (listed twice)
- `platform/blecentral.h`
- `ui/pindialog.h`
- `ui/authoriseddialog.h`
- `ui/checkstartdialog.h`
- `ui/checkquestiondialog.h`
- `ui/checkconfirmationdialog.h`
- `ui/checkcompleteddialog.h`
- `ui/lockeddialog.h`
- `ui/unlockeddialog.h`
- `platform/canbus.h`
- `app/cigconfigs.h`
- `app/checklist.h`
- `app/driverlist.h`
- `app/globalconfigs.h`
- `comm/canmonitor.h`
- `comm/canstatehandler.h`
- `comm/bleexpansion.h`
- `comm/bleexpansionuuid.h`
- `comm/bleinputhandler.h`
- `platform/gnssreceiver.h`
- `platform/modemport.h`
- `comm/modemchat.h`
- `app/backgroundworker.h`
- `platform/userport.h`
- `comm/gmtpchat.h`
- `utils/bytearray.h`
- `comm/ntpsync.h`
- `ui/messagedialog.h`
- `ui/dialog.h`
- `comm/ftpclient.h`
- `platform/seriallogger.h`
- `platform/aescrypto.h`
- `comm/canexpansion.h`
- `ui/keyfilter.h`
- `ui/informationdialog.h`
- `utils/barcode128.h`
- `ui/ondemanddialog.h`
- `ui/optionalcheckconfirmationdialog.h`
- `platform/wifi.h`
- `ui/vorwarningdialog.h`
- `ui/vorconfirmationdialog.h`
- `ui/commentdialog.h`
- `ui/preopscreenoverlay.h`
- `ui/unlockreasondialog.h`

**LIBS:**
- `-L../sdk/3rd/lib` (linux-conditional; no specific `-l` library names specified in the .pro file itself)

**DEFINES:**
- `TEST_MODE=0`
- `QT_DEPRECATED_WARNINGS`

**QT modules:**
- `core`
- `gui`
- `serialport`
- `serialbus`
- `bluetooth`
- `network`
- `widgets` (Qt 5+)

**CONFIG entries:** None explicitly set (no `CONFIG +=` lines present)

**QMAKE_STRIP:** Not set

---

### mk3-test.pro

**TARGET:** `FleetFocus`
**TEMPLATE:** `app`

**SOURCES:** Same as mk3.pro plus:
- `test/test_ota.cpp`
- `test/test_dialog.cpp`
- `test/test_backgroundworker.cpp`
- `test/test_canbus.cpp`

**HEADERS:** Same as mk3.pro plus:
- `test/test_ota.h`
- `test/test_dialog.h`
- `test/test_backgroundworker.h`
- `test/test_canbus.h`

**LIBS:**
- `-L../sdk/3rd/lib` (linux-conditional; no specific `-l` library names)

**DEFINES:**
- `TEST_MODE=0`
- `UNIT_TEST`
- `QT_DEPRECATED_WARNINGS`

**QT modules:**
- `core`
- `gui`
- `serialport`
- `serialbus`
- `bluetooth`
- `network`
- `testlib`
- `widgets` (Qt 5+)

**CONFIG entries:** None explicitly set

**QMAKE_STRIP:** Not set

---

## Security Review

### 1. Memory Safety

Memory Safety: no issues found at the .pro file level. (Memory safety issues in source files are out of scope for this file assignment.)

### 2. Communication Security

Communication Security: no issues found at the .pro file level. (The presence of `comm/ftpclient.cpp`, `comm/gmtpchat.cpp`, `comm/modemchat.cpp`, and `comm/ntpsync.cpp` are noted as subjects requiring deeper source-level review in subsequent passes.)

### 3. Input Handling

Input Handling: no issues found at the .pro file level.

### 4. Build Security

**A02-1** · HIGH · Build Security — Missing stack protection flag
**File:** `mk3.pro:1`
**Description:** Neither `mk3.pro` nor `mk3-test.pro` sets `-fstack-protector-strong` via `QMAKE_CXXFLAGS`. Stack buffer overflows on this embedded device will not be detected at runtime. On a vehicle proximity detection device a stack smash could cause a silent crash or unsafe state with no trap.

**A02-2** · HIGH · Build Security — Missing FORTIFY_SOURCE
**File:** `mk3.pro:1`
**Description:** `-D_FORTIFY_SOURCE=2` is absent from `DEFINES` and `QMAKE_CXXFLAGS` in both .pro files. Standard library buffer overflow checks (e.g. for `memcpy`, `sprintf`) will not be enabled, removing a defence-in-depth layer for the embedded binary.

**A02-3** · HIGH · Build Security — Missing position-independent executable flags
**File:** `mk3.pro:1`
**Description:** Neither `-fPIE` nor `-pie` appear in either .pro file. Without PIE the binary cannot benefit from ASLR on Linux-based embedded targets, making exploitation of any memory corruption significantly easier.

**A02-4** · MEDIUM · Build Security — Missing format-string warning flags
**File:** `mk3.pro:1`
**Description:** `-Wformat` and `-Wformat-security` are not set in either .pro file. Format string vulnerabilities in `printf`/`qDebug` call sites will not be caught at compile time. The project includes `utils/logger.cpp` and multiple UI components that may pass dynamic strings to format functions.

**A02-5** · MEDIUM · Build Security — No explicit release CONFIG
**File:** `mk3.pro:1`
**Description:** Neither .pro file contains `CONFIG += release`. Without this, qmake may default to a debug build depending on the invoking environment, potentially shipping a debug-optimised binary with extra diagnostic output and without full optimisation. Production firmware builds should explicitly enforce `CONFIG += release`.

**A02-6** · MEDIUM · Build Security — QMAKE_STRIP not configured
**File:** `mk3.pro:1`
**Description:** `QMAKE_STRIP` is not set in `mk3.pro`. Debug symbols will not be stripped from the production binary unless the build environment provides a default strip step. Unstripped firmware shipped to the field exposes internal symbol names, function signatures, and string literals, aiding reverse engineering of the proximity detection logic and communication protocols.

**A02-7** · LOW · Build Security — Third-party SDK library path without explicit library names
**File:** `mk3.pro:15`
**Description:** `LIBS += -L../sdk/3rd/lib` adds a third-party library search path under a relative `../sdk` directory without specifying which libraries are linked (`-l` flags). Any library present in that path at build time will be silently available for linking. The contents and provenance of `../sdk/3rd/lib` cannot be audited from the repository alone, and the absence of explicit `-l` entries makes dependency tracking difficult.

### 5. Device and Firmware

Device and Firmware: no issues found at the .pro file level. (The presence of `platform/aescrypto.cpp` warrants source-level review in a subsequent pass to confirm key material is not hardcoded.)

### 6. Qt-Specific Security

Qt-Specific Security: no issues found at the .pro file level. (The `network` Qt module is included; TLS configuration in `comm/ftpclient.cpp` and `comm/gmtpchat.cpp` requires source-level review in a subsequent pass.)

---

## Summary

| ID | Severity | Category |
|----|----------|----------|
| A02-1 | HIGH | Missing `-fstack-protector-strong` |
| A02-2 | HIGH | Missing `-D_FORTIFY_SOURCE=2` |
| A02-3 | HIGH | Missing `-fPIE` / `-pie` |
| A02-4 | MEDIUM | Missing `-Wformat -Wformat-security` |
| A02-5 | MEDIUM | No `CONFIG += release` |
| A02-6 | MEDIUM | `QMAKE_STRIP` not set |
| A02-7 | LOW | Unspecified third-party SDK libraries |
# Pass 1 — Security Audit: A03
**Auditor:** A03
**Date:** 2026-02-28
**Branch:** master
**Scope:** `app/backgroundworker.h`, `app/backgroundworker.cpp`, `app/checklist.h`, `app/checklist.cpp`

---

## Step 4 — Reading Evidence

### File pair 1: backgroundworker.h / backgroundworker.cpp

**File paths:**
- `/c/Projects/cig-audit/repos/mark3-pvd/app/backgroundworker.h`
- `/c/Projects/cig-audit/repos/mark3-pvd/app/backgroundworker.cpp`

**Classes:**

`OtaWorker : public QObject`
- Q_OBJECT at line 40 (backgroundworker.h)
- Public methods:
  - `explicit OtaWorker(QObject *parent = nullptr)` — line 42
  - `void unpack()` — line 43
- Public member variables:
  - `QAtomicInteger<quint32> m_isRunning` — line 45
- Signals:
  - `void sendGmtpMessage(CIGCONF::GmtpMessage msg, const QByteArray &extra = QByteArray())` — line 48
  - `void started()` — line 49
  - `void ready()` — line 50
  - `void failed()` — line 51
- Private member variables:
  - `QMutex m_mutex` — line 58

`BackgroundWorker : public QObject`
- Q_OBJECT at line 64 (backgroundworker.h)
- Public methods:
  - `explicit BackgroundWorker(QObject *parent = nullptr)` — line 68
  - `void setUI(Dialog *ui)` — line 69
  - `bool networkStatus()` — line 70
- Signals (line 79–97):
  - `void powerStateChanged(CIGCONF::PowerState state)`
  - `void reboot()`
  - `void lockScreen(CIGCONF::MaintLockedCode code, bool remote)`
  - `void ambertImpactScreen()`
  - `void cardAuthorised(bool yes, quint64 id)`
  - `void updateStatusInfo(...)`
  - `void cmdMsgReceived(CIGCONF::BroadcastMessage m)`
  - `void onDemandStarted(quint32 start, quint32 end, quint64 id, CIGCONF::OnDemandCmdSrc)`
  - `void onDemandExtended(quint32 start, quint32 end, quint64 id, CIGCONF::OnDemandCmdSrc)`
  - `void onDemandEnded(quint32 end, quint64 id, CIGCONF::OnDemandCmdSrc)`
  - `void sigLanguageChanged()`
  - `void cmdLogin(quint64 id)`
  - `void unpackOta()`
  - `void cameraSettingsUpdated()`
- Private member variables (lines 142–192): raw pointers to EM070 platform objects, comm objects, timers, and config state

**#includes (backgroundworker.cpp):** `backgroundworker.h`, `utils/logger.h`, `platform/blecentral.h`, `platform/canbus.h`, `platform/gnssreceiver.h`, `platform/internalrtc.h`, `platform/modemport.h`, `platform/powersupply.h`, `platform/pwmbacklight.h`, `platform/pwmbeeper.h`, `platform/seriallogger.h`, `platform/userport.h`, `comm/bleexpansion.h`, `comm/bleinputhandler.h`, `comm/canmonitor.h`, `comm/canexpansion.h`, `comm/canstatehandler.h`, `comm/modemchat.h`, `comm/gmtpchat.h`, `comm/ntpsync.h`, `comm/ftpclient.h`, `app/globalconfigs.h`, `ui/dialog.h`, `mytranslator.h`, `<QApplication>`, `<QProcess>`, `<QFileInfo>`, `<QDebug>`, `<QLoggingCategory>`, `<QNetworkConfiguration>`, `<QFile>`, `<QStorageInfo>`, `<QThread>`, `<algorithm>`, `<math.h>`, `utils/zlib.h`, `<fcntl.h>`, conditionally `<unistd.h>`

---

### File pair 2: checklist.h / checklist.cpp

**File paths:**
- `/c/Projects/cig-audit/repos/mark3-pvd/app/checklist.h`
- `/c/Projects/cig-audit/repos/mark3-pvd/app/checklist.cpp`

**Class:** `Checklist` — no base class, no Q_OBJECT

**Public methods:**
- `Checklist()` — constructor, line 23 (h) / line 9 (cpp)
- `static bool isValidCheckItem(const CheckItem &item)` — line 25 (h)
- `void readChecklist()` — line 27 (h)
- `void saveChecklist()` — line 29 (h)
- `void clear()` — line 30 (h)
- `void shuffleChecklist()` — line 31 (h)
- `const CheckItem & checkItem(int index, bool query = false) const` — line 34 (h)
- `bool setCheckItem(int index, const CheckItem &item)` — line 35 (h)
- `quint32 checksum() const` — line 36 (h)

**Private methods:**
- `bool readChecklist50()` — line 39 (h)
- `bool readChecklist100()` — line 40 (h)
- `quint8 copyAllRandomPreop(CheckItem *randomPreop)` — line 41 (h)

**Private member variables:**
- `CheckItem m_checkItems[CHECKLIST_MAX_IDX]` — line 43 (h), CHECKLIST_MAX_IDX = 32
- `CheckItem m_checkItems_shuffled[CHECKLIST_MAX_IDX]` — line 44 (h)
- `bool m_dirty` — line 45 (h)
- `bool m_isShuffled` — line 46 (h)

**Inner struct CheckItem** (lines 9–21, h):
- Union of bitfield (qId:31, doNotRandomize:1) / quint32 questionId
- `CIGCONF::ChecklistType type`
- `quint8 questionLen`
- `char question[CHECKLIST_QUESTION_LEN_100+1]` = `char question[101]`

**Signals/Slots:** None (no Q_OBJECT)

**#includes (checklist.cpp):** `checklist.h`, `<QFile>`, `<QSaveFile>`, `<QDataStream>`, `<QTime>`, `app/globalconfigs.h`, `<algorithm>`

---

## Step 5 — Security Review

### 1. Memory Safety

**A03-1** · MEDIUM · Memory Safety
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/app/backgroundworker.cpp:1148`
**Description:** `qstrcpy(item.question, args.at(argIndex).constData())` is called without verifying the destination buffer size beyond the `questionLen` check. The check on line 1145 (`item.questionLen > CHECKLIST_QUESTION_LEN_100`) validates the `size()` of the QByteArray, but `qstrcpy` copies until the null terminator of the source C-string. If the source data from `args.at(argIndex)` contains embedded null bytes before its reported length, or if Qt's `QByteArray::size()` and `constData()` mismatch expectations, the behavior could diverge. More critically, `qstrcpy` is an unbounded copy function equivalent to `strcpy` — if the preceding length check is ever bypassed or miscounted (e.g. due to off-by-one in the split), the 101-byte `question` buffer can overflow. The bounded alternative `qstrncpy` or `memcpy` with the validated length should be used.

**A03-2** · MEDIUM · Memory Safety
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/app/backgroundworker.cpp:59-60`
**Description:** `static const int CHUNK_SIZE = ZLIB_BUF_SZ;` where `ZLIB_BUF_SZ = 500*1024 = 512000 bytes`. The variable `char out[CHUNK_SIZE]` is declared as a stack-allocated array of 500 KB inside `streamUncompress()`. On an embedded ARM device with limited stack space this allocation is extremely large and risks a stack overflow, particularly because this function is called in a loop from `OtaWorker::unpack()` (lines 221–226). Stack overflows on embedded devices can lead to silent data corruption or crashes.

**A03-3** · LOW · Memory Safety
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/app/checklist.cpp:219`
**Description:** `std::rotate(&randomPreop[0], &randomPreop[rotateNum], &randomPreop[numberOfRandomPreop-1])` — the third argument is `numberOfRandomPreop - 1` rather than `numberOfRandomPreop`. For an array segment of length `n`, `std::rotate` end-iterator should point one past the last element, i.e. `&randomPreop[numberOfRandomPreop]`. Using `numberOfRandomPreop - 1` excludes the last element from the rotation. While not a buffer overread, this is a logic defect in safety-critical checklist ordering that could result in one question never being rotated, weakening the randomisation guarantee.

**A03-4** · LOW · Memory Safety
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/app/checklist.cpp:222-223`
**Description:** In `shuffleChecklist()`, `randomPreopIndex` is incremented without bounds checking: `m_checkItems_shuffled[n] = randomPreop[randomPreopIndex++]`. The array `randomPreop` has `CHECKLIST_MAX_IDX` (32) elements and was populated with `numberOfRandomPreop` items. The loop over `m_checkItems_shuffled` runs up to `CHECKLIST_MAX_IDX` iterations. If `doNotRandomize` is 0 for more slots than `numberOfRandomPreop` items were copied, `randomPreopIndex` will exceed `numberOfRandomPreop` and access uninitialized memory in `randomPreop` beyond the populated range.

**A03-5** · LOW · Memory Safety
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/app/checklist.cpp:54-55`
**Description:** In `readChecklist50()`, `stream.readRawData(m_checkItems[index].question, CHECKLIST_QUESTION_LEN)` always reads exactly `CHECKLIST_QUESTION_LEN` (50) bytes into the buffer. The buffer `question` is `CHECKLIST_QUESTION_LEN_100 + 1` (101) bytes, so the capacity is sufficient. However, immediately after, `m_checkItems[index].question[len] = 0` places a null terminator at offset `len`, where `len` has been validated only to be `<= CHECKLIST_QUESTION_LEN` (50). The maximum valid index for the null write is 50, which is within the 101-byte buffer. This is safe, but the logic relies on `readRawData` always reading exactly 50 bytes; if the stream is truncated, the remainder of the buffer is left with stale data and the `len`-offset null terminator may not be at the end of actual content. No check is made on the return value of `readRawData`.

**A03-6** · INFO · Memory Safety
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/app/backgroundworker.cpp:187-188`
**Description:** The OTA firmware header is parsed using direct `reinterpret_cast` pointer arithmetic against a raw `QByteArray` buffer: `*(reinterpret_cast<const quint32 *>(ba.constData()))` and `*(reinterpret_cast<const quint32 *>(ba.constData() + 4))`. The file size is checked to be at least 8 bytes (line 173) before this read occurs, so an underflow is not possible here. This is noted as an INFO item because pointer aliasing via reinterpret_cast violates strict aliasing rules in C++ and could in principle result in undefined behaviour on some compilers, but in practice Qt's `QByteArray` provides contiguous storage and this is a common embedded pattern.

---

### 2. Communication Security

**A03-7** · HIGH · Communication Security
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/app/backgroundworker.cpp:567-586`
**Description:** The `CMD_FTPF` command handler constructs an FTP URL from network-supplied content (lines 571–584). The URL scheme is hardcoded as `"ftp"` — an unencrypted, cleartext protocol. FTP transmits credentials (username and password, provided in `args.at(2)` and `args.at(3)`) and file data in plaintext. On a vehicle proximity detection device, firmware update files and any associated credentials are transmitted without confidentiality or integrity protection. An attacker with network access can intercept FTP credentials or inject a malicious firmware image. SFTP or FTPS should be used instead.

**A03-8** · MEDIUM · Communication Security
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/app/backgroundworker.cpp:643`
**Description:** `QProcess::startDetached("/etc/pvd/sdcard -format")` — the path `/etc/pvd/sdcard` is hardcoded. While the command itself is hardcoded and not user-controllable, the hardcoded path to the SD card format script is a device-specific configuration detail that is baked into firmware and cannot be changed without a firmware update. This is an INFO-level concern for maintainability but also a LOW security concern if an attacker can replace the `/etc/pvd/sdcard` binary (implying filesystem write access).

**A03-9** · MEDIUM · Communication Security
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/app/backgroundworker.cpp:1663-1667`
**Description:** The `CMD_WIFI` query handler returns the Wi-Fi network password in cleartext over the serial user port: `network.pw.constData()` is included in the `^WIFI:` response string. Wi-Fi passwords stored in configuration and transmitted over the serial RS-232 accessory port are exposed in plaintext. Any party with access to the serial port (e.g. via the RS-232 accessory interface) can retrieve all stored Wi-Fi credentials.

---

### 3. Input Handling

**A03-10** · HIGH · Input Handling
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/app/backgroundworker.cpp:1405-1411`
**Description:** In the `CMD_CANCFG` handler, a shell command string is constructed using `QStringLiteral` with `arg()` substitutions (line 1405): `QStringLiteral("/bin/sh -c \"/bin/sed -i 's,.*set can%1.*,/home/bin/ip link set can%1 up type can bitrate %2,' /etc/pvd/can\"").arg(CanBus::CAN1).arg(baudRate)`. The value `CanBus::CAN1` is a compile-time constant so it is safe. However, the constructed command is passed to `QProcess::start(cmd)` as a single string (line 1407) rather than as a list of arguments. This invokes the shell with the full command string. While `baudRate` is validated to be a numeric `quint32 <= 1000000` (lines 1401–1403), using `QProcess::start()` with a shell-interpolated string introduces shell-injection risk if the validation is ever loosened or bypassed. The pattern of constructing shell command strings and executing them via `/bin/sh -c` should be replaced with explicit argument lists to `QProcess`.

**A03-11** · MEDIUM · Input Handling
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/app/backgroundworker.cpp:1804`
**Description:** `CMD_MDMAT` passes network-received `content` directly to `m_modemPort->sendCmd(content)` without any sanitisation or validation of the content (line 1804). This command relays arbitrary AT commands directly to the modem hardware. An attacker who can send a GMTP `MDMAT` command (i.e., any server-side entity or a man-in-the-middle on the GMTP channel) can issue arbitrary AT commands to the modem, including commands that change APN settings, disable the modem, or exfiltrate SIM information.

**A03-12** · MEDIUM · Input Handling
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/app/backgroundworker.cpp:444`
**Description:** `qDebug() << "LEADER CMD < " << ba;` at the entry of `parseLeaderCmd()` logs the full contents of every received command — including those received from the GMTP server (remote commands) — to the debug output. Since `ba` can contain arbitrary data from the network, this is an information-disclosure risk if debug output is accessible in production builds and a format-string concern if `qDebug` with `<<` is ever changed to a printf-style call. In the current form the `<<` operator is safe against format strings, but logging raw network data to a debug channel in a production device is inadvisable.

**A03-13** · LOW · Input Handling
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/app/checklist.cpp:34,77`
**Description:** The number of checklist items to parse is calculated as `int num = ba.size() / CHECKLIST_ITEM_SIZE` (and `/ CHECKLIST_ITEM_SIZE_100`). If the file contains more entries than `CHECKLIST_MAX_IDX`, the loop will attempt to process them all, but the index validation `if (!index || index > CHECKLIST_MAX_IDX) break;` will terminate the loop early on any out-of-range index. This is adequate but the total iteration bound is not explicitly capped at `CHECKLIST_MAX_IDX`, so a malformed or oversized checklist file causes the loop to iterate up to `ba.size() / item_size` times before a termination condition is hit. For large files this wastes time; more importantly, it means the file size is not validated against a maximum before parsing begins.

**A03-14** · LOW · Input Handling
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/app/checklist.cpp:238-242`
**Description:** `Checklist::checkItem(int index, bool query)` does not perform bounds-checking on `index`. The method accesses `m_checkItems[index]` and `m_checkItems_shuffled[index]` directly (lines 240–241) without verifying `0 <= index < CHECKLIST_MAX_IDX`. While `setCheckItem` does check bounds, all call sites of `checkItem` are responsible for ensuring a valid index. A call with an out-of-range index results in undefined behaviour (array out-of-bounds access).

---

### 4. Build Security

Build security (compiler flags, `.pro` file) is not applicable to the `.cpp` and `.h` files in scope for this assignment. No inline security-relevant build flags or conditional compilation anomalies beyond the `UNIT_TEST` guards (which are acceptable) were observed.

---

### 5. Device and Firmware

**A03-15** · HIGH · Device and Firmware
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/app/backgroundworker.cpp:189`
**Description:** The OTA firmware integrity check (`OtaWorker::unpack()`) uses only a CRC-16 (lines 236–244) and a 16-bit magic value embedded in the firmware header to validate that a downloaded firmware image is authentic before writing it to `/home/FleetFocusOTA`. CRC-16 detects accidental corruption but provides no cryptographic authenticity guarantee. An attacker who can place a file at `FILE_FLEETMS_FW` (the FTP download location) can craft a malicious firmware image with a matching CRC-16 and magic value. There is no firmware signing or cryptographic hash verification. For a safety-critical proximity detection device, firmware authenticity must be verified with a cryptographic signature before installation.

**A03-16** · MEDIUM · Device and Firmware
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/app/backgroundworker.cpp:198,202,205,254`
**Description:** OTA firmware update writes to hardcoded paths: `/home/FleetFocus`, `/home/FleetFocusOTA`, `/home/FleetFocusTemp`. These paths are embedded in the firmware binary. If the `/home` filesystem is writable by unprivileged processes or accessible via the FTP download mechanism, a malicious actor could pre-place files at these paths to interfere with the update logic (e.g. pre-existing `/home/FleetFocusOTA` triggers a FOTA failure alert, as seen in `checkFotaFail()` at line 3319). The hardcoded deployment paths also prevent environment separation.

**A03-17** · LOW · Device and Firmware
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/app/backgroundworker.cpp:1350-1370`
**Description:** `CMD_DEBUG` allows a remote GMTP command to enable verbose debug output (including CAN SPN debug data) and set internal debug mode levels. There is no authentication check specific to this command beyond the general GMTP session being established. Enabling debug mode on a production device via a remote command can expose internal device state and increase attack surface. Debug commands that alter device behaviour should be disabled or require elevated authentication in production firmware.

---

### 6. Qt-Specific Security

**A03-18** · HIGH · Qt-Specific Security
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/app/backgroundworker.cpp:227,241`
**Description:** `QProcess::execute("sh", QStringList() << "-c" << "echo 1 > /proc/sys/vm/drop_caches")` is called twice inside `OtaWorker::unpack()` — once in the decompression loop (line 227) and once in the CRC verification loop (line 241). This spawns a shell process (`sh -c`) that writes to a Linux kernel pseudo-file. Although the command string itself is a hardcoded literal and not attacker-controlled, spawning a shell inside a firmware update loop on an embedded device is an unusual pattern and creates an attack surface if the `PATH` or shell environment is tampered with. More significantly, `QProcess::execute` blocks the calling thread; in the OTA thread context this is acceptable but interacts poorly with the `QMutex` held throughout `unpack()`.

**A03-19** · HIGH · Qt-Specific Security
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/app/backgroundworker.cpp:3161-3165`
**Description:** `QProcess::execute("/etc/pvd/kill_udhcpc_wwan0")` and `QProcess::execute("udhcpc -b -p /var/run/dhcp_wwan0_pid -i wwan0")` are called with hardcoded command strings (not via argument lists). The second call, `"udhcpc -b ..."`, passes a single string to `QProcess::execute`, which on Qt uses the shell to parse it. If the `PATH` environment is attacker-influenced, or if shell metacharacters can be introduced into these strings, command injection is possible. The correct form is `QProcess::execute("udhcpc", QStringList() << "-b" << ...)`.

**A03-20** · MEDIUM · Qt-Specific Security
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/app/backgroundworker.cpp:1612`
**Description:** `QProcess::startDetached("/etc/pvd/ramdisk")` is invoked by `CMD_DBGRAM`, a remote GMTP command. The command is a debug/diagnostic function that can be triggered remotely without additional authentication. `startDetached` launches the process in a detached state and the calling application has no visibility into its success or output. If `/etc/pvd/ramdisk` can be replaced or if the command has unintended side effects, this provides a remote code execution vector for authenticated GMTP server sessions.

**A03-21** · LOW · Qt-Specific Security
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/app/backgroundworker.cpp:57-58`
**Description:** The `streamUncompress` function uses `static bool headerSkipped = false` and the `z_stream strm` is initialised by checking `strm.state == nullptr` (line 63). These are function-level statics, which means they persist across calls and are not thread-safe without synchronisation. `streamUncompress` is called from `OtaWorker::unpack()`, which runs in a dedicated thread (`m_otaThread`). If `unpack()` is ever invoked concurrently (the `QMutex` in `OtaWorker` protects against this, but the static is global to all calls), the static state could be corrupted between calls. The use of static local variables for streaming state in what is logically a per-call operation is a design fragility.

---

## Summary of Findings

| ID | Severity | Category |
|---|---|---|
| A03-1 | MEDIUM | Memory Safety — qstrcpy without bounded copy |
| A03-2 | MEDIUM | Memory Safety — 500 KB stack allocation in embedded loop |
| A03-3 | LOW | Memory Safety — off-by-one in std::rotate end iterator |
| A03-4 | LOW | Memory Safety — randomPreopIndex unbounded in shuffleChecklist |
| A03-5 | LOW | Memory Safety — readRawData return value not checked |
| A03-6 | INFO | Memory Safety — reinterpret_cast aliasing (accepted embedded pattern) |
| A03-7 | HIGH | Communication Security — FTP used for firmware update (plaintext, no integrity) |
| A03-8 | MEDIUM | Communication Security — Wi-Fi password returned in plaintext over serial |
| A03-9 | MEDIUM | Communication Security — hardcoded paths to network config scripts |
| A03-10 | HIGH | Input Handling — shell command constructed with arg() and executed via /bin/sh |
| A03-11 | MEDIUM | Input Handling — arbitrary AT commands forwarded to modem via MDMAT |
| A03-12 | MEDIUM | Input Handling — raw network data logged via qDebug in production |
| A03-13 | LOW | Input Handling — checklist file size not bounded before parse loop |
| A03-14 | LOW | Input Handling — checkItem() has no bounds check on index parameter |
| A03-15 | HIGH | Device and Firmware — OTA authenticated only by CRC-16, no cryptographic signing |
| A03-16 | MEDIUM | Device and Firmware — OTA writes to hardcoded /home paths |
| A03-17 | LOW | Device and Firmware — CMD_DEBUG remotely enables debug mode without elevated auth |
| A03-18 | HIGH | Qt-Specific Security — QProcess spawning shell inside OTA update loop |
| A03-19 | HIGH | Qt-Specific Security — QProcess::execute with single-string shell commands |
| A03-20 | MEDIUM | Qt-Specific Security — CMD_DBGRAM triggers QProcess::startDetached remotely |
| A03-21 | LOW | Qt-Specific Security — static local variables in streamUncompress not thread-safe by design |
# Pass 1 — A04 Security Audit
**Auditor:** A04
**Date:** 2026-02-28
**Branch:** master (confirmed)
**Files reviewed:**
- `/c/Projects/cig-audit/repos/mark3-pvd/app/cigconfigs.h`
- `/c/Projects/cig-audit/repos/mark3-pvd/app/crctable.cpp`
- `/c/Projects/cig-audit/repos/mark3-pvd/app/driverlist.h`
- `/c/Projects/cig-audit/repos/mark3-pvd/app/driverlist.cpp`

---

## Reading Evidence

### File: `/c/Projects/cig-audit/repos/mark3-pvd/app/cigconfigs.h`

**Class name and base classes:** None — this is a pure header file (no class). Contains a namespace `CIGCONF` with enums and structs.

**Public methods:** None (no class).

**Signals and slots:** None.

**`#include` directives:**
- Line 4: `#include <QtGlobal>`
- Line 5: `#include <QByteArray>`
- Line 6: `#include <QString>`

**`Q_OBJECT` macro:** Not present.

**Constants and `#define`s:**
- Line 8: `#define LFF_VERSION 5`
- Line 9: `#define SFF_VERSION 2`
- Line 10: `#define UFF_VERSION 2`
- Line 11: `#define ENG_VERSION "J"`
- Line 12: `#define F_BUILD 6`
- Line 13: `#define C_BUILD 5`
- Line 15: `#define BROADCASTMSG_TEXT_LEN 100`
- Line 17: `#define GMTP_ID_LEN 33`
- Line 18: `#define GMTP_SERVER_CNT 3`
- Line 19: `#define SERVER_ADDR_LEN 33`
- Line 20: `#define MODEM_DIAL_NUMBER_LEN 9`
- Line 21: `#define MODEM_APN_LEN 33`
- Line 22: `#define MODEM_APN_USER_LEN 33`
- Line 23: `#define MODEM_ICCID_LEN 32`
- Line 24: `#define MODEM_APN_PASSWORD_LEN 66`
- Line 26: `#define MAX_POLY_POINTS (6)`
- Line 27: `#define MAX_POLY (4)`
- Line 29: `#define CHECKLIST_TIME_SLOTS 4`
- Line 30: `#define CHECKLIST_MAX_IDX 32`
- Line 31: `#define CHECKLIST_QUESTION_LEN 50`
- Line 32: `#define CHECKLIST_ITEM_SIZE (5 + CHECKLIST_QUESTION_LEN)`
- Line 33: `#define CHECKLIST_QUESTION_LEN_100 100`
- Line 34: `#define CHECKLIST_ITEM_SIZE_100 (7 + CHECKLIST_QUESTION_LEN_100)`
- Line 36: `#define DRIVER_MAX_ID_IDX 3000`
- Line 37: `#define MASTER_MAX_ID_IDX 1024`
- Line 38: `#define SUPER_MAX_ID_IDX 100`
- Line 39: `#define TECH_MAX_ID_IDX 1000`
- Line 42: `#define CAN_MAX_HW_PGN 5`
- Line 43: `#define CAN_MAX_PGN_IDX 10`
- Line 44: `#define CAN_MAX_SPN_IDX 20`
- Line 45: `#define CAN_MAX_LINK_IDX 8`
- Line 46: `#define CAN_MAX_ATT_IDX 15`
- Line 47: `#define CAN_ATT_NAME_LEN 10`
- Line 48: `#define CAN_MSG_TYPE 0x02`
- Line 49: `#define CAN_MSG_DLC 0x8`
- Line 50: `#define CAN_SIG_STATUS 0x01`
- Line 53: `#define ON_DEMAND_DURATION (24*60*60)`
- Line 56: `#define WIFI_MAX_NETWORKS 10`
- Line 57: `#define WIFI_CONF_FILE "/etc/wpa_supplicant.conf"`
- Line 64: `#define FILE_DRIVER_IDS "/home/dlist.txt"`
- Line 65: `#define FILE_MASTER_IDS "/home/mlist.txt"`
- Line 66: `#define FILE_SUPER_IDS "/home/slist.txt"`
- Line 67: `#define FILE_TECH_IDS "/home/tlist.txt"`
- Line 68: `#define FILE_CHECKLIST "/home/PREOP.TXT"`
- Line 69: `#define FILE_CHECKLIST_100 "/home/PREOP100.TXT"`
- Line 70: `#define FILE_FLEETMS_FW "/mnt/sd/FleetIQ360App"`
- Line 71: `#define FILE_FLEETMS_FW_RD "/mnt/ramdisk/FleetIQ360App"`
- Line 72: `#define FILE_LOGIN_SCREEN "/home/login.png"`
- Line 73: `#define FILE_LOGIN_SCREEN_RD "/mnt/ramdisk/login.png"`
- Line 74: `#define FILE_ONCEPERDAY_PREOP_IDS "/home/opdPreopDlist.txt"`
- Line 76: `#define DIR_GMTP_MSG "/mnt/sd"`
- Line 81: `#define SHOW_ALL_MASTER_MENU 255`

**Enums (in namespace `CIGCONF`):**
- `MasterMenuOptions` (line 83): `UnlockVehicle=1`, `NormalDriverAccess=2`, `ActivateVOR=4`, `MaintenanceMode=8`, `DefaultMasterMenu=7`, `UnassignedMasterMenu=255`
- `PowerState` (line 86): `NormalPowerState`, `PreDimState`, `DimState`, `SleepActiveState`, `SleepState`, `PowerOffState`
- `ConfigErrorCode` (line 88): `NoConfigError`, `ConfigCrcError`, `ConfigAddressError`, `ConfigSizeError`, `ConfigSectorError`
- `FtpErrorCode` (line 90): `NoFtpError`, `FtpGenericError`, `FtpServerError`, `FtpIncompleteFileError`, `FtpSaveFileError`, `FtpNoFileError`, `FtpOSError`, `FtpParamError`, `FtpCorruptFileError`, `FtpRetryExceedError`
- `LeaderCmdType` (line 93): `QueryCmd`, `RemoteSetCmd`, `LocalSetCmd`
- `UnlockReasonScreen` (line 95): `Disabled`, `EnabledOptional`, `EnabledMandatory`
- `RealImpact` (line 97): `Unconfirmed`, `No`, `Yes`
- `DigitalInputMode` (line 99): `Default`, `Overload`, `Battery`, `SeenSafety`
- `LeaderCmd` (lines 101–126): extensive command set including `CMD_DEBUG`, `CMD_DBGPWR`, `CMD_DBGBLE`, `CMD_DBGRAM`, `CMD_UNKNOWN=0xff`, etc.
- `GmtpMessage` (lines 128–133)
- `CheckReason` (line 135), `CheckResponses` (line 136), `ChecklistType` (line 137)
- `OnDemandCmdType` (line 139), `OnDemandCmdSrc` (line 140)
- `MaintLockedCode` (lines 142–148): includes `MaintIdle=0xea`, `MaintCriticalQuestion=0xfb`, `MaintRedImpact=0xfd`, `MaintSurveyTimeout=0xfe`
- `ShowTimeFormat` (lines 150–154)
- `BleExpansionDI`, `BleExpansionRelay`, `BleExpansionConnectionStatus` (lines 156–158)
- `CanProtocol` (line 160): `LindeNormal`, `J1939`, `LindeExtended`, `BydCan`, `Linde1202`
- `CanAttributeType` (lines 162–169)
- `WifiPosSource` (line 171)
- `CameraMode` (line 173)

**Structs (in namespace `CIGCONF`):**
- `CanMsgLink` (line 175): `quint16 spnIndex`, `quint8 pos`
- `CanMsgPara` (line 180): `quint32 identifier`, `quint8 type`, `quint8 dlc`, `quint8 sigNum`, `CanMsgLink sigList[CAN_MAX_LINK_IDX]`
- `CanSigPara` (line 188): `quint8 status`, `quint8 width`, `qint32 addr32`, `void *unused2`
- `CigCanConfig` (line 195): `quint8 processType`, `quint8 txEnable`, nested `busInfo` struct, union containing `CanSignalInfo` with `canMsg[CAN_MAX_PGN_IDX]`, `canSig[CAN_MAX_SPN_IDX]`, `spnInfo[CAN_MAX_SPN_IDX]`, `canAtt[CAN_MAX_ATT_IDX]`, `pgnRequestTicks[CAN_MAX_PGN_IDX]`
- `BroadcastMessage` (line 245): `quint32 id`, `QByteArray text`, `quint8 type`, `quint8 res`, `quint32 timeout`
- `WifiNetwork` (line 254): `QByteArray ssid`, `QByteArray pw`
- `PreopDriverId` (line 260): `quint64 id`, `quint32 lastPreopTimestamp`
- `DriverId` (line 265): `quint64 id`, `QString name`
- `MasterId` (line 270): `quint64 id`, `quint8 option`, `QString name`
- `gpsPosStruct` (line 276): `qint32 latitude`, `qint32 longitude`
- `polygonStruct` (line 281): `quint8 nPoints`, `gpsPosStruct polyVertices[MAX_POLY_POINTS]`
- `position` (line 287): `double lat`, `double lon`, `double latrad`, `double lonrad`
- `AccessPoint` (line 295): `QByteArray mac`, `double rssi`, `quint32 lastSeen`, `QByteArray ssid`, `quint32 channel`
- `CheckResponse` (line 304): `quint32 id`, `quint16 type`, `quint16 response`, `QString text`

**Member variables:** None (no class).

---

### File: `/c/Projects/cig-audit/repos/mark3-pvd/app/crctable.cpp`

**Class name and base classes:** None — standalone translation unit, no class.

**Public methods:** None.

**Signals and slots:** None.

**`#include` directives:**
- Line 1: `#include <QtGlobal>`

**`Q_OBJECT` macro:** Not present.

**Constants and `#define`s:** None.

**Declarations and definitions:**
- Line 3: `extern const quint32 crc32Table[];` (forward declaration)
- Line 4: `extern const quint16 crc16Table[];` (forward declaration)
- Line 6: `const quint32 crc32Table[256]` — 256-entry CRC32 lookup table
- Line 41: `const quint16 crc16Table[16]` — 16-entry CRC16 lookup table

**Member variables:** None (no class).

---

### File: `/c/Projects/cig-audit/repos/mark3-pvd/app/driverlist.h`

**Class name and base classes:** `DriverList` — no base class (not a QObject).

**`#include` directives:**
- Line 4: `#include <QtGlobal>`
- Line 5: `#include <QList>`
- Line 6: `#include "app/cigconfigs.h"`
- Line 7: `#include <QDebug>`

**`Q_OBJECT` macro:** Not present.

**Public methods (with line numbers):**
- Line 12: `DriverList()`
- Line 14: `void readDriverIds()`
- Line 15: `void readMasterIds()`
- Line 16: `void readSuperIds()`
- Line 17: `void readTechIds()`
- Line 18: `void saveDriverIds()`
- Line 19: `void saveMasterIds()`
- Line 20: `void saveSuperIds()`
- Line 21: `void saveTechIds()`
- Line 22: `void readPreopDriverIds()`
- Line 23: `void savePreopDriverIds()`
- Line 25: `QList<CIGCONF::DriverId> driverIds() const`
- Line 26: `QList<CIGCONF::MasterId> masterIds() const`
- Line 27: `QList<quint64> superIds() const`
- Line 28: `QList<CIGCONF::DriverId> techIds() const`
- Line 29: `QList<CIGCONF::PreopDriverId> preopDriverIds() const`
- Line 31: `CIGCONF::DriverId driverId(int index) const`
- Line 32: `CIGCONF::MasterId masterId(int index) const`
- Line 33: `CIGCONF::MasterId masterIdById(quint64 id) const`
- Line 34: `quint64 superId(int index) const`
- Line 35: `CIGCONF::DriverId techId(int index) const`
- Line 37: `bool setDriverId(int index, quint64 id, QString name)`
- Line 38: `bool setMasterId(int index, quint64 id, quint8 option, QString name)`
- Line 39: `bool setSuperId(int index, quint64 id)`
- Line 40: `bool setTechId(int index, quint64 id, QString name)`
- Lines 42–48: `bool containsDriverId(quint64 id) const` (inline)
- Lines 50–62: `bool containsMasterId(quint64 id, quint8 permissions) const` (inline)
- Lines 63–68: `bool containsSuperId(quint64 id) const` (inline)
- Lines 69–75: `bool containsTechId(quint64 id) const` (inline)
- Line 77: `bool addDriverId(quint64 id, QString name)`
- Line 78: `bool addSuperId(quint64 id)`
- Line 79: `bool addTechId(quint64 id, QString name)`
- Line 80: `bool addPreopDriverId(quint64 id, quint32 timestamp)`
- Line 82: `bool removeDriverId(quint64 id)`
- Line 83: `bool removeMasterId(quint64 id)`
- Line 84: `bool removeSuperId(quint64 id)`
- Line 85: `bool removeTechId(quint64 id)`
- Line 87: `void clearDriverIds()`
- Line 88: `void clearMasterIds()`
- Line 89: `void clearSuperIds()`
- Line 90: `void clearTechIds()`
- Line 91: `void clearPreopDriverIds()`
- Line 93: `quint32 driverChecksum() const`
- Line 94: `quint32 masterChecksum() const`
- Line 95: `quint32 superChecksum() const`
- Line 96: `quint32 techChecksum() const`
- Line 98: `bool superIsEmpty()`
- Line 100: `int getMasterIdIndex(quint64 id)`
- Line 101: `int getDriverIdIndex(quint64 id)`
- Line 102: `int getTechIdIndex(quint64 id)`
- Line 103: `int getPreopDriverIdIndex(quint64 id)`
- Line 104: `CIGCONF::PreopDriverId getPreopDriverId(quint64 id)`

**Signals and slots:** None.

**Member variables (private):**
- Line 108: `QList<CIGCONF::DriverId> m_driverIds`
- Line 109: `QList<CIGCONF::MasterId> m_masterIds`
- Line 110: `QList<quint64> m_superIds`
- Line 111: `QList<CIGCONF::DriverId> m_techIds`
- Line 112: `QList<CIGCONF::PreopDriverId> m_preopDriverIds`
- Line 113: `bool m_driverIdsDirty`
- Line 114: `bool m_masterIdsDirty`
- Line 115: `bool m_superIdsDirty`
- Line 116: `bool m_techIdsDirty`
- Line 117: `bool m_preopDriverDirty`

---

### File: `/c/Projects/cig-audit/repos/mark3-pvd/app/driverlist.cpp`

**Class name and base classes:** Implementation of `DriverList` (see above).

**`#include` directives:**
- Line 1: `#include "driverlist.h"`
- Line 2: `#include "app/cigconfigs.h"`
- Line 3: `#include <QFile>`
- Line 4: `#include <QSaveFile>`
- Line 5: `#include <QDateTime>`
- Line 6: `#include "app/globalconfigs.h"`

**`Q_OBJECT` macro:** Not present.

**Constants and `#define`s:** None in this file.

**Member variables:** As declared in `driverlist.h`.

---

## Security Review

### 1. Memory Safety

**A04-1** · MEDIUM · Memory Safety
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/app/cigconfigs.h:193`
**Description:** The struct `CanSigPara` contains a member `void *unused2` described in a comment as "set to nullptr". Storing a raw `void*` in a persistent data structure (used inside the union of `CigCanConfig`) creates a use-after-free and dangling-pointer risk if this pointer is ever assigned a non-null value by future code or through memory corruption of the adjacent fields. Because `CigCanConfig` is a plain struct likely serialised to/from non-volatile storage or transmitted over a communications channel, a corrupted value in this field could produce an exploitable pointer dereference when the struct is later read back.

**A04-2** · LOW · Memory Safety
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/app/driverlist.cpp:267–283`
**Description:** `setDriverId` accepts an `int index` parameter and checks `index >= DRIVER_MAX_ID_IDX` (3000) before expanding `m_driverIds` up to that index. If a caller provides `index = 2999` and `m_driverIds` is currently empty, the loop `for (int i = m_driverIds.size(); i <= index; ++i) m_driverIds << d;` will append 3000 entries unconditionally, allocating a `QList` of up to 3000 `DriverId` objects. An equivalent pattern exists for `setMasterId` (up to 1024), `setSuperId` (up to 100), and `setTechId` (up to 1000). If the `index` parameter is received from an attacker-controlled command (e.g., a `CMD_IDBATCH` GMTP command), this constitutes a denial-of-service through large memory allocation on a constrained embedded device.

**A04-3** · LOW · Memory Safety
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/app/driverlist.cpp:430–443`
**Description:** `getPreopDriverIdIndex` contains a spurious local function declaration at line 433: `CIGCONF::PreopDriverId getPreopDriverId(quint64 id);`. This is a forward declaration inside function body scope, which in C++ declares a local function (not the member method). This is a code defect — the declared local function shadows the class member and is never called. While not directly a security vulnerability, it demonstrates that dead/unreachable code paths exist in the authentication logic for once-per-day preop checking, which could mask logic errors in future modifications.

**Unsafe C string functions (strcpy, strcat, sprintf, gets):** None found in these files.

**Raw `new` without RAII:** None found in these files.

**`memcpy`/`memmove` without size check:** None found in these files.

### 2. Communication Security

**A04-4** · MEDIUM · Communication Security
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/app/cigconfigs.h:57`
**Description:** `#define WIFI_CONF_FILE "/etc/wpa_supplicant.conf"` hardcodes the path to the WPA supplicant configuration file. This file typically contains plaintext Wi-Fi pre-shared keys (PSKs) or WPA enterprise credentials. The firmware directly references this path for reading and/or writing Wi-Fi credentials. On a Linux-based embedded device where `/etc/wpa_supplicant.conf` is world-readable, Wi-Fi passwords stored in this file are accessible to any process running on the device. There is no evidence of file permission enforcement or encryption of credentials at rest.

**A04-5** · INFO · Communication Security
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/app/cigconfigs.h:19–24`
**Description:** Length constants are defined for server addresses (`SERVER_ADDR_LEN 33`), modem APN credentials (`MODEM_APN_LEN 33`, `MODEM_APN_USER_LEN 33`, `MODEM_APN_PASSWORD_LEN 66`), and modem dial number (`MODEM_DIAL_NUMBER_LEN 9`). No actual server addresses or credentials are hardcoded in this header. The APN password field comment notes "must >= 64 (WPA key max length)", which suggests these credential fields are populated at runtime (provisioned). No hardcoded credentials were found in this file.

**Hardcoded server addresses, API keys, or encryption keys:** None found in these four files.

**Hardcoded encryption keys or IVs:** None found in these four files.

### 3. Input Handling

**A04-6** · MEDIUM · Input Handling
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/app/driverlist.cpp:22–42`
**Description:** `readDriverIds()` calls `file.readAll()` on `FILE_DRIVER_IDS` (`/home/dlist.txt`) with no limit on file size. On an embedded device with limited RAM, a file that has been tampered with (e.g., replaced via FTP as noted in the comment at `cigconfigs.h:61`) containing many megabytes of data would cause the entire file to be read into a single `QByteArray` in memory, potentially exhausting heap. The same pattern exists in `readMasterIds()` (line 71), `readSuperIds()` (line 126), `readTechIds()` (line 161), and `readPreopDriverIds()` (line 211). The comment in `cigconfigs.h` explicitly acknowledges these files may be updated by FTP, meaning attacker-controlled content is a realistic threat model.

**A04-7** · LOW · Input Handling
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/app/driverlist.cpp:86–87`
**Description:** In `readMasterIds()`, `m.option` is parsed with `toUInt()` at line 86, which returns a `uint` (32-bit on all Qt platforms). This value is then stored in `MasterId::option`, which is typed `quint8`. An attacker who controls the master ID file content (e.g., via FTP replacement) could supply a value greater than 255. Qt's `QByteArray::toUInt()` will parse it successfully without error, and the implicit narrowing conversion from `uint` to `quint8` will silently truncate the value. Because `option` is a permission bitmask used in `containsMasterId()` for access-control decisions (line 55 of `driverlist.h`), a truncated permission value could allow a master ID to bypass permission checks that rely on specific bitmask bits being set.

**A04-8** · LOW · Input Handling
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/app/driverlist.cpp:37`
**Description:** When parsing driver names from the ID file, the name field is taken directly from the file with `QString(args.at(1))` (no trimming or length limiting). While Qt strings do not overflow in the C sense, names of arbitrary length are stored in `DriverId::name` and `MasterId::name`. If these strings are later rendered to a fixed-size display buffer or transmitted in a bounded message field sized against `BROADCASTMSG_TEXT_LEN` (100) or similar constants, the unconstrained input from file could produce truncation or incorrect display behaviour. The same pattern appears in `readTechIds()` (line 176) and `readMasterIds()` (line 89).

**Format string vulnerabilities:** None found — no `printf(var)` or `qDebug(var)` patterns observed.

**Deserialization of untrusted binary data:** Not present in these files; parsing is text-based with Qt conversion functions.

### 4. Build Security

Build Security: no issues found. (Source files only — no `.pro` file in scope for this assignment. No compiler flags to evaluate here.)

### 5. Device and Firmware

**A04-9** · MEDIUM · Device and Firmware
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/app/cigconfigs.h:64–74`
**Description:** All ID list files and checklist files are stored under `/home/` (e.g., `FILE_DRIVER_IDS "/home/dlist.txt"`, `FILE_MASTER_IDS "/home/mlist.txt"`, `FILE_SUPER_IDS "/home/slist.txt"`, `FILE_TECH_IDS "/home/tlist.txt"`, `FILE_CHECKLIST "/home/PREOP.TXT"`, `FILE_ONCEPERDAY_PREOP_IDS "/home/opdPreopDlist.txt"`). The comment at lines 61–63 explicitly states these files may be updated by FTP. Driver and master ID lists are security-critical: they control who can unlock the vehicle and who has master/supervisor access. Storing authentication data in FTP-writable plaintext files on the device filesystem, with no integrity protection (no HMAC, no signature), means that any party with FTP access to the device can add arbitrary driver or master IDs, effectively granting themselves vehicle access. The XOR-based checksum returned by `driverChecksum()` / `masterChecksum()` is not a cryptographic integrity mechanism and can be trivially forged.

**A04-10** · LOW · Device and Firmware
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/app/cigconfigs.h:116–118`
**Description:** The `LeaderCmd` enum includes `CMD_DEBUG`, `CMD_DBGPWR` (with comment "AT^DBGPWR=1/0 for power on/off debug usage"), `CMD_DBGBLE` (with comment "AT^DBGBLE=1/0 for bluetooth debug usage"), and `CMD_DBGRAM`. These are named debug commands that appear to be part of the production command set (they are defined alongside all other production commands with no conditional compilation guard). Debug commands that can affect power state or Bluetooth in production firmware are a firmware security concern: if accessible via the communications channel, they expand the attack surface unnecessarily.

**A04-11** · INFO · Device and Firmware
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/app/cigconfigs.h:83–84`
**Description:** The `MasterMenuOptions` enum uses `UnassignedMasterMenu=255` as the default/unassigned sentinel value, which is the same as `SHOW_ALL_MASTER_MENU 255` defined at line 81. In `masterIdById()` (driverlist.cpp line 650), when a master ID has option `UnassignedMasterMenu`, it is promoted to `DefaultMasterMenu=7`. This default-promotion logic means a freshly provisioned or file-corrupted master ID with no explicit option value (255 = all bits set in a `quint8`) is automatically granted menu options 1+2+4 (UnlockVehicle, NormalDriverAccess, ActivateVOR). This is a design-level access-control concern: the unassigned sentinel value coincides with the maximum-privilege value, so any default or corrupted record silently receives substantial permissions.

**Firmware signing keys committed to repo:** None found in these files.

**Device certificates or credential files:** None found in these files.

### 6. Qt-Specific Security

**A04-12** · LOW · Qt-Specific Security
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/app/driverlist.cpp:244–264`
**Description:** `savePreopDriverIds()` uses a plain `QFile` opened with `QIODevice::WriteOnly | QIODevice::Text` rather than `QSaveFile`. All other save methods in this class correctly use `QSaveFile` (which writes to a temporary file and atomically commits on success), protecting against partial writes if the device loses power mid-write. `savePreopDriverIds()` writes directly to `FILE_ONCEPERDAY_PREOP_IDS` (`/home/opdPreopDlist.txt`). A power loss during this write would corrupt the once-per-day pre-operation check record file, potentially causing all drivers to be re-prompted for the checklist or — depending on error handling — allowing drivers who have already completed the pre-op check to bypass it after reboot.

**`QProcess` usage:** None found in these files.

**`QSettings` usage:** None found in these files.

**`QSslSocket` / TLS configuration:** None found in these files.

---

## Summary of Findings

| ID | Severity | Category | File |
|----|----------|----------|------|
| A04-1 | MEDIUM | Memory Safety | `cigconfigs.h:193` |
| A04-2 | LOW | Memory Safety | `driverlist.cpp:267` |
| A04-3 | LOW | Memory Safety | `driverlist.cpp:430` |
| A04-4 | MEDIUM | Communication Security | `cigconfigs.h:57` |
| A04-5 | INFO | Communication Security | `cigconfigs.h:19–24` |
| A04-6 | MEDIUM | Input Handling | `driverlist.cpp:22` |
| A04-7 | LOW | Input Handling | `driverlist.cpp:86` |
| A04-8 | LOW | Input Handling | `driverlist.cpp:37` |
| A04-9 | MEDIUM | Device and Firmware | `cigconfigs.h:64–74` |
| A04-10 | LOW | Device and Firmware | `cigconfigs.h:116–118` |
| A04-11 | INFO | Device and Firmware | `cigconfigs.h:83–84` |
| A04-12 | LOW | Qt-Specific Security | `driverlist.cpp:244` |
# Pass 1 — A05 Security Audit
**Auditor:** A05
**Date:** 2026-02-28
**Branch:** master (confirmed)

---

## Reading Evidence

### File Pair 1: globalconfigs.h / globalconfigs.cpp

**File paths:**
- `/c/Projects/cig-audit/repos/mark3-pvd/app/globalconfigs.h`
- `/c/Projects/cig-audit/repos/mark3-pvd/app/globalconfigs.cpp`

**Class name and base classes:**
- `GlobalConfigs` : public `QObject`

**Q_OBJECT macro location:**
- `globalconfigs.h` line 17

**#include directives (header):**
- `<QtGlobal>` (line 4)
- `<QFile>` (line 5)
- `<QDateTime>` (line 6)
- `<QObject>` (line 7)
- `"utils/bytearray.h"` (line 8)
- `"app/cigconfigs.h"` (line 9)
- `"app/checklist.h"` (line 10)
- `"app/driverlist.h"` (line 11)

**#include directives (source):**
- `"globalconfigs.h"` (line 1)
- `"platform/internalrtc.h"` (line 2)
- `<QGlobalStatic>` (line 3)
- `<QBluetoothAddress>` (line 4)
- `<QProcess>` (line 5)
- `<QDebug>` (line 6)
- `<QSaveFile>` (line 7)
- `<QTextStream>` (line 8)
- `<QString>` (line 9)

**Signals:**
- `superListChanged(bool empty)` — line 710
- `convorStatusChanged()` — line 711
- `preopOncePerDayStatusChanged()` — line 712

**Slots:** None declared explicitly (no public/protected slots section)

**Every public method with signature and line number (selected key methods):**
- `explicit GlobalConfigs(QObject *parent = nullptr)` — line 20
- `static GlobalConfigs *instance()` — line 21
- `static quint32 crc32(const void *buf, int len)` — line 22
- `void readConfigs()` — line 24
- `void saveConfigs()` — line 25
- `void saveOpdDriverList()` — line 26
- `void resetConfigs(bool resetAll = false)` — line 27
- `quint32 keepAliveTime() const` — line 30
- `bool setKeepAliveTime(quint32 time)` — line 31
- `quint32 shutdownTime() const` — line 40
- `bool setShutdownTime(quint32 time)` — line 41
- `QByteArray gmtpId() const` — line 50
- `bool setGmtpId(const QByteArray &id)` — line 51
- `bool setDialNumber(const QByteArray &number)` — line 88
- `bool setApn(const QByteArray &apn)` — line 98
- `bool setApnUser(const QByteArray &user)` — line 108
- `bool setApnPassword(const QByteArray &password)` — line 118
- `QByteArray gmtpServerAddress(int index) const` — line 127
- `bool setGmtpServerAddress(int index, const QByteArray &addr)` — line 128
- `quint16 gmtpServerPort(int index) const` — line 137
- `bool setGmtpServerPort(int index, quint16 port)` — line 138
- `bool setWifiNetwork(quint32 index, const QByteArray &ssid, const QByteArray &pw)` — line 588
- `bool setWifiCountry(const QByteArray &country)` — line 591
- `void clearWifiConfig()` — line 594
- `quint32 shockThreshold() const` — line 382
- `bool setShockThreshold(quint32 data)` — line 383
- `quint32 shockRedImpact() const` — line 389
- `bool setShockRedImpact(quint32 data)` — line 390
- `quint32 shockPeriod() const` — line 396
- `bool setShockPeriod(quint32 data)` — line 397
- `quint32 shockTimer() const` — line 403
- `bool setShockTimer(quint32 data)` — line 404
- `quint64 fwVersion()` — line 569
- `QString fwVersionString()` — line 570

**Key constants (defined in .cpp):**
- `FMS_INI_FILE` = `"fms.ini"` (line 13)
- `DYN_INI_FILE` = `"dyn.ini"` (line 14)
- `FMS_CONFIG_FILE` = `"fmscfg.dat"` (line 15)
- `OD_CONFIG_FILE` = `"odcfg.dat"` (line 16)
- `VOR_CONFIG_FILE` = `"vor.cfg"` (line 17)
- `GFNCE_CONFIG_FILE` = `"gfnce.cfg"` (line 18)
- `MAGIC_CODE` = `0xA53F3456` (line 19)
- `OD_VERSION` = `1` (line 20)

**Hardcoded values of note in resetConfigs():**
- Default GMTP server address: `"fleetiq.ciifm.com"` (line 208)
- Default GMTP server port: `4687` (line 209)
- Default time server: `"ntp.ciifm.com"` (line 217)
- Default BLE MAC: `"00:07:80:2E:9B:85"` (line 189)

**Key member variables:**
- `ConfigsData m_configs` — includes `gmtpServer[]`, `apnPassword[]`, `dialNumber[]`, `apn[]`, `apnUser[]`, `shockThreshold`, `shockRedImpact`, `shockPeriod`, `shockTimer`, `timeServerAddress`
- `char simICCID[MODEM_ICCID_LEN]` — line 849
- `QList<CIGCONF::WifiNetwork> m_networks` — includes ssid/password pairs (line 819)

---

### File Pair 2: bleexpansion.h / bleexpansion.cpp

**File paths:**
- `/c/Projects/cig-audit/repos/mark3-pvd/comm/bleexpansion.h`
- `/c/Projects/cig-audit/repos/mark3-pvd/comm/bleexpansion.cpp`

**Class name and base classes:**
- `BleExpansion` : public `QObject`

**Q_OBJECT macro location:**
- `bleexpansion.h` line 25

**#include directives (header):**
- `"app/cigconfigs.h"` (line 4)
- `<QObject>` (line 5)
- `<QDateTime>` (line 6)
- `<QBluetoothAddress>` (line 7)
- `<QBluetoothUuid>` (line 8)
- `<QQueue>` (line 9)
- `<QTimer>` (line 10)

**#include directives (source):**
- `"bleexpansion.h"` (line 1)
- `"platform/blecentral.h"` (line 2)
- `"platform/seriallogger.h"` (line 3)
- `"comm/bleexpansionuuid.h"` (line 4)
- `"app/globalconfigs.h"` (line 5)
- `<QTimerEvent>` (line 6)
- `<QDebug>` (line 7)

**Signals:**
- `accessible(bool yes)` — line 60
- `inputStateChanged(CIGCONF::BleExpansionDI input, bool state)` — line 61
- `shockOccurred()` — line 62
- `amberImpactOccurred()` — line 63
- `redImpactOccurred()` — line 64

**Slots (protected):**
- `void timerEvent(QTimerEvent *)` — line 67 (not a Qt slot per se, but overrides QObject::timerEvent)

**Public methods with signatures and line numbers:**
- `explicit BleExpansion(EM070::BleCentral *bleCentral)` — line 32
- `void setEnabled(bool enable)` — line 34
- `const QByteArray &deviceName() const` — line 36
- `const QByteArray &bleVersion() const` — line 37
- `const QByteArray &mainVersion() const` — line 38
- `const QByteArray &manufacture() const` — line 39
- `const QByteArray &modelNumber() const` — line 40
- `bool digitalInput(CIGCONF::BleExpansionDI di) const` — line 42
- `bool relayOutput(CIGCONF::BleExpansionRelay relay) const` — line 44
- `void setRelayOutput(CIGCONF::BleExpansionRelay relay, bool state)` — line 47
- `void setShockThreshold(quint32 threshold)` — line 49
- `void setShockPeriod(quint32 period)` — line 50
- `bool isShockQueueEmpty()` — line 52
- `ShockEvent shockEvent()` — line 53
- `void setCurrentTime(const QDateTime &time)` — line 55
- `bool generateShockMessage(bool force)` — line 57

**Key constants in source:**
- `AUTH_CODE` = `"uS8MgpklMx"` (line 9)
- `MAX_SHOCK_COUNT` = `10000` (line 11)
- `RELAY1_TIMEOUT` = `60` (line 12)
- `RELAY2_TIMEOUT` = `60` (line 13)

**Key member variables:**
- `EM070::BleCentral *m_bleCentral` — line 116
- `bool m_digitalInput[4]` — line 132
- `bool m_outputRelay[2]` — line 133
- `quint32 m_shockThreshold` — line 134
- `quint32 m_shockPeriod` — line 135
- `quint32 m_shockMaxMagnitude` — line 131
- `QQueue<ShockEvent> m_shockEvents` — line 140
- `union RtcTime { char data[10]; ... }` — line 71
- `union WritePending { quint32 val; ... }` — line 85

---

## Security Review

### 1. Memory Safety

**A05-1** · HIGH · Memory Safety
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/app/globalconfigs.h:53`
**Description:** `setGmtpId()` uses `qstrcpy(m_configs.gmtpId, id.constData())` after checking `id.size() < GMTP_ID_LEN`. The check correctly excludes inputs equal to `GMTP_ID_LEN`, but `qstrcpy` performs no length enforcement — if the caller passes a `QByteArray` that does not contain a null terminator and whose `.size()` matches one of the raw bytes, the copy could overrun the destination buffer. More critically, `qstrcpy` is equivalent to `strcpy` and copies until a null byte: if the source `QByteArray` was constructed without an embedded null (e.g. from network data), the copy will read past the declared length. The same pattern applies to `setDialNumber()` (line 90), `setApn()` (line 100), `setApnUser()` (line 110), `setApnPassword()` (line 120), `setGmtpServerAddress()` (line 130), `setTimeServerAddress()` (line 422), and the `resetConfigs()` direct `qstrcpy` calls on lines 183, 197, 208, 217. Every one of these should use `qstrncpy` or `memcpy` with a known length. In an embedded C++ device, a stack or struct buffer overflow from network-supplied configuration data is a memory-safety and safety-critical finding.

**A05-2** · MEDIUM · Memory Safety
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/app/globalconfigs.h:162`
**Description:** `setSimCardID()` uses `qstrcpy(simICCID, iccid.constData())` after checking `iccid.size() < MODEM_ICCID_LEN`. The same null-terminator assumption as A05-1 applies. A `QByteArray` built from raw modem data may not terminate with `\0`, causing overrun of the fixed-size `char simICCID[MODEM_ICCID_LEN]` member.

**A05-3** · MEDIUM · Memory Safety
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/app/globalconfigs.cpp:800-816`
**Description:** `readGeofenceConfig()` uses polygon indices `n` and `vect` parsed directly from a config file with `toInt()-1`. There is no bounds check on `n` before `m_polygon[n]` is written (line 806-807). If the file contains `n=0` the resulting index is `-1`, and if `n` exceeds `MAX_POLY` the array `m_polygon[MAX_POLY]` is overwritten out of bounds. Similarly `vect` is not checked against `MAX_POLY_POINTS` before the write. This is an out-of-bounds write from a file that may be modified or replaced on the device filesystem.

**A05-4** · LOW · Memory Safety
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/app/globalconfigs.cpp:140`
**Description:** In `resetConfigs()`, line 140 reads `memset(&m_configs, 0, sizeof(ConfigsDataExt))`. The first argument is `&m_configs` which is of type `ConfigsData`, not `ConfigsDataExt`. This is almost certainly a copy-paste error; the intent was `memset(&m_configsExt, 0, sizeof(ConfigsDataExt))`. The effect is that the first `sizeof(ConfigsDataExt)` bytes of `m_configs` are zeroed a second time (redundant but harmless as written), while `m_configsExt` is never zero-initialised by this call. This means `m_configsExt.unlkScr` retains its previous value across a `resetConfigs()` call unless explicitly set afterward (it is set at line 231). The bug may mask future fields added to `ConfigsDataExt` that require explicit reset.

### 2. Communication Security

**A05-5** · HIGH · Communication Security — Hardcoded Server Addresses
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/app/globalconfigs.cpp:208`
**Description:** The GMTP server hostname `"fleetiq.ciifm.com"` and port `4687` are hardcoded as the default reset values applied in `resetConfigs()`. The NTP server `"ntp.ciifm.com"` is also hardcoded (line 217). Hardcoding production server addresses in firmware prevents environment separation (dev/staging/production), makes it impossible to redirect devices to a different backend without a firmware update, and leaks infrastructure topology. These values should be injected via a provisioning process or read from a secure configuration store.

**A05-6** · HIGH · Communication Security — Hardcoded BLE Authentication Credential
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/comm/bleexpansion.cpp:9`
**Description:** The BLE expansion module authentication code `AUTH_CODE "uS8MgpklMx"` is hardcoded as a plain-text `#define` and passed directly as the authorization code to the BLE central (line 40). This credential is the same across all devices (it is baked into the firmware binary). Any attacker with access to the firmware binary can extract it and use it to authenticate to any expansion module that shares this firmware. The credential should be unique per device and injected at provisioning time.

**A05-7** · MEDIUM · Communication Security — Hardcoded Default BLE MAC Address
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/app/globalconfigs.cpp:189`
**Description:** The expansion module MAC address `"00:07:80:2E:9B:85"` is hardcoded as the default in `resetConfigs()`. If a device configuration is reset, the device will attempt to connect to this specific hardcoded MAC address. In a multi-device deployment this means all reset devices would try to pair with the same physical module. While this is likely a factory default, it represents a misconfiguration risk and should be clearly flagged.

**A05-8** · MEDIUM · Communication Security — WiFi Passwords Stored in Plaintext Config File
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/app/globalconfigs.cpp:480-481`
**Description:** `saveStaticConfig()` writes WiFi SSID and password pairs to `fms.ini` as plaintext: `out << "Wifi network " << i+1 << "=" << m_networks[i].ssid << "," << m_networks[i].pw`. If the device filesystem is accessible (e.g. via USB mass storage, serial console, or physical extraction), all configured WiFi credentials are trivially readable.

**A05-9** · MEDIUM · Communication Security — APN Password Stored in Plaintext Config File
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/app/globalconfigs.cpp:442`
**Description:** `saveStaticConfig()` writes the cellular APN password to `fms.ini` in plaintext: `out << "APN password=" << apnPassword()`. An attacker with filesystem access obtains the cellular APN credential without any further effort.

**A05-10** · INFO · Communication Security — No TLS or Certificate Validation Visible in These Files
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/app/globalconfigs.cpp`
**Description:** The GMTP server address and port are stored and configured here, but no TLS, certificate pinning, or peer verification logic is present in these files. Whether TLS is applied at the connection layer (in the GMTP communication module) cannot be confirmed from these files alone. This should be verified in the GMTP/comm module during a subsequent pass.

### 3. Input Handling

**A05-11** · MEDIUM · Input Handling — Config File Values Applied Without Range Validation
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/app/globalconfigs.cpp:319-325`
**Description:** In `readStaticConfig()`, the shock safety parameters `shockThreshold`, `shockRedImpact`, `shockPeriod`, and `shockTimer` are read from the plaintext `fms.ini` file and assigned directly to `m_configs` fields without any range validation. For example, `m_configs.shockThreshold = args[1].toUInt()` (line 319). An attacker or corrupted file that sets `shockThreshold = 0` would cause every vibration to register as a shock event; setting `shockRedImpact` to a very high value would suppress red-impact alerts. These are safety-critical parameters — they should be range-validated on read.

**A05-12** · MEDIUM · Input Handling — Config File Values Applied Without Range Validation (Idle/Keepalive/GPS)
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/app/globalconfigs.cpp:286-331`
**Description:** Several additional configuration values are read from `fms.ini` and assigned directly without range checking: `keepAliveTime` (line 286), `shutdownTime` (line 288), `gpsUpdateTime` (line 331), `idleTimeout` (line 333). The setter methods for these values (`setKeepAliveTime`, `setShutdownTime`) do apply range checks, but `readStaticConfig()` bypasses the setters and writes directly to `m_configs` struct fields. This means the range checks in the setters are ineffective for values loaded from the config file.

**A05-13** · MEDIUM · Input Handling — BLE Shock Event Data Parsed via Raw Pointer Cast Without Full Validation
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/comm/bleexpansion.cpp:202-205`
**Description:** `popShockEvent()` checks `ba.size() >= 8` and then accesses `event.timestamp` and `event.magnitude` by casting `ba.constData()` to `const quint32 *`. The size check is present and the alignment comment notes `4-byte aligned is safe`. However, there is no validation that the BLE payload is not adversarially crafted to contain unexpected values. Specifically, `event.magnitude` is used directly in comparisons against `gCfg->shockRedImpact()` and `gCfg->shockThreshold()` to trigger safety alerts (`emit redImpactOccurred()`). A malicious or faulty BLE peripheral could send an arbitrarily high magnitude and trigger a false safety event, or send zero magnitude to suppress real events. Input from a BLE peripheral should be treated as untrusted.

**A05-14** · LOW · Input Handling — Digital Input State Treated as Full Byte, Not Boolean
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/comm/bleexpansion.cpp:332-334`
**Description:** In `characteristicRead()`, when handling `inputD0` through `inputD3`, the code reads `ba[0]` and assigns it directly as a `bool` value: `m_digitalInput[0] = ba[0]`. The emit is `emit inputStateChanged(CIGCONF::BleExpDI1, ba[0])`. Any non-zero byte from the BLE peripheral will be treated as `true`. While functionally equivalent in most cases, a malformed byte from the peripheral could encode additional data that is silently discarded, masking a protocol mismatch. More importantly, `ba[0]` is a `char` which is sign-extended; value `0xFF` as a signed char is `-1`, which is truthy. This is a minor robustness issue.

### 4. Build Security

Build Security: no issues found in the files assigned to this auditor. The `.pro` file was not assigned; compiler security flags (`-fstack-protector-strong`, `-D_FORTIFY_SOURCE=2`, `-fPIE`, `-Wformat-security`) should be checked by the auditor assigned that file.

**A05-15** · MEDIUM · Build Security — QProcess Included But Usage Not Visible in Assigned Files
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/app/globalconfigs.cpp:5`
**Description:** `<QProcess>` is `#include`d in `globalconfigs.cpp` but no `QProcess` usage is visible anywhere in the file. This unused include may be a leftover from removed code, or `QProcess` may be invoked in a macro or template instantiation not visible here. The presence of this include warrants a targeted grep across the codebase to confirm whether `QProcess` is used anywhere with arguments derived from configuration values (which would be a HIGH finding).

### 5. Device and Firmware

**A05-16** · HIGH · Device and Firmware — Safety-Critical Shock Thresholds Received Without Validation
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/app/globalconfigs.h:383-408`
**Description:** The setter methods `setShockThreshold()`, `setShockRedImpact()`, `setShockPeriod()`, and `setShockTimer()` accept any `quint32` value without range validation. These thresholds directly determine when proximity/impact alerts are triggered (`amberImpactOccurred`, `redImpactOccurred` signals in `bleexpansion.cpp`). A server-sent configuration message that sets `shockThreshold` to `UINT32_MAX` would permanently disable all shock alerts. A value of `0` for `shockRedImpact` or `shockThreshold` bypasses alert logic (checked with `if (gCfg->shockRedImpact() && ...)` in bleexpansion.cpp line 213). Safety-critical parameters received from the network must have validated minimum/maximum bounds before being applied.

**A05-17** · MEDIUM · Device and Firmware — Default Shock Threshold Hardcoded
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/app/globalconfigs.cpp:211`
**Description:** `m_configs.shockThreshold = 80000` is set as the hardcoded factory default in `resetConfigs()`. While defaults are expected, the value `80000` has no documented engineering basis visible in the code and no associated comment explaining the unit or calibration rationale. If this value is incorrect for a given vehicle type, it could result in missed impact events. The safety-critical nature of this threshold warrants a documented, validated default value.

**A05-18** · INFO · Device and Firmware — Full Lockout Enable/Timeout Have No Upper Bound Validation
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/app/globalconfigs.h:271-282`
**Description:** `setFullLockoutEnable()` and `setFullLockoutTimeout()` accept any `quint8` or `quint32` value without validation. A lockout timeout of `0` or `UINT32_MAX` could cause unexpected device behavior (permanent lockout or instant expiry). Range validation should be applied.

### 6. Qt-Specific Security

**A05-19** · MEDIUM · Qt-Specific Security — QProcess Included Unnecessarily
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/app/globalconfigs.cpp:5`
**Description:** `#include <QProcess>` appears in `globalconfigs.cpp` with no corresponding usage in the file. As noted in A05-15, this raises the question of whether `QProcess` is used elsewhere with inputs derived from global configuration values (server addresses, APN strings, etc.). If any `QProcess` invocation passes configuration-derived values as command arguments, it would be a HIGH finding. This include should be removed if unused, or investigated if it reflects an intended use not visible in this file.

QSslSocket peer verify mode: no QSslSocket usage found in the assigned files.

---

## Summary of Findings

| ID | Severity | Category | Location |
|----|----------|----------|----------|
| A05-1 | HIGH | Memory Safety | `globalconfigs.h:53` (qstrcpy pattern, multiple setters) |
| A05-2 | MEDIUM | Memory Safety | `globalconfigs.h:162` (setSimCardID qstrcpy) |
| A05-3 | MEDIUM | Memory Safety | `globalconfigs.cpp:800-816` (geofence index no bounds check) |
| A05-4 | LOW | Memory Safety | `globalconfigs.cpp:140` (wrong memset target) |
| A05-5 | HIGH | Communication Security | `globalconfigs.cpp:208` (hardcoded server addresses) |
| A05-6 | HIGH | Communication Security | `bleexpansion.cpp:9` (hardcoded BLE auth credential) |
| A05-7 | MEDIUM | Communication Security | `globalconfigs.cpp:189` (hardcoded BLE MAC) |
| A05-8 | MEDIUM | Communication Security | `globalconfigs.cpp:480-481` (WiFi passwords plaintext) |
| A05-9 | MEDIUM | Communication Security | `globalconfigs.cpp:442` (APN password plaintext) |
| A05-10 | INFO | Communication Security | `globalconfigs.cpp` (TLS not verifiable from these files) |
| A05-11 | MEDIUM | Input Handling | `globalconfigs.cpp:319-325` (shock params no range check on read) |
| A05-12 | MEDIUM | Input Handling | `globalconfigs.cpp:286-331` (setters bypassed on config read) |
| A05-13 | MEDIUM | Input Handling | `bleexpansion.cpp:202-205` (BLE shock data trusted without validation) |
| A05-14 | LOW | Input Handling | `bleexpansion.cpp:332-334` (digital input byte not masked to bool) |
| A05-15 | MEDIUM | Build Security | `globalconfigs.cpp:5` (unused QProcess include) |
| A05-16 | HIGH | Device and Firmware | `globalconfigs.h:383-408` (shock thresholds no range validation) |
| A05-17 | MEDIUM | Device and Firmware | `globalconfigs.cpp:211` (default shock threshold undocumented) |
| A05-18 | INFO | Device and Firmware | `globalconfigs.h:271-282` (lockout params no upper bound) |
| A05-19 | MEDIUM | Qt-Specific Security | `globalconfigs.cpp:5` (QProcess include, potential misuse) |
# Pass 1 — A06 Security Audit
**Category:** A06 — BLE Expansion UUID and Input Handler
**Branch:** master
**Date:** 2026-02-28
**Auditor:** Pass 1 A06

---

## STEP 4 — READING EVIDENCE

### File pair 1: BleExpansionUuid

**Files:**
- `/c/Projects/cig-audit/repos/mark3-pvd/comm/bleexpansionuuid.h`
- `/c/Projects/cig-audit/repos/mark3-pvd/comm/bleexpansionuuid.cpp`

**Class name and base classes:**
- `BleExpansionUuid` — no base class (plain C++ class, no QObject)

**Public methods:**
- Line 9 (`bleexpansionuuid.h`): `static inline bool equals128(const quint128 *v1, const quint128 *v2)` — pointer-based 128-bit UUID comparison

**Signals and slots:** none (no Q_OBJECT)

**Q_OBJECT macro:** not present

**#include directives:**
- `bleexpansionuuid.h`: `#include <QBluetoothUuid>`
- `bleexpansionuuid.cpp`: `#include "comm/bleexpansionuuid.h"`

**UUID constants defined (bleexpansionuuid.cpp):**
| Member | UUID value | Access comment |
|---|---|---|
| authUuid | `{6d1e95a3-12bf-1107-705e-16edf5954aba}` | (used as auth characteristic UUID) |
| deviceName | `{00002a00-0000-1000-8000-00805f9b34fb}` | RO, standard GATT |
| appearance | `{00002a01-0000-1000-8000-00805f9b34fb}` | RO, standard GATT |
| bleVersion | `{204b4a7c-8415-34a0-32d9-52c87a0fdf56}` | RO |
| mainVersion | `{b9642f66-c5f1-54d8-d7a5-1a299b9bdbd7}` | RO |
| manufactureName | `{00002a29-0000-1000-8000-00805f9b34fb}` | RO, standard GATT |
| modelNumber | `{00002a24-0000-1000-8000-00805f9b34fb}` | RO, standard GATT |
| currentRtc | `{00002a2b-0000-1000-8000-00805f9b34fb}` | RW, standard GATT |
| inputTimerReset | `{c97106be-ab79-1ebb-af52-a76f86ca09f8}` | WO |
| inputD0–inputD3 | (four proprietary UUIDs) | RO |
| inputPullUp0–inputPullUp3 | (four proprietary UUIDs) | RW |
| outputReset | `{78aea58a-90b6-e31e-3af7-abaa3def5cec}` | WO |
| outputRelay0–outputRelay1 | (two proprietary UUIDs) | RW |
| relay0Timeout–relay1Timeout | (two proprietary UUIDs) | RW |
| outputD0–outputD3 | (four proprietary UUIDs) | RW |
| openCollector0–openCollector3 | (four proprietary UUIDs) | RW |
| shockCount | `{69dfccac-59b7-ef3e-5309-db222d1c2d09}` | RW |
| shockPeek | `{53535322-e7fc-8229-b470-89d9fda99e46}` | RO |
| shockPop | `{1642fcc6-bcc9-63f5-039a-721e9acbfb93}` | WO |
| shockThreshold | `{6d3f3a08-06dd-4c11-6add-00c0c2443c77}` | RW |
| shockPeriod | `{8f0c111a-37f2-822f-d70e-b0354a848466}` | RW |
| shockMaxMagnitude | `{33f838fe-2047-1932-ccb0-d5e8d627b905}` | RO |
| shockCountNotifyDesc | `{00002902-0000-1000-8000-00805f9b34fb}` | standard GATT descriptor |

**Member variables (private static):**
All 37 UUID members listed above are private static `quint128`.

**Friend classes:** `BleExpansion`

---

### File pair 2: BleInputHandler

**Files:**
- `/c/Projects/cig-audit/repos/mark3-pvd/comm/bleinputhandler.h`
- `/c/Projects/cig-audit/repos/mark3-pvd/comm/bleinputhandler.cpp`

**Class name and base classes:**
- `BleInputHandler : public QObject`

**Q_OBJECT macro:** line 16 (`bleinputhandler.h`)

**Public methods:**
- Line 20: `explicit BleInputHandler(CanExpansion *canExpansion)`
- Line 22: `void updateIgnition(CIGCONF::PowerState state)`
- Line 23: `void updateBleInput(CIGCONF::BleExpansionDI input, bool state)`
- Line 24: `void changeBleState(bool connected)`
- Line 26: `void updateIdleTimer()`
- Line 28: `QByteArray digitalInputs(DigitalFormat format, bool autoReset)`

**Signals:**
- Line 31: `void idleTimeout()`
- Line 32: `void sendGmtpMessage(CIGCONF::GmtpMessage msg, const QByteArray &extra = QByteArray())`

**Private methods:**
- `void resetStates()`
- `void onTimerEvent()`
- `void sendSeenSafeReport(bool state)`

**#include directives:**
- `bleinputhandler.h`: `#include "app/cigconfigs.h"`, `#include <QObject>`
- `bleinputhandler.cpp`: `#include "bleinputhandler.h"`, `#include "comm/canexpansion.h"`, `#include "app/globalconfigs.h"`, `#include "platform/seriallogger.h"`, `#include <QTimer>`

**Member variables:**
- `CanExpansion *m_canExpansion` — raw pointer
- `QTimer *m_timer` — raw pointer (nullable, manually managed)
- `QTimer *m_digInputModeTimer` — raw pointer (parented)
- `InputState m_ignition` — struct
- `InputState m_bleInputs[4]` — fixed-size array of 4 elements
- `bool m_bypassReset`
- `bool m_bleConnected`
- `bool m_seenState`
- `quint64 m_lastSeenReport`
- `bool m_seenSecond`
- `quint32 m_seenTimestamp`

**Enum:**
- `DigitalFormat {SessionFormat, UsageFormat, OnDemandFormat}`

---

## STEP 5 — SECURITY REVIEW

### 1. Memory Safety

**A06-1** · HIGH · Memory Safety — Array Index Without Bounds Check
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/comm/bleinputhandler.cpp:117`
**Description:** `updateBleInput` computes `int index = input - CIGCONF::BleExpDI1` and immediately dereferences `m_bleInputs[index]` at line 119 without any bounds check. `m_bleInputs` is a fixed array of 4 elements. `BleExpansionDI` is an unscoped enum (`BleExpDI1=0, BleExpDI2=1, BleExpDI3=2, BleExpDI4=3`). Although the signal is currently only emitted with well-known enum values, the parameter type is a plain `int`-sized enum. If a caller or a future code path passes a value outside the defined range (e.g., via a queued connection where the integer value comes from a deserialized or BLE-received message), `index` can be negative or >= 4, producing an out-of-bounds array access, undefined behaviour, and a potential crash or memory corruption on the embedded device. No assertion, range guard, or Q_ASSERT is present. The same arithmetic-then-immediate-access pattern appears without bounds checks in `bleexpansion.h:42` (`BleExpansion::digitalInput`) and `canexpansion.h:64` (`CanExpansion::digitalInput`), which are in scope because `BleExpansionUuid` is architecturally paired with these consumers.

**A06-2** · MEDIUM · Memory Safety — Manual QTimer Lifecycle
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/comm/bleinputhandler.cpp:211-214`
**Description:** `m_timer` is a raw pointer that is `new`-allocated and `delete`-d manually inside `updateIdleTimer()`. Although the timer is parented to `this` via `new QTimer(this)` (line 219), `delete m_timer` at line 213 is also called explicitly, which is safe but redundant and fragile: it bypasses Qt's parent-child ownership model and could cause a double-free if the parent destructor also deletes it. More critically, no destructor is defined for `BleInputHandler`, so the case where `updateIdleTimer()` is never called with a condition that triggers deletion — but the object is destroyed — relies entirely on the Qt parent mechanism. The manual `delete` path at line 213 followed by `m_timer = nullptr` at line 214 is inconsistent with using Qt parent ownership and introduces maintenance risk of use-after-free if this pattern is extended.

### 2. Communication Security

**A06-3** · HIGH · Communication Security — Hardcoded BLE Authentication Credential
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/comm/bleexpansion.cpp:9`
**Description:** The BLE authentication code `AUTH_CODE` is hardcoded as the string literal `"uS8MgpklMx"` in source. This credential is written to the expansion module's `authUuid` characteristic (UUID `6d1e95a3-12bf-1107-705e-16edf5954aba`) during BLE connection setup (line 40 of `bleexpansion.cpp`). Any attacker with read access to the firmware binary or this repository can extract the authentication code and directly authenticate to any expansion module within BLE range. For a vehicle proximity detection device, an unauthenticated actor able to connect to the expansion module could manipulate digital outputs (relay0, relay1, outputD0-D3, openCollectors) or alter safety-critical parameters (shockThreshold, shockPeriod). The credential should be provisioned per-device and never embedded in source. This is in `bleexpansion.cpp` which is architecturally coupled to the UUID files under review.

**A06-4** · INFO · Communication Security — Proprietary BLE UUIDs Exposed in Source
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/comm/bleexpansionuuid.cpp:1-83`
**Description:** All 37 proprietary custom UUIDs for the expansion module GATT profile are defined in plaintext in source. These UUIDs serve as the complete enumeration of the device's BLE attack surface. An attacker can use them to enumerate, read, and write characteristics without needing to reverse-engineer firmware. This is an informational finding: UUID confidentiality is not a supported security control in Bluetooth, but the complete GATT profile being in the repository lowers the bar for targeted attacks.

### 3. Input Handling

**A06-5** · MEDIUM · Input Handling — Integer Overflow in Time Delta Accumulation
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/comm/bleinputhandler.cpp:50`
**Description:** The delta between clock samples is computed as `quint32 delta = (clock - m_ignition.clock) / 100` where `clock` is `quint64`. The division result is then added to `quint32` accumulators (`sessionOnTime`, `sessionOffTime`, `usageOnTime`, `usageOffTime`) with no overflow check (lines 57, 58, 65, 66, 130-136, 185-192, 266-287). If the elapsed time between updates exceeds `~429496729.5` seconds (approximately 13.6 years) the `quint32` accumulator wraps silently. More practically, if the clock source is reset, rolls over, or is set to an attacker-controlled value via the `currentRtc` writable characteristic (UUID `00002a2b`), the subtraction `(clock - is.clock)` can produce a very large `quint64` value. After dividing by 100 and truncating to `quint32`, the resulting delta is a large but silent overflow value that corrupts the on-time/off-time accumulators, which are subsequently reported in GMTP messages.

**A06-6** · MEDIUM · Input Handling — Unvalidated BLE-Received Data Used in Time Calculations
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/comm/bleinputhandler.cpp:75`
**Description:** `gCfg->idleTimeout()` is multiplied by 1000 and passed directly to `m_timer->start()` (line 75 and line 254). If `idleTimeout()` returns a value derived from a server-supplied or BLE-received configuration without range validation, the product `idleTimeout() * 1000` can overflow a 32-bit signed integer (Qt's `QTimer::start` takes `int` milliseconds). A value of `idleTimeout() >= 2147484` (approximately 2.1 million seconds) causes signed integer overflow and undefined behaviour. No range check on the configuration value is visible in this file.

**A06-7** · LOW · Input Handling — Debug Output Exposes Internal State
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/comm/bleinputhandler.cpp:47`, `bleinputhandler.cpp:139`
**Description:** `SerialLogger::log()` is called unconditionally (not guarded by a debug build flag) on lines 47 and 139, logging ignition state changes and digital input state changes including the input index and boolean state. If the serial logger is active in production firmware, this leaks vehicle operational state (ignition on/off, digital input transitions) to anyone with physical access to the serial port. This finding is low severity because physical access is required, but it is inconsistent with production hardening.

### 4. Build Security

Build Security: no issues found in the files under review. (`.pro` file analysis is outside the assigned file set for this auditor.)

### 5. Device and Firmware

**A06-8** · HIGH · Device and Firmware — Hardcoded BLE Peripheral Credential in Firmware Image
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/comm/bleexpansion.cpp:9`
**Description:** As noted in A06-3, `AUTH_CODE "uS8MgpklMx"` is a shared static credential baked into every firmware image. Because it is identical across all deployed devices, extraction from any single unit compromises all units in the field. This is a firmware provisioning failure: the authentication code for the BLE expansion module should be unique per device pair and injected at manufacturing or provisioning time, not compiled into the firmware.

### 6. Qt-Specific Security

Qt-Specific Security: no issues found. No `QSslSocket`, `QProcess`, `QSettings`, or QML/QtScript usage is present in the four assigned files. `QTimer` usage is present but the security concern (integer overflow in `start()`) is captured under Input Handling (A06-6).

---

## Summary

| ID | Severity | Category | Location |
|---|---|---|---|
| A06-1 | HIGH | Memory Safety — array index without bounds check | `bleinputhandler.cpp:117` |
| A06-2 | MEDIUM | Memory Safety — manual QTimer lifecycle inconsistency | `bleinputhandler.cpp:211-214` |
| A06-3 | HIGH | Communication Security — hardcoded BLE auth credential | `bleexpansion.cpp:9` |
| A06-4 | INFO | Communication Security — proprietary UUIDs in source | `bleexpansionuuid.cpp:1-83` |
| A06-5 | MEDIUM | Input Handling — integer overflow in time delta accumulation | `bleinputhandler.cpp:50` |
| A06-6 | MEDIUM | Input Handling — unvalidated config used in timer start | `bleinputhandler.cpp:75,254` |
| A06-7 | LOW | Input Handling — unconditional serial debug output | `bleinputhandler.cpp:47,139` |
| A06-8 | HIGH | Device and Firmware — shared static BLE credential in firmware | `bleexpansion.cpp:9` |
# Pass 1 Audit — A07
**Auditor:** A07
**Date:** 2026-02-28
**Branch:** master
**Files reviewed:**
- `/c/Projects/cig-audit/repos/mark3-pvd/comm/canexpansion.h`
- `/c/Projects/cig-audit/repos/mark3-pvd/comm/canexpansion.cpp`
- `/c/Projects/cig-audit/repos/mark3-pvd/comm/canmonitor.h`
- `/c/Projects/cig-audit/repos/mark3-pvd/comm/canmonitor.cpp`

---

## Step 4 — Reading Evidence

### File Pair 1: canexpansion.h / canexpansion.cpp

**File paths:**
- `/c/Projects/cig-audit/repos/mark3-pvd/comm/canexpansion.h`
- `/c/Projects/cig-audit/repos/mark3-pvd/comm/canexpansion.cpp`

**Class name and base classes:**
- `CanExpansion : public QObject`

**Q_OBJECT macro location:**
- `canexpansion.h` line 23

**Every #include directive:**

canexpansion.h:
- `app/cigconfigs.h`
- `<QObject>`
- `<QFile>`
- `<QMap>`
- `<QVector>`
- `<QByteArray>`
- `<QQueue>`
- `<QTimer>`

canexpansion.cpp:
- `canexpansion.h`
- `platform/canbus.h`
- `app/globalconfigs.h`
- `platform/seriallogger.h`
- `platform/gnssreceiver.h`
- `platform/powersupply.h`
- `<QApplication>`
- `<QTimer>`
- `<QDateTime>`
- `<QFile>`
- `<QDebug>`
- `<QDataStream>`

**Every public method with signature and line number:**

canexpansion.h:
- `explicit CanExpansion(EM070::CanBus *canBus, EM070::PowerSupply *ps)` — line 42
- `void setEnabled(bool enable)` — line 44
- `const QByteArray &deviceName() const` — line 46
- `const QByteArray &bleVersion() const` — line 47
- `const QByteArray &mainVersion() const` — line 48
- `const QByteArray &manufacture() const` — line 49
- `const QByteArray &modelNumber() const` — line 50
- `bool relayOutput(CIGCONF::BleExpansionRelay relay) const` — line 52
- `void setRelayOutput(CIGCONF::BleExpansionRelay relay, bool state)` — line 55
- `quint16 relayTimeout(CIGCONF::BleExpansionRelay relay) const` — line 57
- `void setRelayTimeout(CIGCONF::BleExpansionRelay relay, quint16 timeout_in_sec)` — line 60
- `void setCurrentTime(quint32 time)` — line 62
- `bool digitalInput(CIGCONF::BleExpansionDI di) const` — line 64
- `void setShockThreshold(quint32 threshold)` — line 66
- `void setShockPeriod(quint32 period)` — line 67
- `bool isShockQueueEmpty()` — line 69
- `ShockEvent shockEvent()` — line 70
- `bool generateShockMessage(bool force)` — line 72
- `void setGnssReceiver(EM070::GnssReceiver* gnss)` — line 74

**Every signal:**
- `void inputStateChanged(CIGCONF::BleExpansionDI input, bool state)` — line 77
- `void shockOccurred()` — line 78
- `void amberImpactOccurred()` — line 79
- `void redImpactOccurred()` — line 80
- `void accessible(bool yes)` — line 81
- `void expModInfo(QByteArray mainVersion)` — line 82
- `void inactiveNotification(bool inactive, quint32 secs)` — line 83
- `void relayStateChanged(bool relay1, bool relay2)` — line 84

**Every slot (private):**
- `void initialise()` (connected to `m_initTimer` timeout) — line 89
- `void readCanFrame(quint32 id, const QByteArray &ba)` (connected to `CanBus::read`) — line 128
- `void packetHandler()` — line 249
- `void writeFrame()` — line 231
- `void timeout()` (connected to `m_timer` timeout) — line 162

**CAN message IDs / protocol constants defined (canexpansion.cpp):**
- `MK3_ID 0x3C1` — CAN identifier for expmod <-> MK3 comms (line 43)
- `SLIP_END 0xC0`, `SLIP_ESC 0xDB`, `SLIP_ESC_END 0xDC`, `SLIP_ESC_ESC 0xDD` — SLIP framing bytes
- `FROM_MK3_HEADER 0x01`, `TO_MK3_HEADER 0x81` — packet direction headers
- `CMD_WRITE_FLAG 0x8000`
- CMD_DEVICE_NAME (1001), CMD_BLE_FWVER (8), CMD_MAIN_FWVER (10), CMD_MFR_NAME (1002), CMD_MODEL_NUMBER (1003), CMD_RTC_TIME (26)
- CMD_DIGIN_STATE0..3 (31,35,39,43), CMD_RELAY_RESET (48), CMD_RELAY_STATE0 (50), CMD_RELAY_TIMEOUT0 (52), CMD_RELAY_STATE1 (54), CMD_RELAY_TIMEOUT1 (56)
- CMD_SHOCK_COUNT (75), CMD_SHOCK_PEEK (78), CMD_SHOCK_POP (80), CMD_SHOCK_THRESHOLD (82), CMD_SHOCK_PERIOD (84), CMD_SHOCK_MAGMAX (86), CMD_SHOCK_NOTIFY (1004)
- `MAX_BUFFER_SIZE 256` — maximum RX/TX buffer size (line 41)
- `REDIMPACT_SHOCKMSG_TIME 3`, `REDIMPACT_COUNTER_OFF (-1)`

**Every member variable (canexpansion.h):**
- `EM070::CanBus *m_canBus`
- `EM070::PowerSupply *m_powerSupply`
- `EM070::GnssReceiver *m_gnssReceiver`
- `QTimer *m_timer`
- `QTimer *m_initTimer`
- `QByteArray m_rx`
- `QByteArray m_tx`
- `bool m_active`
- `bool m_lastActive`
- `quint32 m_inactiveCount`
- `QByteArray m_deviceName`
- `QByteArray m_bleVersion`
- `QByteArray m_mainVersion`
- `QByteArray m_manufacture`
- `QByteArray m_modelNumber`
- `bool m_digitalInput[4]`
- `bool m_outputRelay[2]`
- `quint16 m_outputRelayTimeout[2]`
- `quint32 m_shockThreshold`
- `quint32 m_shockPeriod`
- `qint32 m_redImpactCounter`
- `quint32 m_shockTimestamp`
- `ShockEvent m_shockEvent1`
- `QQueue<ShockEvent> m_shockEvents`

---

### File Pair 2: canmonitor.h / canmonitor.cpp

**File paths:**
- `/c/Projects/cig-audit/repos/mark3-pvd/comm/canmonitor.h`
- `/c/Projects/cig-audit/repos/mark3-pvd/comm/canmonitor.cpp`

**Class name and base classes:**
- `CanMonitor : public QObject`

**Q_OBJECT macro location:**
- `canmonitor.h` line 18

**Every #include directive:**

canmonitor.h:
- `app/cigconfigs.h`
- `<QObject>`
- `<QFile>`
- `<QMap>`
- `<QVector>`

canmonitor.cpp:
- `canmonitor.h`
- `platform/canbus.h`
- `app/globalconfigs.h`
- `platform/seriallogger.h`
- `<QApplication>`
- `<QTimer>`
- `<QDateTime>`
- `<QTime>`
- `<QFile>`
- `<QDebug>`
- `<QtEndian>`

**Every public method with signature and line number (canmonitor.h):**
- `explicit CanMonitor(EM070::CanBus *canBus)` — line 20
- `bool readCanConfig()` — line 22
- `bool readOldCanConfig()` — line 23
- `void saveCanConfig()` — line 24
- `void calculateCanCrc()` — line 25
- `quint32 canCrc32() const` — line 28
- `void setEnabled(bool enable)` — line 30
- `void clearCanConfig()` — line 32
- `QByteArray canBusConfig() const` — line 33
- `bool setCanBusConfig(const QByteArray &config)` — line 34
- `QByteArray canPgnConfig() const` — line 35
- `bool setCanPgnConfig(const QByteArray &config)` — line 36
- `QByteArray canSpnConfig() const` — line 37
- `bool setCanSpnConfig(const QByteArray &config)` — line 38
- `QByteArray canAttConfig() const` — line 39
- `bool setCanAttConfig(const QByteArray &config)` — line 40
- `QByteArray canLinConfig() const` — line 41
- `bool setCanLinConfig(const QByteArray &config)` — line 42
- `QByteArray canBydConfig() const` — line 43
- `bool setCanBydConfig(const QByteArray &config)` — line 44
- `QByteArray canLin2Config() const` — line 45
- `bool setCanLin2Config(const QByteArray &config)` — line 46
- `bool isXferEnabled() const` — line 48
- `QByteArray attributeName(quint8 index) const` — line 49
- `CIGCONF::CanAttributeType attributeType(quint8 index) const` — line 50
- `void setVdiAccess(bool access, bool inhibit)` — line 52
- `void enableVdi(bool enable)` — line 53

**Every signal:**
- `void resetCanStates(bool resetLast)` — line 60
- `void stateUpdated(quint8 index, quint32 state)` — line 61

**Every slot (private, connected via constructor):**
- `void updateBusConfig()` (connected to `m_timer` timeout) — line 1301
- `void updateRequests()` (connected to `m_timer` timeout) — line 1313
- `void readCanFrame(quint32 id, const QByteArray &ba)` (connected to `CanBus::read`) — line 1369
- `void perfTimer()` (connected to `m_perfTimer` timeout, conditional on `PERF_MON`) — line 101

**CAN message IDs / protocol constants defined (canmonitor.cpp):**
- `CAN_CONF_FILE_OLD "cancfg.dat"`, `CAN_CONF_FILE "cancfgnew.dat"`
- `LIN_CANID_OFFSET 0x10`, `LIN_ADDR_OFFSET 0x4000`
- `BYD_CANID_XOR 0x380`, `BYD_ADDR_OFFSET 0x0B000000`
- `UPDATE_DEFER 3000` — timer delay before applying config changes
- Rule name pattern constants: RULE_SEAT_U/L, RULE_TRAC_U/L, RULE_HYDR_U/L, RULE_HYDL_U/L, RULE_HRS_U/L, RULE_BACD_U/L, RULE_BLAN_U/L

**Every member variable (canmonitor.h):**
- `EM070::CanBus *m_canBus`
- `QTimer *m_timer`
- `QFile m_file`
- `quint32 m_canCrc32`
- `bool m_enabled`
- `BusConfig m_busConfig`
- `PgnConfig m_pgnConfigs[CAN_MAX_PGN_IDX]` — 10 entries
- `SpnConfig m_spnConfigs[CAN_MAX_SPN_IDX]` — 20 entries
- `AttConfig m_attConfigs[CAN_MAX_ATT_IDX]` — 15 entries
- `QMap<quint8, quint8> m_attrToSpn`
- `quint32 m_spnState[CAN_MAX_SPN_IDX]` — 20 entries
- `quint32 m_perfCounter`
- `QTimer *m_perfTimer`
- `bool m_vdiAccess`
- `bool m_vdiInhibit`

---

## Step 5 — Security Review

### 1. Memory Safety

**A07-1** · HIGH · Memory Safety
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/comm/canexpansion.cpp:158-159`
**Description:** The receive buffer `m_rx` is allowed to grow unboundedly from CAN frame data before the overflow guard at line 158 is checked. The guard truncates to the last `MAX_BUFFER_SIZE` (256) bytes using `m_rx.right(MAX_BUFFER_SIZE)`, which silently discards leading data rather than preventing overflow. An attacker who can inject a continuous stream of CAN frames with id `0x3C1` and no SLIP_END byte can cause `m_rx` to grow to an arbitrarily large size before truncation, consuming device heap memory. Over repeated cycles this produces unbounded heap growth. The correct fix is to refuse new data once the limit is reached, not to trim after the fact.

**A07-2** · HIGH · Memory Safety
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/comm/canexpansion.cpp:225-226`
**Description:** The transmit buffer `m_tx` has the same post-hoc truncation pattern as `m_rx`. After `sendPacket` appends a new SLIP-encoded command to `m_tx`, it checks `if (m_tx.size() > MAX_BUFFER_SIZE)` and discards the beginning of the buffer. This silently corrupts in-flight commands rather than rejecting the write. A rapid sequence of `setRelayOutput`, `setRelayTimeout`, `setCurrentTime`, etc. calls can cause valid command packets to be silently dropped or fragmented.

**A07-3** · MEDIUM · Memory Safety
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/comm/canexpansion.cpp:76`
**Description:** `memset(&m_shockEvent1, 0, sizeof(ShockEvent))` is used in the constructor and in `generateShockMessage` (line 588) to zero the `ShockEvent` struct. `ShockEvent` contains a `bool isIgnitionOn` member and several `quint` fields. Using `memset` to zero a struct that contains `bool` members is technically implementation-defined (zero is a valid false representation on all current targets, but this is not guaranteed by the C++ standard). More importantly, if `ShockEvent` is ever extended with a non-POD member, the `memset` calls at lines 76 and 588 will silently corrupt those members. This is a latent safety risk in safety-critical shock event handling.

**A07-4** · MEDIUM · Memory Safety
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/comm/canexpansion.cpp:64`
**Description:** `digitalInput(CIGCONF::BleExpansionDI di)` computes the array index as `di - CIGCONF::BleExpDI1` with no bounds check. `BleExpDI1` through `BleExpDI4` are enum values 0–3, and `m_digitalInput` has size 4. If a caller passes any value outside this range (or a future enum value is added), this produces an out-of-bounds array access. The member is also never written by `readCanFrame` or `packetHandler` — the `inputStateChanged` signal is emitted instead of updating `m_digitalInput`, making `digitalInput()` always return uninitialized memory (the array is not initialized in the constructor or with `memset`). This is a logic and memory safety issue.

**A07-5** · MEDIUM · Memory Safety
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/comm/canmonitor.cpp:400`
**Description:** `qstrcpy(config.CanSignalInfo.canAtt[i].name, attConfig.name)` in `calculateCanCrc()`. Although `attConfig.name` is bounded by `CAN_ATT_NAME_LEN` (10 bytes) and the destination `canAtt[i].name` is also declared with `CAN_ATT_NAME_LEN` characters (cigconfigs.h line 233), `qstrcpy` does no bounds checking. If the source `attConfig.name` is ever not null-terminated within its 10-byte field (possible if binary config data is loaded via `memcpy` from a file without strict validation), this produces a stack buffer overread/overwrite. `qstrncpy` with an explicit length would be the safe equivalent.

**A07-6** · MEDIUM · Memory Safety
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/comm/canmonitor.cpp:818`
**Description:** `qstrcpy(attribute.name, name.constData())` in `setCanAttConfig()`. The `name` `QByteArray` is checked at line 772 (`name.size() >= CAN_ATT_NAME_LEN` returns false), meaning a name of exactly `CAN_ATT_NAME_LEN - 1` bytes (9 bytes) is accepted. However `qstrcpy` copies the null terminator too, so a 9-byte input will write 10 bytes including the null, which exactly fits. If the check at line 772 ever changes to `>` instead of `>=`, or if `CAN_ATT_NAME_LEN` is reduced without updating the check, an off-by-one overflow occurs. The use of `qstrcpy` rather than `qstrncpy` leaves no margin for error. Additionally, the `name` field of `AttConfig` is `char[CAN_ATT_NAME_LEN]` and there is no guarantee it is null-terminated when read back from a binary file via `memcpy`.

**A07-7** · LOW · Memory Safety
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/comm/canmonitor.cpp:449-458`
**Description:** In `childSpnIndexes()`, `spnIndexes[config.siblingIndex]` is written using `siblingIndex` as the array index into `spnIndexes[CAN_MAX_LINK_IDX]` (size 8). `siblingIndex` is a `quint8` loaded from the config file via `memcpy` with no range check at read time. A corrupted or malicious config file can set `siblingIndex` to a value 8–255, causing an out-of-bounds write to the stack-allocated `spnIndexes` array. The call at line 936 `spnConfig.siblingIndex = childSpnIndexes(pgnIndex).size()` does bound the newly-set value, but existing entries in the config file are not re-validated.

---

### 2. Communication Security

**A07-8** · HIGH · Communication Security
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/comm/canexpansion.cpp:43`
**Description:** The CAN identifier `MK3_ID 0x3C1` is hardcoded and is the sole authentication mechanism for the expansion module communication channel. The SLIP protocol over CAN has no message authentication code, no sequence number, and no replay protection. Any device on the same CAN bus that sends frames with id `0x3C1` using the `TO_MK3_HEADER (0x81)` direction byte will be accepted as a legitimate expansion module and can inject arbitrary commands including relay state changes (`CMD_RELAY_STATE0`, `CMD_RELAY_STATE1`) and shock threshold manipulation (`CMD_SHOCK_THRESHOLD`). This is a spoofing risk on the CAN bus.

**A07-9** · MEDIUM · Communication Security
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/comm/canexpansion.cpp:251`
**Description:** The `packetHandler()` state machine uses a `static` local variable `sm` and `shocks_read` to track protocol state. Static locals are shared across all invocations of `packetHandler()`, which is called from the slot `readCanFrame`. Because `CanExpansion` may have only one instance, this is not an immediate multi-instance issue, but a reset of the `m_rx` buffer (line 149) does not reset `sm`, meaning an attacker who sends a valid `CMD_MODEL_NUMBER` response at any time can reset the device into full re-initialization (re-sending shock threshold, relay states, etc.) without going through the intended handshake order.

**A07-10** · MEDIUM · Communication Security
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/comm/canmonitor.cpp:15-16`
**Description:** CAN configuration is persisted to plaintext binary files `cancfg.dat` / `cancfgnew.dat` with only a CRC32 integrity check (not an HMAC or cryptographic signature). CRC32 is not collision-resistant — an attacker with filesystem write access can craft a replacement config file with an identical CRC32, injecting arbitrary CAN PGN/SPN configuration. This could alter which vehicle CAN signals are used for safety-critical decisions (seat sensor, traction control, hydraulics).

---

### 3. Input Handling

**A07-11** · HIGH · Input Handling
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/comm/canexpansion.cpp:353-354`
**Description:** In `packetHandler()`, the `CMD_DIGIN_STATE0` through `CMD_DIGIN_STATE3` cases check `m_rx.size() < 12` before reading, but only a single `quint8 state` value is actually read via `QDataStream`. A check of `< 12` implies a 12-byte minimum but the actual data consumed is 4 bytes (1 header + 2 cmd bytes + 1 state byte). The minimum-size check is inconsistent with actual data consumption. This is not immediately exploitable given QDataStream's read will not crash on a short buffer, but it indicates an unchecked assumption about the protocol message layout that could mask truncated or malformed messages.

**A07-12** · HIGH · Input Handling
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/comm/canexpansion.cpp:608-661`
**Description:** `popShockEvent()` checks `ba.size() >= 8` before reading, but only reads 8 bytes (`quint32 timestamp` + `quint32 magnitude`) via `QDataStream`. The function then proceeds to use the parsed `event.magnitude` directly to trigger safety-critical signals (`amberImpactOccurred()`, `redImpactOccurred()`) and to compare against `m_shockThreshold`. There is no upper-bound check on `event.magnitude`: a spoofed CAN frame from another node on the bus (see A07-8) can inject an arbitrarily large magnitude value, causing false red/amber impact alerts. There is also no validation of `event.timestamp`: a zero or very large timestamp could interfere with the shock deduplication logic in `generateShockMessage()`.

**A07-13** · MEDIUM · Input Handling
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/comm/canmonitor.cpp:1538`
**Description:** In `updateSpnState()`, the expression `(1U << spnConfig.width) - 1` is used to compute a bit mask. `spnConfig.width` is a `quint8` (0–255). If `width` equals 32, the shift `1U << 32` is undefined behavior in C++ (left-shifting a 32-bit value by its bit width). If `width` is 0, the result is `(1U << 0) - 1 = 0`, producing a zero mask that silently discards all data bits. `width` comes from a config file that is only protected by CRC32, so a tampered config can inject a `width` of 32 or greater. The fix is to clamp `spnConfig.width` to the range 1–31 before use in this expression.

**A07-14** · MEDIUM · Input Handling
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/comm/canmonitor.cpp:1579-1586`
**Description:** In the BCD decode branch (`case 'b'`) of `updateSpnState()`, `digits = spnConfig.width / 4`. The loop `for (quint8 i=0; i<sizeof(spnData); ++i)` iterates 4 times (sizeof `quint32`). The subsequent trimming loop `for (quint8 i=2*sizeof(spnData)-digits; i>0; --i)` relies on `digits` being `<= 2*sizeof(spnData)` (i.e., `<= 8`). If `spnConfig.width` is 0, `digits` is 0 and the trim loop counter is `2*4 - 0 = 8`, which may trim too many digits. If `width > 32`, `digits > 8` and the subtraction `2*4 - digits` underflows (wrapping to a large positive number for unsigned `quint8`), causing the trim loop to divide `spnState` by 10 hundreds of times, always producing 0. This silent data corruption affects the vehicle hours/BAC data derived from CAN.

**A07-15** · MEDIUM · Input Handling
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/comm/canmonitor.cpp:1508`
**Description:** In `updateState()`, the `CanAttributeCount`/`CanAttributeTime` case computes `spnStates |= m_spnState[j] << j`. The loop variable `j` iterates up to `CAN_MAX_SPN_IDX` (20). When `j >= 32`, the shift `m_spnState[j] << j` is undefined behavior on 32-bit systems (shifting a 32-bit value by 32 or more). An attacker who controls CAN configuration (see A07-10) can arrange for a `spnMask` bit to be set at position 31 or beyond, triggering this undefined behavior and potentially causing unpredictable safety-critical state evaluation.

**A07-16** · LOW · Input Handling
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/comm/canmonitor.cpp:1282-1283`
**Description:** In `createRequest()` for the `LindeExtended` protocol, `quint16 addr = spnConfig.spn` truncates a `quint64` SPN address field to 16 bits. If the config was set via `setCanLinConfig` the value is bounded to `0xffff - LIN_ADDR_OFFSET`, but if loaded from a binary file via `memcpy` (where `spnConfig.spn` is a full `quint64`), a value with upper bits set will be silently truncated. This could cause the device to poll the wrong CAN address for sensor data.

---

### 4. Build Security

Build Security: no issues found in the reviewed source files. (The `.pro` build file is not within the assigned file set for this auditor; compiler flags are not visible in these files.)

---

### 5. Device and Firmware

**A07-17** · HIGH · Device and Firmware
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/comm/canexpansion.cpp:319-320`
**Description:** Shock detection thresholds are loaded from `gCfg->shockThreshold()` and `gCfg->shockPeriod()` and written to the expansion module over CAN via `setShockThreshold()` and `setShockPeriod()`. There is no range validation applied to these values before they are sent. A configuration that sets `shockThreshold` to `0xFFFFFFFF` would suppress all shock alerts (no impact would ever exceed the threshold), and a `shockPeriod` of 0 or very large value would break the shock event timing. Because these are safety-critical thresholds for a vehicle proximity/impact detection device, values received from a remote configuration source must be validated against a safe operating range before being applied.

**A07-18** · MEDIUM · Device and Firmware
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/comm/canexpansion.cpp:637-643`
**Description:** The amber impact threshold is computed inline as `gCfg->shockRedImpact() / 2`. There is no separate amber threshold configuration — it is always half the red impact threshold. If `gCfg->shockRedImpact()` returns 1 (minimum valid value), the amber threshold is 0, meaning every shock above zero triggers an amber alert. If it returns 0 (disabled), the division and the amber alert check are guarded at line 637 (`gCfg->shockRedImpact()` used as a boolean). The implicit coupling of amber to red thresholds and the absence of an independently validated amber threshold is a safety-critical design issue.

**A07-19** · MEDIUM · Device and Firmware
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/comm/canmonitor.cpp:1600-1613`
**Description:** `initVdi()` hardcodes the VDI (Vehicle Data Interface) CAN configuration by calling `setCanLinConfig` and `setCanAttConfig` with string literals. The CAN identifiers (`195`, `295`), offsets, widths, and attribute names (`SEAT`, `TRACK`, `HYDR`, `HRSS0`) are baked into firmware. Any change to the VDI hardware interface requires a firmware update. More critically, these hardcoded values bypass the CRC-validated configuration file mechanism, meaning VDI mode operates with a fixed, unverifiable configuration that cannot be audited through the same channel as standard CAN configuration.

---

### 6. Qt-Specific Security

**A07-20** · MEDIUM · Qt-Specific Security
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/comm/canexpansion.cpp:659`
**Description:** `qDebug() << "EXPMOD Shock" << event.timestamp << event.magnitude;` at line 659 logs shock event data including timestamp and magnitude unconditionally on every received shock event. `qDebug()` output is active in both debug and release builds unless explicitly disabled at compile time (`QT_NO_DEBUG_OUTPUT` or `qt_configure_warnings`). Shock event data (timestamps, magnitudes) may be logged to a serial console or other output that is accessible in a deployed device. This leaks operational telemetry that could be used by an attacker to understand the device's sensitivity thresholds and timing.

**A07-21** · MEDIUM · Qt-Specific Security
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/comm/canmonitor.cpp:415`
**Description:** `qDebug() << "CAN Config CRC: " << m_canCrc32;` logs the CAN configuration CRC32 value unconditionally every time `calculateCanCrc()` is called. An attacker monitoring the serial output gains the exact CRC32 needed to craft a replacement `cancfgnew.dat` file with the same checksum but altered safety-critical configuration (see A07-10). Logging the CRC value externally removes any practical security value the integrity check might otherwise provide.

**A07-22** · LOW · Qt-Specific Security
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/comm/canmonitor.cpp:1522`
**Description:** `qDebug() << "CAN Name/State:" << attr.name << attState;` logs CAN attribute names and their computed state values on every state change. This fires on every CAN frame that changes a monitored attribute. Depending on the serial logger configuration, this may produce high-volume diagnostic output in production firmware that exposes vehicle operational state (seat occupancy, traction, hydraulic state) to anyone with serial console access.

---

## Summary of Findings

| ID | Severity | Category |
|----|----------|----------|
| A07-1 | HIGH | Memory Safety — unbounded RX buffer growth before truncation |
| A07-2 | HIGH | Memory Safety — unbounded TX buffer truncation corrupts commands |
| A07-3 | MEDIUM | Memory Safety — memset on struct with bool; latent risk if extended |
| A07-4 | MEDIUM | Memory Safety — uninitialized m_digitalInput array; no bounds check on enum index |
| A07-5 | MEDIUM | Memory Safety — qstrcpy without bounds on attConfig.name in calculateCanCrc |
| A07-6 | MEDIUM | Memory Safety — qstrcpy without bounds in setCanAttConfig; off-by-one risk |
| A07-7 | LOW | Memory Safety — unvalidated siblingIndex from config file used as array index |
| A07-8 | HIGH | Communication Security — no CAN message authentication; relay/threshold spoofable |
| A07-9 | MEDIUM | Communication Security — static state machine variable allows out-of-order injection |
| A07-10 | MEDIUM | Communication Security — CRC32-only integrity on config file; not collision-resistant |
| A07-11 | HIGH | Input Handling — inconsistent size check in DIGIN packet handler |
| A07-12 | HIGH | Input Handling — no upper-bound validation on shock magnitude before safety signal |
| A07-13 | MEDIUM | Input Handling — undefined behavior when spnConfig.width >= 32 in bit shift |
| A07-14 | MEDIUM | Input Handling — BCD decode loop underflow when width is 0 or >32 |
| A07-15 | MEDIUM | Input Handling — undefined shift by >= 32 in spnStates computation |
| A07-16 | LOW | Input Handling — quint64 spn address silently truncated to quint16 for LindeExtended |
| A07-17 | HIGH | Device and Firmware — no range validation on shock threshold/period before applying |
| A07-18 | MEDIUM | Device and Firmware — amber impact threshold implicitly derived; no independent validation |
| A07-19 | MEDIUM | Device and Firmware — VDI CAN config hardcoded, bypasses validated config file |
| A07-20 | MEDIUM | Qt-Specific Security — qDebug logs shock telemetry unconditionally in production |
| A07-21 | MEDIUM | Qt-Specific Security — qDebug logs CAN config CRC, undermines integrity check |
| A07-22 | LOW | Qt-Specific Security — qDebug logs vehicle operational state on every CAN state change |
# Pass 1 Security Audit — A08
**Auditor:** A08
**Date:** 2026-02-28
**Branch:** master
**Repo:** /c/Projects/cig-audit/repos/mark3-pvd

---

## Reading Evidence

### File Pair 1: canstatehandler

**File paths:**
- `/c/Projects/cig-audit/repos/mark3-pvd/comm/canstatehandler.h`
- `/c/Projects/cig-audit/repos/mark3-pvd/comm/canstatehandler.cpp`

**Class name and base classes:**
- `CanStateHandler : public QObject`

**Q_OBJECT macro location:**
- `canstatehandler.h` line 12

**Every public method with signature and line number:**
- `explicit CanStateHandler(CanMonitor *canMonitor)` — h:16 / cpp:14
- `void updateIdleTimer()` — h:17 / cpp:91
- `QByteArray canStates(DigitalFormat format, bool autoReset)` — h:18 / cpp:117
- `void resetStates(bool resetLast)` — h:19 / cpp:73

**Every signal:**
- `void idleTimeout()` — h:22

**Every slot (Qt connect targets, private methods connected via signal/slot):**
- `void updateState(quint8 index, quint32 state)` — cpp:24 (connected to `CanMonitor::stateUpdated`)
- `void resetStates(bool resetLast)` — cpp:73 (connected to `CanMonitor::resetCanStates`)

**Every #include directive:**
- `canstatehandler.h`: `"app/cigconfigs.h"`, `<QObject>`
- `canstatehandler.cpp`: `"canstatehandler.h"`, `"comm/canmonitor.h"`, `"app/globalconfigs.h"`, `"platform/seriallogger.h"`, `<QTimer>`, `<QDebug>`

**Every member variable:**
- `CanState m_canStates[CAN_MAX_ATT_IDX]` — h:47 (fixed array of 15 `CanState` structs)
- `CanMonitor *m_canMonitor` — h:49 (raw pointer, owned by parent QObject)
- `QTimer *m_timer` — h:50 (raw pointer, conditionally allocated/deleted)

**Nested struct CanState (private):**
- `quint32 state`
- `union { struct { quint32 sessionOnTime, sessionOffTime, usageOnTime, usageOffTime } time; struct { quint32 sessionRisings, sessionFallings, usageRisings, usageFallings } count; }`
- `quint64 clock`

---

### File Pair 2: ftpclient

**File paths:**
- `/c/Projects/cig-audit/repos/mark3-pvd/comm/ftpclient.h`
- `/c/Projects/cig-audit/repos/mark3-pvd/comm/ftpclient.cpp`

**Class name and base classes:**
- `FtpClient : public QObject`

**Q_OBJECT macro location:**
- `ftpclient.h` line 15

**Every public method with signature and line number:**
- `explicit FtpClient(BackgroundWorker *parent)` — h:17 / cpp:18
- `void download(const QUrl &url)` — h:18 / cpp:31
- `void startTransfer()` — h:19 / cpp:46
- `void writeQueue()` — h:21 / cpp:119
- `void readQueue()` — h:22 / cpp:144
- `void setPowerState(CIGCONF::PowerState state)` — h:24 / cpp:109

**Every signal:**
- `void fileUpdated(const QString &fileName)` — h:27
- `void sendGmtpMessage(CIGCONF::GmtpMessage msg, const QByteArray &extra)` — h:28
- `void nextTransfer()` — h:29 (also used as internal trigger; connected to `startTransfer()`)

**Private methods (slots via connect):**
- `void readData()` — cpp:173 (connected to `QNetworkReply::readyRead`)
- `void downloadFinished()` — cpp:197 (connected to `QNetworkReply::finished`)
- `void setReport(CIGCONF::FtpErrorCode errorCode)` — cpp:273
- `void popQueue()` — cpp:166

**Every #include directive:**
- `ftpclient.h`: `"app/cigconfigs.h"`, `<QObject>`, `<QUrl>`, `<QSaveFile>`, `<QQueue>`
- `ftpclient.cpp`: `"ftpclient.h"`, `"app/backgroundworker.h"`, `"app/globalconfigs.h"`, `"platform/seriallogger.h"`, `<QNetworkAccessManager>`, `<QNetworkReply>`, `<QFile>`, `<QFileInfo>`, `<unistd.h>` (ARM only)

**Preprocessor macros defined in ftpclient.cpp:**
- `MAX_FILE_SIZE (16 * 1024 * 1024)` — cpp:14
- `FTP_QUEUE_FILE "/home/ftpqueue.txt"` — cpp:15
- `FTP_RETRIES 5` — cpp:17

**Every member variable:**
- `BackgroundWorker *m_worker` — h:37 (raw pointer, parent)
- `QNetworkAccessManager *m_manager` — h:38 (raw pointer, parented to this)
- `QUrl m_url` — h:39
- `QSaveFile m_file` — h:40
- `quint32 m_fileSize` — h:41
- `bool m_transferInProgress` — h:43
- `QQueue<QUrl> m_queue` — h:45
- `quint32 m_retries` — h:46
- `bool m_queueFile` — h:47
- `CIGCONF::PowerState m_powerState` — h:48

---

## Security Review

### 1. Memory Safety

**A08-1** · HIGH · Memory Safety
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/utils/bytearray.h:25`
**Description:** `ByteArray::asprintf()` calls `vsnprintf` with a null buffer to compute the required size, then calls `vsprintf` (unbounded) to write into the allocated buffer. The second `va_list ap` is already exhausted after the first `vsnprintf` call — `va_end` is called on line 21 and `va_start` is never called again before the `vsprintf` on line 25. This is undefined behaviour: the second `vsprintf` uses a spent `va_list`. Depending on the platform ABI, the output may be truncated, the buffer may be overflowed, or the stack may be corrupted. This function is called in both `canstatehandler.cpp` and `ftpclient.cpp` for all formatted CAN state and FTP monitoring messages. The correct fix is to call `va_start`/`va_end` a second time around the `vsprintf` call, or to use `vsnprintf` with the known size.

**A08-2** · MEDIUM · Memory Safety
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/comm/canstatehandler.cpp:44`
**Description:** The time delta computation `quint32 delta = (clock - cs.clock) / 100` casts the result of a `quint64` subtraction to `quint32` without bounds checking. `clock` and `cs.clock` are both `quint64`. If `cs.clock` is uninitialised or zero (e.g. on first call before any reset, or if `DEPENDS_ON_TRIGGER` is defined and `cs.clock` has not been set), the subtraction yields a very large 64-bit value. Dividing by 100 and truncating to `quint32` silently discards the upper 32 bits. The resulting delta is then added to `sessionOnTime`/`sessionOffTime`/`usageOnTime`/`usageOffTime` without any overflow check, meaning the 32-bit accumulators can wrap to zero, corrupting usage time records — which are safety-relevant (operator working-time data).

**A08-3** · MEDIUM · Memory Safety
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/comm/canstatehandler.cpp:67`
**Description:** The idle timer is started with `m_timer->start(gCfg->idleTimeout() * 1000)`. `idleTimeout()` returns `quint16` (max 65535 seconds). Multiplying `quint16` by the integer literal `1000` is evaluated as a signed `int` multiplication on most platforms, giving a maximum value of approximately 65,535,000 ms (about 65 million). This fits within a 32-bit signed int, so no overflow occurs in the worst case; however the multiplication is implicitly widened, which is reliant on platform int width. The same pattern occurs at line 114. This is a low-severity concern but warrants an explicit cast to `quint32` before the multiplication.

**A08-4** · LOW · Memory Safety
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/comm/ftpclient.cpp:179`
**Description:** `m_fileSize` is assigned from `reply->header(QNetworkRequest::ContentLengthHeader).toUInt()`. The `Content-Length` header value arrives from the remote FTP server over an unauthenticated, plaintext channel (see A08-6). An attacker who can intercept or spoof the server response can set this header to zero, bypassing the `MAX_FILE_SIZE` guard on line 180 entirely. When `m_fileSize` is zero the check `m_file.size() == m_fileSize` at line 212 is evaluated as zero-equals-zero only if no data was written, but the comment on line 178 notes this is already known to be unreliable. The actual downloaded size is then bounded only by the per-read check at line 191, which is a secondary defence.

### 2. Communication Security

**A08-5** · CRITICAL · Communication Security
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/app/backgroundworker.cpp:576`
**Description:** The FTP URL scheme is hardcoded as `"ftp"` (`url.setScheme("ftp")`). The device downloads firmware updates (`FILE_FLEETMS_FW` = `/mnt/sd/FleetIQ360App`), driver ID lists, master ID lists, technician ID lists, checklist files, and login screen images over plain, unencrypted FTP. FTP transmits all data — including the FTP username and password (lines 579–580, received as plaintext from the GMTP server command) — in cleartext on the wire. Any attacker with network access can observe credentials, intercept and replace downloaded files (including firmware), and inject arbitrary content. FTPS or SFTP must be used instead.

**A08-6** · CRITICAL · Communication Security — Firmware Update via Plaintext FTP
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/comm/ftpclient.cpp:83`
**Description:** The file `FILE_FLEETMS_FW` (`/mnt/sd/FleetIQ360App`) is explicitly handled as a known file name in `startTransfer()` and is processed as a firmware update in `backgroundworker.cpp`'s `updateSelf()` function. This firmware is downloaded over plain FTP with no transport security. The only integrity check applied after download is a 16-bit CRC (`crc16`), which is neither cryptographically secure nor sufficient to prevent a malicious firmware image from passing validation. An attacker who can perform a man-in-the-middle attack on the FTP session can replace the firmware image with a tampered binary that passes the CRC check. There is no cryptographic signature verification. This constitutes a complete remote code execution vector on the physical device.

**A08-7** · HIGH · Communication Security
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/comm/ftpclient.cpp:70`
**Description:** The `SerialLogger::log` call on line 70 logs `"[FTP:START] Starting file transfer: " + fileName`. The `fileName` value is derived from the server-supplied URL path without sanitisation. Similarly, lines 71, 89, 96, 206, 208, 252, 256, 258, and 259 embed the file name or the full file path into GMTP monitoring messages using `ByteArray::asprintf` with a string-concatenation format rather than a `%s` placeholder. The resulting format string is constructed from partially server-controlled data. While `ByteArray::asprintf` takes a `const char *cformat`, the pattern `ByteArray::asprintf("FTPF_XFER_START," + fileName.toLatin1() + ",%d", m_retries)` concatenates a runtime string into the format argument position. If `fileName` contains `%` characters, those will be interpreted as format specifiers, constituting a format string vulnerability in the context of the underlying `vsnprintf`/`vsprintf` calls.

**A08-8** · HIGH · Communication Security
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/comm/ftpclient.cpp:15`
**Description:** The FTP queue persistence file is hardcoded to `/home/ftpqueue.txt`. This file stores FTP URLs including embedded credentials (username and password are part of the `QUrl` serialised with `url.toString()` on line 131). These credentials are written to the filesystem in plaintext. If the device's filesystem is accessible (e.g. via a physical interface or another process), the FTP credentials can be extracted from this file.

**A08-9** · MEDIUM · Communication Security
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/comm/ftpclient.cpp:131`
**Description:** `file.write(url.toString().toLatin1() + '\n')` serialises the full `QUrl` — including scheme, username, password, host, port, and path — to the queue file. Qt's `QUrl::toString()` includes the password in the output by default (`QUrl::FullyEncoded`). FTP credentials are therefore stored in plaintext on the device filesystem between power cycles.

### 3. Input Handling

**A08-10** · HIGH · Input Handling
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/comm/ftpclient.cpp:68`
**Description:** The `fileName` used to select the local destination file path is derived from `m_url.fileName()` (line 68), where the URL originates from a remote GMTP server command. The matching logic (lines 73–90) compares the URL file name against a whitelist of known file names. However, if none of the known file names match, the fallback on line 88 constructs the destination path as `"/mnt/sd/" + fileName`. If `fileName` contains path-traversal sequences (e.g. `../home/dlist.txt`), `QSaveFile::setFileName` will resolve the path outside `/mnt/sd/`. A server-controlled (or intercepted) GMTP command can therefore write arbitrary content to arbitrary locations in the device filesystem. `QFileInfo::fileName()` on the URL strips directory components in most cases, but this is not explicit sanitisation and should not be relied upon as a security control.

**A08-11** · MEDIUM · Input Handling
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/comm/ftpclient.cpp:144`
**Description:** `readQueue()` reads URLs from `/home/ftpqueue.txt` one line at a time with `file.readLine()`. There is no maximum line length enforced: `QFile::readLine()` without a `maxlen` argument will read until a newline or EOF, with no bound on how much memory it may allocate. A maliciously crafted or corrupted queue file with a very long line (no newline until EOF) will cause unbounded heap allocation. In an embedded environment with constrained RAM, this can cause an out-of-memory condition leading to device crash.

**A08-12** · MEDIUM · Input Handling
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/comm/ftpclient.cpp:148`
**Description:** The `readQueue()` loop uses `while (1)` and breaks only on an empty line. If the queue file is malformed and contains no empty lines and no EOF-triggered empty read, the loop condition depends entirely on `file.readLine()` returning an empty string at EOF, which it does — but the loop provides no explicit defence against a corrupted file with no terminating newline. More critically, there is no validation that the lines read are valid FTP URLs before they are enqueued. Malformed or malicious URL strings are silently enqueued as `QUrl` objects and later passed to `QNetworkAccessManager::get()`. Qt's `QNetworkAccessManager` will reject non-HTTP/FTP schemes, but no explicit scheme validation is performed before enqueue.

**A08-13** · LOW · Input Handling
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/comm/canstatehandler.cpp:26`
**Description:** The `updateState` slot validates the `index` parameter against `CAN_MAX_ATT_IDX` (value 15) with a bounds check on line 26. This is correct. However, the `state` parameter (a `quint32`) is accepted without any range validation. It is stored directly in `cs.state` and compared for equality to determine edge direction. For `CanAttributeTime` type, the truthiness of `state` controls which accumulator is incremented. No upper bound is enforced on the `state` value. If the CAN bus delivers unexpected state values this is handled correctly for the existing logic, but it is noted for completeness.

### 4. Build Security

**A08-14** · HIGH · Build Security
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/mk3.pro`
**Description:** The project file contains no compiler security hardening flags. There is no `-fstack-protector-strong`, no `-D_FORTIFY_SOURCE=2`, no `-fPIE`/`-pie`, and no `-Wformat -Wformat-security`. On an embedded Linux ARM device with these flags absent, buffer overflows and format string vulnerabilities (see A08-1, A08-7) have no compile-time or runtime detection. The only security-related define present is `QT_DEPRECATED_WARNINGS`.

**A08-15** · MEDIUM · Build Security
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/mk3.pro`
**Description:** The project file does not set `CONFIG += release` nor include `QMAKE_STRIP` directives. There is no evidence that debug symbols are stripped from the production build. Debug symbols in a deployed embedded firmware binary expose internal function names, data structure layouts, and source file paths to physical attackers who can read the firmware image.

**A08-16** · LOW · Build Security
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/comm/ftpclient.cpp:157`
**Description:** `qDebug() << "Could not remove " << file.fileName()` leaks the internal filesystem path of the queue file to any debug output channel that is active in the production build. The queue file path (`/home/ftpqueue.txt`) is also hardcoded in the macro. If debug output reaches a serial console or log aggregator accessible to untrusted parties, internal filesystem layout is disclosed.

### 5. Device and Firmware

**A08-17** · CRITICAL · Device and Firmware
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/comm/ftpclient.cpp:83` and `/c/Projects/cig-audit/repos/mark3-pvd/app/backgroundworker.cpp:244`
**Description:** Firmware updates are delivered via plain FTP (`FILE_FLEETMS_FW` = `/mnt/sd/FleetIQ360App`) and integrity is verified only by a 16-bit CRC stored in the first 8 bytes of the firmware image (`magic & 0xffff`, backgroundworker.cpp line 244). A 16-bit CRC provides 65536 possible values and can be trivially brute-forced or preimage-attacked. There is no cryptographic signature (RSA, ECDSA, or similar) on the firmware image, no secure hash (SHA-256 or equivalent), and no chain of trust. An attacker who intercepts the FTP transfer (trivial given the plaintext protocol) can produce a malicious firmware image that passes the CRC check. This allows persistent, undetected compromise of the device firmware.

**A08-18** · HIGH · Device and Firmware
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/app/cigconfigs.h:64–73`
**Description:** Multiple sensitive file paths are hardcoded as compile-time macros: `FILE_DRIVER_IDS` (`/home/dlist.txt`), `FILE_MASTER_IDS` (`/home/mlist.txt`), `FILE_TECH_IDS` (`/home/tlist.txt`), `FILE_CHECKLIST` (`/home/PREOP.TXT`), `FILE_CHECKLIST_100` (`/home/PREOP100.TXT`), `FILE_FLEETMS_FW` (`/mnt/sd/FleetIQ360App`), and `FILE_LOGIN_SCREEN` (`/home/login.png`). These paths are all downloaded via FTP and written directly to the live filesystem without intermediate staging in an isolated directory. An attacker with FTP-level access (which requires only intercepting a GMTP command) can overwrite driver ID lists and checklist files, directly affecting who is permitted to operate the vehicle and what safety checks are enforced.

**A08-19** · MEDIUM · Device and Firmware
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/app/backgroundworker.cpp:151`
**Description:** `qDebug() << "OTA Update"` is present in the firmware update path. If the debug build is used in production (no `CONFIG += release` is enforced — see A08-15), debug output includes internal state information about the update process. Additionally, the firmware update function reads the firmware magic value from the first 8 bytes of the downloaded file and uses it to validate size and derive the CRC. The validation relies on the magic value `0x43490000` — this constant is visible in source and constitutes partial disclosure of the firmware image format, lowering the barrier for crafting a malicious image.

### 6. Qt-Specific Security

**A08-20** · MEDIUM · Qt-Specific Security
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/comm/ftpclient.cpp:103`
**Description:** `QNetworkAccessManager::get(QNetworkRequest(m_url))` is used to initiate FTP downloads. No `QSslConfiguration` is set and no TLS/SSL is configured on the `QNetworkAccessManager`. Qt's `QNetworkAccessManager` supports the `ftp://` scheme but does not perform any TLS wrapping for it, confirming the plaintext FTP finding in A08-5. There is no call to `QNetworkRequest::setSslConfiguration` or any equivalent, and no peer certificate verification logic anywhere in the FTP client.

**A08-21** · LOW · Qt-Specific Security
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/comm/ftpclient.cpp:175`
**Description:** `readData()` and `downloadFinished()` retrieve the sender `QNetworkReply` via `qobject_cast<QNetworkReply *>(sender())`. If either slot is ever invoked directly (not via a signal) or connected to a non-`QNetworkReply` sender, `qobject_cast` returns null and the subsequent `reply->header(...)` or `reply->error()` dereference will crash the device. No null check is performed on the result of `qobject_cast` in either function.

---

## Summary Table

| ID | Severity | Category | Location |
|----|----------|----------|----------|
| A08-1 | HIGH | Memory Safety | `utils/bytearray.h:25` |
| A08-2 | MEDIUM | Memory Safety | `comm/canstatehandler.cpp:44` |
| A08-3 | MEDIUM | Memory Safety | `comm/canstatehandler.cpp:67` |
| A08-4 | LOW | Memory Safety | `comm/ftpclient.cpp:179` |
| A08-5 | CRITICAL | Communication Security | `app/backgroundworker.cpp:576` |
| A08-6 | CRITICAL | Communication Security | `comm/ftpclient.cpp:83` |
| A08-7 | HIGH | Communication Security | `comm/ftpclient.cpp:70` |
| A08-8 | HIGH | Communication Security | `comm/ftpclient.cpp:15` |
| A08-9 | MEDIUM | Communication Security | `comm/ftpclient.cpp:131` |
| A08-10 | HIGH | Input Handling | `comm/ftpclient.cpp:68` |
| A08-11 | MEDIUM | Input Handling | `comm/ftpclient.cpp:144` |
| A08-12 | MEDIUM | Input Handling | `comm/ftpclient.cpp:148` |
| A08-13 | LOW | Input Handling | `comm/canstatehandler.cpp:26` |
| A08-14 | HIGH | Build Security | `mk3.pro` |
| A08-15 | MEDIUM | Build Security | `mk3.pro` |
| A08-16 | LOW | Build Security | `comm/ftpclient.cpp:157` |
| A08-17 | CRITICAL | Device and Firmware | `comm/ftpclient.cpp:83` |
| A08-18 | HIGH | Device and Firmware | `app/cigconfigs.h:64` |
| A08-19 | MEDIUM | Device and Firmware | `app/backgroundworker.cpp:151` |
| A08-20 | MEDIUM | Qt-Specific Security | `comm/ftpclient.cpp:103` |
| A08-21 | LOW | Qt-Specific Security | `comm/ftpclient.cpp:175` |
# Pass 1 — A09 Security Audit
**Repository:** mark3-pvd
**Branch:** master (confirmed)
**Date:** 2026-02-28
**Auditor:** A09
**Files reviewed:** `comm/gmtpchat.h`, `comm/gmtpchat.cpp`, `comm/modemchat.h`, `comm/modemchat.cpp`

---

## Reading Evidence

### File Pair 1: gmtpchat

**File paths:**
- `/c/Projects/cig-audit/repos/mark3-pvd/comm/gmtpchat.h`
- `/c/Projects/cig-audit/repos/mark3-pvd/comm/gmtpchat.cpp`

**Class name and base classes:**
- `GmtpChat : public QObject`

**Q_OBJECT macro location:**
- `gmtpchat.h` line 16

**Public methods (signature : line number):**
- `explicit GmtpChat(ModemChat *parent)` — h:21 / cpp:22
- `void setPowerState(CIGCONF::PowerState state)` — h:22 / cpp:70
- `void connectServer()` — h:23 / cpp:85
- `void sendMessage(const QByteArray &msgData, Priority priority = NormalPriority)` — h:24 / cpp:195
- `void sendAck(quint16 msgId)` — h:25 / cpp:225
- `void clearGMTPMsgQueue()` — h:26 / cpp:489
- `bool sleeping()` — h:27 (inline)
- `void setEthernetState(bool up)` — h:28 (inline)
- `bool acksRemaining()` — h:29 (inline)

**Signals:**
- `void cmdReceived(const QByteArray &ba)` — h:32
- `void socketStateChanged(bool state)` — h:33
- `void allMessagesSent()` — h:34
- `void allAcksSent()` — h:35
- `void gmtpHotStartReconnect()` — h:36
- `void disconnectSocket()` — h:37

**Private slots (connected in constructor):**
- `void readToQueue()` — cpp:405
- `void writeQueue(bool recent)` — cpp:434
- `void onConnected()` — cpp:144
- `void onDisconnected()` — cpp:173
- `void reconnectServer()` — cpp:112
- `void readSocket()` — cpp:323
- `void writeSocket()` — cpp:242
- `void bytesWritten(qint64 bytes)` — cpp:308
- `void ackTimeout()` — cpp:496
- `QByteArray packedMessage(const QByteArray &msgData, PduType type, quint16 ackId)` — cpp:380
- `void setOnIgnitionOffDisconnect(bool state)` — cpp:516
- `void disconnectFromHost()` — cpp:525

**#include directives (gmtpchat.cpp):**
- `#include "gmtpchat.h"` — cpp:1
- `#include "app/globalconfigs.h"` — cpp:2
- `#include "comm/modemchat.h"` — cpp:3
- `#include "platform/seriallogger.h"` — cpp:4
- `#include <QFile>` — cpp:5
- `#include <QDir>` — cpp:6
- `#include <QTimer>` — cpp:7
- `#include <QDebug>` — cpp:8
- `#include <QProcess>` — cpp:9 (included but QProcess not used in this file)
- `#include <QMutex>` — cpp:10
- `#include <unistd.h>` — cpp:13 (ARM-only)

**#include directives (gmtpchat.h):**
- `#include "app/cigconfigs.h"` — h:4
- `#include <QObject>` — h:5
- `#include <QQueue>` — h:6
- `#include <QTcpSocket>` — h:7
- `#include <QFile>` — h:8
- `#include <QMutex>` — h:9

**Protocol constants and message types:**
- `MAX_MESSAGE_CNT 1000` — cpp:16
- `MAX_RETRIES 3` — cpp:17
- `DEF_MSOCKET_TIMEOUT (10000)` — cpp:18
- `MAX_GMTP_RECONNECT_CNT (20)` — cpp:19
- `GMTP_SERVER_CNT 3` — cigconfigs.h:19
- `DIR_GMTP_MSG "/mnt/sd"` — cigconfigs.h:76
- PDU type enum: `PduId=1, PduData=2, PduIdExt=3, PduDataExt=4, PduAck=5` — h:19
- Server address and port come from `gCfg->gmtpServerAddress(m_serverIndex)` / `gCfg->gmtpServerPort(m_serverIndex)` at runtime (configurable; not hardcoded in source)

**Member variables:**
- `ModemChat *m_modemChat` — h:53
- `QTcpSocket *m_tcpSocket` — h:54
- `QTimer *m_socketTimer` — h:55
- `QTimer *m_uploadTimer` — h:56
- `QTimer *m_ackTimer` — h:57
- `CIGCONF::PowerState m_powerState` — h:58
- `int m_serverIndex` — h:60
- `QList<quint32> m_gmtpFileIndexes` — h:61
- `QQueue<QByteArray> m_uploadMessages` — h:63
- `QQueue<QByteArray> m_recentMessages` — h:64
- `QQueue<QByteArray> m_ackMessages` — h:65
- `QByteArray m_sendingMessage` — h:67
- `QByteArray m_downloadMessage` — h:68
- `quint16 m_msgId` — h:70
- `quint16 m_ackId` — h:71
- `quint8 m_retryCount` — h:72
- `quint8 m_reconnectCount` — h:73
- `bool m_idSent` — h:74
- `bool m_connect` — h:75
- `bool m_ethState` — h:76
- `bool m_onIgnitionOffDisconnect` — h:77
- `QMutex m_mutexConnectToHost` — h:78
- `QMutex m_mutexWriteSocket` — h:79
- `QMutex m_mutexDisconnectFromHost` — h:80

---

### File Pair 2: modemchat

**File paths:**
- `/c/Projects/cig-audit/repos/mark3-pvd/comm/modemchat.h`
- `/c/Projects/cig-audit/repos/mark3-pvd/comm/modemchat.cpp`

**Class name and base classes:**
- `ModemChat : public QObject`

**Q_OBJECT macro location:**
- `modemchat.h` line 20

**Public methods (signature : line number):**
- `explicit ModemChat(EM070::ModemPort *modemPort)` — h:24 / cpp:24
- `void portStateChanged(bool open)` — h:25 / cpp:59
- `void setGnssEnabled(bool enable)` — h:26 / cpp:116
- `void rssiRefresh()` — h:27 / cpp:131
- `void qmiCheck()` — h:28 / cpp:140
- `void networkCheck()` — h:29 / cpp:170
- `void updateApn()` — h:30 / cpp:316
- `void detach(bool send = true)` — h:31 / cpp:335
- `void requestDetach()` — h:32 / cpp:198
- `const QByteArray &cgmi() const` — h:34 (inline)
- `const QByteArray &cgmm() const` — h:35 (inline)
- `const QByteArray &cgmr() const` — h:36 (inline)
- `const QByteArray &cgsn() const` — h:37 (inline)
- `const QByteArray &iccid() const` — h:38 (inline)
- `const QByteArray &rssi() const` — h:39 (inline)
- `const QByteArray &mobileOperator() const` — h:40 (inline)
- `const QByteArray &moni() const` — h:41 (inline)
- `NetworkState networkState() const` — h:42 (inline)
- `bool isEthernetReady() const` — h:43 (inline)

**Signals:**
- `void simError()` — h:46
- `void ethernetStateChanged(bool ready)` — h:47

**Private slots (connected in constructor):**
- `void sendChat(bool timeout = false)` — cpp:228
- `void popChat()` — cpp:247
- `void pushChat(const QByteArray &chat)` — cpp:254
- `void noResponse()` — cpp:260
- `void parseResponse(bool result, const QByteArrayList &content)` — cpp:363
- `void selectAPN()` — cpp:270
- `void updateEthernetState(bool connected)` — cpp:217
- `void reconnectNetwork()` — cpp:819
- `void onUqmiProcessComplete(int exitCode, QProcess::ExitStatus exitStatus)` — cpp:765
- `void onProcessTimeout()` — cpp:203
- `void resetReconnectFlag()` — cpp:841
- `int args(const QByteArrayList &content, QGenericArgument val1, ...)` — cpp:696

**#include directives (modemchat.cpp):**
- `#include "modemchat.h"` — cpp:1
- `#include "platform/modemport.h"` — cpp:2
- `#include "platform/seriallogger.h"` — cpp:3
- `#include "app/globalconfigs.h"` — cpp:4
- `#include <QTimer>` — cpp:5
- `#include <QDebug>` — cpp:6
- `#include <QProcess>` — cpp:7
- `#include <QStringList>` — cpp:8

**#include directives (modemchat.h):**
- `#include <QProcess>` — h:8
- `#include <QObject>` — h:9
- `#include <QQueue>` — h:10

**Protocol constants:**
- `RETRY_WAIT 500` — cpp:10
- `RETRIES_PER_SEC (1000 / RETRY_WAIT)` — cpp:11
- `ACK_TIMEOUT 3000` — cpp:13
- `RSSI_INTERVAL 10000` — cpp:13
- `QMI_INTERVAL 2000` — cpp:14
- `NETWORK_INTERVAL 2000` — cpp:15
- `NETWORK_TIMEOUT 90` — cpp:16
- `MONOGOTO_PREFIX_SIZE (5)` — cpp:17
- `MAX_QMI_FAILURE_COUNT (7)` — cpp:18
- `PROCESS_MAX_WAIT_TIMEOUT (10000)` — cpp:19
- `MAX_CGDCONT 5` — cpp:20
- Hardcoded APN strings in `selectAPN()`: `"vfinternet.au"`, `"telstra.internet"`, `"om2moptus"`, `"vfd1.korem2m.com"`, `"stream.co.uk"`, `"hologram"`, `"data.mono"` — cpp:278-304
- Hardcoded APN credentials: `apnUser="Kore"`, `apnPassword="Kore"` (Kore M2M) — cpp:287-288; `apnUser="default"`, `apnPassword="void"` (three UK carriers) — cpp:291-303

**Member variables:**
- `EM070::ModemPort *m_modemPort` — h:74
- `QTimer *m_ackTimer` — h:75
- `QTimer *m_tryTimer` — h:76
- `QTimer *m_rssiTimer` — h:77
- `QTimer *m_qmiTimer` — h:78
- `QTimer *m_qmiStateTimer` — h:79
- `QTimer *m_networkTimer` — h:80
- `int m_networkCounter` — h:81
- `QProcess *m_qmiStateProcess` — h:82
- `QQueue<QByteArray> m_chatCmds` — h:83
- `int m_tryTimes` — h:84
- `QByteArray m_cgmi, m_cgmm, m_cgmr, m_cgsn, m_iccid, m_rssi, m_operator, m_moni` — h:86-93
- `NetworkState m_networkState` — h:94
- `bool m_gprsDetach` — h:95
- `bool m_gnssEnabled` — h:96
- `bool m_ethernetState` — h:97
- `apnData m_apn` (struct: apn, apnUser, apnPassword) — h:98
- `bool m_isPdpAuthSupported` — h:99
- `bool m_startReconnect` — h:100
- `bool m_detachRequested` — h:101
- `int m_cgdcontCount` — h:102

---

## Security Review

### 1. Memory Safety

**A09-1** · MEDIUM · Memory Safety
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/comm/gmtpchat.cpp:313`
**Description:** In `bytesWritten()`, `BE_SHORT(m_sendingMessage[2], m_sendingMessage[3])` accesses indices 2 and 3 of `m_sendingMessage` without first verifying that the buffer is at least 4 bytes long. If `m_sendingMessage` is empty or shorter than 4 bytes at the time this slot fires (a possible race condition given QueuedConnection across threads or after the `//m_sendingMessage.clear()` comment at line 315 was removed), this is an out-of-bounds read on a `QByteArray`. The same pattern occurs at `writeSocket()` line 279 (`m_sendingMessage[0]`, `m_sendingMessage[1]`) and line 292 (`m_sendingMessage[2]`, `m_sendingMessage[3]`) without a size guard.

**A09-2** · MEDIUM · Memory Safety
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/comm/gmtpchat.cpp:357`
**Description:** In `readSocket()`, when a `PduAck` is received, `BE_SHORT(m_sendingMessage[0], m_sendingMessage[1])` is accessed at line 357 without checking whether `m_sendingMessage` is non-empty. The guard at line 500 (`ackTimeout`) checks `!m_sendingMessage.isEmpty()` before access, but the `readSocket()` PduAck branch at line 357 has no such guard, creating a potential out-of-bounds read if `m_sendingMessage` was cleared between the ACK being sent and the response being parsed.

**A09-3** · LOW · Memory Safety
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/comm/gmtpchat.cpp:65`
**Description:** In the constructor, GMTP file indexes are parsed with `name.mid(7, 8).toUInt()`. If a filesystem entry in `DIR_GMTP_MSG` matches the `gmtpmsg*.txt` pattern but has a non-numeric 8-character field, `toUInt()` silently returns 0. This could lead to silent collision on index 0 and corrupt or overwrite the `gmtpmsg00000000.txt` queue file. No validation of the parsed index value is performed.

### 2. Communication Security

**A09-4** · CRITICAL · Communication Security
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/comm/gmtpchat.h:7` / `/c/Projects/cig-audit/repos/mark3-pvd/comm/gmtpchat.cpp:24`
**Description:** The GMTP connection uses a plain `QTcpSocket` (not `QSslSocket`). There is no TLS anywhere in `gmtpchat.h` or `gmtpchat.cpp`. All GMTP traffic — including the device identity PDU (`PduIdExt` containing `gCfg->gmtpId()`), proximity events, GPS position, driver IDs, and server commands — is transmitted in cleartext over the cellular network. This is a safety-critical finding: an attacker able to intercept cellular traffic can read driver identifiers, forge server commands (including `CMD_IDAUTH`, `CMD_IDDENY`, `CMD_SHTD`, `CMD_REBOOT`), and inject arbitrary command payloads that will be forwarded via the `cmdReceived` signal.

**A09-5** · HIGH · Communication Security
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/comm/gmtpchat.cpp:98` / `103-104`
**Description:** Server address and port are read from `gCfg->gmtpServerAddress(m_serverIndex)` and `gCfg->gmtpServerPort(m_serverIndex)` at runtime. While not hardcoded in these source files directly, the `GlobalConfigs` struct stores them in a config block that is provisioned over the plaintext GMTP connection itself (via `CMD_HOST`/`CMD_PORT` commands). Because the transport is unauthenticated and unencrypted (see A09-4), these can be changed to point the device to an attacker-controlled server via a man-in-the-middle injection. There is no certificate pinning or any server authentication mechanism.

**A09-6** · HIGH · Communication Security
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/comm/modemchat.cpp:287-288`
**Description:** Hardcoded APN credentials for the Kore M2M network are present in source: `apnUser = "Kore"`, `apnPassword = "Kore"`. These credentials are embedded in firmware and will appear in all deployed units using SIM cards with ICCID prefix `893144`. While APN credentials are carrier-issued and broadly known, their presence in source means they cannot be rotated per-unit or per-deployment without a firmware update.

**A09-7** · MEDIUM · Communication Security
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/comm/modemchat.cpp:291-303`
**Description:** Hardcoded APN credentials `apnUser = "default"`, `apnPassword = "void"` are used for three separate ICCID prefixes (`894450`, `894620`, `891223`) all routing through `stream.co.uk`. These credentials are embedded in firmware. Same rotation risk as A09-6.

**A09-8** · MEDIUM · Communication Security
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/comm/gmtpchat.cpp:163`
**Description:** The GMTP registration PDU sends `gCfg->gmtpId()` as the device identity in plaintext in the first message after TCP connection. This device identifier is transmitted without any challenge-response authentication or MAC. A server receiving this message has no way to verify that the connecting device is genuine. Combined with the lack of TLS (A09-4), this means a device ID can be trivially replayed or spoofed.

### 3. Input Handling

**A09-9** · HIGH · Input Handling
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/comm/gmtpchat.cpp:340`
**Description:** In `readSocket()`, `dataSize` is read from bytes 4-5 of the received TCP stream as a `quint16` (max 65535 bytes). The check at line 342 (`if (ba.size() < 6 + dataSize)`) handles partial reads correctly by buffering. However, there is no upper-bound validation on `dataSize` before buffering — a server (or attacker) can send a PDU advertising a `dataSize` of 65535 bytes, causing the device to accumulate up to 65535 + 6 bytes into `m_downloadMessage` before processing. Additionally, there is no limit on how many partial-read accumulations can occur: if a sender repeatedly sends 5-byte fragments, `m_downloadMessage` can grow indefinitely. This is a potential denial-of-service via memory exhaustion.

**A09-10** · MEDIUM · Input Handling
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/comm/gmtpchat.cpp:348`
**Description:** The `cmdReceived` signal emits `ba.mid(6, dataSize)` directly to the application layer without any content validation. The receiving code (not in scope for this file pair, but visible from the signal name `cmdReceived`) is expected to parse this as an AT-style command. If `dataSize` is 0, an empty `QByteArray` is emitted. There is no check that the payload conforms to the expected command format before emission. This passes the full responsibility for input validation to the signal consumer with no defensive filtering at the protocol boundary.

**A09-11** · MEDIUM · Input Handling
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/comm/gmtpchat.cpp:371-372`
**Description:** In `readSocket()`, the `else` branch at line 371 handles unknown PDU types by advancing the buffer by a single byte (`ba.remove(0, 1)`). This byte-by-byte scan is a performance concern on long malformed streams, but more critically it means a malformed or attacker-controlled stream can cause the socket handler to loop for the full length of the received buffer, processing one byte at a time, potentially stalling the Qt event loop for non-trivial data volumes.

**A09-12** · MEDIUM · Input Handling
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/comm/modemchat.cpp:667`
**Description:** The `+CGEV:` handler processes unsolicited modem notifications. The event string is taken directly from modem serial output (`echo.mid(7)`) and logged. The check `echo.mid(7).toUpper().contains(QByteArray("DETACH").toUpper())` is a case-insensitive substring search, which is safe for this specific path. However, the broader `parseResponse()` function at line 363 treats the entire first element of `content` as a trusted command echo without sanitising it before using it in comparisons. If the modem's serial output can be manipulated (e.g., via a rogue modem firmware or hardware attack), the logic branches in `parseResponse()` can be driven in unintended ways, including injecting AT commands via `pushChat()`.

**A09-13** · LOW · Input Handling
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/comm/modemchat.cpp:749`
**Description:** In the `args()` function, the boolean-type branch at line 749 contains a logic inversion: the condition is `if (val >= 0 || val <= 1)` but should almost certainly be `if (val >= 0 && val <= 1)`. The `||` operator makes this condition always true for any integer value (since every integer is either >= 0 or <= 1), meaning the range check is ineffective. An AT response providing a value such as `255` for a boolean field would be silently accepted and stored.

### 4. Build Security

**A09-14** · HIGH · Build Security
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/mk3.pro`
**Description:** The project file contains no compiler security hardening flags. The following flags are absent: `-fstack-protector-strong` (stack smashing protection), `-D_FORTIFY_SOURCE=2` (stdlib buffer overflow detection), `-fPIE`/`-pie` (ASLR support for the executable), and `-Wformat -Wformat-security` (format string vulnerability warnings). On an ARM embedded Linux target running safety-critical vehicle proximity detection software, the absence of all these mitigations leaves the device without standard exploit-mitigation defences.

**A09-15** · MEDIUM · Build Security
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/comm/gmtpchat.cpp:148` and multiple locations
**Description:** `qDebug()` calls are present throughout both files (e.g., `qDebug() << "GMTP Connected"` at gmtpchat.cpp:148, and multiple `qDebug()`/`qWarning()` calls in modemchat.cpp). These emit server addresses, APN credentials, uqmi command output, and network state to the debug output at runtime. If debug output is enabled in a production build (Qt does not strip `qDebug` unless `QT_NO_DEBUG_OUTPUT` is defined or `CONFIG += release` suppresses it), this information is accessible on the device's serial console. The `.pro` file does not define `QT_NO_DEBUG_OUTPUT` or `QT_NO_WARNING_OUTPUT`.

**A09-16** · MEDIUM · Build Security
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/comm/modemchat.cpp:836`
**Description:** APN credentials (`m_apn.apn`, `m_apn.apnUser`, `m_apn.apnPassword`) are logged via `qDebug()` at the `reconnectNetwork()` function: `qDebug() << "[ModemChat] Executing reconnect command with APN:" << m_apn.apn << m_apn.apnUser << m_apn.apnPassword`. If debug output is enabled on a production device, this logs credentials to the serial console in cleartext.

### 5. Device and Firmware

**A09-17** · HIGH · Device and Firmware
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/comm/modemchat.cpp:270-313`
**Description:** The `selectAPN()` function contains a hardcoded mapping of SIM ICCID prefixes to APN names and credentials. This mapping is baked into firmware and cannot be updated without a full firmware release. Adding a new carrier or rotating credentials requires a firmware build and OTA update. More critically, ICCID prefix matching (6 or 5 digits) is the sole criterion for selecting the APN and credentials — there is no fallback validation and an incorrect match (e.g., if a future SIM ICCID collides with a prefix) would silently apply the wrong APN and credentials.

**A09-18** · MEDIUM · Device and Firmware
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/comm/modemchat.cpp:160`
**Description:** The `uqmi` process is launched with a hardcoded device path `/dev/cdc-wdm0`. This path is not configurable and is embedded in the binary. On a device where this path does not exist or has been redirected, the process launch fails silently (a warning is logged but execution continues). There is no integrity check that the device at this path is the expected QMI modem interface.

**A09-19** · INFO · Device and Firmware
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/app/cigconfigs.h:76`
**Description:** GMTP message persistence uses `/mnt/sd` (the SD card) as `DIR_GMTP_MSG`. GMTP messages queued to disk (in `gmtpmsg*.txt` files) contain raw application-layer payload data. These files are plaintext and unencrypted. If the SD card is physically removed from a deployed unit, an attacker can read the pending GMTP message queue, which may include proximity events, driver IDs, GPS positions, and other operational data.

### 6. Qt-Specific Security

**A09-20** · HIGH · Qt-Specific Security
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/comm/modemchat.cpp:820-838`
**Description:** `reconnectNetwork()` constructs a `QProcess` launch of `sh -x /etc/ci/qmi_reconnect` with APN name, username, and password passed as command-line arguments (`arguments << m_apn.apn`, `<< m_apn.apnUser`, `<< m_apn.apnPassword`). The APN values ultimately derive from `gCfg->apn()`, `gCfg->apnUser()`, `gCfg->apnPassword()` when the mode is non-auto (modemchat.cpp:309-311), and these are set via the GMTP `CMD_*` command channel which is unauthenticated and unencrypted. If an attacker can inject a command over the GMTP channel to set the APN fields to values containing shell metacharacters, those characters are passed as arguments to `sh`. While `QProcess` with a `QStringList` arguments list does not invoke the shell for argument splitting (preventing shell injection via the argument list itself), the script `/etc/ci/qmi_reconnect` receives them as `$1`, `$2`, `$3` positional parameters. If that script uses these parameters in an unquoted shell expansion (which is a common scripting error), shell injection becomes possible. The `-x` flag passed to `sh` also enables verbose tracing, which will echo all expanded commands including credentials to the shell's stderr.

**A09-21** · MEDIUM · Qt-Specific Security
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/comm/modemchat.cpp:209`
**Description:** `QProcess::startDetached("killall uqmi")` is called in `onProcessTimeout()` and `onUqmiProcessComplete()` on error paths. `startDetached` with a plain string invokes the system shell. The command string is a fixed literal (`"killall uqmi"`) and is not constructed from user-controlled data, so there is no injection risk here; however, `QProcess::startDetached(const QString &command)` (the single-string overload) passes the command through the shell, which is a less safe API than the `(program, args)` overload. This is flagged as a pattern to watch.

**A09-22** · LOW · Qt-Specific Security
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/comm/gmtpchat.cpp:9`
**Description:** `#include <QProcess>` is present in `gmtpchat.cpp` but `QProcess` is not used anywhere in that file. This is dead code / unnecessary include. While not a security vulnerability in isolation, it widens the apparent attack surface and may confuse future reviewers into expecting QProcess usage.

---

## Summary Table

| ID | Severity | Category | File |
|----|----------|----------|------|
| A09-1 | MEDIUM | Memory Safety | gmtpchat.cpp:279,292,313 |
| A09-2 | MEDIUM | Memory Safety | gmtpchat.cpp:357 |
| A09-3 | LOW | Memory Safety | gmtpchat.cpp:65 |
| A09-4 | CRITICAL | Communication Security | gmtpchat.h:7 / gmtpchat.cpp:24 |
| A09-5 | HIGH | Communication Security | gmtpchat.cpp:98,103-104 |
| A09-6 | HIGH | Communication Security | modemchat.cpp:287-288 |
| A09-7 | MEDIUM | Communication Security | modemchat.cpp:291-303 |
| A09-8 | MEDIUM | Communication Security | gmtpchat.cpp:163 |
| A09-9 | HIGH | Input Handling | gmtpchat.cpp:340 |
| A09-10 | MEDIUM | Input Handling | gmtpchat.cpp:348 |
| A09-11 | MEDIUM | Input Handling | gmtpchat.cpp:371-372 |
| A09-12 | MEDIUM | Input Handling | modemchat.cpp:667 |
| A09-13 | LOW | Input Handling | modemchat.cpp:749 |
| A09-14 | HIGH | Build Security | mk3.pro |
| A09-15 | MEDIUM | Build Security | gmtpchat.cpp:148 / modemchat.cpp (multiple) |
| A09-16 | MEDIUM | Build Security | modemchat.cpp:836 |
| A09-17 | HIGH | Device and Firmware | modemchat.cpp:270-313 |
| A09-18 | MEDIUM | Device and Firmware | modemchat.cpp:160 |
| A09-19 | INFO | Device and Firmware | cigconfigs.h:76 |
| A09-20 | HIGH | Qt-Specific Security | modemchat.cpp:820-838 |
| A09-21 | MEDIUM | Qt-Specific Security | modemchat.cpp:209 |
| A09-22 | LOW | Qt-Specific Security | gmtpchat.cpp:9 |
# Pass 1 Audit — A10
**Auditor:** A10
**Date:** 2026-02-28
**Branch:** master
**Repo:** /c/Projects/cig-audit/repos/mark3-pvd

---

## STEP 4 — READING EVIDENCE

---

### File: `/c/Projects/cig-audit/repos/mark3-pvd/comm/ntpsync.h`

**Class:** `NtpSync` extends `QObject`

**Q_OBJECT macro:** Line 12

**Public methods:**
- `explicit NtpSync(ModemChat *parent)` — line 14
- `void connectServer()` — line 15
- `void abortConnection()` — line 16

**Signals:**
- `void synchronized(bool yes)` — line 19

**Slots (private, connected via lambda/connect):**
- `void writeSocket()` — line 22 (private)
- `void readSocket()` — line 23 (private)

**Member variables:**
- `ModemChat *m_modemChat` — line 25
- `QUdpSocket *m_udpSocket` — line 26
- `QTimer *m_timer` — line 27
- `int m_syncTimes` — line 29

**#include directives:**
- `<QObject>` — line 4
- `<QUdpSocket>` — line 5

**NTP server addresses defined:** None hardcoded in this file. Server address retrieved at runtime from `gCfg->timeServerAddress()`.

---

### File: `/c/Projects/cig-audit/repos/mark3-pvd/comm/ntpsync.cpp`

**Class:** `NtpSync` (implementation)

**#include directives:**
- `"ntpsync.h"` — line 1
- `"platform/internalrtc.h"` — line 2
- `"platform/seriallogger.h"` — line 3
- `"comm/modemchat.h"` — line 4
- `"app/globalconfigs.h"` — line 5
- `<QTimer>` — line 6
- `<QDateTime>` — line 7

**Macros defined:**
- `#define EPOCH_DIFF  0x83aa7e80UL` — line 9 (NTP epoch offset: seconds from 1900 to Unix epoch 1970)

**NTP server addresses defined:** No hardcoded NTP server address in this file. Address sourced from `gCfg->timeServerAddress()` at lines 47, 50, 62.

**Key operations in `readSocket()` (lines 70–106):**
- Reads UDP datagram with `m_udpSocket->readAll()` — line 74
- Validates minimum size of 48 bytes — line 75
- Extracts `ts1` (Reference Timestamp) at bytes 32–35 and `ts2` (Transmit Timestamp) at bytes 40–43 using `BE_INT` macro — lines 78–79
- Checks that `ts2 - ts1 > 300` and returns early if so — line 81
- Subtracts `EPOCH_DIFF` from `ts2` — line 84
- Validates resulting `QDateTime` is valid and year >= 2019 — lines 87–88
- Calls `EM070::InternalRtc::setRtcTime(dt)` directly — line 99
- Sets last time server update and time error in global config — lines 101–102
- Emits `synchronized(true)` — line 103

---

### File: `/c/Projects/cig-audit/repos/mark3-pvd/main.cpp`

**Class:** None (free functions + `main`)

**#include directives:**
- `<QApplication>` — line 1
- `<QDateTime>` — line 2
- `<QThread>` — line 3
- `<QFile>` — line 4
- `<QDebug>` — line 5
- `<QTranslator>` — line 6
- `<QProcess>` — line 7
- `"utils/logger.h"` — line 8
- `"ui/keyfilter.h"` — line 9
- `"ui/dialog.h"` — line 10
- `"app/backgroundworker.h"` — line 11
- `"mytranslator.h"` — line 12
- `<sys/mman.h>` — line 13

**Free functions:**
- `void hideBootProgress()` — line 24
- `void configureCrashLogging()` — line 38
- `int main(int argc, char *argv[])` — line 71

**Conditional compilation / debug macros:**
- `#define CONSTRAINED_MEMORY_TEST` — commented out, line 17
- `#ifdef __arm__` guards around DPI and boot progress — lines 73, 26

**Command-line arguments processed:**
- `argc` and `argv` are passed directly to `QApplication a(argc, argv)` — line 78. No application-specific command-line argument parsing is performed beyond Qt's own handling.

**QProcess calls (hardcoded shell commands):**
- `QProcess::startDetached("/mnt/sd/app_monitor")` — line 68 (inside commented-out `configureCrashLogging()`)
- `QProcess::execute("/bin/sh", QStringList() << "-c" << "echo 37 > /sys/class/gpio/export")` — line 109
- `QProcess::execute("/bin/sh", QStringList() << "-c" << "echo \"high\" > /sys/class/gpio/gpio37/direction")` — line 110
- `QProcess::execute("/bin/sh", QStringList() << "-c" << "echo 0 > /sys/class/gpio/gpio37/value")` — line 111
- `QProcess::execute("/bin/sh", QStringList() << "-c" << "echo 39 > /sys/class/gpio/export")` — line 114
- `QProcess::execute("/bin/sh", QStringList() << "-c" << "echo \"high\" > /sys/class/gpio/gpio39/direction")` — line 115

**Shell script written to filesystem by `configureCrashLogging()`:** Lines 46–62 (currently commented out at line 101).

**Member variables:** None (no class).

---

### File: `/c/Projects/cig-audit/repos/mark3-pvd/mytranslator.h`

**Class:** None (free functions + extern)

**#include directives:**
- `<QtGlobal>` — line 4

**Public functions declared:**
- `void loadLocalLanguage(void)` — line 15
- `void updateLocalLanguage(const QString &arg1)` — line 16
- `QString getCurrentLanguage(void)` — line 17
- `int queryLanguage(void)` — line 18
- `int setLanguage(int local)` — line 19
- `void removeTranslator()` — line 20

**Global extern:** `extern QTranslator mTranslator` — line 14

**Constants:**
- `const QString langEnglish = "EN"` — line 11
- `const QString langSpanish = "ES"` — line 12

**Q_OBJECT macro:** Not present.

---

### File: `/c/Projects/cig-audit/repos/mark3-pvd/mytranslator.cpp`

**Class:** None (free function implementations)

**#include directives:**
- `<QApplication>` — line 1
- `<QFile>` — line 2
- `<QDebug>` — line 3
- `<QTranslator>` — line 4
- `"mytranslator.h"` — line 5

**Constants:**
- `const QString localFile = "local.dat"` — line 7 (relative path, no directory prefix)
- `const QString langFile = ":/lang.dat"` — line 8 (Qt resource path)

**Key operations:**
- `loadLocalLanguage()`: Opens `local.dat` (relative path) to read language code, opens embedded `:/lang.dat` resource to find corresponding translation filename, calls `mTranslator.load(filename)` where `filename` comes from the resource file — lines 15–68.
- `updateLocalLanguage()`: Same resource lookup pattern, writes the selected language code to `local.dat` — lines 74–126.
- `getCurrentLanguage()`: Same lookup, returns matched language code string — lines 132–165.
- `queryLanguage()` / `setLanguage()`: Thin wrappers around `getCurrentLanguage()` / `updateLocalLanguage()` — lines 167–188.
- `removeTranslator()`: Removes installed translator — lines 190–198.

---

## STEP 5 — SECURITY REVIEW

---

### 1. Memory Safety

**A10-1** · MEDIUM · Memory Safety
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/utils/bytearray.h:25`
**Description:** `ByteArray::asprintf()` calls `vsnprintf(nullptr, 0, ...)` to determine the required size, then calls `vsprintf(ba.data(), cformat, ap)` using a second `va_list` invocation on a `va_list` that has already been consumed by the first call. After `vsnprintf` exhausts `ap`, the second `va_start` is never called before `vsprintf`. This is undefined behaviour: the second variadic call reads from a stack frame that may have been corrupted or advanced past the arguments. The result is a potential heap buffer overflow or write of garbage data. The comment in the code itself flags this function as "not recommended". This file is referenced by `ntpsync.cpp` transitively through `bytearray.h`.

**A10-2** · MEDIUM · Memory Safety
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/utils/bytearray.h:7`
**Description:** The `BE_INT` macro does not cast `c1` (the most-significant byte) to `(uchar)` before the left shift of 24 bits. The other three arguments are explicitly cast: `(uchar)(c2) << 16`, `(uchar)(c3) << 8`, `(uchar)(c4)`. When `c1` is a signed `char` (as would be the case when indexing into a `QByteArray` whose `operator[]` returns `char`), a value with the high bit set (e.g., `0x80`–`0xFF`) is sign-extended to a negative `int` before the 24-bit left shift. Shifting a negative value left is undefined behaviour in C++ prior to C++20. In practice on ARM this produces an incorrect `quint32` result, silently corrupting the NTP transmit-timestamp extraction at `ntpsync.cpp:78–79` and potentially causing the device to set its RTC to a wrong time.

**A10-3** · LOW · Memory Safety
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/app/globalconfigs.h:422`
**Description:** `setTimeServerAddress()` checks `addr.size() < SERVER_ADDR_LEN` (33) before calling `qstrcpy(m_configs.timeServerAddress, addr.constData())`. The check uses `<` (strictly less than) rather than `<=`, so it permits a `QByteArray` of length 32 with no null terminator to be passed. `qstrcpy` copies until the null terminator in `addr.constData()`, which Qt guarantees to append, so the copy itself is safe. However, the intent appears to be to allow up to 32 character hostnames; the off-by-one in the guard is a latent confusion risk and could become a one-byte overflow if the pattern is copied elsewhere without the Qt null-terminator guarantee.

---

### 2. Communication Security

**A10-4** · HIGH · Communication Security
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/comm/ntpsync.cpp:50`
**Description:** NTP time synchronisation is performed over unauthenticated UDP (port 123, SNTPv3). There is no use of NTS (Network Time Security, RFC 8915) or any message authentication code. An on-path attacker or a local network attacker capable of spoofing UDP packets can respond to the NTP request with an arbitrary timestamp. Because the synchronised time is applied directly to the device RTC (`InternalRtc::setRtcTime`) and propagated to safety-critical timestamps (proximity event logs, on-demand command timestamps, maintenance records via `gCfg->setLastTimeServerUpdate`), a time-injection attack can corrupt audit trails, replay expired credentials, or cause safety-critical time-window logic to behave incorrectly. The protocol provides no confidentiality or integrity protection by design.

**A10-5** · INFO · Communication Security
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/comm/ntpsync.cpp:47,50,62`
**Description:** The NTP server address is not hardcoded in source; it is read at runtime from `gCfg->timeServerAddress()` which is ultimately stored in a config struct (`m_configs.timeServerAddress`, a 33-byte char array). This is the correct pattern. However, the default value of this field (what is stored when no configuration has been provided) is not visible in the files assigned to this auditor and should be reviewed by the auditor assigned to the config initialisation code to confirm no default NTP server address is hardcoded there.

---

### 3. Input Handling

**A10-6** · MEDIUM · Input Handling
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/comm/ntpsync.cpp:81`
**Description:** The NTP response validation check at line 81 is logically inverted relative to its stated purpose. The comment at line 32 notes the NTP timestamp fields (`ts1` = Reference Timestamp, `ts2` = Transmit Timestamp). The check `if (ts2 - ts1 > 300) return;` is intended to reject responses where the server's internal processing delay exceeds 300 seconds, discarding implausible responses. However, `ts1` and `ts2` are `quint32` (unsigned 32-bit). If `ts2 < ts1` (which can legitimately occur if the server's reference time is ahead of its transmit time due to clock steps), the subtraction wraps around to a very large positive value and the response is incorrectly discarded. More critically, the check discards responses with large inter-timestamp gaps but does not validate that `ts2` itself falls within any reasonable range relative to the device's current clock before subtracting `EPOCH_DIFF` and applying it to the RTC. A spoofed response with a valid-looking 300-second window but a completely wrong base time will pass validation.

**A10-7** · MEDIUM · Input Handling
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/comm/ntpsync.cpp:84,86,87`
**Description:** After subtracting `EPOCH_DIFF` from `ts2` (converting NTP epoch to Unix epoch), the code constructs a `QDateTime` and only checks `dt.isValid()` and `dt.date().year() < 2019`. This year-floor check provides minimal protection against time injection. A spoofed NTP response can set the device clock to any year from 2019 to 2106 (the limit of `quint32` Unix time). There is no upper-bound check, no check against the device's current clock to limit the magnitude of a step adjustment, and no plausibility check against GPS-derived time if available. The NTP-synchronised time is applied unconditionally to the RTC and to safety-critical timestamps.

**A10-8** · LOW · Input Handling
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/mytranslator.cpp:35`
**Description:** `loadLocalLanguage()` reads a language code from `local.dat` using `in.readLine()` with no length limit on the line. `QTextStream::readLine()` by default reads an unbounded line. While Qt stores this in a `QString` (heap-managed, no stack overflow risk), an extremely large `local.dat` file will cause the entire first line to be read into memory, then compared against language entries in the resource file. This is a minor denial-of-service risk if the file is writable by an attacker; the device could be caused to allocate excessive memory during startup.

**A10-9** · LOW · Input Handling
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/mytranslator.cpp:35,37`
**Description:** `loadLocalLanguage()` reads the translation filename from the embedded Qt resource file `:/lang.dat` (line 35: `filename = list[1]`) and passes it directly to `mTranslator.load(filename)` (line 37/94). The resource file `:/lang.dat` is compiled into the binary and is not attacker-controlled in normal deployment. However, if the resource file's format is ever changed to include an absolute path or if the build process were compromised to inject a malicious `lang.dat`, the `QTranslator::load()` call would follow that path. This is a build-supply-chain concern rather than a runtime vulnerability, and is rated LOW because the resource is embedded.

---

### 4. Build Security

Build Security: no issues found in the files assigned to this auditor. The `.pro` file was not assigned; compiler hardening flags cannot be assessed from these files alone.

---

### 5. Device and Firmware

**A10-10** · MEDIUM · Device and Firmware
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/main.cpp:38–68`
**Description:** `configureCrashLogging()` writes a shell script to `/mnt/sd/app_monitor` and then executes it with `QProcess::startDetached("/mnt/sd/app_monitor")`. The script is written to the SD card filesystem, which may be writable by other processes or even accessible via the physical card. If an attacker replaces `/mnt/sd/app_monitor` between the write and the `startDetached` call (TOCTOU), or if the SD card is removed and tampered with, arbitrary code will be executed as the application user on next crash detection. This function is currently called only when uncommented (line 101 is commented out), but the code path is present in the source and could be re-enabled.

**A10-11** · LOW · Device and Firmware
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/main.cpp:99`
**Description:** `qsrand(QDateTime::currentSecsSinceEpoch())` seeds Qt's legacy random number generator with the current Unix timestamp. This is a predictable seed: an attacker who knows the approximate boot time (e.g., from observing device power-on or NTP log entries) can predict the sequence generated by subsequent `qrand()` calls. If `qrand()` is used anywhere in security-sensitive contexts (session token generation, nonce generation), this is a HIGH finding. The seed predictability should be assessed in conjunction with the files that consume `qrand()`.

**A10-12** · LOW · Device and Firmware
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/comm/ntpsync.cpp:99`
**Description:** `EM070::InternalRtc::setRtcTime(dt)` is called unconditionally once the NTP response passes the minimal validation checks described in A10-6 and A10-7. There is no rate limiting, no step-change threshold, and no confirmation from a second source before writing to the hardware RTC. This means a single valid-looking spoofed UDP packet is sufficient to alter the device's hardware clock, which is used for safety-critical proximity event timestamping.

---

### 6. Qt-Specific Security

**A10-13** · LOW · Qt-Specific Security
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/main.cpp:109–115`
**Description:** Five `QProcess::execute()` calls use `/bin/sh -c` with shell-interpolated strings to export and configure GPIO pins. The strings are fully hardcoded literals with no user-supplied or network-supplied content, so there is no injection risk from these specific calls. However, the pattern of using `QProcess::execute("/bin/sh", QStringList() << "-c" << <string>)` is inherently fragile: if any future developer substitutes a variable into the shell string, it immediately becomes a command injection vulnerability. Direct file I/O to the sysfs paths (e.g., `QFile::write`) would be safer and avoid spawning a shell.

**A10-14** · INFO · Qt-Specific Security
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/comm/ntpsync.h:26`
**Description:** `m_udpSocket` is a `QUdpSocket*` allocated with `new QUdpSocket(this)` in the constructor; Qt parent-child ownership ensures it will be deleted when the `NtpSync` object is destroyed. This is the standard Qt RAII pattern and there is no leak. Noted for completeness.

---

## Summary Table

| ID     | Severity | Category                | File                                      |
|--------|----------|-------------------------|-------------------------------------------|
| A10-1  | MEDIUM   | Memory Safety           | utils/bytearray.h:25                      |
| A10-2  | MEDIUM   | Memory Safety           | utils/bytearray.h:7                       |
| A10-3  | LOW      | Memory Safety           | app/globalconfigs.h:422                   |
| A10-4  | HIGH     | Communication Security  | comm/ntpsync.cpp:50                       |
| A10-5  | INFO     | Communication Security  | comm/ntpsync.cpp:47,50,62                 |
| A10-6  | MEDIUM   | Input Handling          | comm/ntpsync.cpp:81                       |
| A10-7  | MEDIUM   | Input Handling          | comm/ntpsync.cpp:84,86,87                 |
| A10-8  | LOW      | Input Handling          | mytranslator.cpp:35                       |
| A10-9  | LOW      | Input Handling          | mytranslator.cpp:35,37                    |
| A10-10 | MEDIUM   | Device and Firmware     | main.cpp:38–68                            |
| A10-11 | LOW      | Device and Firmware     | main.cpp:99                               |
| A10-12 | LOW      | Device and Firmware     | comm/ntpsync.cpp:99                       |
| A10-13 | LOW      | Qt-Specific Security    | main.cpp:109–115                          |
| A10-14 | INFO     | Qt-Specific Security    | comm/ntpsync.h:26                         |
# Pass 1 Audit — A11
**Auditor:** A11
**Date:** 2026-02-28
**Branch:** master
**Repo:** /c/Projects/cig-audit/repos/mark3-pvd

---

## Step 4 — Reading Evidence

### File Pair 1: aescrypto

**File paths:**
- `/c/Projects/cig-audit/repos/mark3-pvd/platform/aescrypto.h`
- `/c/Projects/cig-audit/repos/mark3-pvd/platform/aescrypto.cpp`

**Class name and base classes:**
- `AesCrypto` (no base class; plain C++ class, not a QObject)
- Namespace: `EM070`

**Public methods (with signature and line number):**
- `static QByteArray encrypt(const QByteArray &in)` — aescrypto.h:16, aescrypto.cpp:150
- `static QByteArray descrypt(const QByteArray &in)` — aescrypto.h:17, aescrypto.cpp:156

**Private methods:**
- `bool enableMtp()` — aescrypto.h:20, aescrypto.cpp:20
- `QByteArray aes(const QByteArray &in, bool encrypt)` — aescrypto.h:21, aescrypto.cpp:63

**Signals:** none
**Slots:** none
**Q_OBJECT macro:** not present

**#include directives (aescrypto.cpp):**
- `#include "aescrypto.h"` — line 1
- `#include <unistd.h>` — line 3 (ARM only, inside `#ifdef __arm__`)
- `#include <linux/if_alg.h>` — line 4 (ARM only)
- `#include <sys/socket.h>` — line 5 (ARM only)
- `#include <QDebug>` — line 7

**#include directives (aescrypto.h):**
- `#include <QByteArray>` — line 4

**Cryptographic constants:**
- Cipher algorithm: `"cbc(aes)"` — aescrypto.cpp:79
- IV size: 16 bytes (set via `iv->ivlen = 16`) — aescrypto.cpp:123
- Hardcoded IV value: `\x3d\xaf\xba\x42\x9d\x9e\xb4\x30\xb4\x22\xda\x80\x2c\x9f\xac\x41` — aescrypto.cpp:124
- Key source: hardware MTP (Manufacturing Test Protection) key via `ALG_USE_MTP_KEY` socket option — aescrypto.cpp:86
- Key size: determined by hardware MTP; not set in source
- Block cipher mode: CBC

**Member variables:**
- `static bool m_mtpEnabled` — aescrypto.h:22, aescrypto.cpp:18

---

### File Pair 2: blecentral

**File paths:**
- `/c/Projects/cig-audit/repos/mark3-pvd/platform/blecentral.h`
- `/c/Projects/cig-audit/repos/mark3-pvd/platform/blecentral.cpp`

**Classes and base classes:**
- `CharacteristicInfo : public QObject` — blecentral.h:13
- `DescriptorInfo : public QObject` — blecentral.h:31
- `BleCentral : public QObject` — blecentral.h:45
- Namespace: `EM070`

**Q_OBJECT macro locations:**
- `CharacteristicInfo` — blecentral.h:15
- `DescriptorInfo` — blecentral.h:32
- `BleCentral` — blecentral.h:47

**Public methods of BleCentral (with signature and line number):**
- `explicit BleCentral(QObject *parent = nullptr)` — blecentral.h:51, blecentral.cpp:14
- `~BleCentral()` — blecentral.h:52, blecentral.cpp:42
- `void setEnabled(bool enable)` — blecentral.h:54, blecentral.cpp:74
- `void setPeripheralAddress(const quint64 &address)` — blecentral.h:56, blecentral.cpp:54
- `void setAuthorizationCode(const quint128 &uuid, const QByteArray &code)` — blecentral.h:57, blecentral.cpp:68
- `State state() const` — blecentral.h:59
- `QByteArrayList servicesUuid() const` — blecentral.h:61, blecentral.cpp:303
- `QByteArrayList characteristicsUuid() const` — blecentral.h:62, blecentral.cpp:312
- `QByteArrayList descriptionsUuid() const` — blecentral.h:63, blecentral.cpp:321
- `bool readCharacteristic(const quint128 &uuid)` — blecentral.h:65, blecentral.cpp:350
- `bool writeCharacteristic(const quint128 &uuid, const QByteArray &ba)` — blecentral.h:66, blecentral.cpp:364
- `bool readDescriptor(const quint128 &uuid)` — blecentral.h:67, blecentral.cpp:378
- `bool writeDescriptor(const quint128 &uuid, const QByteArray &ba)` — blecentral.h:68, blecentral.cpp:396

**Signals of BleCentral:**
- `void accessible(bool yes)` — blecentral.h:71
- `void error(QBluetoothDeviceDiscoveryAgent::Error newError)` — blecentral.h:74
- `void error(QLowEnergyController::Error newError)` — blecentral.h:77
- `void error(QLowEnergyService::ServiceError newError)` — blecentral.h:80
- `void characteristicChanged(const quint128 &uuid, const QByteArray &newValue)` — blecentral.h:81
- `void characteristicRead(const quint128 &uuid, const QByteArray &value)` — blecentral.h:82
- `void characteristicWritten(const quint128 &uuid, const QByteArray &newValue)` — blecentral.h:83
- `void descriptorRead(const quint128 &uuid, const QByteArray &value)` — blecentral.h:84
- `void descriptorWritten(const quint128 &uuid, const QByteArray &newValue)` — blecentral.h:85

**Private slots/methods of BleCentral:**
- `const DescriptorInfo *descriptionInfo(const quint128 &uuid)` — blecentral.h:88, blecentral.cpp:330
- `const CharacteristicInfo *characteristicInfo(const quint128 &uuid)` — blecentral.h:89, blecentral.cpp:340
- `void startDeviceDiscovery()` — blecentral.h:91, blecentral.cpp:101
- `void connectToDevice()` — blecentral.h:92, blecentral.cpp:143
- `void addDevice(const QBluetoothDeviceInfo &)` — blecentral.h:95, blecentral.cpp:110
- `void deviceDiscoveryFinished()` — blecentral.h:96, blecentral.cpp:125
- `void deviceDiscoveryError(QBluetoothDeviceDiscoveryAgent::Error)` — blecentral.h:97, blecentral.cpp:136
- `void deviceConnected()` — blecentral.h:100, blecentral.cpp:181
- `void deviceDisconnected()` — blecentral.h:101, blecentral.cpp:196
- `void addService(const QBluetoothUuid &newService)` — blecentral.h:102, blecentral.cpp:205
- `void serviceDiscoveryFinished()` — blecentral.h:103, blecentral.cpp:246
- `void serviceStateChanged(QLowEnergyService::ServiceState newState)` — blecentral.h:106, blecentral.cpp:257

**#include directives (blecentral.cpp):**
- `#include "blecentral.h"` — line 1
- `#include "seriallogger.h"` — line 2
- `#include <QTimer>` — line 3
- `#include <QDebug>` — line 4
- `#include <QLowEnergyConnectionParameters>` — line 5

**#include directives (blecentral.h):**
- `#include <QObject>` — line 4
- `#include <QBluetoothDeviceDiscoveryAgent>` — line 5
- `#include <QBluetoothDeviceInfo>` — line 6
- `#include <QLowEnergyController>` — line 7

**Member variables of BleCentral:**
- `QTimer *m_discoveryTimer` — blecentral.h:108
- `QTimer *m_reconnectTimer` — blecentral.h:109
- `QBluetoothDeviceInfo m_device` — blecentral.h:111
- `QBluetoothDeviceDiscoveryAgent *m_discoveryAgent` — blecentral.h:112
- `QLowEnergyController *m_controller` — blecentral.h:113
- `QList<QLowEnergyService *> m_services` — blecentral.h:115
- `QList<CharacteristicInfo *> m_charInfos` — blecentral.h:116
- `QList<DescriptorInfo *> m_descInfos` — blecentral.h:117
- `QBluetoothAddress m_previousAddress` — blecentral.h:119
- `QBluetoothAddress m_peripheralAddress` — blecentral.h:120
- `QBluetoothUuid m_authUuid` — blecentral.h:121
- `QByteArray m_authCode` — blecentral.h:122
- `State m_state` — blecentral.h:124
- `int m_serviceIndex` — blecentral.h:125

---

## Step 5 — Security Review

---

**A11-1** · CRITICAL · Communication Security
**File:** `platform/aescrypto.cpp:124`
**Description:** A hardcoded, static IV (`\x3d\xaf\xba\x42\x9d\x9e\xb4\x30\xb4\x22\xda\x80\x2c\x9f\xac\x41`) is embedded as a string literal in source. The same 16-byte value is passed to every single encrypt and decrypt operation via `memcpy(iv->iv, ...)`. In CBC mode, reusing an identical IV for all encryptions eliminates the semantic security of the cipher: two plaintexts that share a common prefix will produce identical ciphertext prefixes, making traffic analysis and pattern recognition trivially possible. An attacker who can observe multiple ciphertext blocks encrypted with the same key and IV can also mount chosen-plaintext attacks. A unique, cryptographically random IV must be generated per operation (e.g., via `/dev/urandom` or the kernel's `getrandom()` syscall) and transmitted alongside the ciphertext.

---

**A11-2** · HIGH · Memory Safety
**File:** `platform/aescrypto.cpp:32`
**Description:** `::strcpy((char *) sa.salg_type, "skcipher")` is called unconditionally on the `salg_type` field of a `struct sockaddr_alg`. The field `salg_type` is declared in `<linux/if_alg.h>` as `__u8 salg_type[14]`. The string `"skcipher"` is 8 characters plus a null terminator (9 bytes), which fits within 14 bytes in this instance — however the same pattern is repeated for `salg_name` at line 33 with the value `"mtp"` and again at line 78 with `"cbc(aes)"`. While the current string literals fit, the use of `strcpy` into fixed-size kernel struct fields is inherently unsafe: any future change to the algorithm name string without updating a paired length check would overflow the destination buffer without warning. No bounds checking exists. The bounded alternative `strncpy` with the exact field size should be used for all such copies.

---

**A11-3** · HIGH · Memory Safety
**File:** `platform/aescrypto.cpp:78`
**Description:** `::strcpy((char *) sa.salg_name, "cbc(aes)")` writes into `sockaddr_alg.salg_name`, which is declared as `__u8 salg_name[64]` in `<linux/if_alg.h>`. The current literal fits, but the function also copies into `salg_type` (14-byte field) at line 77 using the same unchecked `strcpy` pattern. Combining with the same issue in `enableMtp()`, there are four total `strcpy` calls into kernel struct fields across the two functions (lines 32, 33, 77, 78), all without bounds checking. These should all be replaced with `strncpy` specifying the exact field sizes.

---

**A11-4** · HIGH · Memory Safety
**File:** `platform/aescrypto.cpp:131-141`
**Description:** The return values of `sendmsg(tfd, &msg, MSG_MORE)` and `read(tfd, ba.data() + i, 1024)` are never checked within the processing loop (lines 134–135) or in the tail read (lines 140–141). If `sendmsg` returns an error (e.g., due to a kernel-side failure or partial send) or `read` returns fewer bytes than requested, the code continues silently and writes into the output buffer `ba` at the current offset as though a full 1024 bytes were returned. This results in a partially zeroed or stale output buffer being returned to callers as if it were valid ciphertext or plaintext, corrupting the result without any error indication to higher layers.

---

**A11-5** · MEDIUM · Memory Safety
**File:** `platform/aescrypto.cpp:99`
**Description:** The control message buffer `cbuf` is declared as `char cbuf[CMSG_SPACE(4) + CMSG_SPACE(20)]`. The second CMSG entry sets `cmsg->cmsg_len = CMSG_LEN(20)` at line 121, where the 20-byte data region holds a 4-byte `ivlen` field plus 16 bytes of IV data. The `CMSG_SPACE(20)` allocation provides space for the ancillary data header plus 20 bytes of payload, which matches correctly. However, the `af_alg_iv` struct layout is `{ __u32 ivlen; __u8 iv[0]; }` — the actual IV data begins at `iv->iv` which is at offset 4 within the CMSG payload. The total CMSG payload consumed is 4 (ivlen) + 16 (iv data) = 20 bytes, which exactly fills the allocated space with no margin. If the kernel's `CMSG_SPACE` macro pads differently than expected, or if `ivlen` is set to a value larger than 16 in a future change without adjusting the buffer allocation, a stack buffer overflow occurs in the control message region.

---

**A11-6** · MEDIUM · Communication Security
**File:** `platform/aescrypto.cpp:63-148`
**Description:** The `aes()` function is conditionally compiled: the entire implementation, including all socket setup, key configuration, and encrypt/decrypt logic, is wrapped in `#ifdef __arm__`. On non-ARM platforms (e.g., x86 development machines, CI build environments, or any non-ARM target that might be used for testing), the function returns an empty `QByteArray` unconditionally. This means that any code path relying on encryption or decryption silently receives empty output on non-ARM builds with no error signal. If test environments or development machines do not use ARM, encryption is silently bypassed and data that should be protected is transmitted or stored in plaintext. There is no fallback software AES implementation or error indication on these platforms.

---

**A11-7** · MEDIUM · Communication Security
**File:** `platform/blecentral.cpp:165`
**Description:** `QLowEnergyController::createCentral(m_device)` is called with no security mode configured on the resulting controller. The Qt BLE API defaults to `QLowEnergyController::UnconnectedState` and uses unauthenticated, unencrypted connections at the BLE link layer unless a security mode is explicitly requested (e.g., `QBluetoothSocket::ManPageSecurity` or through pairing). The codebase then proceeds to write an authorization code to a specific characteristic (blecentral.cpp:275: `service->writeCharacteristic(characteristic, m_authCode)`) over this unauthenticated BLE link. Without BLE link-layer encryption and authentication (pairing/bonding), the authorization code is transmitted in plaintext over the radio and is trivially interceptable by any nearby BLE sniffer.

---

**A11-8** · MEDIUM · Communication Security
**File:** `platform/blecentral.cpp:68-72`
**Description:** The authorization code (`m_authCode`) is stored as a plain `QByteArray` member variable for the lifetime of the `BleCentral` object. It is set via `setAuthorizationCode()` and retained indefinitely. If the `BleCentral` object persists between connections (e.g., across reconnect cycles), the authorization credential remains in heap memory for the entire session. There is no zeroing or explicit clearing of `m_authCode` after use in `serviceStateChanged()` or in the destructor. On an embedded Linux device with physical access, a memory dump could recover the authorization code.

---

**A11-9** · LOW · Qt-Specific Security
**File:** `platform/blecentral.cpp:274-275`
**Description:** When a characteristic's UUID matches `m_authUuid`, the code immediately writes `m_authCode` to that characteristic without any additional validation of service context, connection security state, or confirmation that the peripheral is the expected trusted device. The target device is selected solely by BLE MAC address match (blecentral.cpp:117: `info.address() == m_peripheralAddress`). A rogue BLE device that spoofs the expected MAC address and advertises the expected service UUID with the authorization characteristic would receive the authorization code. BLE MAC address matching does not constitute authentication of the peripheral.

---

**A11-10** · LOW · Build Security
**File:** `platform/aescrypto.cpp:50`
**Description:** `qDebug() << "AesCrypto: MTP Status Error: " << status;` logs the raw MTP hardware status register value to debug output. If `qDebug` output is active in production builds (which is the default unless `QT_NO_DEBUG_OUTPUT` is defined at build time or the message handler is suppressed), this leaks internal hardware state information. The status bits include flags that describe the state of the hardware cryptographic module. While not a direct key disclosure, this information assists an attacker in profiling the hardware environment. This should be verified against the production build configuration.

---

**A11-11** · INFO · Memory Safety
**File:** `platform/blecentral.cpp:42-52`
**Description:** The destructor explicitly calls `delete m_discoveryAgent` and `delete m_controller` (raw pointers) followed by `qDeleteAll()` on the three lists, then manually calls `.clear()` on each list. This is correct and consistent cleanup. It is noted as a pattern, not a defect: the class uses raw Qt parent-child ownership for some objects and manual deletion for others, which is a potential maintenance risk if the ownership model changes. No use-after-free was found in the current code.

---

1. Memory Safety: findings A11-2, A11-3, A11-4, A11-5 above.
2. Communication Security: findings A11-1, A11-6, A11-7, A11-8 above.
3. Input Handling: no issues found.
4. Build Security: finding A11-10 above.
5. Device and Firmware: no issues found.
6. Qt-Specific Security: finding A11-9 above.
# Pass 1 Security Audit — A12
**Auditor:** A12
**Date:** 2026-02-28
**Branch:** master (confirmed)
**Files reviewed:**
- `platform/canbus.h`
- `platform/canbus.cpp`
- `platform/gnssreceiver.h`
- `platform/gnssreceiver.cpp`

---

## STEP 4 — READING EVIDENCE

### canbus.h / canbus.cpp

**File paths:**
- `/c/Projects/cig-audit/repos/mark3-pvd/platform/canbus.h`
- `/c/Projects/cig-audit/repos/mark3-pvd/platform/canbus.cpp`

**Class name and base classes:**
- `EM070::CanBus` : public `QObject`

**Q_OBJECT macro location:**
- `canbus.h` line 14

**Every public method with signature and line number (canbus.h):**
- Line 25: `explicit CanBus(CanDeviceId id = CAN1, QObject *parent = nullptr)`
- Line 26: `~CanBus()`
- Line 28: `void initialize()`
- Line 30: `void setXferEnabled(bool enable)`
- Line 31: `bool isXferEnabled() const`
- Line 33: `void setPower(bool on)`
- Line 34: `bool isEnabled() const`
- Line 36: `bool setBaudRate(int baudRate)`
- Line 37: `int baudRate() const`
- Line 39: `void addRequest(quint32 id, const QByteArray &ba, quint32 interval)`
- Line 40: `QList<Request> getRequests()`
- Line 41: `void clearRequests()`
- Line 43: `void addFilter(quint32 identifier)`
- Line 44: `void clearFilters()`
- Line 45: `void applyFilters()`
- Line 47: `void writeFrameDirect(quint32 id, const QByteArray &ba)`
- Line 49: `void removeRequests(quint32 id)`

**Protected methods:**
- Line 58 (canbus.h): `void sendRequest()`

**Private methods:**
- Line 61 (canbus.h): `void readFrame()`
- Line 62 (canbus.h): `void handleError(QCanBusDevice::CanBusError error)`

**Signals (canbus.h):**
- Line 54: `void error(QCanBusDevice::CanBusError canBusError)`
- Line 55: `void read(quint32 identifier, const QByteArray &ba)`

**Slots:** None explicitly declared (readFrame and handleError connected via lambda/signal-slot in initialize())

**#include directives (canbus.h):**
- `<QObject>`
- `<QCanBusDevice>`
- `<QCanBusFrame>`
- `<QQueue>`
- `<QTimer>`

**#include directives (canbus.cpp):**
- `"canbus.h"`
- `"platform/seriallogger.h"`
- `<QCanBus>`
- `<QMetaObject>`
- `<QProcess>`
- `<QTimerEvent>`
- `<QTimer>`
- `<QDebug>`
- `<QFile>`
- `<QDateTime>`

**Protocol constants / defines (canbus.cpp):**
- `REQUEST_TIMER  100` (line 14) — polling interval in milliseconds
- `CANBUS_DEBUG   0` (line 15) — debug flag

**Member variables (canbus.h):**
- `QCanBusDevice *m_canBusDevice` — pointer to Qt CAN bus device
- `CanDeviceId m_canDeviceId` — enum CAN1/CAN2
- `bool m_powerOn`
- `bool m_xferEnabled`
- `int m_baudRate`
- `QList<Request> m_requests`
- `QList<quint32> m_filterIds`
- `QQueue<QCanBusFrame> m_requestQueue`
- `QTimer *m_timer`
- `qint64 m_lastReportedError`

**Nested struct (canbus.h):**
- `Request { QCanBusFrame frame; quint32 interval; qint32 timer; }`

**Enum (canbus.h):**
- `CanDeviceId { CAN2, CAN1 }` — note: CAN2=0, CAN1=1 (reversed from natural order per schematic comment)

---

### gnssreceiver.h / gnssreceiver.cpp

**File paths:**
- `/c/Projects/cig-audit/repos/mark3-pvd/platform/gnssreceiver.h`
- `/c/Projects/cig-audit/repos/mark3-pvd/platform/gnssreceiver.cpp`

**Class name and base classes:**
- `EM070::GnssReceiver` : public `QObject`

**Q_OBJECT macro location:**
- `gnssreceiver.h` line 15

**Every public method with signature and line number (gnssreceiver.h):**
- Line 17: `explicit GnssReceiver(QObject *parent = nullptr)`
- Line 18: `void portStateChanged(bool open)`
- Line 19: `void reset()`
- Line 20: `void changeUpdateTime()`
- Line 22: `quint8 satelliteCount() const`
- Line 23: `qint32 latitude() const`
- Line 24: `qint32 longitude() const`
- Line 25: `qint32 lastLatitude() const`
- Line 26: `qint32 lastLongitude() const`
- Line 27: `qint16 speed() const`
- Line 28: `qint16 course() const`
- Line 29: `quint32 distance() const`
- Line 30: `quint32 sumOfDistance() const`
- Line 31: `quint32 altitude() const`
- Line 32: `bool locked() const`
- Line 33: `quint32 hpe() const` — inline, converts HDOP to accuracy estimate
- Line 34: `quint32 hdop() const`
- Line 35: `qint64 age()`
- Line 36: `quint8 warn() const`
- Line 37: `void setWarn(quint8 n)`
- Line 38: `quint8 quality() const`
- Line 39: `void setQuality(quint8 n)`
- Line 40: `quint16 markerCnt() const`
- Line 41: `void setMarkerCnt(quint16 n)`
- Line 42: `quint32 pathLatitude(int n)`
- Line 43: `void setPathLatitude(int n, quint32 lat)`
- Line 44: `quint32 pathLongitude(int n)`
- Line 45: `void setPathLongitude(int n, quint32 lon)`
- Line 46: `void gpsDebugPrint()`
- Line 47: `bool inPoly2(const CIGCONF::gpsPosStruct *gpsPos, const CIGCONF::polygonStruct *polygon)`
- Line 48: `bool pointInPolygon(int polyCorners, CIGCONF::position me, CIGCONF::position *points)`
- Line 49: `double degrees2radians(double degrees)`

**Protected methods:**
- Line 51 (gnssreceiver.h): `void timerEvent(QTimerEvent *)`

**Private methods:**
- Line 57 (gnssreceiver.h): `void readData()`
- Line 58 (gnssreceiver.h): `void parseData(const QByteArray &ba)`
- Line 59 (gnssreceiver.h): `void cumulateDistance()`
- Line 60 (gnssreceiver.h): `static quint32 calculateDistance(qint32 lat1, qint32 lng1, qint32 lat2, qint32 lng2)`

**Signals (gnssreceiver.h):**
- Line 54: `void sendGmtpMessage(CIGCONF::GmtpMessage msg, const QByteArray &extra = QByteArray())`

**Slots:** `readData()` connected to `QSerialPort::readyRead` (gnssreceiver.cpp line 39)

**#include directives (gnssreceiver.h):**
- `"app/cigconfigs.h"`
- `<QObject>`

**#include directives (gnssreceiver.cpp):**
- `"gnssreceiver.h"`
- `"app/globalconfigs.h"`
- `"platform/seriallogger.h"`
- `<QFile>`
- `<QSerialPort>`
- `<QTimerEvent>`
- `<QDebug>`
- `<QtMath>`
- `<math.h>`

**GNSS/GPS message format constants (gnssreceiver.cpp):**
- `FILE_GNSS_PORT  "/dev/ttyUSB1"` (line 11) — hardcoded serial port path
- `EARTH_R  6371000UL` (line 13) — earth radius in metres
- `MAX_POINTS (8)` (gnssreceiver.h line 7) — path point buffer size
- NMEA sentence types parsed: `GPGGA` (line 107), `GPRMC` (line 129)

**Member variables (gnssreceiver.h):**
- `quint16 m_markerCnt`
- `CIGCONF::gpsPosStruct m_path[MAX_POINTS]` — fixed array of 8 GPS path points
- `QSerialPort *m_serialPort`
- `QByteArray m_receiver` — serial receive buffer, reserved at 512 bytes
- `int m_timerId`
- `bool m_locked`
- `quint8 m_warn`
- `quint8 m_quality`
- `quint8 m_satelliteCount`
- `qint32 m_latitude`
- `qint32 m_longitude`
- `qint32 m_lastLatitude`
- `qint32 m_lastLongitude`
- `qint16 m_speed`
- `qint16 m_course`
- `quint32 m_distance`
- `quint16 m_hdop`
- `quint32 m_sumOfDistance`
- `quint32 m_diffDistance`
- `quint32 m_lastPos`
- `qint64 m_lastReport`
- `quint32 m_altitude`
- `bool m_positionValid`
- `qint64 m_timestamp`

---

## STEP 5 — SECURITY REVIEW

---

### 1. Memory Safety

**A12-1** · HIGH · Memory Safety
**File:** `platform/gnssreceiver.cpp:261`
**Description:** `m_path[m_markerCnt]` is written in `cumulateDistance()` without a bounds check before the write. `m_markerCnt` is incremented at lines 255 and 263, and the array `m_path` has exactly `MAX_POINTS` (8) elements. The check `if (m_markerCnt == MAX_POINTS)` at line 267 fires a GMTP message but does NOT stop further increments — after the message is sent, `cumulateDistance()` continues to be called (it is invoked on every GPGGA message while `m_warn == 'A'`), so on subsequent GPS fixes `m_markerCnt` equals 8 or higher and the write at line 261 `m_path[m_markerCnt].longitude = m_longitude` indexes past the end of the 8-element array. This is an out-of-bounds write producing undefined behaviour and potential memory corruption.

**A12-2** · MEDIUM · Memory Safety
**File:** `platform/gnssreceiver.cpp:97-98`
**Description:** `m_receiver` is a `QByteArray` pre-reserved to 512 bytes. In `readData()`, when a partial NMEA sentence spans a serial read boundary, the trailing bytes are appended to `m_receiver` at line 98 (`m_receiver += ba.right(size)`). There is no check on the total accumulated length of `m_receiver` before appending. A sender that transmits a very long line without a `\r` or `\n` terminator — possible if the serial input is tampered with or the GNSS module malfunctions — will cause `m_receiver` to grow without bound, consuming heap memory. This is a slow-path denial-of-service / heap exhaustion path.

**A12-3** · LOW · Memory Safety
**File:** `platform/gnssreceiver.cpp:116`
**Description:** `bas[8].toFloat() * 100` is assigned to `m_hdop` which is declared as `quint16`. The NMEA GPGGA HDOP field is a floating-point string. If a malformed or spoofed GPGGA sentence supplies a value greater than 655.35 the multiplication produces a value exceeding `UINT16_MAX` (65535), causing silent integer truncation on assignment. The downstream check `m_hdop >= 5000` at line 137 used to reject bad fixes could then be bypassed if the truncated value falls below 5000.

---

### 2. Communication Security

**A12-4** · INFO · Communication Security
**File:** `platform/canbus.cpp:40`
**Description:** The CAN bus device is created using Qt's `socketcan` plugin. CAN bus carries no authentication or encryption at the protocol level. Any device on the same physical CAN bus can inject frames with arbitrary IDs. The application accepts all frames passing the configured filter without any message authentication code or sequence number check. This is an inherent CAN bus limitation, but the absence of any in-software authentication layer means a rogue CAN node can inject spoofed vehicle data. Documented here for completeness as a known architectural constraint.

**A12-5** · INFO · Communication Security
**File:** `platform/gnssreceiver.cpp:11`
**Description:** GNSS data is received over a serial port (`/dev/ttyUSB1`) from the GNSS module. There is no authentication of the GNSS data stream. A hardware-level attacker with access to the serial bus could inject arbitrary NMEA sentences. The application applies only a satellite-count and HDOP quality gate before accepting position data as valid. There is no GNSS spoofing detection (e.g., sudden large position jumps, unexpected signal levels). Given this is a proximity detection safety device, GNSS spoofing is a meaningful threat; the current implementation has no countermeasure.

---

### 3. Input Handling

**A12-6** · HIGH · Input Handling
**File:** `platform/gnssreceiver.cpp:104`
**Description:** In `parseData()`, `bas[0]` is accessed unconditionally at line 104 without first checking that `bas` is non-empty. `ba.split(',')` on an empty `QByteArray` returns a list with one empty element, so this does not crash in that case. However, `bas[6]` is accessed at line 110 inside the `GPGGA` branch only after checking `size >= 8`, and `bas[8]` at line 116 is also within that guard. In the `GPRMC` branch at line 129 the check is `size > 8` (strictly greater than 8) meaning `bas[8]` at line 161 is valid. However, `bas[2].at(0)` at line 132 is called after only `size > 8` is confirmed — this accesses element 2 which is within bounds, but `at(0)` on an empty `QByteArray` (if field 2 of the NMEA sentence is empty) will trigger an assertion failure or undefined behaviour. A GPRMC sentence with an empty status field (`,, ,`) would reach line 132 and call `at(0)` on an empty byte array.

**A12-7** · MEDIUM · Input Handling
**File:** `platform/gnssreceiver.cpp:143-152`
**Description:** Latitude and longitude are parsed from NMEA fields using `left()`, `mid()`, `toInt()`, and `toFloat()` without validating field lengths. For latitude (GPGGA/GPRMC `ddmm.mmmmm` format), `bas[3].left(2).toInt()` assumes at least 2 characters are present, and `bas[3].mid(2, 7).toFloat()` assumes at least 9 characters. If a spoofed or malformed NMEA sentence supplies a shorter field, `left(2)` or `mid(2,7)` silently return shorter strings and `toInt()`/`toFloat()` parse whatever is there. No range validation is applied to the resulting `latitude` value before it is stored in `m_latitude` and used in safety-critical geofencing logic. A valid geographic latitude in `qint32` scaled units should be in the range -900000000 to 900000000 — values outside this range are not rejected.

**A12-8** · MEDIUM · Input Handling
**File:** `platform/canbus.cpp:133-148`
**Description:** In `setPower()`, shell commands are built using `QStringLiteral("...").arg(m_canDeviceId)` and `QStringLiteral("...").arg(m_baudRate)`. `m_canDeviceId` is an enum (values 0 or 1), so injection via that field is not possible. However, `m_baudRate` is an `int` supplied by callers via `setBaudRate(int baudRate)`. There is no validation that `m_baudRate` is a legitimate CAN baud rate value (e.g., 125000, 250000, 500000, 1000000) before it is interpolated into the shell command at line 144: `/home/bin/ip link set up can%1 type can bitrate %2`. An integer value cannot carry shell metacharacters since Qt's `arg()` formats it numerically, so direct shell injection is not possible here. However, an extremely large or negative baud rate will produce an invalid `ip link` command without any diagnostic, and the failure is silently swallowed — the function returns without signalling the error to the caller.

**A12-9** · LOW · Input Handling
**File:** `platform/gnssreceiver.cpp:107`
**Description:** The NMEA sentence type is checked by comparing the first field `bas[0]` (after splitting on `,`) against string literals `"GPGGA"` and `"GPRMC"`. There is no NMEA checksum validation anywhere in `parseData()` or `readData()`. NMEA 0183 sentences include an optional `*HH` checksum at the end of each sentence. The code does not strip or verify this checksum before parsing numeric fields. A corrupted transmission or injected sentence with a wrong checksum will be silently accepted. Checksum validation would reject single-bit errors and trivial injection attempts at the serial layer.

---

### 4. Build Security

Build Security: no issues found in the files under review. The `.pro` file was not assigned to this auditor; compiler flag analysis is deferred to the auditor assigned to the build configuration files.

---

### 5. Device and Firmware

**A12-10** · MEDIUM · Device and Firmware
**File:** `platform/gnssreceiver.cpp:11`
**Description:** The GNSS serial port path `"/dev/ttyUSB1"` is hardcoded as a compile-time `#define`. A runtime override is provided via the environment variable `QT_NMEA_SERIAL_PORT` (lines 24-26). Reading a device path from an unauthenticated environment variable in production firmware allows an attacker with process-level access to redirect the GNSS input to an attacker-controlled file or device, feeding arbitrary NMEA sentences to the parser. On an embedded device where the environment is set from a configuration script, this is an elevated risk if that script is world-writable.

**A12-11** · HIGH · Device and Firmware
**File:** `platform/gnssreceiver.cpp:258-265`
**Description:** GPS path waypoints (`m_path[]`) are written to the fixed array in `cumulateDistance()` using `m_markerCnt` as the index, which is incremented every time the cumulative distance exceeds the configured `gpsDistanceMark()` threshold. The `gpsDistanceMark()` value comes from `gCfg` (global configuration), which is received from a server according to the checklist description of this device class. If a server or configuration file supplies a very small `gpsDistanceMark` value (e.g., 0 or 1 metre), the counter increments on every GPS fix and the out-of-bounds write described in A12-1 is triggered rapidly. A safety-critical parameter (distance marking threshold) received from an external source without a minimum-value floor directly enables a memory corruption path.

**A12-12** · MEDIUM · Device and Firmware
**File:** `platform/gnssreceiver.cpp:272-310`
**Description:** Geofence polygon vertices are read from `gCfg->polygon(polygon)` and `gCfg->polygonNPoints(polygon)` inside the geofencing loop in `cumulateDistance()`. The polygon data originates from server-supplied configuration. The loop iterates `i` from 0 to `polyCorners-1` and writes into `points[i]` where `points` is a fixed-size stack array `CIGCONF::position points[MAX_POLY_POINTS]` (line 277). If the server supplies a `polygonNPoints` value larger than `MAX_POLY_POINTS`, the loop at line 289 writes past the end of the stack-allocated `points` array, causing a stack buffer overflow. There is no check that `polyCorners <= MAX_POLY_POINTS` before the loop begins.

---

### 6. Qt-Specific Security

**A12-13** · MEDIUM · Qt-Specific Security
**File:** `platform/canbus.cpp:124-148`
**Description:** `QProcess` is used in `setPower()` to invoke `ifconfig` and `/home/bin/ip link set`. The `QProcess::start()` call at line 134 passes the full command as a single string (not a program + argument list). When `QProcess::start()` receives a single string, Qt splits it on spaces — this is the "shell-style" single-string form. While `m_canDeviceId` (an enum integer) and `m_baudRate` (an integer) cannot carry shell metacharacters, the use of `QProcess::start(QString)` with a constructed command string rather than `QProcess::start(QString program, QStringList args)` is a maintainability risk: if a future refactor introduces a string-typed parameter (e.g., a configurable interface name), the single-string invocation form does not provide the argument isolation that the two-argument form provides.

**A12-14** · LOW · Qt-Specific Security
**File:** `platform/canbus.cpp:30-32`
**Description:** The destructor `CanBus::~CanBus()` manually calls `delete m_canBusDevice` after a null check. `m_canBusDevice` is created with `QCanBus::instance()->createDevice()` in `initialize()` but is also passed `this` as the parent at construction in some Qt patterns. If `m_canBusDevice` was created with a parent, Qt's object tree will also attempt to delete it, resulting in a double-free. Inspection of line 40 shows `createDevice()` is called without passing a parent, so the object is unparented and the manual delete is the sole deletion path. This is currently safe, but the pattern is fragile: if `initialize()` is ever refactored to pass a parent, a double-free would be introduced silently.

---

## Summary of Findings

| ID | Severity | Category | File |
|---|---|---|---|
| A12-1 | HIGH | Memory Safety | `platform/gnssreceiver.cpp:261` |
| A12-2 | MEDIUM | Memory Safety | `platform/gnssreceiver.cpp:97-98` |
| A12-3 | LOW | Memory Safety | `platform/gnssreceiver.cpp:116` |
| A12-4 | INFO | Communication Security | `platform/canbus.cpp:40` |
| A12-5 | INFO | Communication Security | `platform/gnssreceiver.cpp:11` |
| A12-6 | HIGH | Input Handling | `platform/gnssreceiver.cpp:104` |
| A12-7 | MEDIUM | Input Handling | `platform/gnssreceiver.cpp:143-152` |
| A12-8 | MEDIUM | Input Handling | `platform/canbus.cpp:133-148` |
| A12-9 | LOW | Input Handling | `platform/gnssreceiver.cpp:107` |
| A12-10 | MEDIUM | Device and Firmware | `platform/gnssreceiver.cpp:11` |
| A12-11 | HIGH | Device and Firmware | `platform/gnssreceiver.cpp:258-265` |
| A12-12 | MEDIUM | Device and Firmware | `platform/gnssreceiver.cpp:272-310` |
| A12-13 | MEDIUM | Qt-Specific Security | `platform/canbus.cpp:124-148` |
| A12-14 | LOW | Qt-Specific Security | `platform/canbus.cpp:30-32` |
# Pass 1 Audit — A13
**Date:** 2026-02-28
**Branch:** master
**Auditor:** A13

---

## Step 4 — Reading Evidence

### File Pair 1: InternalRfid

**File paths:**
- `/c/Projects/cig-audit/repos/mark3-pvd/platform/internalrfid.h`
- `/c/Projects/cig-audit/repos/mark3-pvd/platform/internalrfid.cpp`

**Class name and base classes:**
- `EM070::InternalRfid` : `QObject`

**Q_OBJECT macro location:**
- `internalrfid.h` line 12

**Public methods (signature : line):**
- `explicit InternalRfid(QObject *parent = 0)` : h:14 / cpp:12
- `void setEnabled(bool enabled)` : h:15 / cpp:38

**Signals:**
- `void response()` : h:18
- `void cardData(quint64 wiegand, quint16 facility, quint32 number, QByteArray &readerOutput)` : h:19
- `void error(const QString &text)` : h:20

**Slots (private):**
- `void readData()` (connected to `QSerialPort::readyRead`) : h:23 / cpp:51
- `void parseData()` : h:24 / cpp:67

**`#include` directives (cpp):**
- `#include "internalrfid.h"` (cpp:1)
- `#include "wiegandrfid.h"` (cpp:2)
- `#include <QSerialPort>` (cpp:3)
- `#include <QDebug>` (cpp:4)
- `#include "seriallogger.h"` (cpp:5)

**`#include` directives (h):**
- `#include <QObject>` (h:4)

**Serial port configuration:**
- Port name default: `/dev/ttyS2` (macro `FILE_SERIAL_PORT`, cpp:7)
- Port name override: environment variable `QT_RFID_SERIAL_PORT` (cpp:16–18)
- Baud rate: `QSerialPort::Baud115200` (cpp:22)
- Data bits: `Data8` (cpp:23)
- Stop bits: `OneStop` (cpp:24)
- Parity: `NoParity` (cpp:25)
- Flow control: `NoFlowControl` (cpp:26)

**Member variables:**
- `QSerialPort *m_serialPort` : h:26
- `QByteArray m_receiver` : h:27

**Key macros:**
- `FILE_SERIAL_PORT "/dev/ttyS2"` (cpp:7)
- `RECEIVER_MAX_SIZE 128` (cpp:8)

---

### File Pair 2: InternalRtc

**File paths:**
- `/c/Projects/cig-audit/repos/mark3-pvd/platform/internalrtc.h`
- `/c/Projects/cig-audit/repos/mark3-pvd/platform/internalrtc.cpp`

**Class name and base classes:**
- `EM070::InternalRtc` — no base class, no Q_OBJECT, static-method-only utility class

**Q_OBJECT macro location:**
- None

**Public methods (signature : line):**
- `static void setRtcTime(QDateTime dateTime = QDateTime())` : h:11 / cpp:10
- `static void setSystemTime()` : h:12 / cpp:24
- `static quint64 euiAddress()` : h:13 / cpp:31

**Signals:** None

**Slots:** None

**`#include` directives (cpp):**
- `#include "internalrtc.h"` (cpp:1)
- `#include <QFile>` (cpp:2)
- `#include <QProcess>` (cpp:3)

**`#include` directives (h):**
- `#include <QDateTime>` (h:4)

**Serial port configuration:** N/A

**Member variables:** None (all static methods)

**Key macros:**
- `FILE_RTC_DEVICE "/dev/rtc1"` (cpp:5)
- `FILE_RTC_EUI "/sys/devices/platform/nuc970-i2c0/i2c-0/0-006f/eui"` (cpp:6)

---

### File Pair 3: ModemPort

**File paths:**
- `/c/Projects/cig-audit/repos/mark3-pvd/platform/modemport.h`
- `/c/Projects/cig-audit/repos/mark3-pvd/platform/modemport.cpp`

**Class name and base classes:**
- `EM070::ModemPort` : `QObject`

**Q_OBJECT macro location:**
- `modemport.h` line 11

**Public methods (signature : line):**
- `explicit ModemPort(QObject *parent = nullptr)` : h:14 / cpp:12
- `bool sendCmd(const QByteArray &cmd)` : h:15 / cpp:125
- `void resetModem()` : h:16 / cpp:50
- `void setEnabled(bool enable)` : h:17 / cpp:68
- `void setEcho(bool enable)` : h:18 (inline)
- `bool isWwx()` : h:19 (inline)
- `void setWwx(bool isWwx)` : h:20 (inline)

**Signals:**
- `void portStateChanged(bool open)` : h:23
- `void response(bool ok, const QByteArrayList &content)` : h:24

**Private slots/methods:**
- `void openPort()` : h:27 / cpp:90
- `void portError()` : h:28 / cpp:108
- `void readData()` : h:29 / cpp:139
- `void parseData(const QByteArray &line)` : h:30 / cpp:168

**`#include` directives (cpp):**
- `#include "modemport.h"` (cpp:1)
- `#include "seriallogger.h"` (cpp:2)
- `#include <QProcess>` (cpp:3)
- `#include <QDebug>` (cpp:4)
- `#include <QFile>` (cpp:5)

**`#include` directives (h):**
- `#include <QObject>` (h:4)
- `#include <QSerialPort>` (h:5)
- `#include <QTimer>` (h:6)

**Serial port configuration:**
- Port name default (arm): `/dev/ttyUSB3` (macro `FILE_MODEM_PORT`, cpp:8), fallback `/dev/ttyUSB2` (cpp:7)
- Port name override: environment variable `QT_MOBILE_SERIAL_PORT` (cpp:21–23)
- Non-arm default: hardcoded `"COM4"` (cpp:33)
- Baud rate: `QSerialPort::Baud115200` (cpp:35)
- Data bits: `Data8` (cpp:36)
- Stop bits: `OneStop` (cpp:37)
- Parity: `NoParity` (cpp:38)
- Flow control: `NoFlowControl` (cpp:39)

**Member variables:**
- `QSerialPort *m_serialPort` : h:32
- `QTimer *m_timer` : h:33
- `int m_tryTimes` : h:34
- `QByteArray m_receiver` : h:35
- `QByteArrayList m_response` : h:36
- `QByteArray m_cmdLine` : h:37
- `bool m_echo` : h:38
- `bool m_wwx` : h:39

**Key macros:**
- `FILE_MODEM_PORT_WWX "/dev/ttyUSB2"` (cpp:7)
- `FILE_MODEM_PORT "/dev/ttyUSB3"` (cpp:8)

---

## Step 5 — Security Review

---

### 1. Memory Safety

**A13-1** · MEDIUM · Memory Safety
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/platform/internalrfid.cpp:53-58`
**Description:** `readData()` appends all available serial bytes to `m_receiver` before checking the size: `m_receiver += m_serialPort->readAll()` (line 53), then checks `if (m_receiver.size() > RECEIVER_MAX_SIZE)` (line 55). This means the buffer is allowed to grow beyond the 128-byte limit before the overflow is detected and the buffer cleared. A malicious or malfunctioning RFID reader could deliver a single large burst that exceeds RECEIVER_MAX_SIZE before the check fires. The correct pattern is to enforce the limit before appending. The reserve(RECEIVER_MAX_SIZE) call (line 34) sets internal capacity only and does not prevent the QByteArray from growing past that size.

**A13-2** · LOW · Memory Safety
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/platform/modemport.cpp:164-165`
**Description:** The `readData()` loop accumulates trailing bytes (non-terminated line fragments) into `m_receiver` indefinitely: `m_receiver += ba.right(size)` (line 165). There is no length cap on `m_receiver` for the modem port. A modem that streams data without a line terminator (or a line that is never terminated) will grow `m_receiver` without bound, consuming heap memory and potentially causing an out-of-memory crash on the embedded target. The RFID receiver has an explicit maximum-size guard; the modem receiver does not.

---

### 2. Communication Security

**A13-3** · HIGH · Communication Security
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/platform/internalrtc.cpp:19-21`
**Description:** `setRtcTime()` constructs a shell command string and executes it via `QProcess::execute(cmd)` where `cmd` is assembled from a hardcoded string plus the hardcoded macro `FILE_RTC_DEVICE`. Although in this specific instance the path is a compile-time constant, the pattern of constructing a shell command string and passing it to `QProcess::execute` is dangerous. `QProcess::execute(QString)` on Qt interprets the argument through the shell on some platforms. If `FILE_RTC_DEVICE` were ever sourced from a configuration file or environment variable, shell injection would be directly possible. The same pattern appears in `setSystemTime()` (line 26) and in `resetModem()` via `QProcess::startDetached("/etc/pvd/mobile -r")` (modemport.cpp:61). See also A13-4 for `resetModem()`.

**A13-4** · HIGH · Communication Security
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/platform/modemport.cpp:61`
**Description:** `QProcess::startDetached("/etc/pvd/mobile -r")` launches an external binary using a hardcoded absolute path in a single-string form. The path `/etc/pvd/mobile` is writable only by root on a standard Linux system, but passing the command as a single string to `startDetached` invokes shell processing. If the path or arguments ever become configurable this is a direct command injection path. Additionally, the detached process is started with no handle retained — there is no way to determine whether it launched successfully or to manage its lifecycle.

Communication Security (TLS, credentials, hardcoded keys): no issues found in these three files. The modem port transmits AT commands over a local serial port (not a network socket), and no APN credentials or authentication tokens appear in these files.

---

### 3. Input Handling

**A13-5** · MEDIUM · Input Handling
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/platform/internalrfid.cpp:108-109`
**Description:** The final `else` branch of `parseData()` emits `cardData(0, 0, 0, log)` for any trimmed line longer than 3 bytes that does not match the `#6:`, `#8:`, or `#R` prefixes (line 108–109). This means arbitrary unrecognised data from the RFID serial port will propagate upward to callers as a card-read event with wiegand=0, facility=0, number=0. If the upstream handler treats a wiegand value of 0 as a valid card presentation (even an access-denied one), this produces phantom authentication attempts from noise, framing errors, or from a spoofed device injecting garbage. No validation is performed that the data represents a well-formed RFID response before emitting the signal.

**A13-6** · MEDIUM · Input Handling
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/platform/internalrfid.cpp:83-95`
**Description:** RFID tag facility and card number values are parsed from hex strings and subjected only to a non-zero check (`if (facility && number)`) before being passed to the authentication function `wiegandData()` and emitted on the `cardData` signal (lines 86–87, 93–94). There is no range validation: facility is extracted as `quint8` from a 2-hex-digit field for the `#6:` format (line 84), but for `#8:` format facility is `quint16` from a 4-hex-digit field (line 91) — a value of `0xFFFF` is accepted without question. No maximum value check, format canonicalisation, or replay-protection mechanism is present before these values are used in authentication decisions.

**A13-7** · LOW · Input Handling
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/platform/internalrfid.cpp:79`
**Description:** `qDebug() << "Read internal card data: " << ba` logs raw RFID serial data to the debug output. The `ba` value is a trimmed `QByteArray` received directly from the serial port with no sanitisation. On a system where debug output is aggregated into a log file or transmitted over a network interface, this constitutes unauthenticated external data reaching log sinks. If the logging subsystem performs any further string interpolation, this could become a log injection vector. The same raw data flows into `SerialLogger::log` via the `log` variable constructed at line 81.

**A13-8** · LOW · Input Handling
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/platform/modemport.cpp:170`
**Description:** `qDebug() << "ModemPort <" << line` logs the full content of every line received from the modem to debug output without any sanitisation. Modem responses can include operator-provided strings (e.g., SMS body text, network operator name in `+COPS` responses) that an adversary with influence over the modem link could craft to inject content into logs.

---

### 4. Build Security

Build Security: no issues found. Build security (compiler flags, .pro file, strip configuration) is outside the scope of the three file pairs assigned to this auditor. No relevant build configuration is present in the reviewed files.

---

### 5. Device and Firmware

**A13-9** · MEDIUM · Device and Firmware
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/platform/internalrfid.cpp:7`
**Description:** The RFID serial port path `/dev/ttyS2` is hardcoded as a compile-time macro (`FILE_SERIAL_PORT`). While an environment variable override (`QT_RFID_SERIAL_PORT`) is supported, the fallback is a fixed kernel device node. On a device where the hardware layout changes (different carrier board revision, updated device tree), firmware must be recompiled to update the port assignment. More critically, no validation is performed on the `QT_RFID_SERIAL_PORT` environment variable value before use — any string set in the environment is accepted as a port name, potentially redirecting the RFID driver to an unintended device.

**A13-10** · MEDIUM · Device and Firmware
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/platform/internalrfid.cpp:83-109`
**Description:** There is no anti-replay mechanism for RFID authentication events. The RFID reader emits `cardData` signals for every parsed tag read with no sequence number, timestamp comparison, or deduplication window. A captured Wiegand transmission replayed over the serial interface (or a stuck reader transmitting the same tag ID repeatedly) will generate repeated authentication attempts indistinguishable from legitimate access. This is a fundamental anti-replay gap in the RFID authentication path.

**A13-11** · LOW · Device and Firmware
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/platform/internalrtc.cpp:6`
**Description:** The EUI address is read from a sysfs path `/sys/devices/platform/nuc970-i2c0/i2c-0/0-006f/eui` hardcoded as a compile-time macro. The EUI is returned as a `quint64` with no validation that the value is non-zero or within the valid EUI-64 range. A return value of 0 (file missing, read error, or device not present) is silently returned to the caller with no error indication beyond the fact that 0 is returned. If the EUI is used as a device identifier for authentication or registration, a zero value could cause device identity confusion.

**A13-12** · INFO · Device and Firmware
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/platform/modemport.cpp:29`
**Description:** The line `//m_wwx = true;` is a commented-out assignment that would enable the WWX modem variant path. The fallback device selection logic (lines 26–31) silently selects the WWX port (`/dev/ttyUSB2`) when the primary port (`/dev/ttyUSB3`) does not exist, but sets `m_wwx = false` (the commented line that would set it true is disabled). This means the device type flag does not reflect the actual hardware in use when the fallback path is taken, potentially causing incorrect modem initialisation commands to be sent. This appears to be a deliberate or inadvertent uncommitted change with a safety-affecting consequence.

---

### 6. Qt-Specific Security

**A13-13** · HIGH · Qt-Specific Security
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/platform/internalrtc.cpp:19-21`
**Description:** `QProcess::execute(cmd)` is called with a `QString` assembled by concatenation (line 21). Qt's `QProcess::execute(const QString &command)` overload on Linux passes the command through `/bin/sh -c`, which means shell metacharacters in the string are interpreted. Although `FILE_RTC_DEVICE` is a compile-time constant here, using the single-string `QProcess::execute` form instead of the `QProcess::execute(program, arguments)` overload is an unsafe pattern. The same applies to `setSystemTime()` (line 27) and `resetModem()` in modemport.cpp (line 61). All three call sites should use the two-argument `QProcess` form with a separate argument list to prevent shell injection if any part of the path ever becomes runtime-configurable.

**A13-14** · INFO · Qt-Specific Security
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/platform/internalrfid.cpp:44,46`
**Description:** `m_serialPort->write("AT+LFID=ON\r")` and `m_serialPort->write("AT+LFID=OFF\r")` use string literals that are not `QStringLiteral`-wrapped (they are `const char*` literals passed to `QSerialPort::write(const char*)`). This is not a security vulnerability but is noted for completeness: there is no return-value check on `write()`, so a failed write (serial port closed or error state) is silently ignored. The `waitForBytesWritten(10)` call uses a 10-millisecond timeout with no handling of the return value, so command delivery failure goes undetected.
# Pass 1 Audit — A14
**Auditor:** A14
**Date:** 2026-02-28
**Branch:** master (confirmed)
**Files reviewed:**
- `/c/Projects/cig-audit/repos/mark3-pvd/platform/powersupply.h`
- `/c/Projects/cig-audit/repos/mark3-pvd/platform/powersupply.cpp`
- `/c/Projects/cig-audit/repos/mark3-pvd/platform/pwmbacklight.h`
- `/c/Projects/cig-audit/repos/mark3-pvd/platform/pwmbacklight.cpp`
- `/c/Projects/cig-audit/repos/mark3-pvd/platform/pwmbeeper.h`
- `/c/Projects/cig-audit/repos/mark3-pvd/platform/pwmbeeper.cpp`

---

## STEP 4 — READING EVIDENCE

### powersupply.h / powersupply.cpp

**File paths:**
- `/c/Projects/cig-audit/repos/mark3-pvd/platform/powersupply.h`
- `/c/Projects/cig-audit/repos/mark3-pvd/platform/powersupply.cpp`

**Class name and base classes:**
- `EM070::PowerSupply` : `QObject`

**Q_OBJECT macro location:**
- `powersupply.h` line 14

**Every public method with signature and line number:**
- `explicit PowerSupply(QObject *parent = nullptr)` — h:19
- `bool isIgnitionOn() const` — h:21
- `bool isPowerGood() const` — h:23
- `bool isBatteryAvailable() const` — h:24
- `ChargeState chargeState() const` — h:25
- `ChargeFault chargeFault() const` — h:26
- `quint16 voltage() const` — h:27
- `qint16 current() const` — h:28
- `quint16 temperature() const` — h:29
- `quint16 remainingCapacity() const` — h:30
- `quint16 designCapacity() const` — h:31
- `quint16 timeToEmpty() const` — h:32
- `quint16 timeToFull() const` — h:33
- `static void reboot()` — h:35
- `static void poweroff()` — h:36
- `static void setBlankMode(BlankMode mode)` — h:37
- `static void setTouchPower(bool on)` — h:38
- `static void charge(bool enable)` — h:39
- `static void setBatteryEnabled(bool enable)` — h:40

**Signals:**
- `void ignitionStateChanged(bool on)` — h:43
- `void batteryStatusRead(bool avail, int state, int fault, quint16 voltage, qint16 current, quint16 temp, quint16 remainingCapacity)` — h:44

**Slots (private):**
- `void readIgnitionState()` — h:47 (connected to QSocketNotifier::activated)
- `void readChargerStatus()` — h:48 (connected to QTimer::timeout)
- `void readGaugeStatus()` — h:49 (called from readChargerStatus)

**#include directives (powersupply.h):**
- `<QObject>` — h:4
- `<QFile>` — h:5

**#include directives (powersupply.cpp):**
- `"powersupply.h"` — cpp:1
- `<QEventLoop>` — cpp:2
- `<QProcess>` — cpp:3
- `<QSocketNotifier>` — cpp:4
- `<QTimer>` — cpp:5
- `<QDebug>` — cpp:6

**Hardware register / sysfs paths defined (powersupply.cpp):**
- `FILE_IGNITION` = `/sys/devices/platform/nuc970-gpio.0/gpio/gpio225/value` — cpp:10
- `FILE_FB_BLANK` = `/sys/devices/platform/nuc970-lcd/graphics/fb0/blank` — cpp:11
- `FILE_TOUCH_POWER` = `/sys/touchscreen/power_state` — cpp:12
- `FILE_CHARGE_EN` = `/sys/class/gpio/gpio160/value` — cpp:13
- `FILE_BATFET_DISABLE` = `/sys/devices/platform/nuc970-i2c0/i2c-0/0-006b/power_supply/bq24190-charger/f_batfet_disable` — cpp:14
- `FILE_PG_STAT` = `/sys/devices/platform/nuc970-i2c0/i2c-0/0-006b/power_supply/bq24190-charger/f_pg_stat` — cpp:15
- `FILE_VSYS_STAT` = `/sys/devices/platform/nuc970-i2c0/i2c-0/0-006b/power_supply/bq24190-charger/f_vsys_stat` — cpp:16
- `FILE_CHRG_STAT` = `/sys/devices/platform/nuc970-i2c0/i2c-0/0-006b/power_supply/bq24190-charger/f_chrg_stat` — cpp:17
- `FILE_CHRG_FAULT` = `/sys/devices/platform/nuc970-i2c0/i2c-0/0-006b/power_supply/bq24190-charger/f_chrg_fault` — cpp:18
- `FILE_NTC_FAULT` = `/sys/devices/platform/nuc970-i2c0/i2c-0/0-006b/power_supply/bq24190-charger/f_ntc_fault` — cpp:19
- `FILE_GAUGE_REGS` = `/sys/devices/platform/nuc970-i2c0/i2c-0/0-0055/show_regs` — cpp:20

**Member variables:**
- `QFile m_ignitionFile` — h:51
- `QSocketNotifier *m_notifier` — h:52
- `QTimer *m_timer` — h:53
- `bool m_ignitionOn` — h:55
- `bool m_powerGood` — h:56
- `bool m_batteryAvailable` — h:57
- `ChargeState m_chargeState` — h:58
- `ChargeFault m_chargeFault` — h:59
- `quint16 m_voltage` — h:60 (in mV)
- `qint16 m_current` — h:61 (in mA)
- `quint16 m_temperature` — h:62 (in Celsius)
- `quint16 m_remainingCapacity` — h:63 (in %)
- `quint16 m_designCapacity` — h:64 (in mAH)
- `quint16 m_timeToEmpty` — h:65 (in minutes)
- `quint16 m_timeToFull` — h:66 (in minutes)

---

### pwmbacklight.h / pwmbacklight.cpp

**File paths:**
- `/c/Projects/cig-audit/repos/mark3-pvd/platform/pwmbacklight.h`
- `/c/Projects/cig-audit/repos/mark3-pvd/platform/pwmbacklight.cpp`

**Class name and base classes:**
- `EM070::PwmBacklight` : `QObject`

**Q_OBJECT macro location:**
- `pwmbacklight.h` line 13

**Every public method with signature and line number:**
- `explicit PwmBacklight(QObject *parent = nullptr)` — h:16
- `~PwmBacklight()` — h:17
- `void setAutoBrightness(bool enable)` — h:18
- `bool isAutoBrightness() const` — h:19
- `static quint8 brightness()` — h:21
- `static void setBrightness(quint8 val)` — h:22

**Signals:**
- `void luxRead(int lux)` — h:25

**Slots (protected / private):**
- `void timerEvent(QTimerEvent *)` — h:28 (protected, Qt event override)
- `void parse(int lux)` — h:31 (private)
- `void adjust(int lux)` — h:32 (private)
- `int readLux()` — h:33 (private)

**#include directives (pwmbacklight.h):**
- `<QObject>` — h:4
- `<QFile>` — h:5
- `<QQueue>` — h:6
- `<QMap>` — h:7

**#include directives (pwmbacklight.cpp):**
- `"pwmbacklight.h"` — cpp:1
- `<QTimerEvent>` — cpp:2
- `<QFile>` — cpp:3
- `<QDebug>` — cpp:4

**Hardware register / sysfs paths defined (pwmbacklight.cpp):**
- `FILE_BRIGHTNESS` = `/sys/devices/platform/pwm-backlight.0/backlight/pwm-backlight.0/brightness` — cpp:6
- `FILE_ALS_POWER` = `/sys/devices/platform/nuc970-i2c0/i2c-0/0-0044/power_state` — cpp:7
- `FILE_ALS_RANGE` = `/sys/devices/platform/nuc970-i2c0/i2c-0/0-0044/range` — cpp:8
- `FILE_ALS_LUX` = `/sys/devices/platform/nuc970-i2c0/i2c-0/0-0044/lux` — cpp:9

**Macros:**
- `TIMER_INTERVAL` = 250 — cpp:11
- `TWO_SECONDS` = 7 — cpp:12
- `THREE_SECONDS` = 11 — cpp:13
- `MAX_QUEUE_SIZE` = 20 — cpp:15
- `X1P1(v)` = `(v) * 333 >> 8` — cpp:17
- `X1P2(v)` = `(v) * 333 >> 8` — cpp:18

**Member variables:**
- `QFile m_alsPowerFile` — h:36
- `QFile m_alsLuxFile` — h:37
- `QMap<int, int> m_brightnessMap` — h:38
- `QQueue<int> m_luxQueue` — h:39
- `bool m_autoBrightness` — h:40
- `int m_timerId` — h:41
- `State m_state` — h:42
- `quint8 m_stateCount` — h:43
- `int m_currentLux` — h:44

---

### pwmbeeper.h / pwmbeeper.cpp

**File paths:**
- `/c/Projects/cig-audit/repos/mark3-pvd/platform/pwmbeeper.h`
- `/c/Projects/cig-audit/repos/mark3-pvd/platform/pwmbeeper.cpp`

**Class name and base classes:**
- `EM070::PwmBeeper` : `QObject`

**Q_OBJECT macro location:**
- `pwmbeeper.h` line 13

**Every public method with signature and line number:**
- `explicit PwmBeeper(bool autoDelete = false, QObject *parent = nullptr)` — h:18
- `~PwmBeeper()` — h:19
- `void setFrequency(quint16 frequency)` — h:20
- `void beep(quint16 milliseconds)` — h:21
- `void beep(quint16 frequency, quint16 milliseconds)` — h:22
- `void beep(qint16 count, quint16 msecOn, quint16 msecOff)` — h:23
- `void stop()` — h:24

**Signals:** None.

**Slots (private):**
- `void timeout()` — h:27 (connected to QTimer::timeout)
- `void setBeep(bool on)` — h:28 (private helper)

**#include directives (pwmbeeper.h):**
- `<QObject>` — h:4
- `<QFile>` — h:5

**#include directives (pwmbeeper.cpp):**
- `"pwmbeeper.h"` — cpp:1
- `<linux/input.h>` (guarded by `#ifdef __arm__`) — cpp:3
- `<QTimer>` — cpp:5
- `<QDebug>` — cpp:6

**Hardware device path defined (pwmbeeper.cpp):**
- `FILE_BEEPER` = `/dev/input/event3` — cpp:8

**Member variables:**
- `QTimer *m_timerOn` — h:30
- `QTimer *m_timerOff` — h:31
- `QFile m_file` — h:32
- `bool m_autoDelete` — h:33
- `quint16 m_frequency` — h:34
- `bool m_beeping` — h:35
- `qint16 m_count` — h:36
- `quint16 m_msecOn` — h:37
- `quint16 m_msecOff` — h:38

---

## STEP 5 — SECURITY REVIEW

### 1. Memory Safety

**powersupply.cpp — gauge data parsed with no array bounds check**

`readGaugeStatus()` at line 143 splits a single line read from sysfs into a `QByteArrayList` and then directly indexes `args[0]` through `args[6]` (lines 145, 154, 158, 163, 166, 170, 174) without first verifying that `args.size() >= 7`. If the kernel driver or the sysfs file returns a line with fewer than seven comma-separated fields — due to a partial read, driver bug, or filesystem error — any of these accesses will index out of bounds on a `QByteArrayList`, which in Qt invokes undefined behaviour (the operator[] on QList performs no bounds check in release builds). On an embedded device running without address-space layout randomisation and without a stack protector (see Section 4), this is an exploitable crash vector.

**powersupply.cpp — temperature calculation can produce a signed integer underflow stored in an unsigned type**

At line 160:
```cpp
m_temperature = (value - 2732) / 10;
```
`value` is `int`, `m_temperature` is `quint16`. If the gauge returns a raw temperature below 2732 (i.e., below 273.2 K, which is physically impossible but possible if the sensor faults or returns 0), `(value - 2732)` is negative, the division truncates toward zero to a negative `int`, and assigning that to a `quint16` wraps to a large positive number (e.g., -10 / 10 = -1, stored as 65535). This corrupted temperature is then emitted in the `batteryStatusRead` signal and may affect safety-critical charge logic or UI display.

**pwmbacklight.cpp — integer overflow in lux threshold macros for large lux values**

At lines 17–18:
```cpp
#define X1P1(v)     ((v) * 333 >> 8)
#define X1P2(v)     ((v) * 333 >> 8)
```
Both macros multiply `v` (an `int`) by 333 before shifting. For `v` = `m_currentLux` which is of type `int` and is populated from `ba.toInt()` on sensor data read from sysfs, the ALS sensor range is documented as up to 4000 lux. `4000 * 333 = 1,332,000` which fits in a 32-bit `int`. However, the sysfs read is uncapped: if the sensor or a faulty driver returns a value larger than approximately 6,442,450 (0x62B3_D2), the multiplication overflows a 32-bit signed integer, producing a negative or wrapped result. The macros are used in `parse()` (lines 139, 146) to make brightness change decisions; overflow would cause the thresholds to compare incorrectly, potentially causing the backlight to flicker rapidly or lock at an extreme brightness.

**pwmbacklight.cpp — `brightness()` return value truncation**

At line 188, `ba.toUInt()` returns an `uint` but the function return type is `quint8`. If the sysfs brightness file contains a value greater than 255, the implicit truncation silently discards the upper bits. This is a minor data integrity issue.

**pwmbeeper.cpp — `m_count` signed/unsigned mismatch with potential infinite loop**

`m_count` is declared `qint16` (h:36). `beep(qint16 count, ...)` accepts a signed count. In `timeout()` at line 53, the decrement `--m_count` followed by `if (--m_count > 0)` is correct for positive values, but callers passing `count = 0` or a negative value will cause the decrement to wrap around (`qint16` wraps from -32768 to 32767 on underflow) and the beeper will continue indefinitely since `m_count` will never reach 0 from a large positive value. The `beep(quint16 milliseconds)` overload at line 84–87 calls `beep(1, milliseconds, 0)` with `count = 1` (safe), but the three-argument overload `beep(qint16 count, ...)` is public and can be called with 0 or negative values from any caller.

**Finding:**

**A14-1** · HIGH · Memory Safety
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/platform/powersupply.cpp:143`
**Description:** `readGaugeStatus()` indexes `args[0]` through `args[6]` on the result of `ba.split(',')` without first checking that `args.size() >= 7`. A sysfs read returning fewer than seven comma-separated fields — due to a driver error, partial read, or filesystem fault — will cause an out-of-bounds access on `QByteArrayList`. In a Qt release build, `QList::operator[]` does not bounds-check, producing undefined behaviour. On this embedded target (no ASLR, no stack protector per `.pro` file), this is a crash or memory-corruption vector in safety-critical power management code.

**A14-2** · MEDIUM · Memory Safety
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/platform/powersupply.cpp:160`
**Description:** The temperature calculation `(value - 2732) / 10` produces a negative `int` when `value` is less than 2732 (any sensor fault or zero return). Assigning this negative `int` to `quint16 m_temperature` wraps to a large positive value (e.g., -1 becomes 65535). This corrupted temperature value is emitted in the `batteryStatusRead` signal and may propagate into charge control decisions or UI alerts.

**A14-3** · MEDIUM · Memory Safety
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/platform/pwmbacklight.cpp:17`
**Description:** The `X1P1` and `X1P2` macros multiply an unclamped `int lux` value by 333 before bit-shifting. The lux value originates from `ba.toInt()` on sysfs data with no upper-bound clamp applied. If the sensor or a buggy driver returns a value above approximately 6,442,450, the multiplication overflows a signed 32-bit integer, producing a negative or wrapped threshold. This causes the brightness change logic in `parse()` to behave incorrectly, with potential for rapid backlight oscillation or lockout.

**A14-4** · LOW · Memory Safety
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/platform/pwmbeeper.cpp:53`
**Description:** `m_count` is `qint16` and is decremented in `timeout()` without validating that it was initially positive. Calling the public `beep(qint16 count, quint16 msecOn, quint16 msecOff)` with `count <= 0` causes the decrement to wrap a value of 0 to 32767 (signed 16-bit underflow), creating a near-infinite beep sequence that cannot be stopped without calling `stop()` explicitly. This is a resource exhaustion / device annoyance issue rather than a safety-critical crash, but the signed type should be validated at entry.

---

### 2. Communication Security

No network or communication logic is present in these three file pairs. All hardware interaction is via local sysfs/devfs paths.

Communication Security: no issues found.

---

### 3. Input Handling

**pwmbeeper.cpp — device file path controlled by environment variable without sanitisation**

At lines 19–23:
```cpp
QByteArray event = qgetenv("QT_BUZZER_EVENT");
if (!event.isEmpty())
    m_file.setFileName(QString::fromUtf8(event));
else
    m_file.setFileName(QStringLiteral(FILE_BEEPER));
```
The beeper device file path is taken directly from the `QT_BUZZER_EVENT` environment variable with no validation or sanitisation. On an embedded Linux device, environment variables can be set by any process with the same UID as the application (or by a parent process). An attacker or misconfigured process that can set this variable could redirect the beeper writes to an arbitrary device file or path, including `/dev/sda`, `/proc/sysrq-trigger`, or other sensitive device nodes. This is a path injection issue at the hardware access layer.

**powersupply.cpp — `QProcess::execute` with fixed arguments (no injection)**

`reboot()` at line 205 and `poweroff()` at line 211 call `QProcess::execute("/etc/pvd/reboot")` and `QProcess::execute("/etc/pvd/reboot -p")` respectively. These use literal string arguments with no user-controlled or network-received data in the command string, so there is no command injection vector here. However, see the Qt-Specific section for notes on `QProcess::execute` blocking the event loop.

**Finding:**

**A14-5** · HIGH · Input Handling
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/platform/pwmbeeper.cpp:19`
**Description:** The hardware device path used for beeper writes is read directly from the `QT_BUZZER_EVENT` environment variable and converted to a `QString` without any sanitisation, path prefix validation, or allowlist check. Any process or attacker that can set this environment variable before application launch can redirect the binary `input_event` structure writes to an arbitrary device file or path, potentially targeting sensitive device nodes such as `/proc/sysrq-trigger` or raw block devices. The environment variable should be ignored in production builds, or validated against a strict allowlist of permitted device paths.

---

### 4. Build Security

The `mk3.pro` file was reviewed. It contains no `-fstack-protector-strong`, no `-D_FORTIFY_SOURCE=2`, no `-fPIE`/`-pie`, and no `-Wformat -Wformat-security` flags. No `QMAKE_CXXFLAGS` security hardening entries are present at all.

**A14-6** · HIGH · Build Security
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/mk3.pro:1`
**Description:** The project file defines no compiler security hardening flags. Missing entirely: `-fstack-protector-strong` (stack overflow detection), `-D_FORTIFY_SOURCE=2` (standard library buffer overflow detection), `-fPIE`/`-pie` (position-independent executable for ASLR support), and `-Wformat -Wformat-security` (format string vulnerability detection). On an embedded device with direct hardware access, safety-critical charging logic, and no apparent OS-level hardening, the absence of these flags means that memory safety bugs (such as A14-1 above) have no compile-time or runtime mitigation.

---

### 5. Device and Firmware

**powersupply.cpp — `QProcess::execute` blocks the event loop during reboot/poweroff sequence**

`PowerSupply::reboot()` (line 205) and `PowerSupply::poweroff()` (line 211) use `QProcess::execute()`, which is a blocking call. The reboot script comment (lines 187–202) notes the script "costs around a couple seconds" and includes a `sleep` loop of up to 30 seconds waiting for `/dev/ttyUSB0` to disappear. Blocking `QProcess::execute()` during this time freezes the Qt event loop entirely. For a safety-critical proximity detection device, freezing the event loop means no proximity alerts, no UI updates, and no signal processing for the duration of the script. This is a safety-critical availability concern.

**powersupply.cpp — charge control logic based on unclamped gauge data**

At lines 148–151:
```cpp
if (m_voltage < 4100 || m_remainingCapacity < 99)
    charge(true);
else if (m_voltage > 4300 || m_remainingCapacity == 100)
    charge(false);
```
The `m_voltage` and `m_remainingCapacity` values come directly from the sysfs `show_regs` file, parsed without range validation. As noted in A14-1, if fewer fields than expected are returned, `m_voltage` retains its previous value or default (0), which is less than 4100 mV — causing `charge(true)` to be called unconditionally. Additionally, `m_remainingCapacity` is `quint16` but semantically a percentage (0–100); no clamping to 100 is enforced. A driver returning a value above 100 would cause neither charge-enable nor charge-disable condition to trigger from the capacity side, relying entirely on the voltage threshold.

**A14-7** · HIGH · Device and Firmware
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/platform/powersupply.cpp:205`
**Description:** Both `reboot()` and `poweroff()` call `QProcess::execute()`, which blocks the calling thread until the spawned script exits. The script comment indicates an up-to-30-second wait loop. During this period the Qt event loop is completely frozen: no proximity alerts can be processed, no BLE or CAN events are handled, and no UI updates occur. For a vehicle proximity detection device this represents a safety-critical availability gap — the device appears operational but is unresponsive during a safety-relevant transition.

**A14-8** · MEDIUM · Device and Firmware
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/platform/powersupply.cpp:148`
**Description:** Battery charge control decisions at lines 148–151 use `m_voltage` and `m_remainingCapacity` values that are populated by parsing sysfs gauge data without range validation. If the sysfs read returns fewer fields than expected (see A14-1), `m_voltage` defaults to 0 mV, unconditionally triggering `charge(true)`. Additionally, `m_remainingCapacity` is typed as `quint16` with no clamping to the valid 0–100% range; values above 100 returned by a faulty driver bypass the capacity-based charge-disable condition.

---

### 6. Qt-Specific Security

**powersupply.cpp — `QProcess::execute` with a string containing a space (shell argument splitting)**

At line 211:
```cpp
QProcess::execute("/etc/pvd/reboot -p");
```
`QProcess::execute(const QString &)` with a single string argument performs shell-style argument splitting: it splits the string on whitespace and treats the first token as the program and subsequent tokens as arguments. This is Qt's documented behaviour for this overload. The `-p` argument is a literal string, so there is no injection risk here. However, this overload is deprecated in Qt 5 and its argument-splitting behaviour is a known source of bugs when paths contain spaces. This is a code quality note.

**powersupply.cpp — `QProcess` include present but only `QProcess::execute` (static) is used**

`<QProcess>` is included (cpp:3) and two `QProcess::execute` calls exist. No `QProcess` instance is created and no process output is read. No shell metacharacter injection risk from user/network data. No issue beyond A14-7.

**pwmbacklight.h — include guard mismatch**

`pwmbacklight.h` opens with:
```cpp
#ifndef PWMBACKLIGHT_H
#define BRIGHTNESS_H
```
The `#ifndef` guard checks `PWMBACKLIGHT_H` but the `#define` defines `BRIGHTNESS_H`. These do not match: if `pwmbacklight.h` is included twice (directly and transitively), the `#ifndef PWMBACKLIGHT_H` guard will pass on the second inclusion because `PWMBACKLIGHT_H` was never defined, but `BRIGHTNESS_H` will already be defined, so the `#define BRIGHTNESS_H` line will be silently skipped. The net result is that the entire header will be re-processed on the second inclusion, causing duplicate class definition errors at compile time. This is a build correctness defect.

**A14-9** · LOW · Qt-Specific Security
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/platform/pwmbacklight.h:1`
**Description:** The include guard is mismatched: `#ifndef PWMBACKLIGHT_H` (line 1) guards entry but the macro defined is `BRIGHTNESS_H` (line 2), not `PWMBACKLIGHT_H`. This means the guard does not protect against double-inclusion: a second `#include "pwmbacklight.h"` in the same translation unit will re-enter the header (since `PWMBACKLIGHT_H` was never defined), causing a duplicate class definition compile error. While this is currently masked because the header is likely included only once per translation unit, it is a latent defect that will fail silently under refactoring.

**A14-10** · INFO · Qt-Specific Security
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/platform/powersupply.cpp:211`
**Description:** `QProcess::execute("/etc/pvd/reboot -p")` uses the single-string overload of `QProcess::execute` which performs internal whitespace-based argument splitting. This overload is deprecated in Qt 5.15+ in favour of the `(program, arguments)` form. No injection risk exists with the current literal string, but the use of this deprecated overload should be noted for maintainability.

---

## Summary of Findings

| ID | Severity | Category | Location |
|----|----------|----------|----------|
| A14-1 | HIGH | Memory Safety | powersupply.cpp:143 |
| A14-2 | MEDIUM | Memory Safety | powersupply.cpp:160 |
| A14-3 | MEDIUM | Memory Safety | pwmbacklight.cpp:17 |
| A14-4 | LOW | Memory Safety | pwmbeeper.cpp:53 |
| A14-5 | HIGH | Input Handling | pwmbeeper.cpp:19 |
| A14-6 | HIGH | Build Security | mk3.pro:1 |
| A14-7 | HIGH | Device and Firmware | powersupply.cpp:205 |
| A14-8 | MEDIUM | Device and Firmware | powersupply.cpp:148 |
| A14-9 | LOW | Qt-Specific Security | pwmbacklight.h:1 |
| A14-10 | INFO | Qt-Specific Security | powersupply.cpp:211 |
# A15 — Pass 1 Security Audit
**Files:** `platform/seriallogger.h`, `platform/seriallogger.cpp`, `platform/userport.h`, `platform/userport.cpp`
**Branch:** master
**Date:** 2026-02-28

---

## Reading Evidence

### File Pair 1: SerialLogger

**File paths:**
- `/c/Projects/cig-audit/repos/mark3-pvd/platform/seriallogger.h`
- `/c/Projects/cig-audit/repos/mark3-pvd/platform/seriallogger.cpp`

**Class name and base classes:**
- `SerialLogger` — no base class; plain C++ class (no QObject inheritance)

**Public methods (signature and line number):**
- `static void log(const QByteArray &message)` — seriallogger.h:9 / seriallogger.cpp:15
- `static void setSerialPort(EM070::UserPort *serial)` — seriallogger.h:10 / seriallogger.cpp:10

**Signals and slots:** None (class does not use Q_OBJECT)

**#include directives:**
- seriallogger.h:4 — `#include "userport.h"`
- seriallogger.cpp:1 — `#include "seriallogger.h"`
- seriallogger.cpp:2 — `#include <QDateTime>`
- seriallogger.cpp:3 — `#include <QFile>`

**Q_OBJECT macro:** Not present in either file.

**Log file paths and serial port paths defined:**
- `SERIAL_LOG_FILE` defined as `"/mnt/sd/sl.log"` at seriallogger.cpp:6
- `ENABLE_SL_FILE` defined as `0` at seriallogger.cpp:5 (file logging is compiled-in but disabled at runtime by preprocessor)

**Member variables:**
- `static EM070::UserPort *m_serial` — seriallogger.h:13 / seriallogger.cpp:8 (static, initialised to 0)

---

### File Pair 2: UserPort

**File paths:**
- `/c/Projects/cig-audit/repos/mark3-pvd/platform/userport.h`
- `/c/Projects/cig-audit/repos/mark3-pvd/platform/userport.cpp`

**Class name and base classes:**
- `EM070::UserPort` — inherits `QObject`

**Public methods (signature and line number):**
- `explicit UserPort(QObject *parent = nullptr)` — userport.h:15 / userport.cpp:15
- `void response(const QByteArray &ba)` — userport.h:16 / userport.cpp:78
- `void setBaudRate(QSerialPort::BaudRate baudRate)` — userport.h:18 / userport.cpp:88

**Signals:**
- `void cmdReceived(const QByteArray &ba)` — userport.h:21
  - Emitted from: userport.cpp:49 (TEST_MODE stdin path), userport.cpp:63 (serial port newline path)

**Slots:** None declared. `readData()` is a private method connected as a slot via `connect()` at userport.cpp:42.

**#include directives:**
- userport.h:4 — `#include <QObject>`
- userport.h:5 — `#include <QSerialPort>`
- userport.cpp:1 — `#include "userport.h"`
- userport.cpp:2 — `#include "app/globalconfigs.h"`
- userport.cpp:3 — `#include <QDebug>`
- userport.cpp:8 (TEST_MODE block) — `#include <QSocketNotifier>`
- userport.cpp:9 (TEST_MODE block) — `#include <iostream>`

**Q_OBJECT macro:** userport.h:13

**Log file paths and serial port paths defined:**
- `FILE_USER_PORT` defined as `"/dev/ttyS1"` at userport.cpp:5

**Member variables:**
- `QSerialPort *m_serialPort` — userport.h:26 (raw pointer, owned by QObject parent)
- `QByteArray m_receiver` — userport.h:27 (accumulation buffer for incoming serial data)

---

## Security Review

### 1. Memory Safety

**A15-1** · MEDIUM · Memory Safety
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/platform/userport.cpp:40`
**Description:** `m_receiver.reserve(256)` pre-allocates 256 bytes, but the buffer is grown unboundedly. In `readData()` (lines 58–75), every byte received that is not `\r`, `\n`, or `\b` is appended to `m_receiver` with `m_receiver += c` (line 73). There is no maximum size check before appending. A peer or attacker that sends a continuous stream of bytes without a newline terminator will cause `m_receiver` to grow without limit, consuming heap memory until the device crashes or the Qt allocator throws. On an embedded device with limited RAM this is a denial-of-service vulnerability. The `reserve(256)` call sets an initial capacity hint only; it does not enforce a cap on the `QByteArray` size.

**A15-2** · LOW · Memory Safety
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/platform/userport.cpp:10`
**Description:** `notifier` (TEST_MODE block, line 10) is declared as a raw file-scope pointer `QSocketNotifier *notifier` with no initialisation to `nullptr`. If `TEST_MODE` is compiled in and the `UserPort` constructor is called but `m_serialPort->open()` fails and returns early (line 34–37), the `notifier = new QSocketNotifier(...)` line (line 45) is never reached, leaving the pointer uninitialised. Any other TEST_MODE code that later reads `notifier` would access an indeterminate pointer. (The QObject parent mechanism would prevent the leak itself, but the uninitialised-pointer state is a latent hazard.)

### 2. Communication Security

**A15-3** · HIGH · Communication Security
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/platform/seriallogger.cpp:6` / `app/backgroundworker.cpp:2669` / `comm/modemchat.cpp:425,430`
**Description:** The serial logger writes sensitive device identifiers to the serial port (and optionally to a log file) unconditionally and permanently in production builds. Confirmed sensitive items logged by callers of `SerialLogger::log()` include:
- The device EUI (Extended Unique Identifier) at `backgroundworker.cpp:2669`: `"[RTC:INFO] Original EUI(Extended Unique Identifier) " + originalEuiAddress`
- The modem IMEI at `modemchat.cpp:425`: `"[MODEM:CGSN] IMEI=" + m_cgsn`
- The SIM ICCID at `modemchat.cpp:430`: `"[MODEM:ICCID] ICCID=" + m_iccid`

These are permanent device identifiers. Logging them to a user-accessible serial port exposes them to anyone with physical access to the RS-232 connector, and (if `ENABLE_SL_FILE` is ever enabled) persists them in plaintext on the SD card. IMEI and ICCID in particular are regulated identifiers that can facilitate SIM cloning or device tracking.

**A15-4** · MEDIUM · Communication Security
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/platform/seriallogger.cpp:18–29`
**Description:** The file logging path (`ENABLE_SL_FILE`) opens the log file at `/mnt/sd/sl.log` with `QFile::WriteOnly` and no rotation, size limit, or age limit. If this flag is enabled (it is currently `0` but is a compile-time switch that could be re-enabled for a field debug build), the log file will grow without bound for the lifetime of the device. On an embedded system with a fixed-size SD card, this is an unbounded disk consumption (DoS) vulnerability. Additionally, the file is opened with `WriteOnly` only — no explicit permission bits are set, meaning the file will be created with the process umask permissions, which may be world-readable.

**A15-5** · MEDIUM · Communication Security
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/platform/gnssreceiver.cpp:109,131`
**Description:** When `gCfg->GPSMsgLogEn()` returns true, raw GPGGA and GPRMC NMEA sentences are forwarded to `SerialLogger::log()` and consequently to the serial port. GPGGA contains latitude, longitude, altitude, fix quality, and satellite count. GPRMC contains latitude, longitude, speed, and course. This is a continuous stream of precise location data being output on a user-accessible port. The logging is gated by a configuration flag, but if that flag is set in a deployed configuration the device leaks real-time location to anyone monitoring the serial port.

### 3. Input Handling

**A15-6** · HIGH · Input Handling
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/platform/seriallogger.cpp:17`
**Description:** Log injection via newline characters in the `msg` argument. The `log()` function prepends a timestamp and passes the result directly to `m_serial->response(ba)` without sanitising the content of `msg`. All callers pass messages that are largely static strings or controlled numeric values, but several callers pass data originating from external sources — notably `modemchat.cpp:488` logs raw modem AT command response data (`ba`) from `[MODEM:CGDCONT?]`, and `bleexpansion.cpp:392–416` / `canexpansion.cpp:274–316` log device name, BLE version, firmware version, manufacturer, and model strings read from peripheral hardware. If any of these external strings contain `\r\n` sequences, they will inject spurious log lines that could confuse a human reading the serial log or a log parser, potentially causing misattribution of log entries (log forging). There is no stripping of embedded newlines from logged external data anywhere in the pipeline.

**A15-7** · LOW · Input Handling
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/platform/userport.cpp:18–20`
**Description:** The serial port device name is read from the environment variable `QT_USER_SERIAL_PORT` via `qgetenv()` and used directly to set the serial port name via `m_serialPort->setPortName(QString::fromUtf8(portName))`. No validation is performed on the value — it is not checked for path-traversal characters, excessive length, or valid device name format. On a desktop or test host this could be used to redirect the port to an arbitrary device path. On the production embedded target this is lower risk as environment variables are set by the system, but it is nonetheless unvalidated external input used to select a device resource.

### 4. Build Security

**A15-8** · MEDIUM · Build Security
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/mk3.pro`
**Description:** The `.pro` file defines no compiler security hardening flags. The following flags are absent:
- `-fstack-protector-strong` — no stack buffer overflow protection
- `-D_FORTIFY_SOURCE=2` — no standard library buffer overflow detection
- `-fPIE` / `-pie` — no position-independent executable (ASLR support)
- `-Wformat -Wformat-security` — no compile-time format string vulnerability detection

On an embedded ARM device running Linux, the absence of `-fstack-protector-strong` and `-D_FORTIFY_SOURCE=2` means that stack smashing and several classes of buffer overflows will not be caught at runtime. Given that this is a safety-critical proximity detection device, the lack of these mitigations is a meaningful risk.

**A15-9** · LOW · Build Security
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/platform/userport.cpp:7–11` and `/c/Projects/cig-audit/repos/mark3-pvd/mk3.pro:6`
**Description:** `TEST_MODE` is controlled by `DEFINES += "TEST_MODE=0"` in `mk3.pro`. When `TEST_MODE=1`, a `QSocketNotifier` on stdin is created that reads from standard input and emits `cmdReceived` — effectively a backdoor command interface via stdin. The `response()` function also calls `qDebug("%s", ba.constData())` in TEST_MODE. While TEST_MODE is currently set to 0 in the production `.pro` file, the mechanism exists in production source and would be enabled by a single `.pro` edit or a build override. There is no build-time guard to prevent accidental or deliberate TEST_MODE=1 production builds (e.g. no `static_assert` or `#error` in a release configuration).

### 5. Device and Firmware

**A15-10** · MEDIUM · Device and Firmware
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/platform/seriallogger.cpp:5–6`
**Description:** `ENABLE_SL_FILE` is a preprocessor `#define` set to `0`. This is a compile-time toggle, not a runtime configuration or a build-configuration flag passed via the `.pro` file's `DEFINES`. A developer can enable file-based logging of all serial log output (including IMEI, ICCID, EUI, GPS coordinates, modem state, proximity events) simply by changing this single line in the source file. Because the flag is in a `.cpp` file rather than governed by a build profile (e.g., `CONFIG(debug, debug|release)`), there is no structural barrier to accidentally shipping a firmware build with file logging enabled. The `/mnt/sd/sl.log` path on the SD card would then accumulate all sensitive log data in plaintext on removable media.

**A15-11** · INFO · Device and Firmware
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/platform/userport.cpp:5`
**Description:** The production serial port device path `/dev/ttyS1` is hardcoded via `FILE_USER_PORT`. This is consistent with a fixed embedded hardware platform, but it means that if the hardware UART assignment ever changes, a source code change and firmware rebuild is required. This is an observation rather than a finding, but it is noted for completeness.

### 6. Qt-Specific Security

**A15-12** · LOW · Qt-Specific Security
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/platform/userport.cpp:56`
**Description:** `m_serialPort->readAll()` is called in `readData()` with no size limit. `QSerialPort::readAll()` reads all available bytes in the OS receive buffer in a single call. On a serial port this is generally bounded by the OS buffer size, but combined with the unbounded `m_receiver` accumulation identified in A15-1, a connected device sending data faster than it is consumed could result in large allocations in both the OS buffer and `m_receiver`. This is a Qt-specific manifestation of the unbounded buffer issue.

**A15-13** · INFO · Qt-Specific Security
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/platform/userport.cpp:83–85`
**Description:** In TEST_MODE, `response()` calls `qDebug("%s", ba.constData())`. The format string is a literal `"%s"` — this is the correct safe form. No format string vulnerability is present here. Noted for completeness: if this were `qDebug(ba.constData())` it would be a format string vulnerability, but the literal format string is used correctly.
# Pass 1 Audit — A16
**Auditor:** A16
**Date:** 2026-02-28
**Branch:** master (verified)
**Repository:** mark3-pvd

---

## Step 4 — Reading Evidence

### File Pair 1: wiegandrfid.h / wiegandrfid.cpp

**File paths:**
- `/c/Projects/cig-audit/repos/mark3-pvd/platform/wiegandrfid.h`
- `/c/Projects/cig-audit/repos/mark3-pvd/platform/wiegandrfid.cpp`

**Class name and base classes:**
- `EM070::WiegandRfid` — inherits `QObject`

**Q_OBJECT macro location:**
- `wiegandrfid.h` line 12

**Every public method (signature and line number):**
- `explicit WiegandRfid(QObject *parent = 0)` — constructor, `.h` line 14 / `.cpp` line 11
- `void setEnabled(bool enable)` — `.h` line 15 / `.cpp` line 106
- `static quint64 wiegandData(quint8 facility, quint32 number)` — `.h` line 17 / `.cpp` line 111

**Signals:**
- `void cardData(quint64 wiegand, quint16 facility, quint32 number, QByteArray &readerOutput)` — `.h` line 20
- `void error(const QString &text)` — `.h` line 21

**Slots:**
- None declared explicitly; `activated()` is a private method connected via signal in constructor.

**Private methods:**
- `void activated()` — `.h` line 24 / `.cpp` line 24

**Member variables:**
- `QFile m_cardReadyFile` — `.h` line 26
- `QSocketNotifier *m_notifier` — `.h` line 27

**#include directives (wiegandrfid.h):**
- `<QFile>`

**#include directives (wiegandrfid.cpp):**
- `"wiegandrfid.h"`
- `<QSocketNotifier>`
- `<QDebug>`

**Wiegand protocol constants:**
- `FILE_CARD_READY` = `/sys/devices/platform/wiegand-gpio.0/card_ready` — `.cpp` line 5
- `FILE_CARD_DATA`  = `/sys/devices/platform/wiegand-gpio.0/card_data` — `.cpp` line 6
- `FILE_RAW_DATA`   = `/sys/devices/platform/wiegand-gpio.0/raw_data` — `.cpp` line 7
- 34-bit format handled at `.cpp` line 67 (bit strip: `~((quint64)1<<33)`, right-shift 1)
- 37-bit format commented out at `.cpp` lines 83–96 (strip bit 36, shift 1)
- 26-bit lower bound check at `.cpp` line 98 (`bits >= 26`)
- Wiegand-26 parity logic (12-bit even leading, 12-bit odd trailing) at `.cpp` lines 145–162
- Wiegand-42 format for `number > 65535` at `.cpp` lines 131–140

---

### File Pair 2: wifi.h / wifi.cpp

**File paths:**
- `/c/Projects/cig-audit/repos/mark3-pvd/platform/wifi.h`
- `/c/Projects/cig-audit/repos/mark3-pvd/platform/wifi.cpp`

**Class name and base classes:**
- `EM070::Wifi` — inherits `QObject`

**Q_OBJECT macro location:**
- `wifi.h` line 23

**Every public method (signature and line number):**
- `explicit Wifi(EM070::UserPort *userPort)` — `.h` line 26 / `.cpp` line 16
- `~Wifi()` — `.h` line 27 (inline empty)
- `void writeConf()` — `.h` line 29 / `.cpp` line 46
- `void restart()` — `.h` line 30 / `.cpp` line 82
- `bool status()` — `.h` line 32 (inline)
- `bool startPositioning()` — `.h` line 34 / `.cpp` line 191
- `void parseResponse(const QByteArray &ba)` — `.h` line 36 / `.cpp` line 211
- `QList<CIGCONF::AccessPoint> accessPoints()` — `.h` line 38 (inline)
- `void setCellularState(bool state)` — `.h` line 40 / `.cpp` line 146
- `void setPowerState(CIGCONF::PowerState state)` — `.h` line 42 / `.cpp` line 297

**Signals:**
- `void ethernetStateChanged(bool ready)` — `.h` line 46
- `void wifiReconnectionFailed()` — `.h` line 47
- `void wifiScanFinished(QList<CIGCONF::AccessPoint> list)` — `.h` line 48

**Private methods:**
- `void attemptReconnectToWifi()` — `.h` line 51 / `.cpp` line 153
- `void checkStatus()` — `.h` line 52 / `.cpp` line 96
- `void scanAccessPoints()` — `.h` line 53 / `.cpp` line 250
- `void scanFinished(int exitCode, QProcess::ExitStatus exitStatus)` — `.h` line 54 / `.cpp` line 266

**Member variables:**
- `EM070::UserPort *m_userPort` — `.h` line 56
- `QNetworkConfigurationManager *m_configurationManager` — `.h` line 58
- `bool m_status` — `.h` line 59
- `bool m_wifiStatus` — `.h` line 60
- `bool m_cellularStatus` — `.h` line 61
- `QTimer *m_posTimer` — `.h` line 63
- `QTimer *m_reconnectTimer` — `.h` line 64
- `QProcess *m_ps` — `.h` line 66
- `QList<CIGCONF::AccessPoint> m_accessPoints` — `.h` line 68
- `CIGCONF::PowerState m_powerState` — `.h` line 69

**#include directives (wifi.h):**
- `"../app/cigconfigs.h"`
- `<QObject>`
- `<QByteArray>`
- `<QList>` (twice)
- `<QProcess>`
- `<QNetworkConfigurationManager>`
- `<QTimer>`

**#include directives (wifi.cpp):**
- `"wifi.h"`
- `"seriallogger.h"`
- `"platform/userport.h"`
- `"../app/globalconfigs.h"`
- `<QDebug>`
- `<QSaveFile>`
- `<QNetworkConfiguration>`
- `<QTextStream>`

**WiFi configuration parameters (from wifi.cpp and cigconfigs.h):**
- `WIFI_CONF_FILE` = `/etc/wpa_supplicant.conf` — `cigconfigs.h` line 57
- `WIFI_MAX_NETWORKS` = 10 — `cigconfigs.h` line 56
- `SCAN_WATCHDOG` = 300000 ms — `wifi.cpp` line 13
- `RECONNECT_TIMEOUT` = 210000 ms — `wifi.cpp` line 14
- Password length validation: empty / < 8 / > 63 triggers `key_mgmt=NONE` — `wifi.cpp` lines 65–68
- Password in range [8,63] writes `psk=` in plaintext — `wifi.cpp` lines 70–74

**Related configuration file:**
- `netcfg.json` (listed in `mk3.qrc` and `mk3.pro` DISTFILES) contains `"ssid": "cigSecureConnect"` and `"password": "P@ssMK3!"`. It is embedded in the Qt resource bundle at compile time but is not read by wifi.cpp; no source code reference to `netcfg.json` was found in any `.cpp` or `.h` file. The file is committed to git history.

---

## Step 5 — Security Review

### 1. Memory Safety

**wiegandrfid.cpp — `bas.first()` / `bas.last()` called without empty-list guard:**
`activated()` reads a line from a kernel sysfs file, splits it on `,`, and immediately calls `bas.first()` (line 45) and `bas.last()` (line 46) without checking that the resulting list is non-empty. If the sysfs file returns a blank line or a line with no comma, `QByteArrayList::first()` and `last()` on an empty list are undefined behaviour in older Qt versions and cause an assertion failure / crash in debug builds. The same pattern repeats at lines 63–64. This is sourced from a kernel driver sysfs interface, so the data is not directly attacker-controlled, but a malfunctioning or emulated device could present malformed input.

**wiegandrfid.cpp — `quint16 facility` type truncation (line 45):**
`bas.first().toUInt()` returns an unsigned int (up to 32 bits). The result is stored in `quint16 facility`. If the card data value exceeds 65535, silent truncation occurs before being passed to `wiegandData()` whose parameter is `quint8`, producing a second truncation. Neither truncation is checked or flagged.

**wiegandrfid.cpp — `number` parameter narrowed from `quint32` to `quint8` in `wiegandData` call:**
`wiegandData(facility, number)` is declared as `wiegandData(quint8 facility, quint32 number)`. At line 45, `facility` is stored as `quint16` and then passed as a `quint8` parameter — a narrowing implicit conversion with no explicit check, silent data loss if facility > 255.

**No raw `new` without RAII issues identified** — `m_notifier` is parented to `this` (Qt ownership).

### 2. Communication Security

**wifi.cpp — WiFi plaintext credential storage in wpa_supplicant.conf:**
`writeConf()` (lines 46–80) writes the PSK for each configured network as a plaintext string (`psk="<password>"`) directly into `/etc/wpa_supplicant.conf`. The wpa_supplicant.conf format supports hashed PSK (a 256-bit hex string produced by `wpa_passphrase`). Writing the plaintext passphrase means the credential is readable by any process with filesystem access to `/etc/wpa_supplicant.conf`.

**wifi.cpp — Open network accepted without operator warning:**
`writeConf()` at lines 65–68 silently falls through to `key_mgmt=NONE` (no encryption, open network) whenever the configured password is empty, shorter than 8 characters, or longer than 63 characters. There is no log entry, no user warning, and no refusal to connect. A misconfigured or blank password causes the device to connect to an open network without any security. This is not a "graceful fallback" — it is a silent security downgrade.

**wifi.cpp — `netcfg.json` credentials committed to version control:**
The file `netcfg.json` at the repository root contains a plaintext WiFi SSID (`cigSecureConnect`) and password (`P@ssMK3!`). The file is tracked by git (committed in at least two historical commits) and is bundled into the Qt resource file (`mk3.qrc` line 29), meaning the credential is compiled into the firmware binary. Even if the credential represents a provisioning network that is rotated post-deployment, committing it to the repository exposes it to all repository collaborators and any CI/CD system with repo access.

**wifi.cpp — No TLS configuration present:**
The `Wifi` class uses `QNetworkConfigurationManager` for network state monitoring only. There is no `QNetworkAccessManager`, `QSslSocket`, or TLS setup visible in these files. TLS configuration for outbound connections is handled elsewhere in the codebase (e.g., `gmtpchat.cpp`). No `QSslSocket::setPeerVerifyMode(QSslSocket::VerifyNone)` was found in `wifi.cpp` or `wiegandrfid.cpp`.

### 3. Input Handling

**wifi.cpp — Unvalidated PID from filesystem used in shell kill command (line 165–167):**
In `attemptReconnectToWifi()`, the content of `/var/run/dhcp_wlan0_pid` is read with `readAll()`, trimmed, and inserted directly into a `kill` command string using `QString::arg()`:
```cpp
QString pid = dhcpPidFile.readAll().trimmed();
QProcess::startDetached(QString("kill -USR2 %1").arg(pid));
```
There is no validation that `pid` contains only digits. If the PID file contains a value such as `1; rm -rf /home` (possible if the PID file path is writable by an attacker or if a symlink attack is feasible), the shell would execute the injected command because `QProcess::startDetached` with a single string argument invokes the shell. However, the actual risk depends on filesystem permissions for `/var/run/dhcp_wlan0_pid` on the embedded Linux target.

**wifi.cpp — Shell meta-character injection in `scanAccessPoints()` (line 261):**
`m_ps->start("/bin/sh -c \"iw wlan0 scan | grep ...\"")` passes a shell command as a single string to `QProcess::start()`. The interface name `wlan0` is hardcoded so no injection is possible here, but using `/bin/sh -c` with a composite string is a pattern that is unsafe if any variable portion is ever introduced.

**wiegandrfid.cpp — Wiegand card data logged via qDebug without sanitisation (lines 42, 60, 74, 99):**
Raw card data (facility code and card number) is emitted to debug output. In a production build where `QT_NO_DEBUG_OUTPUT` is not defined, this exposes credential data (card numbers) via the debug channel. See Build Security section.

**wiegandrfid.cpp — Empty `bas` list not checked before `.first()` / `.last()` (lines 45–46, 63–64):**
See Memory Safety section. In the input handling context: if the kernel sysfs driver returns an unexpected format (no comma, empty string), the split produces a one-element list where `first()` and `last()` return the same element, leading to `facility == number`, which then fails the `if (facility && number)` gate at line 47. This is a silent misparse rather than a crash in the one-element case, but the zero-element case remains unsafe.

### 4. Build Security

**mk3.pro — No security compiler flags present:**
The `mk3.pro` file contains no `-fstack-protector-strong`, `-D_FORTIFY_SOURCE=2`, `-fPIE`/`-pie`, or `-Wformat -Wformat-security` flags. The `DEFINES` block contains only `TEST_MODE=0` and `QT_DEPRECATED_WARNINGS`. No `-w` suppression flag is present (positive finding). No `QMAKE_STRIP` or explicit `CONFIG += release` stripping configuration was found, meaning debug symbols may be present in production firmware builds.

**wiegandrfid.cpp — Sensitive data in qDebug output (lines 42, 60, 74, 99):**
Card facility codes and card numbers are printed via `qDebug()`. Unless `QT_NO_DEBUG_OUTPUT` is defined at compile time for production builds (which is not enforced in `mk3.pro`), these statements will execute in firmware and expose credential data via any accessible debug console or serial logger.

### 5. Device and Firmware

**netcfg.json — WiFi credentials committed to git and compiled into firmware:**
`netcfg.json` contains plaintext credentials (`"password": "P@ssMK3!"`, `"ssid": "cigSecureConnect"`) and is included in `mk3.qrc`, causing it to be compiled directly into the firmware binary as a Qt resource. The file is tracked in git history (commits `5fdc821`, `2adcd83`). Any party with repository access can extract the credential. Any party with access to the firmware binary can extract it using `strings` or Qt resource extraction tools. This is a provisioning or default network credential that should not be in version control or compiled into firmware.

**wiegandrfid.cpp — No authentication on Wiegand protocol:**
Wiegand is an unencrypted, unauthenticated protocol. Card UIDs (facility + number, or raw 26/34/37-bit data) are transmitted in cleartext on the wire and are trivially cloneable with commodity RFID hardware (e.g., Proxmark, HID cloners). The `cardData` signal produced by `WiegandRfid::activated()` flows directly to `Dialog::onCardSwiped()`, which calls `login(wiegand)`, and the Wiegand data value is the sole credential used to authenticate a driver or supervisor (`containsDriverId`, `containsMasterId`, `containsSuperId`). There is no secondary factor, no replay protection, and no challenge-response. Any Wiegand card cloner can impersonate any enrolled user.

### 6. Qt-Specific Security

**wifi.cpp — QProcess used with shell invocation for scan command (line 261):**
`m_ps->start("/bin/sh -c \"iw wlan0 scan | grep ...\"")` starts a shell subprocess. Using `QProcess::start()` with a single string causes Qt to invoke the system shell (`/bin/sh -c`) to parse the command. The safer pattern is `QProcess::start(program, QStringList args)` which avoids shell interpretation entirely. As currently written, any future modification that introduces variable input into this command string would create a shell injection vulnerability.

**wifi.cpp — QProcess::startDetached used with dynamically-constructed command strings (lines 90, 92, 166, 167):**
`QProcess::startDetached(QString(...).arg(pid))` and `QProcess::startDetached("killall -SIGHUP wpa_supplicant")` are called with single-string arguments, meaning they execute via the shell. The `pid` value at lines 166–167 is read from a file and not validated before insertion into the command string. See Input Handling finding above.

**wifi.cpp — No QSslSocket or QNetworkAccessManager TLS configuration in these files:**
`QSslSocket::setPeerVerifyMode(QSslSocket::VerifyNone)` is not present in `wifi.cpp` or `wiegandrfid.cpp`. No TLS disabling was observed in the assigned files.

---

## Findings

**A16-1** · CRITICAL · Device and Firmware
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/netcfg.json:2`
**Description:** The file `netcfg.json` contains a plaintext WiFi password (`P@ssMK3!`) and SSID (`cigSecureConnect`) committed to the git repository and compiled into the firmware binary via `mk3.qrc`. The credential appears in at least two git commits (`5fdc821`, `2adcd83`) and is permanently in repository history. Any person with repository read access or access to a firmware binary can extract the credential using `strings` or Qt resource tools. Provisioning credentials must not be committed to version control or baked into firmware; they should be injected at device provisioning time and stored in a protected location on the device.

**A16-2** · HIGH · Communication Security
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/platform/wifi.cpp:65`
**Description:** `writeConf()` silently writes `key_mgmt=NONE` (open/unencrypted network) to the wpa_supplicant configuration whenever the configured WiFi password is empty, shorter than 8 characters, or longer than 63 characters. There is no user-visible warning, no log entry via `SerialLogger`, and no refusal to configure the network. This means a device with a blank or short WiFi password will silently connect to an open network without encryption, exposing all WiFi traffic to passive interception. WPA2 or WPA3 should be enforced as a minimum, with a configuration rejection or explicit operator acknowledgment required for open-network connections.

**A16-3** · HIGH · Communication Security
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/platform/wifi.cpp:73`
**Description:** `writeConf()` writes WiFi passphrases as plaintext strings (`psk="<password>"`) in `/etc/wpa_supplicant.conf`. The wpa_supplicant configuration format supports a pre-computed 256-bit hex PSK (as produced by the `wpa_passphrase` tool), which avoids storing the cleartext passphrase on the filesystem. Writing plaintext credentials means they are readable by any process with access to the configuration file and are visible in any filesystem dump or backup.

**A16-4** · HIGH · Device and Firmware
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/platform/wiegandrfid.cpp:24`
**Description:** Wiegand is a legacy unencrypted, unauthenticated protocol. The raw card UID (facility code and card number, or a 26/34-bit value) transmitted over Wiegand is trivially cloneable with commodity RFID hardware. The `cardData` signal from `WiegandRfid::activated()` flows directly to `Dialog::login()` where the Wiegand value is the sole credential used to authenticate drivers and supervisors against the enrolled ID lists (`containsDriverId`, `containsMasterId`, `containsSuperId`). No secondary authentication factor, no replay protection, and no challenge-response mechanism is present. An attacker with a Wiegand cloner can read any enrolled card at close range and replay it to gain vehicle access or supervisor privileges.

**A16-5** · MEDIUM · Input Handling
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/platform/wifi.cpp:165`
**Description:** In `attemptReconnectToWifi()`, the content of `/var/run/dhcp_wlan0_pid` is read with `readAll().trimmed()` and inserted without validation into shell `kill` commands via `QProcess::startDetached(QString("kill -USR2 %1").arg(pid))`. No check is performed to verify that the content is a numeric PID. If the PID file is writable by a lower-privileged process or subject to a symlink attack, an attacker could inject arbitrary shell arguments. `QProcess::startDetached()` with a single string argument invokes the system shell, making injection possible. The PID value should be validated to contain only digits before use, and the `QProcess::startDetached(program, args)` overload should be used to avoid shell interpretation.

**A16-6** · MEDIUM · Memory Safety
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/platform/wiegandrfid.cpp:45`
**Description:** `activated()` splits the sysfs card data line on `,` (line 43) and immediately calls `bas.first()` (line 45) and `bas.last()` (line 46) without verifying the list is non-empty. The same pattern occurs at lines 63–64 for raw card data. If the kernel driver returns a blank line, an empty file, or a line containing no comma, `QByteArrayList::first()` / `last()` on an empty list is undefined behaviour. While the sysfs interface is kernel-controlled, a malfunctioning driver or emulated hardware could trigger this path. A guard checking `bas.size() >= 2` (or at minimum `!bas.isEmpty()`) is required before accessing list elements.

**A16-7** · MEDIUM · Input Handling
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/platform/wifi.cpp:261`
**Description:** `scanAccessPoints()` starts a WiFi scan by passing a single composite shell command string to `QProcess::start()`: `m_ps->start("/bin/sh -c \"iw wlan0 scan | grep ...\"")`. This invokes `/bin/sh` to interpret the command string. Although no variable input is currently interpolated into the command, this pattern is inherently unsafe: any future change that introduces a variable (e.g., a configurable interface name) would create a shell command injection vulnerability. The preferred pattern is `QProcess::start(program, QStringList{"-c", command})` which keeps the argument as a single shell string without further shell expansion, or better, use the argument-list overload of `QProcess::start` with a fixed program and arguments.

**A16-8** · MEDIUM · Build Security
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/mk3.pro:1`
**Description:** The project file contains no security-hardening compiler flags: `-fstack-protector-strong`, `-D_FORTIFY_SOURCE=2`, `-fPIE`/`-pie`, or `-Wformat -Wformat-security` are all absent. On an embedded Linux ARM target, the absence of stack canaries (`-fstack-protector-strong`) means stack buffer overflows will not be detected at runtime. The absence of `-D_FORTIFY_SOURCE=2` removes compile-time and runtime bounds checking for standard library buffer functions. These flags should be added to the `QMAKE_CXXFLAGS` and `QMAKE_LFLAGS` in `mk3.pro`.

**A16-9** · LOW · Build Security
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/platform/wiegandrfid.cpp:42`
**Description:** `activated()` emits raw card data (card number, facility code) via `qDebug()` at lines 42, 60, 74, and 99. The `mk3.pro` file does not define `QT_NO_DEBUG_OUTPUT` or enforce `CONFIG += release` to suppress debug output. In a production firmware build where debug output is not suppressed, card credential data is written to the debug channel, which may be accessible via the serial console (`seriallogger.cpp` is present in the build). Card numbers should not appear in production logs.

**A16-10** · LOW · Memory Safety
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/platform/wiegandrfid.cpp:45`
**Description:** `bas.first().toUInt()` returns an unsigned int, which is stored in `quint16 facility` (line 45), then passed to `wiegandData(quint8 facility, quint32 number)` where it is implicitly narrowed again to `quint8`. Facility codes above 255 are silently truncated without any check or log entry. Similarly, the `quint16 facility` variable at line 45 is declared to hold a facility value, but the signal `cardData` emits it as `quint16` (line 20), while `wiegandData` accepts only `quint8`. These silent truncations could cause enrolled card IDs to be mismatched in edge cases with high facility codes, potentially either denying access to valid cards or — depending on how IDs are compared — matching a different enrolled card.
# Pass 1 Security Audit — A17
**Repository:** mark3-pvd
**Branch:** master
**Date:** 2026-02-28
**Auditor:** A17

---

## Step 1 — Branch Verification

`git rev-parse --abbrev-ref HEAD` returned: `master`. Confirmed correct branch.

---

## Step 4 — Reading Evidence

### File Set 1: AmberImpactAlertDialog

**File paths:**
- `/c/Projects/cig-audit/repos/mark3-pvd/ui/amberimpactalertdialog.h`
- `/c/Projects/cig-audit/repos/mark3-pvd/ui/amberimpactalertdialog.cpp`
- `/c/Projects/cig-audit/repos/mark3-pvd/ui/amberimpactalertdialog.ui`

**Class name and base classes:**
- `AmberImpactAlertDialog : public QDialog`

**Q_OBJECT macro location:**
- `amberimpactalertdialog.h` line 12

**Public methods (with line numbers):**
- `explicit AmberImpactAlertDialog(QWidget *parent = nullptr)` — .h line 15 / .cpp line 6
- `~AmberImpactAlertDialog()` — .h line 16 / .cpp line 14
- `bool isOpen() const` — .h line 18 / .cpp line 49
- `void closeWindow()` — .h line 19 / .cpp line 31
- `void languageChanged()` — .h line 20 / .cpp line 19

**Signals:** none declared

**Slots:**
- `void amberAlertDialogShowEvent(bool isLocked)` — .h line 23 (public slot) / .cpp line 54

**Protected methods:**
- `void mouseReleaseEvent(QMouseEvent *)` — .h line 26 / .cpp line 25
- `void showEvent(QShowEvent *event = 0)` — .h line 27 / .cpp line 39

**#include directives:**
- `.h`: `<QDialog>`
- `.cpp`: `"amberimpactalertdialog.h"`, `"ui_amberimpactalertdialog.h"`, `"app/globalconfigs.h"`, `<QDebug>`

**Member variables:**
- `Ui::AmberImpactAlertDialog *ui` (private, line 30 .h)
- `bool dialogOpenFlag` (private, line 31 .h)

**UI widgets (amberimpactalertdialog.ui):**
- `AmberImpactAlertDialog` — QDialog, 800x480
- `labelWarning` — QLabel (displays warning.png pixmap)
- `labelTip` — QLabel (displays "Amber shock impact detected. Kindly acknowledge by tapping the screen.")
- `label_3` — QLabel (displays "Amber Impact Alert")

---

### File Set 2: AuthorisedDialog

**File paths:**
- `/c/Projects/cig-audit/repos/mark3-pvd/ui/authoriseddialog.h`
- `/c/Projects/cig-audit/repos/mark3-pvd/ui/authoriseddialog.cpp`
- `/c/Projects/cig-audit/repos/mark3-pvd/ui/authoriseddialog.ui`

**Class name and base classes:**
- `AuthorisedDialog : public QDialog`

**Q_OBJECT macro location:**
- `authoriseddialog.h` line 14

**Public methods (with line numbers):**
- `explicit AuthorisedDialog(QWidget *parent = 0)` — .h line 17 / .cpp line 13
- `~AuthorisedDialog()` — .h line 18 / .cpp line 44
- `void setHasChecklist(bool yes)` — .h line 19 / .cpp line 56
- `void setDriverId(quint64 id)` — .h line 20 / .cpp line 67
- `void setTime(const QString s)` — .h line 21 / .cpp line 178
- `void setPower(bool on)` — .h line 22 / .cpp line 211
- `void updateCamera()` — .h line 23 / .cpp line 217

**Signals:**
- `void userLogout()` — .h line 30

**Protected methods:**
- `void showEvent(QShowEvent *)` — .h line 33 / .cpp line 71
- `void hideEvent(QHideEvent *)` — .h line 34 / .cpp line 113

**Private methods:**
- `bool debounce()` — .h line 43 / .cpp line 148
- `void screensaverOff()` — .h line 44 / .cpp line 120
- `void screensaverPressed()` — .h line 45 / .cpp line 138
- `void onButtonConfirmStart()` — .h line 46 / .cpp line 50
- `void screensaverOn()` — .h line 47 / .cpp line 130
- `void setCamera(bool on, bool flip)` — .h line 48 / .cpp line 188

**Private slots:**
- `void rstLogout()` — .h line 54 / .cpp line 172
- `void onLogoutRequest()` — .h line 55 / .cpp line 156

**#include directives:**
- `.h`: `<QDialog>`
- `.cpp`: `"app/globalconfigs.h"`, `"authoriseddialog.h"`, `"ui_authoriseddialog.h"`, `"ui/optionalcheckconfirmationdialog.h"`, `<QMouseEvent>`, `<QTimer>`, `"app/driverlist.h"`, `<QDebug>`, `<QFile>`

**Member variables:**
- `bool m_waking` (private, .h line 37)
- `Ui::AuthorisedDialog *ui` (private, .h line 38)
- `OptionalCheckConfirmationDialog *m_optionalCheckConfirmationDialog` (private, .h line 39)
- `QTimer *m_resetTimer` (private, .h line 40)
- `quint32 m_lastPress` (private, .h line 41)
- `quint64 m_pendingDriverId` (private, .h line 42)
- `bool m_showCamera` (private, .h line 50)
- `bool m_power` (private, .h line 51)

**Conditional compilation:**
- `#ifdef UNIT_TEST` — `friend class TestDialog` declared at .h lines 25-27

**UI widgets (authoriseddialog.ui):**
- `AuthorisedDialog` — QDialog, 800x480
- `labelUpper` — QLabel (background panel, no text)
- `labelBelow` — QLabel (background panel, no text)
- `label` — QLabel (displays authorised.png pixmap)
- `label_2` — QLabel (displays "Cool! You are in.")
- `label_3` — QLabel (displays "You are authorised to operate this vehicle")
- `btnStart` — QPushButton (optional pre-op check trigger)
- `labelStart` — QLabel (displays "Optional pre-op check")
- `btnScreensaver` — QPushButton (full-screen screensaver overlay)
- `btnLogout` — QPushButton (logout button)
- `lblDriverName` — QLabel (displays driver name if `showDriverName` enabled)
- `labelTime` — QLabel (displays current time)

---

### File Set 3: BroadcastUIDialog

**File paths:**
- `/c/Projects/cig-audit/repos/mark3-pvd/ui/broadcastuidialog.h`
- `/c/Projects/cig-audit/repos/mark3-pvd/ui/broadcastuidialog.cpp`
- `/c/Projects/cig-audit/repos/mark3-pvd/ui/broadcastuidialog.ui`

**Class name and base classes:**
- `BroadcastUIDialog : public QDialog`

**Q_OBJECT macro location:**
- `broadcastuidialog.h` line 14

**Public enum:**
- `enum MessageResult {MsgResultOK, MsgResultYes, MsgResultNo, MsgResultTimeout, MsgResultLogout, MsgResultNoDriver}` — .h line 17

**Public methods (with line numbers):**
- `explicit BroadcastUIDialog(QWidget *parent = nullptr)` — .h line 19 / .cpp line 4
- `~BroadcastUIDialog()` — .h line 20 / .cpp line 19
- `void setUIParam(CIGCONF::BroadcastMessage m)` — .h line 22 / .cpp line 24

**Signals:**
- `void messageClosed(CIGCONF::BroadcastMessage m)` — .h line 25

**Private slots:**
- `void onYes()` — .h line 32 / .cpp line 48
- `void onNo()` — .h line 33 / .cpp line 54
- `void onOK()` — .h line 34 / .cpp line 60

**#include directives:**
- `.h`: `"app/cigconfigs.h"`, `<QDialog>`, `<QTimer>`
- `.cpp`: `"broadcastuidialog.h"`, `"ui_broadcastuidialog.h"`

**Member variables:**
- `Ui::BroadcastUIDialog *ui` (private, .h line 28)
- `QTimer *m_timer` (private, .h line 29)

**UI widgets (broadcastuidialog.ui):**
- `BroadcastUIDialog` — QDialog, 800x480
- `pEditMsgBox` — QPlainTextEdit (read-only, displays broadcast message body; enabled=false, readOnly=true)
- `label` — QLabel (static header "Broadcast Message")
- `btnNo` — QPushButton ("NO")
- `btnYes` — QPushButton ("YES")
- `labelWarning` — QLabel (displays urgent.png pixmap when message type is set)
- `btnOK` — QPushButton ("OK")

---

## Step 5 — Security Review

### 1. Memory Safety

**A17-1** · LOW · Memory Safety
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/ui/authoriseddialog.cpp:192`
**Description:** `setCamera()` opens `/sys/class/gpio/gpio37/value` and `/sys/class/gpio/gpio39/value` using `QFile::open()` but does not check the return value of `open()`. If the GPIO sysfs entry is absent or permission-denied (e.g., during early boot, after a hardware fault, or on a non-ARM build), `file.write()` is called on an unopened file handle. While `QFile::write()` on a closed file returns -1 rather than crashing, the failure is entirely silent — no error is logged, no fallback is taken, and the camera/relay GPIO state becomes undefined. On a safety device this silent failure is a reliability concern. The pattern is repeated for both gpio37 (lines 192–198) and gpio39 (lines 201–208).

**A17-2** · LOW · Memory Safety
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/ui/broadcastuidialog.cpp:7`
**Description:** `m_timer` is allocated with `new QTimer` (no parent argument) in the constructor. All other `QTimer` and `QObject` child objects in this codebase are constructed with `this` as parent, enabling automatic deletion. This `QTimer` has no parent, so it is not part of the Qt object-ownership tree and will not be deleted when the dialog is destroyed unless explicitly managed. There is no `delete m_timer` in `~BroadcastUIDialog()` (destructor only calls `delete ui`), resulting in a memory leak every time a `BroadcastUIDialog` is instantiated and destroyed. In a long-running embedded application this leaks heap memory and an OS timer handle on every broadcast message receipt.

### 2. Communication Security

Communication Security: no issues found in the three assigned dialog files. These dialogs are display/UI components and do not themselves initiate network connections, transmit credentials, or contain hardcoded server addresses. The `BroadcastUIDialog` receives a `CIGCONF::BroadcastMessage` struct from the application layer and displays it — the communication path itself is out of scope for these files. No TLS configuration, certificate handling, or plaintext transmission logic is present in the reviewed files.

### 3. Input Handling

**A17-3** · MEDIUM · Input Handling
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/ui/authoriseddialog.cpp:79`
**Description:** Driver name data received from the server (provisioned into `gCfg` via the driver list) is concatenated directly into a UI label string with no length validation or sanitisation: `ui->lblDriverName->setText("Welcome, " + driverName)`. `QLabel::setText()` renders rich text when it detects HTML tags, and `driverName` is a `QString` obtained from `m_driverList` structures populated from network-received data (AT commands from the GMTP server, or FTP-provisioned list files at `/home/dlist.txt`, `/home/mlist.txt`). A driver name containing HTML such as `<img src=x onerror=...>` or `<a href="file:///...">` may be rendered as rich text by Qt's label renderer, allowing UI content injection. While this does not have the same severity as a remote code execution on a server, it can produce misleading on-screen content and potentially trigger unintended Qt resource loading. The `QLabel` has no `setTextFormat(Qt::PlainText)` call to force plain-text rendering.

**A17-4** · LOW · Input Handling
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/ui/broadcastuidialog.cpp:26`
**Description:** Broadcast message text from the server is truncated to `BROADCASTMSG_TEXT_LEN` (100 characters, defined in `cigconfigs.h` line 15) before display: `ui->pEditMsgBox->setPlainText(m.text.mid(0, BROADCASTMSG_TEXT_LEN))`. The use of `setPlainText()` correctly prevents HTML injection in this widget. The length truncation is a correct defensive control. However, the `timeout` field of `BroadcastMessage` is used without range validation at line 45: `m_timer->start(m.timeout * 1000)`. `m.timeout` is a `quint32`; multiplying by 1000 before passing to `QTimer::start(int msec)` (which takes a signed `int`) can overflow when `m.timeout` is greater than 2,147,483 (approximately 24.8 days). An attacker-controlled timeout value of 2,147,484 or higher would overflow to a negative or zero millisecond value, causing the timer to fire immediately or behave unpredictably, potentially bypassing the intended timeout-dismiss behaviour for broadcast messages.

### 4. Build Security

Build Security: not assessed in this file set. The assigned files are UI dialog source files (.h/.cpp/.ui). Build flags are controlled by the project `.pro` file, which is outside the file set assigned to A17. No build configuration artefacts are present in these files.

### 5. Device and Firmware

**A17-5** · MEDIUM · Device and Firmware — Authorization Logic
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/ui/authoriseddialog.cpp:160`
**Description:** The logout confirmation check at line 160 compares the button's displayed text string against a translated string to determine whether to execute a logout: `if (ui->btnLogout->text() == tr("Confirm?"))`. This is a UI-state-as-security-gate pattern. The authorization state ("is the user in the first-press or second-press/confirm stage?") is stored in a mutable UI widget property rather than in a dedicated boolean member variable. This creates two risks: (1) if a translation for "Confirm?" in any supported locale produces a string that collides with "Logout" (the initial button label), a single press would immediately log out without confirmation; (2) any external path that sets `btnLogout`'s text to "Confirm?" (e.g., a language-change event firing at an unexpected time) could cause the dialog to treat the next button press as a confirmed logout even if the user has not initiated one. The correct pattern is to maintain an explicit `bool m_awaitingLogoutConfirm` state variable.

**A17-6** · LOW · Device and Firmware — GPIO Error Handling
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/ui/authoriseddialog.cpp:188`
**Description:** The `setCamera()` function controls hardware GPIO lines by writing to sysfs files (`/sys/class/gpio/gpio37/value`, `/sys/class/gpio/gpio39/value`). This is a direct hardware control path for the camera and (by implication) a relay. No error is returned from `setCamera()` (return type is `void`), no error is logged, and callers (`updateCamera()`) have no way to detect or respond to a GPIO write failure. In a proximity-detection device where camera state may be safety-relevant (e.g., reversing camera for proximity alerts), silent hardware control failure is a safety and audit concern.

**A17-7** · INFO · Device and Firmware — UNIT_TEST Friend Class
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/ui/authoriseddialog.h:25`
**Description:** `AuthorisedDialog` declares `friend class TestDialog` under `#ifdef UNIT_TEST` (lines 25–27). This pattern is standard and the guard ensures the friend declaration is removed from production builds. Auditors should verify that no production build configuration defines `UNIT_TEST`, as doing so would grant `TestDialog` unrestricted access to all private members of the authorization dialog, including `m_pendingDriverId` and `m_optionalCheckConfirmationDialog`.

### 6. Qt-Specific Security

**A17-8** · LOW · Qt-Specific Security — screensaver debounce via QTimer::singleShot
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/ui/authoriseddialog.cpp:145`
**Description:** The screensaver wake-up path uses `QTimer::singleShot(200, this, [this](){screensaverOff();})`. The lambda captures `this` by value. If the `AuthorisedDialog` is destroyed within the 200 ms window (e.g., a logout is processed while the screensaver wake timer is in flight), the lambda will execute with a dangling `this` pointer, invoking `screensaverOff()` on a destroyed object. Qt's `QTimer::singleShot` with a raw `this` context pointer does not automatically invalidate the callback when the context object is destroyed when used with a lambda (unlike the `SLOT()` form which uses Qt's connection tracking). This is a potential use-after-free. The pattern at line 126 (`QTimer::singleShot(5000, this, &AuthorisedDialog::screensaverOn)`) uses a member function pointer form and is safe because Qt's signal/slot connection tracks object lifetime. Only the lambda form at line 145 is affected.

Qt-Specific: No `QProcess` usage, no `QSslSocket` usage, no `QSettings` usage, and no dynamic code execution was found in any of the three reviewed dialog files.

---

## Summary of Findings

| ID | Severity | Category | File |
|----|----------|----------|------|
| A17-1 | LOW | Memory Safety | authoriseddialog.cpp:192 |
| A17-2 | LOW | Memory Safety | broadcastuidialog.cpp:7 |
| A17-3 | MEDIUM | Input Handling | authoriseddialog.cpp:79 |
| A17-4 | LOW | Input Handling | broadcastuidialog.cpp:45 |
| A17-5 | MEDIUM | Device and Firmware | authoriseddialog.cpp:160 |
| A17-6 | LOW | Device and Firmware | authoriseddialog.cpp:188 |
| A17-7 | INFO | Device and Firmware | authoriseddialog.h:25 |
| A17-8 | LOW | Qt-Specific Security | authoriseddialog.cpp:145 |
# Pass 1 Audit — A18
**Auditor:** A18
**Date:** 2026-02-28
**Branch:** master (confirmed)

---

## Step 4 — Reading Evidence

### File Set 1: CheckCompletedDialog

**Files:**
- `/c/Projects/cig-audit/repos/mark3-pvd/ui/checkcompleteddialog.h`
- `/c/Projects/cig-audit/repos/mark3-pvd/ui/checkcompleteddialog.cpp`
- `/c/Projects/cig-audit/repos/mark3-pvd/ui/checkcompleteddialog.ui`

**Class:** `CheckCompletedDialog` : `QDialog`

**Q_OBJECT macro:** `checkcompleteddialog.h:14`

**Public methods:**
- `explicit CheckCompletedDialog(QWidget *parent = 0)` — h:17, cpp:7
- `~CheckCompletedDialog()` — h:18, cpp:62
- `void languageChanged(void)` — h:20, cpp:67
- `bool isTimerActive()` — h:21, cpp:135
- `void stopTimer()` — h:22, cpp:140
- `void setCheckResponses(QList<CIGCONF::CheckResponse> &responses)` — h:23 (inline)

**Signals:**
- `void openPreopNotes()` — h:30

**Protected:**
- `void showEvent(QShowEvent *event = 0)` — h:33, cpp:75

**`#include` directives (cpp):**
- `#include "checkcompleteddialog.h"` — cpp:1
- `#include "ui_checkcompleteddialog.h"` — cpp:2
- `#include "app/globalconfigs.h"` — cpp:3

**`#include` directives (h):**
- `#include <QDialog>` — h:4
- `#include <QTimer>` — h:5
- `#include "app/cigconfigs.h"` — h:6

**Member variables:**
- `Ui::CheckCompletedDialog *ui` — h:36
- `QTimer *m_timer` — h:37
- `QList<CIGCONF::CheckResponse> m_checkResponses` — h:38

**Macro:**
- `#define NO_ACTIVITY_TIME 10000` — cpp:5

**UI widgets (checkcompleteddialog.ui):**
- `btnBack` (QPushButton) — hidden in constructor
- `btnSend` (QPushButton) — icon-only "Continue" button
- `btnSend_2` (QPushButton) — text "Continue"
- `btnRepeat` (QPushButton) — icon-only "Repeat" button
- `btnRepeat_2` (QPushButton) — text "Repeat all questions"
- `btnNotes` (QPushButton) — icon-only "Notes" button
- `btnNotes_2` (QPushButton) — text "Add notes"
- `label_2` (QLabel) — "Pre-op safety check complete"
- `lblSummaryCritical` (QLabel) — "1 Failed critical question"

---

### File Set 2: CheckConfirmationDialog

**Files:**
- `/c/Projects/cig-audit/repos/mark3-pvd/ui/checkconfirmationdialog.h`
- `/c/Projects/cig-audit/repos/mark3-pvd/ui/checkconfirmationdialog.cpp`
- `/c/Projects/cig-audit/repos/mark3-pvd/ui/checkconfirmationdialog.ui`

**Class:** `CheckConfirmationDialog` : `QDialog`

**Q_OBJECT macro:** `checkconfirmationdialog.h:13`

**Public methods:**
- `explicit CheckConfirmationDialog(QWidget *parent = 0)` — h:16, cpp:4
- `~CheckConfirmationDialog()` — h:17, cpp:24
- `void confirm(bool yes)` — h:19, cpp:29
- `void setQuestion(const QString &question)` — h:20, cpp:40
- `void languageChanged(void)` — h:21, cpp:45

**Signals:** none

**Slots:** none explicitly declared (connect-time lambdas used)

**`#include` directives (h):**
- `#include <QDialog>` — h:4
- `#include "ui/dialog.h"` — h:5

**`#include` directives (cpp):**
- `#include "checkconfirmationdialog.h"` — cpp:1
- `#include "ui_checkconfirmationdialog.h"` — cpp:2

**Member variables:**
- `Ui::CheckConfirmationDialog *ui` — h:24

**UI widgets (checkconfirmationdialog.ui):**
- `labelQuestion` (QLabel) — displays question text, wordWrap enabled
- `labelNo` (QLabel) — "NO"
- `labelYes` (QLabel) — "YES"
- `btnBack` (QPushButton) — icon-only back
- `btnNext` (QPushButton) — icon-only next
- `label_2` (QLabel) — "CONFIRMATION"
- `label_3` (QLabel) — "You pressed"
- `btnNext_2` (QPushButton) — text "Next"
- `btnBack_2` (QPushButton) — text "Back"

---

### File Set 3: CheckQuestionDialog

**Files:**
- `/c/Projects/cig-audit/repos/mark3-pvd/ui/checkquestiondialog.h`
- `/c/Projects/cig-audit/repos/mark3-pvd/ui/checkquestiondialog.cpp`
- `/c/Projects/cig-audit/repos/mark3-pvd/ui/checkquestiondialog.ui`

**Class:** `CheckQuestionDialog` : `QDialog`

**Q_OBJECT macro:** `checkquestiondialog.h:14`

**Public methods:**
- `explicit CheckQuestionDialog(QWidget *parent = 0)` — h:17, cpp:4
- `~CheckQuestionDialog()` — h:18, cpp:14
- `const QString &question() const` — h:20 (inline)
- `void setQuestion(const QString &question, bool critical = false)` — h:21, cpp:19

**Signals:**
- `void shown(void)` — h:28

**Protected:**
- `void showEvent(QShowEvent *event)` — h:31, cpp:39

**`#include` directives (h):**
- `#include <QDialog>` — h:4
- `#include <QTimer>` — h:5
- `#include "ui/dialog.h"` — h:6

**`#include` directives (cpp):**
- `#include "checkquestiondialog.h"` — cpp:1
- `#include "ui_checkquestiondialog.h"` — cpp:2

**Member variables:**
- `Ui::CheckQuestionDialog *ui` — h:34
- `QString m_question` — h:35

**UI widgets (checkquestiondialog.ui):**
- `labelQuestion` (QLabel) — displays question text, wordWrap enabled
- `btnNo` (QPushButton) — "NO", wired to reject()
- `btnYes` (QPushButton) — "YES", wired to accept()
- `lblCritical` (QLabel) — "[Critical Question]", shown/hidden based on critical flag

---

## Step 5 — Security Review

### 1. Memory Safety

**A18-1** · HIGH · Memory Safety
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/utils/bytearray.h:25`
**Description:** `ByteArray::asprintf` calls `va_end(ap)` at line 21, then passes the already-invalidated `ap` to `vsprintf` at line 25. After `va_end`, the `va_list` is indeterminate; using it is undefined behaviour per C/C++ standards. On many architectures this corrupts the stack or heap. This function is called at `dialog.cpp:408` with the checklist response text, making the corruption reachable from configuration-supplied question text. While `ByteArray.h` is not directly assigned to A18, the call at `dialog.cpp:408` is inside `onCheckCompletedDialogAccepted` which directly processes checklist responses collected by the three assigned dialogs, making it a direct consequence of the checklist flow audited here.

**A18-2** · LOW · Memory Safety
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/ui/checkcompleteddialog.cpp:105`
**Description:** The loop variable in `for (const CIGCONF::CheckResponse response : m_checkResponses)` copies each struct by value which is benign, but `failedResponses` is declared `quint8` (8-bit unsigned). If a checklist ever contains more than 255 items with failures, the counter silently wraps to zero, causing the summary label to show "0 failed critical questions" even when all questions failed. This is an integer overflow on a safety-critical display counter.

### 2. Communication Security

No direct communication logic exists in the three assigned dialog files. The `sendGmtpMessage` signal is emitted in `dialog.cpp:onCheckCompletedDialogAccepted`, which is out of scope for this file set. The assigned files themselves do not transmit data.

Communication Security: no issues found.

### 3. Input Handling

**A18-3** · HIGH · Input Handling — Format String
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/ui/dialog.cpp:408`
**Description:** In `onCheckCompletedDialogAccepted`, the checklist response is serialised with:
```cpp
QByteArray ba = ByteArray::asprintf("%u,%u," + response.text.toLatin1(), response.id & 0x7fffffff, response.response);
```
The format string is constructed by concatenating the fixed literal `"%u,%u,"` with `response.text.toLatin1()`, which is the question text loaded from external configuration. If a question string contains `printf` format specifiers (e.g., `%s`, `%n`, `%x`), they are passed verbatim to `vsprintf` as active format specifiers, because `ByteArray::asprintf` passes this concatenated `const char*` directly as the `cformat` parameter. An attacker who can write a checklist configuration file with a question containing `%n` can write to an arbitrary memory address. The question text is displayed without modification by `CheckQuestionDialog::setQuestion` and `CheckConfirmationDialog::setQuestion`, so the same externally-supplied string reaches the format call unchanged.

**A18-4** · MEDIUM · Input Handling — Question Text Length
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/ui/checkquestiondialog.cpp:36` and `/c/Projects/cig-audit/repos/mark3-pvd/ui/checkconfirmationdialog.cpp:42`
**Description:** Question text is assigned directly to `QLabel::setText` with no maximum length check. `QLabel` does not truncate; a very long question string (e.g., tens of thousands of characters) from a misconfigured or maliciously modified checklist file will cause the label to allocate a large heap buffer and attempt to lay out the text, potentially causing excessive memory consumption or an out-of-memory crash on the embedded device.

### 4. Build Security

Build Security: no issues found.
(Build configuration files are not among the assigned files; no `.pro` file was reviewed here.)

### 5. Device and Firmware — Checklist Bypass

**A18-5** · HIGH · Device and Firmware — Checklist Bypass via Timeout Auto-Accept
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/ui/checkcompleteddialog.cpp:58` and `checkcompleteddialog.cpp:132`
**Description:** `CheckCompletedDialog` starts a 10-second single-shot timer (`NO_ACTIVITY_TIME = 10000 ms`) in `showEvent`. On timeout, the timer fires `accept()` unconditionally, advancing the checklist workflow to the authorised/unlocked state as if the operator had pressed "Continue". There is no check at timeout whether any critical questions were failed (`m_checkFailed`). The timeout path bypasses the `onCheckCompletedDialogAccepted` logic in `dialog.cpp` — that slot fires from `CheckCompletedDialog::accepted`, but so does the timer path via the lambda at line 58 which also calls `accept()`. Tracing the signal chain: both paths emit `accepted`, so `onCheckCompletedDialogAccepted` is reached for both. However, the 10-second automatic acceptance without operator confirmation is a security concern on an embedded safety device: if the device screen is unattended, the checklist completion step is auto-confirmed without operator presence, potentially unlocking equipment without a deliberate confirmation action.

**A18-6** · MEDIUM · Device and Firmware — Deprecated PRNG for YES/NO Button Shuffle
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/ui/checkquestiondialog.cpp:24`
**Description:** `qrand() % 2` is used to randomly swap the positions of the YES and NO buttons each time a question is displayed. `qrand()` is deprecated since Qt 5.15 and is a simple LCG with a predictable sequence if `qsrand()` is not called with a strong seed. More importantly, use of a predictable PRNG for this swap means that a sophisticated attacker who can predict or observe the seed state could anticipate button layout and automate or spoof operator input. The security impact is low in isolation, but on a safety-critical proximity-detection device, the design intent of randomising buttons is to prevent muscle-memory bypass of the checklist; a predictable PRNG undermines that intent.

**A18-7** · MEDIUM · Device and Firmware — Checklist Bypass via convorStatus
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/ui/dialog.cpp:799` (context of `bypassChecklist()`)
**Description:** `bypassChecklist()` returns `true` unconditionally when `gCfg->convorStatus()` is active, skipping the entire pre-operation checklist for the logged-in driver. If the `convorStatus` flag can be set by a remotely received message without adequate authentication (this is outside the scope of the assigned files but is a concern raised by reading the checklist workflow), an attacker could bypass the mandatory pre-op safety check entirely. This finding is raised as a flag for the reviewer of the communication and configuration modules.

### 6. Qt-Specific Security

**A18-8** · INFO · Qt-Specific Security — QDialog Accepted by Timer Without User Gesture
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/ui/checkcompleteddialog.cpp:58`
**Description:** The `QTimer::timeout` signal is connected to `accept()` on the `CheckCompletedDialog`. This is a Qt-level observation: `QDialog::accept()` emits `accepted`, which is connected in the parent `Dialog` to `onCheckCompletedDialogAccepted`. The timer fires on the main Qt event loop so there is no threading concern, but the design means the dialog resolves itself as "accepted" (continue) rather than "rejected" (repeat) on timeout. This design choice treats operator inaction as affirmative consent for a safety-critical step.

**A18-9** · INFO · Qt-Specific Security — `#include "ui/dialog.h"` in Header Files
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/ui/checkconfirmationdialog.h:5` and `/c/Projects/cig-audit/repos/mark3-pvd/ui/checkquestiondialog.h:6`
**Description:** Both dialog headers include `"ui/dialog.h"`, which is the top-level application dialog header. This creates a wide transitive include dependency. `dialog.h` pulls in nearly every subsystem header (RFID, beeper, GMTP, all other dialogs). While not a direct security vulnerability, this tight coupling means that any future security-sensitive change to `dialog.h` (e.g., adding a friend declaration, changing visibility of security-critical members) silently affects the compilation environment of these checklist dialogs. It is an architectural concern that increases the attack surface of the header dependency chain.

---

## Summary of Findings

| ID | Severity | Category | File |
|----|----------|----------|------|
| A18-1 | HIGH | Memory Safety — use-after-va_end in ByteArray::asprintf | bytearray.h:25 |
| A18-2 | LOW | Memory Safety — quint8 overflow on failedResponses counter | checkcompleteddialog.cpp:105 |
| A18-3 | HIGH | Input Handling — format string injection via question text | dialog.cpp:408 |
| A18-4 | MEDIUM | Input Handling — no length check on question text in QLabel | checkquestiondialog.cpp:36, checkconfirmationdialog.cpp:42 |
| A18-5 | HIGH | Device/Firmware — 10-second auto-accept bypasses operator confirmation | checkcompleteddialog.cpp:58,132 |
| A18-6 | MEDIUM | Device/Firmware — deprecated predictable PRNG for button shuffle | checkquestiondialog.cpp:24 |
| A18-7 | MEDIUM | Device/Firmware — checklist bypass via convorStatus flag | dialog.cpp:799 |
| A18-8 | INFO | Qt-Specific — timer-driven QDialog::accept() as affirmative consent | checkcompleteddialog.cpp:58 |
| A18-9 | INFO | Qt-Specific — broad transitive include via dialog.h in dialog headers | checkconfirmationdialog.h:5, checkquestiondialog.h:6 |
# Pass 1 Security Audit — A19
**Repository:** mark3-pvd
**Branch:** master
**Date:** 2026-02-28
**Auditor:** A19

---

## Step 4 — Reading Evidence

### File Set 1: checkstartdialog

**Files:**
- `/c/Projects/cig-audit/repos/mark3-pvd/ui/checkstartdialog.h`
- `/c/Projects/cig-audit/repos/mark3-pvd/ui/checkstartdialog.cpp`
- `/c/Projects/cig-audit/repos/mark3-pvd/ui/checkstartdialog.ui`

**Class:** `CheckStartDialog : public QDialog`

**Q_OBJECT:** `checkstartdialog.h` line 12

**Public methods:**
- `explicit CheckStartDialog(QWidget *parent = 0)` — line 15 (.h), line 5 (.cpp)
- `~CheckStartDialog()` — line 16 (.h), line 18 (.cpp)
- `void setMandatory(bool mandatory)` — line 17 (.h), line 23 (.cpp)
- `void languageChanged(void)` — line 18 (.h), line 34 (.cpp)

**Signals:** none declared
**Slots:** none declared (btnStart connected directly to `accept()`)

**#include directives (.cpp):**
- `"checkstartdialog.h"`
- `"ui_checkstartdialog.h"`
- `<QDebug>`

**Member variables:**
- `Ui::CheckStartDialog *ui` (private, line 25 .h)

**Friend class (conditional):** `TestDialog` (when `UNIT_TEST` defined, line 21 .h)

**UI widgets (.ui):**
- `QLabel` name="label" — background fill
- `QLabel` name="label_2" — background fill
- `QLabel` name="label_3" — "Start check" label
- `QLabel` name="labelTip11" — "Press below to start your"
- `QLabel` name="labelTip12" — " optional" (red text, toggleable)
- `QLabel` name="labelTip21" — "mandatory " (red text, toggleable)
- `QLabel` name="labelTip22" — "pre-op safety check."
- `QPushButton` name="btnStart" — start button (icon only, connects to `accept()`)

---

### File Set 2: commentdialog

**Files:**
- `/c/Projects/cig-audit/repos/mark3-pvd/ui/commentdialog.h`
- `/c/Projects/cig-audit/repos/mark3-pvd/ui/commentdialog.cpp`
- `/c/Projects/cig-audit/repos/mark3-pvd/ui/commentdialog.ui`

**Class:** `CommentDialog : public QDialog`

**Q_OBJECT:** `commentdialog.h` line 23

**Macros defined in header:**
- `NO_ACTIVITY_TIME 10000` (line 12)
- `MAX_CHARACTER 100` (line 13)

**Enum:** `CommentDialogType {Unlock, Preop}` (line 15)

**Public methods:**
- `explicit CommentDialog(CommentDialogType type, QWidget *parent = nullptr)` — line 26 (.h)
- `~CommentDialog()` — line 27 (.h)
- `void UpdateTextInput(QString str, onScreenKeyboard::CtrlButton ctrl)` — line 29 (.h), line 104 (.cpp)
- `void onkeyboardClosed()` — line 30 (.h), line 98 (.cpp)
- `void onUnlkReasonSelected()` — line 31 (.h), line 205 (.cpp)
- `void languageChanged()` — line 32 (.h), line 214 (.cpp)

**Private methods:**
- `bool debounce()` — line 37 (.h), line 188 (.cpp)
- `void reset()` — line 38 (.h), line 199 (.cpp)
- `void showWidgets()` — line 39 (.h), line 46 (.cpp)

**Private slots:**
- `void run_keyboard_lineEdit()` — line 51 (.h), line 121 (.cpp)
- `void onDone()` — line 52 (.h), line 134 (.cpp)
- `void onSkip()` — line 53 (.h), line 168 (.cpp)

**Protected methods:**
- `void showEvent(QShowEvent *event = 0)` — line 47 (.h), line 91 (.cpp)
- `void hideEvent(QHideEvent *)` — line 48 (.h), line 41 (.cpp)

**#include directives (.cpp):**
- `"commentdialog.h"`
- `"ui_commentdialog.h"`
- `"app/globalconfigs.h"`
- `<QtWidgets/QPlainTextEdit>`
- `<QtWidgets/QLineEdit>`
- `<QDebug>`
- `<QComboBox>`

**Member variables:**
- `Ui::CommentDialog *ui` (private, line 35 .h)
- `onScreenKeyboard *lineEditkeyboard` (private, line 36 .h)
- `QTimer *m_timer` (private, line 41 .h)
- `quint32 m_lastPress` (private, line 42 .h)
- `CommentDialogType m_dlgType` (private, line 43 .h)
- `UnlockReasonDialog *m_unlkReasonDlg` (private, line 44 .h)

**UI widgets (.ui):**
- `QLabel` name="lblHeaderText"
- `QLabel` name="lblWarning"
- `QLabel` name="lblRealImpact"
- `QLabel` name="label" — icon pixmap
- `QPlainTextEdit` name="pteMessageBox" — free-text comment input; no `maxLength` property set in .ui
- `QPushButton` name="btnDone"
- `QPushButton` name="btnSkipButton"
- `QPushButton` name="btnDropdown"
- `QRadioButton` name="btnYes"
- `QRadioButton` name="btnNo"
- `QRadioButton` name="btnUnconfirmed"

---

### File Set 3: dialog

**Files:**
- `/c/Projects/cig-audit/repos/mark3-pvd/ui/dialog.h`
- `/c/Projects/cig-audit/repos/mark3-pvd/ui/dialog.cpp`
- `/c/Projects/cig-audit/repos/mark3-pvd/ui/dialog.ui`

**Class:** `Dialog : public QDialog`

**Q_OBJECT:** `dialog.h` line 41

**Public methods (dialog.h):**
- `explicit Dialog(QWidget *parent = 0)` — line 44
- `~Dialog()` — line 45
- `void onPowerChanged(CIGCONF::PowerState powerState)` — line 47
- `void onReboot()` — line 48
- `void onBleReady(bool yes)` — line 49
- `void onNetworkReady(bool yes)` — line 50
- `void onCardAuthorised(bool yes, quint64)` — line 51
- `void onCmdLogin(quint64 id)` — line 52
- `void onIdleTimeout()` — line 53
- `void lockScreen(CIGCONF::MaintLockedCode code, bool remote)` — line 54
- `void ambertImpactScreen()` — line 55
- `void updateLux(int lux)` — line 57
- `void updateStatus(...)` — line 58
- `void updateBatteryStatus(...)` — line 59
- `void updateExpModInfo(QByteArray mainVersion)` — line 60
- `void onBroadcastMsgReceived(CIGCONF::BroadcastMessage m)` — line 61
- `void showInformationScreen()` — line 62
- `void updateLoginImage()` — line 63
- `void quickPowerUpdate(bool on)` — line 64
- `void onDemandStarted(...)` — line 66
- `void onDemandExtended(...)` — line 67
- `void onDemandEnded(...)` — line 68
- `void onLanguageChanged(void)` — line 70
- `void updateCamera()` — line 72

**Signals (dialog.h):**
- `void driverChanged(quint64 id)` — line 79
- `void lastCheckDriverChanged(quint64 id)` — line 80
- `void screenLocked(CIGCONF::MaintLockedCode code)` — line 81
- `void setRelayOut(bool on1, bool on2)` — line 82
- `void setRelay2Out(bool on)` — line 83
- `void sendGmtpMessage(CIGCONF::GmtpMessage msg, const QByteArray &extra = QByteArray())` — line 84
- `void resetCanStates(bool resetLast)` — line 85
- `void forceBroadcastUIClose()` — line 86
- `void log(QByteArray &msg)` — line 87
- `void updatePreopTimer(QString timeout)` — line 88
- `void amberDialogAboutToShow(bool isLocked)` — line 89

**Protected methods:**
- `void mouseReleaseEvent(QMouseEvent *)` — line 92
- `void showEvent(QShowEvent *event = 0)` — line 93

**Private slots:**
- `void on_pushButton_clicked()` — line 96

**Private methods:**
- `void onPinCode()` — line 99
- `void onCardSwiped(...)` — line 100
- `void onPinDialogAccepted()` — line 102
- `void onAuthorisedDialogAccepted()` — line 103
- `void onAuthorisedUserLogout()` — line 104
- `void onOptionalCheckConfirmed()` — line 105
- `void onCheckStartDialogAccepted()` — line 106
- `void onCheckQuestionDialogFinished(int result)` — line 107
- `void onCheckConfirmationDialogFinished(int result)` — line 108
- `void onCheckCompletedDialogAccepted()` — line 109
- `void onCheckCompletedDialogRejected()` — line 110
- `void onUnlockedDialogAccepted()` — line 111
- `void onProcessUnlock()` — line 112
- `void onPreopCommentDone()` — line 113
- `void onBroadcastDialogDone(int result)` — line 114
- `bool isValidId(quint64 id)` — line 116
- `bool isChecklistEmpty(bool reload)` — line 117
- `bool bypassChecklist()` — line 118
- `void clearWidgets()` — line 119
- `void login(quint64 id)` — line 121
- `void postLogin()` — line 122
- `void postMaintenanceLogin()` — line 123
- `void logout()` — line 124
- `void openMenuDialog()` — line 125
- `void startCheck(bool restartTimer=true)` — line 127
- `void sendStartCheck()` — line 128
- `void superListUpdated(bool empty)` — line 130
- `void updateOnDemand()` — line 131
- `void convorStatusUpdated()` — line 133
- `bool isOnDemandExpired()` — line 135
- `void fullLockStart()` — line 137
- `void updateFullLock()` — line 138
- `void updateTime()` — line 140
- `void writeMsgToQueue(CIGCONF::BroadcastMessage m)` — line 201
- `bool displayNextBroadcastMessage()` — line 202
- `void clearMsgQueue()` — line 203
- `void initOnScreenPreopTimer(quint16 survto)` — line 207
- `QString showCustomTimeFormat(quint32 time)` — line 208
- `void adjustPreopDialogs(bool en)` — line 212
- `void updateBLEConSpinner(quint8 status)` — line 214

**#include directives (dialog.cpp):**
- `"dialog.h"`, `"ui_dialog.h"`, `"ui/pindialog.h"`, `"ui/authoriseddialog.h"`, `"ui/checkstartdialog.h"`, `"ui/checkcompleteddialog.h"`, `"ui/checkconfirmationdialog.h"`, `"ui/checkquestiondialog.h"`, `"ui/lockeddialog.h"`, `"ui/unlockeddialog.h"`, `"ui/messagedialog.h"`, `"ui/ondemanddialog.h"`, `"ui/commentdialog.h"`, `"ui/informationdialog.h"`, `"ui/broadcastuidialog.h"`, `"ui/supervisordialog.h"`, `"ui/languagedialog.h"`, `"platform/wiegandrfid.h"`, `"platform/internalrfid.h"`, `"platform/pwmbeeper.h"`, `"app/globalconfigs.h"`, `<QMouseEvent>`, `<QTimer>`, `<QTime>`, `<QDebug>`, `<QApplication>`, `<QPixmap>`, `"ui/keyfilter.h"`, `"ui/vorwarningdialog.h"`, `"mytranslator.h"`, `"ui/preopscreenoverlay.h"`, `"ui/amberimpactalertdialog.h"`

**Member variables (dialog.h):**
- `Ui::Dialog *ui`
- All child dialog pointers: `m_pinDialog`, `m_authorisedDialog`, `m_checkStartDialog`, `m_checkQuestionDialog`, `m_checkConfirmationDialog`, `m_checkCompletedDialog`, `m_lockedDialog`, `m_unlockedDialog`, `m_messageDialog`, `m_informationDialog`, `m_onDemandDialog`, `m_unlockReasonDlg`, `m_preopCommentDlg`, `m_broadcastDialog`, `m_supervisorDialog`, `m_languageDialog`, `m_amberImpactAlertDialog`
- Hardware: `m_internalRfid`, `m_wiegandRfid`, `m_beeper`
- Timers: `m_checklistTimer`, `m_odTimer`, `m_messageTimer`, `m_timeTimer`
- State: `m_driverId`, `m_pendingDriverId`, `m_checkReason`, `m_checkFailed`, `m_checkSelectedYes`, `m_checkResponses`, `m_checkItemIndex`, `m_checkItem`, `m_bleReady`, `m_networkReady`, `m_locked`, `m_driverBased`, `m_timeBased`, `m_preopOncePerDay`, `m_power`
- `m_vorwarningDialog`, `m_survTo`, `m_overlay`, `m_bleSpinnerMovie`
- `m_broadcastMsgUrgent`, `m_broadcastMsgNormal`, `m_response`

**UI widgets (dialog.ui):**
- `QLabel` name="label" — full-screen login background pixmap
- `QLabel` name="labelOdm" — on-demand mode text overlay
- `QLabel` name="labelTime" — clock display
- `QLabel` name="lblVor_1" — VOR icon left
- `QLabel` name="lblVor_2" — VOR icon right
- `QPushButton` name="pushButton" — language selector ("EN")
- `QFrame` name="frLoginOverlay" — BLE connecting overlay
  - `QLabel` name="lblBleConnStat" — spinner animation
  - `QLabel` name="label_2" — "Please wait while we connect to the expansion module"

---

## Step 5 — Security Review

### 1. Memory Safety

**A19-1** · HIGH · Memory Safety
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/utils/bytearray.h:25`
**Description:** `ByteArray::asprintf` calls `vsnprintf` with a cleared `va_list` (after `va_end` on line 21) to measure the required buffer size, then calls `vsprintf` (unbounded) on line 25 with a second `va_start` that was never called — the `va_list ap` is reused after `va_end` without reinitialisation. Accessing a `va_list` after `va_end` is undefined behaviour in C++. Additionally, `vsprintf` is used instead of `vsnprintf` for the actual write, so if the undefined-behaviour `va_list` reuse produces a different (larger) size than measured, it will write past the end of the `QByteArray`. This function is called from `dialog.cpp` with operator-influenced data (checklist question text and comment strings), making corruption of the output buffer possible.

**A19-2** · MEDIUM · Memory Safety
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/ui/commentdialog.cpp:209-211`
**Description:** `onUnlkReasonSelected()` inserts a reason string selected from `UnlockReasonDialog` directly into `pteMessageBox` without applying the `MAX_CHARACTER` (100) limit check that `UpdateTextInput()` enforces for keyboard input. If any pre-defined reason string in `UnlockReasonDialog` exceeds 100 characters, the resulting `unlockString` passed to `gCfg->setUnlkReasonString()` and then formatted with `vsprintf` in `backgroundworker.cpp:2340` will exceed the intended limit, creating an inconsistency between the keyboard and dropdown paths.

### 2. Communication Security

**A19-3** · HIGH · Communication Security
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/app/backgroundworker.cpp:2243-2246`
**Description:** The preop comment string entered by the operator is inserted into the GMTP OPCMNT message using `ByteArray::asprintf("AUTH=%llX,%X OPCMNT=%s", ..., gCfg->preopCommentString().toLatin1().data())`. The comment string is used as a `%s` argument to an `sprintf`-family call, not as the format string itself, so this is not a format-string vulnerability. However, there is no validation that the comment string is free of control characters or embedded protocol delimiters before transmission to the server. A malicious or malformed comment could corrupt the server-side message parsing if the server does not sanitise the field. This is a medium-to-high concern in a safety-critical communications protocol.

**A19-4** · HIGH · Communication Security
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/app/backgroundworker.cpp:2340-2347`
**Description:** The unlock reason string from `gCfg->UnlkReasonString()` is transmitted to the server via `ByteArray::asprintf("UNLK=%llX,%X,%X,%llX,%X,%s,%X", ..., gCfg->UnlkReasonString().toLatin1().data(), ...)`. As with the OPCMNT case, the string is used as a `%s` argument, but it is not validated for embedded commas, percent signs, or other protocol-significant characters before being formatted and transmitted. Because the UNLK message uses comma-delimited fields, an operator-entered reason string containing a comma will corrupt the field structure seen by the server parser.

### 3. Input Handling

**A19-5** · HIGH · Input Handling
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/ui/dialog.cpp:408`
**Description:** Format string constructed from operator-influenced data. The call `ByteArray::asprintf("%u,%u," + response.text.toLatin1(), response.id & 0x7fffffff, response.response)` constructs the format string by concatenating a literal prefix with `response.text.toLatin1()`. `response.text` originates from `m_checkItem.question`, which is the checklist question text loaded from configuration. If a checklist question string contains a `%` character followed by a format specifier (e.g., `%s`, `%n`, `%x`), it will be interpreted as a format directive by `vsprintf` inside `ByteArray::asprintf`. This is a format-string injection vulnerability. Configuration data may be delivered from the server, making this exploitable remotely by an attacker who can influence checklist content.

**A19-6** · MEDIUM · Input Handling
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/ui/commentdialog.cpp:115`
**Description:** The `MAX_CHARACTER` limit of 100 is enforced only in `UpdateTextInput()`, which is called from the on-screen keyboard path. The limit is enforced with `< MAX_CHARACTER` (strictly less than), meaning the maximum text length is 99 characters, not 100 as the constant name implies. This is an off-by-one inconsistency in the enforcement of the stated constraint. Direct paste or programmatic injection through `onUnlkReasonSelected()` bypasses this check entirely (see A19-2).

**A19-7** · LOW · Input Handling
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/ui/dialog.cpp:863`
**Description:** Debug output leaks operational state. `qDebug() << "Timebased " << hm_now << " " << hm_last;` at line 863 inside `bypassChecklist()` logs current time and last check time values to debug output. If debug logging is active in a production build, this leaks the device's local time and checklist scheduling state to any process or log reader with access to the device's debug output.

### 4. Build Security

**A19-8** · HIGH · Build Security
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/mk3.pro`
**Description:** No hardening compiler flags are present in the `.pro` file. Specifically absent are: `-fstack-protector-strong` (stack overflow detection), `-D_FORTIFY_SOURCE=2` (buffer overflow detection for standard library functions), `-fPIE`/`-pie` (position-independent executable for ASLR), and `-Wformat -Wformat-security` (format string vulnerability detection at compile time). On an embedded Linux device running safety-critical vehicle proximity detection software, the absence of these flags means the firmware has no run-time stack-smashing protection and no ASLR benefit, maximising the impact of the memory-safety issues identified above.

**A19-9** · MEDIUM · Build Security
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/mk3.pro`
**Description:** No `CONFIG += release` or `QMAKE_STRIP` directive is present in the `.pro` file. Without an explicit release configuration or strip directive, debug symbols may be included in production firmware images, providing an attacker who gains access to the firmware binary with full symbol information including function names, variable names, and source file paths. The comment on line 37 of `dialog.cpp` — `/* TODO: all functions of gCfg might be guarded as they are used in multithread */` — would also be visible in debug symbol strings.

### 5. Device and Firmware

**A19-10** · HIGH · Device and Firmware
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/ui/dialog.cpp:233`
**Description:** `QProcess::execute("/bin/sh", QStringList() << "-c" << "echo 0 > /sys/class/gpio/gpio37/value")` is called inside `showInformationScreen()` to disable the camera GPIO. While the command string is a literal (not user-influenced), this call spawns a full shell (`/bin/sh -c`) to write a single byte to a sysfs path. If the PATH or environment is manipulated prior to this call (e.g., by a compromised service on the device), or if the sysfs path is writable by a lower-privilege process, this represents a privileged shell execution from the UI process. Using direct file I/O (`QFile::write`) on the GPIO sysfs path would eliminate the shell invocation entirely. Additionally, using `/bin/sh -c` for any operation, even with a literal command, is a pattern that is unsafe to generalise and sets a precedent for future developers to pass variable data to this pattern.

**A19-11** · MEDIUM · Device and Firmware
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/ui/dialog.cpp:37`
**Description:** A developer TODO comment acknowledges a known thread-safety defect: `/* TODO: all functions of gCfg might be guarded as they are used in multithread */`. `gCfg` (the global `GlobalConfigs` object) is accessed from both the UI thread (dialog.cpp) and the background worker thread (backgroundworker.cpp), including the `preopCommentString` and `UnlkReasonString` fields that are written in the UI thread and read in the background worker. Without mutex protection, this is a data race with undefined behaviour. On an embedded device with a safety-critical function (vehicle proximity detection), a data race corrupting device state could cause incorrect relay output behaviour.

### 6. Qt-Specific Security

**A19-12** · MEDIUM · Qt-Specific Security
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/ui/dialog.cpp:233`
**Description:** `QProcess::execute` is used to control a GPIO via a shell command. See A19-10. From the Qt-specific security perspective: `QProcess::execute` is a blocking call that runs a subprocess. It is called from the UI thread inside `showInformationScreen()`. This can cause the UI to freeze if the subprocess takes longer than expected. More importantly, spawning `/bin/sh -c` from the main application process grants the shell the same process credentials as the Qt application, which on an embedded device may run as root. Any subsequent call that passes non-literal data to a similar pattern would be a command injection vulnerability.

**A19-13** · INFO · Qt-Specific Security
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/ui/commentdialog.cpp:18`
**Description:** `ui->pteMessageBox->setTextInteractionFlags(Qt::TextEditable)` is called in the constructor. `QPlainTextEdit` is editable by default; this call is redundant and has no security impact, but it documents that the widget is intentionally made editable. No rich-text or HTML rendering flags are set, so HTML injection into the display label is not a concern for this widget.

---

*End of A19 findings.*
# Pass 1 Audit — A20
**Auditor:** A20
**Date:** 2026-02-28
**Branch:** master (confirmed)

---

## Reading Evidence

### informationdialog.h / informationdialog.cpp / informationdialog.ui

**File paths:**
- `/c/Projects/cig-audit/repos/mark3-pvd/ui/informationdialog.h`
- `/c/Projects/cig-audit/repos/mark3-pvd/ui/informationdialog.cpp`
- `/c/Projects/cig-audit/repos/mark3-pvd/ui/informationdialog.ui`

**Class:** `InformationDialog` extends `QDialog`

**Q_OBJECT macro:** `informationdialog.h` line 18

**Public methods:**
- `explicit InformationDialog(QWidget *parent = 0)` — h:21 / cpp:11
- `~InformationDialog()` — h:22 / cpp:101
- `void updateInformationScreen()` — h:23 / cpp:233
- `void setLux(int lux)` — h:24 / cpp:106
- `void setStatus(QByteArray IO, bool Rly1, bool Rly2, QByteArray can, const QByteArray &rssi, const QByteArray &moni, bool netStat, bool mdemStat, bool wifiStat, qint8 sat, qint32 lat, qint32 lon)` — h:25 / cpp:111
- `void setConfigParam()` — h:26 / cpp:137
- `void setBatteryStatus(bool avail, int state, int fault, quint16 voltage, qint16 current, quint16 temp, quint16 remainingCapacity)` — h:27 / cpp:126
- `void setExpModInfo(QByteArray mainVersion)` — h:28 / cpp:195
- `void setSuperMasterStatus()` — h:29 / cpp:200
- `void setVOR()` — h:30 / cpp:220
- `void setLastWiegand(quint64 id)` — h:31 / cpp:228
- `void languageChanged()` — h:32 / cpp:240

**Signals:** none declared

**Slots (protected):**
- `void showEvent(QShowEvent *)` — h:35 / cpp:94
- `void hideEvent(QHideEvent *)` — h:36 / cpp:89

**#include directives (cpp):**
- `#include "informationdialog.h"` (line 1)
- `#include "ui_informationdialog.h"` (line 2)
- `#include "app/globalconfigs.h"` (line 3)
- `#include "utils/barcode128.h"` (line 4)
- `#include <QBluetoothAddress>` (line 5)
- `#include <QProcess>` (line 6)
- `#include <QFile>` (line 7)

**Member variables (h):**
- `Ui::InformationDialog *ui` — h:39
- `QMap<int, QString> m_chargeStatusMap` — h:40
- `QMap<int, QString> m_chargeFaultMap` — h:41
- `QTimer *m_updateConfigTmr` — h:42

**UI widgets (informationdialog.ui):** QPushButton `btnHide`; QTabWidget `tabWidget` with tabs: System, Status, Configuration, Diagnostics; numerous QLabel widgets including: `labelHwVer`, `labelKernelVer`, `labelRootfsVer`, `labelAppVer`, `labelExpVer`, `lblgmtpid`, `labelBarcode`, `lblRelay1`, `lblCSQ`, `lblNetworkStatus`, `lblModemStatus`, `lblWifiStatus`, `lblDigitalIO`, `lblCAN`, `lblMoni`, `lblSMStatus`, `lblVOR`, `labelGPSSat`, `labelGPSLat`, `labelGPSLong`, `lblKeepAliveTime`, `lblshutDTime`, `lblMaint`, `lblServerProfile1`, `lblServerProfile2`, `lblServerProfile3`, `lblMacAddress`, `lblMacAddress_2`, `lblChkTimeout`, `lblChkSchedule1`–`lblChkSchedule4`, `lblTimezone`, `lblTHost`, `lblIdle`, `lblLastCheck`, `lblShockParam`, `lblICCID`, `labelBattPres`, `labelBattStat`, `labelBattFault`, `labelBattVolt`, `labelBattCurr`, `labelBattTemp`, `labelBattCap`, `labelWiegand`, `labelLux`, `labelGPSSat`, `labelGPSLat`, `labelGPSLong`; many static QLabel description labels (label_3 through label_42 with gaps).

---

### keyfilter.h / keyfilter.cpp

**File paths:**
- `/c/Projects/cig-audit/repos/mark3-pvd/ui/keyfilter.h`
- `/c/Projects/cig-audit/repos/mark3-pvd/ui/keyfilter.cpp`

**Class:** `KeyFilter` extends `QObject`

**Q_OBJECT macro:** `keyfilter.h` line 10

**Public methods:**
- `explicit KeyFilter(QObject *parent = nullptr)` — h:12 / cpp:8
- `static bool isPowerKeyPressed()` — h:13 (inline, returns `m_powerKeyPressed`)

**Signals:**
- `void showInfoDialog()` — h:16

**Protected methods:**
- `bool eventFilter(QObject *obj, QEvent *event)` — h:18 / cpp:20

**Private methods:**
- `void resetKeyCount()` — h:34 / cpp:66
- `void incrementKeyCount(int key)` — h:35 / cpp:76
- `int getKeyCount(int key)` — h:36 / cpp:101
- `void resetKeyCounter(int key)` — h:37 / cpp:114
- `bool getPressState(int key)` — h:38 / cpp:145
- `void setPressState(int key, bool state)` — h:39 / cpp:126

**#include directives (cpp):**
- `#include "keyfilter.h"` (line 1)
- `#include <QEvent>` (line 2)
- `#include <QKeyEvent>` (line 3)
- `#include <QTimer>` (line 4)

**Member variables (h):**
- `static bool m_powerKeyPressed` — h:21
- `QSet<int> m_pressedKeys` — h:22
- `QTimer *m_timer` — h:24
- `int m_leftKeyCount` — h:25
- `int m_rightKeyCount` — h:26
- `int m_upKeyCount` — h:27
- `int m_downKeyCount` — h:28
- `bool m_leftKeyPressed` — h:29
- `bool m_rightKeyPressed` — h:30
- `bool m_upKeyPressed` — h:31
- `bool m_downKeyPressed` — h:32

---

### languagedialog.h / languagedialog.cpp / languagedialog.ui

**File paths:**
- `/c/Projects/cig-audit/repos/mark3-pvd/ui/languagedialog.h`
- `/c/Projects/cig-audit/repos/mark3-pvd/ui/languagedialog.cpp`
- `/c/Projects/cig-audit/repos/mark3-pvd/ui/languagedialog.ui`

**Class:** `LanguageDialog` extends `QDialog`

**Q_OBJECT macro:** `languagedialog.h` line 12

**Public methods:**
- `explicit LanguageDialog(QWidget *parent = nullptr)` — h:15 / cpp:12
- `~LanguageDialog()` — h:16 / cpp:25
- `void languageChanged()` — h:17 / cpp:76
- `void startScreenTimeout()` — h:18 / cpp:84

**Signals:**
- `void sigLanguageChanged()` — h:21

**Private slots:**
- `void on_btnEnglish_clicked()` — h:24 / cpp:30
- `void on_btnSpanish_clicked()` — h:25 / cpp:42
- `void on_btnQuit_clicked()` — h:26 / cpp:54

**Protected methods:**
- `void showEvent(QShowEvent *event = 0)` — h:29 / cpp:59

**#include directives (cpp):**
- `#include "languagedialog.h"` (line 1)
- `#include "ui_languagedialog.h"` (line 2)
- `#include "app/globalconfigs.h"` (line 3)
- `#include "mytranslator.h"` (line 4)
- `#include "ui/dialog.h"` (line 5)
- `#include <QTimer>` (line 6)
- `#include <QLocale>` (line 7)
- `#include <QDebug>` (line 8)

**Member variables (h):**
- `Ui::LanguageDialog *ui` — h:32
- `QTimer *m_timer` — h:33
- `quint32 m_lastPress` — h:35

**UI widgets (languagedialog.ui):** QLabel `labelMsg`; QPushButton `btnEnglish`; QPushButton `btnSpanish`; QPushButton `btnQuit`.

---

### mytranslator.h / mytranslator.cpp (referenced by languagedialog)

**File paths:**
- `/c/Projects/cig-audit/repos/mark3-pvd/mytranslator.h`
- `/c/Projects/cig-audit/repos/mark3-pvd/mytranslator.cpp`

**Global constants:** `langEnglish = "EN"`, `langSpanish = "ES"` (h:11–12)
**Global variable:** `extern QTranslator mTranslator` (h:14)

**Free functions:**
- `void loadLocalLanguage(void)` — cpp:15
- `void updateLocalLanguage(const QString &arg1)` — cpp:74
- `QString getCurrentLanguage(void)` — cpp:132
- `int queryLanguage(void)` — cpp:167
- `int setLanguage(int local)` — cpp:177
- `void removeTranslator()` — cpp:190

**#include directives (cpp):**
- `#include <QApplication>`, `#include <QFile>`, `#include <QDebug>`, `#include <QTranslator>`, `#include "mytranslator.h"`

**Key file reads:**
- `localFile = "local.dat"` (relative path, cpp:7) — read/written to store active language code
- `langFile = ":/lang.dat"` (Qt resource, cpp:8) — read-only resource embedded in binary mapping language codes to translation filenames

---

## Security Review

### 1. Memory Safety

No `strcpy`, `strcat`, `sprintf`, `gets`, `memcpy`, or `memmove` usage found in the audited files. `QString::asprintf` is used throughout `informationdialog.cpp` with fixed format literals and typed arguments only — no user-controlled format strings. Raw `new` is used to allocate `ui` (both dialogs) and `m_updateConfigTmr` / `m_timer`, but all are deleted in destructors or parented to the dialog (Qt parent-child memory management). No unguarded array index access observed.

One marginal note: `informationdialog.cpp` line 53 computes `ba.mid(14, id1 - 15)` from `/proc/version` content. If `id1` is 14, the length argument is `-1` which in Qt's `QByteArray::mid` is treated as "to end of array" — this is benign but worth noting as it reads a kernel-provided file, not attacker-controlled data. No exploitable path identified.

Memory Safety: no issues found.

---

### 2. Communication Security

**A20-1** · MEDIUM · Communication Security
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/ui/informationdialog.cpp:150-158`
**Description:** `setConfigParam()` renders the APN username (`gCfg->apnUser()`) and APN password (`gCfg->apnPassword()`) in plaintext inside a QLabel on the Configuration tab of the information screen. This screen is accessible at runtime by pressing any directional key four times (or a three-key combo via KeyFilter). If an operator or bystander accesses this screen, the modem APN credentials are visible in clear text on the display. On a vehicle-mounted device in a shared or high-traffic environment, this represents unintended credential exposure.

---

### 3. Input Handling

**A20-2** · HIGH · Input Handling — Hidden Debug/Info Menu via Key Sequence
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/ui/keyfilter.cpp:26-43`
**Description:** `KeyFilter::eventFilter` implements two undocumented key sequences that silently emit `showInfoDialog()` and open the information/diagnostic screen: (1) simultaneous press of Left + Up + Down (three keys held at once, line 26–30); (2) pressing any single directional key exactly four times within 1.5 seconds (lines 31–43). The information screen that is revealed displays system configuration, APN credentials, server addresses, modem status, GPS coordinates, battery diagnostics, and Wiegand card IDs. There is no authentication, PIN, or operator-role check before the screen is shown. On a vehicle-mounted embedded device accessible to operators and drivers, this constitutes an unauthenticated hidden diagnostic menu reachable via the physical keypad.

**A20-3** · MEDIUM · Input Handling — `eventFilter` consumes all key events unconditionally
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/ui/keyfilter.cpp:49, 60`
**Description:** Both the `KeyPress` and `KeyRelease` branches of `eventFilter` return `true` unconditionally (lines 49 and 60), preventing any key event from being propagated further up the event chain regardless of whether `KeyFilter` handled it. This means legitimate UI elements that rely on keyboard navigation or input will silently receive no key events when this filter is installed. While primarily a correctness/availability issue, the suppression of all key events is a defence-in-depth concern: if an attacker can trigger UI states where input is expected (e.g., a PIN or numeric entry widget), no characters will reach those widgets, potentially bypassing intended input validation flows entirely.

**A20-4** · LOW · Input Handling — `m_rightKeyPressed` initialisation missing in constructor
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/ui/keyfilter.cpp:8-18`
**Description:** The constructor member-initialiser list sets `m_leftKeyPressed(false)` (line 14) but does not explicitly initialise `m_rightKeyPressed`, `m_upKeyPressed`, or `m_downKeyPressed`. In C++, non-static bool members of a class that are not initialised in the constructor initialiser list or at the point of declaration are left with indeterminate values. If `getPressState` is called for Right, Up, or Down before `setPressState` has been called, the returned value is undefined. This could cause the key-repeat suppression logic (line 31: `!getPressState(key)`) to behave incorrectly, potentially allowing key events to be processed multiple times or ignored.

---

### 4. Build Security

Build Security: no issues found in the audited files (build configuration files were not part of this assignment).

---

### 5. Device and Firmware

**A20-5** · HIGH · Device and Firmware — Unauthenticated access to sensitive device information via hidden key sequences
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/ui/keyfilter.cpp:26-43`
**Description:** As noted in A20-2, two hidden key sequences open a diagnostic screen without any authentication. The information exposed on that screen includes: kernel and rootfs version strings (useful for targeting exploits), GMTP server addresses and ports, APN credentials, modem and WiFi MAC addresses, GPS satellite count and coordinates, Wiegand card IDs, on-demand (super-master) status including operator IDs and session timing, shock sensor thresholds, and SIM card ICCID. The combination of unauthenticated physical access and the breadth of information disclosed represents a significant device and firmware security weakness for a deployed safety-critical proximity detection device.

**A20-6** · INFO · Device and Firmware — Kernel and rootfs version disclosed on information screen
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/ui/informationdialog.cpp:44-63`
**Description:** The constructor reads `/proc/version` and `/home/root_version` and displays both on the System tab. While not independently a vulnerability, exposing the precise kernel version string assists an attacker in identifying known CVEs applicable to the device firmware. This information should be restricted to authenticated maintenance personnel.

---

### 6. Qt-Specific Security

**A20-7** · INFO · Qt-Specific Security — `QProcess` included but not used
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/ui/informationdialog.cpp:6`
**Description:** `#include <QProcess>` is present in `informationdialog.cpp` but no `QProcess` call appears anywhere in the file. This is dead code / an unused include. While not a vulnerability on its own, unused includes that reference process-spawning capabilities may indicate previously removed or future-planned use of `QProcess`. If `QProcess` usage is ever added to this file with arguments derived from the configuration data displayed here (server addresses, ICCID, etc.), it would become a command-injection risk. The include should be removed.

**A20-8** · LOW · Qt-Specific Security — Translation filename from resource file loaded via `QTranslator::load()` without path sanitisation
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/mytranslator.cpp:37, 94`
**Description:** `loadLocalLanguage()` and `updateLocalLanguage()` read a language-to-filename mapping from the embedded Qt resource `:/lang.dat`, split each line on a space, and pass `list[1]` (the filename field) directly to `mTranslator.load(filename)` without any path sanitisation (lines 37 and 94). `QTranslator::load()` accepts both resource paths and filesystem paths, and will attempt to open the file if it is not found as a resource. If an attacker can modify the `:/lang.dat` resource (e.g., via a firmware replacement attack or if the resource is somehow writable at runtime), they could cause `QTranslator::load()` to load a crafted `.qm` file from an arbitrary filesystem path. The risk is mitigated because `:/lang.dat` is an embedded read-only Qt resource in normal builds, but the absence of filename validation is a latent path traversal weakness if the resource origin is ever changed or the binary is tampered with.
# Pass 1 — Auditor A21
**Date:** 2026-02-28
**Branch:** master
**Files reviewed:** ui/lockeddialog.h, ui/lockeddialog.cpp, ui/lockeddialog.ui, ui/messagedialog.h, ui/messagedialog.cpp, ui/messagedialog.ui, ui/onScreenKeyboard.h, ui/onScreenKeyboard.cpp, ui/onScreenKeyboard.ui

---

## Step 4 — Reading Evidence

### File Set 1: lockeddialog

**File paths:**
- `/c/Projects/cig-audit/repos/mark3-pvd/ui/lockeddialog.h`
- `/c/Projects/cig-audit/repos/mark3-pvd/ui/lockeddialog.cpp`
- `/c/Projects/cig-audit/repos/mark3-pvd/ui/lockeddialog.ui`

**Class name and base classes:**
- `LockedDialog : public QDialog`

**Q_OBJECT macro location:**
- `lockeddialog.h:15`

**#include directives:**
- `lockeddialog.h`: `app/globalconfigs.h`, `app/cigconfigs.h`, `<QDialog>`, `<QTimer>`
- `lockeddialog.cpp`: `lockeddialog.h`, `ui_lockeddialog.h`, `platform/pwmbeeper.h`, `platform/seriallogger.h`

**Public methods (with line numbers):**
- `explicit LockedDialog(QWidget *parent = 0)` — h:18
- `~LockedDialog()` — h:19
- `void setLockedReason(CIGCONF::MaintLockedCode lockedCode)` — h:20
- `void languageChanged(void)` — h:21
- `void setTimeRemaining(quint32 secs)` — h:22
- `void clearTimerText()` — h:23
- `void stopTimer()` — h:24
- `void startTimer()` — h:25

**Signals:**
- `void fullLockoutTimerEnded(bool on1, bool on2)` — h:32
- `void beeperOn()` — h:33

**Protected method:**
- `void mouseReleaseEvent(QMouseEvent *) {accept();}` — h:36

**Private methods:**
- `void updateFullLock()` — h:40
- `void fullLockStart()` — h:41

**Member variables:**
- `Ui::LockedDialog *ui` — h:39
- `QTimer *m_fullLockTimer` — h:43
- `quint32 m_timeCntr` — h:44

**UNIT_TEST friend:**
- `friend class TestDialog` — h:28 (conditional on UNIT_TEST)

**UI widgets (lockeddialog.ui):**
- `QDialog` named `LockedDialog` — 800x480
- `QLabel` named `labelReason` — displays locked reason text
- `QLabel` named `label_3` — displays "Machine locked"
- `QLabel` named `label` — displays `not-allowed.png` icon
- `QLabel` named `lblLockOutTime` — displays countdown timer text

---

### File Set 2: messagedialog

**File paths:**
- `/c/Projects/cig-audit/repos/mark3-pvd/ui/messagedialog.h`
- `/c/Projects/cig-audit/repos/mark3-pvd/ui/messagedialog.cpp`
- `/c/Projects/cig-audit/repos/mark3-pvd/ui/messagedialog.ui`

**Class name and base classes:**
- `MessageDialog : public QDialog`

**Q_OBJECT macro location:**
- `messagedialog.h:15`

**#include directives:**
- `messagedialog.h`: `<QDialog>`
- `messagedialog.cpp`: `messagedialog.h`, `ui_messagedialog.h`, `<QMovie>`, `<QTimer>`, `<QDebug>`

**Public methods (with line numbers):**
- `explicit MessageDialog(QWidget *parent = 0)` — h:29
- `~MessageDialog()` — h:30
- `void openWithMessage(MessageType type)` — h:31 (inline: calls `setMessageType(type); open()`)
- `void setMessageType(MessageType type)` — h:33 / cpp:42
- `MessageType messageType() const` — h:34 (inline getter)

**Enum `MessageType`:**
- `NoMessage`, `ExpansionConnecting`, `WaitForAuthorised`, `NotAuthorised`, `OnDemandNotAuthorised`, `PowerOff`, `Reboot`, `VehicleOutOfService` — h:18–27

**Protected method:**
- `void hideEvent(QHideEvent *)` — h:37 / cpp:35

**Member variables:**
- `Ui::MessageDialog *ui` — h:40
- `QTimer *m_timer` — h:42
- `QMovie *m_movie` — h:43
- `MessageType m_messageType` — h:44

**Timing constants (messagedialog.cpp):**
- `WAIT_AUTH_TIME 10000` (10 s) — cpp:7
- `NOT_AUTH_TIME 5000` (5 s) — cpp:8

**UI widgets (messagedialog.ui):**
- `QDialog` named `MessageDialog` — 800x480
- `QLabel` named `labelMsg` — message text display
- `QLabel` named `labelMovie` — animated GIF / pixmap display
- `QPushButton` named `btn` — Cancel button
- `QLabel` named `labelUpper` — upper background area
- `QLabel` named `labelLower` — lower background area

---

### File Set 3: onScreenKeyboard

**File paths:**
- `/c/Projects/cig-audit/repos/mark3-pvd/ui/onScreenKeyboard.h`
- `/c/Projects/cig-audit/repos/mark3-pvd/ui/onScreenKeyboard.cpp`
- `/c/Projects/cig-audit/repos/mark3-pvd/ui/onScreenKeyboard.ui`

**Class name and base classes:**
- `onScreenKeyboard : public QWidget`

**Q_OBJECT macro location:**
- `onScreenKeyboard.h:13`

**#include directives:**
- `onScreenKeyboard.h`: `<QWidget>`, `<QtGui>`, `<QPushButton>`
- `onScreenKeyboard.cpp`: `onScreenKeyboard.h`, `ui_onScreenKeyboard.h`, `<QtGui>`

**Public methods (with line numbers):**
- `explicit onScreenKeyboard(QWidget *parent = 0)` — h:20
- `~onScreenKeyboard()` — cpp:102
- `void setInitialText(QString str)` — h:24 / cpp:56
- `void languageChanged(void)` — h:25 / cpp:248
- `QPushButton *enterButton` — h:22 (public member, not method)

**Enums:**
- `KeyToggleState { Normal, Upper, Lower }` — h:17
- `CaseButton { AllButtons, CapsButton, ShiftButton, SymbolButton }` — h:18
- `CtrlButton { None, Backspace, Delete }` — h:19

**Signals:**
- `void updateText(QString str, CtrlButton ctrl)` — h:36
- `void onScreenKeyboardClose()` — h:37

**Private slots:**
- `void keyboardHandler()` — h:28 / cpp:61
- `void on_btnShift_clicked(bool checked)` — h:29 / cpp:113
- `void on_btnEnter_clicked()` — h:30 / cpp:184
- `void on_btnBack_clicked()` — h:31 / cpp:192
- `void on_btnCaps_toggled(bool checked)` — h:32 / cpp:197
- `void on_btnHideKeyboard_clicked()` — h:33 / cpp:202
- `void on_btnDelete_clicked()` — h:34 / cpp:243

**Protected method:**
- `void closeEvent(QCloseEvent *event)` — h:40 / cpp:107

**Private methods:**
- `void toggle()` — h:43 / cpp:145
- `QString dualCharCase(QString ch, int toggleState)` — h:44 / cpp:127
- `QString singleCharCase(QString ch, int toggleState)` — h:45 / cpp:119
- `void setCaseButton(CaseButton btn, bool set)` — h:46 / cpp:209

**Member variables:**
- `Ui::onScreenKeyboard *ui` — h:47
- `QString outputText` — h:48
- `QString m_capsStylesheet` — h:49
- `QString m_symbolStylesheet` — h:50
- `QString m_shiftStylesheet` — h:51

**UI widgets (onScreenKeyboard.ui):**
- `QWidget` named `onScreenKeyboard` — 800x310, NonModal, windowOpacity=50.0
- Full QWERTY layout: `QPushButton` named `Button{a-z}`, `Button{0-9}`, `space`
- Control buttons: `btnShift` (checkable), `btnCaps` (checkable), `btnBack`, `btnDelete`, `btnEnter`, `btnHideKeyboard`

---

## Step 5 — Security Review

### 1. Memory Safety

**A21-1 · HIGH · Memory Safety**
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/ui/lockeddialog.cpp:87`
**Description:** `m_timeCntr` is declared as `quint32` (unsigned 32-bit). In `updateFullLock()`, the condition is `if (!m_timeCntr--)`. When `m_timeCntr` is 0 at the start of a tick, the post-decrement wraps to `0xFFFFFFFF` (4,294,967,295) before the zero-check fires, and the branch is taken correctly. However, if `fullLockoutTimeout()` returns 0, `m_timeCntr` is initialised to 0 and the very first tick immediately wraps, causing the timer to fire `fullLockoutTimerEnded(false, false)` (relay cut-off) immediately. The comment at cpp:86 acknowledges this: "This will immediately close both relays if Timeout Parameter is zero." The issue is that this is a safety-critical control path: a zero value from a server-supplied configuration causes immediate shutdown of both relays. There is no guard at the call site in `startTimer()` (cpp:26) to prevent starting the full-lockout countdown when the server supplies 0 — the condition `gCfg->fullLockoutEnable() && !m_fullLockTimer->isActive()` does not exclude a zero timeout. If the lock-enable flag is set but timeout is zero, entering the locked state immediately triggers relay cut-off on the next 1-second tick, regardless of operator presence. This is a safety-critical integer edge-case that conflates "no countdown" with "instant shutdown."

**A21-2 · LOW · Memory Safety**
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/ui/onScreenKeyboard.cpp:63`
**Description:** In `keyboardHandler()`, the sender is obtained via `QPushButton *button = (QPushButton *)sender()` using a C-style cast rather than `qobject_cast<QPushButton *>`. If a non-QPushButton object were ever connected to this slot (e.g. through accidental re-use), the unchecked cast would produce a dangling pointer dereference on the subsequent `button->text()` call at cpp:65. The risk is low in this codebase since all connections are explicitly to button widgets, but the pattern is unsafe.

### 2. Communication Security

Communication Security: no issues found within the three assigned files. All message content set in `MessageDialog::setMessageType()` is composed exclusively from `tr()` string literals embedded in the firmware — no content is received from the network and rendered into the dialog. The lock state itself is propagated via `gCfg->maintCode()` and `screenLocked()` signals; the actual server-synchronisation logic is outside the scope of the assigned files.

### 3. Input Handling

**A21-3 · HIGH · Input Handling**
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/ui/onScreenKeyboard.cpp:66`
**Description:** In `keyboardHandler()`, button text is read directly from the widget with `button->text()`, then that raw text is emitted via the `updateText` signal. If the text property of a button is ever sourced from a translated string that resolves to multi-character sequences (or later from a network-supplied language resource), there is no maximum-length validation before the output is assembled. More concretely, the condition at cpp:76 — `else if (inputText == "\\") { outputText = ui->Buttonr->text(); }` — reads the label from `Buttonr` (the letter key) and assigns it as the keyboard output for the backslash character. If the case state of `Buttonr` were ever unexpected, this would silently emit the wrong character. While the immediate impact is a functional bug rather than a direct security vulnerability, the pattern of reading output from widget state rather than a canonical data structure means the output is implicitly trusted to match expectations with no assertion or validation.

**A21-4 · MEDIUM · Input Handling**
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/ui/onScreenKeyboard.cpp:186`
**Description:** The `on_btnEnter_clicked()` handler clears `outputText` to an empty string (`outputText=""`) before closing the keyboard. However, `outputText` is a persistent `QString` member variable. Qt's `QString` does not guarantee that internal buffer memory is zeroed on assignment of an empty string — the previous character data may remain in heap memory. For a general text-input keyboard this is low risk, but `onScreenKeyboard` is used via `CommentDialog` for entry of free-text notes. If an operator has previously typed a sensitive comment (e.g., an unlock reason or incident note), the characters remain recoverable from process memory after the keyboard is dismissed. A secure wipe (e.g., `outputText.fill(QChar(0)); outputText.clear()`) should be applied before closing. The same concern applies to the `QString` local variable `inputText` at cpp:65, which holds individual keystrokes and is left for GC without zeroing.

**A21-5 · MEDIUM · Input Handling**
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/ui/onScreenKeyboard.cpp:66`
**Description:** `keyboardHandler()` calls `QString::split()` with the deprecated overload `QString::SkipEmptyParts` (the non-namespaced form deprecated since Qt 5.14). While not a direct security issue, use of deprecated API indicates code that has not been maintained against current Qt security recommendations and may break without warning on Qt version upgrades on the embedded platform.

### 4. Build Security

Build Security: no issues found within the assigned files. Build flag analysis was covered by other auditors reviewing the `.pro` file; no build-related constructs were observed in the three assigned source pairs.

### 5. Device and Firmware

**A21-6 · CRITICAL · Device and Firmware**
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/ui/lockeddialog.h:36`
**Description:** `LockedDialog::mouseReleaseEvent` is implemented inline in the header as `{accept();}`. This causes any touch or mouse click anywhere on the lock screen to emit the `QDialog::accepted()` signal and dismiss the dialog. In `dialog.cpp:112`, `LockedDialog::accepted` is connected to `Dialog::onPinCode()`, which opens the PIN entry dialog. The design intent is that tapping the lock screen opens the PIN dialog, which is the correct next step. However, the lock screen itself offers no visual affordance for this (no "tap to enter PIN" instruction), and more importantly: the `accepted()` signal triggers unconditionally for any touch event, including swipe-away gestures, accidental contact, or tool-assisted input injection. There is no interstitial check on locked state before transitioning to PIN entry. An operator who does not know the PIN can still dismiss the locked state if they can cause the PIN dialog's `accepted()` signal to fire through any means — the lock-state machine transitions entirely on UI signal emission rather than on verified server-side confirmation. The `m_locked` flag is client-side; it is set at startup from `gCfg->maintCode()` (a local config value) and cleared in `onProcessUnlock()` after PIN flow. If the device were to lose power and restart while `gCfg->maintCode()` had been locally altered, the lock could be bypassed. The safety-critical relay control (`setRelayOut`) is gated on multiple checks deeper in `postLogin()`, so a full bypass is not trivially achievable — but the lock screen UI boundary itself provides weaker protection than its safety-critical context demands.

**A21-7 · HIGH · Device and Firmware**
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/ui/lockeddialog.cpp:79`
**Description:** `fullLockStart()` reads the full-lockout timeout directly from `gCfg->fullLockoutTimeout()` and assigns it to `m_timeCntr` (a `quint32`). This value is sourced from the server via `backgroundworker.cpp` GMTP message handling and is stored in `m_configs` without an observed upper-bound validation in the assigned files. A server-supplied value of `0` causes instant relay cutoff on the next timer tick (see A21-1). A server-supplied value of `0xFFFFFFFF` (4,294,967,295) would cause a countdown lasting approximately 136 years, effectively making the full-lockout feature permanently inoperative. Neither boundary is validated before use in the safety-critical shutdown path.

### 6. Qt-Specific Security

**A21-8 · MEDIUM · Qt-Specific Security**
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/ui/pindialog.ui:505`
**Description:** The PIN entry `QLineEdit` in `PinDialog` uses `QLineEdit::PasswordEchoOnEdit` as its echo mode. This mode displays characters briefly as they are typed before replacing them with masking characters, in contrast to `QLineEdit::Password` which masks immediately. On an embedded touchscreen device without shoulder-surfing mitigation, briefly displayed PIN characters are visible to bystanders. For a vehicle-proximity safety device used in industrial or mining environments where multiple operators may be nearby, this is a meaningful credential exposure risk. The echo mode should be `QLineEdit::Password`. Note: this file (`pindialog.ui`) is included here because it is the credential-entry component directly coupled to the `LockedDialog` flow examined in this review.

**A21-9 · LOW · Qt-Specific Security**
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/ui/onScreenKeyboard.ui:26`
**Description:** The `onScreenKeyboard` widget has `windowOpacity` set to `50.000000000000000` in its `.ui` file. An opacity of 50 (interpreted by Qt as a ratio — effectively this would be applied as the literal double value, but Qt's `setWindowOpacity` takes 0.0–1.0) may be a malformed value from the designer. If Qt interprets this as `50.0` and clamps it to `1.0` (fully opaque), the effect is benign. If the platform interprets the raw value differently, the keyboard could appear fully transparent, making entered characters invisible to the user while still processing input — a usability and potential security concern. This should be verified against the target Qt version's behaviour and set explicitly to `1.0` (fully opaque) for a credential-entry component.
# Pass 1 Security Audit — A22
**Auditor:** A22
**Date:** 2026-02-28
**Branch:** master
**Repository:** mark3-pvd

---

## Step 1 — Branch Verification

```
git -C /c/Projects/cig-audit/repos/mark3-pvd rev-parse --abbrev-ref HEAD
master
```

Branch confirmed: master.

---

## Step 4 — Reading Evidence

### File Set 1: OnDemandDialog

**File paths:**
- `/c/Projects/cig-audit/repos/mark3-pvd/ui/ondemanddialog.h`
- `/c/Projects/cig-audit/repos/mark3-pvd/ui/ondemanddialog.cpp`
- `/c/Projects/cig-audit/repos/mark3-pvd/ui/ondemanddialog.ui`

**Class name and base classes:**
- `OnDemandDialog` : `QDialog`

**Q_OBJECT macro location:**
- `ondemanddialog.h` line 17

**Every #include directive:**
- `ondemanddialog.h`: `<QDialog>`, `<QMap>`, `<QString>`, `<QPushButton>`, `<QTimer>`, `"app/cigconfigs.h"`
- `ondemanddialog.cpp`: `"ondemanddialog.h"`, `"ui_ondemanddialog.h"`, `"app/globalconfigs.h"`, `<QPalette>`

**Every public method with signature and line number:**
- `explicit OnDemandDialog(QWidget *parent = 0)` — h:20
- `~OnDemandDialog()` — h:21
- `void setSuperMasterId(quint64 id)` — h:23 (inline)
- `void reset()` — h:24
- `void setTimeRemaining(quint32 secs)` — h:25
- `QString showCustomTimeFormat(quint32 time)` — h:26

**Every signal:**
- `void onDemandStarted(quint32 start, quint32 end, quint64 id, CIGCONF::OnDemandCmdSrc src = CIGCONF::OnDemandLocal)` — h:29
- `void onDemandExtended(quint32 start, quint32 end, quint64 id, CIGCONF::OnDemandCmdSrc src = CIGCONF::OnDemandLocal)` — h:30
- `void onDemandEnded(quint32 end, quint64 id, CIGCONF::OnDemandCmdSrc src = CIGCONF::OnDemandLocal)` — h:31

**Slots (protected methods used as slots):**
- `void showEvent(QShowEvent *event = 0)` — h:34
- `void onStart()` — h:36
- `void onExtend()` — h:37
- `void onEnd()` — h:38

**Private methods:**
- `bool debounce()` — h:41

**Member variables:**
- `Ui::OnDemandDialog *ui` — h:42
- `QTimer *m_timer` — h:44
- `quint32 m_lastPress` — h:45
- `quint64 m_smId` — h:46

**#define constants (ondemanddialog.cpp):**
- `NO_ACTIVITY_TIME 10000` — cpp:7

**UI widgets (ondemanddialog.ui):**
- `QPushButton btnHide` — closes dialog (accept)
- `QLabel labelMsg` — main message label
- `QPushButton btnStart` — starts on-demand session (initially disabled)
- `QPushButton btnExtend` — extends session (initially disabled)
- `QPushButton btnEnd` — ends session (initially disabled)
- `QLabel label` — describes Start button
- `QLabel label_2` — describes Extend button
- `QLabel label_3` — describes End button

---

### File Set 2: OptionalCheckConfirmationDialog

**File paths:**
- `/c/Projects/cig-audit/repos/mark3-pvd/ui/optionalcheckconfirmationdialog.h`
- `/c/Projects/cig-audit/repos/mark3-pvd/ui/optionalcheckconfirmationdialog.cpp`
- `/c/Projects/cig-audit/repos/mark3-pvd/ui/optionalcheckconfirmationdialog.ui`

**Class name and base classes:**
- `OptionalCheckConfirmationDialog` : `QDialog`

**Q_OBJECT macro location:**
- `optionalcheckconfirmationdialog.h` line 12

**Every #include directive:**
- `optionalcheckconfirmationdialog.h`: `<QDialog>`
- `optionalcheckconfirmationdialog.cpp`: `"optionalcheckconfirmationdialog.h"`, `"ui_optionalcheckconfirmationdialog.h"`, `<QTimer>`, `<QDebug>`

**Every public method with signature and line number:**
- `explicit OptionalCheckConfirmationDialog(QWidget *parent = 0)` — h:15
- `~OptionalCheckConfirmationDialog()` — h:16
- `void onRefreshLanguage(void)` — h:17

**Signals:** None defined.

**Protected methods:**
- `void hideEvent(QHideEvent *)` — h:24
- `void showEvent(QShowEvent *event = 0)` — h:25

**Member variables:**
- `Ui::OptionalCheckConfirmationDialog *ui` — h:20
- `QTimer *m_timer` — h:21

**UI widgets (optionalcheckconfirmationdialog.ui):**
- `QLabel label_2` — lower background gradient label
- `QLabel label` — upper background gradient label
- `QWidget layoutWidget` — container for VBoxLayout
  - `QLabel labelTip11` — "Please confirm that you would like to do"
  - `QLabel labelTip22_2` — "an"
  - `QLabel labelTip21` — " optional " (red text)
  - `QLabel labelTip22` — "pre-op safety check."
- `QPushButton btnYes` — accepts dialog
- `QPushButton btnNo` — rejects dialog

---

### File Set 3: PinDialog

**File paths:**
- `/c/Projects/cig-audit/repos/mark3-pvd/ui/pindialog.h`
- `/c/Projects/cig-audit/repos/mark3-pvd/ui/pindialog.cpp`
- `/c/Projects/cig-audit/repos/mark3-pvd/ui/pindialog.ui`

**Class name and base classes:**
- `PinDialog` : `QDialog`

**Q_OBJECT macro location:**
- `pindialog.h` line 14

**Every #include directive:**
- `pindialog.h`: `<QDialog>` (forward declares `QTimer`)
- `pindialog.cpp`: `"pindialog.h"`, `"ui_pindialog.h"`, `"app/globalconfigs.h"`, `<QDebug>`, `<QTimer>`, `<QThread>`, `<QApplication>`

**Every public method with signature and line number:**
- `explicit PinDialog(QWidget *parent = 0)` — h:17
- `~PinDialog()` — h:18
- `quint32 pinCode() const` — h:20
- `void clearPinCode()` — h:21
- `void languageChanged()` — h:22

**Protected methods (event handlers):**
- `void showEvent(QShowEvent *)` — h:25
- `void hideEvent(QHideEvent *)` — h:26

**Private methods:**
- `void keyPressed()` — h:29

**Member variables:**
- `Ui::PinDialog *ui` — h:31
- `QTimer *m_timer` — h:32

**#define constants (pindialog.cpp):**
- `PIN_MAX_LENGTH 5` — cpp:9
- `ACTIVITY_TIME 30000` — cpp:10

**UI widgets (pindialog.ui):**
- `QWidget layoutWidget` — container for keypad VBoxLayout
  - `QPushButton btn1` through `btn9`, `btn0` — digit keys (text = digit string)
  - `QPushButton btnCancel` — rejects dialog
  - `QPushButton btnClear` — clears input (text = "CLEAR")
  - `QPushButton btnEnter` — accepts dialog
  - `QPushButton btnStar` — key with text "*"
  - `QPushButton btnHash` — key with text "#" (also triggers accept)
  - `QPushButton btnBack` — backspace (text = "DEL")
- `QLabel label` — "Please enter PIN"
- `QLineEdit lineEdit` — stores PIN; maxLength=5; echoMode=`QLineEdit::PasswordEchoOnEdit`
- `QLabel labelPin` — overlapping asterisk masking label (workaround for Helvetica font)

---

## Step 5 — Security Review

### 1. Memory Safety

**A22-1** · LOW · Memory Safety
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/ui/pindialog.cpp:51`
**Description:** The debounce variable `last` inside `keyPressed()` is declared `static quint64 last = 0`. On a single-CPU embedded device this is not a thread-safety issue in practice, but a static local variable persists PIN-entry timing state across all dialog open/close cycles for the lifetime of the process. If `gCfg->clockTime()` ever wraps or returns a value less than the stored `last` value (which is handled on line 54-55 only for the case `last > now`), debounce logic could be bypassed or permanently block input. The condition on line 54 resets `last` only when `last > now`, meaning a wrap scenario where `now` skips past `last` by an amount less than 50ms would not be caught. The risk is low on a stable embedded clock, but the pattern is fragile for an authentication input handler.

**A22-2** · LOW · Memory Safety
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/ui/pindialog.cpp:97`
**Description:** `pinCode()` returns a `quint32`. The PIN value is then cast to `quint64` at the call site (`dialog.cpp:321`). The PIN digits are accumulated via `val *= 10; val += c.toLatin1() - '0'` with no overflow check on `val`. With `PIN_MAX_LENGTH` enforced at 5 digits, the maximum value is 99999, which fits comfortably in `quint32`. However, the `*` button is wired to `keyPressed()` (which inserts the `*` character), and `pinCode()` stops parsing at the first non-digit character. If the asterisk button text ("*") is inserted, the returned PIN will be 0 or a truncated value — silently, without any user feedback — which could enable a brute-force shortcut via the `*` key.

### 2. Communication Security

**A22-3** · HIGH · Communication Security
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/ui/dialog.cpp:546`
**Description:** When a PIN is accepted, `onPinDialogAccepted()` calls `login()`, which immediately emits `sendGmtpMessage(CIGCONF::GMTP_CARD, QByteArray::number(id, 16))` at line 546. The GMTP transport (`comm/gmtpchat.cpp:24`) uses a plain `QTcpSocket`, not `QSslSocket`. There is no TLS wrapping in the GMTP communication layer. The `AesCrypto::encrypt()` function exists in `platform/aescrypto.cpp` but is never called anywhere in the GMTP send path. Consequently, the PIN-derived identifier is transmitted to the server in plaintext hex format over an unencrypted TCP connection on port 4687. Any network observer on the path between the device and `fleetiq.ciifm.com` can capture and replay this value to impersonate a driver.

**A22-4** · MEDIUM · Communication Security
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/platform/aescrypto.cpp:124`
**Description:** A hardcoded AES-CBC initialization vector `\x3d\xaf\xba\x42\x9d\x9e\xb4\x30\xb4\x22\xda\x80\x2c\x9f\xac\x41` is embedded in `aescrypto.cpp` at line 124. A fixed IV with CBC mode destroys semantic security: two identical plaintexts always produce identical ciphertexts, and patterns in the first block are not concealed. Although `AesCrypto::encrypt()` is not currently called in the GMTP path, this function is part of the codebase and may be used for firmware or configuration encryption. A hardcoded IV committed to version control is a security finding regardless of current usage.

### 3. Input Handling

**A22-5** · MEDIUM · Input Handling
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/ui/pindialog.cpp:29`
**Description:** The `*` (star) button is connected to `keyPressed()` and will insert the literal character `"*"` into `ui->lineEdit`. The `pinCode()` method stops digit parsing at the first non-digit character and returns the partial numeric value accumulated up to that point. This means a user (or an attacker with physical access) can submit a partial PIN ending in `*` — for example, entering `123*` will result in `pinCode()` returning 123 — and that truncated value is then passed to `login()`. Depending on whether 123 happens to be a valid driver ID, this may allow PIN bypass. The `*` key should be validated out of the accepted character set or prevented from triggering `accept()`.

**A22-6** · MEDIUM · Input Handling
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/ui/pindialog.cpp:34`
**Description:** The `#` (hash) button is connected directly to `accept()` (line 35 in constructor), not to `keyPressed()`. Pressing `#` immediately submits the dialog regardless of how many digits have been entered, including zero digits. A user pressing `#` on an empty PIN field calls `pinCode()`, which returns 0. If 0 happens to map to a valid or fallback driver identifier (e.g., if the caller does not validate the returned code before calling `login()`), an empty PIN could authenticate. The `pinCode()` return value of 0 should be explicitly rejected before calling `login()`, or `#` should be treated as ENTER (requiring minimum-length validation) rather than as an unconditional submit trigger.

### 4. Build Security

Build Security: no issues found in the reviewed files. The `.pro` file and build configuration were not part of this file assignment. No compiler flags or build-related content appears in the three dialog files reviewed.

### 5. Device and Firmware

**A22-7** · HIGH · Device and Firmware
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/ui/pindialog.cpp:112`
**Description:** After a successful PIN submission, `clearPinCode()` is never called. In `onPinDialogAccepted()` (`dialog.cpp:319-323`), `pinCode()` is read and `login()` is called, but `clearPinCode()` is not invoked. The PIN string remains stored in `ui->lineEdit` until the next time the PIN dialog is opened — at which point `clearPinCode()` is called before `open()` (see `dialog.cpp:272`). Between those two events, the PIN digits remain accessible in the QLineEdit widget's internal buffer. On an embedded device, this buffer lives in process heap memory and is not zeroed. A memory dump of the process (e.g., via `/proc/<pid>/mem`, a crash dump, or a debug port) taken after authentication would expose the previously entered PIN.

**A22-8** · HIGH · Device and Firmware
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/ui/pindialog.cpp:9`
**Description:** There is no rate limiting or brute-force protection on PIN entry attempts. The dialog has a 30-second inactivity timeout (`ACTIVITY_TIME = 30000`) that rejects the dialog if no key is pressed, but there is no count of incorrect PIN submissions and no lockout or delay after a failed attempt. The PIN space is at most 5 decimal digits (0–99999 = 100,000 possible values). An operator with physical access to the device can repeatedly open the PIN dialog (via the lock screen) and attempt different PINs at the rate limited only by the 200ms debounce in `OnDemandDialog` — the PinDialog itself has a 50ms debounce. With automated tapping, exhaustive search of the 5-digit PIN space is feasible.

### 6. Qt-Specific Security

**A22-9** · MEDIUM · Qt-Specific Security
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/ui/pindialog.ui:505`
**Description:** The `QLineEdit` widget (`lineEdit`) in `pindialog.ui` has its `echoMode` set to `QLineEdit::PasswordEchoOnEdit`. This mode shows each character briefly as it is typed before replacing it with a masking character. The comment in `pindialog.cpp` (line 76-78) acknowledges that Helvetica does not contain Qt's password masking character and therefore a `QLabel` (`labelPin`) is used as a visual overlay of asterisks. However, the underlying `QLineEdit` still operates in `PasswordEchoOnEdit` mode — each new digit is briefly visible on screen as it is inserted before the label overlays it. The label overlay does not prevent the `QLineEdit` itself from briefly displaying the typed character, which may be captured by a camera or shoulder-surfing observer. The `echoMode` should be set to `QLineEdit::Password` (always masked) and the custom asterisk label retained for the font workaround.

**A22-10** · LOW · Qt-Specific Security
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/ui/optionalcheckconfirmationdialog.cpp:28`
**Description:** The optional pre-op safety check confirmation dialog has a 5-second auto-reject timer (`m_timer->start(5000)`). When the timer fires, `reject()` is called, meaning the optional check is automatically skipped if the operator does not respond within 5 seconds. This timer applies to a safety-related prompt — "please confirm that you would like to do an optional pre-op safety check." If the intent is to encourage safety checks, defaulting to rejection on timeout works against that intent. If an attacker or inattentive operator is aware of the 5-second timeout, they can simply wait for the dialog to dismiss itself without pressing NO, potentially appearing compliant while the check is bypassed. This is a safety-process concern as well as a security concern.

---

## Summary Table

| Finding | Severity | Category | File |
|---------|----------|----------|------|
| A22-1 | LOW | Memory Safety | `pindialog.cpp:51` |
| A22-2 | LOW | Memory Safety | `pindialog.cpp:97` |
| A22-3 | HIGH | Communication Security | `dialog.cpp:546` |
| A22-4 | MEDIUM | Communication Security | `aescrypto.cpp:124` |
| A22-5 | MEDIUM | Input Handling | `pindialog.cpp:29` |
| A22-6 | MEDIUM | Input Handling | `pindialog.cpp:34` |
| A22-7 | HIGH | Device and Firmware | `pindialog.cpp:112` |
| A22-8 | HIGH | Device and Firmware | `pindialog.cpp:9` |
| A22-9 | MEDIUM | Qt-Specific Security | `pindialog.ui:505` |
| A22-10 | LOW | Qt-Specific Security | `optionalcheckconfirmationdialog.cpp:28` |
# Pass 1 Audit — A23
**Date:** 2026-02-28
**Auditor:** A23
**Branch:** master (confirmed)

---

## Reading Evidence

### File Set 1 — PreopScreenOverlay

**Files:**
- `/c/Projects/cig-audit/repos/mark3-pvd/ui/preopscreenoverlay.h`
- `/c/Projects/cig-audit/repos/mark3-pvd/ui/preopscreenoverlay.cpp`
- `/c/Projects/cig-audit/repos/mark3-pvd/ui/preopscreenoverlay.ui`

**Class:** `PreopScreenOverlay` extends `QDialog`

**Q_OBJECT macro:** Line 12 of `preopscreenoverlay.h`

**Public methods:**
- `explicit PreopScreenOverlay(QWidget *parent = 0)` — constructor (line 15, .h)
- `~PreopScreenOverlay()` — destructor (line 16, .h)
- `void onUpdatePreopTimer(QString time)` — updates the timer label (line 18, .h)

**Signals:** None declared.

**Slots:** None declared.

**#include directives (.h):**
- `<QDialog>`

**#include directives (.cpp):**
- `"preopscreenoverlay.h"`
- `"ui_preopscreenoverlay.h"`

**Member variables:**
- `Ui::PreopScreenOverlay *ui` (private)

**UI widgets (.ui):**
- `PreopScreenOverlay` — `QDialog`, 800x50
- `lblPreopTimer` — `QLabel`, displays "Time Remaining: 00:00:00"

**Notes:**
- `onUpdatePreopTimer` appends externally-supplied `time` string directly to a label (line 13, .cpp). The `time` parameter is a `QString` passed by value with no validation or length check before display. The overlay has no close/dismiss button in the UI file; it is a thin 50px-high strip. No dismiss action is present in the widget itself; dismissal must be managed by the parent.

---

### File Set 2 — SupervisorDialog

**Files:**
- `/c/Projects/cig-audit/repos/mark3-pvd/ui/supervisordialog.h`
- `/c/Projects/cig-audit/repos/mark3-pvd/ui/supervisordialog.cpp`
- `/c/Projects/cig-audit/repos/mark3-pvd/ui/supervisordialog.ui`

**Class:** `SupervisorDialog` extends `QDialog`

**Q_OBJECT macro:** Line 17 of `supervisordialog.h`

**Public methods:**
- `explicit SupervisorDialog(QWidget *parent = nullptr)` — constructor (line 20, .h)
- `~SupervisorDialog()` — destructor (line 21, .h)
- `void setMasterOptions(CIGCONF::MasterId m)` — configures button visibility based on master permissions bitmask (line 23, .h / line 172, .cpp)
- `void setTransportOptions()` — sets transport-mode button visibility (line 24, .h / line 202, .cpp)

**Signals:**
- `void startMasterSession()` — emitted to trigger a master-level unlock session (line 32, .h)
- `void startMaintenanceSession()` — emitted to trigger a maintenance session (line 33, .h)
- `void onVORUpdate()` — emitted after VOR status toggle (line 34, .h)

**Private slots:**
- `void onUnlkVehicle()` — handles Unlock Vehicle button click (line 52, .h / line 88, .cpp)
- `void onNormalDriverAccess()` — handles Normal Driver Access button click (line 53, .h / line 106, .cpp)
- `void onActivateVOR()` — performs VOR toggle after confirmation (line 54, .h / line 144, .cpp)
- `void openConfirmationDialog()` — shows VOR confirmation dialog (line 55, .h / line 126, .cpp)
- `void on_btnMaintenanceMode_clicked()` — handles Maintenance Mode button click (line 56, .h / line 211, .cpp)

**Protected methods:**
- `void showEvent(QShowEvent *event = 0)` — resets UI labels and starts inactivity timer (line 49, .h / line 52, .cpp)

**Private methods:**
- `bool debounce()` — returns false if last press was within 200ms (line 37, .h / line 155, .cpp)
- `void reset()` — clears last press timestamp and resets UI (line 38, .h / line 166, .cpp)

**#include directives (.h):**
- `"app/cigconfigs.h"`
- `<QDialog>`
- `<QTimer>`

**#include directives (.cpp):**
- `"supervisordialog.h"`
- `"ui_supervisordialog.h"`
- `"app/globalconfigs.h"`
- `"ui/vorconfirmationdialog.h"`
- `"ui/warningdialog.h"`

**Member variables:**
- `Ui::SupervisorDialog *ui` (private)
- `QTimer *m_timer` — inactivity auto-close timer, 10000ms (private)
- `QTimer *m_resetTimer` — button-label reset timer, 2000ms (private)
- `quint32 m_lastPress` — timestamp of last button press for debounce (private)
- `CIGCONF::MasterId m_master` — identity and permissions of the current master user (private)
- `VORConfirmationDialog *m_vorConfirmationDialog` (private)
- `WarningDialog *m_maintWarningDialog` (private)
- `WarningDialog *m_warningDialog` (private)

**UI widgets (.ui):**
- `SupervisorDialog` — `QDialog`, 800x480
- `btnActivateVOR` — `QPushButton`, "Activate VOR"
- `btnUnlkVehicle` — `QPushButton`, "Unlock Vehicle"
- `btnNormalDriver` — `QPushButton`, "Normal Driver Access"
- `lblUnlock` — `QLabel` (empty)
- `labelMsg` — `QLabel`, "Supervisor Menu"
- `btnHide` — `QPushButton`, "QUIT"
- `btnMaintenanceMode` — `QPushButton`, "Maintenance Mode"
- `labelDriver` — `QLabel`, "Driver"
- `labelLastSession` — `QLabel`, "Last Session"
- `labelStart` — `QLabel`, "Start"
- `labelEnd` — `QLabel`, "End"

**Macros:**
- `NO_ACTIVITY_TIME 10000` (line 7, .cpp)
- `RESET_TIME 2000` (line 8, .cpp)
- `UNIT_TEST` conditional friend class `TestDialog` (lines 26–28, .h)

---

### File Set 3 — UnlockedDialog

**Files:**
- `/c/Projects/cig-audit/repos/mark3-pvd/ui/unlockeddialog.h`
- `/c/Projects/cig-audit/repos/mark3-pvd/ui/unlockeddialog.cpp`
- `/c/Projects/cig-audit/repos/mark3-pvd/ui/unlockeddialog.ui`

**Class:** `UnlockedDialog` extends `QDialog`

**Q_OBJECT macro:** Line 12 of `unlockeddialog.h`

**Public enum:**
- `Mode { UnlockNoChecklist, UnlockChecklist, UnlockOnly }` (line 15, .h)

**Public methods:**
- `explicit UnlockedDialog(QWidget *parent = 0)` — constructor (line 17, .h)
- `~UnlockedDialog()` — destructor (line 18, .h)
- `void setMode(Mode m)` — configures labels and visibility based on unlock scenario (line 20, .h / line 23, .cpp)
- `void languageChanged()` — updates "OK" label text for language changes (line 21, .h / line 42, .cpp)

**Signals:** None declared.

**Slots:** None declared (btnOk connected directly to `accept()` via lambda in constructor, line 15, .cpp).

**#include directives (.h):**
- `<QDialog>`

**#include directives (.cpp):**
- `"unlockeddialog.h"`
- `"ui_unlockeddialog.h"`
- `"app/globalconfigs.h"`

**Member variables:**
- `Ui::UnlockedDialog *ui` (private)

**UI widgets (.ui):**
- `UnlockedDialog` — `QDialog`, 800x480, white background
- `labelWarning` — `QLabel`, warning icon pixmap
- `btnOk` — `QPushButton`, no text (icon-only OK button)
- `label_3` — `QLabel`, "OK" text label overlaid on button area
- `labelLocked` — `QLabel`, "Machine unlocked"
- `labelTip` — `QLabel`, "Operational check list required\nPress OK to continue"

**Macros:**
- `UNIT_TEST` conditional friend class `TestDialog` (lines 23–25, .h)

---

## Security Review

### 1. Memory Safety

No unsafe C string functions (`strcpy`, `strcat`, `sprintf`, `gets`) are present in the three assigned files. No raw `new` without a corresponding `delete` in the same scope — `ui` pointers are deleted in destructors, and `QTimer`/dialog children are Qt-parented. No `memcpy` or `memmove` calls. No array index access in the assigned files. No integer overflow in buffer size calculations.

Memory Safety: no issues found.

---

### 2. Communication Security

The three assigned files do not contain any direct network communication, TLS configuration, server addresses, hardcoded credentials, or encryption keys. The `GMTP_UNLK` message is emitted from `dialog.cpp` (not in scope), not from these files directly. Within scope, no communication issues exist.

Communication Security: no issues found.

---

### 3. Input Handling

**A23-1** · LOW · Input Handling
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/ui/preopscreenoverlay.cpp:13`
**Description:** `onUpdatePreopTimer(QString time)` concatenates the `time` parameter directly into a `QLabel` with no length validation: `ui->lblPreopTimer->setText(tr("Time Remaining") + ": " + time)`. If the caller passes an arbitrarily long string (e.g., from a corrupt or attacker-influenced timer value), the label will display it in full. While Qt's `QLabel` will not overflow memory on a long string, very long input can cause unexpected UI layout behaviour on a constrained embedded display, potentially obscuring safety-critical proximity alert indicators. The `time` string should be validated to a reasonable length (e.g., HH:MM:SS format) before display.

---

### 4. Build Security

Build Security: no issues found in the assigned files. (Build configuration is assessed against the `.pro` file, which is not in scope for this assignment.)

---

### 5. Device and Firmware — Supervisor Access and Unlock Safety

**A23-2** · HIGH · Device and Firmware — Supervisor Access
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/ui/supervisordialog.cpp:106-124`
**Description:** In `onNormalDriverAccess()`, when the second-press confirmation condition is met, the code calls `m_warningDialog->open()`, immediately followed by `emit startMasterSession()` and `accept()` on the same lines (113–115). The `emit startMasterSession()` fires unconditionally without waiting for the user to acknowledge the `m_warningDialog`. The signal `startMasterSession` is connected in `dialog.cpp` (line 176) to `postLogin()`, which performs the full unlock sequence including setting the relay output and sending `GMTP_UNLK` to the server. The warning dialog's `accepted` signal is also connected to emit `startMasterSession()` (constructor lines 33–36). This means `startMasterSession` is emitted twice for Normal Driver Access: once immediately (before the warning dialog is confirmed), and once when the warning dialog is accepted. This results in the unlock/login flow being triggered before the operator has acknowledged the warning. The double-emission may also cause a double-login condition in `postLogin()`. Compare with `onUnlkVehicle()` (lines 88–104) and `on_btnMaintenanceMode_clicked()` (lines 211–229), which do not have this pattern — they rely entirely on the warning dialog's `accepted` signal and do not emit the session signal unconditionally.

**A23-3** · HIGH · Device and Firmware — Supervisor Access
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/ui/supervisordialog.cpp:88-104`
**Description:** In `onUnlkVehicle()`, the confirmation step relies solely on matching the button label text against the translated string `tr("Confirm?")` (line 93). This is a fragile security gate: if a translation file contains an incorrect or empty string for "Confirm?", or if `showEvent()` is called between the two presses (which it is — line 97 calls `showEvent()` on the first press, resetting the button text to "Unlock Vehicle"), the logic is reset correctly. However, the entire confirmation mechanism is based on UI widget text state rather than an explicit boolean flag. A race between the `m_resetTimer` (2000ms) expiry (calling `reset()` → `showEvent()`) and rapid double-press is the only protection. The debounce window is 200ms, while the reset window is 2000ms; if a user presses twice within 200ms–2000ms, the label will read "Confirm?" and the unlock will proceed. There is no cryptographic or server-side verification that this supervisor is still authorized at the moment of unlock: the authorization check (`containsMasterId`) happens at card swipe time in `dialog.cpp`, and by the time the supervisor menu is shown and the unlock button pressed, no re-verification occurs.

**A23-4** · MEDIUM · Device and Firmware — Unlock Not Server-Verified at Point of Action
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/ui/supervisordialog.cpp:88-104` and `/c/Projects/cig-audit/repos/mark3-pvd/ui/unlockeddialog.cpp:23-40`
**Description:** The supervisor unlock action (`onUnlkVehicle` and `onNormalDriverAccess`) emits `startMasterSession()` which triggers `postLogin()` in `dialog.cpp`. Within `postLogin()`, `GMTP_UNLK` is sent to the server (line 508, `dialog.cpp`) after the relay output has already been set (implicit in `postLogin`). The `UnlockedDialog` is shown as a notification screen only — pressing OK on `UnlockedDialog` simply calls `accept()` (line 15, `unlockeddialog.cpp`), which is connected to `onUnlockedDialogAccepted` in `dialog.cpp`. The local unlock relay is set before server acknowledgment of the `GMTP_UNLK` message. If server connectivity is lost at the moment of unlock, the equipment is physically unlocked without confirmed server-side logging. This is an audit/compliance gap: the unlock state is not synchronized with the server before granting physical access.

**A23-5** · MEDIUM · Device and Firmware — Unlock Dismissal Not Independently Logged
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/ui/unlockeddialog.cpp:15`
**Description:** `UnlockedDialog` presents the user with a confirmation screen after unlock. The OK button is connected directly to `QDialog::accept()` via a lambda, with no logging, no timestamp, and no GMTP message emitted at the moment of dismissal. The unlock screen presents three different modes (`UnlockOnly`, `UnlockChecklist`, `UnlockNoChecklist`) but the act of the operator pressing OK — acknowledging the machine is unlocked — is not separately recorded or reported. An operator could press OK immediately without reading the safety warning, and there is no audit trail of when the unlock acknowledgment occurred.

**A23-6** · MEDIUM · Device and Firmware — VOR Toggle Authenticated Locally Only
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/ui/supervisordialog.cpp:144-153`
**Description:** `onActivateVOR()` modifies VOR (Vehicle Off Road / restriction) status by calling `gCfg->setConvor()` and `gCfg->saveConfigs()` locally, then emits `onVORUpdate()` (which causes a logout in `dialog.cpp` line 182). The VOR state is a safety-critical parameter for a proximity detection device — enabling or disabling it affects whether the system alerts to proximity hazards. The change is persisted to local configuration and the server is notified via `GMTP_CONVOR` (handled elsewhere), but there is no server-side authorization check at the moment of toggle: if the device is offline, the VOR status is changed locally with no server record or rejection mechanism. The `m_master.id` used to identify who made the change is set at menu-open time and is not re-validated at the moment of the VOR change.

---

### 6. Qt-Specific Security

**A23-7** · MEDIUM · Qt-Specific Security — Debug Output Leaks Sensitive Identifiers
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/ui/supervisordialog.cpp:112`
**Description:** `onNormalDriverAccess()` contains `qDebug() << "current driver id " << gCfg->currentDriverId()` which logs the current driver's identifier to the debug output unconditionally. On a production embedded device, if Qt debug output is not completely suppressed (e.g., via `QT_NO_DEBUG_OUTPUT` compile flag or `qInstallMessageHandler` discard), this emits the driver identifier to stderr or a system log. Driver identifiers are personally identifying data and their exposure in debug logs is a privacy and security concern.

**A23-8** · MEDIUM · Qt-Specific Security — Debug Output Leaks Master ID and Permission Bitmask
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/ui/supervisordialog.cpp:174-176`
**Description:** `setMasterOptions()` contains a `qDebug()` call that logs both the master user's ID (in hex) and the permission option bitmask: `qDebug() << QString("setMasterOptions(): id=0x%1; option=0x%2").arg(m.id, 0, 16).arg(m.option, 0, 16)`. This is called every time a master card is swiped, logging the credential identifier and its permissions. If debug output reaches a log file or serial console accessible outside the device, this constitutes exposure of access credential identifiers and capability information to anyone with physical or remote access to device logs.

**A23-9** · LOW · Qt-Specific Security — UNIT_TEST Friend Class Exposes Private State
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/ui/supervisordialog.h:26-28` and `/c/Projects/cig-audit/repos/mark3-pvd/ui/unlockeddialog.h:23-25`
**Description:** Both `SupervisorDialog` and `UnlockedDialog` declare `friend class TestDialog` under `#ifdef UNIT_TEST`. If a build is accidentally produced with `UNIT_TEST` defined in a production or field firmware image, `TestDialog` gains full access to all private members of both classes, including `m_master` (which holds the master user ID and permission bitmask) and the ability to call private slots directly, bypassing the two-press confirmation mechanism. This is a defence-in-depth concern: the `UNIT_TEST` flag should be verified to be absent in all production build configurations.

**A23-10** · LOW · Qt-Specific Security — Debounce Uses `quint32` Clock with Potential Overflow on Non-ARM Builds
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/ui/supervisordialog.cpp:155-163`
**Description:** `debounce()` computes `now - m_lastPress` using `quint32` arithmetic from `gCfg->clockTime()`. On ARM builds, `clockTime()` returns a `quint64` millisecond value from `CLOCK_MONOTONIC` (line 548–555, `globalconfigs.h`). However, `m_lastPress` is declared as `quint32` in `supervisordialog.h` (line 42), meaning the 64-bit value is silently truncated. After approximately 49.7 days of device uptime, the truncated `quint32` will wrap around to zero, causing `now - m_lastPress` to appear as a large positive number regardless of actual elapsed time, effectively disabling the debounce for a brief window. During this window, a user could double-tap in under 200ms without the debounce suppressing the second press. On non-ARM builds `clockTime()` always returns 0 (line 553, `globalconfigs.h`), meaning `now - m_lastPress` is always 0, so `debounce()` always returns false and every button press is suppressed after the first press until `reset()` is called by the timer. This makes the supervisor menu unusable in non-ARM test builds, which may mask integration test failures.
# Pass 1 Audit — A24
**Auditor:** A24
**Date:** 2026-02-28
**Branch:** master (confirmed)
**Files reviewed:**
- `ui/unlockreasondialog.h` / `.cpp` / `.ui`
- `ui/vorconfirmationdialog.h` / `.cpp` / `.ui`
- `ui/vorwarningdialog.h` / `.cpp` / `.ui`

---

## Step 4 — Reading Evidence

### File Set 1: UnlockReasonDialog

**File paths:**
- `/c/Projects/cig-audit/repos/mark3-pvd/ui/unlockreasondialog.h`
- `/c/Projects/cig-audit/repos/mark3-pvd/ui/unlockreasondialog.cpp`
- `/c/Projects/cig-audit/repos/mark3-pvd/ui/unlockreasondialog.ui`

**Class:** `UnlockReasonDialog` extends `QDialog`

**Q_OBJECT:** `unlockreasondialog.h` line 13

**Public methods:**
- `explicit UnlockReasonDialog(QWidget *parent = 0)` — h:16, cpp:5
- `~UnlockReasonDialog()` — h:17, cpp:34
- `QString getReason()` — h:18, cpp:45
- `void languageChanged(void)` — h:19, cpp:50

**Signals:** none declared beyond inherited QDialog signals (accept/reject/finished)

**Slots:**
- `setReason()` (private) — cpp:39

**Includes:**
- h: `<QDialog>`, `<QString>`
- cpp: `"unlockreasondialog.h"`, `"ui_unlockreasondialog.h"`, `<QPushButton>`

**Member variables:**
- `Ui::UnlockReasonDialog *ui` (private)
- `QString m_reason` (private)

**UI widgets:**
- `QLabel lblHeaderText` — header label
- `QPushButton btnDone` — "BACK" button, triggers `reject()`
- `QGroupBox groupBox` — "Red Impact" group containing:
  - `QPushButton btnRedImpact_R1` through `btnRedImpact_R10` (10 preset reason buttons)
- `QGroupBox groupBox_2` — "Preop Checklist Timeout" group containing:
  - `QPushButton btnCheckLockout_R1`, `btnCheckLockout_R2`
- `QGroupBox groupBox_3` — "Preop Checklist Failed" group containing:
  - `QPushButton btnCheckTimeOut_R1`, `btnCheckTimeOut_R2`

**Behaviour:** All 14 reason buttons connect to `setReason()` which reads `sender()->text()` and stores it in `m_reason`, then emits `accept()`. No free-text entry widget is present in this dialog; free-text is handled by the parent `CommentDialog` (`ui/commentdialog.cpp`), where `pteMessageBox` (a `QPlainTextEdit`) is capped at `MAX_CHARACTER = 100` characters (defined in `ui/commentdialog.h:13`).

---

### File Set 2: VORConfirmationDialog

**File paths:**
- `/c/Projects/cig-audit/repos/mark3-pvd/ui/vorconfirmationdialog.h`
- `/c/Projects/cig-audit/repos/mark3-pvd/ui/vorconfirmationdialog.cpp`
- `/c/Projects/cig-audit/repos/mark3-pvd/ui/vorconfirmationdialog.ui`

**Class:** `VORConfirmationDialog` extends `QDialog`

**Q_OBJECT:** `vorconfirmationdialog.h` line 12

**Public methods:**
- `explicit VORConfirmationDialog(QWidget *parent = 0)` — h:15, cpp:6
- `~VORConfirmationDialog()` — h:16, cpp:30
- `void isBeingTurnOn(bool on)` — h:18, cpp:35

**Signals:** none (uses inherited `accepted`, `rejected`, `finished`)

**Slots (protected):**
- `void hideEvent(QHideEvent *)` — cpp:25
- `void showEvent(QShowEvent *event = 0)` — cpp:19

**Includes:**
- h: `<QDialog>`
- cpp: `"vorconfirmationdialog.h"`, `"ui_vorconfirmationdialog.h"`, `"../mytranslator.h"`, `<QTimer>`

**Member variables:**
- `Ui::VORConfirmationDialog *ui` (private)
- `QTimer *m_timer` (private)

**UI widgets:**
- `QLabel label`, `QLabel label_2` — background gradient labels
- `QPushButton btnCancel` — "CANCEL", triggers `reject()`
- `QPushButton btnTurnOn` — "TURN ON"/"TURN OFF", triggers `accept()`
- `QLabel lblNotif` — notification text
- `QLabel lblCornfirm` — confirmation question text (note: typo in widget name "Cornfirm")
- `QLabel lblOn` — "ON" or "OFF" label (displayed in red)

**Behaviour:** Dialog auto-rejects after 10 seconds via `m_timer` started in `showEvent`. `isBeingTurnOn(bool on)` configures labels: when `on=false` (VOR currently off, about to turn on), shows "turn ON"; when `on=true` (VOR currently on, about to turn off), shows "turn OFF". Language-dependent text differences for English vs other languages (English branch shows an incomplete sentence for the confirmation label — "Please confirm that you want to turn VOR mode" — missing "ON" or "OFF").

---

### File Set 3: VORWarningDialog

**File paths:**
- `/c/Projects/cig-audit/repos/mark3-pvd/ui/vorwarningdialog.h`
- `/c/Projects/cig-audit/repos/mark3-pvd/ui/vorwarningdialog.cpp`
- `/c/Projects/cig-audit/repos/mark3-pvd/ui/vorwarningdialog.ui`

**Class:** `VORWarningDialog` extends `QDialog`

**Q_OBJECT:** `vorwarningdialog.h` line 12

**Public methods:**
- `explicit VORWarningDialog(QWidget *parent = 0)` — h:15, cpp:5
- `~VORWarningDialog()` — h:16, cpp:66

**Signals:** none (uses inherited `accepted`, `rejected`)

**Slots (protected):**
- `void hideEvent(QHideEvent *)` — cpp:61
- `void showEvent(QShowEvent *event = 0)` — cpp:17

**Includes:**
- h: `<QDialog>`
- cpp: `"vorwarningdialog.h"`, `"ui_vorwarningdialog.h"`, `<QTimer>`

**Member variables:**
- `Ui::VORWarningDialog *ui` (private)
- `QTimer *m_timer` (private)

**UI widgets:**
- `QLabel labelWarning` — "WARNING" heading
- `QPushButton btnACK` — "ACKNOWLEDGE", triggers `accept()`
- `QTextEdit textEdit` — read-only rich-text area displaying the VOR warning text (`textInteractionFlags: Qt::NoTextInteraction`)

**Behaviour:** On `showEvent`, builds HTML string from translated text segments and sets it on the read-only `QTextEdit`. Timer fires after 30 seconds and calls `reject()`. If the user presses "ACKNOWLEDGE" (`accept()`), the caller in `dialog.cpp:183` calls `openMenuDialog()`, allowing VOR-mode access for masters and tech IDs. If the timer fires and the dialog is `reject()`ed, there is no further action connected in `dialog.cpp` — the dialog silently closes.

---

## Step 5 — Security Review

### 1. Memory Safety

The `setReason()` method in `UnlockReasonDialog` (cpp:41) uses a C-style cast:

```cpp
m_reason = ((QPushButton *)sender())->text();
```

`sender()` is cast from `QObject*` to `QPushButton*` using a C-style cast, bypassing Qt's safe `qobject_cast<>`. If the slot were ever connected to a non-`QPushButton` signal source, this is a type-unsafe access. In this code all connects are explicitly to `QPushButton::clicked`, so the runtime risk is low, but it is a code quality / future-maintenance risk.

No unsafe C string functions (`strcpy`, `sprintf`, `gets`) are used in the three dialog files themselves.

However, the unlock reason string is ultimately passed through `ByteArray::asprintf` (defined in `utils/bytearray.h`) at `backgroundworker.cpp:2346`. That function calls `va_end(ap)` on line 21 of `bytearray.h`, then uses the invalidated `ap` variable with `vsprintf` on line 25 — this is undefined behaviour per C and C++ standards. On most architectures this happens to work because `va_end` is a no-op, but it is formally undefined, and on some ABI implementations (e.g. ARM with AAPCS) it can corrupt state.

---

**A24-1** · HIGH · Memory Safety
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/utils/bytearray.h:21-25`
**Description:** `ByteArray::asprintf` calls `va_end(ap)` on line 21 then passes the now-invalidated `va_list ap` to `vsprintf` on line 25 without calling `va_start` or `va_copy` again. Reuse of a `va_list` after `va_end` is undefined behaviour per the C and C++ standards. This function is used to serialize the unlock reason string for network transmission (`backgroundworker.cpp:2346`) and VOR status messages (`backgroundworker.cpp:2389-2393`). On ARM embedded targets with certain ABIs this can produce garbled output or memory corruption. The fix is to call `va_copy` before `va_end` and use the copy in `vsprintf`, or restructure to avoid the double pass.

---

**A24-2** · LOW · Memory Safety
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/ui/unlockreasondialog.cpp:41`
**Description:** `setReason()` uses a C-style cast `((QPushButton *)sender())->text()` rather than `qobject_cast<QPushButton*>(sender())`. A C-style cast bypasses Qt's runtime type checking. Although all current signal connections in this file are from `QPushButton::clicked`, future maintenance connecting a non-`QPushButton` signal to this slot would silently produce a type-unsafe pointer dereference. `qobject_cast` would return `nullptr` and allow safe handling.

---

### 2. Communication Security

The unlock reason string (`m_reason` / `m_unlkMessage`) is transmitted to the server via the `GMTP_UNLK` message formatted in `backgroundworker.cpp:2340-2347`:

```cpp
ba = ByteArray::asprintf("UNLK=%llX,%X,%X,%llX,%X,%s,%X",
                         gCfg->unlockId(),
                         gCfg->timestamp(),
                         gCfg->maintCode(),
                         gCfg->maintDriverId(),
                         gCfg->maintTimestamp(),
                         gCfg->UnlkReasonString().toLatin1().data(),
                         gCfg->UnlkOption());
```

The VOR state is transmitted via `GMTP_CONVOR` (`backgroundworker.cpp:2388-2393`) triggered whenever `convorStatusChanged` fires (`backgroundworker.cpp:311`). The transmission protocol (GMTP) and whether TLS is used is outside the scope of the assigned files; those were reviewed by other auditors (noted in prior pass1 reports). No hardcoded keys, server addresses, or plaintext credential issues are introduced by the three dialog files themselves.

Communication Security: no issues found in the assigned dialog files. The `ByteArray::asprintf` UB noted above (A24-1) affects the integrity of transmitted UNLK and CONVOR messages.

---

### 3. Input Handling

**Unlock reason (free-text path):** The `UnlockReasonDialog` itself presents only fixed preset buttons — there is no free-text entry in this dialog. The companion `CommentDialog` (`ui/commentdialog.cpp`) wraps `UnlockReasonDialog` and provides a `QPlainTextEdit` (`pteMessageBox`). Character input is capped at `MAX_CHARACTER = 100` in `commentdialog.h:13` and enforced in `commentdialog.cpp:115`. The reason string from the preset buttons is injected into the same text box (`commentdialog.cpp:210`), so all values ultimately pass through `MAX_CHARACTER` enforcement via the on-screen keyboard path.

However, the preset button text is set in `languageChanged()` via `ui->btnRedImpact_R1->setText(tr("..."))`. The `tr()` call passes strings through Qt's translation system. If a translation file were loaded with adversarially long translations for these strings, the 100-character cap in `commentdialog.cpp:115` only applies when the user types character-by-character through the on-screen keyboard. When `onUnlkReasonSelected()` fires (`commentdialog.cpp:205-211`), it calls `insertText(selectedvalue)` without applying the 100-character limit. A translated button label longer than 100 characters would bypass the cap.

---

**A24-3** · MEDIUM · Input Handling
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/ui/commentdialog.cpp:205-211`
**Description:** When a preset unlock reason is selected via `UnlockReasonDialog`, `onUnlkReasonSelected()` directly calls `ui->pteMessageBox->textCursor().insertText(selectedvalue)` without checking the `MAX_CHARACTER` (100) limit that is enforced for on-screen keyboard input. If a translation file provides a button label longer than 100 characters, the reason string stored in `gCfg->setUnlkReasonString()` and subsequently transmitted in the `GMTP_UNLK` message can exceed the expected limit. This may cause truncation or misparse at the server if it applies a fixed-length field assumption, and interacts with the `%s` format specifier in `ByteArray::asprintf` at `backgroundworker.cpp:2346`.

---

**A24-4** · LOW · Input Handling
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/ui/vorconfirmationdialog.cpp:40-43` and `49-52`
**Description:** In `isBeingTurnOn()`, the English language branch (`!lang.compare(langEnglish, ...)`) sets `lblCornfirm` to the incomplete sentence "Please confirm that you want to turn VOR mode" — omitting "ON" or "OFF". This is a display logic defect: the English-language operator sees an ambiguous confirmation message ("turn VOR mode" with no direction stated), while the `lblOn` label shows "ON" or "OFF" separately. An operator may confirm the wrong action. Note: both branches (lines 40-43 and 49-52) produce the same incomplete sentence for English, making the "TURN ON" / "TURN OFF" distinction on `btnTurnOn` the only direction indicator visible to an English-speaking operator — this is a UI/safety concern for a vehicle tag-out operation.

---

### 4. Build Security

Build Security: no issues found in the assigned dialog files. Build flags are governed by the `.pro` file, outside this assignment's scope.

---

### 5. Device and Firmware

**VOR safety parameters:** VOR mode enables/disables vehicle access entirely. There are no VOR threshold calculations in the assigned files — VOR is a binary flag (`convorStatus()`). The threshold and timing parameters that control proximity detection are outside the scope of these dialog files. The VOR confirmation dialog enforces a 10-second auto-reject timeout (hardcoded at `vorconfirmationdialog.cpp:22`). The VOR warning dialog enforces a 30-second auto-reject timeout (hardcoded at `vorwarningdialog.cpp:57`).

---

**A24-5** · MEDIUM · Device and Firmware
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/ui/vorwarningdialog.cpp:13` and `57`
**Description:** The `VORWarningDialog` timer fires after 30 seconds and calls `reject()`. In `dialog.cpp:183`, only the `accepted` signal of `VORWarningDialog` is connected (`connect(m_vorwarningDialog, &VORWarningDialog::accepted, this, &Dialog::openMenuDialog)`). There is no handler for the `rejected` signal. When the 30-second timer elapses and the dialog is dismissed via `reject()`, the dialog closes silently and the waiting master/tech card presentation is abandoned with no further action. This means a VOR-mode vehicle can be accessed by a master/tech who presents their card but fails to press "ACKNOWLEDGE" within 30 seconds — the device returns to an idle locked state, which is safe. However, the absence of any timeout event handler means there is no audit record that the warning was displayed and auto-dismissed without acknowledgement. This gap in the audit trail may be a compliance concern for safety-regulated deployments.

---

**A24-6** · LOW · Device and Firmware
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/ui/vorconfirmationdialog.cpp:22`
**Description:** The VOR confirmation dialog auto-rejects after 10 seconds (hardcoded `m_timer->start(10000)`). This value is not configurable. While auto-reject (rather than auto-accept) is the safe default, the 10-second duration is hardcoded in firmware and cannot be adjusted without a firmware update. This is the safer of the two possible failure modes (auto-reject preserves the locked state), but the hardcoded nature of safety-relevant timing parameters is noted for completeness.

---

### 6. Qt-Specific Security

No `QProcess`, `QSettings`, `eval()`, or `QSslSocket` usage is present in any of the three dialog files. `QTimer` usage is standard and correct. Memory management follows the Qt parent-child ownership pattern (`new QTimer(this)`, `new Ui::...`), with explicit `delete ui` in all three destructors — consistent with Qt convention.

Qt-Specific Security: no issues found.

---

## Summary of Findings

| ID | Severity | Category | Location |
|---|---|---|---|
| A24-1 | HIGH | Memory Safety | `utils/bytearray.h:25` — `va_list` used after `va_end` (UB), affects UNLK and CONVOR message serialization |
| A24-2 | LOW | Memory Safety | `ui/unlockreasondialog.cpp:41` — C-style cast instead of `qobject_cast` |
| A24-3 | MEDIUM | Input Handling | `ui/commentdialog.cpp:210` — preset reason bypass of `MAX_CHARACTER` limit |
| A24-4 | LOW | Input Handling | `ui/vorconfirmationdialog.cpp:40-52` — ambiguous English confirmation label for VOR toggle direction |
| A24-5 | MEDIUM | Device and Firmware | `ui/vorwarningdialog.cpp:57` — timer auto-dismiss produces no audit trail entry |
| A24-6 | LOW | Device and Firmware | `ui/vorconfirmationdialog.cpp:22` — VOR confirmation timeout hardcoded, not configurable |
# Pass 1 Audit — A25
**Auditor:** A25
**Date:** 2026-02-28
**Branch:** master

---

## Reading Evidence

### `/c/Projects/cig-audit/repos/mark3-pvd/ui/warningdialog.h`
- **Class:** `WarningDialog` : `QDialog`
- **Q_OBJECT:** line 14
- **Includes:** `<QDialog>` (line 4)
- **Public methods:**
  - `explicit WarningDialog(WarningDialogType type, QWidget *parent = 0)` — line 17
  - `~WarningDialog()` — line 18
- **Private methods:**
  - `QString showVorWarning()` — line 24
  - `QString showTransportWarning()` — line 25
  - `QString showMaintenanceWarning()` — line 26
- **Protected methods (event overrides):**
  - `void hideEvent(QHideEvent *)` — line 29
  - `void showEvent(QShowEvent *event = 0)` — line 30
- **Member variables:**
  - `Ui::WarningDialog *ui` — line 21
  - `QTimer *m_timer` — line 22
  - `WarningDialogType m_type` — line 23
- **Signals:** none
- **Slots:** none (connections use lambdas/direct method pointers)
- **Enum (file scope):** `WarningDialogType {VOR, Transport, Maintenance}` — line 10

---

### `/c/Projects/cig-audit/repos/mark3-pvd/ui/warningdialog.cpp`
- **Includes:**
  - `"warningdialog.h"` — line 1
  - `"ui_warningdialog.h"` — line 2
  - `<QTimer>` — line 3
- **Constructor** (line 5): allocates `ui` and `m_timer`, connects `btnACK::clicked` to `accept`, connects `m_timer::timeout` to `reject`, sets timer single-shot.
- **showEvent** (line 18): dispatches to type-specific warning builder, sets HTML into `textEdit`, starts 45-second timer.
- **showTransportWarning / showVorWarning / showMaintenanceWarning** (lines 47, 84, 120): build static HTML strings from hardcoded translated text.
- **hideEvent** (line 156): stops the timer.
- **Destructor** (line 161): `delete ui`.

---

### `/c/Projects/cig-audit/repos/mark3-pvd/ui/warningdialog.ui`
- UI class: `WarningDialog` based on `QDialog`, 800x480
- Widgets: `QLabel labelWarning`, `QPushButton btnACK`, `QTextEdit textEdit`
- `textEdit` property `readOnly=true`, `textInteractionFlags=Qt::NoTextInteraction`
- No external connections, no dynamic content slots.

---

### `/c/Projects/cig-audit/repos/mark3-pvd/utils/barcode128.h`
- **Class `BarcodeChar`** (line 7): no base class
  - **Q_OBJECT:** absent
  - Public constructors: default (line 10), copy (line 17), parameterised `(int, QString, QString)` (line 24)
  - `BarcodeChar &operator=(const BarcodeChar &other)` — line 31
  - Private members: `int m_value`, `QString m_name`, `QString m_pattern`
  - `friend class Barcode128` — line 44
- **Class `Barcode128`** (line 47): no base class
  - **Q_OBJECT:** absent
  - **Includes:** `<QPixmap>` (line 4), `<QMap>` (line 5)
  - Public methods:
    - `Barcode128(const QString &info, int height = 100, int sizeMult = 2)` — line 50
    - `~Barcode128()` — line 51
    - `static int width(const QString &info, int sizeMult)` — line 52
    - `QPixmap pixmap()` — line 54
  - Private methods:
    - `void initChar(int value, const QString &name, const QString &pattern)` — line 57
    - `void initChars()` — line 58
    - `void encodeChar(const BarcodeChar &ch)` — line 59
    - `void drawBlackVerticalLineAtPos()` — line 60
    - `void drawEmptyVerticalLineAtPos()` — line 61
  - Member variables:
    - `QMap<int, BarcodeChar> m_valueToChar` — line 63
    - `QMap<QString, BarcodeChar> m_nameToChar` — line 64
    - `QImage *m_image` — line 66
    - `int m_pos` — line 67
    - `int m_sizeMult` — line 68
  - Macros: `START_CODE 104`, `END_CODE 106`, `MODULO_VAL 103`

---

### `/c/Projects/cig-audit/repos/mark3-pvd/utils/barcode128.cpp`
- **Includes:** `"barcode128.h"` (line 1), `<QImage>` (line 2), `<QDebug>` (line 3)
- Constructor (line 9): calls `width()` to size image, draws 15 leading quiet-zone columns, encodes START_CODE, iterates over every QChar in `info` encoding each, accumulates checksum, encodes checksum and STOP characters, draws 15 trailing quiet-zone columns.
- `width()` (line 320): returns `(info.length() * 11 + 13 + 11 + 11) * sizeMult + 30`

---

### `/c/Projects/cig-audit/repos/mark3-pvd/utils/bytearray.h`
- **Class `ByteArray`** (line 13): no base class, no Q_OBJECT
- **Includes:** `<QByteArray>` (line 4)
- **Macros:**
  - `LE_INT(c1,c2,c3,c4)` — line 6: `(c4) << 24 | (uchar)(c3) << 16 | (uchar)(c2) << 8 | (uchar)(c1)`
  - `BE_INT(c1,c2,c3,c4)` — line 7: `(c1) << 24 | (uchar)(c2) << 16 | (uchar)(c3) << 8 | (uchar)(c4)`
  - `LE_SHORT(c1,c2)` — line 8: `(c2) << 8 | (uchar)(c1)`
  - `BE_SHORT(c1,c2)` — line 9: `(c1) << 8 | (uchar)(c2)`
  - `BE_LONG(c1..c8)` — line 11: `((((quint64)BE_INT(c1,c2,c3,c4))<<32) | (quint32)BE_INT(c5,c6,c7,c8))`
- **Static methods:**
  - `static QByteArray asprintf(const char *cformat, ...)` — line 16
  - `static int sscanf(const QByteArray &ba, const char *cformat, ...)` — line 30
- **Member variables:** none (pure static utility class)

---

## Security Review

### 1. Memory Safety

**A25-1** · CRITICAL · Memory Safety
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/utils/bytearray.h:25`
**Description:** `ByteArray::asprintf` calls `va_end(ap)` at line 22 after the first `vsnprintf` call, then calls `vsprintf(ba.data(), cformat, ap)` at line 25 using the same `va_list` after it has already been ended. Accessing a `va_list` after `va_end` is undefined behaviour in C++. The second varargs call must use a separately initialised `va_list` (i.e. call `va_start` again, or use `va_copy`). Additionally, `vsprintf` is used for the second call instead of `vsnprintf`, meaning there is no bounds check on the write into `ba.data()` even though the buffer was sized to exactly the output of the first dry-run. Any mismatch (e.g. a format argument that changes between calls on certain platforms or if `size` calculation is off by one for the null terminator) will write one byte past the allocated buffer.

**A25-2** · HIGH · Memory Safety
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/utils/bytearray.h:6`
**Description:** In the `LE_INT` and `BE_INT` macros, the first argument (`c4` in `LE_INT`, `c1` in `BE_INT`) is shifted left by 24 bits without first being cast to an unsigned 32-bit type. If the argument is of type `int` or `char` and its value has bit 7 set, the shift produces a signed integer overflow, which is undefined behaviour in C++. Only the remaining arguments are cast to `uchar` before their shifts. The fix is to cast the first argument to `quint32` before the shift, consistent with how the other arguments are handled.

**A25-3** · HIGH · Memory Safety
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/utils/bytearray.h:11`
**Description:** In the `BE_LONG` macro, the high 32-bit word is cast to `quint64` before shifting left by 32, which is correct. However, the low 32-bit word is cast to `quint32` before being OR'd in: `(quint32)BE_INT(c5,c6,c7,c8)`. If `BE_INT` produces a negative `int` value, casting to `quint32` before OR'ing into a `quint64` will zero-extend correctly on most platforms, but the reliance on implementation-defined signed-to-unsigned conversion is fragile. More critically, if a caller passes the result of `BE_LONG` into a context expecting a signed type, the high bit silently produces a negative value. This is a latent data-integrity defect in binary protocol parsing.

**A25-4** · HIGH · Memory Safety
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/utils/barcode128.cpp:322`
**Description:** `Barcode128::width()` computes `(info.length() * 11 + 13 + 11 + 11) * sizeMult + 30`. `info.length()` returns `int`. For a string of approximately 195 million characters, `info.length() * 11` overflows a 32-bit signed integer. With `sizeMult = 2` the overflow threshold is approximately 97 million characters. There is no maximum-length check on `info` anywhere before this calculation or before the `new QImage(width(info, sizeMult), height, ...)` allocation. An attacker or misconfigured server supplying an oversized barcode string can trigger integer overflow leading to a very small (or negative) image allocation, followed by out-of-bounds pixel writes in the draw loop. On an embedded device with limited memory this can corrupt adjacent heap memory.

**A25-5** · MEDIUM · Memory Safety
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/utils/barcode128.cpp:28`
**Description:** The checksum accumulation `checksum += ch.m_value * (++i)` uses `int` arithmetic with no upper bound on the loop counter `i` or on `info.length()`. For a very long input string, `ch.m_value * i` (max character value 102, no length limit) will eventually overflow `int`. While the 45-second timer in the UI implies barcodes are generated from device-local data, the lack of any length guard is an input validation defect.

### 2. Communication Security

Communication Security: no issues found.

### 3. Input Handling

**A25-6** · HIGH · Input Handling
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/utils/bytearray.h:16`
**Description:** `ByteArray::asprintf` accepts a caller-supplied format string (`cformat`) which is passed directly to `vsnprintf` and `vsprintf`. Although the method is labelled "not recommended" in a comment, it is a public static method available throughout the codebase. If any call site passes a format string derived from network-received or configuration-file data rather than a string literal, this is a format-string vulnerability allowing arbitrary memory read and write. The method provides no mechanism to enforce that the format string is a literal.

**A25-7** · MEDIUM · Input Handling
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/utils/barcode128.cpp:26`
**Description:** When a character from `info` is not present in `m_nameToChar`, `QMap::operator[]` inserts and returns a default-constructed `BarcodeChar` with `m_value = -1` and `m_pattern = "1111111"`. The encoding loop silently encodes this invalid character without any error, warning, or rejection of the input. The invalid `m_value = -1` is then included in the checksum calculation. There is no validation that `info` contains only characters supported by the selected Code 128 variant (Code B, for `START_CODE == 104`), and no length limit is enforced before the barcode image is allocated.

### 4. Build Security

Build Security: no issues found in the files assigned to this auditor. (Build configuration files were not part of this assignment.)

### 5. Device and Firmware

**A25-8** · HIGH · Device and Firmware — Warning Dismissal Safety
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/ui/warningdialog.cpp:43`
**Description:** The warning dialog shown for safety-critical mode changes (VOR mode, Transport mode, Maintenance mode) is connected via `m_timer` to automatically call `reject()` after 45 seconds (`m_timer->start(45000)`). `reject()` dismisses the dialog with a rejected result, which in Qt's modal dialog model allows the parent application to continue. An operator who does not acknowledge the safety warning — whether by inattention, incapacitation, or deliberate bypass by simply waiting — will have the dialog dismissed automatically after 45 seconds. For a safety-critical warning on a vehicle proximity detection device, auto-dismissal without acknowledgement creates a hazard scenario: the device continues into the restricted operating mode (VOR, transport, maintenance) without the operator having read or acknowledged the warning. The `reject` path is also reachable programmatically if any other widget or event triggers rejection. The `accept` path (acknowledgement button) should be the only path to dismissal.

### 6. Qt-Specific Security

**A25-9** · MEDIUM · Qt-Specific Security
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/ui/warningdialog.h:30`
**Description:** `showEvent` is declared as `void showEvent(QShowEvent *event = 0)` with a default null pointer argument. The Qt virtual override `QWidget::showEvent(QShowEvent *)` does not have a default argument. Adding a default argument to a virtual override is legal C++ but creates a discrepancy: if the dialog is ever shown through a base-class pointer (`QWidget *w = dialog; w->show()`), the base-class virtual dispatch still calls the derived implementation correctly, but the default-argument annotation is misleading and can cause confusion. More concretely, the implementation immediately calls `Q_UNUSED(event)` and ignores the event pointer entirely, meaning the method never passes the event to `QDialog::showEvent()`. Failing to call the base class `showEvent` prevents Qt from performing its standard show-event handling (geometry restoration, activation, etc.), which can produce unexpected UI behaviour in some deployment scenarios.

---
# Pass 1 Security Audit — A26
**Repository:** mark3-pvd
**Branch:** master
**Auditor:** A26
**Date:** 2026-02-28

---

## Reading Evidence

### File: `/c/Projects/cig-audit/repos/mark3-pvd/utils/logger.h`

**Class:** `Logger` — no base class (not a QObject)

**Public methods:**
- `static Logger* instance()` — line 13
- `void close()` — line 14
- `void setLogThreshold(LogLevel level)` — line 15
- `LogLevel logThreshold() const` — line 16
- `void log(LogLevel level, const QString &message)` — line 17

**Protected methods:**
- `Logger()` — line 20 (constructor)
- `virtual ~Logger()` — line 21 (destructor)
- `static void logMessageHandler(QtMsgType type, const QMessageLogContext &context, const QString &msg)` — line 22

**Signals:** none
**Slots:** none

**#include directives:**
- `<QMutex>` — line 4
- `<QFile>` — line 5
- `<QTextStream>` — line 6

**Q_OBJECT macro:** not present

**Member variables (private):**
- `static Logger *m_instance` — line 25
- `static QMutex m_mutex` — line 26
- `QFile m_file` — line 28
- `QTextStream m_outStream` — line 29
- `LogLevel m_logThreshold` — line 30
- `QtMessageHandler m_oldHandler` — line 31

**Enum defined at file scope:**
- `LogLevel { LogDebug, LogInfo, LogWarning, LogCritical, LogFatal, LogNone }` — line 8

---

### File: `/c/Projects/cig-audit/repos/mark3-pvd/utils/logger.cpp`

**Class:** `Logger` (implementation of logger.h)

**#include directives:**
- `"logger.h"` — line 1
- `<QCoreApplication>` — line 3
- `<QMutexLocker>` — line 4
- `<QDateTime>` — line 5
- `<QDir>` — line 6

**Macro defined:**
- `#define LOG_FILE_DIR "/mnt/sd"` — line 8

**Static member initializations:**
- `Logger* Logger::m_instance = nullptr` — line 10
- `QMutex Logger::m_mutex` — line 11

**Method implementations:**
- `Logger::Logger()` constructor — lines 13–44
- `Logger::~Logger()` destructor — lines 46–52
- `Logger* Logger::instance()` (singleton, non-thread-safe) — lines 54–59
- `void Logger::close()` — lines 61–68
- `void Logger::setLogThreshold(LogLevel level)` — lines 70–73
- `LogLevel Logger::logThreshold() const` — lines 75–78
- `void Logger::log(LogLevel level, const QString &msg)` — lines 80–115
- `void Logger::logMessageHandler(QtMsgType type, const QMessageLogContext &context, const QString &msg)` — lines 117–147

**Key observations in constructor (lines 13–44):**
- Log file directory hardcoded to `/mnt/sd` (line 8)
- Log file name constructed as `"log" + yyyy.MM.dd + ".txt"` (lines 16–18)
- Log rotation: keeps 7 files, removes oldest when count >= 7 (lines 20–24)
- Platform guard: on ARM, writes to `/mnt/sd/log<date>.txt`; otherwise writes to `log.txt` (lines 29–33)
- File opened with `QIODevice::ReadWrite | QIODevice::Append` (line 35)
- Qt message handler installed via `qInstallMessageHandler` (line 43)

**Key observations in `log()` (lines 80–115):**
- Message received as `const QString &msg`
- Output assembled by QString concatenation only; no `printf`-style format string used
- Writes to `m_outStream` via `<<` operator (line 114)
- Protected by `QMutexLocker` (line 85)

---

### File: `/c/Projects/cig-audit/repos/mark3-pvd/utils/zconf.h`

**Purpose:** zlib configuration header
**#include directives (conditional):**
- `<stddef.h>` — line 254 (when STDC defined, for `size_t`)
- `<limits.h>` — line 420 (when !Z_SOLO && STDC, for `UINT_MAX`)
- `<sys/types.h>` — line 446 (when STDC && !Z_SOLO, for `off_t`)
- `<stdarg.h>` — line 452 (when STDC || Z_HAVE_STDARG_H && !Z_SOLO, for `va_list`)
- `<stddef.h>` — line 458 (when _WIN32 && !Z_SOLO, for `wchar_t`)
- `<unistd.h>` — line 484 (when Z_HAVE_UNISTD_H && !Z_SOLO, for `SEEK_*`, `off_t`)
- `<windows.h>` — line 354 (when ZLIB_WINAPI)

**No Q_OBJECT macro. No class definitions. No methods.**

**Key type definitions:**
- `Byte` = `unsigned char`
- `uInt` = `unsigned int`
- `uLong` = `unsigned long`
- `Bytef`, `charf`, `intf`, `uIntf`, `uLongf` — FAR-qualified variants
- `voidpc`, `voidpf`, `voidp`
- `z_crc_t` — `Z_U4` or `unsigned long`
- `z_size_t` — `size_t` or `unsigned long`
- `z_off_t` — `off_t` or `long`
- `z_off64_t` — `off64_t`, `__int64`, or `z_off_t`

---

### File: `/c/Projects/cig-audit/repos/mark3-pvd/utils/zlib.h`

**Purpose:** zlib compression library public API header

**zlib version defined:**
- `ZLIB_VERSION "1.3.1"` — line 40
- `ZLIB_VERNUM 0x1310` — line 41
- `ZLIB_VER_MAJOR 1`, `ZLIB_VER_MINOR 3`, `ZLIB_VER_REVISION 1`, `ZLIB_VER_SUBREVISION 0` — lines 42–45
- File header comment: "version 1.3.1, January 22nd, 2024" — line 2

**#include directives:**
- `"zconf.h"` — line 34

**Major API functions declared:**
- `zlibVersion(void)` — line 220
- `deflate(z_streamp strm, int flush)` — line 250
- `deflateEnd(z_streamp strm)` — line 363
- `inflate(z_streamp strm, int flush)` — line 401
- `inflateEnd(z_streamp strm)` — line 521
- `deflateSetDictionary(z_streamp strm, const Bytef *dictionary, uInt dictLength)` — line 611
- `deflateGetDictionary(z_streamp strm, Bytef *dictionary, uInt *dictLength)` — line 655
- `deflateCopy(z_streamp dest, z_streamp source)` — line 677
- `deflateReset(z_streamp strm)` — line 695
- (additional advanced functions continue beyond line 695: deflateParams, deflateTune, deflateBound, deflatePending, deflatePrime, deflateSetHeader, deflateInit2_, inflateSetDictionary, inflateGetDictionary, inflateSync, inflateSyncPoint, inflateReset, inflateReset2, inflatePrime, inflateMark, inflateGetHeader, inflateBack, inflateBackEnd, zlibCompileFlags, compress, compress2, compressBound, uncompress, uncompress2, gz* family, adler32*, crc32*, zError)

**Key structs:**
- `z_stream` / `z_stream_s` — lines 86–106
- `gz_header` / `gz_header_s` — lines 114–129

**No Q_OBJECT macro. No C++ class definitions.**

---

## Security Review

### 1. Memory Safety

**A26-1** · LOW · Memory Safety
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/utils/logger.cpp:54`
**Description:** The `instance()` singleton factory is not thread-safe. It performs a null check on `m_instance` and then assigns it without holding `m_mutex`. If two threads call `instance()` concurrently before initialization completes, both may evaluate `!m_instance` as true and construct two `Logger` objects, causing a double-construction race and a memory leak of one instance. In a Qt embedded application where threads may call `qDebug()` or `qWarning()` before the logger is fully initialized, this is a realistic race. The `QMutexLocker` guard is only applied inside `log()`, not in `instance()`.

No unsafe C string functions (`strcpy`, `strcat`, `sprintf`, `gets`) are present in logger.cpp or logger.h. No raw `new` without delete is present beyond the intentional singleton pattern (which does have a matching `delete` in `close()`). No `memcpy` or `memmove` calls. No buffer size calculations from external data.

---

### 2. Communication Security

No network communication, TLS configuration, certificate handling, hardcoded server addresses, API keys, or encryption keys appear in the four assigned files. zlib is a compression library; its presence does not itself represent a communication security issue.

Communication Security: no issues found in these four files.

---

### 3. Input Handling

**A26-2** · INFO · Input Handling
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/utils/logger.cpp:80`
**Description:** The `log()` method accepts the message as a `const QString &msg` and concatenates it via `output += msg` (line 113), then writes it to a `QTextStream` using the `<<` operator (line 114). This is safe — no `printf`-style format string is used, so there is no format string vulnerability. The Qt message handler (`logMessageHandler`) similarly passes the already-formatted `msg` string directly to `log()` without treating it as a format string. This is documented here as a positive finding: the implementation is safe with respect to format string injection.

No deserialization, no network input parsing, and no configuration file parsing are present in these four files.

---

### 4. Build Security

Build Security: no issues found in the assigned files. (The `.pro` file is not among the assigned files for this auditor; build flag coverage is assigned elsewhere.)

---

### 5. Device and Firmware

**A26-3** · MEDIUM · Device and Firmware
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/utils/logger.cpp:8`
**Description:** The log file directory is hardcoded as `/mnt/sd` via a compile-time `#define LOG_FILE_DIR "/mnt/sd"`. This is a mount point for what is presumed to be a removable SD card. If the SD card is absent, unmounted, or full, `m_file.open()` will fail silently (the constructor returns without error at line 36), and all subsequent calls to `log()` are silently discarded. There is no fallback logging destination (e.g. stderr, syslog, or internal flash), no alert to the application, and no error reported to the caller. On an embedded proximity-detection device where logs are the primary post-incident diagnostic tool, silent log loss is a safety concern.

**A26-4** · LOW · Device and Firmware
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/utils/logger.cpp:22`
**Description:** The log rotation logic at lines 22–24 removes the oldest log file only when the count reaches 7 and the newest file name differs from today's file name. The condition `logs.size() >= 7 && logs.last() != fileName` means that if the SD card fills up within a single day (i.e., `logs.last() == fileName`), no rotation occurs and the current log file continues to grow unboundedly until the filesystem is full. On an embedded device with a small SD card, a verbose logging run (e.g. during an extended event or fault condition) could exhaust available disk space within a single calendar day, causing the SD card to fill completely. This could affect other filesystem operations on the device.

**A26-5** · INFO · Device and Firmware
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/utils/logger.cpp:29`
**Description:** The platform guard `#ifdef __arm__` at lines 29–33 directs ARM builds to log to the SD card at `/mnt/sd/log<date>.txt` and non-ARM (development/CI) builds to log to `log.txt` in the current working directory. The development log path is relative, meaning it will be created in whatever the current working directory is when the process starts. On developer workstations this is benign, but if a non-ARM build were ever deployed to a device this could result in log files scattered in unexpected locations.

**A26-6** · INFO · Device and Firmware — zlib version
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/utils/zlib.h:40`
**Description:** The bundled zlib headers declare version 1.3.1 (released January 22, 2024). This is the most recent release of zlib as of the audit date. It is not subject to CVE-2022-37434 (fixed in 1.2.12) or CVE-2023-45853 (fixed in 1.3.1). No known CVEs apply to this version. Recorded for completeness.

---

### 6. Qt-Specific Security

**A26-7** · MEDIUM · Qt-Specific Security
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/utils/logger.cpp:35`
**Description:** The log file is opened with `QIODevice::ReadWrite | QIODevice::Append` (line 35). The `ReadWrite` flag grants both read and write access to the file descriptor. For a write-only append log, `QIODevice::WriteOnly | QIODevice::Append` would be sufficient and would follow the principle of least privilege. Using `ReadWrite` unnecessarily broadens the file access mode, which on a multi-process embedded Linux system could allow another thread or process sharing the file descriptor (e.g. via `fork`) to seek and read previously written log entries, including any sensitive operational data logged by higher-level application code.

**A26-8** · LOW · Qt-Specific Security
**File:** `/c/Projects/cig-audit/repos/mark3-pvd/utils/logger.h:22`
**Description:** The `Logger` class does not use the `Q_OBJECT` macro and therefore is not a `QObject`. The `logMessageHandler` is a plain static function installed via `qInstallMessageHandler`. This is architecturally acceptable, but the class destructor restores the previous message handler (`qInstallMessageHandler(m_oldHandler)` at line 51 of logger.cpp). If `Logger::close()` is called from one thread while another thread is in the middle of dispatching a Qt message through the installed handler, there is a TOCTOU window where the handler pointer has been replaced but an in-flight call is still executing against the now-deleted `Logger` instance. This is a use-after-free risk in multi-threaded applications.

---

## Pass 2 — Test Coverage Findings

# Pass 2 – Test Coverage Audit
**Agent ID:** A01
**Audit Run:** 2026-02-28-01
**Branch confirmed:** master
**Files assigned:**
- `.gitignore`
- `run_tests`
- `netcfg.json`

---

## Reading Evidence

### 1. `.gitignore`

**Purpose:** Specifies intentionally untracked files that Git should ignore for this repository.

**All entries (line numbers):**

| Line | Rule | Effect |
|------|------|--------|
| 1 | `Makefile` | Ignores the generated `Makefile` (qmake output) |
| 2 | `FleetFocus` | Ignores the compiled test binary produced by `mk3-test.pro` |
| 3 | `.*` | Ignores all dot-files/dot-directories (except those explicitly negated) |
| 5 | `/tmp` | Ignores a top-level `tmp/` directory |
| 7 | `!.gitignore` | Negation — un-ignores `.gitignore` itself (overrides line 3) |
| 8 | `*.bak` | Ignores all backup files |

**Coverage gap observations:**
- `netcfg.json` is NOT listed in `.gitignore`. It is tracked in git and contains plaintext Wi-Fi credentials. There is no rule that would prevent future credential files of the same type from being committed.
- The `.*` wildcard on line 3 would suppress any attempt to add a `.env` or similar secrets file, but it has no bearing on `netcfg.json`.
- No test file in `test/` references `.gitignore`. There are no tests that verify the ignore rules protect sensitive file patterns.

---

### 2. `run_tests`

**Purpose:** Shell convenience script that executes the compiled `FleetFocus` test binary and colorises its output via `awk`.

**All script commands (line numbers):**

| Line | Command / construct | Description |
|------|---------------------|-------------|
| 1 | `#!/bin/sh` | POSIX sh shebang |
| 2 | `./FleetFocus \| awk '...'` | Runs test binary, pipes stdout to awk for colourisation |
| 3 | `/PASS/ {print "\033[32m" $0 "\033[0m"}` | Colours PASS lines green |
| 4 | `/FAIL/ {print "\033[31m" $0 "\033[0m"}` | Colours FAIL lines red |
| 5 | `/DEBUG/ {print $0}` | Passes DEBUG lines through unchanged |
| 6 | `/WARN/ {print $0}` | Passes WARN lines through unchanged |
| 7 | `!/PASS\|FAIL\|DEBUG\|WARN/ {print $0}` | Passes all other lines through unchanged |

**Coverage gap observations:**
- The script exits with the exit code of `awk` (always 0 on normal completion), not the exit code of `FleetFocus`. The pipe `./FleetFocus | awk` causes the shell to lose the test binary's exit code. A CI system invoking `run_tests` would always see exit 0 regardless of test failures.
- There are no tests that exercise or verify `run_tests` itself.
- No CI/CD pipeline configuration file (`.yml`, `.yaml`, Jenkinsfile, Bitbucket pipeline, etc.) was found in the repository. `run_tests` is not integrated into any automated pipeline.
- The `FleetFocus` binary (the target of the script) is not present in the working tree — it is produced at build time and correctly excluded by `.gitignore` line 2. However, the absence of the binary means `run_tests` would silently fail if executed without a prior build step; there is no guard or error message for this case.
- The script has CRLF line endings (`\r\n`) despite the `#!/bin/sh` shebang. On Linux/embedded targets this may cause `run_tests: not found` or syntax errors when the shebang line is parsed with a trailing `\r`.

---

### 3. `netcfg.json`

**Purpose:** Wi-Fi network provisioning configuration. Embedded into the Qt resource bundle (`mk3.qrc`) and listed in DISTFILES in both `mk3.pro` and `mk3-test.pro`. Provides the SSID and pre-shared key for the device's Wi-Fi connection.

**All configuration entries (line numbers):**

| Line | Key | Value |
|------|-----|-------|
| 2 | `password` | `P@ssMK3!` (plaintext Wi-Fi pre-shared key) |
| 3 | `ssid` | `cigSecureConnect` |

**Coverage gap observations:**
- No test file in `test/` references `netcfg.json`, its keys (`password`, `ssid`), or its values. There are zero tests for the parsing, loading, validation, or application of this file's contents.
- The file has been present in git history since commit `5fdc821` and was updated in commit `2adcd83`. Both commits embed the same plaintext credential.
- There are no tests that verify the credential is not empty, meets a minimum length/complexity policy, or that the JSON is well-formed before use.
- There are no tests that confirm the file is not accessible at runtime to unprivileged processes.

---

## Findings

**A01-1** · HIGH · Test Coverage – Missing test for `run_tests` exit code propagation
**File:** `C:/Projects/cig-audit/repos/mark3-pvd/run_tests:2`
**Description:** The script pipes `./FleetFocus` through `awk` for colourisation. Because the pipeline's exit status is the exit code of `awk` (always 0 on normal exit), any CI invocation of `run_tests` will report success even when all tests fail. The test binary's exit code is silently discarded. There is no test or automated check that verifies the runner correctly signals failure to its caller.
**Fix:** Use `pipefail` (`set -o pipefail` at the top of the script, then change shebang to `#!/bin/bash` or verify the target shell supports it) so the script exits non-zero if `FleetFocus` exits non-zero. Alternatively, capture the exit code manually: run `./FleetFocus > /tmp/test_out 2>&1; rc=$?; awk '...' /tmp/test_out; exit $rc`. Add a smoke test to the CI pipeline that runs `run_tests` with a known-failing binary and asserts exit code is non-zero.

---

**A01-2** · HIGH · Test Coverage – No tests for `netcfg.json` parsing or validation
**File:** `C:/Projects/cig-audit/repos/mark3-pvd/netcfg.json:1`
**Description:** The Wi-Fi provisioning file `netcfg.json` is embedded in the Qt resource bundle and used at runtime, but no test in the `test/` directory references this file, its keys, or the code that reads it. There are no tests verifying the file is valid JSON, that required fields (`ssid`, `password`) are present and non-empty, or that the loaded values are applied correctly to the Wi-Fi subsystem.
**Fix:** Write unit tests (e.g., in `test_dialog.cpp` or a new `test_netcfg.cpp`) that: (1) parse `netcfg.json` and assert the required keys exist and are non-empty strings; (2) test the consumer code (wifi configuration logic) with valid and invalid inputs; (3) assert graceful failure when the file is absent or malformed.

---

**A01-3** · MEDIUM · Test Coverage – `netcfg.json` not excluded from version control; no `.gitignore` rule protects secrets files
**File:** `C:/Projects/cig-audit/repos/mark3-pvd/.gitignore:1`
**Description:** `netcfg.json` contains a plaintext Wi-Fi password and is committed to the repository (tracked since `5fdc821`). The `.gitignore` file contains no rule that would prevent credential or secrets files (e.g., `*.json`, `netcfg.json`, `*.secret`) from being committed. There are no tests or pre-commit hooks that scan for secrets before they enter the repository. All git hooks in `.git/hooks/` are `.sample` files only — none are active.
**Fix:** (1) Remove `netcfg.json` from version control with `git rm --cached netcfg.json` and add `netcfg.json` (or `*cfg.json`) to `.gitignore`. (2) Add a pre-commit hook (e.g., using `detect-secrets` or `git-secrets`) to block credential patterns from being committed. (3) Rotate the exposed credential `P@ssMK3!` immediately as it is now in git history on a shared remote.

---

**A01-4** · MEDIUM · Test Coverage – `run_tests` has CRLF line endings; no cross-platform execution test
**File:** `C:/Projects/cig-audit/repos/mark3-pvd/run_tests:1`
**Description:** Despite having a `#!/bin/sh` shebang and being a POSIX shell script, `run_tests` has Windows CRLF (`\r\n`) line endings. On Linux or embedded targets (where the device firmware runs), executing this script will result in a `bad interpreter: /bin/sh\r: no such file or directory` error or similar, making the test runner completely non-functional on the target platform. There is no test or CI check verifying the script executes successfully on the deployment platform.
**Fix:** Convert the file to Unix LF line endings: `dos2unix run_tests` or `sed -i 's/\r//' run_tests`. Add a `.gitattributes` rule (`run_tests text eol=lf`) to enforce LF line endings for this file in all future checkouts. Add a CI step that runs `run_tests` on a Linux host to confirm it executes without error.

---

**A01-5** · LOW · Test Coverage – No guard in `run_tests` for missing `FleetFocus` binary
**File:** `C:/Projects/cig-audit/repos/mark3-pvd/run_tests:2`
**Description:** The script unconditionally executes `./FleetFocus` without first checking that the binary exists. If the repository has not been built, the script fails with a shell error message but no informative guidance. The `FleetFocus` binary is not present in the working tree (it is `.gitignore`-excluded). There is no test that validates the precondition check.
**Fix:** Add a pre-execution guard at the top of the script:
```sh
if [ ! -x ./FleetFocus ]; then
    echo "ERROR: FleetFocus binary not found. Run 'make -f Makefile.test' first." >&2
    exit 1
fi
```

---

**A01-6** · LOW · Test Coverage – No tests for `.gitignore` rule correctness
**File:** `C:/Projects/cig-audit/repos/mark3-pvd/.gitignore:1`
**Description:** The `.gitignore` rules (including the negation `!.gitignore` and the broad `.*` pattern) are not tested. There is no automated check that verifies the ignore rules correctly exclude build artifacts and do not accidentally ignore required source files. The broad `.*` rule on line 3 suppresses all dot-files, which could silently hide untracked configuration files from `git status`.
**Fix:** Add a CI step that runs `git status --short` after a clean build and asserts that no unexpected files appear as untracked. Consider using a tool such as `git check-ignore` in a test script to validate that key build artifacts (`Makefile`, `FleetFocus`) are ignored and that source files are not.

---

**A01-7** · INFO · Test Coverage – No CI/CD pipeline configuration found
**File:** `C:/Projects/cig-audit/repos/mark3-pvd/run_tests:1`
**Description:** No CI/CD pipeline configuration file was found in the repository (no `.yml`/`.yaml` pipeline files, no Jenkinsfile, no Bitbucket Pipelines config). The `run_tests` script exists as a manual convenience wrapper with no automated invocation. This means tests are only run when a developer manually executes the script, providing no safety net against regressions on merge.
**Fix:** Add a CI pipeline configuration (e.g., `bitbucket-pipelines.yml` for Bitbucket, which is where this repository appears to be hosted based on commit merge messages). The pipeline should build the test binary (`make -f Makefile.test`) and then invoke `run_tests` (after fixing the exit code and line ending issues noted above), failing the build if any test fails.

---

## Summary Table

| ID | Severity | Category | File | Description |
|----|----------|----------|------|-------------|
| A01-1 | HIGH | Test Coverage | `run_tests:2` | Exit code of `FleetFocus` silently discarded by pipe to `awk`; CI always sees success |
| A01-2 | HIGH | Test Coverage | `netcfg.json:1` | No tests for JSON parsing, field validation, or Wi-Fi config application |
| A01-3 | MEDIUM | Test Coverage | `.gitignore:1` | No `.gitignore` rule guards against secrets files; no active pre-commit hooks |
| A01-4 | MEDIUM | Test Coverage | `run_tests:1` | CRLF line endings break execution on Linux/embedded targets; no platform test |
| A01-5 | LOW | Test Coverage | `run_tests:2` | No guard for missing `FleetFocus` binary before execution |
| A01-6 | LOW | Test Coverage | `.gitignore:1` | No automated tests verify `.gitignore` rule correctness |
| A01-7 | INFO | Test Coverage | `run_tests:1` | No CI/CD pipeline configuration found in repository |

**Total findings: 7** (2 HIGH, 2 MEDIUM, 2 LOW, 1 INFO)
# Audit Report – Agent A02 (Test Coverage)

**Agent ID:** A02
**Audit Run:** 2026-02-28-01
**Pass:** 2 – Test Coverage
**Files Assigned:** `mk3.pro`, `mk3-test.pro`
**Branch Confirmed:** `master` (verified via `git branch --show-current`)
**Date:** 2026-02-28

---

## Reading Evidence

### File 1: `mk3.pro`

**Purpose:** Production Qt project file. Defines the FleetFocus application build for the mark3-pvd embedded platform. Pulls in all production source, header, form, and resource files.

#### SOURCES entries (mk3.pro)

| Line | File |
|------|------|
| 39 | `main.cpp` |
| 40 | `mytranslator.cpp` |
| 41 | `platform/internalrfid.cpp` |
| 42 | `platform/wiegandrfid.cpp` |
| 43 | `platform/pwmbeeper.cpp` |
| 44 | `platform/pwmbacklight.cpp` |
| 45 | `platform/internalrtc.cpp` |
| 46 | `platform/powersupply.cpp` |
| 47 | `platform/blecentral.cpp` |
| 48 | `app/globalconfigs.cpp` |
| 49 | `ui/amberimpactalertdialog.cpp` |
| 50 | `ui/languagedialog.cpp` |
| 51 | `ui/onScreenKeyboard.cpp` |
| 52 | `ui/broadcastuidialog.cpp` |
| 53 | `ui/pindialog.cpp` |
| 54 | `ui/authoriseddialog.cpp` |
| 55 | `ui/checkstartdialog.cpp` |
| 56 | `ui/checkquestiondialog.cpp` |
| 57 | `ui/checkconfirmationdialog.cpp` |
| 58 | `ui/checkcompleteddialog.cpp` |
| 59 | `ui/lockeddialog.cpp` |
| 60 | `ui/supervisordialog.cpp` |
| 61 | `ui/unlockeddialog.cpp` |
| 62 | `ui/warningdialog.cpp` |
| 63 | `utils/logger.cpp` |
| 64 | `platform/canbus.cpp` |
| 65 | `app/checklist.cpp` |
| 66 | `app/driverlist.cpp` |
| 67 | `app/crctable.cpp` |
| 68 | `platform/gnssreceiver.cpp` |
| 69 | `comm/canmonitor.cpp` |
| 70 | `comm/canstatehandler.cpp` |
| 71 | `comm/bleexpansion.cpp` |
| 72 | `comm/bleexpansionuuid.cpp` |
| 73 | `comm/bleinputhandler.cpp` |
| 74 | `platform/modemport.cpp` |
| 75 | `comm/modemchat.cpp` |
| 76 | `app/backgroundworker.cpp` |
| 77 | `platform/userport.cpp` |
| 78 | `comm/gmtpchat.cpp` |
| 79 | `comm/ntpsync.cpp` |
| 80 | `ui/messagedialog.cpp` |
| 81 | `ui/dialog.cpp` |
| 82 | `comm/ftpclient.cpp` |
| 83 | `platform/seriallogger.cpp` |
| 84 | `platform/aescrypto.cpp` |
| 85 | `comm/canexpansion.cpp` |
| 86 | `ui/keyfilter.cpp` |
| 87 | `ui/informationdialog.cpp` |
| 88 | `utils/barcode128.cpp` |
| 89 | `ui/ondemanddialog.cpp` |
| 90 | `ui/optionalcheckconfirmationdialog.cpp` |
| 91 | `platform/wifi.cpp` |
| 92 | `ui/vorwarningdialog.cpp` |
| 93 | `ui/vorconfirmationdialog.cpp` |
| 94 | `ui/commentdialog.cpp` |
| 95 | `ui/preopscreenoverlay.cpp` |
| 96 | `ui/unlockreasondialog.cpp` |

**Total production SOURCES: 57** (including `main.cpp`)

#### HEADERS entries (mk3.pro) — selected notable items

| Line | File | Note |
|------|------|------|
| 99 | `mytranslator.h` | |
| 100–157 | (all platform/ui/app/comm/utils headers) | Full list in file |
| 122 | `utils/logger.h` | **Duplicate** – also listed at line 112 |

#### DEFINES entries (mk3.pro)

| Line | Define |
|------|--------|
| 6 | `TEST_MODE=0` |
| 30 | `QT_DEPRECATED_WARNINGS` |

#### LIBS / INCLUDEPATH entries (mk3.pro)

| Line | Entry |
|------|-------|
| 13 | `INCLUDEPATH += ../sdk/kernel_include` (linux only) |
| 14 | `INCLUDEPATH += ../sdk/3rd/include` (linux only) |
| 15 | `LIBS += -L../sdk/3rd/lib` (linux only) |

#### QT modules (mk3.pro)

```
core gui serialport serialbus bluetooth network
```
(line 8); `widgets` added conditionally at line 10.

---

### File 2: `mk3-test.pro`

**Purpose:** Qt test project file. Mirrors the production build and adds the four Qt Test suite source files plus the `UNIT_TEST` define and the `testlib` Qt module.

#### SOURCES entries (mk3-test.pro)

| Line | File | Classification |
|------|------|----------------|
| 40 | `test/test_ota.cpp` | Test source |
| 41 | `test/test_dialog.cpp` | Test source |
| 42 | `test/test_backgroundworker.cpp` | Test source (contains `main()`) |
| 43 | `test/test_canbus.cpp` | Test source |
| 44–100 | (identical to mk3.pro lines 40–96, minus `main.cpp`) | Production sources |

`main.cpp` is **absent** from mk3-test.pro SOURCES. The test harness main() lives in `test/test_backgroundworker.cpp` lines 359–387.

#### HEADERS entries (mk3-test.pro)

| Line | File | Classification |
|------|------|----------------|
| 103 | `test/test_ota.h` | Test header |
| 104 | `test/test_dialog.h` | Test header |
| 105 | `test/test_backgroundworker.h` | Test header |
| 106 | `test/test_canbus.h` | Test header |
| 107–165 | (identical to mk3.pro HEADERS) | Production headers |
| 130 | `utils/logger.h` | **Duplicate** – also at line 120 (same as mk3.pro) |

#### DEFINES entries (mk3-test.pro)

| Line | Define | In mk3.pro? |
|------|--------|-------------|
| 6 | `TEST_MODE=0` | Yes |
| 7 | `UNIT_TEST` | **No – test-only** |
| 31 | `QT_DEPRECATED_WARNINGS` | Yes |

#### LIBS / INCLUDEPATH entries (mk3-test.pro)

| Line | Entry |
|------|-------|
| 14 | `INCLUDEPATH += ../sdk/kernel_include` (linux only) |
| 15 | `INCLUDEPATH += ../sdk/3rd/include` (linux only) |
| 16 | `LIBS += -L../sdk/3rd/lib` (linux only) |

#### QT modules (mk3-test.pro)

```
core gui serialport serialbus bluetooth network testlib
```
(line 9); `widgets` added conditionally at line 11.

---

### Test directory contents

Files found in `C:/Projects/cig-audit/repos/mark3-pvd/test/`:

```
test_backgroundworker.cpp / .h
test_canbus.cpp / .h
test_dialog.cpp / .h
test_ota.cpp / .h
FleetIQ360App_5.2.2F.h        (OTA firmware blob for test_ota)
```

No `.pro` or build configuration fragments were found in the test directory. All build configuration is consolidated in `mk3-test.pro`.

### Test methods identified

| Test class | Methods |
|------------|---------|
| `TestBackgroundWorker` | `test_cmdIddeny`, `test_cmdIdlelock`, `test_cmdUnlkmode`, `test_cmdShowtime`, `test_cmdChktsum`, `test_cmdVdimode`, `test_cmdCamera`, `test_cmdCameraFlip` |
| `TestDialog` | `test_enums`, `test_globalConfigs`, `test_idleLockout`, `test_showPreopSummary`, `test_unlockMode1`, `test_showTime` |
| `TestCanbus` | `test_vdiMode` |
| `TestOta` | `test_unpack` |

---

## Findings

---

**A02-1** · HIGH · Coverage Gap – `main.cpp` excluded from test build
**File:** `mk3-test.pro`:39–43 / `mk3.pro`:39
**Description:** `main.cpp` is the application entry point and is listed in mk3.pro SOURCES (line 39) but is deliberately omitted from mk3-test.pro. The test project replaces it with an inline `main()` at `test/test_backgroundworker.cpp:359`. This means application startup logic in `main.cpp` – including any early initialisation, command-line argument handling, QApplication construction options, and platform setup – is never exercised by the test suite. Any bugs in startup sequencing (e.g. Qt::AA_Use96Dpi ARM path, resource initialisation order) are completely invisible to automated testing.
**Fix:** Extract startup logic from `main.cpp` into a testable `AppInit` function or class. Add a `TestMain` test case in mk3-test.pro that verifies the initialisation path. At minimum, document the deliberate exclusion with a comment in mk3-test.pro so auditors can verify the omission is intentional.

---

**A02-2** · HIGH · Coverage Gap – `app/crctable.cpp` has no associated header and is untested
**File:** `mk3.pro`:67 / `mk3-test.pro`:71
**Description:** `app/crctable.cpp` is included in both project files but there is no corresponding `app/crctable.h` in either HEADERS list and no header file exists on disk. No test method in any of the four test classes directly invokes CRC table functions. The CRC logic is safety-relevant: it is used for checklist and config integrity. Because it has no header, the implementation is accessed only via internal linkage or via `extern` declarations embedded in callers, making it impossible to unit-test in isolation. The test suite provides no standalone CRC correctness coverage.
**Fix:** Create `app/crctable.h` and add it to both `.pro` HEADERS sections. Write a dedicated `TestCrc` test class covering boundary values, known-good CRC vectors, and error cases. Add the class to the test runner in `test_backgroundworker.cpp`.

---

**A02-3** · HIGH · Coverage Gap – Large surface of platform and comm sources have no direct unit tests
**File:** `mk3.pro`:41–96 (platform/ and comm/ sources)
**Description:** The following 30+ production source files are compiled into the test binary but have no dedicated test class and are not directly exercised by any test method:

- `platform/internalrfid.cpp`, `platform/wiegandrfid.cpp`, `platform/pwmbeeper.cpp`, `platform/pwmbacklight.cpp`, `platform/internalrtc.cpp`, `platform/powersupply.cpp`, `platform/blecentral.cpp`, `platform/gnssreceiver.cpp`, `platform/modemport.cpp`, `platform/userport.cpp`, `platform/seriallogger.cpp`, `platform/aescrypto.cpp`, `platform/wifi.cpp`
- `comm/bleexpansion.cpp`, `comm/bleexpansionuuid.cpp`, `comm/bleinputhandler.cpp`, `comm/modemchat.cpp`, `comm/gmtpchat.cpp`, `comm/ntpsync.cpp`, `comm/ftpclient.cpp`, `comm/canexpansion.cpp`
- `utils/logger.cpp`, `utils/barcode128.cpp`
- `mytranslator.cpp`

These are included for compilation completeness (so that the linked test binary matches the production binary's symbol set) but no test case calls into them. Security-sensitive modules such as `platform/aescrypto.cpp` (encryption), `comm/ftpclient.cpp` (file transfer), and `comm/ntpsync.cpp` (time synchronisation) have zero test coverage. `utils/barcode128.cpp` contains a pure-function barcode encoder that is trivially unit-testable yet is untested.
**Fix:** At minimum add unit tests for `platform/aescrypto.cpp` (encrypt/decrypt round-trip, key length edge cases), `utils/barcode128.cpp` (known barcode vectors), and `comm/ntpsync.cpp` (timestamp parsing). Flag remaining platform HAL files for hardware-in-the-loop or mock-based coverage.

---

**A02-4** · MEDIUM · Coverage Gap – UI source files included but only partially exercised through integration-style tests
**File:** `mk3.pro`:49–96 (ui/ sources) / `mk3-test.pro`:53–100
**Description:** All 23 UI source files are compiled into the test project. The test suite exercises several dialogs (Dialog, AuthorisedDialog, LockedDialog, CheckStartDialog, CheckQuestionDialog, CheckCompletedDialog, SupervisorDialog, UnlockedDialog) through `TestDialog`. However, the following dialog implementations are compiled but never instantiated or tested:

- `ui/amberimpactalertdialog.cpp`
- `ui/languagedialog.cpp`
- `ui/onScreenKeyboard.cpp`
- `ui/broadcastuidialog.cpp`
- `ui/pindialog.cpp`
- `ui/warningdialog.cpp`
- `ui/messagedialog.cpp`
- `ui/keyfilter.cpp`
- `ui/informationdialog.cpp`
- `ui/ondemanddialog.cpp`
- `ui/optionalcheckconfirmationdialog.cpp`
- `ui/vorwarningdialog.cpp`
- `ui/vorconfirmationdialog.cpp`
- `ui/commentdialog.cpp`
- `ui/preopscreenoverlay.cpp`
- `ui/unlockreasondialog.cpp`

This includes safety-relevant dialogs (`vorwarningdialog`, `amberimpactalertdialog`, `unlockreasondialog`) and the PIN entry dialog (`pindialog`).
**Fix:** Add targeted test cases for the VOR warning and amber impact alert dialogs (state machine coverage). Add a `TestPinDialog` test verifying PIN validation logic. At minimum add `show()`/`hide()` smoke tests for each untested dialog to catch regression crashes.

---

**A02-5** · MEDIUM · `TestCanbus` has only a single test method for a complex multi-class subsystem
**File:** `test/test_canbus.cpp`:73 / `test/test_canbus.h`:15
**Description:** The CAN subsystem spans four production files: `platform/canbus.cpp`, `comm/canmonitor.cpp`, `comm/canstatehandler.cpp`, and `comm/canexpansion.cpp`. `TestCanbus` contains exactly one test method (`test_vdiMode`) that verifies CAN rule configuration in VDI mode. There is no coverage for: CAN frame parsing, canstatehandler state machine transitions, canexpansion message handling, error/timeout paths, or the second CAN bus (the test calls `initialiseCanbus1()` and `initialiseCanbus2()` but only reads `m_canBus1`). CAN communication failures are a known safety vector on vehicle-mounted devices.
**Fix:** Add test methods covering `CanStateHandler` state transitions, `CanExpansion` message parsing, `CanBus` error-frame handling, and multi-bus (canBus2) request validation.

---

**A02-6** · MEDIUM · `TestOta` is hardware-path-only and will silently pass/skip on non-Linux/non-ARM hosts
**File:** `test/test_ota.cpp`:53–55, 67
**Description:** `TestOta::init()` removes hardcoded Linux filesystem paths (`/home/FleetFocusTemp`, `/home/FleetFocusOTA`, `/mnt/sd/FleetIQ360App`). `test_unpack()` writes to `/mnt/sd/FleetIQ360App` and expects decompressed output at `/home/FleetFocusOTA`. On a Windows build host these paths either silently resolve to incorrect locations or fail the `QFile::open()` with no test assertion checking the return value of `QFile::remove()`. The firmware blob is embedded from `test/FleetIQ360App_5.2.2F.h` (only found in the test directory, not the production project). The OTA test is therefore platform-specific but has no compile-time or runtime guard to skip gracefully on non-Linux systems.
**Fix:** Wrap OTA tests with `#ifdef Q_OS_LINUX` or use `QSKIP` with a runtime `QSysInfo::productType()` check. Use `QTemporaryDir` and `QTemporaryFile` for path independence. Add a `QVERIFY(file.open(...))` assertion before writing the firmware blob.

---

**A02-7** · MEDIUM · Duplicate `utils/logger.h` entry in both project files
**File:** `mk3.pro`:112 and 122 / `mk3-test.pro`:120 and 130
**Description:** `utils/logger.h` appears twice in the HEADERS list of both `mk3.pro` (lines 112 and 122) and `mk3-test.pro` (lines 120 and 130). While qmake silently deduplicates header entries during MOC processing, the duplication is a maintenance hazard: it indicates a copy-paste error, makes the file harder to audit, and could produce duplicate MOC output in some qmake versions, causing linker errors if the header ever gains Q_OBJECT.
**Fix:** Remove one of the duplicate `utils/logger.h` lines from both project files.

---

**A02-8** · LOW · `UNIT_TEST` define present in mk3-test.pro has no confirmed counterpart guards in production code
**File:** `mk3-test.pro`:7
**Description:** `mk3-test.pro` adds `DEFINES += UNIT_TEST` (line 7) but `mk3.pro` does not define it. This define is typically used to stub out hardware-dependent code paths (e.g. `#ifdef UNIT_TEST ... #endif`). The test project sets `TEST_MODE=0` identically to production (both line 6 in their respective files), meaning `TEST_MODE` provides no differentiation. If `UNIT_TEST` is not consistently guarded across all platform HAL files, hardware initialisation code may execute in the test environment and cause non-deterministic failures. If it is not used at all, the define is dead and misleading.
**Fix:** Grep for `UNIT_TEST` usage across all source files. Where hardware calls occur unconditionally, wrap them with `#ifndef UNIT_TEST` guards or use dependency injection/mock interfaces. If the define is unused, remove it to reduce confusion.

---

**A02-9** · LOW · `TEST_MODE=0` is identical in both project files – the flag is non-functional
**File:** `mk3.pro`:6 / `mk3-test.pro`:6
**Description:** Both project files set `DEFINES += "TEST_MODE=0"`. If `TEST_MODE` was intended to enable/disable test-only code paths (e.g. `#if TEST_MODE`), setting it to `0` in both projects means it never activates test behaviour. The define appears to have been added for future use but never wired up, providing no coverage differentiation between test and production builds.
**Fix:** Either set `TEST_MODE=1` in mk3-test.pro and add appropriate guards in source where needed, or remove the define from both files and rely solely on `UNIT_TEST`.

---

**A02-10** · LOW · No coverage runner or CI invocation script references either `.pro` file
**File:** `mk3-test.pro` (general)
**Description:** Neither project file references a CI pipeline script, Makefile target, or test runner script. There is no evidence of automated test execution (no `.gitlab-ci.yml`, no `Jenkinsfile`, no `CMakeLists.txt` wrapping the test project). Without a CI gate the test project may not be compiled or run regularly, making all coverage gaps more severe in practice.
**Fix:** Add a CI pipeline step that builds `mk3-test.pro` and invokes the resulting test binary with `-o result.xml,xunitxml`. Enforce a failing build if any `TestXxx` method reports failure.

---

## Summary Table

| ID | Severity | Category | Short Description |
|----|----------|----------|-------------------|
| A02-1 | HIGH | Coverage Gap | `main.cpp` excluded from test build; startup logic untested |
| A02-2 | HIGH | Coverage Gap | `app/crctable.cpp` has no header and no direct unit tests |
| A02-3 | HIGH | Coverage Gap | 30+ platform/comm/utils sources compiled but never directly tested |
| A02-4 | MEDIUM | Coverage Gap | 16 UI dialog sources compiled but not tested, including safety dialogs |
| A02-5 | MEDIUM | Coverage Gap | CAN subsystem has only one test method for four source files |
| A02-6 | MEDIUM | Test Quality | OTA test uses hardcoded Linux paths; silently broken on non-Linux hosts |
| A02-7 | MEDIUM | Project Hygiene | `utils/logger.h` duplicated in HEADERS of both project files |
| A02-8 | LOW | Build Config | `UNIT_TEST` define in mk3-test.pro lacks verified usage across source files |
| A02-9 | LOW | Build Config | `TEST_MODE=0` identical in both files; define provides no differentiation |
| A02-10 | LOW | Process | No CI invocation evidence; test suite may not run regularly |

**Overall assessment:** The test project correctly mirrors the production source surface (57 production sources compiled, minus `main.cpp`, plus 4 test sources). However, only 4 of the 56 compiled production modules (`backgroundworker`, `dialog`, `canbus`/`canmonitor`, and indirectly the OTA path in `backgroundworker`) have any meaningful direct test method coverage. The remaining 52+ modules are compiled for linkage completeness only. Critical security-adjacent modules (`aescrypto`, `ftpclient`, `crctable`) have zero test coverage.
# Security Audit – Pass 2 (Test Coverage)
**Agent:** A03
**Audit Run:** 2026-02-28-01
**Branch Confirmed:** master
**Date:** 2026-02-28

---

## Assigned Files

| File | Lines |
|------|-------|
| `app/backgroundworker.cpp` | 3416 |
| `app/backgroundworker.h` | 195 |
| `app/checklist.cpp` | 242 |
| `app/checklist.h` | 49 |

**Primary test file:** `test/test_backgroundworker.cpp` + `test/test_backgroundworker.h`
**Additional test files examined:** `test/test_ota.cpp`, `test/test_canbus.cpp`, `test/test_dialog.cpp`

---

## Step 4 – Reading Evidence

### `app/backgroundworker.h`

**Class:** `OtaWorker` (line 38)
**Class:** `BackgroundWorker` (line 62)

#### `OtaWorker` – Public Methods
| Method | Line |
|--------|------|
| `OtaWorker(QObject *parent = nullptr)` (constructor) | 42 |
| `void unpack()` | 43 |

#### `OtaWorker` – Signals
| Signal | Line |
|--------|------|
| `sendGmtpMessage(CIGCONF::GmtpMessage msg, const QByteArray &extra)` | 48 |
| `started()` | 49 |
| `ready()` | 50 |
| `failed()` | 51 |

#### `BackgroundWorker` – Public Methods
| Method | Line |
|--------|------|
| `BackgroundWorker(QObject *parent = nullptr)` (constructor) | 68 |
| `void setUI(Dialog *ui)` | 69 |
| `bool networkStatus()` | 70 |

#### `BackgroundWorker` – Signals
| Signal | Line |
|--------|------|
| `powerStateChanged(CIGCONF::PowerState state)` | 80 |
| `reboot()` | 81 |
| `lockScreen(CIGCONF::MaintLockedCode code, bool remote)` | 82 |
| `ambertImpactScreen()` | 83 |
| `cardAuthorised(bool yes, quint64 id)` | 84 |
| `updateStatusInfo(...)` | 85 |
| `cmdMsgReceived(CIGCONF::BroadcastMessage m)` | 86 |
| `onDemandStarted(quint32 start, quint32 end, quint64 id, ...)` | 87 |
| `onDemandExtended(quint32 start, quint32 end, quint64 id, ...)` | 88 |
| `onDemandEnded(quint32 end, quint64 id, ...)` | 89 |
| `sigLanguageChanged()` | 90 |
| `cmdLogin(quint64 id)` | 91 |
| `unpackOta()` | 92 |
| `cameraSettingsUpdated()` | 93 |
| `gmtpMessagePosted(const QByteArray &ba, bool highPriority)` (UNIT_TEST) | 95 |
| `leaderCmdResponse(const QByteArray &ba)` (UNIT_TEST) | 96 |

#### `BackgroundWorker` – Private Methods (slots/helpers)
| Method | Line |
|--------|------|
| `void initHash()` | 102 |
| `void ignitionStateChanged(bool on)` | 103 |
| `void parseLeaderCmd(const QByteArray &ba, bool local)` | 104 |
| `bool dispatchLeaderCmd(LeaderCmdType type, const QByteArray &header, const QByteArray &content)` | 105 |
| `void sendGmtpMessage(CIGCONF::GmtpMessage msg, const QByteArray &ba)` | 106 |
| `void powerTimerEvent()` | 107 |
| `void onTimerEvent()` | 108 |
| `void changePowerState()` | 109 |
| `void updateFile(const QString &file)` | 110 |
| `void updateSelf(bool wait = false)` | 111 |
| `void updateFromRamdisk()` | 112 |
| `void timeChanged()` | 113 |
| `void quit(const QuitMode qm)` | 114 |
| `void quitWaitForAcks(const QuitMode qm)` | 115 |
| `void printDateBatt()` | 116 |
| `quint64 getKernelBuildDate()` | 117 |
| `quint64 convert2UTC(QString tzone, quint64 time)` | 118 |
| `bool pointInPolygon(int polyCorners, CIGCONF::position me, CIGCONF::position *points)` | 119 |
| `double degrees2radians(double degrees)` | 120 |
| `void testGeofence(qint32 lat, qint32 lon)` | 121 |
| `void checkAppCrash()` | 122 |
| `void checkSdSpace()` | 123 |
| `void checkFotaFail()` | 124 |
| `void dataTest()` | 126 |
| `void ethernetStateChanged(EthernetInterface interface, bool state)` | 128 |
| `QByteArray sendGmtpWifiPos()` | 129 |
| `void onAllAcksSent()` | 131 |
| `void handleModemConnection()` | 132 |
| `void handleNtpSynchronization(EthernetInterface interface, bool newState, bool &reconnect)` | 133 |
| `void handleWiFiConnection()` | 134 |
| `void monitTimer()` | 136 |
| `void initialiseCanbus1()` | 138 |
| `void initialiseCanbus2()` | 139 |

#### `backgroundworker.cpp` – File-scope functions
| Function | Line |
|----------|------|
| `QByteArray streamUncompress(QByteArray &chunk, z_stream &strm, bool &finished)` | 49 |
| `quint16 crc16(quint16& state, const QByteArray &chunk)` | 130 |

#### `backgroundworker.cpp` – Includes
```
backgroundworker.h, utils/logger.h, platform/blecentral.h, platform/canbus.h,
platform/gnssreceiver.h, platform/internalrtc.h, platform/modemport.h,
platform/powersupply.h, platform/pwmbacklight.h, platform/pwmbeeper.h,
platform/seriallogger.h, platform/userport.h, platform/wifi.h,
comm/bleexpansion.h, comm/bleinputhandler.h, comm/canmonitor.h,
comm/canexpansion.h, comm/canstatehandler.h, comm/modemchat.h,
comm/gmtpchat.h, comm/ntpsync.h, comm/ftpclient.h,
app/globalconfigs.h, ui/dialog.h, mytranslator.h,
QApplication, QProcess, QFileInfo, QDebug, QLoggingCategory,
QNetworkConfiguration, QFile, QStorageInfo, QThread, algorithm, math.h,
utils/zlib.h, fcntl.h
```

---

### `app/checklist.h`

**Class:** `Checklist` (line 6)

#### `Checklist` – Public Methods
| Method | Line |
|--------|------|
| `Checklist()` (constructor) | 23 |
| `static bool isValidCheckItem(const CheckItem &item)` | 25 |
| `void readChecklist()` | 27 |
| `void saveChecklist()` | 29 |
| `void clear()` | 30 |
| `void shuffleChecklist()` | 31 |
| `const CheckItem & checkItem(int index, bool query = false) const` | 34 |
| `bool setCheckItem(int index, const CheckItem &item)` | 35 |
| `quint32 checksum() const` | 36 |

#### `Checklist` – Private Methods
| Method | Line |
|--------|------|
| `bool readChecklist50()` | 39 |
| `bool readChecklist100()` | 40 |
| `quint8 copyAllRandomPreop(CheckItem *randomPreop)` | 41 |

#### `checklist.cpp` – Includes
```
checklist.h, QFile, QSaveFile, QDataStream, QTime, app/globalconfigs.h, algorithm
```

---

### `test/test_backgroundworker.h` – Test Slots

| Test Method | Line |
|-------------|------|
| `initTestCase()` | 11 |
| `cleanupTestCase()` | 12 |
| `init()` | 13 |
| `test_cmdIddeny()` | 15 |
| `test_cmdIdlelock()` | 16 |
| `test_cmdUnlkmode()` | 17 |
| `test_cmdShowtime()` | 18 |
| `test_cmdChktsum()` | 19 |
| `test_cmdVdimode()` | 20 |
| `test_cmdCamera()` | 21 |
| `test_cmdCameraFlip()` | 22 |

---

## Step 5 – Test Coverage Analysis

### Legend
- **Tested** = covered by at least one test assertion
- **Partial** = some paths tested, others not
- **None** = no test exercises this code

### `BackgroundWorker` – Coverage Summary

| Method / Command | Tested? | Notes |
|-----------------|---------|-------|
| Constructor | None | Object is instantiated in test setup but constructor logic (timer setup, OTA thread start, signal wiring) is not verified |
| `setUI()` | Partial | Called in test setup; signal connections not independently verified |
| `networkStatus()` | None | No test reads or asserts on this method |
| `initHash()` | Partial | Hash populated implicitly; individual entries exercised only for tested commands |
| `parseLeaderCmd()` – local AT echo | None | "AT" command path not tested |
| `parseLeaderCmd()` – AT^ prefix stripping | Partial | Tested implicitly for set commands; query path not separately tested |
| `parseLeaderCmd()` – RS-232 access guard | None | isRs232AccessoryActive() false path not tested |
| `dispatchLeaderCmd()` – CMD_SAVE (AT&W) | None | Not tested |
| `dispatchLeaderCmd()` – CMD_KALV | None | Not tested |
| `dispatchLeaderCmd()` – CMD_SHTD | None | Not tested |
| `dispatchLeaderCmd()` – CMD_IDNT | None | Not tested |
| `dispatchLeaderCmd()` – CMD_PRFX | None | Not tested |
| `dispatchLeaderCmd()` – CMD_FTPF | None | Not tested |
| `dispatchLeaderCmd()` – CMD_IDBATCH / CMD_IDSAVE | None | Not tested |
| `dispatchLeaderCmd()` – CMD_CLRMEM | None | Not tested |
| `dispatchLeaderCmd()` – CMD_REBOOT | None | Not tested |
| `dispatchLeaderCmd()` – CMD_MAINT | None | Not tested |
| `dispatchLeaderCmd()` – CMD_FMTSD | None | Not tested |
| `dispatchLeaderCmd()` – CMD_PRFL | None | Not tested |
| `dispatchLeaderCmd()` – CMD_HOST / CMD_PORT | None | Not tested |
| `dispatchLeaderCmd()` – CMD_RLY1 / CMD_RLY2 | None | Not tested |
| `dispatchLeaderCmd()` – CMD_RLY1TO / CMD_RLY2TO | None | Not tested |
| `dispatchLeaderCmd()` – CMD_MAC | None | Not tested |
| `dispatchLeaderCmd()` – CMD_FIDL / CMD_FIDM / CMD_FIDS / CMD_FIDT | None | Not tested |
| `dispatchLeaderCmd()` – CMD_IDAUTH | None | Not tested |
| `dispatchLeaderCmd()` – CMD_IDDENY | Tested | test_cmdIddeny covers normal, master-only, driver+master, and error paths |
| `dispatchLeaderCmd()` – CMD_IDMAST / CMD_IDSMAST | None | Not tested |
| `dispatchLeaderCmd()` – CMD_IDCLEAR | None | Not tested |
| `dispatchLeaderCmd()` – CMD_IDTAUTH / CMD_IDTDENY | None | Not tested |
| `dispatchLeaderCmd()` – CMD_CHKT | None | Not tested |
| `dispatchLeaderCmd()` – CMD_SURTO / CMD_SURV | None | Not tested |
| `dispatchLeaderCmd()` – CMD_CLR_CHKT | None | Not tested |
| `dispatchLeaderCmd()` – CMD_CLEAR_LIST | None | Not tested |
| `dispatchLeaderCmd()` – CMD_PREC | None | Not tested |
| `dispatchLeaderCmd()` – CMD_OPCHK | Partial | test_dialog.cpp exercises set path via at^opchk but only one variant; error paths missing |
| `dispatchLeaderCmd()` – CMD_FSSS / CMD_FSSX / CMD_FSSP / CMD_FSST | None | Not tested |
| `dispatchLeaderCmd()` – CMD_TIME | None | Not tested |
| `dispatchLeaderCmd()` – CMD_TZONE / CMD_THOST | None | Not tested |
| `dispatchLeaderCmd()` – CMD_GPSR | None | Not tested |
| `dispatchLeaderCmd()` – CMD_TGFNCE / CMD_GFNCE | None | Not tested |
| `dispatchLeaderCmd()` – CMD_SATNUM | None | Not tested |
| `dispatchLeaderCmd()` – CMD_DEBUG | None | Not tested |
| `dispatchLeaderCmd()` – CMD_CLRCAN | Partial | Called in test_canbus setup; no response assertion in test_backgroundworker |
| `dispatchLeaderCmd()` – CMD_CANCFG / CMD_CANPGN / CMD_CANSPN / CMD_CANATT / CMD_CANLIN / CMD_CANBYD / CMD_CANLIN2 / CMD_CANCRC | Partial | Covered in test_canbus.cpp only |
| `dispatchLeaderCmd()` – CMD_IDLE | None | Not tested |
| `dispatchLeaderCmd()` – CMD_BATT | None | Not tested |
| `dispatchLeaderCmd()` – CMD_POWEROFF / CMD_QUIT | None | Not tested |
| `dispatchLeaderCmd()` – CMD_DBGPWR / CMD_DBGBLE / CMD_DBGRAM | None | Not tested |
| `dispatchLeaderCmd()` – CMD_CONVOR | None | Not tested |
| `dispatchLeaderCmd()` – CMD_MSG | None | Not tested |
| `dispatchLeaderCmd()` – CMD_WIFI / CMD_CLRWIFI / CMD_WIFIPOS | None | Not tested |
| `dispatchLeaderCmd()` – CMD_UNLKSCR | None | Not tested |
| `dispatchLeaderCmd()` – CMD_LOGLVL | None | Not tested |
| `dispatchLeaderCmd()` – CMD_SCRSAV | None | Not tested |
| `dispatchLeaderCmd()` – CMD_DIGCFG | None | Not tested |
| `dispatchLeaderCmd()` – CMD_SEENPAR | None | Not tested |
| `dispatchLeaderCmd()` – CMD_MDMAT | None | Not tested |
| `dispatchLeaderCmd()` – CMD_GMTPTIMER | None | Not tested |
| `dispatchLeaderCmd()` – CMD_LANG | None | Not tested |
| `dispatchLeaderCmd()` – CMD_LOCKOUT | None | Not tested |
| `dispatchLeaderCmd()` – CMD_OPRNDM | None | Not tested |
| `dispatchLeaderCmd()` – CMD_SHOWNAMES | None | Not tested |
| `dispatchLeaderCmd()` – CMD_GPSMSG | None | Not tested |
| `dispatchLeaderCmd()` – CMD_SHOWPC | None | Not tested |
| `dispatchLeaderCmd()` – CMD_LOGIN | None | Not tested |
| `dispatchLeaderCmd()` – CMD_MDMRST | None | Not tested |
| `dispatchLeaderCmd()` – CMD_AMIMP | None | Not tested |
| `dispatchLeaderCmd()` – CMD_OPDCHK | None | Not tested |
| `dispatchLeaderCmd()` – CMD_UPDOTA | None | Not tested |
| `dispatchLeaderCmd()` – CMD_IDLELOCK | Tested | test_cmdIdlelock covers on/off/invalid |
| `dispatchLeaderCmd()` – CMD_CHKTSUM | Tested | test_cmdChktsum covers on/off/invalid |
| `dispatchLeaderCmd()` – CMD_UNLKMODE | Tested | test_cmdUnlkmode covers on/off/invalid |
| `dispatchLeaderCmd()` – CMD_SHOWTIME | Tested | test_cmdShowtime covers 0/1/2/3 |
| `dispatchLeaderCmd()` – CMD_VDIMODE | Tested | test_cmdVdimode covers on/off/invalid |
| `dispatchLeaderCmd()` – CMD_CAMERA | Tested | test_cmdCamera covers off/forced/on/invalid |
| `dispatchLeaderCmd()` – CMD_CAMERAFLIP | Tested | test_cmdCameraFlip covers on/off/invalid |
| `sendGmtpMessage()` (private) | Partial | Some message types exercised via integration; most switch branches untested in isolation |
| `powerTimerEvent()` | None | No test for power state transitions |
| `onTimerEvent()` | None | Not tested |
| `changePowerState()` | None | Returns early in UNIT_TEST mode; state machine transitions untested |
| `ignitionStateChanged()` | None | Not tested |
| `updateFile()` | None | Not tested |
| `updateSelf()` | Tested | test_ota.cpp::test_unpack exercises success and CRC-failure cases |
| `updateFromRamdisk()` | None | Not tested |
| `timeChanged()` | None | Not tested |
| `quit()` | None | Not tested |
| `quitWaitForAcks()` | None | Not tested |
| `onAllAcksSent()` | None | Not tested |
| `printDateBatt()` | None | Not tested |
| `getKernelBuildDate()` | None | Not tested |
| `convert2UTC()` | None | Not tested |
| `pointInPolygon()` | None | Not tested |
| `degrees2radians()` | None | Not tested |
| `testGeofence()` | None | Not tested |
| `checkAppCrash()` | None | Not tested |
| `checkSdSpace()` | None | Not tested |
| `checkFotaFail()` | None | Not tested |
| `dataTest()` | None | Debug function, no test |
| `ethernetStateChanged()` | None | Not tested |
| `handleModemConnection()` | None | Not tested |
| `handleWiFiConnection()` | None | Not tested |
| `handleNtpSynchronization()` | None | Not tested |
| `sendGmtpWifiPos()` | None | Not tested |
| `monitTimer()` | None | Not tested |
| `initialiseCanbus1()` | Partial | Called in test_canbus.cpp setup; guard (if m_canBus1 return) not tested |
| `initialiseCanbus2()` | Partial | Called in test_canbus.cpp setup; guard not tested |
| `streamUncompress()` (file-scope) | Partial | Exercised via test_unpack for success and truncated-data; Z_BUF_ERROR and multi-chunk paths untested |
| `crc16()` (file-scope) | Partial | Exercised via test_unpack for happy path and mismatch only |

### `Checklist` – Coverage Summary

| Method | Tested? | Notes |
|--------|---------|-------|
| `Checklist()` | None | No dedicated Checklist unit tests |
| `isValidCheckItem()` | None | Not directly tested |
| `readChecklist()` | None | Not directly tested |
| `readChecklist50()` | None | Not tested |
| `readChecklist100()` | None | Not tested |
| `saveChecklist()` | None | Not tested |
| `clear()` | None | gCfg->clearChecklist() is called in test_dialog but Checklist::clear() has no direct unit test |
| `shuffleChecklist()` | None | Not tested |
| `copyAllRandomPreop()` | None | Not tested |
| `checkItem()` | None | Not tested directly |
| `setCheckItem()` | None | Not tested directly |
| `checksum()` | None | Not tested |

---

## Findings

**A03-1** · HIGH · Missing Tests – Large Set of Untested Command Handlers
**File:** app/backgroundworker.cpp:512
**Description:** `dispatchLeaderCmd()` contains approximately 70 distinct command switch cases. Of these, only 8 are covered by tests in `test_backgroundworker.cpp` (IDLELOCK, CHKTSUM, UNLKMODE, SHOWTIME, VDIMODE, CAMERA, CAMERAFLIP, IDDENY). The remaining roughly 62 cases have zero test coverage including security-sensitive handlers: CMD_IDAUTH (add driver), CMD_IDMAST (add supervisor), CMD_REBOOT (force reboot), CMD_MAINT (force lock screen), CMD_FMTSD (format SD card), CMD_TIME (set RTC), CMD_CLRMEM (wipe all config), CMD_FTPF (initiate FTP download). Any regression, boundary violation, or format-string error in these handlers is undetectable by automated testing.
**Fix:** Add individual test methods for each untested command, covering the set path, the query path, the empty-content error path, and at least one out-of-range value. Prioritise commands that modify security-sensitive state (CMD_IDAUTH, CMD_IDMAST, CMD_REBOOT, CMD_MAINT, CMD_FMTSD, CMD_TIME, CMD_CLRMEM).

---

**A03-2** · HIGH · No Unit Tests for `Checklist` Class
**File:** app/checklist.cpp:1
**Description:** The entire `Checklist` class (9 public methods, 3 private methods) has no dedicated unit tests. The class handles binary file I/O for safety-critical pre-operation checklist data. Bugs in parsing, saving, shuffling, or checksum computation would not be caught by automated tests. The class is used directly by `GlobalConfigs` which is exercised in `test_dialog.cpp`, but only through high-level operations that do not validate the internal state of the `Checklist` object.
**Fix:** Create a `test_checklist.cpp` test file with tests for: (1) reading a well-formed v50 file, (2) reading a well-formed v100 file, (3) reading a missing file, (4) reading a truncated/corrupt file, (5) `saveChecklist` round-trip, (6) `shuffleChecklist` with zero/one/many items, (7) `setCheckItem` at boundary indices (0, MAX_IDX-1, -1, MAX_IDX), (8) `checksum` with empty list and with known items.

---

**A03-3** · HIGH · `streamUncompress()` Static Variable Causes Non-Reentrant Behavior and Incomplete Test Coverage
**File:** app/backgroundworker.cpp:58
**Description:** `streamUncompress()` uses `static bool headerSkipped = false` at line 58. This static local is shared across all calls within the same process lifetime. In `test_unpack`, Test 2 (corrupted file) runs immediately after Test 1 in the same process. If Test 1 exits an error path that does not reset `headerSkipped`, Test 2 will incorrectly skip the 4-byte header on the first chunk. More broadly, this design makes the function non-reentrant and prevents reliable isolated testing. The current tests do not cover: multi-chunk decompression across loop iterations, the Z_BUF_ERROR return from `inflate`, or correct behavior after a prior error call.
**Fix:** Eliminate the static variable by passing `headerSkipped` as a reference parameter or by encapsulating the entire stream state (`z_stream`, `headerSkipped`) in a caller-owned struct. Add tests that simulate multi-chunk decompression and the Z_BUF_ERROR return path.

---

**A03-4** · MEDIUM · `parseLeaderCmd()` RS-232 Access Guard and AT Echo Paths Not Tested
**File:** app/backgroundworker.cpp:462
**Description:** Lines 462-470 contain a guard that drops local set commands when `gCfg->isRs232AccessoryActive()` returns false. This security control is not exercised in any test. A regression in this condition could allow unauthorized local command execution. Additionally, the `"AT"` echo command path (line 448) is never tested.
**Fix:** Add a test that sets `isRs232AccessoryActive()` to false and confirms that a local set command (e.g., `at^kalv=10`) is silently dropped. Add a test for the `AT` echo that verifies `leaderCmdResponse("OK\r\n")` is emitted.

---

**A03-5** · MEDIUM · Power State Machine Completely Untested
**File:** app/backgroundworker.cpp:2604
**Description:** `powerTimerEvent()`, `onTimerEvent()`, `changePowerState()`, and `ignitionStateChanged()` implement the device power state machine (`NormalPowerState`, `PreDimState`, `DimState`, `SleepActiveState`, `SleepState`, `PowerOffState`). None of these functions has any test coverage. `changePowerState()` returns immediately in `UNIT_TEST` mode (line 2652), but the state transition logic in `powerTimerEvent()` and the initialisation sequence in `ignitionStateChanged()` remain exercisable.
**Fix:** Add tests that call `ignitionStateChanged(true)` and `ignitionStateChanged(false)` and verify the resulting `m_powerState` value and timer start/stop behavior. Test `powerTimerEvent()` by pre-setting `m_powerState` to each value and verifying the state transitions.

---

**A03-6** · MEDIUM · Geofence Logic Not Tested
**File:** app/backgroundworker.cpp:2446
**Description:** `degrees2radians()` (line 2446), `pointInPolygon()` (line 2450), and `testGeofence()` (line 2470) implement coordinate mathematics used to determine whether a vehicle is inside a restricted zone. None of these functions is exercised by any test. Edge cases such as zero-corner polygons, a point exactly on a boundary, polygons with the minimum valid corner count (3), and maximum coordinate values are untested.
**Fix:** Add unit tests for `degrees2radians` (0, 90, 180, 360, negative), `pointInPolygon` (point inside, point outside, point on edge, zero corners), and `testGeofence` against a known polygon and coordinate pair. Expose these as `friend` or make them free functions to allow direct testing.

---

**A03-7** · MEDIUM · `getKernelBuildDate()` and `convert2UTC()` Not Tested
**File:** app/backgroundworker.cpp:3060
**Description:** `getKernelBuildDate()` parses `/proc/version` using a regular expression and string manipulation. `convert2UTC()` applies a hard-coded timezone offset only for `"PDT"` and silently falls through for all other timezone strings (including an implicit `return time` that does not adjust at all for non-PDT zones). Both functions lack any tests. A malformed `/proc/version` produces a silent zero result sent to the server.
**Fix:** Test `convert2UTC` with `"PDT"`, an empty string, and an unrecognised timezone. Test `getKernelBuildDate` by temporarily providing a controlled fixture representing `/proc/version` content with a known date string, and verify the returned timestamp.

---

**A03-8** · MEDIUM · `checkAppCrash()`, `checkSdSpace()`, `checkFotaFail()` Not Tested
**File:** app/backgroundworker.cpp:3243
**Description:** These three startup-diagnostic functions interact with the filesystem and emit GMTP messages. They are called unconditionally at startup (lines 2790-2792). None has any test. Regressions (e.g., failure to remove the sentinel file, incorrect GMTP message format, `awk` output parsing failure in `checkSdSpace`) would go undetected.
**Fix:** Add tests that pre-create each sentinel file, call the function under test, and verify: (a) the correct GMTP message is emitted via `gmtpMessagePosted` signal spy, and (b) the sentinel file is removed. Also test each function when the sentinel file does not exist (no-op path).

---

**A03-9** · MEDIUM · `ethernetStateChanged()` and Network Helper Functions Not Tested
**File:** app/backgroundworker.cpp:3121
**Description:** `ethernetStateChanged()`, `handleModemConnection()`, `handleWiFiConnection()`, and `handleNtpSynchronization()` implement network failover logic. These are not exercised by any test. Regressions in the modem-vs-WiFi priority logic or NTP reconnection trigger would be undetectable.
**Fix:** Refactor network-setup shell calls (`QProcess::execute`) into a virtual or injectable helper so they can be suppressed in tests. Add tests that call `ethernetStateChanged` with modem-up, WiFi-up, modem-then-WiFi, and both-down scenarios and verify the resulting state of `m_modemState`, `m_wifiState`, and the GMTP chat ethernet state.

---

**A03-10** · MEDIUM · `CMD_OPCHK` Error Paths Not Tested
**File:** app/backgroundworker.cpp:1103
**Description:** `test_dialog.cpp` issues `at^opchk=1,1,0,"Test?"` which exercises only one happy-path variant of CMD_OPCHK. The following error paths have no test: (1) fewer than 4 arguments, (2) `qId == 0` rejection, (3) `type > CriticalByNo` rejection, (4) `doNotRandomize > 1` rejection, (5) `questionLen > CHECKLIST_QUESTION_LEN_100` rejection, (6) `index` out of range, (7) the query path that enumerates all items.
**Fix:** Add test cases for each rejection path in `dispatchLeaderCmd` for CMD_OPCHK, and add a query test that verifies the formatted response matches expected output.

---

**A03-11** · MEDIUM · `Checklist::checkItem()` Missing Bounds Check and No Tests
**File:** app/checklist.cpp:238
**Description:** `checkItem(int index, bool query)` performs a direct array access on `m_checkItems[index]` and `m_checkItems_shuffled[index]` without any bounds check on `index`. The companion `setCheckItem()` (line 178) does validate bounds. If a caller passes a negative value or a value >= `CHECKLIST_MAX_IDX`, the function will access memory out of the array bounds, causing undefined behaviour. No test exercises this function at all.
**Fix:** Add a bounds check in `checkItem()` consistent with the one in `setCheckItem()`. Add unit tests for `checkItem(-1)`, `checkItem(0)`, `checkItem(CHECKLIST_MAX_IDX - 1)`, and `checkItem(CHECKLIST_MAX_IDX)`, verifying a safe default is returned for out-of-bounds indices.

---

**A03-12** · MEDIUM · `Checklist::shuffleChecklist()` Potential Out-of-Bounds Write Not Tested
**File:** app/checklist.cpp:221
**Description:** In `shuffleChecklist()`, `randomPreopIndex` is incremented unconditionally at line 223 for every slot in `m_checkItems_shuffled` where `doNotRandomize == 0`. If the number of such slots exceeds `numberOfRandomPreop` (the count of items copied into the stack-allocated `randomPreop[CHECKLIST_MAX_IDX]` array), `randomPreopIndex` will exceed the bounds of that array causing an out-of-bounds read. There is no guard before the assignment. No test covers this scenario.
**Fix:** Add a guard `if (randomPreopIndex < numberOfRandomPreop)` before line 223. Add a unit test that constructs a checklist where the number of randomisable slots differs from the number populated, and verify no crash or data corruption occurs.

---

**A03-13** · MEDIUM · `Checklist::readChecklist50()` Returns `true` on Malformed File
**File:** app/checklist.cpp:22
**Description:** `readChecklist50()` returns `true` even if zero valid items were loaded (the loop body exits on the first iteration due to an invalid index or out-of-range type/len). A caller checking the return value to decide whether the checklist was successfully loaded will incorrectly treat an empty or malformed file as a successful read, potentially masking data corruption. No test verifies this behavior.
**Fix:** Consider returning `false` if zero items were loaded from a non-empty file. Add tests with: (a) a valid file containing one item, (b) a file whose first item has an invalid type (>2), and (c) a file whose first item has an invalid length. Verify the return value and the resulting state of `m_checkItems` for each case.

---

**A03-14** · LOW · `OtaWorker::unpack()` Mutex Re-Entry Guard Not Tested
**File:** app/backgroundworker.cpp:146
**Description:** `unpack()` calls `m_mutex.tryLock()` at line 148 and returns early if the lock is already held, preventing concurrent re-entry. This guard has no test. A test should confirm that a second simultaneous call is silently ignored and does not corrupt the in-progress unpack operation.
**Fix:** Add a test that initiates `updateSelf()` on a sufficiently large file and immediately calls `updateSelf()` again, verifying that `m_isRunning` remains 1 throughout and that only one `started()` signal is emitted.

---

**A03-15** · LOW · `networkStatus()` Not Tested
**File:** app/backgroundworker.h:70
**Description:** `networkStatus()` returns `m_wifiState || m_modemState`. This is a public API method with no test. If the underlying fields are refactored, breakage would go undetected.
**Fix:** Add a test that sets `m_wifiState` and `m_modemState` to known values (via friend access available in UNIT_TEST mode) and asserts the return value of `networkStatus()` for all four input combinations.

---

**A03-16** · LOW · `Checklist::checksum()` XOR Algorithm Does Not Detect Duplicate Question IDs
**File:** app/checklist.cpp:188
**Description:** `checksum()` XORs all valid `questionId` values. XOR checksums are insensitive to duplicate values (two identical IDs cancel each other out) and to reordering. A checklist with the same question listed twice produces the same checksum as a checklist missing both instances. No test documents or verifies this behavior.
**Fix:** Add a unit test that demonstrates the XOR cancellation behavior with duplicate IDs and either documents it as intentional or replaces the algorithm with a stronger accumulation method (e.g., additive checksum, CRC, or simple hash).

---

**A03-17** · LOW · Test Teardown Memory Leak – `BackgroundWorker` Worker Not Deleted
**File:** test/test_backgroundworker.cpp:48
**Description:** `cleanupTestCase()` has `delete m_worker` and `m_worker = nullptr` commented out (lines 56-57). The `m_worker` pointer is never freed. While this is a test-only issue, it masks potential object lifetime and signal/slot lifetime bugs and can cause spurious failures when all test suites run sequentially in a single process.
**Fix:** Re-enable the `delete m_worker` call, ensuring the worker thread is quit and waited before deletion, or document with a comment why deletion is suppressed and verify no use-after-free risk exists.

---

## Summary Table

| ID | Severity | Category | File | Brief Description |
|----|----------|----------|------|-------------------|
| A03-1 | HIGH | Missing Tests | backgroundworker.cpp:512 | ~62 of ~70 dispatchLeaderCmd cases have zero test coverage |
| A03-2 | HIGH | Missing Tests | checklist.cpp:1 | Entire Checklist class has no unit tests |
| A03-3 | HIGH | Test Isolation / Design | backgroundworker.cpp:58 | Static variable in streamUncompress causes non-reentrant behavior and incomplete coverage |
| A03-4 | MEDIUM | Missing Tests | backgroundworker.cpp:462 | RS-232 access guard and AT echo command paths untested |
| A03-5 | MEDIUM | Missing Tests | backgroundworker.cpp:2604 | Power state machine transitions not tested |
| A03-6 | MEDIUM | Missing Tests | backgroundworker.cpp:2446 | Geofence math functions have no tests |
| A03-7 | MEDIUM | Missing Tests | backgroundworker.cpp:3060 | getKernelBuildDate and convert2UTC not tested |
| A03-8 | MEDIUM | Missing Tests | backgroundworker.cpp:3243 | checkAppCrash, checkSdSpace, checkFotaFail not tested |
| A03-9 | MEDIUM | Missing Tests | backgroundworker.cpp:3121 | ethernetStateChanged and network helpers not tested |
| A03-10 | MEDIUM | Incomplete Tests | backgroundworker.cpp:1103 | CMD_OPCHK has one happy-path test only; all error paths missing |
| A03-11 | MEDIUM | Missing Tests / Defect | checklist.cpp:238 | checkItem() has no bounds check and no tests |
| A03-12 | MEDIUM | Missing Tests / Defect | checklist.cpp:221 | shuffleChecklist() can read out of bounds on randomPreop; not tested |
| A03-13 | MEDIUM | Missing Tests | checklist.cpp:22 | readChecklist50 returns true on malformed file; not tested |
| A03-14 | LOW | Missing Tests | backgroundworker.cpp:146 | OtaWorker mutex re-entry guard not tested |
| A03-15 | LOW | Missing Tests | backgroundworker.h:70 | networkStatus() not tested |
| A03-16 | LOW | Design / Documentation | checklist.cpp:188 | XOR checksum does not detect duplicate IDs; behavior not documented |
| A03-17 | LOW | Test Quality | test/test_backgroundworker.cpp:48 | BackgroundWorker worker leaked in test teardown |
# Security Audit — Pass 2: Test Coverage
**Agent:** A04
**Audit Run:** 2026-02-28-01
**Branch confirmed:** master (verified via `git branch --show-current`)
**Pass:** 2 — Test Coverage

---

## Files Assigned

| File | Status |
|------|--------|
| `app/cigconfigs.h` | Read in full (header-only, 313 lines) |
| `app/crctable.cpp` | Read in full (47 lines) |
| `app/crctable.h` | Does NOT exist (no companion header) |
| `app/driverlist.cpp` | Read in full (657 lines) |
| `app/driverlist.h` | Read in full (120 lines) |

---

## Test Files Examined

| Test File | Relevant? |
|-----------|-----------|
| `test/test_backgroundworker.cpp` | Yes — exercises `CIGCONF` enums and `gCfg` (GlobalConfigs wrapper over DriverList) |
| `test/test_dialog.cpp` | Yes — exercises `CIGCONF` enums, `setDriverId`, `setMasterId`, `containsDriverId`, `containsMasterId`, `masterIdById` |
| `test/test_canbus.cpp` | No — only registers CIGCONF metatypes |
| `test/test_ota.cpp` | No — only registers CIGCONF metatypes |

---

## Reading Evidence

### app/cigconfigs.h

**Type/constant definitions (all public — header-only):**

| Kind | Name | Line(s) |
|------|------|---------|
| `#define` | `LFF_VERSION`, `SFF_VERSION`, `UFF_VERSION`, `ENG_VERSION`, `F_BUILD`, `C_BUILD` | 8–13 |
| `#define` | `BROADCASTMSG_TEXT_LEN` | 15 |
| `#define` | `GMTP_ID_LEN`, `GMTP_SERVER_CNT`, `SERVER_ADDR_LEN` | 17–19 |
| `#define` | `MODEM_DIAL_NUMBER_LEN`, `MODEM_APN_LEN`, `MODEM_APN_USER_LEN`, `MODEM_ICCID_LEN`, `MODEM_APN_PASSWORD_LEN` | 20–24 |
| `#define` | `MAX_POLY_POINTS`, `MAX_POLY` | 26–27 |
| `#define` | `CHECKLIST_TIME_SLOTS`, `CHECKLIST_MAX_IDX`, `CHECKLIST_QUESTION_LEN`, `CHECKLIST_ITEM_SIZE`, `CHECKLIST_QUESTION_LEN_100`, `CHECKLIST_ITEM_SIZE_100` | 29–34 |
| `#define` | `DRIVER_MAX_ID_IDX` (3000), `MASTER_MAX_ID_IDX` (1024), `SUPER_MAX_ID_IDX` (100), `TECH_MAX_ID_IDX` (1000) | 36–39 |
| `#define` | CAN bus limits: `CAN_MAX_HW_PGN`, `CAN_MAX_PGN_IDX`, `CAN_MAX_SPN_IDX`, `CAN_MAX_LINK_IDX`, `CAN_MAX_ATT_IDX`, `CAN_ATT_NAME_LEN`, `CAN_MSG_TYPE`, `CAN_MSG_DLC`, `CAN_SIG_STATUS` | 42–50 |
| `#define` | `ON_DEMAND_DURATION` | 53 |
| `#define` | `WIFI_MAX_NETWORKS`, `WIFI_CONF_FILE` | 56–57 |
| `#define` | File paths: `FILE_DRIVER_IDS`, `FILE_MASTER_IDS`, `FILE_SUPER_IDS`, `FILE_TECH_IDS`, `FILE_CHECKLIST`, `FILE_CHECKLIST_100`, `FILE_FLEETMS_FW`, `FILE_FLEETMS_FW_RD`, `FILE_LOGIN_SCREEN`, `FILE_LOGIN_SCREEN_RD`, `FILE_ONCEPERDAY_PREOP_IDS` | 64–74 |
| `#define` | `DIR_GMTP_MSG` | 76 |
| `enum` | `MasterMenuOptions` | 83–84 |
| `enum` | `PowerState` | 86 |
| `enum` | `ConfigErrorCode` | 88 |
| `enum` | `FtpErrorCode` | 90–91 |
| `enum` | `LeaderCmdType` | 93 |
| `enum` | `UnlockReasonScreen` | 95 |
| `enum` | `RealImpact` | 97 |
| `enum` | `DigitalInputMode` | 99 |
| `enum` | `LeaderCmd` (large; ~80 values) | 101–126 |
| `enum` | `GmtpMessage` | 128–133 |
| `enum` | `CheckReason` | 135 |
| `enum` | `CheckResponses` | 136 |
| `enum` | `ChecklistType` | 137 |
| `enum` | `OnDemandCmdType` | 139 |
| `enum` | `OnDemandCmdSrc` | 140 |
| `enum` | `MaintLockedCode` | 142–148 |
| `enum` | `ShowTimeFormat` | 150–154 |
| `enum` | `BleExpansionDI`, `BleExpansionRelay`, `BleExpansionConnectionStatus` | 156–158 |
| `enum` | `CanProtocol` | 160 |
| `enum` | `CanAttributeType` | 162–169 |
| `enum` | `WifiPosSource` | 171 |
| `enum` | `CameraMode` | 173 |
| `struct` | `CanMsgLink` | 175–178 |
| `struct` | `CanSigPara` | 188–193 |
| `struct` | `CigCanConfig` | 195–243 |
| `struct` | `BroadcastMessage` | 245–252 |
| `struct` | `WifiNetwork` | 254–258 |
| `struct` | `PreopDriverId` | 260–263 |
| `struct` | `DriverId` | 265–268 |
| `struct` | `MasterId` | 270–274 |
| `struct` | `gpsPosStruct` | 276–279 |
| `struct` | `polygonStruct` | 281–285 |
| `struct` | `position` | 287–293 |
| `struct` | `AccessPoint` | 295–302 |
| `struct` | `CheckResponse` | 304–309 |

No functions are defined in this header. All content is types, constants, and enums.

---

### app/crctable.cpp

**No companion header (`app/crctable.h` does not exist).**

| Kind | Name | Line |
|------|------|------|
| `extern` declaration | `crc32Table[]` (quint32) | 3 |
| `extern` declaration | `crc16Table[]` (quint16) | 4 |
| `const quint32[256]` | `crc32Table` — standard CRC-32/ISO-HDLC lookup table | 6–39 |
| `const quint16[16]` | `crc16Table` — 16-entry CRC-16/CCITT nibble lookup table | 41–46 |

No functions. The file is purely a data table. The tables are consumed by:
- `app/globalconfigs.cpp` line 46: CRC32 used in `GlobalConfigs::crc32()` to integrity-check configuration data
- `app/backgroundworker.cpp` lines 136–138: CRC16 used inline (appears to be CCITT/X.25 variant for modem/comms framing)

---

### app/driverlist.cpp + app/driverlist.h

**Class:** `DriverList`

| Method | Line (cpp) | Visibility |
|--------|-----------|------------|
| `DriverList()` constructor | 8 | public |
| `void readDriverIds()` | 16 | public |
| `void saveDriverIds()` | 45 | public |
| `void readMasterIds()` | 66 | public |
| `void saveMasterIds()` | 97 | public |
| `void readSuperIds()` | 120 | public |
| `void saveSuperIds()` | 136 | public |
| `void readTechIds()` | 155 | public |
| `void saveTechIds()` | 184 | public |
| `void readPreopDriverIds()` | 205 | public |
| `void savePreopDriverIds()` | 233 | public |
| `bool setDriverId(int, quint64, QString)` | 267 | public |
| `bool setMasterId(int, quint64, quint8, QString)` | 285 | public |
| `bool setSuperId(int, quint64)` | 304 | public |
| `bool setTechId(int, quint64, QString)` | 317 | public |
| `int getDriverIdIndex(quint64)` | 335 | public |
| `bool addDriverId(quint64, QString)` | 344 | public |
| `int getMasterIdIndex(quint64)` | 370 | public |
| `bool addSuperId(quint64)` | 379 | public |
| `int getTechIdIndex(quint64)` | 395 | public |
| `bool addTechId(quint64, QString)` | 404 | public |
| `int getPreopDriverIdIndex(quint64)` | 430 | public |
| `CIGCONF::PreopDriverId getPreopDriverId(quint64)` | 445 | public |
| `bool addPreopDriverId(quint64, quint32)` | 455 | public |
| `bool removeDriverId(quint64)` | 489 | public |
| `bool removeMasterId(quint64)` | 511 | public |
| `bool removeSuperId(quint64)` | 529 | public |
| `bool removeTechId(quint64)` | 543 | public |
| `void clearDriverIds()` | 560 | public |
| `void clearMasterIds()` | 566 | public |
| `void clearSuperIds()` | 572 | public |
| `void clearTechIds()` | 578 | public |
| `void clearPreopDriverIds()` | 584 | public |
| `quint32 driverChecksum() const` | 590 | public |
| `quint32 masterChecksum() const` | 601 | public |
| `quint32 superChecksum() const` | 613 | public |
| `quint32 techChecksum() const` | 624 | public |
| `bool superIsEmpty()` | 635 | public |
| `CIGCONF::MasterId masterIdById(quint64) const` | 645 | public |
| Inline accessors (header): `driverIds()`, `masterIds()`, `superIds()`, `techIds()`, `preopDriverIds()`, `driverId(int)`, `masterId(int)`, `superId(int)`, `techId(int)` | h:25–35 | public |
| Inline predicates (header): `containsDriverId(quint64)`, `containsMasterId(quint64, quint8)`, `containsSuperId(quint64)`, `containsTechId(quint64)` | h:42–75 | public |

**Note:** `addMasterId` is absent — there is no such method in either `.cpp` or `.h`. Callers use `setMasterId` to add masters by index.

---

## Test Coverage Analysis

### app/cigconfigs.h

Tests only exercise a small subset of the constants and enums defined here. The CIGCONF namespace types are mostly used as type tokens in `qRegisterMetaType` calls and as values in assertions. Specifically:

- **Tested (enum values verified):** `MaintLockedCode` (all 5 values), `ShowTimeFormat` (all 3 values), `CameraMode` (all 3 values), `ChecklistType` (NotCritical, CriticalByYes, CriticalByNo), `CheckResponses` (CheckResponsedYes, CheckResponsedNo), `UnlockReasonScreen` (Disabled), `MasterMenuOptions` (NormalDriverAccess)
- **Not tested:** `PowerState`, `ConfigErrorCode`, `FtpErrorCode`, `LeaderCmdType`, `RealImpact`, `DigitalInputMode`, `LeaderCmd` enum values, `GmtpMessage` enum values, `CheckReason` enum values, `OnDemandCmdType`, `OnDemandCmdSrc`, `BleExpansionDI/Relay/ConnectionStatus`, `CanProtocol`, `CanAttributeType`, `WifiPosSource`
- **Not tested:** All struct layouts (`CigCanConfig`, `CanMsgLink`, `CanSigPara`, `BroadcastMessage`, `WifiNetwork`, `PreopDriverId`, `DriverId`, `MasterId`, `gpsPosStruct`, `polygonStruct`, `position`, `AccessPoint`, `CheckResponse`)
- **Not tested:** All `#define` constants (boundary values, buffer sizes)

### app/crctable.cpp

- There are **zero tests** for the CRC tables themselves.
- `GlobalConfigs::crc32()` (which uses `crc32Table`) is not directly tested.
- The CRC-16 inline routine in `backgroundworker.cpp` (which uses `crc16Table`) is not tested.
- No known-good vector test exists (e.g., CRC32("") == 0x00000000, CRC32("123456789") == 0xCBF43926).

### app/driverlist.cpp

Tests are conducted entirely through the `GlobalConfigs` facade (`gCfg`), which wraps a `DriverList` instance. Direct `DriverList` unit tests do not exist.

| Method | Tested? | Notes |
|--------|---------|-------|
| `readDriverIds()` | Indirectly (via `gCfg->readConfigs()`) | No isolation — file parsing not tested directly |
| `saveDriverIds()` | Indirectly (via `gCfg->saveConfigs()`) | No isolation |
| `readMasterIds()` | Indirectly | No isolation |
| `saveMasterIds()` | Indirectly | No isolation |
| `readSuperIds()` | Indirectly | No isolation |
| `saveSuperIds()` | Indirectly | No isolation |
| `readTechIds()` | Not tested | No test invokes readTechIds path directly |
| `saveTechIds()` | Not tested | No test exercises tech ID save |
| `readPreopDriverIds()` | Not tested | — |
| `savePreopDriverIds()` | Not tested | — |
| `setDriverId()` | Yes (indirectly via `gCfg->setDriverId`) | Bounds not tested |
| `setMasterId()` | Yes (indirectly) | Bounds not tested |
| `setSuperId()` | Not tested | — |
| `setTechId()` | Not tested | — |
| `addDriverId()` | Not tested directly | |
| `addSuperId()` | Not tested | |
| `addTechId()` | Not tested | |
| `addPreopDriverId()` | Not tested | |
| `removeDriverId()` | Not tested | |
| `removeMasterId()` | Not tested | |
| `removeSuperId()` | Not tested | |
| `removeTechId()` | Not tested | |
| `clearDriverIds()` | Not tested | |
| `clearMasterIds()` | Not tested | |
| `clearSuperIds()` | Not tested | |
| `clearTechIds()` | Not tested | |
| `clearPreopDriverIds()` | Not tested | |
| `driverChecksum()` | Not tested | |
| `masterChecksum()` | Not tested | |
| `superChecksum()` | Not tested | |
| `techChecksum()` | Not tested | |
| `superIsEmpty()` | Not tested | |
| `masterIdById()` | Yes (test_backgroundworker.cpp:109) | Only one scenario |
| `containsDriverId()` | Yes (test_backgroundworker.cpp:74–107) | id==1 edge case not tested |
| `containsMasterId()` | Yes | id==1 edge case not tested |
| `containsSuperId()` | Not tested | |
| `containsTechId()` | Not tested | |
| `getDriverIdIndex()` | Not tested directly | |
| `getMasterIdIndex()` | Not tested directly | |
| `getTechIdIndex()` | Not tested directly | |
| `getPreopDriverIdIndex()` | Not tested | |
| `getPreopDriverId()` | Not tested | |

---

## Findings

**A04-1** · CRITICAL · Missing Test Coverage — CRC Table Correctness
**File:** app/crctable.cpp:6
**Description:** The CRC32 and CRC16 lookup tables in `crctable.cpp` have no unit tests whatsoever. `crc32Table` is used by `GlobalConfigs::crc32()` to protect configuration integrity, and `crc16Table` is used in the modem communications framing in `backgroundworker.cpp`. A single corrupted or incorrectly indexed table entry would silently produce wrong CRC values, potentially allowing corrupt configuration data to pass integrity checks or causing communications to fail unpredictably. No known-input/known-output test vectors (e.g., RFC 3720 CRC32 standard vector "123456789" -> 0xCBF43926) exist anywhere in the test suite.
**Fix:** Add a dedicated test case (e.g., `test_crctable.cpp`) that: (1) tests `GlobalConfigs::crc32()` against at least two standard RFC vectors for CRC32 (empty string, "123456789"), (2) tests the CRC16 routine in `backgroundworker.cpp` against CCITT/X.25 vectors, and (3) spot-checks at least the first, last, and a middle table entry of each table against independently computed values.

---

**A04-2** · HIGH · No Tests for DriverList File Parsing — Normal or Malformed Input
**File:** app/driverlist.cpp:16
**Description:** All eight file-parsing methods (`readDriverIds`, `readMasterIds`, `readSuperIds`, `readTechIds`, `readPreopDriverIds`, and their corresponding save methods) are exercised only indirectly through the `GlobalConfigs` facade with real files on disk. There are no isolated unit tests for: (1) malformed lines (non-hex ID, wrong column count, embedded nulls), (2) empty files, (3) files with only blank lines, (4) files that exceed the maximum index limits (`DRIVER_MAX_ID_IDX` = 3000, etc.), or (5) duplicate ID entries. In `readMasterIds()`, if the `option` field parse fails (`!ok`), the entry is still appended because the `ok` check on line 92 only reflects the last conversion. This logic defect and other edge cases are untested.
**Fix:** Add direct `DriverList` unit tests (instantiate a `DriverList` object, write a temporary file, call the read method, assert the list contents) for: empty file, single valid entry, entry with no name field, entry with extra commas, entry with invalid hex ID, entry with id == 0, and a file exceeding the max entry count. Test round-trip (save then read) for all four list types.

---

**A04-3** · HIGH · Logic Defect in readMasterIds() — Failed Option Parse Does Not Skip Entry
**File:** app/driverlist.cpp:85
**Description:** In `readMasterIds()`, when `args.size() >= 2`, the `option` field is parsed and sets `ok`. However, when `args.size() == 3`, the name is then read without resetting or re-checking `ok`. The final `if (ok)` on line 92 will fail if the `option` field was invalid, discarding the entry — but if `args.size() == 2` and the option field is invalid, the entry is still silently discarded even though the name wasn't read. More critically, if `args.size() == 1` (only an ID), `ok` retains the value from the ID parse (true), so the entry is always added with the default `UnassignedMasterMenu` option — but the code at line 85 never enters the option-parse branch, meaning `ok` is still `true` from the ID parse. This is accidentally correct for size==1, but the `ok` variable is being repurposed across unrelated parse steps, making the logic fragile and untested. No test exercises a master list file entry with a bad option value.
**Fix:** Separate `ok` variables for each parsed field, with explicit `continue` on failure. Add a unit test for a master list file with a non-numeric option field to confirm the entry is skipped.

---

**A04-4** · HIGH · No Tests for DriverList Mutation Methods
**File:** app/driverlist.cpp:344
**Description:** The following public methods have zero test coverage: `addDriverId`, `addSuperId`, `addTechId`, `addPreopDriverId`, `removeDriverId`, `removeMasterId`, `removeSuperId`, `removeTechId`, `clearDriverIds`, `clearMasterIds`, `clearSuperIds`, `clearTechIds`, `clearPreopDriverIds`, `setSuperId`, `setTechId`. These methods manage access control lists for drivers, masters, supervisors, technicians, and the once-per-day pre-op list. Undetected defects in add/remove logic could allow unauthorized access or deny authorized users. For example, `addDriverId` contains a slot-reuse strategy (replaces slot with id==0) that is entirely untested.
**Fix:** Add unit tests for each mutation method covering: add to empty list, add duplicate (should update in place), add when list is full (should return false), remove existing entry, remove non-existent entry (should return false), remove id==0 (should return false), and clear operations.

---

**A04-5** · HIGH · No Tests for Checksum Functions
**File:** app/driverlist.cpp:590
**Description:** `driverChecksum()`, `masterChecksum()`, `superChecksum()`, and `techChecksum()` are not tested. These checksums use XOR over all IDs and, for masters, XOR the `option` byte. XOR-based checksums have well-known weaknesses (they cannot detect swapped even-count duplicates, and XOR of a value with itself cancels out). If the checksum functions produce incorrect results, the system may incorrectly flag list corruption or fail to detect actual corruption. Additionally, because the empty-list checksum is 0, an empty list and a list of two identical entries will both produce checksum 0 — an untested collision.
**Fix:** Add unit tests for each checksum function with known inputs and expected XOR-derived outputs. Include a test for the empty list (expected 0), a single-entry list, and the collision case (two identical IDs should produce checksum 0).

---

**A04-6** · MEDIUM · No Test for superIsEmpty() with Mixed Zero and Non-Zero Entries
**File:** app/driverlist.cpp:635
**Description:** `superIsEmpty()` is not tested. The method correctly iterates backwards and returns false if any non-zero entry exists, and true for an all-zero or empty list. However, no test confirms behaviour for a list that has been partially cleared (some entries zeroed via `removeSuperId`), or for an empty list. The delete-by-zeroing pattern used by `removeSuperId` means `m_superIds` always grows and never shrinks; `superIsEmpty()` must handle a list of all-zero values.
**Fix:** Add unit tests: (1) empty list returns true, (2) list with one non-zero entry returns false, (3) list where all entries were removed via `removeSuperId` returns true.

---

**A04-7** · MEDIUM · containsDriverId/containsMasterId/containsSuperId/containsTechId — id==1 Edge Case Untested
**File:** app/driverlist.h:42
**Description:** All four `contains*` inline methods include the guard `return id != 1 ? true : false`, which means ID value 1 is always treated as not present, even if it exists in the list. This is presumably an intentional reserved-ID convention, but it is entirely undocumented and untested. No test inserts id==1 and then calls `containsDriverId(1)` to verify the expected false return. If the convention is ever violated (e.g., a device legitimately gets assigned id==1), authentication could silently fail.
**Fix:** Add explicit test cases: insert id==1 into each list type, then assert that `contains*Id(1)` returns false. Document the reserved-ID convention in a code comment.

---

**A04-8** · MEDIUM · No Tests for Preop Driver ID Subsystem
**File:** app/driverlist.cpp:205
**Description:** The entire once-per-day pre-op subsystem — `readPreopDriverIds`, `savePreopDriverIds`, `addPreopDriverId`, `getPreopDriverId`, `getPreopDriverIdIndex`, `clearPreopDriverIds`, and the `preopDriverIds()` accessor — has no test coverage. `savePreopDriverIds` contains date-filtering logic (only entries whose `lastPreopTimestamp` date matches today are written back), which is a non-trivial stateful computation involving `gCfg->localTime()`. A bug here could either fail to persist valid pre-op records (causing drivers to be re-prompted unnecessarily) or retain stale records (skipping required pre-op checks).
**Fix:** Add unit tests for: `addPreopDriverId` with id==0 (should fail), add a valid id/timestamp, add same id again (should update timestamp), `getPreopDriverId` for existing and non-existing id, `readPreopDriverIds` with a malformed file, and `savePreopDriverIds` date-filtering (write two entries with different dates, call save, confirm only today's entry is retained).

---

**A04-9** · MEDIUM · cigconfigs.h Constants Not Tested for Correct Values or Sizing
**File:** app/cigconfigs.h:26
**Description:** Critical buffer-size and limit constants such as `MODEM_APN_PASSWORD_LEN` (66, comment says must be >= 64), `CHECKLIST_ITEM_SIZE` (computed as `5 + CHECKLIST_QUESTION_LEN`), `CHECKLIST_ITEM_SIZE_100` (computed as `7 + CHECKLIST_QUESTION_LEN_100`), and `CAN_MAX_*` family are never verified by any test. If a refactoring changes `CHECKLIST_QUESTION_LEN` without updating `CHECKLIST_ITEM_SIZE`, serialization bugs would go undetected. No test asserts sizeof any struct against an expected wire-format size.
**Fix:** Add static_assert or test-time assertions for: `CHECKLIST_ITEM_SIZE == 55`, `CHECKLIST_ITEM_SIZE_100 == 107`, `MODEM_APN_PASSWORD_LEN >= 64`, and `sizeof(CigCanConfig)` against a reference value to catch accidental ABI breakage.

---

**A04-10** · MEDIUM · Large Majority of CIGCONF Enum Values Untested
**File:** app/cigconfigs.h:83
**Description:** Of the approximately 17 enums defined in the CIGCONF namespace, only three (`MaintLockedCode`, `ShowTimeFormat`, `CameraMode`) have their numerical values explicitly verified in `test_dialog.cpp::test_enums()`. The remaining 14 enums — including `LeaderCmd` (~80 values), `GmtpMessage` (~24 values), `ConfigErrorCode`, `FtpErrorCode`, `CanProtocol`, `CanAttributeType`, etc. — are never value-checked. If any enum value is reordered without corresponding protocol-level awareness, serialized messages could be misinterpreted by remote systems.
**Fix:** Extend `test_enums()` to verify at minimum the first and last value of each enum that is serialized over a wire protocol or stored to disk. Priority: `GmtpMessage`, `LeaderCmd` sentinels, `CheckReason`, `OnDemandCmdType`.

---

**A04-11** · LOW · crctable.cpp Has No Companion Header
**File:** app/crctable.cpp:3
**Description:** `crctable.cpp` declares its tables with `extern` at the top of the same file, then defines them. Consumers (`globalconfigs.cpp`, `backgroundworker.cpp`) also declare their own local `extern` references. There is no shared header (`crctable.h` does not exist), so nothing prevents a consumer from declaring the array with a wrong type or wrong size. This is a minor architectural issue but can mask type errors at compile time.
**Fix:** Create `app/crctable.h` exposing `extern const quint32 crc32Table[256];` and `extern const quint16 crc16Table[16];` and include it in all consumers and in `crctable.cpp`. This gives the compiler one authoritative declaration to check against.

---

**A04-12** · LOW · savePreopDriverIds Uses QFile Instead of QSaveFile
**File:** app/driverlist.cpp:244
**Description:** `savePreopDriverIds()` opens the pre-op driver ID file using `QFile` with `WriteOnly`, unlike the other four save methods (`saveDriverIds`, `saveMasterIds`, `saveSuperIds`, `saveTechIds`) which all use `QSaveFile` for atomic write-then-commit. If the process is interrupted or power is lost mid-write with `QFile`, the file can be left partially written or truncated, potentially losing all pre-op history for the day. This inconsistency is untested because `savePreopDriverIds` has no test coverage.
**Fix:** Refactor `savePreopDriverIds()` to use `QSaveFile` and `commit()` for atomic write semantics, consistent with all other save methods. Add a test that simulates the save and verifies the file contents.

---

## Summary Table

| ID | Severity | Category | File | Tested? |
|----|----------|----------|------|---------|
| A04-1 | CRITICAL | Missing CRC test coverage | app/crctable.cpp:6 | No |
| A04-2 | HIGH | No file-parsing tests (normal/malformed) | app/driverlist.cpp:16 | No |
| A04-3 | HIGH | Logic defect in readMasterIds — bad option parse | app/driverlist.cpp:85 | No |
| A04-4 | HIGH | No tests for add/remove/clear mutations | app/driverlist.cpp:344 | No |
| A04-5 | HIGH | No tests for checksum functions | app/driverlist.cpp:590 | No |
| A04-6 | MEDIUM | superIsEmpty() not tested | app/driverlist.cpp:635 | No |
| A04-7 | MEDIUM | id==1 reserved-ID guard untested | app/driverlist.h:42 | No |
| A04-8 | MEDIUM | Preop driver ID subsystem entirely untested | app/driverlist.cpp:205 | No |
| A04-9 | MEDIUM | cigconfigs.h constants not verified | app/cigconfigs.h:26 | No |
| A04-10 | MEDIUM | Most CIGCONF enum values not tested | app/cigconfigs.h:83 | No |
| A04-11 | LOW | No crctable.h header | app/crctable.cpp:3 | N/A |
| A04-12 | LOW | savePreopDriverIds uses QFile not QSaveFile | app/driverlist.cpp:244 | No |

**Total findings:** 12 (1 CRITICAL, 4 HIGH, 5 MEDIUM, 2 LOW)
# Security Audit – Pass 2: Test Coverage
**Agent:** A05
**Audit Run:** 2026-02-28-01
**Branch confirmed:** master
**Date:** 2026-02-28

---

## Files Audited

| File | Lines |
|---|---|
| `app/globalconfigs.cpp` | 819 |
| `app/globalconfigs.h` | 865 |

---

## Reading Evidence

### Class

`GlobalConfigs` (singleton via `Q_GLOBAL_STATIC`, macro alias `gCfg`) — inherits `QObject`.

### Includes (globalconfigs.cpp)

| Include |
|---|
| `globalconfigs.h` |
| `platform/internalrtc.h` |
| `<QGlobalStatic>` |
| `<QBluetoothAddress>` |
| `<QProcess>` |
| `<QDebug>` |
| `<QSaveFile>` |
| `<QTextStream>` |
| `<QString>` |

### Includes (globalconfigs.h)

| Include |
|---|
| `<QtGlobal>` |
| `<QFile>` |
| `<QDateTime>` |
| `<QObject>` |
| `utils/bytearray.h` |
| `app/cigconfigs.h` |
| `app/checklist.h` |
| `app/driverlist.h` |

### Public Methods (with line numbers in globalconfigs.h unless noted)

| Method | Line (h) | Implemented in |
|---|---|---|
| `GlobalConfigs(QObject*)` constructor | 20 | cpp:26 |
| `static instance()` | 21 | cpp:33 |
| `static crc32(const void*, int)` | 22 | cpp:38 |
| `readConfigs()` | 24 | cpp:51 |
| `saveConfigs()` | 25 | cpp:110 |
| `saveOpdDriverList()` | 26 | cpp:126 |
| `resetConfigs(bool)` | 27 | cpp:131 |
| `keepAliveTime()` / `setKeepAliveTime()` | 30–38 | inline |
| `shutdownTime()` / `setShutdownTime()` | 40–48 | inline |
| `gmtpId()` / `setGmtpId()` | 50–58 | inline |
| `maintCode()` / `maintDriverId()` / `maintTimestamp()` | 60–62 | inline |
| `setMaintCode()` | 64 | inline |
| `unlockId()` / `setUnlockId()` | 81–85 | inline |
| `dialNumber()` / `setDialNumber()` | 87–95 | inline |
| `apn()` / `setApn()` | 97–105 | inline |
| `apnUser()` / `setApnUser()` | 107–115 | inline |
| `apnPassword()` / `setApnPassword()` | 117–125 | inline |
| `gmtpServerAddress()` / `setGmtpServerAddress()` | 127–135 | inline |
| `gmtpServerPort()` / `setGmtpServerPort()` | 137–145 | inline |
| `expansionModMac()` / `setExpansionModMac()` | 147–155 | inline |
| `resetSimCardID()` / `getSimCardID()` / `setSimCardID()` | 157–166 | inline |
| `driverIds()` / `masterIds()` / `superIds()` / `techIds()` / `preopDriverIds()` | 168–172 | inline |
| `driverId()` / `masterId()` / `masterIdById()` / `superId()` / `techId()` | 174–178 | inline |
| `setDriverId()` / `setMasterId()` / `setTechId()` | 180–183 | inline |
| `setSuperId()` | 182 | cpp:639 |
| `containsDriverId()` / `containsMasterId()` / `containsSuperId()` / `containsTechId()` | 185–188 | inline |
| `addDriverId()` / `addTechId()` / `addPreopDriverId()` | 190–193 | inline |
| `addSuperId()` | 191 | cpp:649 |
| `removeDriverId()` / `removeMasterId()` / `removeTechId()` | 195–198 | inline |
| `removeSuperId()` | 197 | cpp:659 |
| `clearDriverIds()` / `clearMasterIds()` / `clearSuperIds()` / `clearTechIds()` / `clearPreopDriverIds()` | 200–204 | inline |
| `getMasterIdIndex()` / `getDriverIdIndex()` / `getTechIdIndex()` / `getPreopDriverIdIndex()` / `getPreopDriverId()` | 206–210 | inline |
| `preopOncePerDayEn()` / `setPreopOncePerDayEn()` | 212–218 | inline |
| `getDriverName()` | 220 | inline |
| `superIsEmpty()` | 233 | inline |
| `digitalInputMode1..4()` / `setDigInputMode()` | 235–246 | inline |
| `seenDebounceTime()` / `seenHoldTime()` / `setSeenParam()` | 248–255 | inline |
| `convorStatus()` / `convorId()` / `setConvor()` | 257–267 | inline |
| `fullLockoutEnable()` / `setFullLockoutEnable()` | 270–275 | inline |
| `fullLockoutTimeout()` / `setFullLockoutTimeout()` | 277–282 | inline |
| `unlkScr()` / `setUnlkScr()` | 284–292 | inline |
| `scrSavMode()` / `setScrSavMode()` | 294–302 | inline |
| `checkTimeSlot()` / `setCheckTimeSlot()` | 304–312 | inline |
| `checklistTimeout()` / `setChecklistTimeout()` | 314–322 | inline |
| `lastTimeServerUpdate()` / `setLastTimeServerUpdate()` | 324–328 | inline |
| `timeError()` / `setTimeError()` | 330–334 | inline |
| `lastPreopOncePerDayTimestamp()` / `setlastPreopOncePerDayTimestamp()` | 336–342 | inline |
| `lastCheckTimestamp()` / `setLastCheckTimestamp()` | 344–350 | inline |
| `lastCheckDriverId()` / `setLastCheck()` | 352–359 | inline |
| `clearChecklist()` / `checkItem()` / `setCheckItem()` | 361–365 | inline |
| `nextValidCheckItemIndex()` / `shuffleChecklist()` | 367–374 | inline |
| `preopRandom()` / `setPreopRandom()` | 375–380 | inline |
| `shockThreshold()` / `setShockThreshold()` | 382–387 | inline |
| `shockRedImpact()` / `setShockRedImpact()` | 389–394 | inline |
| `shockPeriod()` / `setShockPeriod()` | 396–401 | inline |
| `shockTimer()` / `setShockTimer()` | 403–408 | inline |
| `timeZoneInMinutes()` / `setTimeZoneInMinutes()` | 410–417 | inline |
| `timeServerAddress()` / `setTimeServerAddress()` | 419–427 | inline |
| `gpsUpdateTime()` / `setGpsUpdateTime()` | 429–437 | inline |
| `gpsDistanceMark()` / `setGpsDistanceMark()` | 439–447 | inline |
| `satNum()` / `setSatNum()` | 449–457 | inline |
| `idleTimeout()` / `setIdleTimeout()` | 459–464 | inline |
| `getGmtpWaitTimeout()` / `setGmtpWaitTimeout()` | 466–471 | inline |
| `idleInputPolarity()` / `setIdleInputPolarity()` | 473–478 | inline |
| `idleInputSource()` / `setIdleInputSource()` | 480–488 | inline |
| `polygon()` / `polygonNPoints()` / `setPolygonNPoints()` | 490–499 | inline |
| `polygonLatitude()` / `setPolygonLatitude()` | 502–510 | inline |
| `polygonLongitude()` / `setPolygonLongitude()` | 512–520 | inline |
| `configVersion()` / `backlight()` / `checksum()` | 524–527 | inline |
| `configErrorCode()` | 529 | inline |
| `readPreopDriverIds()` / `readDriverIds()` / `readMasterIds()` / `readSuperIds()` / `readTechIds()` / `readChecklist()` | 531–536 | inline |
| `driverChecksum()` / `masterChecksum()` / `superChecksum()` / `questionChecksum()` | 537–540 | inline |
| `timestamp()` / `localTimestamp()` / `localTime()` / `clockTime()` | 542–555 | inline |
| `preopCommentString()` / `setPreopCommentString()` | 557–558 | inline |
| `UnlkReasonString()` / `setUnlkReasonString()` | 560–561 | inline |
| `UnlkOption()` / `setUnlkOption()` | 563–564 | inline |
| `currentDriverId()` / `setCurrentDriverId()` | 566–567 | inline |
| `fwVersion()` / `fwVersionString()` | 569–570 | inline |
| `onDemandStartTime()` / `onDemandEndTime()` / `onDemandSmId()` | 573–575 | inline |
| `setOnDemand()` / `clearOnDemand()` | 577–583 | inline |
| `onDemandActive()` / `onDemandVehicleEnabled()` | 585–586 | inline |
| `setWifiNetwork()` | 588 | cpp:709 |
| `wifiNetwork()` | 589 | inline |
| `setWifiCountry()` | 591 | cpp:723 |
| `wifiCountry()` | 592 | inline |
| `clearWifiConfig()` | 594 | cpp:733 |
| `wifiPos()` / `wifiPosInterval()` / `wifiPosSource()` / `setWifiPos()` | 596–605 | inline |
| `isRs232AccessoryActive()` | 606 | inline |
| `debugMsg()` / `setDebugMsg()` / `debugSpn()` / `setDebugSpn()` | 608–612 | inline |
| `geofenceState()` / `setGeofenceState()` | 614–615 | inline |
| `showDriverName()` / `setShowDriverName()` | 617–622 | inline |
| `GPSMsgLogEn()` / `setGPSMsgLogEn()` | 624–628 | inline |
| `showPreopComment()` / `setShowPreopComment()` | 630–634 | inline |
| `amberImpactAlertActive()` / `setAmberImpactAlertActive()` | 636–640 | inline |
| `idleLockout()` / `setIdleLockout()` | 642–647 | inline |
| `showPreopSummary()` / `setShowPreopSummary()` | 649–653 | inline |
| `unlockMode()` / `setUnlockMode()` | 655–659 | inline |
| `forceChecklist()` / `setForceChecklist()` | 661–667 | inline |
| `showTime()` / `setShowTime()` | 669–673 | inline |
| `vdiMode()` / `setVdiMode()` | 675–679 | inline |
| `cameraMode()` / `setCameraMode()` | 681–685 | inline |
| `cameraFlip()` / `setCameraFlip()` | 687–691 | inline |
| `lastSessionDriver()` / `lastSessionStart()` / `lastSessionEnd()` | 693–695 | inline |
| `setLastSessionDriver()` / `setLastSessionStart()` / `setLastSessionEnd()` | 696–707 | inline |

### Signals (globalconfigs.h:709–712)

| Signal | Line |
|---|---|
| `superListChanged(bool empty)` | 710 |
| `convorStatusChanged()` | 711 |
| `preopOncePerDayStatusChanged()` | 712 |

### Private Methods (implemented in globalconfigs.cpp)

| Method | cpp line |
|---|---|
| `readStaticConfig()` | 265 |
| `saveStaticConfig()` | 420 |
| `readDynamicConfig()` | 510 |
| `saveDynamicConfig()` | 556 |
| `readOdConfig()` | 587 |
| `saveOdConfig()` | 618 |
| `readVORConfig()` | 669 |
| `saveVORConfig()` | 690 |
| `readGeofenceConfig()` | 778 |
| `saveGeofenceConfig()` | 749 |

---

## Test Files Examined

| File | Relevance |
|---|---|
| `test/test_dialog.cpp` | Contains `test_globalConfigs()` — primary unit test for GlobalConfigs |
| `test/test_backgroundworker.cpp` | Uses `gCfg` extensively through AT command integration tests |
| `test/test_ota.cpp` | Uses `gCfg->resetConfigs(true)` in setup only |
| `test/test_canbus.cpp` | Not examined in detail (no GlobalConfigs references found in grep) |

---

## Findings

---

**A05-1** · HIGH · Missing Test Coverage – Core I/O functions
**File:** app/globalconfigs.cpp:265
**Description:** `readStaticConfig()` and `saveStaticConfig()` are the primary persistence functions for device configuration (fms.ini). They are never directly unit-tested. `test_globalConfigs()` calls `readConfigs()` and `saveConfigs()` which invoke them, but no test verifies behavior when fms.ini is absent, unreadable (permissions error), or contains truncated/malformed content. The fallback path in `readConfigs()` (cpp:62–90) that reads the binary `fmscfg.dat` with CRC validation is also entirely untested.
**Fix:** Add explicit unit tests for `readStaticConfig()` with: (a) missing file, (b) file with permission denied, (c) file with unknown keys only, (d) file with malformed lines (no `=` separator). Add tests for the `fmscfg.dat` binary fallback path with: (a) file missing, (b) file too small (size < sizeof(ConfigsData)), (c) bad magic code, (d) CRC mismatch, (e) valid file.

---

**A05-2** · HIGH · Missing Test Coverage – Dynamic config I/O
**File:** app/globalconfigs.cpp:510
**Description:** `readDynamicConfig()` and `saveDynamicConfig()` handle the dyn.ini persistence file. While `test_globalConfigs()` indirectly exercises `setForceChecklist()` which triggers `saveDynamicConfig()`, there is no test for: (a) dyn.ini missing on first boot, (b) dyn.ini with permission error, (c) malformed lines in dyn.ini, or (d) verifying all nine fields round-trip correctly (Maint code, Maint driver, Maint timestamp, Last check timestamp, Last check driver, Last check OncePerDay Timestamp, Force checklist, Last session driver/start/end). In particular, the maint fields written in hex (`Maint driver`, `Last check driver`) are not round-trip tested at all.
**Fix:** Add dedicated tests for `readDynamicConfig()` / `saveDynamicConfig()` covering all fields, hex-formatted fields, and error paths (missing file, unwritable directory).

---

**A05-3** · HIGH · Missing Test Coverage – On-Demand config I/O
**File:** app/globalconfigs.cpp:587
**Description:** `readOdConfig()` and `saveOdConfig()` (odcfg.dat) are completely untested. No test exercises `setOnDemand()`, `clearOnDemand()`, or the persistence round-trip. Error paths — missing file, fewer than 4 lines, wrong version number — are not tested. The signal `superListChanged` emitted by `readOdConfig()` (cpp:613) on successful read is also never verified in tests.
**Fix:** Add tests for: (a) `setOnDemand()` + file read-back, (b) `clearOnDemand()` + file read-back, (c) missing file, (d) truncated file (fewer than 4 lines), (e) wrong version field, (f) verify `superListChanged` signal is emitted on successful load.

---

**A05-4** · HIGH · Missing Test Coverage – VOR/Convor config I/O
**File:** app/globalconfigs.cpp:669
**Description:** `readVORConfig()` and `saveVORConfig()` (vor.cfg) are completely untested. `setConvor()` is not covered by any test. The `convorStatusChanged()` signal emitted from `readVORConfig()` is never verified. Error paths (file missing, empty file) are not tested.
**Fix:** Add tests for `setConvor()` verifying: (a) signal `convorStatusChanged` fires when status changes, (b) `gCfg->setLastCheckTimestamp(0)` side effect is triggered, (c) persistence round-trip through `saveVORConfig()` / `readVORConfig()`, (d) missing/empty vor.cfg handled without crash.

---

**A05-5** · HIGH · Missing Test Coverage – Geofence config I/O
**File:** app/globalconfigs.cpp:749
**Description:** `readGeofenceConfig()` and `saveGeofenceConfig()` (gfnce.cfg) are completely untested. No test calls `setPolygonLatitude()`, `setPolygonLongitude()`, `setPolygonNPoints()`, or verifies geofence data survives a save/load cycle. The out-of-bounds logic for `n` and `vect` indices in `readGeofenceConfig()` (cpp:801–807) is not tested — negative or oversized indices from a malformed file would cause undefined behavior (array overwrite).
**Fix:** Add tests for: (a) save/load round-trip for a simple polygon, (b) malformed file with fewer than 4 comma-separated fields per line (skipped silently), (c) out-of-range polygon/vertex index values in the file — these currently are not bounds-checked before array write at cpp:806–807 and must be guarded.

---

**A05-6** · HIGH · Untested Bounds Defect – readGeofenceConfig() array overwrite
**File:** app/globalconfigs.cpp:801
**Description:** `n` and `vect` are derived from file content (`pol[0].trimmed().toInt()-1`, `pol[1].trimmed().toInt()-1`) with no range validation before being used as indices into `m_polygon[n]` (size `MAX_POLY`) and `polyVertices[vect]` (size `MAX_POLY_POINTS`). A malformed or adversarially crafted gfnce.cfg file can produce negative values (e.g., field value "0" gives index -1) or values exceeding the array bounds, causing out-of-bounds memory writes. There are zero tests that exercise this path with out-of-range input.
**Fix:** Add bounds checks before the array writes: verify `n >= 0 && n < MAX_POLY` and `vect >= 0 && vect < MAX_POLY_POINTS`. Add unit tests supplying out-of-range polygon/vertex indices to confirm safe rejection.

---

**A05-7** · MEDIUM · Missing Test Coverage – setMaintCode() logic
**File:** app/globalconfigs.h:64
**Description:** `setMaintCode()` contains non-trivial logic: it rejects codes not in the allowed set, and (via the condition `if (m_configs.maint.code && code != 0)`) prevents overwriting a non-zero maint code with another non-zero code. This guard is entirely untested. No test verifies that an invalid code is rejected, that a second non-zero code is blocked when one is already set, or that the function correctly sets `m_currentDriverId` and the current timestamp into the maint struct.
**Fix:** Add unit tests for: (a) valid code set when current code is zero, (b) rejection of invalid code values, (c) rejection of a second non-zero code when one is already set (the double-lock guard), (d) verify `m_currentDriverId` and timestamp are captured correctly.

---

**A05-8** · MEDIUM · Missing Test Coverage – setWifiNetwork() / setWifiCountry() / clearWifiConfig()
**File:** app/globalconfigs.cpp:709
**Description:** WiFi configuration methods (`setWifiNetwork()`, `setWifiCountry()`, `clearWifiConfig()`) are entirely untested. `setWifiNetwork()` enforces constraints on password length (8–63 bytes), SSID length (1–32 bytes), and index bounds; none of these boundaries are exercised. `setWifiCountry()` requires exactly 2-byte input — not tested. The persistence of wifi config through `saveStaticConfig()` / `readStaticConfig()` is not tested either.
**Fix:** Add tests for: (a) valid wifi network add and read-back, (b) index out of range, (c) password too short (< 8), (d) password too long (> 63), (e) empty SSID, (f) SSID too long (> 32), (g) `setWifiCountry()` with 2-char, 1-char, and 3-char inputs, (h) `clearWifiConfig()` resets all networks.

---

**A05-9** · MEDIUM · Missing Test Coverage – crc32() static function
**File:** app/globalconfigs.cpp:38
**Description:** `crc32()` is a standalone static method used in `readConfigs()` to validate the binary config file checksum. It is never directly tested. Its correctness for known inputs, zero-length input, and single-byte input is not verified.
**Fix:** Add direct unit tests for `GlobalConfigs::crc32()` with known input/output pairs, empty input (len=0), and single-byte inputs to verify the CRC table lookup is correct.

---

**A05-10** · MEDIUM · Missing Test Coverage – setSimCardID() / getSimCardID() / resetSimCardID()
**File:** app/globalconfigs.h:157
**Description:** SIM card ID accessors are never referenced in any test file. `setSimCardID()` enforces a length bound (< `MODEM_ICCID_LEN`) using `memset` + `qstrcpy`. No test checks the happy path, the rejection of an oversized ICCID, or the reset via `resetSimCardID()`.
**Fix:** Add tests for: (a) set and get round-trip for a valid ICCID, (b) input equal to `MODEM_ICCID_LEN` is rejected, (c) `resetSimCardID()` clears all bytes.

---

**A05-11** · MEDIUM · Missing Test Coverage – Geofence and Polygon setter validation
**File:** app/globalconfigs.h:493
**Description:** `setPolygonNPoints()`, `setPolygonLatitude()`, `setPolygonLongitude()` all accept an `int n` index and validate it against `MAX_POLY`. These boundary conditions are never tested. The boundary condition `n == MAX_POLY - 1` (last valid) and `n == MAX_POLY` (first invalid) are untested.
**Fix:** Add tests for each setter at index 0 (valid), MAX_POLY-1 (valid), MAX_POLY (invalid, expect false return), -1 (invalid, expect false return).

---

**A05-12** · MEDIUM · Missing Test Coverage – preopOncePerDayEn / setPreopOncePerDayEn signal
**File:** app/globalconfigs.h:212
**Description:** `setPreopOncePerDayEn()` emits `preopOncePerDayStatusChanged()`. This signal is never captured in a QSignalSpy in any test. The once-per-day enable flag is tested only indirectly through `readConfigs()` flow; its persistence through `saveStaticConfig()` / `readStaticConfig()` and the signal emission are not verified.
**Fix:** Add a test that installs a `QSignalSpy` on `preopOncePerDayStatusChanged`, calls `setPreopOncePerDayEn(true)` and `setPreopOncePerDayEn(false)`, and verifies the signal fires and the flag persists through a save/load cycle.

---

**A05-13** · MEDIUM · Missing Test Coverage – superListChanged signal (addSuperId / removeSuperId / setSuperId)
**File:** app/globalconfigs.cpp:639
**Description:** `setSuperId()`, `addSuperId()`, and `removeSuperId()` all emit `superListChanged`. While some tests use `gCfg->resetConfigs(true)` which calls `clearSuperIds()` (which also emits the signal), none verify that these three methods emit the signal correctly or that `superIsEmpty()` returns the correct value before and after each operation.
**Fix:** Add tests that spy on `superListChanged`, call `addSuperId()` / `removeSuperId()` / `setSuperId()`, and verify the signal fires with the correct `empty` boolean argument and that `superIsEmpty()` is consistent.

---

**A05-14** · LOW · Missing Test Coverage – resetConfigs(false) (partial reset)
**File:** app/globalconfigs.cpp:131
**Description:** The `resetConfigs()` function has two branches: `resetAll=true` clears driver lists, OD config, and VOR config; `resetAll=false` (the default) skips these. No test exercises `resetConfigs(false)` explicitly. The constructor calls `resetConfigs()` (no argument = false) but this is not independently verified. The APN preservation logic at cpp:135–203 (where existing APN/user/password values are preserved across a partial reset) is untested.
**Fix:** Add a test that sets APN, user, and password values, calls `resetConfigs()` (default/false), and verifies the APN values are preserved while other defaults are applied. Also verify the driver list is not cleared.

---

**A05-15** · LOW · Missing Test Coverage – setTimeZoneInMinutes() boundary conditions
**File:** app/globalconfigs.h:411
**Description:** `setTimeZoneInMinutes()` rejects values outside [-720, 840]. No test exercises this boundary: the valid extremes (-720, 840), first invalid values (-721, 841), and zero are not tested. `test_showTime()` calls `setTimeZoneInMinutes(60)` for display testing but does not verify the setter's return value or rejection behavior.
**Fix:** Add tests for: (a) set to -720 (valid, returns true), (b) set to 840 (valid, returns true), (c) set to -721 (invalid, returns false, value unchanged), (d) set to 841 (invalid, returns false, value unchanged).

---

**A05-16** · LOW · Missing Test Coverage – setIdleInputSource() allowed-values guard
**File:** app/globalconfigs.h:481
**Description:** `setIdleInputSource()` only accepts specific bitmask values {1, 2, 4, 8, 16, 64} and rejects everything else. No test verifies this whitelist. In particular, value 32 (between 16 and 64) and value 0 would be incorrectly accepted or rejected — it is not obvious from the code whether this whitelist is complete.
**Fix:** Add tests for each allowed value (returns true), at least two disallowed values (e.g., 0, 32, 3), and verify the stored value does not change on rejection.

---

**A05-17** · LOW · Missing Test Coverage – setGmtpId() empty and exact-length inputs
**File:** app/globalconfigs.h:51
**Description:** `setGmtpId()` rejects empty input (`id.isEmpty()`) and input of `GMTP_ID_LEN` or larger. No test checks the rejection of an empty ID, an ID of exactly `GMTP_ID_LEN` bytes (boundary off-by-one risk), or an ID with embedded null bytes.
**Fix:** Add tests for: (a) valid non-empty ID shorter than limit (returns true), (b) empty ID (returns false), (c) ID of exactly `GMTP_ID_LEN` bytes (returns false), (d) ID of `GMTP_ID_LEN - 1` bytes (returns true).

---

**A05-18** · LOW · Dirty-Flag Not Tested – saveStaticConfig() no-op when clean
**File:** app/globalconfigs.cpp:422
**Description:** `saveStaticConfig()` returns early when `m_fmsDirty == false`. This optimization is never verified by a test. If `m_fmsDirty` is incorrectly set to false, config changes will be silently lost. There is no test that confirms a save is skipped when no changes have been made, nor one that verifies a change does mark the flag dirty and a subsequent save then writes the file.
**Fix:** Add a test that: calls `saveConfigs()` to establish a clean state, modifies a value with a setter that marks `m_fmsDirty`, calls `saveConfigs()` again, then reads back and verifies the new value persisted. Complement with a test that verifies `saveStaticConfig()` does not update the file's modification timestamp when called on an already-clean config.

---

## Summary Table

| ID | Severity | Category | Brief Description |
|---|---|---|---|
| A05-1 | HIGH | Missing Coverage | readStaticConfig / saveStaticConfig not tested for errors or binary fallback |
| A05-2 | HIGH | Missing Coverage | readDynamicConfig / saveDynamicConfig incomplete coverage; maint hex fields untested |
| A05-3 | HIGH | Missing Coverage | readOdConfig / saveOdConfig / setOnDemand / clearOnDemand not tested |
| A05-4 | HIGH | Missing Coverage | readVORConfig / saveVORConfig / setConvor not tested; signal not verified |
| A05-5 | HIGH | Missing Coverage | readGeofenceConfig / saveGeofenceConfig not tested |
| A05-6 | HIGH | Untested Defect | readGeofenceConfig() has no bounds check on polygon/vertex index from file |
| A05-7 | MEDIUM | Missing Coverage | setMaintCode() double-lock guard and invalid-code rejection untested |
| A05-8 | MEDIUM | Missing Coverage | WiFi setters not tested (boundaries, persistence) |
| A05-9 | MEDIUM | Missing Coverage | crc32() static function never directly tested |
| A05-10 | MEDIUM | Missing Coverage | setSimCardID / getSimCardID / resetSimCardID not tested |
| A05-11 | MEDIUM | Missing Coverage | Polygon setter boundary conditions not tested |
| A05-12 | MEDIUM | Missing Coverage | preopOncePerDayStatusChanged signal not tested |
| A05-13 | MEDIUM | Missing Coverage | superListChanged signal from addSuperId/removeSuperId/setSuperId not tested |
| A05-14 | LOW | Missing Coverage | resetConfigs(false) partial reset and APN preservation not tested |
| A05-15 | LOW | Missing Coverage | setTimeZoneInMinutes() boundary rejection not tested |
| A05-16 | LOW | Missing Coverage | setIdleInputSource() whitelist not tested |
| A05-17 | LOW | Missing Coverage | setGmtpId() empty/boundary rejection not tested |
| A05-18 | LOW | Missing Coverage | saveStaticConfig() dirty-flag short-circuit not tested |

**Total findings: 18**
**HIGH: 6 | MEDIUM: 7 | LOW: 5**
# Audit Report – A06 · Pass 2 · Test Coverage
**Agent:** A06
**Audit run:** 2026-02-28-01
**Pass:** 2 – Test Coverage
**Branch confirmed:** master (verified via `git branch --show-current`)

---

## Files Audited

| # | File |
|---|------|
| 1 | `comm/bleexpansion.cpp` |
| 2 | `comm/bleexpansion.h` |
| 3 | `comm/bleexpansionuuid.cpp` |
| 4 | `comm/bleexpansionuuid.h` |

---

## Reading Evidence

### bleexpansion.h — Class: `BleExpansion : QObject`

**Includes:**
- `app/cigconfigs.h` (line 4)
- `<QObject>` (line 5)
- `<QDateTime>` (line 6)
- `<QBluetoothAddress>` (line 7)
- `<QBluetoothUuid>` (line 8)
- `<QQueue>` (line 9)
- `<QTimer>` (line 10)

**Public methods:**

| Line | Signature |
|------|-----------|
| 32 | `explicit BleExpansion(EM070::BleCentral *bleCentral)` |
| 34 | `void setEnabled(bool enable)` |
| 36 | `const QByteArray &deviceName() const` (inline) |
| 37 | `const QByteArray &bleVersion() const` (inline) |
| 38 | `const QByteArray &mainVersion() const` (inline) |
| 39 | `const QByteArray &manufacture() const` (inline) |
| 40 | `const QByteArray &modelNumber() const` (inline) |
| 42 | `bool digitalInput(CIGCONF::BleExpansionDI di) const` (inline) |
| 44 | `bool relayOutput(CIGCONF::BleExpansionRelay relay) const` (inline) |
| 47 | `void setRelayOutput(CIGCONF::BleExpansionRelay relay, bool state)` |
| 49 | `void setShockThreshold(quint32 threshold)` |
| 50 | `void setShockPeriod(quint32 period)` |
| 52 | `bool isShockQueueEmpty()` (inline) |
| 53 | `ShockEvent shockEvent()` (inline) |
| 55 | `void setCurrentTime(const QDateTime &time)` |
| 57 | `bool generateShockMessage(bool force)` |

**Signals:**

| Line | Signal |
|------|--------|
| 60 | `void accessible(bool yes)` |
| 61 | `void inputStateChanged(CIGCONF::BleExpansionDI input, bool state)` |
| 62 | `void shockOccurred()` |
| 63 | `void amberImpactOccurred()` |
| 64 | `void redImpactOccurred()` |

**Protected slots/events:**

| Line | Signature |
|------|-----------|
| 67 | `void timerEvent(QTimerEvent *)` |

**Private slots/methods:**

| Line | Signature |
|------|-----------|
| 103 | `void setAccessible(bool yes)` |
| 104 | `void readDeviceInfo()` |
| 105 | `void resetInputTimer()` |
| 106 | `void resetOutput()` |
| 107 | `void initRelays()` |
| 108 | `void clearShockEvent()` |
| 109 | `void popShockEvent(const QByteArray &ba)` |
| 110 | `void allowShockCountNotify(bool yes)` |
| 111 | `void characteristicRead(const quint128 &uuid, const QByteArray &ba)` |
| 112 | `void characteristicWritten(const quint128 &uuid, const QByteArray &ba)` |
| 113 | `void descriptorRead(const quint128 &uuid, const QByteArray &ba)` |
| 114 | `void descriptorWritten(const quint128 &uuid, const QByteArray &ba)` |

---

### bleexpansionuuid.h — Class: `BleExpansionUuid`

**Includes:**
- `<QBluetoothUuid>` (line 4)

**Public methods:**

| Line | Signature |
|------|-----------|
| 9 | `static inline bool equals128(const quint128 *v1, const quint128 *v2)` |

**Private static members (all `quint128`):**
`authUuid`, `deviceName`, `appearance`, `bleVersion`, `mainVersion`, `manufactureName`, `modelNumber`, `currentRtc`, `inputTimerReset`, `inputD0`–`inputD3`, `inputPullUp0`–`inputPullUp3`, `outputReset`, `outputRelay0`–`outputRelay1`, `relay0Timeout`–`relay1Timeout`, `outputD0`–`outputD3`, `openCollector0`–`openCollector3`, `shockCount`, `shockPeek`, `shockPop`, `shockThreshold`, `shockPeriod`, `shockMaxMagnitude`, `shockCountNotifyDesc` (lines 20–56)

**Friend class:** `BleExpansion` (line 58)

---

### bleexpansionuuid.cpp

Defines all 28+ `quint128` static members via `QBluetoothUuid(QStringLiteral(...)).toUInt128()`. No procedural logic — purely constant initialisation.

---

### bleexpansion.cpp — Key implementation notes

**Constructor** (line 17): Connects five signals from `BleCentral` to internal slots. Calls `m_bleCentral->setPeripheralAddress()` and `m_bleCentral->setAuthorizationCode()` with a hard-coded auth string `"uS8MgpklMx"` (line 9, `#define AUTH_CODE`).

**`timerEvent`** (line 43): Fires every 1000 ms when accessible. Reads six characteristics per tick; calls `generateShockMessage(false)`.

**`setAccessible`** (line 81): On `true`, calls `readDeviceInfo()`, `setCurrentTime()`, `setShockThreshold()`, `setShockPeriod()`, `clearShockEvent()`, `initRelays()`, reads all four digital inputs, starts the 1 s poll timer, emits `accessible(true)`.

**`characteristicRead`** (line 308): Dispatches on UUID to handle `shockCount`, `shockPeek`, `inputD0`–`inputD3`, `outputRelay0`–`outputRelay1`, and six read-only device-info UUIDs. Minimum-size guards are applied inconsistently (see findings).

**`characteristicWritten`** (line 427): Clears the appropriate `m_pending` bit-field after each confirmed write.

**`popShockEvent`** (line 200): Deserialises an 8-byte shock record via `reinterpret_cast`. Emits `amberImpactOccurred` and/or `redImpactOccurred` based on magnitude thresholds.

**`generateShockMessage`** (line 237): Accumulates the peak shock event and enqueues it when the shock timer expires.

---

## Test Coverage Search Results

The test suite (`C:/Projects/cig-audit/repos/mark3-pvd/test/`) contains four files:

| File | Purpose |
|------|---------|
| `test_backgroundworker.cpp` | AT-command parsing, background worker logic |
| `test_canbus.cpp` | CAN bus configuration and VDI mode |
| `test_dialog.cpp` | UI dialog behaviour, config file I/O |
| `test_ota.cpp` | OTA firmware update flow |

**Grep results for `BleExpansion` / `BleExpansionUuid` and all method names:**

- `CIGCONF::BleExpansionDI` is registered as a Qt meta-type in all four test files (boilerplate `qRegisterMetaType` call only — not a functional test).
- Zero occurrences of: `BleExpansion`, `BleExpansionUuid`, `characteristicRead`, `characteristicWritten`, `descriptorWritten`, `descriptorRead`, `popShockEvent`, `generateShockMessage`, `setRelayOutput`, `setShockThreshold`, `setShockPeriod`, `setAccessible`, `initRelays`, `clearShockEvent`, `allowShockCountNotify`, `equals128`.

**Conclusion: `BleExpansion` and `BleExpansionUuid` have zero test coverage.**

---

## Findings

---

**A06-1** · CRITICAL · No Test Coverage – Entire Module
**File:** `comm/bleexpansion.cpp`, `comm/bleexpansionuuid.cpp`
**Description:** Neither `BleExpansion` nor `BleExpansionUuid` has any unit or integration test. The entire BLE expansion module — covering relay control, shock event ingestion, digital input state changes, RTC sync, characteristic read/write dispatch, descriptor handling, and the UUID equality utility — executes exclusively during hardware-on-device runs with no automated regression safety net. Defects in any of these paths can only be discovered through manual testing or field failures.
**Fix:** Create a `test_bleexpansion.cpp` test class. Use a mock or stub for `BleCentral` (injectable via the existing constructor parameter). Test each UUID dispatch branch in `characteristicRead` and `characteristicWritten` with both valid and under-length payloads.

---

**A06-2** · HIGH · No Test Coverage – `generateShockMessage` Logic
**File:** `comm/bleexpansion.cpp` lines 237–252
**Description:** `generateShockMessage` contains time-comparison logic including a special backward-time case (`ts < m_shockTimestamp`, line 247) to handle clock-sync rollback. This branch enqueues a shock event based on `gCfg->shockTimer()`. None of these branches — normal expiry, forced emission, time-rollback correction — are tested. A regression in shock-timer arithmetic would go undetected until field reports of missed or duplicated shock alerts.
**Fix:** Unit-test `generateShockMessage` with fabricated `m_shockEvent1` state and controlled `gCfg->shockTimer()` values covering: (a) timer not yet expired, (b) timer expired (normal), (c) `force=true`, (d) `ts < m_shockTimestamp` rollback.

---

**A06-3** · HIGH · No Test Coverage – `popShockEvent` Threshold and Signal Emission
**File:** `comm/bleexpansion.cpp` lines 200–235
**Description:** `popShockEvent` emits `amberImpactOccurred` and `redImpactOccurred` based on configured thresholds. The amber-alert condition (`shockRedImpact / 2 < magnitude < shockRedImpact`, lines 208–210) involves integer division with no rounding guarantee and no test verifying the boundary values. A magnitude exactly equal to `shockRedImpact / 2` or `shockRedImpact` is silently excluded, which may differ from documented intent. No `QSignalSpy` tests exist for any of the three signals.
**Fix:** Add signal-spy tests using `QSignalSpy` on `amberImpactOccurred`, `redImpactOccurred`, and `shockOccurred`. Cover: magnitude below threshold, magnitude in amber zone (boundary values), magnitude exactly at red threshold, magnitude above red threshold.

---

**A06-4** · HIGH · No Test Coverage – `characteristicRead` Minimum-Size Guards
**File:** `comm/bleexpansion.cpp` lines 308–424
**Description:** `inputD0`–`inputD3` branches each require `ba.size() >= 9` (lines 331, 341, 352, 363) but the payload described in the UUID comment is nine bytes (`"\x00\x00\x00\x00\x00\x04\x00\x00\x00"`). The `shockCount` branch requires `ba.size() >= 2` (line 315). The `shockMaxMagnitude` branch requires `ba.size() >= 4` (line 421). The `outputRelay0`/`outputRelay1` branches only check `!ba.isEmpty()` (lines 375, 383). There are no tests for under-length payloads on any branch, so a malformed BLE notification with a short payload could silently discard valid data or trigger a misparse.
**Fix:** Test each `characteristicRead` UUID branch with: (a) a valid-length payload, (b) a payload one byte shorter than the minimum guard, (c) an empty payload. Confirm that short payloads are silently skipped and no state mutation occurs.

---

**A06-5** · HIGH · No Test Coverage – `characteristicWritten` Pending-Bit Clearing
**File:** `comm/bleexpansion.cpp` lines 427–506
**Description:** `characteristicWritten` manages the `m_pending` bit-field which is the sole mechanism for detecting stalled writes (checked in `timerEvent`, line 50–54). The bit-mask operations for `outputRelay` (lines 441, 448) use `&= 0x2` and `&= 0x1` respectively — but these constants are bitmasks, not the complement that would be expected for clearing a single bit (e.g., `&= ~0x1`). For a 2-bit field, `&= 0x2` correctly clears bit 0, and `&= 0x1` correctly clears bit 1 in practice, but this is non-obvious and fragile if the field width changes. No test verifies that a confirmed relay write actually clears the pending bit and that a mismatched-value confirmation leaves the bit set.
**Fix:** Test `characteristicWritten` for `outputRelay0` and `outputRelay1` with: (a) a payload matching the expected relay state (bit should clear), (b) a mismatched payload (bit should remain set), (c) an empty payload (bit should remain set).

---

**A06-6** · MEDIUM · No Test Coverage – `equals128` UUID Comparison Utility
**File:** `comm/bleexpansionuuid.h` lines 9–17
**Description:** `equals128` is the sole UUID-matching function used throughout the dispatch logic in `characteristicRead`, `characteristicWritten`, `descriptorRead`, and `descriptorWritten`. It performs a four-word `quint32` comparison via pointer reinterpretation. No test verifies correct equality detection, inequality detection, or that pointer aliasing is handled safely (i.e., that the function returns `true` when both pointers reference the same object).
**Fix:** Add unit tests for `equals128`: (a) equal UUIDs, (b) UUIDs differing in each of the four 32-bit words, (c) a pointer compared against itself.

---

**A06-7** · MEDIUM · No Test Coverage – `setCurrentTime` RTC Struct Packing
**File:** `comm/bleexpansion.cpp` lines 154–173
**Description:** `setCurrentTime` serialises a `QDateTime` into the `RtcTime` union using a `__attribute__((packed))` struct (`bleexpansion.h` line 82). The `char data[10]` array is written directly to the BLE characteristic. No test verifies that the byte-level serialisation matches the expected 10-byte GATT Current Time format (year as `quint16` LE, then month, day, hour, minute, second, dayOfWeek, reserved `quint16`). A platform alignment difference or a struct layout change would silently corrupt the device clock.
**Fix:** Test `setCurrentTime` by capturing the `QByteArray` passed to `writeCharacteristic` (via a mock `BleCentral`) and asserting each byte against expected values for a known `QDateTime` input.

---

**A06-8** · MEDIUM · No Test Coverage – `setAccessible(false)` / BLE Disconnection Path
**File:** `comm/bleexpansion.cpp` lines 81–112
**Description:** `setAccessible` handles the `yes=false` case by only emitting `accessible(false)` (line 111). It does not stop the poll timer (`m_timerId`), meaning `timerEvent` continues to fire and attempt reads on a disconnected peripheral. No test exercises the disconnection path or verifies that the timer is (or is not) stopped, or that `m_readingShocks` and `m_popTimer` are properly cleaned up on reconnect versus disconnect.
**Fix:** Test `setAccessible(false)`: verify `accessible(false)` signal is emitted, and audit whether `timerEvent` firing while `m_accessible == false` causes any unintended side effects (the `generateShockMessage(false)` call on line 72 runs unconditionally regardless of accessibility state).

---

**A06-9** · MEDIUM · No Test Coverage – `initRelays` Hardcoded Timeout Constants
**File:** `comm/bleexpansion.cpp` lines 265–287
**Description:** `initRelays` always writes `RELAY1_TIMEOUT = 60` and `RELAY2_TIMEOUT = 60` (macros defined at lines 12–13). These values are not configurable at runtime and are not tested. No test verifies the byte ordering of the little-endian 16-bit timeout encoding (low byte first, high byte second, lines 268–269, 273–274), nor that `characteristicWritten` correctly clears the `relayTimeout` pending bits when the confirmed value matches.
**Fix:** Test `initRelays` by capturing the written `QByteArray` and asserting `ba[0] == 0x3C` and `ba[1] == 0x00` (60 in little-endian). Test the matching `characteristicWritten` handler with the correct and incorrect timeout values.

---

**A06-10** · LOW · No Test Coverage – `descriptorRead` / `descriptorWritten`
**File:** `comm/bleexpansion.cpp` lines 508–526
**Description:** Both `descriptorRead` and `descriptorWritten` update `m_shockCountNotifyEnabled` based on a two-byte CCCD value. Neither function is tested. In particular, `descriptorRead` is never called from `BleCentral` connections set up in the constructor (the constructor only connects `descriptorWritten`, not `descriptorRead`), making `descriptorRead` effectively dead code. This also means `m_shockCountNotifyEnabled` can never be set to `true` through the `descriptorRead` path in production.
**Fix:** Investigate whether `descriptorRead` is intentionally excluded from the `BleCentral` signal connections. If it is needed, connect it. Add tests for both `descriptorWritten` with `0x0100` payload (enable) and `0x0000` payload (disable), and for `descriptorRead` if it is re-connected.

---

**A06-11** · LOW · No Test Coverage – `allowShockCountNotify` Is Never Called
**File:** `comm/bleexpansion.cpp` lines 300–306
**Description:** `allowShockCountNotify` is declared private and defined but is never invoked anywhere in the codebase (confirmed by source inspection). The function writes a CCCD descriptor to enable or disable BLE notifications for `shockCount`. Because it is never called, BLE notification mode for shock count is never configured at runtime. This may be intentional (poll-only design) but is undocumented and untested.
**Fix:** Determine whether notification-driven shock count is a future feature or dead code. If dead code, remove the function. If intended, add a call site and a test verifying the descriptor write payload (`0x0100` for enable, `0x0000` for disable).

---

## Summary Table

| ID | Severity | Category | Tested? |
|----|----------|----------|---------|
| A06-1 | CRITICAL | No tests – entire module | No |
| A06-2 | HIGH | `generateShockMessage` logic uncovered | No |
| A06-3 | HIGH | `popShockEvent` signal emission uncovered | No |
| A06-4 | HIGH | `characteristicRead` short-payload edge cases | No |
| A06-5 | HIGH | `characteristicWritten` pending-bit logic | No |
| A06-6 | MEDIUM | `equals128` UUID utility | No |
| A06-7 | MEDIUM | `setCurrentTime` RTC struct packing | No |
| A06-8 | MEDIUM | `setAccessible(false)` disconnection path | No |
| A06-9 | MEDIUM | `initRelays` timeout byte encoding | No |
| A06-10 | LOW | `descriptorRead` / `descriptorWritten` | No |
| A06-11 | LOW | `allowShockCountNotify` dead code | No |

**Total findings: 11**
**Tested public/private methods: 0 of 16**
**Test files examined: 4** (`test_backgroundworker.cpp`, `test_canbus.cpp`, `test_dialog.cpp`, `test_ota.cpp`)
# Pass 2 – Test Coverage Audit: A07

**Agent:** A07
**Audit Run:** 2026-02-28-01
**Pass:** 2 – Test Coverage
**Branch Confirmed:** master (verified via `git branch --show-current`)

---

## Files Audited

| File | Lines |
|------|-------|
| `comm/bleinputhandler.h` | 64 |
| `comm/bleinputhandler.cpp` | 354 |
| `comm/canexpansion.h` | 131 |
| `comm/canexpansion.cpp` | 670 |

---

## Reading Evidence

### bleinputhandler.h

**Class:** `BleInputHandler : public QObject`

**Enum:**
- `DigitalFormat` { `SessionFormat`, `UsageFormat`, `OnDemandFormat` } (line 18)

**Public Methods:**

| Method | Line |
|--------|------|
| `BleInputHandler(CanExpansion *canExpansion)` (constructor) | 20 |
| `void updateIgnition(CIGCONF::PowerState state)` | 22 |
| `void updateBleInput(CIGCONF::BleExpansionDI input, bool state)` | 23 |
| `void changeBleState(bool connected)` | 24 |
| `void updateIdleTimer()` | 26 |
| `QByteArray digitalInputs(DigitalFormat format, bool autoReset)` | 28 |

**Signals:**

| Signal | Line |
|--------|------|
| `void idleTimeout()` | 31 |
| `void sendGmtpMessage(CIGCONF::GmtpMessage msg, const QByteArray &extra)` | 32 |

**Private Methods (slots/helpers):**

| Method | Line |
|--------|------|
| `void resetStates()` | 36 |
| `void onTimerEvent()` | 37 |
| `void sendSeenSafeReport(bool state)` | 38 |

**Private Members:**
- `CanExpansion *m_canExpansion` (line 50)
- `QTimer *m_timer` (line 51) — idle timer, nullable
- `QTimer *m_digInputModeTimer` (line 52) — single-shot debounce timer
- `InputState m_ignition` (line 54)
- `InputState m_bleInputs[4]` (line 55) — fixed-size array, indices 0-3
- `bool m_bypassReset` (line 56)
- `bool m_bleConnected` (line 57)
- `bool m_seenState` (line 58) — **not initialized in constructor**
- `quint64 m_lastSeenReport` (line 59)
- `bool m_seenSecond` (line 60)
- `quint32 m_seenTimestamp` (line 61)

**Includes:** `app/cigconfigs.h`, `<QObject>`

---

### bleinputhandler.cpp

**Includes:** `bleinputhandler.h`, `comm/canexpansion.h`, `app/globalconfigs.h`, `platform/seriallogger.h`, `<QTimer>`

**Constructor (line 7-23):**
- `m_seenState` is not in member-initialization list (indeterminate value)
- Connects `CanExpansion::inputStateChanged` to `updateBleInput`
- Connects `CanExpansion::accessible` to `changeBleState`
- Connects `m_digInputModeTimer::timeout` to `onTimerEvent`

**`resetStates()` (line 25-38):**
- Uses `memset` on `m_ignition` and `m_bleInputs[4]` — safe for fixed-size structs
- `m_seenState` is NOT reset here either

**`updateIgnition()` (line 40-79):**
- `delta = (clock - m_ignition.clock) / 100` — no backward-clock guard; unsigned wraparound corrupts accumulators
- quint32 accumulation fields susceptible to overflow on long-running deployments
- Calls `resetStates()` which calls `updateIdleTimer()` — no infinite loop but indirect re-entry

**`updateBleInput()` (line 115-176):**
- `index = input - CIGCONF::BleExpDI1` — no bounds check before `m_bleInputs[index]` access
- `m_digInputModeTimer->start()` called only when `index == 2` and SeenSafety mode

**`digitalInputs()` (line 257-353):**
- `OnDemandFormat` branch returns early (line 296), skipping BLE input accumulation entirely
- When `!m_bleConnected`, BLE input loop breaks at line 276 but stale values are still emitted in format output
- Hardcoded ` 5: 0 0 0` and ` 10: 0 0 0` sentinels (lines 328, 350)

---

### canexpansion.h

**Class:** `CanExpansion : public QObject`

**Public Struct:** `ShockEvent` (line 25-40) — 13 fields

**Public Methods:**

| Method | Line |
|--------|------|
| `CanExpansion(EM070::CanBus*, EM070::PowerSupply*)` (constructor) | 42 |
| `void setEnabled(bool enable)` | 44 |
| `const QByteArray &deviceName() const` | 46 |
| `const QByteArray &bleVersion() const` | 47 |
| `const QByteArray &mainVersion() const` | 48 |
| `const QByteArray &manufacture() const` | 49 |
| `const QByteArray &modelNumber() const` | 50 |
| `bool relayOutput(CIGCONF::BleExpansionRelay relay) const` | 52 |
| `void setRelayOutput(CIGCONF::BleExpansionRelay relay, bool state)` | 55 |
| `quint16 relayTimeout(CIGCONF::BleExpansionRelay relay) const` | 57 |
| `void setRelayTimeout(CIGCONF::BleExpansionRelay relay, quint16 timeout_in_sec)` | 60 |
| `void setCurrentTime(quint32 time)` | 62 |
| `bool digitalInput(CIGCONF::BleExpansionDI di) const` | 64 |
| `void setShockThreshold(quint32 threshold)` | 66 |
| `void setShockPeriod(quint32 period)` | 67 |
| `bool isShockQueueEmpty()` | 69 |
| `ShockEvent shockEvent()` | 70 |
| `bool generateShockMessage(bool force)` | 72 |
| `void setGnssReceiver(EM070::GnssReceiver* gnss)` | 74 |

**Signals:**

| Signal | Line |
|--------|------|
| `void inputStateChanged(CIGCONF::BleExpansionDI input, bool state)` | 77 |
| `void shockOccurred()` | 78 |
| `void amberImpactOccurred()` | 79 |
| `void redImpactOccurred()` | 80 |
| `void accessible(bool yes)` | 81 |
| `void expModInfo(QByteArray mainVersion)` | 82 |
| `void inactiveNotification(bool inactive, quint32 secs)` | 83 |
| `void relayStateChanged(bool relay1, bool relay2)` | 84 |

**Private Methods:**

| Method | Line |
|--------|------|
| `void initialise()` | 87 |
| `void updateBusConfig()` | 88 |
| `void readCanFrame(quint32 id, const QByteArray &ba)` | 89 |
| `void packetHandler()` | 90 |
| `void writeFrame()` | 91 |
| `void timeout()` | 92 |
| `void sendPacket(uint16_t cmd, const QByteArray &ba)` | 94 |
| `void initRelays()` | 96 |
| `void clearShockEvent()` | 97 |
| `void popShockEvent(const QByteArray &ba)` | 98 |

**Includes:** `app/cigconfigs.h`, `<QObject>`, `<QFile>`, `<QMap>`, `<QVector>`, `<QByteArray>`, `<QQueue>`, `<QTimer>`

---

### canexpansion.cpp

**Includes:** `canexpansion.h`, `platform/canbus.h`, `app/globalconfigs.h`, `platform/seriallogger.h`, `platform/gnssreceiver.h`, `platform/powersupply.h`, `<QApplication>`, `<QTimer>`, `<QDateTime>`, `<QFile>`, `<QDebug>`, `<QDataStream>`

**`readCanFrame()` (line 128-160):**
- `static bool esc = false` — static local persists across all calls and reconnections; not reset on disconnect
- Buffer overflow protection at line 158 truncates `m_rx` to last 256 bytes — discards framing context, may corrupt reassembly

**`packetHandler()` (line 249-467):**
- `static quint16 sm = 0` and `static quint16 shocks_read = 0` — static locals persist across reconnections
- State machine is never reset when `setEnabled(false)` + `setEnabled(true)` cycle occurs
- Minimum size check `m_rx.size() < 3` (line 257) guards header; CMD_DIGIN_STATE* cases check `< 12` (lines 353, 369, 385, 401)
- CMD_SHOCK_PEEK checks `< 11` (line 440); `popShockEvent` independently checks `>= 8`
- Unknown CMD values fall through with no default case or logging

**`sendPacket()` (line 202-229):**
- `m_tx` truncated to last 256 bytes when exceeded — can silently discard partially-encoded SLIP packets

**`popShockEvent()` (line 608-665):**
- `m_gnssReceiver` null-check present at line 621 — safe
- `m_powerSupply` used without null-check at line 633

**`generateShockMessage()` (line 572-597):**
- Line 592: explicit `ts < m_shockTimestamp` time-wrap guard — partial mitigation

---

## Test Coverage Search Results

**Test directory:** `C:/Projects/cig-audit/repos/mark3-pvd/test/`

**Files present:**
- `test_backgroundworker.cpp` / `.h`
- `test_canbus.cpp` / `.h`
- `test_dialog.cpp` / `.h`
- `test_ota.cpp` / `.h`

**Grep results — all class names and every public method searched:**

| Search Term | Matches in test/ |
|-------------|------------------|
| `BleInputHandler` | 0 |
| `CanExpansion` | 0 |
| `updateIgnition` | 0 |
| `updateBleInput` | 0 |
| `changeBleState` | 0 |
| `updateIdleTimer` | 0 |
| `digitalInputs` | 0 |
| `readCanFrame` | 0 |
| `packetHandler` | 0 |
| `sendPacket` | 0 |
| `writeFrame` | 0 |
| `setRelayOutput` | 0 |
| `setRelayTimeout` | 0 |
| `setCurrentTime` | 0 |
| `setShockThreshold` | 0 |
| `setShockPeriod` | 0 |
| `generateShockMessage` | 0 |
| `clearShockEvent` | 0 |
| `popShockEvent` | 0 |
| `setGnssReceiver` | 0 |
| `setEnabled` | 0 |
| `isShockQueueEmpty` | 0 |
| `shockEvent` (method) | 0 |
| `BleExpansionDI` | 4 (only `qRegisterMetaType` boilerplate in unrelated tests) |

**Conclusion:** Zero test coverage. Neither `BleInputHandler` nor `CanExpansion` is instantiated, exercised, or referenced in any test. The `BleExpansionDI` meta-type registrations appear only as boilerplate for signal/slot cross-thread use in unrelated tests.

---

## Findings

---

**A07-1** · CRITICAL · Missing Test Coverage — Both Classes
**File:** `comm/bleinputhandler.cpp`, `comm/canexpansion.cpp`
**Description:** Neither `BleInputHandler` nor `CanExpansion` has any unit or integration test. Zero test files instantiate these classes, invoke any method, or assert any output or signal. These two classes are responsible for CAN bus communication, BLE expansion module state, shock event handling, relay control, and idle timeout — all safety-relevant and security-relevant subsystems. The complete absence of test coverage means no regression protection exists for any of this logic.
**Fix:** Create `test/test_ble_can_expansion.cpp` with a dedicated test class. Use mock or stub implementations of `CanBus`, `PowerSupply`, and `GnssReceiver`. Cover at minimum: constructor initialization state, all three `DigitalFormat` branches of `digitalInputs()`, `updateIgnition()` with all `PowerState` values, `updateBleInput()` for each of the four DI indices, `changeBleState()` connected/disconnected transitions, `generateShockMessage()` with and without a pending event, and `popShockEvent()` with valid and undersized payloads.

---

**A07-2** · HIGH · Uninitialized Member — `m_seenState`
**File:** `comm/bleinputhandler.h`:58, `comm/bleinputhandler.cpp`:7-23
**Description:** `m_seenState` is declared at line 58 and used in `onTimerEvent()` at line 85 as a state comparison (`if (m_seenState == newState) return;`), but it is never initialized in the constructor member-initialization list and is not set in `resetStates()`. The comparison with `m_bleInputs[2].state` (zero-initialized by `memset`) may produce an incorrect equality on the first timer fire, suppressing the first SeenSafe report that should be emitted.
**Fix:** Add `m_seenState(false)` to the constructor member-initialization list and add `m_seenState = false;` to `resetStates()`. Add a unit test asserting that the first `onTimerEvent()` invocation after a state change on input 3 always emits the `sendGmtpMessage` signal.

---

**A07-3** · HIGH · Out-of-Bounds Array Access — `updateBleInput()`
**File:** `comm/bleinputhandler.cpp`:117-119
**Description:** `index = input - CIGCONF::BleExpDI1` is computed without any bounds validation before it is used to index `m_bleInputs[4]` (a fixed-size four-element array). If the `CIGCONF::BleExpansionDI` enum value passed in is less than `BleExpDI1` or greater than `BleExpDI4`, the subtraction yields a negative signed result (silently cast to a large positive size on array access) or a value >= 4, causing undefined behavior. This value arrives from a CAN-frame-decoded signal in `CanExpansion::packetHandler()`, meaning a malformed incoming CAN frame can trigger this path.
**Fix:** Insert a bounds check immediately after computing `index`:
```cpp
if (index < 0 || index >= 4) {
    SerialLogger::log("[BLE:DIG] Invalid DI index\r\n");
    return;
}
```
Add a test case that calls `updateBleInput()` with an out-of-range enum value and verifies no crash and no state change occurs.

---

**A07-4** · HIGH · Static Local State Never Reset on Reconnection — `packetHandler()`
**File:** `comm/canexpansion.cpp`:251-252
**Description:** `static quint16 sm = 0` (state machine cursor) and `static quint16 shocks_read = 0` (shock read counter) are function-local statics that persist for the entire process lifetime. When the BLE expansion module disconnects and reconnects — whether via `setEnabled(false)/setEnabled(true)` or a `timeout()` re-initialisation cycle — these variables retain previous values. The handshake can resume from an arbitrary mid-sequence state, silently skipping the device-name → firmware-version → model-number chain, leaving version fields empty and relay/shock configuration unapplied.
**Fix:** Promote `sm` and `shocks_read` to member variables (`m_packetSm` and `m_shocksRead`) initialized to 0 in the constructor, and reset them in `setEnabled(false)` and at the start of `initialise()`. Add integration tests simulating a disconnect/reconnect cycle and verifying the full handshake re-executes.

---

**A07-5** · HIGH · Static Local SLIP Escape Flag Never Reset on Reconnection — `readCanFrame()`
**File:** `comm/canexpansion.cpp`:130
**Description:** `static bool esc = false` persists across reconnection events. If the BLE expansion module disconnects mid-SLIP-escape sequence (after sending `SLIP_ESC` but before the continuation byte), `esc` remains `true`. On reconnection, the first byte of the new device-name response will be misinterpreted as an escape continuation, corrupting `m_rx` and causing `packetHandler()` to discard or misparse the response header.
**Fix:** Promote `esc` to a member variable `m_slipEsc` initialized to `false` in the constructor, and reset it in `setEnabled(false)`, `initialise()`, and wherever `m_rx` is cleared. Add a unit test that feeds a partial SLIP frame ending in `SLIP_ESC` followed by a valid complete frame after a simulated reconnect, and verifies the second frame is parsed correctly.

---

**A07-6** · MEDIUM · Silent Buffer Truncation Corrupts Protocol State — `readCanFrame()` and `sendPacket()`
**File:** `comm/canexpansion.cpp`:158-159, 225-226
**Description:** Both `m_rx` (receive) and `m_tx` (transmit) buffers are silently truncated to the last 256 bytes when they exceed `MAX_BUFFER_SIZE`. For `m_rx`, truncation discards the beginning of the accumulated SLIP frame, leaving a fragment that will fail the `packetHandler()` header check but still consume processing time with no log entry. For `m_tx`, truncation discards the oldest queued data, potentially cutting a SLIP-encoded CAN frame mid-stream. Neither path logs a warning or increments an error counter.
**Fix:** Log a `SerialLogger` warning when either buffer is truncated. For `m_rx`, clear the buffer entirely on overflow (partial frames are invalid anyway) rather than keeping an arbitrary suffix. For `m_tx`, evaluate whether the queue should be cleared entirely. Add test cases that inject more than 256 bytes into `readCanFrame()` and verify the buffer is handled deterministically.

---

**A07-7** · MEDIUM · Integer Overflow in Time Accumulation Fields — Backward Clock Not Guarded
**File:** `comm/bleinputhandler.cpp`:50, 65-66, 130-133, 135-136, 184-191, 263-287
**Description:** All delta computations (`delta = (clock - is.clock) / 100`) use unsigned arithmetic. If `gCfg->clockTime()` returns a value smaller than `is.clock` due to a clock synchronization event, NTP adjustment, or device restart without counter reset, the subtraction wraps around to a very large quint64, which after division by 100 still produces a huge quint32 delta, corrupting all accumulated time values. No guard is present in `BleInputHandler` — compare to the partial guard in `generateShockMessage()` at line 592 of `canexpansion.cpp`.
**Fix:** Add a backward-clock guard in all delta computations:
```cpp
quint32 delta = (clock >= is.clock) ? (quint32)((clock - is.clock) / 100) : 0;
```
Add unit tests with a simulated clock that goes backward and verify counters do not corrupt.

---

**A07-8** · MEDIUM · BLE Input Stats Silently Under-Counted When Disconnected — `digitalInputs()`
**File:** `comm/bleinputhandler.cpp`:274-288, 320-325
**Description:** When `m_bleConnected` is `false`, the time-accumulation loop for `m_bleInputs` breaks immediately at line 276, so the elapsed time since the last `digitalInputs()` call is not applied to the BLE input time fields. The formatting loop at lines 320-325 still emits the four BLE input entries with their stale (under-counted) `sessionOnTime`/`sessionOffTime` values. Callers requesting `SessionFormat` or `UsageFormat` data while the module is disconnected receive under-counted values proportional to the gap between the last `digitalInputs()` call and the disconnect event.
**Fix:** Document this behavior explicitly with a comment, or apply the remaining elapsed delta within `digitalInputs()` similarly to what `changeBleState()` does at disconnect time. Add a test that calls `digitalInputs()` after `changeBleState(false)` and verifies the returned byte array does not contain stale-gap values.

---

**A07-9** · MEDIUM · `m_powerSupply` Used Without Null Guard — `popShockEvent()`
**File:** `comm/canexpansion.cpp`:633
**Description:** `m_powerSupply->isIgnitionOn()` is called unconditionally at line 633. While the constructor requires a non-null `PowerSupply*`, there is no null guard at the call site, unlike `m_gnssReceiver` which is checked at line 621. If future refactoring or a test harness passes a null `ps`, this produces an immediate null-pointer dereference. The asymmetry with `m_gnssReceiver` indicates inconsistent null-safety convention.
**Fix:** Add a null guard: `if (m_powerSupply) event.isIgnitionOn = m_powerSupply->isIgnitionOn();` — or enforce non-null via `Q_ASSERT(ps)` in the constructor. Add a unit test with a null `PowerSupply` stub verifying no crash occurs.

---

**A07-10** · MEDIUM · SLIP Framing Edge Cases Untested — `readCanFrame()`
**File:** `comm/canexpansion.cpp`:128-160
**Description:** The SLIP decoder has several untested edge cases: (1) back-to-back `SLIP_END` bytes (zero-length payload) — the `m_rx.size() > 0` guard at line 146 correctly skips dispatch but is untested; (2) `SLIP_ESC` split across two `readCanFrame()` calls at the 8-byte CAN frame boundary — the static `esc` persists correctly but this cross-call behavior has no test; (3) `SLIP_ESC` followed by a byte that is neither `SLIP_ESC_ESC` nor `SLIP_ESC_END` — the current code falls into neither branch in lines 137-142 but still appends `b` to `m_rx` unmodified via the `else` on line 153, silently corrupting the decoded payload.
**Fix:** Add tests for: (a) zero-length SLIP frames, (b) `SLIP_ESC` split across two calls, and (c) `SLIP_ESC` followed by an invalid continuation byte. For case (c), log an error and reset escape state without appending the invalid byte.

---

**A07-11** · MEDIUM · `shocks_read` Counter Can Stall Shock Queue Drainage
**File:** `comm/canexpansion.cpp`:423-432
**Description:** The static `shocks_read` counter (see also A07-4) is only reset when `count == 0` or `shocks_read >= 3`, limiting peek/pop cycles to three per `timeout()` interval. If the firmware shock queue contains more than three events and the counter is not reset between reconnections, remaining shock events are never dequeued until the next disconnect/reconnect cycle. The queue silently stalls, and unprocessed shock events may be lost when the firmware discards them.
**Fix:** As part of the A07-4 fix, ensure `m_shocksRead` is reset to 0 both on reconnection and whenever `sm` transitions back to `CMD_DIGIN_STATE0`. Add a test that simulates a `CMD_SHOCK_COUNT` response indicating 5 pending shocks and verifies all are eventually dequeued across multiple timer cycles.

---

**A07-12** · LOW · `OnDemandFormat` Returns Only Ignition Data — Undocumented
**File:** `comm/bleinputhandler.cpp`:290-296
**Description:** The `OnDemandFormat` branch returns a single string containing only `m_ignition.sessionOnTime` and exits immediately. BLE input data is not included. There is no documentation at the method declaration, the enum definition, or the branch itself to communicate this restriction. A caller requesting `OnDemandFormat` while expecting a full digital input report will silently receive an incomplete result.
**Fix:** Add a comment block above `digitalInputs()` documenting that `OnDemandFormat` returns only ignition data. Consider whether BLE DI data should be included. Add a test asserting the format and field count of each of the three `DigitalFormat` variant outputs.

---

**A07-13** · LOW · Integer Overflow in Inactive Notification Duration — `timeout()`
**File:** `comm/canexpansion.cpp`:187-190
**Description:** At line 188, `m_inactiveCount * TIMER / 1000` computes the inactive duration in seconds. `m_inactiveCount` is `quint32` and `TIMER` is a plain `int` literal (2000). The intermediate product `m_inactiveCount * TIMER` is evaluated as a 32-bit multiplication before the division, and can overflow when `m_inactiveCount` exceeds approximately 2,147,483 (roughly 49 days of 500 ms timer ticks). The overflow produces a truncated or negative duration value passed to `inactiveNotification()`.
**Fix:** Cast before multiplication: `(quint64)m_inactiveCount * TIMER / 1000` and update the signal parameter type if necessary, or cap `m_inactiveCount` at a reasonable maximum. Add a test with a large inactive count value verifying the emitted duration is correct.

---

## Summary Table

| ID | Severity | Category | File | Line | Tested? |
|----|----------|----------|------|------|---------|
| A07-1 | CRITICAL | Missing Test Coverage | bleinputhandler.cpp, canexpansion.cpp | — | No — zero coverage |
| A07-2 | HIGH | Uninitialized Member | bleinputhandler.h:58, bleinputhandler.cpp:7 | 58 / 7 | No |
| A07-3 | HIGH | Out-of-Bounds Array Access | bleinputhandler.cpp | 117 | No |
| A07-4 | HIGH | Static State Not Reset on Reconnect | canexpansion.cpp | 251 | No |
| A07-5 | HIGH | Static SLIP Escape Flag Not Reset | canexpansion.cpp | 130 | No |
| A07-6 | MEDIUM | Silent Buffer Truncation | canexpansion.cpp | 158, 225 | No |
| A07-7 | MEDIUM | Backward Clock Overwrites Accumulators | bleinputhandler.cpp | 50, 65, 130, 184 | No |
| A07-8 | MEDIUM | BLE Stats Under-Counted When Disconnected | bleinputhandler.cpp | 274 | No |
| A07-9 | MEDIUM | Null Dereference Risk — m_powerSupply | canexpansion.cpp | 633 | No |
| A07-10 | MEDIUM | SLIP Framing Edge Cases Untested | canexpansion.cpp | 128 | No |
| A07-11 | MEDIUM | Shock Queue Stalls After 3 Events Per Cycle | canexpansion.cpp | 423 | No |
| A07-12 | LOW | OnDemandFormat Undocumented Partial Return | bleinputhandler.cpp | 290 | No |
| A07-13 | LOW | Inactive Duration Multiplication Overflow | canexpansion.cpp | 187 | No |

**Total findings:** 13 (1 Critical, 4 High, 6 Medium, 2 Low)

**Overall coverage verdict:** ZERO. No test file references either class. No method, signal, or edge case has any automated test.
# Security Audit – Pass 2: Test Coverage
**Agent:** A08
**Audit Run:** 2026-02-28-01
**Branch Confirmed:** master (verified via `git branch --show-current`)
**Date:** 2026-02-28

---

## Files Under Review

| File | Lines |
|------|-------|
| `comm/canmonitor.h` | 150 |
| `comm/canmonitor.cpp` | 1656 |
| `comm/canstatehandler.h` | 53 |
| `comm/canstatehandler.cpp` | 207 |

---

## Reading Evidence

### canmonitor.h – Class: `CanMonitor` (inherits QObject)

**Includes:**
- `app/cigconfigs.h`
- `<QObject>`, `<QFile>`, `<QMap>`, `<QVector>`
- Forward declarations: `EM070::CanBus`, `QTimer`

**Public Methods:**

| Line | Method | Signature |
|------|--------|-----------|
| 20 | Constructor | `explicit CanMonitor(EM070::CanBus *canBus)` |
| 22 | `readCanConfig` | `bool readCanConfig()` |
| 23 | `readOldCanConfig` | `bool readOldCanConfig()` |
| 24 | `saveCanConfig` | `void saveCanConfig()` |
| 25 | `calculateCanCrc` | `void calculateCanCrc()` |
| 28 | `canCrc32` | `quint32 canCrc32() const` (inline) |
| 30 | `setEnabled` | `void setEnabled(bool enable)` |
| 32 | `clearCanConfig` | `void clearCanConfig()` |
| 33 | `canBusConfig` | `QByteArray canBusConfig() const` |
| 34 | `setCanBusConfig` | `bool setCanBusConfig(const QByteArray &config)` |
| 35 | `canPgnConfig` | `QByteArray canPgnConfig() const` |
| 36 | `setCanPgnConfig` | `bool setCanPgnConfig(const QByteArray &config)` |
| 37 | `canSpnConfig` | `QByteArray canSpnConfig() const` |
| 38 | `setCanSpnConfig` | `bool setCanSpnConfig(const QByteArray &config)` |
| 39 | `canAttConfig` | `QByteArray canAttConfig() const` |
| 40 | `setCanAttConfig` | `bool setCanAttConfig(const QByteArray &config)` |
| 41 | `canLinConfig` | `QByteArray canLinConfig() const` |
| 42 | `setCanLinConfig` | `bool setCanLinConfig(const QByteArray &config)` |
| 43 | `canBydConfig` | `QByteArray canBydConfig() const` |
| 44 | `setCanBydConfig` | `bool setCanBydConfig(const QByteArray &config)` |
| 45 | `canLin2Config` | `QByteArray canLin2Config() const` |
| 46 | `setCanLin2Config` | `bool setCanLin2Config(const QByteArray &config)` |
| 48 | `isXferEnabled` | `bool isXferEnabled() const` (inline) |
| 49 | `attributeName` | `QByteArray attributeName(quint8 index) const` (inline) |
| 50 | `attributeType` | `CIGCONF::CanAttributeType attributeType(quint8 index) const` (inline) |
| 52 | `setVdiAccess` | `void setVdiAccess(bool access, bool inhibit)` |
| 53 | `enableVdi` | `void enableVdi(bool enable)` |

**Signals:**

| Line | Signal |
|------|--------|
| 60 | `void resetCanStates(bool resetLast)` |
| 61 | `void stateUpdated(quint8 index, quint32 state)` |

**Private Methods (referenced in test scope via `friend class TestCanbus`):**

| Line | Method |
|------|--------|
| 101 | `perfTimer()` |
| 107 | `readCanConfig()` |
| 418 | `findPgnIndex(quint32 rspId, quint32 reqId)` |
| 437 | `newPgnIndex()` |
| 447 | `childSpnIndexes(quint8 pgnIndex)` |
| 1193 | `attributePollingRate(quint32 namePattern)` |
| 1231 | `createRequest(quint8 spnIndex, quint32 pollingRate)` |
| 1301 | `updateBusConfig()` |
| 1313 | `updateRequests()` |
| 1369 | `readCanFrame(quint32 id, const QByteArray &ba)` |
| 1474 | `updateState(quint8 spnIndex, quint64 data)` |
| 1526 | `updateSpnState(quint8 spnIndex, quint64 data)` |
| 1600 | `initVdi()` |
| 1627 | `configureVdiAccessRequest()` |

---

### canstatehandler.h – Class: `CanStateHandler` (inherits QObject)

**Includes:**
- `app/cigconfigs.h`
- `<QObject>`
- Forward declarations: `CanMonitor`, `QTimer`

**Public Methods:**

| Line | Method |
|------|--------|
| 14 | `enum DigitalFormat {SessionFormat, UsageFormat, OnDemandFormat}` |
| 16 | `explicit CanStateHandler(CanMonitor *canMonitor)` |
| 17 | `void updateIdleTimer()` |
| 18 | `QByteArray canStates(DigitalFormat format, bool autoReset)` |
| 19 | `void resetStates(bool resetLast)` |

**Signals:**

| Line | Signal |
|------|--------|
| 22 | `void idleTimeout()` |

**Private Methods:**

| Line | Method |
|------|--------|
| 45 | `void updateState(quint8 index, quint32 state)` (private slot, connected from `CanMonitor::stateUpdated`) |

---

## Test Coverage Analysis

### Test Infrastructure

- Test project file: `mk3-test.pro` – defines `UNIT_TEST`, compiles both `comm/canmonitor.cpp` and `comm/canstatehandler.cpp`
- Test class: `TestCanbus` (declared friend of `CanMonitor` via `#ifdef UNIT_TEST` at `canmonitor.h:55–57`)
- Test file: `test/test_canbus.cpp` – contains a single test method: `test_vdiMode()`
- Test framework: Qt Test (`QTest`)

### Coverage Table – CanMonitor Public Methods

| Method | Tested | Test Name | Notes |
|--------|--------|-----------|-------|
| `CanMonitor()` constructor | Indirect | `initTestCase` | Via `BackgroundWorker::initialiseCanbus1()` |
| `readCanConfig()` | No | – | No direct test; only invoked implicitly at construction |
| `readOldCanConfig()` | No | – | Not tested at all |
| `saveCanConfig()` | No | – | Not tested |
| `calculateCanCrc()` | No | – | Not tested |
| `canCrc32()` | No | – | Not tested |
| `setEnabled()` | No | – | Not tested |
| `clearCanConfig()` | Indirect | `test_vdiMode` | Via `at^clrcan` AT command |
| `canBusConfig()` | Partial | `test_vdiMode` | Only VDI mode path checked |
| `setCanBusConfig()` | Partial | `test_vdiMode` | Only via VDI init path |
| `canPgnConfig()` | No | – | Not tested |
| `setCanPgnConfig()` | No | – | Not tested |
| `canSpnConfig()` | No | – | Not tested |
| `setCanSpnConfig()` | No | – | Not tested |
| `canAttConfig()` | Partial | `test_vdiMode` | Only VDI mode values checked |
| `setCanAttConfig()` | Partial | `test_vdiMode` | Only via VDI init path |
| `canLinConfig()` | Partial | `test_vdiMode` | Only VDI mode values checked |
| `setCanLinConfig()` | Partial | `test_vdiMode` | Only via VDI init path |
| `canBydConfig()` | No | – | Not tested |
| `setCanBydConfig()` | No | – | Not tested |
| `canLin2Config()` | No | – | Not tested |
| `setCanLin2Config()` | No | – | Not tested |
| `isXferEnabled()` | No | – | Not tested |
| `attributeName()` | No | – | Not tested directly |
| `attributeType()` | No | – | Not tested directly |
| `setVdiAccess()` | Partial | `test_vdiMode` | Signal pathway tested, but not non-VDI guard |
| `enableVdi()` | Indirect | `test_vdiMode` | enable=true path only |

### Coverage Table – CanMonitor Private Methods

| Method | Tested | Notes |
|--------|--------|-------|
| `readCanFrame()` | No | Core CAN frame processing; never exercised in tests |
| `updateState()` | No | Never exercised in tests |
| `updateSpnState()` | No | Never exercised in tests |
| `findPgnIndex()` | No | Not tested |
| `newPgnIndex()` | No | Not tested |
| `childSpnIndexes()` | No | Not tested |
| `attributePollingRate()` | No | Not tested |
| `createRequest()` | Indirect | Exercised through VDI init only; LindeExtended/J1939/BydCan/Linde1202 paths untested |
| `updateBusConfig()` | Partial | Called in `forceCanbusUpdate()` helper, but only checks VDI state |
| `updateRequests()` | Partial | Called in `forceCanbusUpdate()` helper, but only checks VDI state |
| `initVdi()` | Indirect | Called through `enableVdi(true)` path |
| `configureVdiAccessRequest()` | Partial | Three states tested (access+inhibit, access+no-inhibit, no access) |
| `perfTimer()` | No | Not tested (disabled by `PERF_MON=0`) |
| `calculateCanCrc()` | No | Not tested |

### Coverage Table – CanStateHandler

| Method | Tested | Notes |
|--------|--------|-------|
| `CanStateHandler()` constructor | No | Not directly tested; constructed as part of BackgroundWorker but no assertions made |
| `updateIdleTimer()` | No | No test covers idle timer configuration or triggering |
| `canStates()` | No | No test calls this method directly or verifies its output |
| `resetStates()` | No | Connected via signal; not directly verified in any test |
| `updateState()` (private slot) | No | No test injects `stateUpdated` signals to verify state machine transitions |
| `idleTimeout` signal | No | Never verified to fire in tests |

---

## Findings

**A08-1** · CRITICAL · Missing Test Coverage – Core CAN Frame Processing
**File:** `comm/canmonitor.cpp:1369`
**Description:** `readCanFrame()` is the primary entry point for all inbound CAN bus data. It dispatches across four protocol branches (J1939, LindeExtended, BydCan, Linde1202), each with distinct bit-extraction and frame-matching logic. Zero tests exercise this method. Malformed, undersized, or adversarially crafted CAN frames are never validated under test. The `LindeExtended` branch pads short frames silently (`b.append(8-b.size(), (char)0)`) – padding behaviour is untested. The `BydCan` branch returns early for frames shorter than 8 bytes but this guard is untested. The Linde1202 branch applies a response mask (`spnResponseMask`) to filter frames – this filtering is untested.
**Fix:** Add unit tests that inject synthetic CAN frames via a mock `CanBus::read` signal for each protocol variant. Include: correct frames, frames shorter than 8 bytes, frames with PGN not in the config table, frames where the mask filter should suppress processing, and maximum-length edge cases.

---

**A08-2** · CRITICAL · Missing Test Coverage – SPN State Update and Bit Extraction
**File:** `comm/canmonitor.cpp:1526`
**Description:** `updateSpnState()` implements a custom MSB-first bit extraction algorithm at lines 1546–1558. It computes `bitA` and `bitR` from `spnConfig.offset`, then extracts bits. An arithmetic edge case exists at line 1538: `spnMask = (1U << spnConfig.width) - 1`. If `spnConfig.width` is 32, this expression causes undefined behaviour in C++ (left-shifting a 32-bit value by its full width). The width field is validated to be in range 1–255 by `setCanSpnConfig()`, but is read directly from file in `readCanConfig()` / `readOldCanConfig()` without re-validation. No tests exercise any opcode path ('>', '=', '-', 'b') nor the BCD decoder at lines 1574–1587.
**Fix:** Add unit tests for each opcode ('>', '=', '-', 'b') with known input data and expected state output. Add a test for width=32 and width=0. Add a test where data read from a corrupted config file contains width=32 to confirm the UB path cannot be reached via file input without validation.

---

**A08-3** · HIGH · Missing Test Coverage – Config File Parsing (readCanConfig / readOldCanConfig)
**File:** `comm/canmonitor.cpp:107`, `comm/canmonitor.cpp:209`
**Description:** `readCanConfig()` and `readOldCanConfig()` perform `memcpy` of fixed-size binary structs from a file into internal arrays. The file size is checked before reading, but the CRC covers the entire blob: no per-field range validation is performed after the `memcpy`. Fields such as `SpnConfig.pgnIndex` (used as an array index at line 1234), `AttConfig.spnIndex` (used as an array index at line 1331), and `AttConfig.spnIndex2` (used at line 1337) could contain out-of-bounds values if the file is corrupt or tampered with. No test exercises reading a file with a valid CRC but out-of-range index fields, nor reading a file where the version field is unexpected (e.g., ver=0 or ver=3).
**Fix:** Add tests for: (1) missing config file returns false; (2) file with invalid CRC returns false; (3) file with valid CRC but unsupported version returns false; (4) file with valid CRC and a `pgnIndex` value of `CAN_MAX_PGN_IDX` or greater in an SPN entry; (5) old-format (ver=0 / SpnConfig0) versus new-format (ver=2) config loading.

---

**A08-4** · HIGH · Missing Test Coverage – CanStateHandler State Machine
**File:** `comm/canstatehandler.cpp:24`
**Description:** `CanStateHandler::updateState()` maintains time and count accumulators (`sessionOnTime`, `sessionOffTime`, `usageOnTime`, `usageOffTime`, and the rising/falling edge counters). It also controls the idle timer based on `m_canStates[0]`. No test exercises this method. Specifically: the delta time calculation at line 44 (`(clock - cs.clock) / 100`) is never verified; the idle timer start/stop at lines 64–70 is never verified; and the `DEPENDS_ON_TRIGGER` conditional compilation path (currently disabled) is never checked. The `canStates()` serialisation method, which is the output of all accumulated state, is also entirely untested.
**Fix:** Add tests that: (1) emit `stateUpdated(0, value)` with a controlled clock and verify delta time accumulation; (2) verify idle timer starts when state matches `idleInputPolarity` and stops when state changes; (3) call `canStates()` in each of the three `DigitalFormat` modes and verify the serialised output; (4) call `canStates()` with `autoReset=true` and verify that session counters are zeroed while usage counters are not.

---

**A08-5** · HIGH · Missing Test Coverage – resetStates Partial Reset Logic
**File:** `comm/canstatehandler.cpp:73`
**Description:** `resetStates(bool resetLast)` selectively zeroes state entries based on attribute type: when `resetLast=false`, entries of type `CanAttributeLast`, `CanAttributeLast2`, and `CanAttributeTime` are preserved. No test verifies this conditional behaviour. An incorrect implementation that always zero-fills would pass the existing (non-existent) tests. Furthermore, after the selective zero-fill, all clocks are reset unconditionally when `DEPENDS_ON_TRIGGER` is not defined (line 83–85), which could cause time accumulation to restart incorrectly. No test validates the interaction between partial reset and subsequent `canStates()` output.
**Fix:** Add tests that populate state for `CanAttributeLast` and `CanAttributeTime` entries, call `resetStates(false)`, and verify that `CanAttributeLast` entries are NOT zeroed while `CanAttributeCount` entries ARE zeroed. Also verify `resetStates(true)` zeroes all entries.

---

**A08-6** · HIGH · Missing Test Coverage – updateIdleTimer Edge Cases
**File:** `comm/canstatehandler.cpp:91`
**Description:** `updateIdleTimer()` creates, starts, or destroys a `QTimer` based on three conditions: `gCfg->idleTimeout()`, `gCfg->currentDriverId()`, and `gCfg->idleInputSource() == 64`. The timer teardown path (deleting and nulling `m_timer`) is not tested. The path where all conditions are met and the timer is created is not tested. The interaction between `updateIdleTimer()` being called from `resetStates()` and concurrent `updateState()` calls is untested.
**Fix:** Add tests that configure `idleTimeout`, `currentDriverId`, and `idleInputSource` to trigger timer creation; verify `idleTimeout` signal fires after the timeout; verify timer is destroyed when `idleTimeout()` is set to 0; verify timer is destroyed when `currentDriverId()` is 0 (driver logs out).

---

**A08-7** · MEDIUM · Missing Test Coverage – Protocol-Gated Config Setters
**File:** `comm/canmonitor.cpp:498`, `566`, `642`, `752`, `857`, `976`, `1097`
**Description:** Each `setCanXxxConfig()` method validates the input string, but several also gate on `m_busConfig.protocol`. For example, `setCanPgnConfig()` (line 569) returns false if protocol is not `J1939` or `LindeExtended`; `setCanLinConfig()` (line 860) only accepts `LindeExtended`; `setCanBydConfig()` (line 979) only accepts `BydCan`; `setCanLin2Config()` (line 1100) only accepts `Linde1202`. No test verifies that calling a config setter with an incompatible protocol returns false and leaves state unchanged. No test verifies input validation rejection paths (e.g., `setCanBusConfig` with `baudRate > 1000000`, or `setCanAttConfig` with `name.size() >= CAN_ATT_NAME_LEN`).
**Fix:** Add tests for each setter with: (1) incorrect protocol returning false; (2) each validation field at its boundary (too few fields, field out of range); (3) correct input returning true and observable state change.

---

**A08-8** · MEDIUM · Missing Test Coverage – J1939 and Linde1202 createRequest Paths
**File:** `comm/canmonitor.cpp:1231`
**Description:** `createRequest()` constructs and queues CAN request frames with protocol-specific byte layouts. The test suite only exercises the `LindeExtended` path via VDI mode. The J1939 path (extended ID, 3-byte PGN payload), the BydCan path (4-byte big-endian address), and the Linde1202 path (8-byte big-endian address) are never tested. An incorrect byte ordering in any of these paths would produce silent data corruption on the CAN bus with no test failure.
**Fix:** Add tests that configure each protocol, call `updateRequests()`, and verify the request frames enqueued on the mock `CanBus` match the expected byte layout for each protocol.

---

**A08-9** · MEDIUM · Incomplete VDI Mode Test Coverage
**File:** `test/test_canbus.cpp:73`
**Description:** The single existing test (`test_vdiMode`) covers the VDI mode configuration path. However it does not test: (1) what happens when `enableVdi(false)` is called directly (it calls `clearCanConfig()` but this is not asserted); (2) `setVdiAccess()` when `vdiMode()` returns false – the early-return guard is not tested; (3) `configureVdiAccessRequest()` when `vdiMode()` returns false; (4) the `access=true, inhibit=true` state where byte[0] should be `0x05` – the test emits `setRelayOut(true, false)` first, which is access+inhibit, but the parameter naming in the test comment reads "access, inhibit" while the signal is `setRelayOut(bool relay, bool inhibit)` creating potential confusion.
**Fix:** Add dedicated sub-cases for the VDI guard paths. Clarify or add assertions for the `access=false` with `inhibit=true` combination. Verify `enableVdi(false)` results in zero requests.

---

**A08-10** · LOW · No Test for saveCanConfig File I/O Failure
**File:** `comm/canmonitor.cpp:265`
**Description:** `saveCanConfig()` logs a critical error if the config file cannot be opened but does not return a success indicator (returns void). No test verifies the error-logging behaviour or the file-write path. A failed write would silently discard configuration without notification to callers.
**Fix:** Add a test that mocks a read-only or non-existent file path and verifies the critical log output. Consider changing the return type to `bool` to allow callers to detect write failures.

---

**A08-11** · LOW · Friend Class Access Bypasses Encapsulation But Is Insufficiently Used
**File:** `comm/canmonitor.h:55–57`
**Description:** `CanMonitor` declares `friend class TestCanbus` under `#ifdef UNIT_TEST`, granting full access to all private members and methods. However the test class only uses this access for `updateBusConfig()` and `updateRequests()` via `forceCanbusUpdate()` at `test/test_canbus.cpp:262–267`. The private methods `readCanFrame`, `updateState`, `updateSpnState`, `findPgnIndex`, `childSpnIndexes`, and `updateBusConfig` are all accessible for direct unit testing but none are tested. The friend declaration provides a testing surface that is almost entirely unused.
**Fix:** Write direct unit tests that call the private methods through the friend relationship. This is particularly important for `readCanFrame()` and `updateSpnState()` which contain the most complex logic and the highest risk of silent data-corruption bugs.

---

## Summary Table

| ID | Severity | Category | File | Tested? |
|----|----------|----------|------|---------|
| A08-1 | CRITICAL | Missing Coverage – readCanFrame | `canmonitor.cpp:1369` | No |
| A08-2 | CRITICAL | Missing Coverage – updateSpnState / UB risk | `canmonitor.cpp:1526` | No |
| A08-3 | HIGH | Missing Coverage – Config file parsing | `canmonitor.cpp:107,209` | No |
| A08-4 | HIGH | Missing Coverage – CanStateHandler state machine | `canstatehandler.cpp:24` | No |
| A08-5 | HIGH | Missing Coverage – resetStates partial reset | `canstatehandler.cpp:73` | No |
| A08-6 | HIGH | Missing Coverage – updateIdleTimer | `canstatehandler.cpp:91` | No |
| A08-7 | MEDIUM | Missing Coverage – protocol-gated config setters | `canmonitor.cpp:498–1097` | No |
| A08-8 | MEDIUM | Missing Coverage – J1939/BydCan/Linde1202 createRequest | `canmonitor.cpp:1231` | No |
| A08-9 | MEDIUM | Incomplete VDI mode test | `test/test_canbus.cpp:73` | Partial |
| A08-10 | LOW | saveCanConfig I/O failure not tested | `canmonitor.cpp:265` | No |
| A08-11 | LOW | Friend access granted but almost unused | `canmonitor.h:55` | N/A |

---

## Overall Assessment

The test suite for `CanMonitor` and `CanStateHandler` is severely deficient. A single test method (`test_vdiMode`) covers only the VDI mode initialisation path, which is a minor side-feature of the CAN subsystem. The core responsibilities of both classes – receiving and parsing CAN frames, extracting SPN values via bit manipulation, accumulating time and edge-count state, serialising state for upload, and managing the idle timer – have zero test coverage. Two critical findings (A08-1, A08-2) involve logic that processes externally-sourced data (CAN bus frames and config files) without any test validation of error or edge-case paths, making silent data corruption and undefined behaviour plausible failure modes in production.
# Audit Report — Agent A09 — Pass 2: Test Coverage
**Audit run:** 2026-02-28-01
**Agent:** A09
**Branch confirmed:** master (verified via `git branch --show-current` → `master`)
**Date:** 2026-02-28

---

## Files Under Review

| File | Lines |
|------|-------|
| `comm/ftpclient.h` | 51 |
| `comm/ftpclient.cpp` | 281 |
| `comm/gmtpchat.h` | 83 |
| `comm/gmtpchat.cpp` | 533 |

**Primary test file checked:** `test/test_ota.cpp` + `test/test_ota.h`
**All test files read:** `test/test_ota.cpp`, `test/test_ota.h`, `test/test_backgroundworker.cpp`, `test/test_backgroundworker.h`, `test/test_canbus.cpp`, `test/test_canbus.h`, `test/test_dialog.cpp`, `test/test_dialog.h`

---

## Reading Evidence

### FtpClient (`comm/ftpclient.h` + `comm/ftpclient.cpp`)

**Class:** `FtpClient : public QObject` (h:13)

**Public methods:**
| Method | Header line | Impl line |
|--------|-------------|-----------|
| `FtpClient(BackgroundWorker *parent)` | h:17 | cpp:18 |
| `void download(const QUrl &url)` | h:18 | cpp:31 |
| `void startTransfer()` | h:19 | cpp:46 |
| `void writeQueue()` | h:21 | cpp:119 |
| `void readQueue()` | h:22 | cpp:144 |
| `void setPowerState(CIGCONF::PowerState state)` | h:24 | cpp:109 |

**Signals:**
| Signal | Header line |
|--------|-------------|
| `void fileUpdated(const QString &fileName)` | h:27 |
| `void sendGmtpMessage(CIGCONF::GmtpMessage msg, const QByteArray &extra)` | h:28 |
| `void nextTransfer()` | h:29 |

**Private methods (tested only if exercised indirectly):**
| Method | Impl line |
|--------|-----------|
| `void readData()` | cpp:173 |
| `void downloadFinished()` | cpp:197 |
| `void setReport(CIGCONF::FtpErrorCode errorCode)` | cpp:273 |
| `void popQueue()` | cpp:166 |

**Includes (ftpclient.h):** `"app/cigconfigs.h"`, `<QObject>`, `<QUrl>`, `<QSaveFile>`, `<QQueue>`
**Includes (ftpclient.cpp):** `"ftpclient.h"`, `"app/backgroundworker.h"`, `"app/globalconfigs.h"`, `"platform/seriallogger.h"`, `<QNetworkAccessManager>`, `<QNetworkReply>`, `<QFile>`, `<QFileInfo>`, `<unistd.h>` (ARM-only)

**Key preprocessor constants:**
- `MAX_FILE_SIZE (16 * 1024 * 1024)` — cpp:14
- `FTP_QUEUE_FILE "/home/ftpqueue.txt"` — cpp:15
- `FTP_RETRIES 5` — cpp:16

---

### GmtpChat (`comm/gmtpchat.h` + `comm/gmtpchat.cpp`)

**Class:** `GmtpChat : public QObject` (h:14)

**Enumerations:**
- `enum Priority { NormalPriority, HighPriority }` — h:18
- `enum PduType { PduId=1, PduData=2, PduIdExt=3, PduDataExt=4, PduAck=5 }` — h:19

**Public methods:**
| Method | Header line | Impl line |
|--------|-------------|-----------|
| `GmtpChat(ModemChat *parent)` | h:21 | cpp:22 |
| `void setPowerState(CIGCONF::PowerState state)` | h:22 | cpp:70 |
| `void connectServer()` | h:23 | cpp:85 |
| `void sendMessage(const QByteArray &msgData, Priority priority)` | h:24 | cpp:195 |
| `void sendAck(quint16 msgId)` | h:25 | cpp:225 |
| `void clearGMTPMsgQueue()` | h:26 | cpp:489 |
| `bool sleeping()` | h:27 | h:27 (inline) |
| `void setEthernetState(bool up)` | h:28 | h:28 (inline) |
| `bool acksRemaining()` | h:29 | h:29 (inline) |

**Signals:**
| Signal | Header line |
|--------|-------------|
| `void cmdReceived(const QByteArray &ba)` | h:32 |
| `void socketStateChanged(bool state)` | h:33 |
| `void allMessagesSent()` | h:34 |
| `void allAcksSent()` | h:35 |
| `void gmtpHotStartReconnect()` | h:36 |
| `void disconnectSocket()` | h:37 |

**Private methods:**
| Method | Impl line |
|--------|-----------|
| `void readToQueue()` | cpp:405 |
| `void writeQueue(bool recent)` | cpp:434 |
| `void onConnected()` | cpp:144 |
| `void onDisconnected()` | cpp:173 |
| `void reconnectServer()` | cpp:112 |
| `void readSocket()` | cpp:323 |
| `void writeSocket()` | cpp:242 |
| `void bytesWritten(qint64 bytes)` | cpp:308 |
| `void ackTimeout()` | cpp:496 |
| `QByteArray packedMessage(...)` | cpp:380 |
| `void setOnIgnitionOffDisconnect(bool state)` | cpp:516 |
| `void disconnectFromHost()` | cpp:525 |

**Includes (gmtpchat.h):** `"app/cigconfigs.h"`, `<QObject>`, `<QQueue>`, `<QTcpSocket>`, `<QFile>`, `<QMutex>`
**Includes (gmtpchat.cpp):** `"gmtpchat.h"`, `"app/globalconfigs.h"`, `"comm/modemchat.h"`, `"platform/seriallogger.h"`, `<QFile>`, `<QDir>`, `<QTimer>`, `<QDebug>`, `<QProcess>`, `<QMutex>`, `<unistd.h>` (ARM-only)

**Key preprocessor constants:**
- `MAX_MESSAGE_CNT 1000` — cpp:16
- `MAX_RETRIES 3` — cpp:17
- `DEF_MSOCKET_TIMEOUT (10000)` — cpp:18 (10 seconds)
- `MAX_GMTP_RECONNECT_CNT (20)` — cpp:19

---

## Coverage Analysis

### FtpClient — Test Coverage Summary

**Test file examination findings:**

Grep across all files in `test/` for every FtpClient method name (`download`, `startTransfer`, `writeQueue`, `readQueue`, `setPowerState`, `setReport`, `popQueue`, `readData`, `downloadFinished`) returned **zero matches**. Grep for `FtpClient`, `ftpclient`, and `m_ftpClient` in the test directory also returned **zero matches**.

The `test/test_ota.cpp` file does test OTA-related logic (`updateSelf()`, decompression, MD5 verification) but exercises the `BackgroundWorker::updateSelf()` / `OtaWorker` path, not `FtpClient`. The `FtpClient` is instantiated in `BackgroundWorker::initialise()` (backgroundworker.cpp:2704), but none of the test harnesses call that initialise path — they assign `m_gmtpChat` directly but never assign `m_ftpClient`.

**Result: FtpClient has zero test coverage. Not one method, signal, or code path is exercised by any test in the suite.**

---

### GmtpChat — Test Coverage Summary

**Test file examination findings:**

Grep for all GmtpChat method names (`sendMessage`, `sendAck`, `clearGMTPMsgQueue`, `connectServer`, `reconnectServer`, `readSocket`, `writeSocket`, `bytesWritten`, `ackTimeout`, `packedMessage`, `readToQueue`, `disconnectFromHost`, `onConnected`, `onDisconnected`) returned **zero matches** in any test file.

`GmtpChat` is instantiated in four test harnesses (`test_ota.cpp:33`, `test_backgroundworker.cpp:34`, `test_canbus.cpp:38`, `test_dialog.cpp:53`) purely as a stub to satisfy the `BackgroundWorker` dependency. No test calls any method on the resulting object, inspects any signal it emits, or injects any data into its TCP socket or message queues.

**Result: GmtpChat has zero functional test coverage. The class is instantiated as a dependency stub only; no behaviour is verified.**

---

## Findings

---

**A09-1** · CRITICAL · Missing Test Coverage — FtpClient: No Connection Setup Test
**File:** `comm/ftpclient.cpp:18` (constructor) / `comm/ftpclient.cpp:31` (`download`) / `comm/ftpclient.cpp:46` (`startTransfer`)
**Description:** There are no tests that exercise the FtpClient constructor, the `download()` method, or the `startTransfer()` method. The constructor calls `readQueue()` at startup (cpp:28) and connects the `nextTransfer` signal (cpp:26–27). Neither the happy-path (queue empty at start, network available, transfer begins) nor any variant (queue pre-populated from file, network unavailable) is tested. For a component that performs OTA firmware delivery to embedded devices this is a critical reliability and security gap.
**Fix:** Add a unit test that constructs `FtpClient` with a mock `BackgroundWorker`, calls `download()` with a controlled URL, and uses `QSignalSpy` on `nextTransfer` and `sendGmtpMessage` to verify the queuing and handoff logic. Use `QNetworkAccessManager` mock or intercept at the `QNetworkReply` level to avoid real network I/O.

---

**A09-2** · CRITICAL · Missing Test Coverage — FtpClient: Download Success Path
**File:** `comm/ftpclient.cpp:197` (`downloadFinished`) / `comm/ftpclient.cpp:247–252`
**Description:** The success path inside `downloadFinished()` — `QNetworkReply::NoError`, file size matches `m_fileSize`, `m_file.commit()` succeeds, `fileUpdated` signal emitted — is never tested. This is the primary function of the component: delivering a file and signalling completion to the rest of the system. An untested success path means there is no regression protection should the commit/signal logic be accidentally broken.
**Fix:** Add an integration test that uses a local HTTP server (e.g., `QTcpServer` serving a fixed binary) to satisfy the `QNetworkAccessManager` request, then verifies that `fileUpdated` is emitted with the correct filename and that the target file exists on disk with the expected content.

---

**A09-3** · CRITICAL · Missing Test Coverage — FtpClient: Download Failure Paths
**File:** `comm/ftpclient.cpp:210–260` (`downloadFinished` error switch)
**Description:** All download failure branches are completely untested:
- Network errors (`ConnectionRefusedError`, `HostNotFoundError`, `TimeoutError`) → `FtpSaveFileError` / `FtpServerError`
- File-not-found (`ContentNotFoundError`, `ContentGoneError`) → `FtpNoFileError`
- Oversized file detected in `readData()` causing `OperationCanceledError` → `FtpGenericError`
- Incomplete file (size mismatch) → `FtpIncompleteFileError`
- Local save failure (`m_file.commit()` returns false) → `FtpSaveFileError`

Without tests for these paths there is no assurance that: (a) error codes are reported correctly via `sendGmtpMessage`; (b) `m_file` is properly discarded (cancelWriting + commit) on each failure; (c) the retry counter increments correctly and stops at `FTP_RETRIES` (5).
**Fix:** Add parameterised tests for each error code branch, injecting the appropriate `QNetworkReply::NetworkError` via a mock reply. Verify that `setReport` emits `sendGmtpMessage(GMTP_FTPF, ...)` with the expected error code, that the file is not committed on the filesystem, and that retries exhaust before queue pop.

---

**A09-4** · HIGH · Missing Test Coverage — FtpClient: Retry and Queue Persistence Logic
**File:** `comm/ftpclient.cpp:119–163` (`writeQueue`, `readQueue`) / `comm/ftpclient.cpp:253–260`
**Description:** The retry mechanism (up to `FTP_RETRIES = 5` attempts before popping the queue) and the queue persistence path (`writeQueue` to `/home/ftpqueue.txt` on sleep, `readQueue` on resume) are untested. These two behaviours are critical for device correctness: if the retry counter is not properly reset (`popQueue` at cpp:170 resets to 0) or if the persistent queue file becomes corrupt or is only partially written, downloads may silently stall. The double-semicolon typo at cpp:124 (`QFile file(FTP_QUEUE_FILE);;`) does not cause a bug but indicates the queue code has had minimal scrutiny.
**Fix:** Add tests that: (a) simulate repeated failures up to FTP_RETRIES and confirm the URL is eventually removed from the queue; (b) call `setPowerState(SleepState)` with a populated queue and verify `/home/ftpqueue.txt` is written with the correct URLs; (c) construct a new `FtpClient` after writing that file and verify the queue is restored in `readQueue()`.

---

**A09-5** · HIGH · Missing Test Coverage — FtpClient: File Size Limit Enforcement
**File:** `comm/ftpclient.cpp:173–194` (`readData`) / `comm/ftpclient.cpp:220–224` (`downloadFinished`)
**Description:** The `MAX_FILE_SIZE` guard (16 MiB) is checked in two places: once against the `Content-Length` header (cpp:180) and once against the accumulated size during streaming (cpp:191). Neither check is tested. If the header check is bypassed by a server that omits `Content-Length` (which the comment at cpp:33 explicitly acknowledges: "length in header depends on ftp server setting, might be 0"), the streaming check becomes the sole defence. The streaming check closes the reply but `m_fileSize` remains 0, which causes `downloadFinished` at cpp:212 to accept the file via the `!m_fileSize` bypass. This interaction — no Content-Length header + file > 16 MiB — is a security-relevant edge case with no test.
**Fix:** Add tests for: (a) server sends `Content-Length > MAX_FILE_SIZE` → reply is closed, no file committed; (b) server sends no `Content-Length` header and streams more than 16 MiB of data → reply is closed via the size check in `readData`, and `downloadFinished` correctly classifies the result as `FtpGenericError` (not a silent accept due to `!m_fileSize`).

---

**A09-6** · CRITICAL · Missing Test Coverage — GmtpChat: Message Send Path
**File:** `comm/gmtpchat.cpp:195` (`sendMessage`) / `comm/gmtpchat.cpp:242` (`writeSocket`)
**Description:** `sendMessage()` — the primary public API used by the rest of the system to upload telemetry and control messages — is not tested at all. This covers both `NormalPriority` (enqueue to `m_uploadMessages`) and `HighPriority` (prepend). The spill-over path to `m_recentMessages` and subsequent `writeQueue(true)` when the queue reaches `MAX_MESSAGE_CNT` (1000) is also untested. No test verifies that `packedMessage()` produces a correctly framed PDU (big-endian type, 2-byte msgId, 2-byte length, payload), that `m_msgId` wraps from 65535 to 1 (skipping 0), or that the upload timer is started.
**Fix:** Add unit tests for `sendMessage()` covering: normal priority enqueue, high priority prepend, the 1000-message spill-over to file, and the `SleepState` guard that silently drops messages. Use `QSignalSpy` on `allMessagesSent` and inspect queue state. Test `packedMessage()` output format directly for both `PduDataExt` and `PduAck` types.

---

**A09-7** · CRITICAL · Missing Test Coverage — GmtpChat: Message Receive and Framing
**File:** `comm/gmtpchat.cpp:323` (`readSocket`)
**Description:** `readSocket()` is the inbound data parser. It handles: multi-message batches in a single TCP segment, partial frames stored in `m_downloadMessage`, `PduDataExt` data frames (→ emit `cmdReceived` + send ACK), `PduAck` frames (→ clear `m_ackId`, stop ack timer), and unknown type bytes (→ advance by 1 byte). None of these paths are tested. The partial-frame reassembly path (cpp:342–345) is especially critical: if a 6-byte header arrives split across two `readyRead` calls, `m_downloadMessage` stores the incomplete buffer and the loop resumes on the next call. A framing defect here could cause command injection (emitting a `cmdReceived` with wrong data) or silent message loss.
**Fix:** Add tests that feed raw byte arrays directly to `readSocket()` via a loopback `QTcpSocket` or by calling the slot directly. Cover: complete single frame, two frames in one call, frame split at header boundary, frame split within payload, unknown type byte, zero-length payload (`PduAck`), maximum-size payload (65535 bytes per `quint16` dataSize field).

---

**A09-8** · HIGH · Missing Test Coverage — GmtpChat: ACK Timeout and Reconnection
**File:** `comm/gmtpchat.cpp:496` (`ackTimeout`) / `comm/gmtpchat.cpp:112` (`reconnectServer`)
**Description:** The ACK timeout handler at cpp:496 re-queues `m_sendingMessage` and increments `m_retryCount`. After `MAX_RETRIES` (3) exhausted retries it calls `onDisconnected()`, which in turn calls `connectServer()`. The reconnect logic at cpp:129–141 rotates through server indexes and after `MAX_GMTP_RECONNECT_CNT` (20) failures calls `m_modemChat->requestDetach()` to reset the modem. This entire retry-reconnect chain is untested. A fault in the retry counter reset (e.g., `m_retryCount` not zeroed on `onConnected`, cpp:155) could cause premature modem detach or a stuck-connected state that never retries.
**Fix:** Add tests that: (a) trigger `ackTimeout` fewer than `MAX_RETRIES` times and confirm `m_sendingMessage` is re-prepended; (b) trigger it `MAX_RETRIES + 1` times and confirm `onDisconnected` is called (via spy on `socketStateChanged`); (c) trigger `reconnectServer` more than `MAX_GMTP_RECONNECT_CNT` times and confirm `requestDetach` is invoked on the modem chat mock.

---

**A09-9** · HIGH · Missing Test Coverage — GmtpChat: Connection Drop During Message Send
**File:** `comm/gmtpchat.cpp:173` (`onDisconnected`)
**Description:** `onDisconnected()` re-queues `m_sendingMessage` at the head of `m_uploadMessages` (cpp:178–179) so the in-flight message is not lost. This is correct logic but it is not tested. If the prepend is omitted or the condition is wrong, a message could be silently dropped during a TCP connection loss, which for a vehicle control/compliance system could result in missing safety events. Additionally, `onDisconnected` always calls `connectServer()` (cpp:192) regardless of power state, which contradicts the commented-out guard (cpp:187–190) — this behaviour is also untested.
**Fix:** Add a test that: establishes a connected state, calls `writeSocket()` to populate `m_sendingMessage`, then calls `onDisconnected()` directly, and verifies that `m_uploadMessages.head()` contains the originally sent message. Also verify `socketStateChanged(false)` is emitted and `connectServer()` is called.

---

**A09-10** · HIGH · Missing Test Coverage — GmtpChat: Empty and Maximum Payload
**File:** `comm/gmtpchat.cpp:380` (`packedMessage`) / `comm/gmtpchat.cpp:323` (`readSocket`)
**Description:** `packedMessage()` encodes payload length as a big-endian `quint16` at bytes 4–5 of the header. For `PduAck` the payload is empty (`""`, size 0). For a `PduDataExt` message the maximum representable payload is 65535 bytes; however `readSocket()` uses `dataSize = BE_SHORT(ba[4], ba[5])` to determine how many bytes to consume, and the `sendMessage()` guard only limits the queue count (1000 entries), not individual message size. No test verifies: (a) that a zero-length ACK frame is correctly round-tripped; (b) that a near-maximum-size payload (e.g., 65534 bytes) is correctly framed and parsed; (c) that a message whose payload contains a null byte or a newline (which is used as the delimiter in the persistent queue file at cpp:468–470) is correctly stored and restored.
**Fix:** Add tests for zero-length ACK frames, large payloads up to the `quint16` limit, and payloads containing `\n` bytes to verify the file-persistence round-trip does not corrupt message boundaries.

---

**A09-11** · MEDIUM · Missing Test Coverage — GmtpChat: Queue Persistence on Sleep
**File:** `comm/gmtpchat.cpp:70` (`setPowerState`) / `comm/gmtpchat.cpp:434` (`writeQueue`)
**Description:** When `setPowerState(SleepState)` is called, `writeQueue(false)` and `writeQueue(true)` are called in sequence to flush both `m_uploadMessages` and `m_recentMessages` to numbered files in `DIR_GMTP_MSG`. The file index tracking logic in `m_gmtpFileIndexes` (prepend 0 for upload, append last+1 for recent) is non-trivial and completely untested. If the index sequence overflows or the file is not written atomically (the `fsync` at cpp:484 is ARM-only so it is skipped on PC), messages could be silently lost across a power cycle.
**Fix:** Add tests for `setPowerState(SleepState)` with pre-populated queues, verifying that the correct files are created in the GMTP message directory and that a subsequent `readToQueue()` call recovers the messages in order.

---

**A09-12** · MEDIUM · Missing Test Coverage — GmtpChat: Duplicate PduId Suppression
**File:** `comm/gmtpchat.cpp:278–287` (`writeSocket`)
**Description:** If `m_idSent` is true and the head of `m_uploadMessages` is a `PduId` or `PduIdExt` frame, the message is silently discarded (cpp:281–287). This guard prevents the server from terminating the session on a duplicate registration PDU. It is not tested, so there is no assurance that: (a) the dequeue happens correctly; (b) the upload timer restarts; (c) a legitimately queued `PduId` frame following a reconnect (before `m_idSent` is cleared) is dropped but the next normal data frame is sent.
**Fix:** Add a test that pre-populates `m_uploadMessages` with a `PduIdExt` frame, sets `m_idSent = true`, calls `writeSocket()`, and verifies the queue is drained without writing to the socket, and that the next non-identity frame is then sent normally.

---

**A09-13** · LOW · GmtpChat Instantiated with Null Parent in All Tests
**File:** `test/test_ota.cpp:33`, `test/test_backgroundworker.cpp:34`, `test/test_canbus.cpp:38`, `test/test_dialog.cpp:53`
**Description:** All four test harnesses instantiate `GmtpChat(nullptr)` rather than a proper `ModemChat` parent. The constructor stores the pointer as `m_modemChat` (cpp:23) and calls `m_modemChat->requestDetach()` inside `reconnectServer()` (cpp:137) when the reconnect count exceeds the maximum. Since no test exercises reconnection, this null dereference has not been triggered, but it represents a latent crash in any test that would exercise the reconnection limit.
**Fix:** Provide a mock `ModemChat` object with at least `requestDetach()` stubbed out for all test harnesses, or construct `GmtpChat` with a valid (but inactive) `ModemChat` instance.

---

## Summary Table

| ID | Severity | Category | Location | Description |
|----|----------|----------|----------|-------------|
| A09-1 | CRITICAL | Missing Coverage | `comm/ftpclient.cpp:18,31,46` | FtpClient: no test for constructor, download(), or startTransfer() |
| A09-2 | CRITICAL | Missing Coverage | `comm/ftpclient.cpp:197,247–252` | FtpClient: download success path (fileUpdated signal, file commit) never tested |
| A09-3 | CRITICAL | Missing Coverage | `comm/ftpclient.cpp:210–260` | FtpClient: all download failure branches (network error, server error, incomplete file, save error) untested |
| A09-4 | HIGH | Missing Coverage | `comm/ftpclient.cpp:119–163,253–260` | FtpClient: retry exhaustion and queue persistence (writeQueue/readQueue) untested |
| A09-5 | HIGH | Missing Coverage | `comm/ftpclient.cpp:173–194,220–224` | FtpClient: MAX_FILE_SIZE enforcement and the Content-Length=0 bypass interaction untested |
| A09-6 | CRITICAL | Missing Coverage | `comm/gmtpchat.cpp:195,242` | GmtpChat: sendMessage() (normal, high priority, spill-over, sleep guard) never tested |
| A09-7 | CRITICAL | Missing Coverage | `comm/gmtpchat.cpp:323` | GmtpChat: readSocket() framing, partial-frame reassembly, PduAck handling never tested |
| A09-8 | HIGH | Missing Coverage | `comm/gmtpchat.cpp:496,112` | GmtpChat: ACK timeout, retry exhaustion, modem detach trigger untested |
| A09-9 | HIGH | Missing Coverage | `comm/gmtpchat.cpp:173` | GmtpChat: in-flight message re-queue on connection drop untested |
| A09-10 | HIGH | Missing Coverage | `comm/gmtpchat.cpp:380,323` | GmtpChat: empty payload, maximum payload, payload with newline character untested |
| A09-11 | MEDIUM | Missing Coverage | `comm/gmtpchat.cpp:70,434` | GmtpChat: queue persistence to file on sleep/wake cycle untested |
| A09-12 | MEDIUM | Missing Coverage | `comm/gmtpchat.cpp:278–287` | GmtpChat: duplicate PduId suppression logic (m_idSent guard) untested |
| A09-13 | LOW | Test Quality | `test/test_ota.cpp:33` et al. | GmtpChat instantiated with null ModemChat parent; latent null-dereference in reconnect path |

---

## Overall Assessment

**FtpClient test coverage: 0%**
**GmtpChat test coverage: 0% (functional)**

Both components are compiled into the test binary and `GmtpChat` is instantiated as a stub in four test harnesses, but no test exercises any behaviour of either class. The test suite (`test_ota.cpp`) focuses entirely on the OTA decompression/MD5 path in `BackgroundWorker`, which is orthogonal to the FTP and GMTP communications layers.

Given that `FtpClient` is the delivery mechanism for firmware updates and configuration files on an embedded safety device, and `GmtpChat` is the sole uplink for telemetry and command receipt, the absence of any test coverage is a high-severity finding from a software quality and security assurance standpoint. Four findings are rated CRITICAL specifically because the untested code paths include: firmware file delivery success/failure, inbound command parsing, and outbound message queuing — all of which are directly relevant to the safety and integrity of the deployed device.
# Pass 2 Audit — A10 (Test Coverage)
**Agent:** A10
**Pass:** 2 — Test Coverage
**Date:** 2026-02-28
**Audit Run:** 2026-02-28-01
**Branch:** master (confirmed by `git branch --show-current`)
**Repo:** C:/Projects/cig-audit/repos/mark3-pvd

---

## Step 1 — Branch Confirmation

```
$ git branch --show-current
master
```

Branch is **master**. Confirmed.

---

## Step 2 & 4 — Reading Evidence

### File: `comm/modemchat.h`

**Class:** `ModemChat` extends `QObject`

**Enums:**
- `NetworkState { NetworkStopped, NetworkHome, NetworkSearching, NetworkDenied, NetworkUnknown, NetworkRoaming }` — line 22

**Public Methods (with line numbers):**
| Line | Signature |
|------|-----------|
| 24 | `explicit ModemChat(EM070::ModemPort *modemPort)` |
| 25 | `void portStateChanged(bool open)` |
| 26 | `void setGnssEnabled(bool enable)` |
| 27 | `void rssiRefresh()` |
| 28 | `void qmiCheck()` |
| 29 | `void networkCheck()` |
| 30 | `void updateApn()` |
| 31 | `void detach(bool send = true)` |
| 32 | `void requestDetach()` |
| 34 | `const QByteArray &cgmi() const` |
| 35 | `const QByteArray &cgmm() const` |
| 36 | `const QByteArray &cgmr() const` |
| 37 | `const QByteArray &cgsn() const` |
| 38 | `const QByteArray &iccid() const` |
| 39 | `const QByteArray &rssi() const` |
| 40 | `const QByteArray &mobileOperator() const` |
| 41 | `const QByteArray &moni() const` |
| 42 | `NetworkState networkState() const` |
| 43 | `bool isEthernetReady() const` |

**Signals:**
| Line | Signature |
|------|-----------|
| 46 | `void simError()` |
| 47 | `void ethernetStateChanged(bool ready)` |

**Private Methods:**
| Line | Signature |
|------|-----------|
| 56 | `void sendChat(bool timeout = false)` |
| 57 | `void popChat()` |
| 58 | `void pushChat(const QByteArray &chat)` |
| 59 | `void noResponse()` |
| 60 | `void parseResponse(bool result, const QByteArrayList &content)` |
| 61 | `void selectAPN()` |
| 62 | `void updateEthernetState(bool connected)` |
| 63 | `void reconnectNetwork()` |
| 64 | `void onUqmiProcessComplete(int exitCode, QProcess::ExitStatus exitStatus)` |
| 65 | `void onProcessTimeout()` |
| 66 | `void resetReconnectFlag()` |
| 69 | `int args(const QByteArrayList &content, QGenericArgument val1, ...)` |

**Includes:**
- `<QProcess>` — line 8
- `<QObject>` — line 9
- `<QQueue>` — line 10
- Forward declarations: `EM070::ModemPort`, `QTimer`

---

### File: `comm/modemchat.cpp`

**Includes:**
- `"modemchat.h"` — line 1
- `"platform/modemport.h"` — line 2
- `"platform/seriallogger.h"` — line 3
- `"app/globalconfigs.h"` — line 4
- `<QTimer>` — line 5
- `<QDebug>` — line 6
- `<QProcess>` — line 7
- `<QStringList>` — line 8

**Key Macros:**
- `RETRY_WAIT 500` — line 10
- `RETRIES_PER_SEC (1000 / RETRY_WAIT)` — line 11 (= 2)
- `ACK_TIMEOUT 3000` — line 12
- `RSSI_INTERVAL 10000` — line 13
- `QMI_INTERVAL 2000` — line 14
- `NETWORK_INTERVAL 2000` — line 15
- `NETWORK_TIMEOUT 90` — line 16 (90 × 2s = 180 s total)
- `MAX_QMI_FAILURE_COUNT 7` — line 18 (defined but not used)
- `PROCESS_MAX_WAIT_TIMEOUT 10000` — line 19
- `MAX_CGDCONT 5` — line 20

**AT command sequence enqueued at `portStateChanged(true)` (lines 65–80):**
`AT`, `AT+CGMI`, `AT+CGMM`, `AT+CGMR`, `AT+CGSN`, `AT+ICCID`, `AT+CMEE=0`, `AT#USBCFG?`, `AT#RXDIV?`, `AT+CGEREP=1,0`, `AT+COPS=2`, `AT+CGDCONT=2`, `AT+CGDCONT=3`, `AT+COPS=0`; optionally `AT$GPSP=1`, `AT$GPSNMUN=2,1,1,1,1,1,1`.

**`noResponse()` (lines 260–268):** resets modem after `RETRIES_PER_SEC * 60` = 120 retries (60 seconds).

**`parseResponse()` (lines 363–693):** Central dispatch handler; handles all AT command responses, emits `simError()` and `ethernetStateChanged()` as appropriate.

---

### File: `comm/ntpsync.h`

**Class:** `NtpSync` extends `QObject`

**Public Methods:**
| Line | Signature |
|------|-----------|
| 14 | `explicit NtpSync(ModemChat *parent)` |
| 15 | `void connectServer()` |
| 16 | `void abortConnection()` |

**Signals:**
| Line | Signature |
|------|-----------|
| 19 | `void synchronized(bool yes)` |

**Private Methods (slots):**
| Line | Signature |
|------|-----------|
| 22 | `void writeSocket()` |
| 23 | `void readSocket()` |

**Includes:**
- `<QObject>` — line 4
- `<QUdpSocket>` — line 5

---

### File: `comm/ntpsync.cpp`

**Includes:**
- `"ntpsync.h"` — line 1
- `"platform/internalrtc.h"` — line 2
- `"platform/seriallogger.h"` — line 3
- `"comm/modemchat.h"` — line 4
- `"app/globalconfigs.h"` — line 5
- `<QTimer>` — line 6
- `<QDateTime>` — line 7

**Key Macro:**
- `EPOCH_DIFF 0x83aa7e80UL` — line 9 (NTP-to-Unix epoch offset: 2208988800 seconds)

**NTP retry logic (`connectServer()`, lines 29–51):** Aborts after 3 failed attempts and emits `synchronized(false)`.

**`readSocket()` validation (lines 70–106):** Minimum packet size 48 bytes; `ts2 - ts1 > 300` filter; EPOCH_DIFF subtraction; year >= 2019 floor check; emits `synchronized(true)` on success.

---

## Step 3 — Test Coverage Search

**Grep executed across `C:/Projects/cig-audit/repos/mark3-pvd/test/` for:**
- Class names: `ModemChat`, `NtpSync`, `modemchat`, `ntpsync`
- Method names: `portStateChanged`, `setGnssEnabled`, `rssiRefresh`, `qmiCheck`, `networkCheck`, `updateApn`, `detach`, `requestDetach`, `parseResponse`, `selectAPN`, `connectServer`, `abortConnection`, `writeSocket`, `readSocket`, `synchronized`

**Result: Zero matches across all `.cpp` and `.h` files in the test directory.**

**Test files present in `test/`:**
- `test_backgroundworker.cpp` / `.h` — tests `BackgroundWorker` GMTP command handling
- `test_canbus.cpp` / `.h` — tests CAN bus
- `test_dialog.cpp` / `.h` — tests dialog UI
- `test_ota.cpp` / `.h` — tests OTA update

**Test project (`mk3-test.pro`):** `comm/modemchat.cpp` (line 79) and `comm/ntpsync.cpp` (line 83) are compiled into the test binary, but no test class exercises either of them. They are present only as transitive compilation dependencies.

**Conclusion: Neither `ModemChat` nor `NtpSync` has any automated test coverage whatsoever.**

---

## Step 5 — Findings

---

**A10-TC-1** · HIGH · Test Coverage — Missing
**File:** `comm/modemchat.cpp` + `comm/modemchat.h`
**Description:** The entire `ModemChat` class — including the AT command sequencing engine, APN auto-selection logic, network state machine, QMI reconnection flow, `parseResponse()` dispatch, modem reset path, and both signals (`simError`, `ethernetStateChanged`) — has zero unit or integration test coverage. `parseResponse()` alone is 330 lines of branching AT response logic. The lack of any test means regressions in modem initialization, SIM detection failure handling, network re-attachment, or GPRS detach sequencing are undetectable until runtime on hardware. This has direct bearing on vehicle connectivity reliability and safety-critical event transmission.
**Fix:** Write a `TestModemChat` Qt test class using a mock `EM070::ModemPort` that exposes a controllable `response` signal. At minimum, test cases should cover: (1) the full `portStateChanged(true)` AT sequence completing successfully; (2) `AT+ICCID` failure after `RETRIES_PER_SEC * 5` retries emitting `simError()`; (3) `noResponse()` triggering `resetModem()` after 120 retries; (4) `parseResponse()` handling `AT+CGMM` for WWX vs non-WWX modem type selection; (5) `selectAPN()` auto-APN mapping for each known ICCID prefix; (6) `networkCheck()` decrementing the counter and calling `detach()` at timeout; (7) `updateEthernetState()` emitting `ethernetStateChanged()`.

---

**A10-TC-2** · HIGH · Test Coverage — Missing
**File:** `comm/ntpsync.cpp` + `comm/ntpsync.h`
**Description:** `NtpSync` has zero unit or integration test coverage. The class is responsible for setting the device hardware RTC from a network-sourced UDP packet. Its `readSocket()` method applies several validation heuristics (`ba.size() < 48`, the `ts2 - ts1 > 300` gap check, the year >= 2019 floor) that were identified in Pass 1 as containing logical defects (unsigned wraparound, no upper-bound check). Without tests these defects cannot be confirmed or regression-protected. The `connectServer()` retry/abort logic (three attempts, then `synchronized(false)`) is also untested. Any regression in NTP handling directly affects the accuracy of all timestamped audit records.
**Fix:** Write a `TestNtpSync` Qt test class using a `QUdpSocket`-based mock NTP server or by directly calling `readSocket()` with crafted `QByteArray` payloads. At minimum, test cases should cover: (1) a well-formed 48-byte NTP response sets the RTC and emits `synchronized(true)`; (2) a packet shorter than 48 bytes is silently discarded; (3) `ts2 - ts1 > 300` causes the packet to be discarded (note: also test the unsigned-wraparound edge case where `ts2 < ts1`); (4) a `ts2` yielding year < 2019 after EPOCH_DIFF subtraction is discarded; (5) a `ts2` yielding year > 2100 is not discarded by current code (demonstrating the missing upper-bound check); (6) after three `connectServer()` calls without a response, `synchronized(false)` is emitted; (7) `abortConnection()` stops the retry timer and resets `m_syncTimes`.

---

**A10-TC-3** · MEDIUM · Test Coverage — Specific Logic Gap
**File:** `comm/modemchat.cpp:277–313`
**Description:** `selectAPN()` contains a chain of ICCID-prefix comparisons covering nine different carriers (Vodafone AU, Telstra, Optus, Kore, Monogoto, Hologram, UK "stream.co.uk" on three different ICCID prefixes). This logic uses `m_iccid.left(6)` string comparisons and is invoked from `parseResponse()` on every `AT+CGDCONT?` response. There are no tests for any of these ICCID branches. A typo or prefix transposition would silently configure the wrong APN, preventing network connectivity on affected SIMs. The Monogoto branch uses `left(5)` (line 303) rather than `left(6)`, diverging from the pattern used by all other carriers — this inconsistency is untested and may be intentional (the prefix `89999` is five digits) or may reflect a copy-paste error.
**Fix:** Add parameterised test cases for `selectAPN()` covering each ICCID prefix (including the five-digit Monogoto prefix), an unrecognised prefix in auto mode (resulting in an empty APN), and manual APN override mode. Consider extracting the ICCID-to-APN table into a data structure to make it directly testable without full `ModemChat` construction.

---

**A10-TC-4** · MEDIUM · Test Coverage — Specific Logic Gap
**File:** `comm/modemchat.cpp:228–245`
**Description:** `sendChat()` implements retry gating: if `m_ackTimer` is active (waiting for a previous response) or the queue is empty, it returns immediately. If `m_tryTimes` is non-zero and this is not a timeout-driven call, it starts `m_tryTimer` to delay the retry by `RETRY_WAIT` (500 ms). This prevents flooding the modem. If `m_modemPort->sendCmd()` fails (returns false), the entire queue is cleared. This queue-clearing behaviour on send failure — which effectively abandons all pending AT commands — is a significant operational behaviour with no test. A test could inject a `sendCmd()` failure and verify the queue is cleared and the system reaches a recoverable state (waiting for `portStateChanged`).
**Fix:** Mock `ModemPort::sendCmd()` to return false and verify that `m_chatCmds` is cleared after a `sendChat()` call. Also verify that `sendChat()` is a no-op when `m_ackTimer` is active.

---

**A10-TC-5** · MEDIUM · Test Coverage — Specific Logic Gap
**File:** `comm/modemchat.cpp:765–811`
**Description:** `onUqmiProcessComplete()` handles three distinct outcomes from the `uqmi` process: abnormal exit (kills the process and restarts the QMI timer), "disconnected"/"incompatible" output (calls `updateEthernetState(false)`), "connected" output (calls `updateEthernetState(true)`), and any other output (logs a warning). The reconnect path (`m_startReconnect == true`) skips state parsing entirely and just calls `resetReconnectFlag()`. None of these branches are tested. The "unexpected output" path in particular has no handling beyond a warning log, meaning unknown `uqmi` output silently leaves ethernet state unchanged. Additionally, the macro `MAX_QMI_FAILURE_COUNT` (line 18, value 7) is defined but is never referenced anywhere in the code — it has no effect. This suggests dead code or a missing guard that was intended to limit successive QMI failures.
**Fix:** Write tests that mock `QProcess` output and verify: (1) "connected" triggers `ethernetStateChanged(true)`; (2) "disconnected" triggers `ethernetStateChanged(false)`; (3) crash exit (`QProcess::CrashExit`) triggers timer restart without state change; (4) unrecognised output leaves state unchanged. Investigate the intended use of `MAX_QMI_FAILURE_COUNT` and either implement the guard or remove the dead macro.

---

**A10-TC-6** · MEDIUM · Test Coverage — Specific Logic Gap
**File:** `comm/modemchat.cpp:170–196`
**Description:** `networkCheck()` is called every `NETWORK_INTERVAL` (2000 ms) by `m_networkTimer`. It implements two distinct behaviours: (a) decrement `m_networkCounter` when ethernet is not connected, and force-detach when it reaches zero (representing a 180-second connectivity timeout); and (b) if `m_detachRequested` is true, immediately call `detach()` when ethernet is connected but wait out the 180-second timeout otherwise. Both behaviours are safety-critical: the timeout detach is the mechanism for recovering from a permanently failed connection. Neither behaviour has any test. There is also a subtle interaction: `m_detachRequested` is reset to `false` unconditionally within the block regardless of whether the detach was executed, meaning a detach request made while ethernet is disconnected will be lost.
**Fix:** Test `networkCheck()` by: (1) calling it 90 times with `m_ethernetState == false` and verifying `detach()` is invoked on the 90th call; (2) calling it with `m_detachRequested == true` and `m_ethernetState == true` and verifying `detach()` is invoked immediately; (3) calling it with `m_detachRequested == true` and `m_ethernetState == false` and verifying `detach()` is NOT invoked and `m_detachRequested` is reset (documenting the existing behaviour of silently dropping the request).

---

**A10-TC-7** · LOW · Test Coverage — Specific Logic Gap
**File:** `comm/modemchat.cpp:696–757`
**Description:** The `args()` helper method parses comma-separated AT response fields into typed C++ values via `QGenericArgument`. It handles `QByteArray`, `QString`, `int`, and `bool` types. The `bool` branch (lines 748–752) contains a logical defect: the condition `if (val >= 0 || val <= 1)` is a tautology — it is always true for any integer value, since every integer is either >= 0 or <= 1. The intent was almost certainly `if (val >= 0 && val <= 1)` (i.e., only accept 0 or 1). As written, a value like `-5` or `99` will be silently assigned to the `bool` output as a non-zero value (true), when the AT response format only specifies 0 or 1. This defect in `args()` propagates into every AT command response that extracts a boolean (e.g., `AT+CGATT?`, `AT#ECMC?`, `AT#ECM?`, `AT$GPSP?`, `AT+CGREG?`). No tests exist to catch this.
**Fix:** Add unit tests for `args()` covering each type, including edge cases for `bool`: verify that `"0"` maps to `false`, `"1"` maps to `true`, `"2"` is rejected (should return before the bool position under correct semantics), and `"-1"` is rejected. Fix the tautological condition to `val >= 0 && val <= 1`.

---

**A10-TC-8** · LOW · Test Coverage — Specific Logic Gap
**File:** `comm/modemchat.cpp:260–268`
**Description:** `noResponse()` resets the modem (`m_modemPort->resetModem()`) when `m_tryTimes > RETRIES_PER_SEC * 60` (i.e., after 120 retry attempts at 500 ms each = 60 seconds). This is the only modem self-recovery mechanism for a stuck AT command. There is no test verifying that the threshold is correct or that `resetModem()` is called at exactly the right count. A regression that increments `m_tryTimes` at a different rate, or changes `RETRIES_PER_SEC`, would silently change the reset threshold without any test failure.
**Fix:** Add a test that drives `noResponse()` 120 times via repeated `m_ackTimer` timeout signals and verifies `resetModem()` is called on the 121st invocation. Also verify `resetModem()` is not called before that threshold.

---

**A10-TC-9** · LOW · Test Coverage — Specific Logic Gap
**File:** `comm/ntpsync.cpp:29–51`
**Description:** `connectServer()` uses `m_syncTimes` as both a retry counter and a "synced" sentinel (`m_syncTimes < 0` means already synced). The increment (`++m_syncTimes > 3`) on line 41 causes the method to emit `synchronized(false)` after the fourth call (syncTimes values 1, 2, 3, then 4 > 3). The pre-increment means the method processes `syncTimes == 1` on the first call (not zero), which is mildly confusing. More importantly, `abortConnection()` (line 53) resets `m_syncTimes` to 0 only if it is currently > 0 — if `m_syncTimes` is already 0 (i.e., `connectServer()` has never been called), the reset is skipped. This means calling `abortConnection()` before any sync attempt leaves `m_syncTimes` at 0, and the next `connectServer()` call will not see a synced sentinel. This is the correct behaviour but it is subtle and untested.
**Fix:** Add tests for `abortConnection()` called: (1) before any `connectServer()` call; (2) mid-sequence (after 1-2 retries); (3) after successful sync (`m_syncTimes == -1`). Verify that after `abortConnection()`, the next `connectServer()` call restarts cleanly without prematurely emitting `synchronized(false)`.

---

## Summary Table

| ID | Severity | Category | File | Description |
|----|----------|----------|------|-------------|
| A10-TC-1 | HIGH | Test Coverage — Missing | `comm/modemchat.cpp` + `.h` | Entire `ModemChat` class has zero test coverage |
| A10-TC-2 | HIGH | Test Coverage — Missing | `comm/ntpsync.cpp` + `.h` | Entire `NtpSync` class has zero test coverage |
| A10-TC-3 | MEDIUM | Test Coverage — Specific Logic Gap | `comm/modemchat.cpp:277–313` | `selectAPN()` ICCID-to-APN mapping untested; Monogoto uses `left(5)` vs `left(6)` elsewhere |
| A10-TC-4 | MEDIUM | Test Coverage — Specific Logic Gap | `comm/modemchat.cpp:228–245` | `sendChat()` queue-clearing on `sendCmd()` failure untested |
| A10-TC-5 | MEDIUM | Test Coverage — Specific Logic Gap | `comm/modemchat.cpp:765–811` | `onUqmiProcessComplete()` branches untested; `MAX_QMI_FAILURE_COUNT` defined but never used |
| A10-TC-6 | MEDIUM | Test Coverage — Specific Logic Gap | `comm/modemchat.cpp:170–196` | `networkCheck()` 180-second timeout detach and `requestDetach()` flow untested |
| A10-TC-7 | LOW | Test Coverage — Specific Logic Gap | `comm/modemchat.cpp:748–752` | `args()` bool branch has tautological condition (`>=0 \|\| <=1`); defect propagates to all bool AT responses |
| A10-TC-8 | LOW | Test Coverage — Specific Logic Gap | `comm/modemchat.cpp:260–268` | `noResponse()` modem reset threshold untested |
| A10-TC-9 | LOW | Test Coverage — Specific Logic Gap | `comm/ntpsync.cpp:29–51` | `connectServer()` retry counter / sentinel semantics and `abortConnection()` edge cases untested |

---

## Coverage Summary

| Question | ModemChat | NtpSync |
|----------|-----------|---------|
| AT command sequence tested? | **No** | N/A |
| Timeout handling tested? | **No** | **No** |
| Unexpected modem response tested? | **No** | N/A |
| Connection failure recovery tested? | **No** | **No** |
| Time sync success tested? | N/A | **No** |
| Server unreachable (retry/abort) tested? | N/A | **No** |
| Malformed NTP response tested? | N/A | **No** |
| Large time delta handling tested? | N/A | **No** |

Overall test coverage for both assigned files: **0%**. Both classes are compiled into the test binary (`mk3-test.pro` lines 79, 83) but no test class exercises any of their methods.
# Audit Report – Agent A11 (Test Coverage)
**Audit Run:** 2026-02-28-01
**Pass:** 2 – Test Coverage
**Agent:** A11
**Branch confirmed:** master
**Date:** 2026-02-28

---

## Files Assigned

| File | Path |
|------|------|
| main.cpp | `C:/Projects/cig-audit/repos/mark3-pvd/main.cpp` |
| mytranslator.cpp | `C:/Projects/cig-audit/repos/mark3-pvd/mytranslator.cpp` |
| mytranslator.h | `C:/Projects/cig-audit/repos/mark3-pvd/mytranslator.h` |

---

## Step 1 – Branch Verification

```
git branch --show-current → master
```

Confirmed: working on branch **master**.

---

## Step 2 – Reading Evidence

### main.cpp

**Class:** None (free functions + `main` entry point)

**Includes:**
- `<QApplication>`
- `<QDateTime>`
- `<QThread>`
- `<QFile>`
- `<QDebug>`
- `<QTranslator>`
- `<QProcess>`
- `"utils/logger.h"`
- `"ui/keyfilter.h"`
- `"ui/dialog.h"`
- `"app/backgroundworker.h"`
- `"mytranslator.h"`
- `<sys/mman.h>`

**Functions:**

| Line | Signature |
|------|-----------|
| 24 | `void hideBootProgress()` |
| 38 | `void configureCrashLogging()` |
| 71 | `int main(int argc, char *argv[])` |

**Key observations:**
- `hideBootProgress()` writes directly to `/sys/module/nuc970fb/parameters/progress` (ARM-only, `#ifdef __arm__`).
- `configureCrashLogging()` writes a shell script to `/mnt/sd/app_monitor` and launches it with `QProcess::startDetached`; it is currently **commented out** at the call site (line 101).
- `main()` calls six `QProcess::execute()` shell commands to configure GPIO pins via `/sys/class/gpio` (lines 109–115), unconditionally on all platforms.
- `main()` constructs `QApplication`, `KeyFilter`, `Dialog`, `BackgroundWorker`, and a `QThread`, wires signals/slots, and enters the Qt event loop.
- `loadLocalLanguage()` is called at line 81 before any UI is shown.
- A commented-out `TODO` (lines 92–96) notes that production log redirection is not yet enabled.
- `CONSTRAINED_MEMORY_TEST` dead code block (lines 19–22, 102–105) locks a 10 MB memory region; it is compiled out by default but the dead code remains.

---

### mytranslator.h

**Class:** None (C-style free-function header)

**Includes:**
- `<QtGlobal>`

**Declarations:**

| Line | Signature |
|------|-----------|
| 11 | `const QString langEnglish = "EN"` |
| 12 | `const QString langSpanish = "ES"` |
| 14 | `extern QTranslator mTranslator` |
| 15 | `void loadLocalLanguage(void)` |
| 16 | `void updateLocalLanguage(const QString &arg1)` |
| 17 | `QString getCurrentLanguage(void)` |
| 18 | `int queryLanguage(void)` |
| 19 | `int setLanguage(int local)` |
| 20 | `void removeTranslator()` |

**Key observation:** `const QString langEnglish` and `const QString langSpanish` are defined in the header (not `inline`). Any translation unit that includes this header gets its own copy, which causes **ODR (One Definition Rule) violations** at link time if multiple translation units include it.

---

### mytranslator.cpp

**Class:** None (free functions)

**Includes:**
- `<QApplication>`
- `<QFile>`
- `<QDebug>`
- `<QTranslator>`
- `"mytranslator.h"`

**Functions:**

| Line | Signature |
|------|-----------|
| 15 | `void loadLocalLanguage(void)` |
| 74 | `void updateLocalLanguage(const QString &arg1)` |
| 132 | `QString getCurrentLanguage(void)` |
| 167 | `int queryLanguage(void)` |
| 177 | `int setLanguage(int local)` |
| 190 | `void removeTranslator()` |

**Global state:** `QTranslator mTranslator` at file scope (line 10).

**Key observations:**
- All file I/O is against hardcoded paths: `"local.dat"` (relative, CWD-dependent) and `":/lang.dat"` (Qt resource).
- `loadLocalLanguage()` silently deletes `local.dat` if no matching language is found (line 62), making repeated calls destructive.
- `updateLocalLanguage()` opens `localFile` with `QIODevice::ReadWrite` but does not truncate first; if the new language string is shorter than the old one, stale bytes remain.
- `queryLanguage()` returns `-1` for any language that is not English or Spanish; callers receive a sentinel with no named constant.
- `setLanguage()` returns `-1` for an unsupported locale integer without any error signal or documented contract.
- `removeTranslator()` depends on the global `mTranslator` singleton being the one that was installed; a second translator loaded from elsewhere would not be removed.

---

## Step 3 – Test Coverage Search

**Search targets:** `MyTranslator`, `mytranslator`, `loadLocalLanguage`, `updateLocalLanguage`, `getCurrentLanguage`, `queryLanguage`, `setLanguage`, `removeTranslator`, `mTranslator`, `langEnglish`, `langSpanish`

**Search path:** `C:/Projects/cig-audit/repos/mark3-pvd/test/`

**Result:** **Zero matches** across all test files.

**Test files present:**
- `test/test_backgroundworker.cpp` / `.h`
- `test/test_canbus.cpp` / `.h`
- `test/test_dialog.cpp` / `.h`
- `test/test_ota.cpp` / `.h`

**Project file confirmation:**
- `mk3.pro` lists `main.cpp` (production build, no test runner).
- `mk3-test.pro` lists `mytranslator.cpp` in `SOURCES` (line 44) and `mytranslator.h` in `HEADERS` (line 107) — meaning the translation unit is **compiled into the test binary** — but no test class or test function references any of its symbols.
- `main.cpp` is deliberately absent from `mk3-test.pro`, which is correct practice (the test binary supplies its own `main()`).

---

## Step 4 – Findings

---

**A11-1** · HIGH · Missing Test Coverage – Complete Absence
**File:** `C:/Projects/cig-audit/repos/mark3-pvd/mytranslator.cpp`
**Description:** No test file exercises any function in `mytranslator.cpp`. The module is compiled into the test binary (`mk3-test.pro` line 44) but none of its six public functions (`loadLocalLanguage`, `updateLocalLanguage`, `getCurrentLanguage`, `queryLanguage`, `setLanguage`, `removeTranslator`) are called from any test case. Language selection is a user-visible feature and file-system-mutating code; the absence of any test coverage means regressions will not be detected.
**Fix:** Create `test/test_translator.cpp` and `test/test_translator.h` with a `TestTranslator` QObject test class. Add it to `mk3-test.pro`. Use `QTemporaryDir` to sandbox file I/O so tests are hermetic. Register the class in the test runner in `test_backgroundworker.cpp` (lines 370–386). Minimum cases: happy path load, missing `local.dat`, unrecognised language token, empty `local.dat`, `lang.dat` resource missing or empty, `updateLocalLanguage` with unknown language, `queryLanguage` English/Spanish/unknown, `setLanguage` no-op when language matches.

---

**A11-2** · HIGH · Missing Test – `loadLocalLanguage` Silently Deletes State File
**File:** `C:/Projects/cig-audit/repos/mark3-pvd/mytranslator.cpp:55-62`
**Description:** When a language is read from `local.dat` but no matching entry is found in `lang.dat`, `loadLocalLanguage()` calls `local.remove()` (line 62), permanently deleting the persisted setting. There is no test that verifies whether this destructive fallback is intentional and behaves correctly (e.g., whether the application then defaults to English on next boot, and whether partial `local.dat` content triggers deletion). A regression here could silently reset the language for all devices on a firmware update that changes `lang.dat` entries.
**Fix:** In `TestTranslator`, write a `local.dat` containing a language code that is absent from a mock `lang.dat`, call `loadLocalLanguage()`, and assert that `local.dat` is removed and that a subsequent `getCurrentLanguage()` returns `langEnglish`.

---

**A11-3** · MEDIUM · Missing Test – `updateLocalLanguage` File Truncation Bug (No Test Catches It)
**File:** `C:/Projects/cig-audit/repos/mark3-pvd/mytranslator.cpp:112-118`
**Description:** `local.dat` is opened with `QIODevice::ReadWrite | QIODevice::Text` without `QIODevice::Truncate`. If a previously-written language string is longer than the new one (e.g., switching from a future 10-char code back to `"EN"`), stale trailing bytes remain in the file. A subsequent `loadLocalLanguage()` would read the full corrupt line, fail to match any language, and delete `local.dat`. There is no test that catches this corruption path because the module has zero test coverage.
**Fix:** Add a test that writes a long language string, then calls `updateLocalLanguage("EN")`, then reads back `local.dat` directly and asserts it contains exactly `"EN\n"` with no trailing characters. Also fix the production code by adding `QIODevice::Truncate` to the open flags.

---

**A11-4** · MEDIUM · Missing Test – `queryLanguage` Returns Undocumented Sentinel `-1`
**File:** `C:/Projects/cig-audit/repos/mark3-pvd/mytranslator.cpp:167-175`
**Description:** `queryLanguage()` returns `-1` for any language that is not English or Spanish. There is no named constant for this sentinel and no test that verifies callers handle it. `setLanguage()` (line 177) also returns `-1` for unsupported locale integers. Callers that treat the return value as a `QLocale::Language` enum would interpret `-1` as `QLocale::AnyLanguage` (value 0 in some Qt versions) or cause undefined behaviour. No test currently validates the boundary conditions or return semantics.
**Fix:** Define a named constant (e.g., `const int langUnknown = -1`) and add tests asserting that `queryLanguage()` returns it for unsupported languages, and that `setLanguage()` with an unknown locale returns `-1` without modifying `local.dat`.

---

**A11-5** · MEDIUM · Missing Test – `getCurrentLanguage` with Corrupt or Multi-Line `local.dat`
**File:** `C:/Projects/cig-audit/repos/mark3-pvd/mytranslator.cpp:132-165`
**Description:** `getCurrentLanguage()` reads only the first line of `local.dat` (`in.readLine()`, line 141) and uses a case-insensitive match. There is no test for: an empty first line, a line with only whitespace, a file containing multiple lines, or a file with a BOM. These edge cases are especially relevant because `updateLocalLanguage()` may write stale bytes (see A11-3) that corrupt the first line.
**Fix:** Add parametrised tests in `TestTranslator` for each of: empty file, whitespace-only first line, multi-line file (second line is valid language), BOM-prefixed content. Verify that `getCurrentLanguage()` returns `langEnglish` for all invalid-input cases.

---

**A11-6** · MEDIUM · main.cpp – Startup Logic Not Testable Due to Hardwired Side Effects
**File:** `C:/Projects/cig-audit/repos/mark3-pvd/main.cpp:71-135`
**Description:** `main()` cannot be unit tested (correctly excluded from `mk3-test.pro`). However, the two free functions `hideBootProgress()` and `configureCrashLogging()` are also not covered by any test, and both contain side effects (file writes to `/sys/...` and `/mnt/sd/...`, and `QProcess::startDetached`). The six `QProcess::execute()` GPIO calls (lines 109–115) in `main()` are not wrapped or abstracted, making it impossible to test initialization logic without real hardware. The dead `CONSTRAINED_MEMORY_TEST` block (lines 17–22, 102–105) also calls `mlock()` which would affect test environments if accidentally enabled.
**Fix:** Extract GPIO setup and boot-progress toggling into an abstracted platform interface (or at minimum a standalone free function guarded by `#ifndef UNIT_TEST`) so the logic can be exercised in the test build without requiring `/sys/class/gpio`. Add unit tests for `hideBootProgress()` and `configureCrashLogging()` that mock the file system. Remove or formally document the `CONSTRAINED_MEMORY_TEST` dead code.

---

**A11-7** · LOW · ODR Violation Risk – `const QString` Definitions in Header
**File:** `C:/Projects/cig-audit/repos/mark3-pvd/mytranslator.h:11-12`
**Description:** `langEnglish` and `langSpanish` are defined as `const QString` objects in a header file. In C++, `const` variables at namespace scope have internal linkage, so each translation unit gets its own copy. For plain types this is harmless, but `QString` has a non-trivial constructor; the duplicated static objects increase binary size and may cause subtle lifetime issues in translation units that outlive the destructor order. No test validates the string values or detects silent redefinition.
**Fix:** Move the definitions to `mytranslator.cpp` and declare them `extern const QString` in the header, or use `inline const QString` (C++17) / `constexpr char[]` literals.

---

**A11-8** · LOW · Missing Test – `removeTranslator` with No Translator Installed
**File:** `C:/Projects/cig-audit/repos/mark3-pvd/mytranslator.cpp:190-198`
**Description:** `removeTranslator()` guards removal with `!mTranslator.isEmpty()`, but there is no test that calls it before any translator is installed, verifying the guard works correctly and does not crash. There is also no test for the path where `QCoreApplication::removeTranslator()` returns `false` (translator not found), which triggers a debug print but no error handling.
**Fix:** Add tests: (1) call `removeTranslator()` with no translator loaded and verify no crash; (2) install a translator, call `removeTranslator()`, verify the translator is no longer active; (3) call `removeTranslator()` twice and verify the second call is a no-op.

---

## Step 5 – Summary Table

| ID | Severity | Category | File | Brief Description |
|----|----------|----------|------|-------------------|
| A11-1 | HIGH | Missing Coverage | `mytranslator.cpp` | Zero test coverage across all six public functions |
| A11-2 | HIGH | Missing Coverage | `mytranslator.cpp:55-62` | No test for `loadLocalLanguage` destructive file deletion on language mismatch |
| A11-3 | MEDIUM | Missing Coverage / Bug | `mytranslator.cpp:112-118` | No test for `updateLocalLanguage` file-truncation bug |
| A11-4 | MEDIUM | Missing Coverage | `mytranslator.cpp:167-175` | No test for `queryLanguage`/`setLanguage` sentinel `-1` return |
| A11-5 | MEDIUM | Missing Coverage | `mytranslator.cpp:132-165` | No test for `getCurrentLanguage` with corrupt or edge-case `local.dat` content |
| A11-6 | MEDIUM | Testability / Design | `main.cpp:71-135` | Startup side effects (GPIO, file writes, process launch) are not abstracted or tested |
| A11-7 | LOW | Design / ODR | `mytranslator.h:11-12` | `const QString` constants defined in header — ODR risk and binary bloat |
| A11-8 | LOW | Missing Coverage | `mytranslator.cpp:190-198` | No test for `removeTranslator` edge cases (uninstalled translator, double-remove) |

---

*End of report – Agent A11, Pass 2 (Test Coverage), Audit 2026-02-28-01*
# Security Audit – Pass 2: Test Coverage
**Agent:** A12
**Audit Run:** 2026-02-28-01
**Branch confirmed:** master (verified via `git branch --show-current`)
**Date:** 2026-02-28

---

## Files Audited

| # | Source file | Header |
|---|-------------|--------|
| 1 | `platform/aescrypto.cpp` | `platform/aescrypto.h` |
| 2 | `platform/blecentral.cpp` | `platform/blecentral.h` |

---

## Reading Evidence

### AesCrypto (`platform/aescrypto.h` + `platform/aescrypto.cpp`)

**Class:** `EM070::AesCrypto`

**Includes:**
- `aescrypto.h`
- `<unistd.h>` (ARM only)
- `<linux/if_alg.h>` (ARM only)
- `<sys/socket.h>` (ARM only)
- `<QDebug>`
- `<QByteArray>` (via header)

**Public methods:**

| Method | Location | Notes |
|--------|----------|-------|
| `static QByteArray encrypt(const QByteArray &in)` | `aescrypto.h:16`, impl `aescrypto.cpp:150` | Public static entry point for encryption |
| `static QByteArray descrypt(const QByteArray &in)` | `aescrypto.h:17`, impl `aescrypto.cpp:156` | Public static entry point for decryption (note: misspelled — "descrypt" not "decrypt") |

**Private methods:**

| Method | Location |
|--------|----------|
| `bool enableMtp()` | `aescrypto.cpp:20` |
| `QByteArray aes(const QByteArray &in, bool encrypt)` | `aescrypto.cpp:63` |

**Signals/Slots:** None declared.

**Static data member:** `static bool m_mtpEnabled` (`aescrypto.h:22`, initialised `aescrypto.cpp:18`)

**Key implementation notes:**
- All real crypto work is inside `#ifdef __arm__` guards; on non-ARM builds every method returns an empty `QByteArray`.
- IV is hardcoded at `aescrypto.cpp:124`: `"\x3d\xaf\xba\x42\x9d\x9e\xb4\x30\xb4\x22\xda\x80\x2c\x9f\xac\x41"`.
- CBC-AES via Linux kernel AF_ALG socket interface; key comes from MTP hardware (not from the caller).
- Chunk loop at `aescrypto.cpp:131` may call `sendmsg`/`read` with a zero-length final chunk when `in.size()` is an exact multiple of 1024.

---

### BleCentral (`platform/blecentral.h` + `platform/blecentral.cpp`)

**Classes:**
- `EM070::CharacteristicInfo` (helper, `blecentral.h:13`)
- `EM070::DescriptorInfo` (helper, `blecentral.h:30`)
- `EM070::BleCentral` (main class, `blecentral.h:45`)

**Includes:**
- `blecentral.h`
- `seriallogger.h`
- `<QTimer>`
- `<QDebug>`
- `<QLowEnergyConnectionParameters>`
- `<QObject>`, `<QBluetoothDeviceDiscoveryAgent>`, `<QBluetoothDeviceInfo>`, `<QLowEnergyController>` (via header)

**Public methods of `BleCentral`:**

| Method | Location |
|--------|----------|
| `explicit BleCentral(QObject *parent = nullptr)` | `blecentral.h:51`, impl `blecentral.cpp:14` |
| `~BleCentral()` | `blecentral.h:52`, impl `blecentral.cpp:42` |
| `void setEnabled(bool enable)` | `blecentral.h:54`, impl `blecentral.cpp:74` |
| `void setPeripheralAddress(const quint64 &address)` | `blecentral.h:56`, impl `blecentral.cpp:54` |
| `void setAuthorizationCode(const quint128 &uuid, const QByteArray &code)` | `blecentral.h:57`, impl `blecentral.cpp:68` |
| `State state() const` | `blecentral.h:59` (inline) |
| `QByteArrayList servicesUuid() const` | `blecentral.h:61`, impl `blecentral.cpp:303` |
| `QByteArrayList characteristicsUuid() const` | `blecentral.h:62`, impl `blecentral.cpp:312` |
| `QByteArrayList descriptionsUuid() const` | `blecentral.h:63`, impl `blecentral.cpp:321` |
| `bool readCharacteristic(const quint128 &uuid)` | `blecentral.h:65`, impl `blecentral.cpp:350` |
| `bool writeCharacteristic(const quint128 &uuid, const QByteArray &ba)` | `blecentral.h:66`, impl `blecentral.cpp:364` |
| `bool readDescriptor(const quint128 &uuid)` | `blecentral.h:67`, impl `blecentral.cpp:378` |
| `bool writeDescriptor(const quint128 &uuid, const QByteArray &ba)` | `blecentral.h:68`, impl `blecentral.cpp:396` |

**Signals of `BleCentral`:**

| Signal | Location |
|--------|----------|
| `void accessible(bool yes)` | `blecentral.h:71` |
| `void error(QBluetoothDeviceDiscoveryAgent::Error newError)` | `blecentral.h:74` |
| `void error(QLowEnergyController::Error newError)` | `blecentral.h:77` |
| `void error(QLowEnergyService::ServiceError newError)` | `blecentral.h:80` |
| `void characteristicChanged(const quint128 &uuid, const QByteArray &newValue)` | `blecentral.h:81` |
| `void characteristicRead(const quint128 &uuid, const QByteArray &value)` | `blecentral.h:82` |
| `void characteristicWritten(const quint128 &uuid, const QByteArray &newValue)` | `blecentral.h:83` |
| `void descriptorRead(const quint128 &uuid, const QByteArray &value)` | `blecentral.h:84` |
| `void descriptorWritten(const quint128 &uuid, const QByteArray &newValue)` | `blecentral.h:85` |

**Private slots / internal handlers (connected via signal-slot):**

| Slot | Location |
|------|----------|
| `void startDeviceDiscovery()` | `blecentral.cpp:101` |
| `void connectToDevice()` | `blecentral.cpp:143` |
| `void addDevice(const QBluetoothDeviceInfo &)` | `blecentral.cpp:110` |
| `void deviceDiscoveryFinished()` | `blecentral.cpp:125` |
| `void deviceDiscoveryError(QBluetoothDeviceDiscoveryAgent::Error)` | `blecentral.cpp:136` |
| `void deviceConnected()` | `blecentral.cpp:181` |
| `void deviceDisconnected()` | `blecentral.cpp:196` |
| `void addService(const QBluetoothUuid &newService)` | `blecentral.cpp:205` |
| `void serviceDiscoveryFinished()` | `blecentral.cpp:246` |
| `void serviceStateChanged(QLowEnergyService::ServiceState newState)` | `blecentral.cpp:257` |

---

## Test Coverage Search Results

**Test directory contents (`test/`):**
- `test_backgroundworker.cpp/.h`
- `test_canbus.cpp/.h`
- `test_dialog.cpp/.h`
- `test_ota.cpp/.h`
- `FleetIQ360App_5.2.2F.h`

**Search results for `AesCrypto`, `encrypt`, `descrypt`, `enableMtp`, `aescrypto` (case-insensitive) across all files in `test/`:** NO MATCHES FOUND.

**Search results for `BleCentral`, `blecentral`, `setEnabled`, `setPeripheralAddress`, `setAuthorizationCode`, `readCharacteristic`, `writeCharacteristic`, `readDescriptor`, `writeDescriptor`, `servicesUuid`, `characteristicsUuid`, `descriptionsUuid` across all files in `test/`:** NO MATCHES FOUND.

Neither `AesCrypto` nor `BleCentral` is referenced anywhere in the test directory. There are no test files dedicated to either class.

---

## Findings

---

**A12-1** · CRITICAL · Missing Test Coverage – Cryptographic Component
**File:** `platform/aescrypto.cpp:150-160`
**Description:** The `AesCrypto` class, which provides the sole encryption and decryption interface for the product (`encrypt()` and `descrypt()`), has zero test coverage in the test suite. No test file includes the header, instantiates the class, or calls either public method. This means there is no automated verification that the cipher produces correct output, that encrypt followed by decrypt returns the original plaintext, or that the implementation behaves correctly across input sizes.
**Fix:** Create `test/test_aescrypto.cpp`. Because the ARM-only `#ifdef __arm__` guard makes the underlying kernel socket path unavailable on a host build system, introduce a thin seam (e.g., a virtual or function-pointer-based `aes()` backend) so unit tests can supply a stub. At minimum, on an ARM target or in an integration CI environment, add Known-Answer Tests (KATs) using NIST CAVP CBC-AES test vectors: supply a known plaintext and key, verify the ciphertext matches the expected value, then decrypt and verify round-trip equality.

---

**A12-2** · CRITICAL · No Known-Answer Tests (KAT) for AES Implementation
**File:** `platform/aescrypto.cpp:63-148`
**Description:** No KAT vectors are present anywhere in the test suite for the AES-CBC implementation. A KAT feeds a fixed, published plaintext/key/IV tuple into the cipher and asserts the resulting ciphertext matches a reference value from a standards body (e.g., NIST SP 800-38A). Without KATs, a regression in the underlying crypto driver or a misconfiguration of the IV (which is hardcoded at line 124) would go undetected.
**Fix:** Add NIST SP 800-38A CBC test vectors as static test cases. Run them as part of a `QTest`-based test function that directly calls `AesCrypto::encrypt()` and compares the output to the published expected ciphertext. These tests should be gated to run on the ARM target (or a compatible emulator) where the AF_ALG path is available.

---

**A12-3** · HIGH · No Boundary / Edge-Case Tests for AesCrypto
**File:** `platform/aescrypto.cpp:126-141`
**Description:** The following boundary conditions are entirely untested:
1. **Empty input** (`in.size() == 0`): The loop at line 131 (`i < in.size() - 1024`) evaluates to `0 < -1024` which, because `in.size()` returns a signed `int`, results in a large positive value due to unsigned wrap-around. The loop body would then execute with an out-of-range pointer, causing undefined behaviour or a crash.
2. **Input size not a multiple of AES block size (16 bytes)**: CBC-AES requires plaintext to be padded to a multiple of the block size. The code performs no padding and does not document or enforce this requirement. Calling `encrypt()` with, for example, a 15-byte or 17-byte input will silently pass a non-block-aligned length to the kernel, producing an implementation-defined result or an error that is silently swallowed.
3. **Input exactly 1024 bytes (loop boundary)**: When `in.size() == 1024`, the loop condition `i < in.size() - 1024` equals `0 < 0` and the loop body is skipped; the tail path then sends 1024 bytes via `sendmsg(tfd, &msg, 0)`. This path is the one normally taken for the last (or only) segment, so 1024 bytes should be handled correctly, but it is untested.
**Fix:** Add unit/integration test cases for empty input (assert that an empty `QByteArray` is returned without crashing), for inputs of sizes 1, 15, 16, 17, 1023, 1024, 1025, and 2048 bytes. Fix the signed-integer underflow bug in the loop guard before adding tests.

---

**A12-4** · CRITICAL · Missing Test Coverage – BleCentral Component
**File:** `platform/blecentral.cpp`, `platform/blecentral.h`
**Description:** The `BleCentral` class, which manages all BLE device discovery, connection lifecycle, service and characteristic enumeration, and data read/write operations, has zero test coverage. Not one test file references it. The following observable behaviours are completely untested:
- Device discovery start/stop and retry on failure.
- Correct state machine transitions (`Disabled` → `Discovering` → `Ready` and back).
- Connection timeout and reconnect logic (the `m_reconnectTimer` path).
- Service and characteristic enumeration (the `addService` / `serviceStateChanged` chain).
- Authorization code write (`serviceStateChanged:274-275`).
- `readCharacteristic`, `writeCharacteristic`, `readDescriptor`, `writeDescriptor` return values for missing UUID, non-readable characteristic, and missing parent service.
- Emission of `accessible(true/false)` and `error()` signals at correct lifecycle points.
**Fix:** Create `test/test_blecentral.cpp`. Use Qt's `QSignalSpy` to observe signals. Provide mock/stub implementations of `QBluetoothDeviceDiscoveryAgent` and `QLowEnergyController` (or use dependency injection to replace them) so that tests can simulate device-found, connected, disconnected, and error events without requiring real hardware.

---

**A12-5** · HIGH · Disconnection Handling Not Tested
**File:** `platform/blecentral.cpp:196-202`
**Description:** `deviceDisconnected()` sets state to `Discovering`, emits `accessible(false)`, and starts `m_reconnectTimer` with `RECONNECT_RETRY_WAIT` (2000 ms). The reconnect path fires a lambda that calls `setEnabled(false)` then `setEnabled(true)`, which tears down the controller and restarts discovery. This entire reconnect loop is untested. A regression here — such as the state guard at line 76 preventing re-enable — would cause the device to silently stop attempting to reconnect after a drop, with no automated detection.
**Fix:** In the `BleCentral` test suite, simulate a disconnection event (by calling `deviceDisconnected()` directly or through a mock controller signal) and use `QSignalSpy` to assert that `accessible(false)` is emitted and that the reconnect timer fires within the expected window, ultimately transitioning back to `Discovering` state.

---

**A12-6** · HIGH · Service Enumeration with Empty Service List Not Tested
**File:** `platform/blecentral.cpp:246-255`
**Description:** `serviceDiscoveryFinished()` guards against an empty `m_services` list at line 248 and returns early without emitting any signal. This means a connected device that advertises no services silently leaves `BleCentral` in a non-`Ready` state indefinitely (the reconnect timer from `deviceConnected()` is still running and will eventually reset the connection). This failure mode and its recovery are untested.
**Fix:** Add a test case that simulates a successful connection followed by `serviceDiscoveryFinished()` with an empty service list. Assert that `accessible(true)` is never emitted, that the reconnect timer eventually fires, and that the state machine returns to `Discovering`.

---

## Summary Table

| ID | Severity | Category | Component | One-line description |
|----|----------|----------|-----------|----------------------|
| A12-1 | CRITICAL | Missing Test Coverage | AesCrypto | No tests exist for `encrypt()` or `descrypt()` |
| A12-2 | CRITICAL | Missing KAT | AesCrypto | No NIST Known-Answer Tests for AES-CBC implementation |
| A12-3 | HIGH | Boundary Cases | AesCrypto | Empty input, non-block-aligned input, and chunk-boundary sizes are untested and trigger UB |
| A12-4 | CRITICAL | Missing Test Coverage | BleCentral | No tests exist for any BleCentral method or signal |
| A12-5 | HIGH | Disconnection Handling | BleCentral | Reconnect-after-disconnect path is entirely untested |
| A12-6 | HIGH | Edge Case | BleCentral | Empty service list after connection leaves state machine stalled; untested |

**Overall assessment:** Both `AesCrypto` and `BleCentral` have 0% test coverage. `AesCrypto` is a security-critical component whose correctness cannot be verified without Known-Answer Tests; additionally the implementation contains a potential integer underflow in its loop guard for empty inputs. `BleCentral` is a complex stateful component whose reconnect and service-enumeration paths contain subtle failure modes that are entirely undetected by the current suite.
# Audit Report — Agent A13 — Pass 2: Test Coverage
**Audit Run:** 2026-02-28-01
**Agent:** A13
**Pass:** 2 — Test Coverage
**Date:** 2026-02-28

---

## 1. Branch Confirmation

```
Branch verified: master
Command: git branch --show-current → "master"
```

---

## 2. Assigned Files

| # | Source File | Header File |
|---|-------------|-------------|
| 1 | `platform/canbus.cpp` | `platform/canbus.h` |
| 2 | `platform/gnssreceiver.cpp` | `platform/gnssreceiver.h` |

---

## 3. Reading Evidence

### 3.1 `platform/canbus.h` — Includes

| Line | Include |
|------|---------|
| 4 | `<QObject>` |
| 5 | `<QCanBusDevice>` |
| 6 | `<QCanBusFrame>` |
| 7 | `<QQueue>` |
| 8 | `<QTimer>` |

### 3.2 `platform/canbus.cpp` — Includes

| Line | Include |
|------|---------|
| 1 | `"canbus.h"` |
| 2 | `"platform/seriallogger.h"` |
| 3 | `<QCanBus>` |
| 4 | `<QMetaObject>` |
| 5 | `<QProcess>` |
| 6 | `<QTimerEvent>` |
| 7 | `<QTimer>` |
| 8 | `<QDebug>` |
| 9 | `<QFile>` |
| 10 | `<QDateTime>` |

### 3.3 `EM070::CanBus` — Public Methods

| Line (header) | Signature | Type |
|---------------|-----------|------|
| 25 | `CanBus(CanDeviceId id = CAN1, QObject *parent = nullptr)` | Constructor |
| 28 | `~CanBus()` | Destructor |
| 30 | `void initialize()` | Public method |
| 32 | `void setXferEnabled(bool enable)` | Public method |
| 33 | `bool isXferEnabled() const` | Public method (inline) |
| 35 | `void setPower(bool on)` | Public method |
| 36 | `bool isEnabled() const` | Public method (inline) |
| 38 | `bool setBaudRate(int baudRate)` | Public method |
| 39 | `int baudRate() const` | Public method (inline) |
| 41 | `void addRequest(quint32 id, const QByteArray &ba, quint32 interval)` | Public method |
| 42 | `QList<Request> getRequests()` | Public method (inline) |
| 43 | `void clearRequests()` | Public method |
| 45 | `void addFilter(quint32 identifier)` | Public method |
| 46 | `void clearFilters()` | Public method |
| 47 | `void applyFilters()` | Public method |
| 49 | `void writeFrameDirect(quint32 id, const QByteArray &ba)` | Public method |
| 51 | `void removeRequests(quint32 id)` | Public method |

### 3.4 `EM070::CanBus` — Signals

| Line (header) | Signature |
|---------------|-----------|
| 54 | `void error(QCanBusDevice::CanBusError canBusError)` |
| 55 | `void read(quint32 identifier, const QByteArray &ba)` |

### 3.5 `EM070::CanBus` — Protected / Private Methods

| Line (cpp) | Signature | Visibility |
|------------|-----------|------------|
| 51 | `void sendRequest()` | Protected |
| 264 | `void readFrame()` | Private |
| 274 | `void handleError(QCanBusDevice::CanBusError error)` | Private |

---

### 3.6 `platform/gnssreceiver.h` — Includes

| Line | Include |
|------|---------|
| 4 | `"app/cigconfigs.h"` |
| 5 | `<QObject>` |
| 9 | `class QSerialPort` (forward declaration) |

### 3.7 `platform/gnssreceiver.cpp` — Includes

| Line | Include |
|------|---------|
| 1 | `"gnssreceiver.h"` |
| 2 | `"app/globalconfigs.h"` |
| 3 | `"platform/seriallogger.h"` |
| 4 | `<QFile>` |
| 5 | `<QSerialPort>` |
| 6 | `<QTimerEvent>` |
| 7 | `<QDebug>` |
| 8 | `<QtMath>` |
| 9 | `<math.h>` |

### 3.8 `EM070::GnssReceiver` — Public Methods

| Line (header) | Signature | Type |
|---------------|-----------|------|
| 17 | `GnssReceiver(QObject *parent = nullptr)` | Constructor |
| 18 | `void portStateChanged(bool open)` | Public method |
| 19 | `void reset()` | Public method |
| 20 | `void changeUpdateTime()` | Public method |
| 22 | `quint8 satelliteCount() const` | Public accessor (inline) |
| 23 | `qint32 latitude() const` | Public accessor (inline) |
| 24 | `qint32 longitude() const` | Public accessor (inline) |
| 25 | `qint32 lastLatitude() const` | Public accessor (inline) |
| 26 | `qint32 lastLongitude() const` | Public accessor (inline) |
| 27 | `qint16 speed() const` | Public accessor (inline) |
| 28 | `qint16 course() const` | Public accessor (inline) |
| 29 | `quint32 distance() const` | Public accessor (inline) |
| 30 | `quint32 sumOfDistance() const` | Public accessor (inline) |
| 31 | `quint32 altitude() const` | Public accessor (inline) |
| 32 | `bool locked() const` | Public accessor (inline) |
| 33 | `quint32 hpe() const` | Public accessor (inline) |
| 34 | `quint32 hdop() const` | Public accessor (inline) |
| 35 | `qint64 age()` | Public method |
| 36 | `quint8 warn() const` | Public accessor (inline) |
| 37 | `void setWarn(quint8 n)` | Public setter (inline) |
| 38 | `quint8 quality() const` | Public accessor (inline) |
| 39 | `void setQuality(quint8 n)` | Public setter (inline) |
| 40 | `quint16 markerCnt() const` | Public accessor (inline) |
| 41 | `void setMarkerCnt(quint16 n)` | Public setter (inline) |
| 42 | `quint32 pathLatitude(int n)` | Public method |
| 43 | `void setPathLatitude(int n, quint32 lat)` | Public method |
| 44 | `quint32 pathLongitude(int n)` | Public method |
| 45 | `void setPathLongitude(int n, quint32 lon)` | Public method |
| 46 | `void gpsDebugPrint()` | Public method |
| 47 | `bool inPoly2(const CIGCONF::gpsPosStruct *gpsPos, const CIGCONF::polygonStruct *polygon)` | Public method — **declared but NEVER DEFINED** |
| 48 | `bool pointInPolygon(int polyCorners, CIGCONF::position me, CIGCONF::position *points)` | Public method |
| 49 | `double degrees2radians(double degrees)` | Public method |

### 3.9 `EM070::GnssReceiver` — Signals

| Line (header) | Signature |
|---------------|-----------|
| 54 | `void sendGmtpMessage(CIGCONF::GmtpMessage msg, const QByteArray &extra = QByteArray())` |

### 3.10 `EM070::GnssReceiver` — Protected / Private Methods

| Line (cpp) | Signature | Visibility |
|------------|-----------|------------|
| 44 | `void timerEvent(QTimerEvent *)` | Protected override |
| 57 | `void readData()` | Private slot |
| 58 | `void parseData(const QByteArray &ba)` | Private |
| 59 | `void cumulateDistance()` | Private |
| 60 | `static quint32 calculateDistance(qint32, qint32, qint32, qint32)` | Private static |

---

## 4. Test File Survey

### 4.1 Primary CAN bus test file: `test/test_canbus.h` + `test/test_canbus.cpp`

The `TestCanbus` class contains exactly **one test slot**:

- `test_vdiMode()` — exercises `BackgroundWorker::initialiseCanbus1()`, `initialiseCanbus2()`, and `getRequests()` indirectly via the `CanMonitor` subsystem. It verifies that the VDI-mode hard-coded CAN rules produce the correct frame IDs and payloads in `m_canBus1->getRequests()`.

**Coverage via `test_vdiMode()`:**

| CanBus Method | Called in Test? | Notes |
|---------------|-----------------|-------|
| `CanBus()` constructor | Indirectly (via `initialiseCanbus1/2`) | Not directly tested |
| `initialize()` | Indirectly | No assertion on device-creation failure |
| `setXferEnabled()` | No | Never invoked in test |
| `isXferEnabled()` | No | Never asserted |
| `setPower()` | No | Never invoked in test |
| `isEnabled()` | No | Never asserted |
| `setBaudRate()` | No | Never invoked in test |
| `baudRate()` | No | Never asserted |
| `addRequest()` | No (called internally by `CanMonitor`) | Not tested directly |
| `getRequests()` | Yes | Asserted on frame ID and payload |
| `clearRequests()` | No | Not exercised directly |
| `addFilter()` | No | Not tested |
| `clearFilters()` | No | Not tested |
| `applyFilters()` | No | Not tested |
| `writeFrameDirect()` | No | Not tested |
| `removeRequests()` | No | Not tested |
| `sendRequest()` (protected) | No | Not triggered |
| `readFrame()` (private) | No | No frame injection |
| `handleError()` (private) | No | No error injection |
| Signal `error` | No | Never spied on |
| Signal `read` | No | Never spied on |

### 4.2 GnssReceiver test coverage

Grep search across the entire repository confirms: **no test file references `GnssReceiver`, `gnssreceiver`, `parseData`, `GPRMC`, `GPGGA`, or any NMEA-related term in a test context.** There are zero test cases for `GnssReceiver`.

---

## 5. Findings

---

**A13-01** · HIGH · Missing Test Coverage — CanBus Error Paths
**File:** `platform/canbus.cpp:274`
**Description:** `handleError()` emits the `error` signal and rate-limits its own logging using a 10-second cooldown (`m_lastReportedError`). No test exercises any `QCanBusDevice::CanBusError` variant — including `BusOffError`, `WriteError`, `ReadError`, or `ConnectionError`. The cooldown logic (which suppresses repeated error signals) is also untested, meaning a regression where the guard is inverted or the window is changed would go undetected. The `error` signal is never captured by a `QSignalSpy` anywhere in the test suite.
**Fix:** Add unit tests that inject `QCanBusDevice::CanBusError` values via a mock or stub `QCanBusDevice`. Assert (a) that the `error` signal fires once on first error, (b) that a second error within 10 seconds does not emit a second signal, and (c) that an error after >10 seconds does re-emit. Cover at least `BusOffError`, `WriteError`, and `ConnectionError`.

---

**A13-02** · HIGH · Missing Test Coverage — CanBus Socket / Device Initialization Failure
**File:** `platform/canbus.cpp:34`
**Description:** `initialize()` calls `QCanBus::instance()->createDevice(...)`. On failure it logs a critical message and returns silently, leaving `m_canBusDevice` as `nullptr`. All subsequent methods guard against `nullptr` (`sendRequest`, `applyFilters`, `writeFrameDirect`, etc.), but none of this failure-path behavior is tested. In particular, the interaction between a `nullptr` device and `setXferEnabled(true)` or `addRequest()` being called subsequently is untested.
**Fix:** Stub or mock `QCanBus::instance()` to simulate a creation failure. Assert that `initialize()` does not crash, that the device remains `nullptr`, and that subsequently calling `setXferEnabled(true)` and `writeFrameDirect()` does not crash or produce unexpected behaviour.

---

**A13-03** · HIGH · Zero Test Coverage — GnssReceiver (Entire Class)
**File:** `platform/gnssreceiver.cpp`, `platform/gnssreceiver.h`
**Description:** There are no test files, no test cases, and no test references to `GnssReceiver` anywhere in the repository. The class implements NMEA sentence parsing, fix-validity state management, cumulative distance tracking, geofence evaluation, and path waypoint storage — all safety- and location-relevant logic. Not a single line is covered by automated tests.
**Fix:** Create a dedicated test file (`test/test_gnssreceiver.cpp`). At minimum, write tests for: (a) valid `GPRMC` sentence parsing — verify latitude/longitude/speed/course fields, (b) valid `GPGGA` sentence parsing — verify satellite count, quality, HDOP, altitude fields, (c) fix-lost scenario — send `GPRMC` with validity field `'V'` and assert `locked()` becomes false, (d) fix-gained scenario — send a sequence of `GPGGA` then `GPRMC` with valid data and assert `locked()` becomes true, (e) checksum/malformed sentence — send truncated or invalid sentences and assert no crash and no state mutation, (f) zero-satellite / high-HDOP inhibit — assert that `m_locked` is forced false when `m_satelliteCount == 0` or `m_hdop >= 5000`.

---

**A13-04** · HIGH · NMEA Checksum Not Validated — No Test Possible Until Code Is Added
**File:** `platform/gnssreceiver.cpp:101`
**Description:** `parseData()` splits the raw NMEA byte array by comma and immediately trusts the field values. Standard NMEA 0183 sentences include a `*HH` checksum suffix at the end of the last field; this implementation performs no checksum extraction or verification. Corrupted serial data (bit errors, serial port framing errors, partial DMA reads) will silently produce wrong latitude/longitude/speed values that propagate into distance accumulation and geofence evaluations. Because there is no checksum validation, a test for "checksum failure is rejected" cannot be written without first adding the validation logic.
**Fix:** Before splitting on commas, extract and validate the XOR checksum from the `*HH` suffix. If the checksum does not match, discard the sentence. Then add a test that supplies a sentence with an intentionally wrong checksum and asserts that no state fields change.

---

**A13-05** · MEDIUM · Missing Test Coverage — `parseData()` Buffer Handling and `readData()` Fragmentation
**File:** `platform/gnssreceiver.cpp:72`
**Description:** `readData()` implements a custom state machine that accumulates NMEA sentence bytes across multiple serial reads using `m_receiver` as a carry buffer. The logic for handling a `'$'` mid-buffer (resetting `size` to 0), partial sentences split across two reads, and the `m_receiver.isEmpty()` branch versus the non-empty branch is complex and completely untested. A regression in this logic could cause sentences to be parsed from stale buffer contents or silently dropped.
**Fix:** Add unit tests that feed raw byte arrays in fragments to a testable variant of `readData()` (or expose `parseData()` for direct testing) and verify: (a) a sentence split at an arbitrary boundary is reassembled correctly, (b) a `'$'` that appears mid-stream discards the prior incomplete sentence, (c) back-to-back complete sentences in a single read are both parsed.

---

**A13-06** · MEDIUM · Missing Test Coverage — `calculateDistance()` Edge Cases
**File:** `platform/gnssreceiver.cpp:339`
**Description:** `calculateDistance()` is a simplified Haversine implementation that operates on fixed-point coordinates scaled by 10,000,000. It has three early-exit paths: returning `UINT_MAX` if `|dx| > 256,000,000` (>1000 km in x), returning `UINT_MAX` if `|dy| > 256,000,000` (>1000 km in y), and a calling-site check in `cumulateDistance()` rejecting distances > 1,000,000 m. The function is also used across the equator and across the anti-meridian. None of these conditions are tested, meaning the overflow-guard code paths and the anti-meridian wrap case have no test evidence of correctness.
**Fix:** Add parameterised unit tests: (a) two nearby points — assert expected distance within ±5%; (b) points separated by more than 1000 km in longitude — assert `UINT_MAX` is returned; (c) points separated by more than 1000 km in latitude — assert `UINT_MAX` is returned; (d) coordinates that straddle the equator; (e) verify that `cumulateDistance()` drops the computed value when it exceeds the 1,000 km guard.

---

**A13-07** · MEDIUM · Missing Test Coverage — `inPoly2()` Declared But Never Defined
**File:** `platform/gnssreceiver.h:47`
**Description:** `bool inPoly2(const CIGCONF::gpsPosStruct *gpsPos, const CIGCONF::polygonStruct *polygon)` is declared as a public method in the header but has no corresponding implementation anywhere in the repository (`grep` across all `.cpp` files confirms no definition). This is a dead or abandoned API. If any code path were to call it at runtime, it would produce an undefined symbol linker error (or, in a shared-library scenario, a runtime crash). The absence of tests means this dangling declaration has never been caught.
**Fix:** Either provide a correct implementation and test it, or remove the declaration from the header to prevent accidental future use.

---

**A13-08** · MEDIUM · Missing Test Coverage — `pointInPolygon()` Correctness
**File:** `platform/gnssreceiver.cpp:428`
**Description:** `pointInPolygon()` implements a ray-casting algorithm using radians-converted coordinates. Edge cases for this algorithm are well-known: a point exactly on an edge, a point at a vertex, a degenerate polygon (fewer than 3 corners), and a concave polygon can all produce incorrect results depending on the implementation. The algorithm uses `latrad` / `lonrad` fields but assumes they have been populated by the caller; there is no guard for uninitialised `points` entries. No tests exist for this method.
**Fix:** Add unit tests covering: (a) a point clearly inside a triangle, (b) a point clearly outside, (c) a point on the boundary edge, (d) a degenerate polygon with 0–2 corners, (e) a concave polygon where the ray-casting result is verified against a known reference.

---

**A13-09** · MEDIUM · Missing Test Coverage — `CanBus::applyFilters()` Extended-Frame Bit Stripping
**File:** `platform/canbus.cpp:224`
**Description:** `applyFilters()` inspects bit 29 of each filter identifier to determine whether to apply an extended-frame mask (`0x3ffff00`) or a base-frame mask (`0x3ff`). It also strips bit 29 from the `id` before writing to `filter.frameId`. This logic is not tested. An off-by-one in the bit position or an incorrect mask value would cause frames to be silently admitted or silently dropped on the bus.
**Fix:** Add tests that add a mix of standard (≤0x7FF) and extended (bit-29 set) identifiers, call `applyFilters()`, and inspect the resulting `QCanBusDevice` configuration parameter for correct `frameId`, `frameIdMask`, and `format` values. Also test the duplicate-suppression (`id == last`) path.

---

**A13-10** · MEDIUM · Missing Test Coverage — `CanBus::sendRequest()` Duplicate Suppression and Queue Draining
**File:** `platform/canbus.cpp:51`
**Description:** `sendRequest()` dequeues one frame per timer tick and re-enqueues periodic requests only when their countdown expires. It also contains a duplicate-suppression loop that prevents the same `(frameId, payload)` pair from being enqueued twice. None of this scheduling logic is tested: there is no test that starts the timer, verifies frame ordering, confirms that duplicate frames are suppressed, or confirms that a request with `interval == 0` is never enqueued.
**Fix:** Add tests that: (a) add two requests with different intervals and verify only the correct one is enqueued after each simulated tick, (b) add a request with `interval == 0` and verify it is never queued, (c) add the same `(id, payload)` twice rapidly and verify only one copy appears in the queue.

---

**A13-11** · LOW · Missing Test Coverage — `CanBus::setPower()` GPIO and Process Failure Paths
**File:** `platform/canbus.cpp:105`
**Description:** `setPower()` opens two GPIO sysfs files and spawns `ifconfig` / `ip link set` processes via `QProcess`. Failures to open the GPIO files are logged but execution continues (the `return` statements are commented out). The `ip link set` process timeout path logs a warning but also continues. None of these hardware-interaction failure paths are tested; the commented-out `return` statements suggest intentional silent continuation that has never been verified by test.
**Fix:** Stub filesystem and process interactions to simulate: (a) GPIO file open failure — assert that `m_powerOn` is still updated correctly and no crash occurs, (b) `ip link set` process timeout — assert the warning is emitted and the device connection attempt still proceeds.

---

**A13-12** · LOW · Missing Test Coverage — `GnssReceiver::portStateChanged()` Serial Port Open Failure
**File:** `platform/gnssreceiver.cpp:51`
**Description:** `portStateChanged(true)` calls `m_serialPort->open(QIODevice::ReadOnly)` and silently returns if it fails (`if (!m_serialPort->open(...)) return`). In the failure case, `m_timerId` is not started and `m_receiver` is not cleared, meaning the object remains in a partially-initialized state with no indication to the caller that the port failed to open. This path is not tested.
**Fix:** Add a test that simulates a serial port open failure and verifies: (a) no timer is started, (b) `m_receiver` is not cleared (state is preserved), (c) a subsequent call to `portStateChanged(false)` does not crash.

---

## 6. Summary Table

| ID | Severity | Category | File | Method / Area |
|----|----------|----------|------|---------------|
| A13-01 | HIGH | Missing Test — Error Path | `platform/canbus.cpp:274` | `handleError()` — no error injection, no signal spy |
| A13-02 | HIGH | Missing Test — Init Failure | `platform/canbus.cpp:34` | `initialize()` — device creation failure path |
| A13-03 | HIGH | Zero Test Coverage | `platform/gnssreceiver.cpp` / `.h` | Entire `GnssReceiver` class |
| A13-04 | HIGH | Missing Validation + Test | `platform/gnssreceiver.cpp:101` | `parseData()` — no NMEA checksum validation |
| A13-05 | MEDIUM | Missing Test — Logic | `platform/gnssreceiver.cpp:72` | `readData()` — fragmented input and carry buffer |
| A13-06 | MEDIUM | Missing Test — Edge Case | `platform/gnssreceiver.cpp:339` | `calculateDistance()` — overflow guards, anti-meridian |
| A13-07 | MEDIUM | Dangling Declaration | `platform/gnssreceiver.h:47` | `inPoly2()` declared, never defined |
| A13-08 | MEDIUM | Missing Test — Logic | `platform/gnssreceiver.cpp:428` | `pointInPolygon()` — boundary and edge cases |
| A13-09 | MEDIUM | Missing Test — Logic | `platform/canbus.cpp:224` | `applyFilters()` — extended-frame bit mask |
| A13-10 | MEDIUM | Missing Test — Logic | `platform/canbus.cpp:51` | `sendRequest()` — queue scheduling and duplicate suppression |
| A13-11 | LOW | Missing Test — Error Path | `platform/canbus.cpp:105` | `setPower()` — GPIO/process failure continuation |
| A13-12 | LOW | Missing Test — Error Path | `platform/gnssreceiver.cpp:51` | `portStateChanged()` — serial port open failure |

---

## 7. Overall Assessment

**CanBus (`platform/canbus.cpp`):** The single existing test (`test_vdiMode`) exercises `getRequests()` indirectly through the `CanMonitor` subsystem and verifies that VDI-mode configuration produces the expected frame structures. This covers approximately 10–15% of the class's logic. No direct-unit-level tests exist for any CanBus method. All error paths (bus-off, error-passive, write error, connection error, socket open failure, GPIO failure) are entirely untested.

**GnssReceiver (`platform/gnssreceiver.cpp`):** Test coverage is **0%**. The class processes raw NMEA serial data and maintains position, speed, course, distance, geofence state, and path waypoints — all of which are safety-relevant in a fleet vehicle telematics context. The complete absence of tests, combined with the missing NMEA checksum validation (A13-04) and the dangling `inPoly2()` declaration (A13-07), represent a significant quality and reliability risk.
# Audit Report – Agent A14
**Audit Run:** 2026-02-28-01
**Pass:** 2 – Test Coverage
**Agent:** A14
**Branch Confirmed:** master (verified via `git branch --show-current`)

---

## Files Under Review

| File | Lines |
|------|-------|
| `platform/internalrfid.cpp` | 113 |
| `platform/internalrfid.h` | 33 |
| `platform/internalrtc.cpp` | 41 |
| `platform/internalrtc.h` | 19 |

---

## Reading Evidence

### internalrfid.h – Class: `EM070::InternalRfid` (inherits QObject)

**Includes:**
- `<QObject>` (line 4)

**Public Methods:**
| Line | Method |
|------|--------|
| 14 | `explicit InternalRfid(QObject *parent = 0)` (constructor) |
| 15 | `void setEnabled(bool enabled)` |

**Signals:**
| Line | Signal |
|------|--------|
| 18 | `void response()` |
| 19 | `void cardData(quint64 wiegand, quint16 facility, quint32 number, QByteArray &readerOutput)` |
| 20 | `void error(const QString &text)` |

**Private Methods:**
| Line | Method |
|------|--------|
| 23 | `void readData()` |
| 24 | `void parseData()` |

---

### internalrfid.cpp – Implementation Detail

**Includes:**
- `internalrfid.h` (line 1)
- `wiegandrfid.h` (line 2)
- `<QSerialPort>` (line 3)
- `<QDebug>` (line 4)
- `seriallogger.h` (line 5)

**Key constants:**
- `FILE_SERIAL_PORT` = `"/dev/ttyS2"` (line 7); overridable via env var `QT_RFID_SERIAL_PORT`
- `RECEIVER_MAX_SIZE` = `128` (line 8)

**parseData logic (lines 67–111):**
- Format `#6:FFNN` → 26-bit Wiegand (facility 1 byte hex, card number 2 bytes hex)
- Format `#8:FFFFNNNN` → 34-bit Wiegand (facility 2 bytes hex, card number 2 bytes hex)
- Format `#R:<hex64>` → raw 64-bit Wiegand pass-through
- Fallback: any `ba.size() > 3` → emits `cardData(0, 0, 0, log)` (line 109)

---

### internalrtc.h – Class: `EM070::InternalRtc` (plain class, no QObject)

**Includes:**
- `<QDateTime>` (line 4)

**Public Static Methods:**
| Line | Method |
|------|--------|
| 11 | `static void setRtcTime(QDateTime dateTime = QDateTime())` |
| 12 | `static void setSystemTime()` |
| 13 | `static quint64 euiAddress()` |

---

### internalrtc.cpp – Implementation Detail

**Includes:**
- `internalrtc.h` (line 1)
- `<QFile>` (line 2)
- `<QProcess>` (line 3)

**Key constants:**
- `FILE_RTC_DEVICE` = `"/dev/rtc1"` (line 5)
- `FILE_RTC_EUI` = `"/sys/devices/platform/nuc970-i2c0/i2c-0/0-006f/eui"` (line 6)

**setRtcTime logic (lines 10–22):**
- Validates `dateTime.isValid()` before calling `::stime()` (ARM only)
- Always runs `hwclock -w -f /dev/rtc1` unconditionally via `QProcess::execute()`, regardless of validity
- `QProcess::execute()` return value is not checked

**euiAddress logic (lines 31–41):**
- Returns `0` on file-open failure with no error signal or log

---

## Test Coverage Search Results

### Search locations examined:
- `test/test_backgroundworker.cpp`
- `test/test_backgroundworker.h`
- `test/test_canbus.cpp`
- `test/test_canbus.h`
- `test/test_dialog.cpp`
- `test/test_dialog.h`
- `test/test_ota.cpp`
- `test/test_ota.h`
- `test/FleetIQ360App_5.2.2F.h`

### Search patterns used:
- `InternalRfid`, `internalrfid`, `InternalRtc`, `internalrtc`
- `setEnabled`, `parseData`, `readData`, `cardData`, `wiegand`, `WiegandRfid`
- `setRtcTime`, `setSystemTime`, `euiAddress`, `hwclock`, `rtc`
- `#6:`, `#8:`, `#R`, `AT+LFID`, `ttyS2`, `RECEIVER_MAX`
- `stime`, `hwclock`, `rtc1`, `FILE_RTC`

**Result: Zero matches found in any test file for any method, class name, signal, or constant from either file.**

---

## Findings

---

**A14-1** · CRITICAL · Missing Test Coverage – InternalRfid (Complete Absence)
**File:** `platform/internalrfid.cpp`
**Description:** The class `EM070::InternalRfid` has zero unit test coverage. No test file in `test/` references the class, any of its methods (`setEnabled`, `readData`, `parseData`), its signals (`cardData`, `error`, `response`), or any of the serial data format constants. This is a hardware-interfacing access control component: it parses raw RFID card reads and emits the card credential (`wiegand`, `facility`, `number`) that drives driver authentication. A defect in parsing logic is a direct authentication bypass risk. The complete lack of tests means regressions cannot be detected.
**Fix:** Create a `test_internalrfid.cpp` test suite that stubs `QSerialPort` (or uses the `QT_RFID_SERIAL_PORT` env-var override) and exercises `parseData()` directly, covering: valid `#6:` frame, valid `#8:` frame, valid `#R:` frame, malformed frames that should emit `error()`, the overflow guard (>128 bytes), and the zero-facility/zero-number guard.

---

**A14-2** · HIGH · No Test for Valid Card Read (cardData signal)
**File:** `platform/internalrfid.cpp`:83–94
**Description:** The primary success path – receiving a properly formatted `#6:` or `#8:` RFID frame and emitting `cardData` – is completely untested. The parsing extracts `facility` and `number` as hex substrings with hardcoded offsets and sizes (`ba.mid(3,2)`, `ba.mid(5,4)`, `ba.mid(3,4)`, `ba.mid(7,4)`). An off-by-one in these offsets would silently produce wrong credential values. Without a test verifying the emitted `wiegand`, `facility`, and `number` values, such defects are undetectable.
**Fix:** Add parameterised test cases feeding known byte arrays (e.g., `"#6:0A1234"`) into `parseData()` via a `QSignalSpy` on `cardData` and assert the decoded values match expected Wiegand output.

---

**A14-3** · HIGH · No Test for Invalid Card Format / Error Signal
**File:** `platform/internalrfid.cpp`:86–107
**Description:** The `error()` signal is emitted when `facility == 0`, `number == 0`, when `#R:` hex parse fails, or when the split produces fewer than two parts. None of these error paths are tested. Additionally, line 108–109 shows a catch-all: any `ba.size() > 3` that does not match a known prefix emits `cardData(0, 0, 0, log)` – this silently fabricates a zero-wiegand card-present event rather than emitting `error()`. This behavioural ambiguity (unknown data treated as a card swipe) is a logic defect that is invisible without tests.
**Fix:** Test that: (a) `#6:0000xx` emits `error()` not `cardData()`; (b) `#R:ZZZZ` (invalid hex) emits `error()`; (c) arbitrary garbage longer than 3 bytes emits `cardData(0,0,0,...)` and confirm this is the intended behaviour or change to `error()`.

---

**A14-4** · HIGH · No Test for Buffer Overflow Guard
**File:** `platform/internalrfid.cpp`:55–58
**Description:** The `readData()` method clears `m_receiver` when it exceeds `RECEIVER_MAX_SIZE` (128 bytes). This is the only defence against an unbounded accumulation of serial bytes. It is untested. If the guard fails or has an off-by-one, `m_receiver` will grow without bound, causing potential memory exhaustion on an embedded device. The guard also discards partial data silently without emitting `error()`.
**Fix:** Test by simulating incremental `readyRead` signals delivering 129+ bytes without a newline terminator and asserting `m_receiver` is cleared and no `cardData` is emitted.

---

**A14-5** · MEDIUM · No Test for No-Card / Empty Frame Conditions
**File:** `platform/internalrfid.cpp`:67–110
**Description:** The behaviour when the serial port delivers only `"OK\n"`, an empty line, or a line shorter than 4 bytes is untested. Lines containing only whitespace, after `trimmed()`, will be 0 bytes and fall through all conditions silently. The intent (suppress noise vs. signal an error) is not validated by any test.
**Fix:** Add tests for: `"OK\n"` (should emit only `response()`), `"\n"` (empty line, should emit nothing), `"XX\n"` (3 bytes or fewer, should emit nothing based on the `> 3` guard).

---

**A14-6** · MEDIUM · No Test for Simultaneous / Multi-Line Card Frames
**File:** `platform/internalrfid.cpp`:69
**Description:** `parseData()` splits `m_receiver` on `'\n'` and iterates all lines, meaning multiple RFID card records delivered in one serial read burst will all be processed. This multi-card-in-one-buffer path is untested. An interleaved delivery (e.g., last part of card A and first part of card B in one chunk) could produce malformed lines. Since `readData()` only calls `parseData()` when `m_receiver` ends with `'\n'`, partial frames from a prior card could precede the next card's frame without separator hygiene.
**Fix:** Test delivery of two complete `#6:` frames in a single `readAll()` burst and assert two `cardData` emissions with correct distinct values.

---

**A14-7** · CRITICAL · Missing Test Coverage – InternalRtc (Complete Absence)
**File:** `platform/internalrtc.cpp`
**Description:** The class `EM070::InternalRtc` has zero unit test coverage. No test file references the class or any of its three static methods (`setRtcTime`, `setSystemTime`, `euiAddress`). `setRtcTime` calls the POSIX `::stime()` syscall on ARM to set the system clock – a privileged, irreversible operation with real-time consequences. `euiAddress` reads a hardware EUI that is used to generate the device's MQTT client ID (`globalconfigs.cpp:162`). Defects in any of these functions have operational and identity-management impact that cannot be caught without tests.
**Fix:** Create `test_internalrtc.cpp`. Mock `QProcess::execute` and the EUI file path (use a temporary file) to make the tests host-runnable. Cover: valid datetime, invalid datetime (null default), `euiAddress` with a known hex file, and `euiAddress` with a missing file.

---

**A14-8** · HIGH · No Test for Invalid DateTime in setRtcTime
**File:** `platform/internalrtc.cpp`:10–22
**Description:** `setRtcTime()` accepts any `QDateTime`, and the only validation is `dateTime.isValid()`. There is no test confirming that an invalid `QDateTime` (month=0, day=32, null default, negative epoch, etc.) skips the `::stime()` call but still proceeds to execute `hwclock -w`. Because `hwclock -w` runs unconditionally regardless of `dateTime.isValid()`, passing an invalid datetime still writes whatever the current system time is to the RTC. This silent behaviour – writing on invalid input – is unintentional-looking and untested.
**Fix:** Add tests that: (a) pass `QDateTime()` (null/invalid) and assert `::stime()` is not called; (b) assert that `hwclock -w` is still invoked in that case and confirm this is intentional; (c) test boundary datetimes (epoch=0, far-future dates).

---

**A14-9** · HIGH · No Test for hwclock Return Value / Failure Path
**File:** `platform/internalrtc.cpp`:19–21, 24–28
**Description:** Both `setRtcTime()` and `setSystemTime()` call `QProcess::execute()` and completely ignore the return value. `QProcess::execute()` returns -2 if the process cannot start, -1 if it crashes, or the exit code of the process. A failure of `hwclock` (e.g., device `/dev/rtc1` not present, permissions error) is silently swallowed. No `error()` signal, no log, no return value. There is no test that simulates `hwclock` failure and verifies the caller is informed.
**Fix:** Check the return value of `QProcess::execute()` and log or signal on non-zero. Add a test that stubs the command to fail and verifies the failure is surfaced.

---

**A14-10** · MEDIUM · No Test for euiAddress File-Not-Found / Return Zero
**File:** `platform/internalrtc.cpp`:31–41
**Description:** When `/sys/devices/platform/nuc970-i2c0/i2c-0/0-006f/eui` cannot be opened, `euiAddress()` silently returns `0`. The caller in `globalconfigs.cpp:162` builds the string `"cii_0"` as the device MQTT client ID when EUI is unavailable. No test verifies this fallback, and no test verifies that a valid EUI hex file produces the correct `quint64` value. A parsing failure (e.g., file contains non-hex whitespace) would also return `0` silently because `toULongLong(nullptr, 16)` returns `0` on failure.
**Fix:** Create a temporary file with a known hex EUI string in the test, override the file path (via a refactor to accept the path or use a compile-time hook), and assert the returned value. Also test empty file and non-hex content.

---

**A14-11** · LOW · setEnabled Writes to Port Without Confirming Port Open State in Tests
**File:** `platform/internalrfid.cpp`:38–49
**Description:** `setEnabled()` guards against `!m_serialPort->isOpen()` but this guard is untested. If the constructor fails to open the serial port (e.g., `/dev/ttyS2` absent on a host test environment), `setEnabled()` silently does nothing. No test verifies that the early-return path is taken, and no test verifies that the `AT+LFID=ON/OFF` command is actually written when the port is open.
**Fix:** Test `setEnabled(true)` and `setEnabled(false)` with a mocked or loopback serial port and verify the written bytes. Test the no-op path when port is closed.

---

## Summary Table

| ID | Severity | Category | File | Covered in Tests? |
|----|----------|----------|------|-------------------|
| A14-1 | CRITICAL | Missing Coverage – InternalRfid | `platform/internalrfid.cpp` | No |
| A14-2 | HIGH | Valid Card Read (cardData signal) | `platform/internalrfid.cpp`:83–94 | No |
| A14-3 | HIGH | Invalid Card Format / Error Signal | `platform/internalrfid.cpp`:86–109 | No |
| A14-4 | HIGH | Buffer Overflow Guard | `platform/internalrfid.cpp`:55–58 | No |
| A14-5 | MEDIUM | No-Card / Empty Frame Conditions | `platform/internalrfid.cpp`:67–110 | No |
| A14-6 | MEDIUM | Multi-Line / Simultaneous Card Frames | `platform/internalrfid.cpp`:69 | No |
| A14-7 | CRITICAL | Missing Coverage – InternalRtc | `platform/internalrtc.cpp` | No |
| A14-8 | HIGH | Invalid DateTime in setRtcTime | `platform/internalrtc.cpp`:10–22 | No |
| A14-9 | HIGH | hwclock Return Value / Failure Path | `platform/internalrtc.cpp`:19–28 | No |
| A14-10 | MEDIUM | euiAddress File-Not-Found / Zero Return | `platform/internalrtc.cpp`:31–41 | No |
| A14-11 | LOW | setEnabled Without Port Open Confirmation | `platform/internalrfid.cpp`:38–49 | No |

**Total findings: 11**
**Critical: 2 | High: 5 | Medium: 3 | Low: 1**

---

## Overall Assessment

Both `InternalRfid` and `InternalRtc` have **zero test coverage**. These are not peripheral utility classes: `InternalRfid` is the internal card reader parser whose output directly drives driver authentication decisions, and `InternalRtc` manages the hardware real-time clock and generates the device's unique network identity (EUI). The complete absence of tests means:

1. Any regression in RFID card parsing (wrong byte offsets, wrong hex base, off-by-one in size checks) will silently produce wrong credentials or silent failures with no automated detection.
2. The `parseData()` catch-all at line 109 (`cardData(0,0,0,log)` for unrecognised frames) is a logic defect that masquerades unknown serial noise as a card-present event – only discoverable through tests.
3. `setRtcTime()` calls the privileged `::stime()` syscall with no boundary validation beyond `isValid()`, and then unconditionally runs `hwclock -w` even on invalid input, with no test catching this asymmetric behaviour.
4. `euiAddress()` returning `0` on file failure silently corrupts the device MQTT client ID to `"cii_0"`, which may cause identity collisions in a fleet context.

Recommended immediate action: introduce a `test_internalrfid.cpp` and `test_internalrtc.cpp` with full coverage of all paths described in findings A14-1 through A14-11.
# Audit Report – Agent A15 (Pass 2: Test Coverage)

**Agent ID:** A15
**Audit Run:** 2026-02-28-01
**Branch Confirmed:** master (verified via `git branch --show-current`)
**Pass:** 2 – Test Coverage

---

## Files Audited

| File | Path |
|------|------|
| ModemPort header | `platform/modemport.h` |
| ModemPort implementation | `platform/modemport.cpp` |
| PowerSupply header | `platform/powersupply.h` |
| PowerSupply implementation | `platform/powersupply.cpp` |

---

## Reading Evidence

### platform/modemport.h

**Includes:**
- `<QObject>` (line 4)
- `<QSerialPort>` (line 5)
- `<QTimer>` (line 6)

**Class:** `EM070::ModemPort` (line 10), inherits `QObject`

**Public methods:**
| Method | Line |
|--------|------|
| `explicit ModemPort(QObject *parent = nullptr)` | 14 |
| `bool sendCmd(const QByteArray &cmd)` | 15 |
| `void resetModem()` | 16 |
| `void setEnabled(bool enable)` | 17 |
| `void setEcho(bool enable)` | 18 (inline) |
| `bool isWwx()` | 19 (inline) |
| `void setWwx(bool isWwx)` | 20 (inline) |

**Signals:**
| Signal | Line |
|--------|------|
| `void portStateChanged(bool open)` | 23 |
| `void response(bool ok, const QByteArrayList &content)` | 24 |

**Private methods:**
| Method | Line |
|--------|------|
| `void openPort()` | 27 |
| `void portError()` | 28 |
| `void readData()` | 29 |
| `void parseData(const QByteArray &line)` | 30 |

**Private members:**
- `QSerialPort *m_serialPort` (line 32)
- `QTimer *m_timer` (line 33)
- `int m_tryTimes` (line 34)
- `QByteArray m_receiver` (line 35)
- `QByteArrayList m_response` (line 36)
- `QByteArray m_cmdLine` (line 37)
- `bool m_echo` (line 38)
- `bool m_wwx` (line 39)

---

### platform/modemport.cpp

**Includes:**
- `"modemport.h"` (line 1)
- `"seriallogger.h"` (line 2)
- `<QProcess>` (line 3)
- `<QDebug>` (line 4)
- `<QFile>` (line 5)

**Port name macros:**
- `FILE_MODEM_PORT_WWX` = `/dev/ttyUSB2` (line 7)
- `FILE_MODEM_PORT` = `/dev/ttyUSB3` (line 8)

**Key implementation notes:**
- Constructor reserves 256 bytes for `m_receiver` (line 19); no upper-bound enforcement on accumulation.
- Baud rate hard-coded to 115200 (line 35); not configurable via public API.
- `resetModem()` calls `QProcess::startDetached("/etc/pvd/mobile -r")` with no return-value check (line 61).
- `openPort()` increments `m_tryTimes` and calls `resetModem()` after 20 failures (line 93); no cap on total resets.
- `sendCmd()` returns `false` if port is closed (line 128) but does not check `QSerialPort::write()` return value (line 135).
- `readData()` parses line-by-line; partial lines accumulated in `m_receiver` with no size cap (line 165).
- `parseData()` emits `response(false, bal)` for unsolicited `+CGEV:` events (line 186); `response(result, m_response)` for all other terminal lines (line 208).

---

### platform/powersupply.h

**Includes:**
- `<QObject>` (line 4)
- `<QFile>` (line 5)
- Forward declarations: `QSocketNotifier`, `QTimer` (lines 7–8)

**Class:** `EM070::PowerSupply` (line 12), inherits `QObject`

**Enums:**
- `BlankMode`: `UnBlank`, `BlankPowerDown = 4` (line 16)
- `ChargeState`: `NotCharging`, `PreCharging`, `FastCharging`, `ChargeDone` (line 17)
- `ChargeFault`: `NoFault`, `InputFault`, `ThermalShutdown`, `ChargeTimerExpired` (line 18)

**Public methods:**
| Method | Line |
|--------|------|
| `explicit PowerSupply(QObject *parent = nullptr)` | 19 |
| `bool isIgnitionOn() const` | 21 (inline) |
| `bool isPowerGood() const` | 23 (inline) |
| `bool isBatteryAvailable() const` | 24 (inline) |
| `ChargeState chargeState() const` | 25 (inline) |
| `ChargeFault chargeFault() const` | 26 (inline) |
| `quint16 voltage() const` | 27 (inline) |
| `qint16 current() const` | 28 (inline) |
| `quint16 temperature() const` | 29 (inline) |
| `quint16 remainingCapacity() const` | 30 (inline) |
| `quint16 designCapacity() const` | 31 (inline) |
| `quint16 timeToEmpty() const` | 32 (inline) |
| `quint16 timeToFull() const` | 33 (inline) |
| `static void reboot()` | 35 |
| `static void poweroff()` | 36 |
| `static void setBlankMode(BlankMode mode)` | 37 |
| `static void setTouchPower(bool on)` | 38 |
| `static void charge(bool enable)` | 39 |
| `static void setBatteryEnabled(bool enable)` | 40 |

**Signals:**
| Signal | Line |
|--------|------|
| `void ignitionStateChanged(bool on)` | 43 |
| `void batteryStatusRead(bool avail, int state, int fault, quint16 voltage, qint16 current, quint16 temp, quint16 remainingCapacity)` | 44 |

**Private methods:**
| Method | Line |
|--------|------|
| `void readIgnitionState()` | 47 |
| `void readChargerStatus()` | 48 |
| `void readGaugeStatus()` | 49 |

---

### platform/powersupply.cpp

**Includes:**
- `"powersupply.h"` (line 1)
- `<QEventLoop>` (line 2)
- `<QProcess>` (line 3)
- `<QSocketNotifier>` (line 4)
- `<QTimer>` (line 5)
- `<QDebug>` (line 6)

**Key implementation notes:**
- Constructor fails silently if ignition file cannot be opened: `m_notifier` is left uninitialised and the method returns early (lines 40–43).
- `readGaugeStatus()` calls `args[0]` through `args[6]` without checking that `args.size() >= 7` (lines 145–174). A malformed or short sysfs line causes undefined behaviour via out-of-bounds `QByteArrayList` access.
- Charge control logic in `readGaugeStatus()`: voltage threshold is < 4100 mV or remainingCapacity < 99 (line 148); upper threshold is > 4300 mV (line 150). No test validates these thresholds.
- `readIgnitionState()` inverts the GPIO active-low logic explicitly (line 57); no test verifies the polarity.
- `reboot()` and `poweroff()` both shell out to `/etc/pvd/reboot` via `QProcess::execute()` (lines 205, 211); no return value checked.
- `readGaugeStatus()` calls `m_timer->start(QUERY_INTERVAL)` (line 178) as well as `readChargerStatus()` calling it again (line 120), meaning the timer is started twice per polling cycle but this is benign since `QTimer::start` restarts the timer.

---

## Test Coverage – Findings

### Test suite inventory

The `test/` directory contains:
- `test_backgroundworker.cpp` / `.h`
- `test_canbus.cpp` / `.h`
- `test_dialog.cpp` / `.h`
- `test_ota.cpp` / `.h`

**Result of grep for `ModemPort`, `PowerSupply`, and all method names across `test/`:**
- Zero matches for `ModemPort` or any of its methods.
- Zero matches for `PowerSupply` or any of its methods.
- `BackgroundWorker` instantiates `PowerSupply` internally (confirmed in `app/backgroundworker.cpp` line 270) and constructs `ModemPort` lazily (line 2700), but no test exercises these objects' own logic or verifies their signals.

**Conclusion: Neither `ModemPort` nor `PowerSupply` has any direct or indirect unit-test coverage.**

---

## Findings

---

**A15-1** · HIGH · Missing Test Coverage – ModemPort (entire class)
**File:** `platform/modemport.cpp:1` / `platform/modemport.h:1`
**Description:** The `ModemPort` class has zero test coverage. No test in `test/` instantiates, stubs, or exercises `ModemPort`. This class manages the physical serial link to the cellular modem: it controls port open/close lifecycle, sends AT commands, handles port errors, and emits `portStateChanged` and `response` signals that drive the rest of the communication stack. None of these paths are exercised by any automated test.
**Fix:** Create a `test_modemport.cpp` test suite. Use `QT_MOBILE_SERIAL_PORT` (already honoured at constructor line 22) to redirect the port to a null device or a `QSerialPort` mock. At minimum, test: (1) constructor initialises baud rate and port name from env variable; (2) `sendCmd()` returns false when port is closed; (3) `portStateChanged(false)` is emitted on `portError()`; (4) `response(true, ...)` is emitted after a valid OK response; (5) `response(false, ...)` is emitted on ERROR/+CME ERROR.

---

**A15-2** · HIGH · Missing Test Coverage – PowerSupply (entire class)
**File:** `platform/powersupply.cpp:1` / `platform/powersupply.h:1`
**Description:** The `PowerSupply` class has zero test coverage. The class drives ignition detection, battery voltage/capacity monitoring, charge control decisions, and the `ignitionStateChanged` and `batteryStatusRead` signals. Both signals directly affect application-level power management and UI updates in `BackgroundWorker`. No test validates their emission, their content, or any of the threshold logic.
**Fix:** Create a `test_powersupply.cpp` test suite. Abstract sysfs file paths behind a configurable base directory or dependency-inject `QFile` sources so tests can provide synthetic data. At minimum, test: (1) `ignitionStateChanged(true)` emitted when GPIO file reads `0` (active-low, line 57); (2) `batteryStatusRead` emitted with correct voltage from a synthetic gauge register file; (3) charge enable/disable triggered by voltage crossing 4100 mV and 4300 mV thresholds (lines 148–151).

---

**A15-3** · HIGH · Undefined Behaviour – Unchecked Array Index in `readGaugeStatus()`
**File:** `platform/powersupply.cpp:143-174`
**Description:** After splitting the gauge register line on commas (`args = ba.split(',')`, line 143), the code directly accesses `args[0]` through `args[6]` without any bounds check. If the sysfs file `/sys/devices/platform/nuc970-i2c0/i2c-0/0-0055/show_regs` returns a line with fewer than seven comma-separated fields (e.g., due to a driver error, a race during read, or device absence), this produces an out-of-bounds `QByteArrayList` access. In Qt's `QList`, operator[] on an out-of-range index is undefined behaviour and will typically crash in a release build.
**Fix:** Add a guard immediately after line 143: `if (args.size() < 7) return;`. Add a unit test that feeds a truncated sysfs line and verifies the function returns without modifying any member state.

---

**A15-4** · MEDIUM · Missing Test – Serial Write Return Value Ignored in `sendCmd()`
**File:** `platform/modemport.cpp:135`
**Description:** `sendCmd()` calls `m_serialPort->write(cmd + "\r\n")` but discards the `qint64` return value. `QSerialPort::write()` can return -1 on error (e.g., the device was removed between the `isOpen()` check at line 127 and the write at line 135). The caller receives `true` even when no bytes were transmitted, silently losing the command. No test exercises this TOCTOU window.
**Fix:** Capture the return value of `write()` and return `false` (or emit an error signal) if it is -1. Add a test that simulates a write failure and verifies `sendCmd()` returns `false`.

---

**A15-5** · MEDIUM · Missing Test – `m_receiver` Buffer Has No Maximum Size Cap
**File:** `platform/modemport.cpp:19` / `platform/modemport.cpp:165`
**Description:** `m_receiver` is pre-reserved to 256 bytes (line 19) but `QByteArray::reserve()` does not enforce a hard limit; Qt will reallocate on demand. If the modem sends data with no newline terminator (e.g., a binary blob, a stuck transmission, or a framing error), `m_receiver` will grow without bound until the process exhausts memory or the port is closed. No test verifies behaviour under oversized input.
**Fix:** Add a guard in `readData()` before appending to `m_receiver` (line 165): if `m_receiver.size()` exceeds a safe threshold (e.g., 4096 bytes), clear `m_receiver` and log a warning. Add a test that injects a stream of data with no newlines and verifies the receiver does not grow unboundedly and that the port recovers.

---

**A15-6** · MEDIUM · Missing Test – `PowerSupply` Constructor Silent Failure
**File:** `platform/powersupply.cpp:40-43`
**Description:** If the ignition GPIO file cannot be opened, the constructor logs a critical message and returns immediately. `m_notifier` is never initialised (`new QSocketNotifier(...)` at line 45 is never reached), so the pointer is uninitialised. Callers that subsequently call `isIgnitionOn()` get the default `false` value with no indication of the failure, and `ignitionStateChanged` is never emitted. No test covers this failure path.
**Fix:** Initialise `m_notifier` to `nullptr` in the member initialiser list and add a public `bool isValid() const` accessor. Add a test that constructs `PowerSupply` when the ignition file does not exist and verifies `isValid()` returns `false` and no crash occurs.

---

**A15-7** · MEDIUM · Missing Test – Ignition GPIO Active-Low Polarity Logic
**File:** `platform/powersupply.cpp:57`
**Description:** The ignition state is derived from an active-low GPIO: `m_ignitionOn = ba.toInt() ? false : true`. This inversion means a file value of `"0"` signals ignition ON, and `"1"` signals ignition OFF. This is a non-obvious mapping that is easy to break in future maintenance. No test verifies that the correct `ignitionStateChanged` argument is emitted for each GPIO value.
**Fix:** Add parameterised tests: when the GPIO file contains `"0"`, verify `ignitionStateChanged(true)` is emitted; when it contains `"1"`, verify `ignitionStateChanged(false)` is emitted.

---

**A15-8** · LOW · Missing Test – `resetModem()` Invokes Detached Process with No Verification
**File:** `platform/modemport.cpp:61`
**Description:** `resetModem()` calls `QProcess::startDetached("/etc/pvd/mobile -r")` with no return-value check. If the binary does not exist or is not executable, the reset silently fails and the timer is restarted (line 65), which can cause repeated failed reset attempts with no observable side-effect. No test covers this path.
**Fix:** Capture the `bool` return value of `QProcess::startDetached()` and emit an appropriate signal or log a warning on failure. Add a test that simulates the absence of the reset binary and verifies the class continues to function (e.g., timer restarts).

---

**A15-9** · LOW · Missing Test – Charge Threshold Boundary Values
**File:** `platform/powersupply.cpp:148-151`
**Description:** `readGaugeStatus()` enables charging when `m_voltage < 4100` or `m_remainingCapacity < 99`, and disables it when `m_voltage > 4300` or `m_remainingCapacity == 100`. The boundary values (exactly 4100, 4300, 99, 100) are untested, leaving the hysteresis behaviour unverified. A regression in the threshold logic could cause excessive charge cycling or failure to charge.
**Fix:** Add unit tests for boundary values: voltage = 4099, 4100, 4101, 4300, 4301 and capacity = 98, 99, 100, verifying that `charge(true)` or `charge(false)` is called with the correct argument in each case.

---

## Summary Table

| ID | Severity | Category | File | Description |
|----|----------|----------|------|-------------|
| A15-1 | HIGH | Missing Test Coverage | `platform/modemport.cpp` | Entire `ModemPort` class has zero test coverage |
| A15-2 | HIGH | Missing Test Coverage | `platform/powersupply.cpp` | Entire `PowerSupply` class has zero test coverage |
| A15-3 | HIGH | Undefined Behaviour | `platform/powersupply.cpp:143-174` | `readGaugeStatus()` accesses `args[0..6]` without bounds check |
| A15-4 | MEDIUM | Missing Test / Error Handling | `platform/modemport.cpp:135` | `write()` return value ignored in `sendCmd()` |
| A15-5 | MEDIUM | Missing Test / Resource Safety | `platform/modemport.cpp:165` | `m_receiver` accumulation has no upper-bound cap |
| A15-6 | MEDIUM | Missing Test / Silent Failure | `platform/powersupply.cpp:40-43` | Constructor silently fails if ignition file cannot be opened |
| A15-7 | MEDIUM | Missing Test / Logic Correctness | `platform/powersupply.cpp:57` | Active-low ignition polarity inversion is untested |
| A15-8 | LOW | Missing Test / Error Handling | `platform/modemport.cpp:61` | `QProcess::startDetached()` return value not checked in `resetModem()` |
| A15-9 | LOW | Missing Test / Boundary | `platform/powersupply.cpp:148-151` | Charge enable/disable threshold boundary values are untested |

---

*End of Agent A15 Report*
# Audit Report – Agent A16 (Pass 2: Test Coverage)

**Audit run:** 2026-02-28-01
**Agent:** A16
**Pass:** 2 – Test Coverage
**Branch confirmed:** master (verified via `git branch --show-current`)

---

## Files Under Review

| # | File |
|---|------|
| 1 | `platform/pwmbacklight.h` |
| 2 | `platform/pwmbacklight.cpp` |
| 3 | `platform/pwmbeeper.h` |
| 4 | `platform/pwmbeeper.cpp` |
| 5 | `platform/seriallogger.h` |
| 6 | `platform/seriallogger.cpp` |

---

## Reading Evidence

### platform/pwmbacklight.h

**Includes:** `<QObject>`, `<QFile>`, `<QQueue>`, `<QMap>`

**Note:** Header guard mismatch — `#ifndef PWMBACKLIGHT_H` on line 1 but `#define BRIGHTNESS_H` on line 2 (macro name is `BRIGHTNESS_H`, not `PWMBACKLIGHT_H`). This means double-include protection is broken.

**Enum:**
- `State {NoChange, Brighter, Darker}` (line 15)

**Public methods:**
| Line | Signature |
|------|-----------|
| 16 | `explicit PwmBacklight(QObject *parent = nullptr)` |
| 17 | `~PwmBacklight()` |
| 18 | `void setAutoBrightness(bool enable)` |
| 19 | `bool isAutoBrightness() const` (inline) |
| 21 | `static quint8 brightness()` |
| 22 | `static void setBrightness(quint8 val)` |

**Signals:**
| Line | Signature |
|------|-----------|
| 25 | `void luxRead(int lux)` |

**Protected:**
| Line | Signature |
|------|-----------|
| 28 | `void timerEvent(QTimerEvent *)` |

**Private methods:**
| Line | Signature |
|------|-----------|
| 31 | `void parse(int lux)` |
| 32 | `void adjust(int lux)` |
| 33 | `int readLux()` |

---

### platform/pwmbacklight.cpp

**Includes:** `"pwmbacklight.h"`, `<QTimerEvent>`, `<QFile>`, `<QDebug>`

**Sysfs paths used:**
- `FILE_BRIGHTNESS` = `/sys/devices/platform/pwm-backlight.0/backlight/pwm-backlight.0/brightness` (line 6)
- `FILE_ALS_POWER`  = `/sys/devices/platform/nuc970-i2c0/i2c-0/0-0044/power_state` (line 7)
- `FILE_ALS_RANGE`  = `/sys/devices/platform/nuc970-i2c0/i2c-0/0-0044/range` (line 8)
- `FILE_ALS_LUX`    = `/sys/devices/platform/nuc970-i2c0/i2c-0/0-0044/lux` (line 9)

**Notable logic:**
- `brightness()` (line 179): opens `FILE_BRIGHTNESS` read-only; returns `255` on open failure instead of an error sentinel (line 184).
- `setBrightness(quint8 val)` (line 191): opens `FILE_BRIGHTNESS` write-only; silently returns (no error propagation) on failure (line 196); does not flush after write (line 200).
- `adjust(int lux)` (line 173): calls `m_brightnessMap.upperBound(lux).value()` (line 175). When `lux` exceeds all keys the iterator is `end()` and `.value()` is undefined behaviour.
- `readLux()` returns `0` for negative values (line 80), valid for hardware but silently masks sensor errors.
- `parse()` macro `X1P1` / `X1P2` use `333 >> 8 = 1.30` not `1.1` / `1.2` — commented-out correct constants indicate deliberate deviation but no test verifies threshold behaviour.

---

### platform/pwmbeeper.h

**Includes:** `<QObject>`, `<QFile>`; forward-declares `QTimer`

**Enum:**
- `BeepType {BeepOn, BeepSilent, BeepOff}` (line 15) — declared but never used anywhere in the file or implementation.

**Public methods:**
| Line | Signature |
|------|-----------|
| 18 | `explicit PwmBeeper(bool autoDelete = false, QObject *parent = nullptr)` |
| 19 | `~PwmBeeper()` |
| 20 | `void setFrequency(quint16 frequency)` (inline) |
| 21 | `void beep(quint16 milliseconds)` |
| 22 | `void beep(quint16 frequency, quint16 milliseconds)` |
| 23 | `void beep(qint16 count, quint16 msecOn, quint16 msecOff)` |
| 24 | `void stop()` |

**Private methods:**
| Line | Signature |
|------|-----------|
| 27 | `void timeout()` |
| 28 | `void setBeep(bool on)` |

---

### platform/pwmbeeper.cpp

**Includes:** `"pwmbeeper.h"`, conditionally `<linux/input.h>` (ARM only), `<QTimer>`, `<QDebug>`

**Device path:** `FILE_BEEPER` = `/dev/input/event3` (line 8); overridable via `QT_BUZZER_EVENT` env var (lines 19–23).

**Notable logic:**
- `setBeep(bool on)` (lines 60–82): hardware write is conditionally compiled under `#ifdef __arm__` (lines 65–79). On non-ARM platforms the function only flips `m_beeping` without any I/O.
- `m_file.write()` result is discarded on line 77; flush is called but write error is never checked.
- `beep(qint16 count, ...)` (line 95): `count = 0` is accepted and stored; `m_count` is decremented in `timeout()` (line 53) reaching −1, at which point `if (--m_count > 0)` is false and `deleteLater()` may be called prematurely. Negative `count` wraps `qint16` down through 32 768 repetitions.
- Constructor fails silently if `m_file.open` fails (lines 25–28); callers receive no indication.

---

### platform/seriallogger.h

**Includes:** `"userport.h"`

**Public methods:**
| Line | Signature |
|------|-----------|
| 9  | `static void log(const QByteArray &message)` |
| 10 | `static void setSerialPort(EM070::UserPort *serial)` |

**Private static member:**
- `static EM070::UserPort *m_serial` (line 13)

---

### platform/seriallogger.cpp

**Includes:** `"seriallogger.h"`, `<QDateTime>`, `<QFile>`

**Preprocessor:**
- `ENABLE_SL_FILE 0` (line 5) — file-based logging is **permanently compiled out**.
- `SERIAL_LOG_FILE` = `/mnt/sd/sl.log` (line 6) — dead constant.

**Notable logic:**
- `log()` (line 15): if `m_serial` is null, silently returns without logging (lines 32–33).
- File logging block (lines 18–29) is guarded by `#if ENABLE_SL_FILE` which evaluates to `0`; the static `QFile` inside the block is never constructed, rotation and flush logic are permanently disabled.
- `m_serial->response(ba)` (line 35): return value is discarded; no error path if the serial port write fails.
- No thread-safety mechanism on the static `m_serial` pointer; simultaneous calls from multiple threads could read a torn pointer.

---

## Test Coverage Search Results

**Search performed:** grep for `PwmBacklight`, `PwmBeeper`, `SerialLogger`, `setBrightness`, `brightness`, `setAutoBrightness`, `readLux`, `setBeep`, `beep`, `setFrequency`, `seriallogger`, `pwmbacklight`, `pwmbeeper` (case-insensitive) across the entire `test/` directory.

**Result: zero matches.**

Test files present in `test/`:
- `test_backgroundworker.cpp` / `.h`
- `test_canbus.cpp` / `.h`
- `test_dialog.cpp` / `.h`
- `test_ota.cpp` / `.h`

All four test suites target `BackgroundWorker`, CAN bus, dialog UI, and OTA. None include or reference any of the three platform modules under review. `Makefile.test` confirms the source files are compiled into the test binary but no `QTEST_*` or manual test function references any symbol from these modules.

**Test coverage: 0% for all three classes.**

---

## Findings

---

**A16-1** · HIGH · Missing Test Coverage – Hardware Write Path (PwmBacklight)
**File:** `platform/pwmbacklight.cpp:191-201`
**Description:** `setBrightness()` writes directly to the sysfs brightness node. There is no test that verifies the correct value is written, that the file is opened with the expected flags, or that the function handles an open failure gracefully. On the target hardware this controls display backlight; a silent failure leaves the display in an unknown state.
**Fix:** Add a unit test using a QTemporaryFile or a mock QFile to inject a fake brightness sysfs path (via a settable path variable or dependency injection). Assert that the byte representation of the supplied `quint8` value is written, and verify the no-open path does not crash or write stale data.

---

**A16-2** · HIGH · Missing Test Coverage – Undefined Behaviour on Lux Exceeding Map Maximum (PwmBacklight)
**File:** `platform/pwmbacklight.cpp:175`
**Description:** `adjust(int lux)` calls `m_brightnessMap.upperBound(lux).value()`. The brightness map contains exactly two entries (`100 → 1`, `4000 → 255`). If `lux` is greater than `4000`, `upperBound` returns `end()` and calling `.value()` on `end()` is undefined behaviour in Qt's QMap. This can corrupt the brightness register or crash the process. No test verifies behaviour at or above the maximum lux value.
**Fix:** Add a guard in `adjust()` to clamp the iterator before dereferencing (e.g., use `--it` when `it == end()`), or use the last value explicitly. Add unit tests for `lux = 4001` and `lux = INT_MAX` to confirm safe clamping.

---

**A16-3** · HIGH · Missing Test Coverage – Hardware Write Path (PwmBeeper)
**File:** `platform/pwmbeeper.cpp:60-82`
**Description:** `setBeep()` performs a raw `m_file.write()` of a `struct input_event` to `/dev/input/event3`. No test verifies the structure is correctly populated (type, code, value), the write reaches the device, or that a write failure is detected. The return value of `write()` is unconditionally discarded.
**Fix:** Extract the device path to a configurable member (it already uses `QT_BUZZER_EVENT` env var). Add tests that set that env var to a temporary file, invoke `beep()`, and assert the binary content written matches the expected `input_event` layout for both on and off transitions.

---

**A16-4** · MEDIUM · Missing Test Coverage – Zero and Negative Beep Count Edge Cases (PwmBeeper)
**File:** `platform/pwmbeeper.cpp:95-110` and `platform/pwmbeeper.cpp:44-57`
**Description:** `beep(qint16 count, ...)` accepts `count = 0`: the beeper is switched on immediately and `m_timerOn` fires, decrementing `m_count` to `−1`, which is not `> 0`, so the beep cycle ends but no incorrect sequence is observable. However, a negative `count` is accepted without validation; the signed decrement will cycle through the full `qint16` range (32 767 additional iterations), holding the beeper on far longer than intended. No test exercises these edge cases.
**Fix:** Add a guard in `beep(qint16 count, ...)` that treats `count <= 0` as a no-op (or documents and enforces minimum `count = 1`). Add unit tests for `count = 0`, `count = -1`, and `count = 1` to assert correct on/off timing and `deleteLater` invocation with `autoDelete = true`.

---

**A16-5** · MEDIUM · Missing Test Coverage – SerialLogger Write and Null Port Handling
**File:** `platform/seriallogger.cpp:15-36`
**Description:** `SerialLogger::log()` silently discards the message when `m_serial` is null. No test verifies that: (a) messages are forwarded when a port is set, (b) messages are silently dropped when no port is set, or (c) the timestamp prefix is correctly formatted. The return value of `m_serial->response()` is also discarded with no error path tested.
**Fix:** Add unit tests that (1) call `log()` with `m_serial = nullptr` and verify no crash, (2) set a mock `UserPort`, call `log()`, and assert the captured output contains the expected millisecond timestamp prefix and the supplied message bytes.

---

**A16-6** · MEDIUM · Missing Test Coverage – File-Based Log Path is Dead Code (SerialLogger)
**File:** `platform/seriallogger.cpp:5-6` and `platform/seriallogger.cpp:18-29`
**Description:** `ENABLE_SL_FILE` is hardcoded to `0`. The entire file-based logging block — including the static `QFile` open, write, flush, and implicitly any rotation that would be needed — is permanently compiled out. The dead constant `SERIAL_LOG_FILE = "/mnt/sd/sl.log"` remains in the source. If file logging is ever re-enabled there is no test to verify the file is created, written correctly, flushed, or handled when the SD card path is unavailable.
**Fix:** Either remove the dead block and the constant entirely (if file logging is permanently abandoned), or re-enable it under a runtime flag and add tests covering: successful write to a temp path, write when the path does not exist, and verification that `flush()` is called after each write.

---

**A16-7** · MEDIUM · Missing Test Coverage – sysfs Open Failure Return Sentinel (PwmBacklight)
**File:** `platform/pwmbacklight.cpp:179-188`
**Description:** `brightness()` returns `255` when the sysfs brightness file cannot be opened. `255` is also a valid maximum brightness value. A caller cannot distinguish "hardware at maximum brightness" from "file open failed." No test exercises the failure path or asserts the return value.
**Fix:** Change the failure sentinel to a value outside the valid range (e.g., return a `std::optional<quint8>` or use a separate error output parameter), and add a unit test that supplies a non-existent file path and asserts the expected error indicator is returned.

---

**A16-8** · MEDIUM · Missing Test Coverage – PwmBacklight Constructor Sysfs Failures
**File:** `platform/pwmbacklight.cpp:22-64`
**Description:** The constructor opens four sysfs paths in sequence. If any of the first three (`FILE_ALS_RANGE`, `FILE_ALS_POWER`, `FILE_ALS_LUX`) fail to open, the constructor returns early with the object partially initialised. Subsequent calls to `setAutoBrightness(true)` guard on `m_alsLuxFile.isOpen()` and silently do nothing, but no test verifies this partial-init behaviour or asserts that the object remains safe to destroy.
**Fix:** Add tests that supply a non-existent `FILE_ALS_LUX` path, construct a `PwmBacklight`, call `setAutoBrightness(true)`, and verify the call is a no-op without crash. Also verify that the destructor on a partially-initialised object does not double-close files.

---

**A16-9** · MEDIUM · Missing Test Coverage – PwmBeeper Constructor File Open Failure
**File:** `platform/pwmbeeper.cpp:25-28`
**Description:** If `m_file.open(QIODevice::ReadWrite)` fails, the constructor logs a critical message and returns, leaving `m_file` closed. All subsequent `beep()` calls check `m_file.isOpen()` and silently return. However, `autoDelete` logic in the failed `beep()` path (line 98–99) calls `deleteLater()` on the object from within its own `beep()` call which may surprise callers who hold the pointer. No test exercises this code path.
**Fix:** Test construction with an invalid device path (e.g., `QT_BUZZER_EVENT=/nonexistent`), call `beep()`, and assert no crash; also assert that if `autoDelete = true` the object schedules deletion rather than calling it synchronously.

---

**A16-10** · LOW · Broken Header Include Guard (PwmBacklight)
**File:** `platform/pwmbacklight.h:1-2`
**Description:** The header guard opens with `#ifndef PWMBACKLIGHT_H` but defines `BRIGHTNESS_H`. The guard never actually fires: a second inclusion of `pwmbacklight.h` in a translation unit will pass the `#ifndef PWMBACKLIGHT_H` check (since that macro was never defined) and re-declare the class, causing a compiler error. No test exercises multi-inclusion scenarios.
**Fix:** Change line 2 to `#define PWMBACKLIGHT_H` to match the guard name on line 1. Add a compile-time test (or a CI step) that includes the header twice in the same translation unit to confirm idempotency.

---

**A16-11** · LOW · Unused Enum `BeepType` (PwmBeeper)
**File:** `platform/pwmbeeper.h:15`
**Description:** The public enum `BeepType {BeepOn, BeepSilent, BeepOff}` is declared but never referenced anywhere in the implementation, tests, or call sites found in the repository. Dead public API in a hardware driver creates confusion about intended interface.
**Fix:** Either implement `BeepType` as the parameter type for the `beep()` overloads (replacing the raw boolean `setBeep()` parameter), or remove the enum. Add a test that verifies `BeepSilent` maps to the expected hardware behaviour if the enum is kept.

---

**A16-12** · LOW · Missing Test Coverage – `luxRead` Signal Emission (PwmBacklight)
**File:** `platform/pwmbacklight.cpp:101`
**Description:** `timerEvent()` emits `luxRead(lux)` on every polling interval. No test uses `QSignalSpy` to verify the signal is emitted with the correct lux value, or that it is not emitted when auto-brightness is disabled.
**Fix:** Add a `QSignalSpy` test that enables auto-brightness, processes a timer event (or advances the timer in a test event loop), and asserts `luxRead` is emitted with the expected value.

---

## Summary Table

| ID | Severity | Category | File | Description |
|----|----------|----------|------|-------------|
| A16-1 | HIGH | Missing Test – Hardware Write | `pwmbacklight.cpp:191` | `setBrightness()` sysfs write never tested |
| A16-2 | HIGH | Missing Test – UB / Edge Case | `pwmbacklight.cpp:175` | `upperBound` past-end dereference on lux > 4000 |
| A16-3 | HIGH | Missing Test – Hardware Write | `pwmbeeper.cpp:77` | `input_event` sysfs write never tested |
| A16-4 | MEDIUM | Missing Test – Edge Case | `pwmbeeper.cpp:95` | Zero/negative beep count causes runaway loop |
| A16-5 | MEDIUM | Missing Test – Null Guard | `seriallogger.cpp:32` | Null serial port silent drop never tested |
| A16-6 | MEDIUM | Missing Test – Dead Code | `seriallogger.cpp:18` | File logging permanently disabled, never tested |
| A16-7 | MEDIUM | Missing Test – Sentinel Ambiguity | `pwmbacklight.cpp:184` | `brightness()` failure returns `255` (valid value) |
| A16-8 | MEDIUM | Missing Test – Partial Init | `pwmbacklight.cpp:22` | Partial constructor init on sysfs open failures |
| A16-9 | MEDIUM | Missing Test – File Open Failure | `pwmbeeper.cpp:25` | Constructor open failure + `autoDelete` path untested |
| A16-10 | LOW | Defect – Header Guard | `pwmbacklight.h:2` | Guard macro name mismatch breaks double-include protection |
| A16-11 | LOW | Dead Code | `pwmbeeper.h:15` | Unused `BeepType` enum in public API |
| A16-12 | LOW | Missing Test – Signal | `pwmbacklight.cpp:101` | `luxRead` signal emission never verified with spy |

**Total findings: 12**
- HIGH: 3
- MEDIUM: 6
- LOW: 3
# Audit Report — Agent A17 (Pass 2: Test Coverage)

**Audit run:** 2026-02-28-01
**Agent:** A17
**Pass:** 2 — Test Coverage
**Branch confirmed:** master (verified via `git branch --show-current`)

---

## Assigned Files

| File | Lines |
|------|-------|
| `platform/userport.h` | 32 |
| `platform/userport.cpp` | 91 |
| `platform/wiegandrfid.h` | 32 |
| `platform/wiegandrfid.cpp` | 167 |
| `platform/wifi.h` | 74 |
| `platform/wifi.cpp` | 300 |

---

## Reading Evidence

### platform/userport.h

**Class:** `EM070::UserPort` (inherits `QObject`)

| Symbol | Kind | Line |
|--------|------|------|
| `UserPort(QObject *parent = nullptr)` | public constructor | 15 |
| `response(const QByteArray &ba)` | public method | 16 |
| `setBaudRate(QSerialPort::BaudRate baudRate)` | public method | 18 |
| `cmdReceived(const QByteArray &ba)` | signal | 21 |
| `readData()` | private slot (connected via `readyRead`) | 24 |

**Includes:** `<QObject>`, `<QSerialPort>`

**Behaviour notes:**
- Constructor opens `/dev/ttyS1` (ARM) or `COM2` (non-ARM) via `QSerialPort::open(ReadWrite)`.
- On open failure (line 34-37): logs `qCritical`, returns silently — port is left closed, no signal emitted.
- `readData()` (line 54-76): accumulates characters; emits `cmdReceived` on CR/LF; handles backspace; echoes characters back to serial port when RS-232 accessory is not active.
- `response()` (line 78-86): writes only if port `isOpen()` — safe guard present, but no error signal on write-to-closed-port.
- `setBaudRate()` (line 88-91): forwards directly to `QSerialPort` with no open-check guard.
- `TEST_MODE == 1` wires stdin as a substitute data source.

---

### platform/wiegandrfid.h

**Class:** `EM070::WiegandRfid` (inherits `QObject`)

| Symbol | Kind | Line |
|--------|------|------|
| `WiegandRfid(QObject *parent = 0)` | public constructor | 14 |
| `setEnabled(bool enable)` | public method | 15 |
| `wiegandData(quint8 facility, quint32 number)` | public static method | 17 |
| `cardData(quint64, quint16, quint32, QByteArray&)` | signal | 20 |
| `error(const QString &text)` | signal | 21 |
| `activated()` | private slot | 24 |

**Includes:** `<QFile>`, forward decl `QSocketNotifier`

**Behaviour notes (wiegandrfid.cpp):**
- Reads three sysfs files: `card_ready`, `card_data`, `raw_data`.
- `activated()` (line 24-104): full dispatch pipeline.
  - Reads `card_data` as `"facility,number"` CSV; if both non-zero emits `cardData` (Wiegand-26/42 path).
  - Falls through to `raw_data` as `"bits,wiegand"` CSV.
  - 34-bit path (lines 67-80): strips outer parity bit, right-shifts, extracts facility (bits 16-23) and number (bits 0-15).
  - 37-bit path (lines 83-96): fully commented out — no runtime support.
  - Falls through to `bits >= 26` path (lines 98-101): emits `cardData(wiegand, 0, 0, ba)` with zero facility/number.
  - Always emits `error(ba)` after the `>= 26` path (line 103) — even when a card was successfully processed by that block.
- `wiegandData()` (lines 111-166): encodes Wiegand-26 or Wiegand-42 with parity.
  - For `number > 99999`: emits `qCritical` and returns 0 without an `error` signal.
- Constructor: on `card_ready` open failure (line 15-18): logs `qCritical`, returns — `m_notifier` is never initialised; `setEnabled()` will then dereference a null pointer (UB).

---

### platform/wifi.h

**Class:** `EM070::Wifi` (inherits `QObject`)

| Symbol | Kind | Line |
|--------|------|------|
| `Wifi(EM070::UserPort *userPort)` | public constructor | 26 |
| `~Wifi()` | public destructor (empty) | 27 |
| `writeConf()` | public method | 29 |
| `restart()` | public method | 31 |
| `status()` | public method (inline) | 33 |
| `startPositioning()` | public method | 34 |
| `parseResponse(const QByteArray &ba)` | public method | 36 |
| `accessPoints()` | public method (inline) | 38 |
| `setCellularState(bool state)` | public method | 40 |
| `setPowerState(CIGCONF::PowerState state)` | public method | 42 |
| `ethernetStateChanged(bool ready)` | signal | 46 |
| `wifiReconnectionFailed()` | signal | 47 |
| `wifiScanFinished(QList<CIGCONF::AccessPoint>)` | signal | 48 |
| `attemptReconnectToWifi()` | private method | 51 |
| `checkStatus()` | private method | 52 |
| `scanAccessPoints()` | private method | 53 |
| `scanFinished(int, QProcess::ExitStatus)` | private method | 54 |

**Includes:** `../app/cigconfigs.h`, `<QObject>`, `<QByteArray>`, `<QList>` (duplicated at lines 7 and 11), `<QProcess>`, `<QNetworkConfigurationManager>`, `<QTimer>`

**Behaviour notes (wifi.cpp):**
- `writeConf()` (lines 46-80): writes `wpa_supplicant.conf`; passphrase < 8 chars or > 63 chars causes `key_mgmt=NONE` (open network) — silently degrades security.
- `checkStatus()` (lines 96-144): skips all processing if `m_powerState != NormalPowerState`; iterates `QNetworkConfigurationManager`; emits `ethernetStateChanged`.
- `attemptReconnectToWifi()` (lines 153-189): actual nmcli reconnect block is entirely commented out (lines 174-188); `wifiReconnectionFailed` signal is therefore never emitted.
- `scanFinished()` (lines 266-295): parses `iw wlan0 scan` output in fixed 4-line groups without bounds checking; `wifiScanFinished` signal is never emitted.
- `parseResponse()` (line 218): accesses `ba.at(0)` without checking `ba.isEmpty()`.

---

## Test Coverage Search Results

**Test directory searched:** `C:/Projects/cig-audit/repos/mark3-pvd/test/`

**Test files found:**
- `test_backgroundworker.cpp` / `.h`
- `test_canbus.cpp` / `.h`
- `test_dialog.cpp` / `.h`
- `test_ota.cpp` / `.h`

**Search terms used:** `UserPort`, `WiegandRfid`, `Wifi`, `wiegandrfid`, `wifi`, `response`, `setBaudRate`, `readData`, `cmdReceived`, `wiegandData`, `cardData`, `setEnabled`, `activated`, `writeConf`, `restart`, `checkStatus`, `scanAccessPoints`, `parseResponse`, `startPositioning`, `scanFinished`, `attemptReconnect`, `setCellularState`, `setPowerState`, `ethernetStateChanged`, `wifiReconnectionFailed`, `wifiScanFinished`

**Results:**

| Class | Usage in tests | Behavioural tests |
|-------|---------------|-------------------|
| `UserPort` | Instantiated as fixture dependency in all 4 test files (lines 30, 29, 34, 49 of respective files) | None — object created and injected into `BackgroundWorker`; no public methods called directly, no signals observed |
| `WiegandRfid` | Not referenced at all | None |
| `Wifi` | Not referenced at all | None |

All three classes have **zero behavioural test coverage**.

---

## Findings

---

**A17-1** · CRITICAL · Missing Test Coverage — UserPort Serial Port Open Failure
**File:** `platform/userport.cpp:34-37`
**Description:** When the serial port cannot be opened (device absent, permission denied, port busy), the constructor logs a `qCritical` message and returns silently. `m_serialPort` is left closed. No signal is emitted to inform callers. Subsequent `response()` calls silently discard data (guarded by `isOpen()` at line 80). Calls to `setBaudRate()` (lines 88-91) reach the underlying `QSerialPort` without any open-check guard. There is no test exercising this failure path — neither for graceful degradation, caller notification, nor safety of post-failure method calls.
**Fix:** Add a unit test that instantiates `UserPort` with an invalid port name (using the `QT_USER_SERIAL_PORT` environment variable override at line 18-20), then verifies: (a) `m_serialPort->isOpen()` is false; (b) subsequent `response()` calls do not crash; (c) subsequent `setBaudRate()` calls do not crash. Add a dedicated `error` signal or `isValid()` accessor to `UserPort` to allow callers to detect the open failure.

---

**A17-2** · CRITICAL · Missing Test Coverage — UserPort readData Character State Machine
**File:** `platform/userport.cpp:54-76`
**Description:** `readData()` contains a non-trivial character-by-character state machine: CR/LF triggers `cmdReceived`, backspace removes the last buffered character and conditionally writes an erase sequence, all other characters accumulate. None of this logic is tested. Untested cases include: (a) multi-character commands ending with CR emitting `cmdReceived`; (b) backspace on an empty buffer (no crash, no array underrun); (c) the echo-back path when `gCfg->isRs232AccessoryActive()` is false; (d) multiple bytes arriving in a single `readAll()` call containing a mix of normal chars, backspace, and CR.
**Fix:** Refactor `readData()` to accept a `QByteArray` parameter directly (or extract its logic into a pure function) to enable unit testing without a live serial port. Add tests for each of the cases listed above and confirm `cmdReceived` carries the correct payload.

---

**A17-3** · HIGH · Missing Test Coverage — WiegandRfid Null Pointer on Constructor Failure
**File:** `platform/wiegandrfid.cpp:14-22`, `106-108`
**Description:** If `m_cardReadyFile.open()` fails (sysfs file absent, hardware not present), the constructor returns without initialising `m_notifier`. The member is declared as a raw pointer (`QSocketNotifier *m_notifier`) with no in-class initialiser and is not set in the member initialiser list, leaving it uninitialised. A subsequent call to `setEnabled()` dereferences this pointer, causing undefined behaviour (likely a crash in production). No test exercises the constructor failure path or `setEnabled()` in any state.
**Fix:** Initialise `m_notifier` to `nullptr` in the member initialiser list. Add a null-check guard in `setEnabled()` before dereferencing. Add a unit test that simulates a missing sysfs file (via a configurable file-path parameter or environment variable) and verifies that `setEnabled(true)` and `setEnabled(false)` do not crash.

---

**A17-4** · HIGH · Missing Test Coverage — WiegandRfid Wiegand-26 Parity Encoding
**File:** `platform/wiegandrfid.cpp:141-163`
**Description:** `wiegandData()` encodes a Wiegand-26 frame. The parity calculation iterates 12 bits for even leading parity (lines 145-151) and a further 12-bit window for odd trailing parity (lines 154-162). Whether these two windows correctly cover the intended bit ranges of the Wiegand-26 standard (12 MSBs of the 24-bit card body for even parity, 12 LSBs for odd parity) is unverified. The Wiegand-42 branch (number 65536-99999, lines 132-140) is also untested. The case `number > 99999` (line 127-129) returns 0 with only a `qCritical` log and no `error` signal.
**Fix:** Add unit tests for `WiegandRfid::wiegandData()` using known Wiegand-26 test vectors with precomputed expected 26-bit output (including parity bits). Cover: (a) facility 0, number 0; (b) facility 255, number 65535; (c) Wiegand-42 path (number 65536-99999); (d) number > 99999 (verify return 0 and no crash). Test vectors should be independently derived from the Wiegand standard specification.

---

**A17-5** · HIGH · Missing Test Coverage — WiegandRfid 34-bit Decode and Dual Signal Emission
**File:** `platform/wiegandrfid.cpp:67-80`, `98-103`
**Description:** The 34-bit path strips the MSB parity bit via `& ~((quint64)1<<33)`, right-shifts by 1, then extracts facility from bits 16-23 and number from bits 0-15. This decode is never tested. Additionally, when facility and number are both zero after 34-bit decode, the condition at line 76 fails and execution falls through to the `bits >= 26` block at line 98 which emits `cardData(wiegand, 0, 0, ba)` and then unconditionally emits `error(ba)` at line 103 — producing two signals simultaneously for the same read event, which may confuse or double-process the event in consumers.
**Fix:** Add unit tests for the 34-bit decode path using precomputed raw values. Specifically test the zero-facility/zero-number edge case and assert that only the expected signals (not both) are emitted. Investigate and fix the dual-emission logic.

---

**A17-6** · HIGH · Missing Test Coverage — WiegandRfid Silent Error Paths and Unconditional error Emission
**File:** `platform/wiegandrfid.cpp:31-32`, `35-37`, `54-57`, `103`
**Description:** Multiple error paths in `activated()` return silently without emitting `error`: (a) `card_ready` reads a value that is zero or non-numeric (line 31-32); (b) `card_data` file open failure (line 35-37); (c) `raw_data` file open failure (line 54-57). None of these silent returns are tested. Additionally, `error(ba)` at line 103 is emitted unconditionally even after a `cardData` signal was emitted at line 100 (the `bits >= 26` path), meaning successful partial reads generate a spurious `error`.
**Fix:** Audit the intended semantics of each return path with respect to the `error` signal. Add tests simulating each failure path and assert the expected signal behaviour (silent return vs. `error` emission). Fix line 103 to only fire when no valid card data was found in the `>= 26` fallback path.

---

**A17-7** · HIGH · Missing Test Coverage — WiegandRfid 37-bit Decode Commented Out
**File:** `platform/wiegandrfid.cpp:83-96`
**Description:** The 37-bit HID format decode block is entirely commented out with no explanation. Sites using 37-bit HID readers will have their cards fall through to the `bits >= 26` block, emitting `cardData` with zero facility and number, which is likely not the intended behaviour. There is no test for this fallback, no documentation of why the code is disabled, and no indication of whether re-enabling it is planned.
**Fix:** Either re-enable the 37-bit decode with associated unit tests using known 37-bit test vectors, or add an explicit code comment citing the specific defect or hardware incompatibility that caused it to be disabled. Add a test asserting the current (fallback) behaviour for a 37-bit input so any future change is caught.

---

**A17-8** · HIGH · Missing Test Coverage — Wifi writeConf Passphrase and SSID Boundary Conditions
**File:** `platform/wifi.cpp:60-74`
**Description:** `writeConf()` silently degrades a configured WPA network to an open network (`key_mgmt=NONE`) when the passphrase is empty, shorter than 8 characters, or longer than 63 characters. It silently skips networks with SSID longer than 32 characters. These are security-critical code paths. No test verifies any of these conditions or the content of the written `wpa_supplicant.conf` file.
**Fix:** Add unit tests for `writeConf()` using a writable temporary file (inject the output path). Cover: (a) 0-char passphrase → `key_mgmt=NONE`; (b) 7-char passphrase → `key_mgmt=NONE`; (c) 8-char passphrase → PSK stanza; (d) 63-char passphrase → PSK stanza; (e) 64-char passphrase → `key_mgmt=NONE`; (f) SSID of 32 chars → included; (g) SSID of 33 chars → skipped; (h) empty SSID → skipped. Assert the exact file content in each case.

---

**A17-9** · HIGH · Missing Test Coverage — Wifi connect/disconnect State Machine and ethernetStateChanged Signal
**File:** `platform/wifi.cpp:96-144`
**Description:** `checkStatus()` is the core WiFi state machine, transitioning `m_wifiStatus` and emitting `ethernetStateChanged`. Neither the connect nor disconnect transition is tested. Specific untested scenarios: (a) initial connect emitting `ethernetStateChanged(true)`; (b) disconnect emitting `ethernetStateChanged(false)` and triggering reconnect; (c) the `NormalPowerState` guard suppressing all processing; (d) `m_reconnectTimer` interaction during disconnect.
**Fix:** Add unit tests that mock or stub `QNetworkConfigurationManager` (via a thin wrapper or subclass) to simulate configuration state changes. Assert `ethernetStateChanged` signal emissions and `m_wifiStatus` transitions for each scenario.

---

**A17-10** · HIGH · Missing Test Coverage — Wifi Reconnection Logic Dead Code and wifiReconnectionFailed Never Emitted
**File:** `platform/wifi.cpp:153-189`
**Description:** `attemptReconnectToWifi()` contains an entirely commented-out nmcli reconnect block (lines 174-188). This was the only code path that could emit `wifiReconnectionFailed`. As implemented today, `wifiReconnectionFailed` is declared but never emitted anywhere in the codebase — it is a dead signal. The active code only issues DHCP process signals (USR2/USR1) without confirming reconnection success. Association failure, DHCP failure, and wrong-passphrase scenarios all have no runtime handling and no tests.
**Fix:** Restore the reconnect mechanism (nmcli or equivalent) and emit `wifiReconnectionFailed` on confirmed repeated failure. Add tests asserting: (a) `wifiReconnectionFailed` emitted after association failure; (b) `ethernetStateChanged(true)` emitted on subsequent success; (c) timer-based retry behaviour.

---

**A17-11** · MEDIUM · Missing Test Coverage — Wifi parseResponse Empty Buffer Access
**File:** `platform/wifi.cpp:218`
**Description:** `parseResponse()` calls `ba.at(0)` without first verifying that `ba` is non-empty. `QByteArray::at()` on an empty array has undefined behaviour (returns garbage or crashes depending on Qt build and platform). An empty byte array can arrive as a line-split artefact from the serial port or from a caller passing an empty response. No test exercises this path.
**Fix:** Add a guard `if (ba.isEmpty()) return;` immediately before line 218. Add a unit test passing an empty `QByteArray` to `parseResponse()` and verifying the method returns without crashing.

---

**A17-12** · MEDIUM · Missing Test Coverage — Wifi wifiScanFinished Signal Never Emitted and Parser Bounds Risk
**File:** `platform/wifi.cpp:266-295`
**Description:** `scanFinished()` populates `m_accessPoints` but never emits `wifiScanFinished`. The signal is declared (header line 48) but is a dead signal. The parser assumes `iw wlan0 scan` output arrives in exact 4-line groups per access point; if the output does not divide evenly by 4, `n = results.size() / 4` truncates silently, discarding the trailing partial entry — but does not cause an out-of-bounds read because the loop bound is `n`. However, the implicit assumption of exactly 4 lines per BSS entry is fragile and entirely untested. The accessor `accessPoints()` requires polling by consumers instead of an event-driven notification.
**Fix:** Emit `wifiScanFinished(m_accessPoints)` at the end of `scanFinished()`. Add unit tests that supply known `iw scan` output strings (via mock or parse-function extraction) and assert correct `m_accessPoints` content. Test inputs that do not divide evenly by 4.

---

**A17-13** · LOW · Duplicate Include in wifi.h
**File:** `platform/wifi.h:7`, `11`
**Description:** `<QList>` is included twice (lines 7 and 11). Harmless due to include guards but indicates inattentive maintenance.
**Fix:** Remove the duplicate `#include <QList>` at line 11.

---

## Summary Table

| ID | Severity | Category | File | Line(s) | Coverage Gap |
|----|----------|----------|------|---------|--------------|
| A17-1 | CRITICAL | Test Coverage / Error Handling | `platform/userport.cpp` | 34-37 | Serial port open failure path entirely untested |
| A17-2 | CRITICAL | Test Coverage / Logic | `platform/userport.cpp` | 54-76 | `readData()` character state machine entirely untested |
| A17-3 | HIGH | Test Coverage / Null Pointer UB | `platform/wiegandrfid.cpp` | 14-22, 106-108 | Constructor failure leaves `m_notifier` uninitialised; crash on `setEnabled()` untested |
| A17-4 | HIGH | Test Coverage / Logic | `platform/wiegandrfid.cpp` | 141-163 | Wiegand-26 and Wiegand-42 parity encoding logic untested |
| A17-5 | HIGH | Test Coverage / Logic | `platform/wiegandrfid.cpp` | 67-80, 98-103 | 34-bit decode untested; dual signal emission on zero facility/number |
| A17-6 | HIGH | Test Coverage / Error Handling | `platform/wiegandrfid.cpp` | 31-32, 35-37, 54-57, 103 | Silent-return error paths and unconditional `error` emission untested |
| A17-7 | HIGH | Test Coverage / Dead Code | `platform/wiegandrfid.cpp` | 83-96 | 37-bit decode commented out; no test, no rationale, no fallback test |
| A17-8 | HIGH | Test Coverage / Security | `platform/wifi.cpp` | 60-74 | `writeConf()` passphrase and SSID boundary conditions untested |
| A17-9 | HIGH | Test Coverage / Logic | `platform/wifi.cpp` | 96-144 | WiFi connect/disconnect state machine and `ethernetStateChanged` signal untested |
| A17-10 | HIGH | Test Coverage / Dead Code | `platform/wifi.cpp` | 153-189 | Reconnect logic commented out; `wifiReconnectionFailed` dead signal, never tested |
| A17-11 | MEDIUM | Test Coverage / Crash Risk | `platform/wifi.cpp` | 218 | `ba.at(0)` without empty-check; no test for empty input |
| A17-12 | MEDIUM | Test Coverage / Dead Signal | `platform/wifi.cpp` | 266-295 | `wifiScanFinished` never emitted; scan parser untested |
| A17-13 | LOW | Code Quality | `platform/wifi.h` | 7, 11 | Duplicate `#include <QList>` |

---

## Overall Assessment

All three classes (`UserPort`, `WiegandRfid`, `Wifi`) have **zero behavioural test coverage**. Across 4 test suite files, `UserPort` is instantiated only as a fixture dependency for `BackgroundWorker`; no public method is called on it directly and no signal is observed. `WiegandRfid` and `Wifi` are not referenced in the test suite at all.

The following production code paths are entirely unverified:

- Serial port lifecycle (open, read, write, close, error)
- Wiegand card decode logic for all bit-widths (26, 34, and 37-bit which is dead code)
- Wiegand parity bit generation
- WiFi configuration file generation including security-critical passphrase handling
- WiFi connect/disconnect state machine
- WiFi reconnection logic (which is also dead code)
- All `error` signals and error return paths across all three classes

Two findings (A17-1, A17-2) are rated CRITICAL because `UserPort` represents core hardware I/O whose correctness cannot be verified without tests, and both contain known untested edge cases (open failure with post-failure method calls, backspace on empty buffer). A17-3 is rated HIGH rather than CRITICAL only because the null-pointer UB in `WiegandRfid` requires a hardware-absence scenario to trigger at runtime, but it is a certain crash if triggered.
# Audit Report — Agent A18 — Pass 2: Test Coverage

**Agent:** A18
**Audit Run:** 2026-02-28-01
**Branch confirmed:** master
**Date:** 2026-02-28

---

## Files Assigned

| File | Role |
|---|---|
| `ui/amberimpactalertdialog.h` | Header |
| `ui/amberimpactalertdialog.cpp` | Implementation |
| `ui/authoriseddialog.h` | Header |
| `ui/authoriseddialog.cpp` | Implementation |
| `ui/broadcastuidialog.h` | Header |
| `ui/broadcastuidialog.cpp` | Implementation |

Primary test files examined:
- `test/test_dialog.cpp`
- `test/test_dialog.h`

All other test files also searched: `test/test_backgroundworker.cpp`, `test/test_canbus.cpp`, `test/test_ota.cpp`.

---

## Reading Evidence

### AmberImpactAlertDialog (`ui/amberimpactalertdialog.h` / `.cpp`)

**Class:** `AmberImpactAlertDialog : public QDialog`

**Includes:**
- `amberimpactalertdialog.h`
- `ui_amberimpactalertdialog.h`
- `app/globalconfigs.h`
- `<QDebug>`

**Public methods:**

| Line | Method |
|---|---|
| h:15 / cpp:6 | `explicit AmberImpactAlertDialog(QWidget *parent = nullptr)` — constructor |
| h:16 / cpp:14 | `~AmberImpactAlertDialog()` — destructor |
| h:18 / cpp:49 | `bool isOpen() const` — returns `dialogOpenFlag` |
| h:19 / cpp:31 | `void closeWindow()` — closes if `dialogOpenFlag == true` |
| h:20 / cpp:19 | `void languageChanged()` — updates UI label text via `tr()` |

**Public slots:**

| Line | Slot |
|---|---|
| h:23 / cpp:54 | `void amberAlertDialogShowEvent(bool isLocked)` — conditionally calls `exec()` when not locked and amber alert is active |

**Protected overrides:**

| Line | Method |
|---|---|
| h:26 / cpp:25 | `void mouseReleaseEvent(QMouseEvent *)` — calls `closeWindow()` |
| h:27 / cpp:39 | `void showEvent(QShowEvent *event = 0)` — sets `dialogOpenFlag = true` if alert active |

**Private members:**
- `Ui::AmberImpactAlertDialog *ui`
- `bool dialogOpenFlag`

**Signals:** None declared.

**Key logic notes:**
- `dialogOpenFlag` is the sole guard preventing double-open; it is set in `showEvent()` and cleared in `closeWindow()`.
- `amberAlertDialogShowEvent(bool isLocked)` calls `exec()` (blocking modal); it also re-checks `amberImpactAlertActive()` and `dialogOpenFlag` independently of `showEvent()`, creating a secondary code path.

---

### AuthorisedDialog (`ui/authoriseddialog.h` / `.cpp`)

**Class:** `AuthorisedDialog : public QDialog`

**Includes:**
- `app/globalconfigs.h`
- `authoriseddialog.h`
- `ui_authoriseddialog.h`
- `ui/optionalcheckconfirmationdialog.h`
- `<QMouseEvent>`, `<QTimer>`, `app/driverlist.h`, `<QDebug>`, `<QFile>`

**Public methods:**

| Line | Method |
|---|---|
| h:17 / cpp:13 | `explicit AuthorisedDialog(QWidget *parent = 0)` — constructor; wires all signals/slots, creates timer |
| h:18 / cpp:44 | `~AuthorisedDialog()` — destructor |
| h:19 / cpp:56 | `void setHasChecklist(bool yes)` — shows/hides `btnStart` and `labelStart` |
| h:20 / cpp:67 | `void setDriverId(quint64 id)` — stores `m_pendingDriverId` |
| h:21 / cpp:178 | `void setTime(const QString s)` — updates `labelTime` text |
| h:22 / cpp:211 | `void setPower(bool on)` — stores `m_power` and calls `updateCamera()` |
| h:23 / cpp:217 | `void updateCamera()` — writes GPIO-based camera enable/flip to sysfs |

**Signals:**

| Line | Signal |
|---|---|
| h:30 | `void userLogout()` |

**Protected overrides:**

| Line | Method |
|---|---|
| h:33 / cpp:71 | `void showEvent(QShowEvent *)` — populates UI labels, calls `screensaverOff()` |
| h:34 / cpp:113 | `void hideEvent(QHideEvent *)` — sets `m_showCamera = false`, calls `updateCamera()` |

**Private methods:**

| Line | Method |
|---|---|
| h:43 / cpp:148 | `bool debounce()` — 200 ms debounce on button presses |
| h:44 / cpp:120 | `void screensaverOff()` — hides screensaver button; starts 5 s timer for `screensaverOn()` if config active |
| h:45 / cpp:138 | `void screensaverPressed()` — debounces press, disables button, fires `screensaverOff()` after 200 ms |
| h:46 / cpp:50 | `void onButtonConfirmStart()` — opens `OptionalCheckConfirmationDialog` |
| h:47 / cpp:130 | `void screensaverOn()` — shows screensaver button, calls `updateCamera()` |
| h:48 / cpp:188 | `void setCamera(bool on, bool flip)` — writes directly to `/sys/class/gpio/gpio37/value` and `/sys/class/gpio/gpio39/value` |

**Private slots:**

| Line | Slot |
|---|---|
| h:54 / cpp:172 | `void rstLogout()` — resets `m_lastPress` and restores logout button text |
| h:55 / cpp:156 | `void onLogoutRequest()` — two-press confirm pattern; emits `userLogout()` and calls `reject()` on second press |

**UNIT_TEST friend:** `friend class TestDialog` when `UNIT_TEST` is defined (h:26-27).

---

### BroadcastUIDialog (`ui/broadcastuidialog.h` / `.cpp`)

**Class:** `BroadcastUIDialog : public QDialog`

**Includes:**
- `broadcastuidialog.h`
- `ui_broadcastuidialog.h`
- `app/cigconfigs.h`
- `<QDialog>`, `<QTimer>`

**Public enum:**

| Line | Values |
|---|---|
| h:17 | `enum MessageResult { MsgResultOK, MsgResultYes, MsgResultNo, MsgResultTimeout, MsgResultLogout, MsgResultNoDriver }` |

**Public methods:**

| Line | Method |
|---|---|
| h:19 / cpp:4 | `explicit BroadcastUIDialog(QWidget *parent = nullptr)` — constructor; connects buttons and timer |
| h:20 / cpp:19 | `~BroadcastUIDialog()` — destructor |
| h:22 / cpp:24 | `void setUIParam(CIGCONF::BroadcastMessage m)` — populates text (truncated to 100 chars), toggles warning label, shows Yes/No or OK button, starts optional timer |

**Signals:**

| Line | Signal |
|---|---|
| h:25 | `void messageClosed(CIGCONF::BroadcastMessage m)` — declared but **never emitted** in the implementation |

**Private slots:**

| Line | Slot |
|---|---|
| h:32 / cpp:48 | `void onYes()` — stops timer, emits `done(MsgResultYes)` |
| h:33 / cpp:54 | `void onNo()` — stops timer, emits `done(MsgResultNo)` |
| h:34 / cpp:60 | `void onOK()` — stops timer, emits `done(MsgResultOK)` |

**Note on `done` signal:** The slots emit `done(int)` which is `QDialog::finished(int)` inherited from `QDialog`. `dialog.cpp:133` connects `BroadcastUIDialog::finished` (the `QDialog` signal) to `Dialog::onBroadcastDialogDone`. The declared `messageClosed` signal is unused dead code.

---

## Test Coverage Analysis

### Test file structure

`test/test_dialog.h` declares six test slots:
- `test_enums()`
- `test_globalConfigs()`
- `test_idleLockout()`
- `test_showPreopSummary()`
- `test_unlockMode1()`
- `test_showTime()`

**`AmberImpactAlertDialog` is never mentioned in any test file** (grep across all `.cpp`/`.h` in `test/` found zero matches).

**`BroadcastUIDialog` is never mentioned in any test file** (grep across all `.cpp`/`.h` in `test/` found zero matches).

**`AuthorisedDialog`** is exercised indirectly through `m_dialog->m_authorisedDialog->isVisible()` checks and one direct method call (`screensaverOn()` at line 613). No dedicated construction test, no signal spy for `userLogout()`, no direct method-level tests for `setHasChecklist`, `setDriverId`, `setTime`, `setPower`, `updateCamera`, `closeWindow`, `debounce`, `onLogoutRequest`, or `rstLogout`.

---

## Findings

---

**A18-1** · HIGH · Missing Tests — Zero Coverage
**File:** `ui/amberimpactalertdialog.cpp:1` / `ui/amberimpactalertdialog.h:1`
**Description:** `AmberImpactAlertDialog` has no test coverage whatsoever. The class is not referenced in any file under `test/`. None of the following are tested: construction with null vs valid parent; `isOpen()` state machine; `closeWindow()` guard (calling when `dialogOpenFlag == false` vs `true`); `languageChanged()` label updates; `mouseReleaseEvent()` triggering close; `showEvent()` guard against double-open when `amberImpactAlertActive()` is false; `amberAlertDialogShowEvent()` behaviour when `isLocked == true` vs `false`.
**Fix:** Add a `TestAmberImpactAlertDialog` test class (or extend `TestDialog`). At minimum: (1) construct with `nullptr` parent; (2) verify `isOpen()` is `false` before show; (3) call `amberAlertDialogShowEvent(true)` and verify `exec()` is not called (i.e., `isOpen()` remains `false`); (4) mock `gCfg->amberImpactAlertActive()` to return `true`, call `amberAlertDialogShowEvent(false)`, verify `isOpen()` becomes `true`; (5) call `closeWindow()` and verify `isOpen()` returns `false`; (6) call `closeWindow()` again and verify no crash (double-close guard); (7) call `languageChanged()` and verify label text.

---

**A18-2** · HIGH · Missing Tests — Zero Coverage
**File:** `ui/broadcastuidialog.cpp:1` / `ui/broadcastuidialog.h:1`
**Description:** `BroadcastUIDialog` has no test coverage whatsoever. The class is not referenced in any file under `test/`. None of the following are tested: construction; `setUIParam()` with `res == 0` (OK button path) vs `res != 0` (Yes/No path); `setUIParam()` with `type == 0` (no warning) vs `type != 0` (warning label); text truncation to `BROADCASTMSG_TEXT_LEN` (100 chars); `onYes()`, `onNo()`, `onOK()` signal emission (all emit `done(int)` = `QDialog::finished`); timer-based `MsgResultTimeout` emission when `timeout > 0`; timer stop when button pressed before timeout.
**Fix:** Add a `TestBroadcastUIDialog` test class. At minimum: (1) construct with `nullptr` parent; (2) call `setUIParam` with `res=0, type=0, timeout=0` and verify OK button visible, Yes/No hidden, warning hidden; (3) `setUIParam` with `res=1, type=1` and verify Yes/No visible, OK hidden, warning visible; (4) use `QSignalSpy` on `finished(int)` to verify `MsgResultOK`, `MsgResultYes`, `MsgResultNo` each emitted correctly; (5) `setUIParam` with `text` longer than 100 characters and verify `pEditMsgBox` contains only 100 characters; (6) `setUIParam` with `timeout=1`, wait >1000 ms, verify `MsgResultTimeout` emitted via spy; (7) press a button before timeout expires and verify timer stopped (no subsequent `MsgResultTimeout`).

---

**A18-3** · HIGH · Missing Tests — Signal Not Tested
**File:** `ui/authoriseddialog.cpp:162` / `ui/authoriseddialog.h:30`
**Description:** The `userLogout()` signal emitted by `onLogoutRequest()` is never captured by a `QSignalSpy` in any test. The logout two-press confirmation flow (`onLogoutRequest()` first press changes button text to "Confirm?", second press emits `userLogout()` and calls `reject()`) is not tested at all. The `rstLogout()` timer reset path (which resets button text after 2000 ms if second press does not come) is also untested.
**Fix:** Add a test case that: (1) constructs or reuses `AuthorisedDialog`; (2) attaches `QSignalSpy` to `userLogout()`; (3) calls `onLogoutRequest()` once and verifies spy count is 0 and button text becomes "Confirm?"; (4) calls `onLogoutRequest()` again within the debounce window (artificially advance `m_lastPress`) and verifies spy count is 1; (5) tests the `rstLogout()` path by calling `onLogoutRequest()` once and then waiting 2100 ms or calling `rstLogout()` directly and verifying button text reverts to "Logout".

---

**A18-4** · MEDIUM · Missing Tests — Public API Not Tested
**File:** `ui/authoriseddialog.cpp:56` / `ui/authoriseddialog.h:19`
**Description:** `setHasChecklist(bool yes)` is never called in any test. This method controls visibility of `btnStart` and `labelStart`. There is no test verifying that `btnStart` is hidden when `yes == false` or shown when `yes == true`.
**Fix:** Add assertions that call `setHasChecklist(false)` and verify `btnStart->isVisible() == false`, then `setHasChecklist(true)` and verify `btnStart->isVisible() == true`. This is straightforward UI state verification.

---

**A18-5** · MEDIUM · Missing Tests — Public API Not Tested
**File:** `ui/authoriseddialog.cpp:67` / `ui/authoriseddialog.h:20`
**Description:** `setDriverId(quint64 id)` is never called directly in tests. The method stores `m_pendingDriverId` which is subsequently used in `showEvent()` to look up and display the driver name via `gCfg->getDriverName()`. The name-display branch (lines 78–97) and the no-name branch (lines 89–97) in `showEvent()` are never exercised independently in the test suite.
**Fix:** Add tests that: (1) call `setDriverId(knownId)` and trigger `showEvent()` with `gCfg->showDriverName()` returning `true` and a non-empty name — verify `lblDriverName` is visible; (2) call `setDriverId(0)` or use an ID returning an empty name — verify `lblDriverName` is hidden.

---

**A18-6** · MEDIUM · Missing Tests — Camera Control Not Tested
**File:** `ui/authoriseddialog.cpp:217` / `ui/authoriseddialog.h:23`
**Description:** `updateCamera()` and `setCamera()` are not tested. `setCamera()` writes directly to hardware GPIO sysfs paths (`/sys/class/gpio/gpio37/value`, `/sys/class/gpio/gpio39/value`). `updateCamera()` has four distinct branches: `CameraForced`, `CameraOff`, camera on with power and screensaver state. None of these branches are verified. The `setPower(bool on)` method, which gates camera output, is also never called in tests.
**Fix:** The sysfs writes make direct unit testing of `setCamera()` impractical on non-target hardware, but `updateCamera()` can be tested by mocking `gCfg` camera mode. At minimum: (1) override camera mode to `CameraForced` and call `updateCamera()` — verify no crash; (2) set `CameraOff` and call `updateCamera()`; (3) call `setPower(false)` and verify camera is disabled. Long-term, `setCamera()` should be extracted to a hardware abstraction layer injectable for testing.

---

**A18-7** · MEDIUM · Missing Tests — Debounce Logic Not Tested
**File:** `ui/authoriseddialog.cpp:148` / `ui/authoriseddialog.h:43`
**Description:** The `debounce()` method (200 ms guard on button actions) is declared `private` and never exercised in tests. When `debounce()` returns `false`, `onLogoutRequest()` silently returns without action. There is no test verifying that a second rapid call to `onLogoutRequest()` within 200 ms is suppressed.
**Fix:** Using the `UNIT_TEST` friend relationship (`friend class TestDialog`), add a test that: (1) calls `onLogoutRequest()` at time T; (2) immediately calls it again at T+50 ms; (3) verifies the button text did not transition to "Confirm?" on the second call (debounce suppressed it).

---

**A18-8** · MEDIUM · Dead Code / Missing Tests — Unused Signal
**File:** `ui/broadcastuidialog.h:25` / `ui/broadcastuidialog.cpp`
**Description:** `BroadcastUIDialog` declares a signal `void messageClosed(CIGCONF::BroadcastMessage m)` at header line 25. This signal is **never emitted** anywhere in `broadcastuidialog.cpp` or any other file in the repository. The button slots (`onYes`, `onNo`, `onOK`) and the timer lambda all emit `done(int)` (the inherited `QDialog::finished` signal) rather than `messageClosed`. This dead signal is misleading: callers who connect to `messageClosed` receive no callbacks.
**Fix:** Either (a) remove `messageClosed` entirely if it is confirmed unused by all callers (verified: `dialog.cpp` connects to `finished`, not `messageClosed`), or (b) emit `messageClosed` with the appropriate `BroadcastMessage` in each slot if the richer data is needed. Add a test with `QSignalSpy` on `messageClosed` to confirm it fires (currently it would fail, making the dead code visible).

---

**A18-9** · LOW · Missing Tests — Edge Case: Empty / Oversized Text
**File:** `ui/broadcastuidialog.cpp:26`
**Description:** `setUIParam()` truncates `m.text` to `BROADCASTMSG_TEXT_LEN` (100 chars) via `m.text.mid(0, 100)`. There is no test verifying that a message with exactly 100 characters passes through untruncated, a message of 101+ characters is truncated, and an empty `text` field produces an empty text box without crashing.
**Fix:** Add parameterised test cases in `TestBroadcastUIDialog`: (1) empty string; (2) string of exactly 100 chars; (3) string of 200 chars — verify `pEditMsgBox->toPlainText().length() == 100`.

---

**A18-10** · LOW · Missing Tests — Edge Case: Null Parent Construction
**File:** `ui/amberimpactalertdialog.cpp:6` / `ui/broadcastuidialog.cpp:4` / `ui/authoriseddialog.cpp:13`
**Description:** All three dialogs declare `QWidget *parent = nullptr` (or `= 0`) as default. None are ever constructed with an explicit `nullptr` parent in unit tests. Qt dialogs exhibit different lifetime and window-management behaviour when constructed without a parent (no implicit destruction when parent destroyed, no centering on parent, different modal behaviour). This edge case is untested for all three.
**Fix:** Add test cases that construct each dialog with an explicit `nullptr` parent, call their primary methods, and verify there is no crash or assertion failure.

---

**A18-11** · LOW · Missing Tests — `languageChanged()` Not Tested
**File:** `ui/amberimpactalertdialog.cpp:19`
**Description:** `AmberImpactAlertDialog::languageChanged()` updates two UI labels. It is never called in tests. If the translation strings are malformed or the label pointers are invalid, no test would catch it.
**Fix:** After constructing the dialog in tests, call `languageChanged()` and verify `ui->label_3->text()` contains "Amber Impact Alert" and `ui->labelTip->text()` is non-empty.

---

## Summary Table

| ID | Severity | Category | Dialog | Finding |
|---|---|---|---|---|
| A18-1 | HIGH | Missing Tests — Zero Coverage | AmberImpactAlertDialog | No tests exist for any method or state |
| A18-2 | HIGH | Missing Tests — Zero Coverage | BroadcastUIDialog | No tests exist for any method or signal |
| A18-3 | HIGH | Missing Tests — Signal Not Tested | AuthorisedDialog | `userLogout` signal and logout two-press flow untested |
| A18-4 | MEDIUM | Missing Tests — Public API Not Tested | AuthorisedDialog | `setHasChecklist()` never called in tests |
| A18-5 | MEDIUM | Missing Tests — Public API Not Tested | AuthorisedDialog | `setDriverId()` / showEvent name-display branches untested |
| A18-6 | MEDIUM | Missing Tests — Camera Control Not Tested | AuthorisedDialog | `updateCamera()`, `setPower()`, `setCamera()` branches untested |
| A18-7 | MEDIUM | Missing Tests — Debounce Logic Not Tested | AuthorisedDialog | `debounce()` suppression behaviour untested |
| A18-8 | MEDIUM | Dead Code / Missing Tests | BroadcastUIDialog | `messageClosed` signal declared but never emitted |
| A18-9 | LOW | Missing Tests — Edge Case | BroadcastUIDialog | Text truncation at boundary (empty / 100 / 101+ chars) untested |
| A18-10 | LOW | Missing Tests — Edge Case | All three | Null-parent construction untested for all three dialogs |
| A18-11 | LOW | Missing Tests — Method Not Called | AmberImpactAlertDialog | `languageChanged()` never called in tests |

**Total findings: 11** (3 HIGH, 5 MEDIUM, 3 LOW)
# Audit Report – Agent A19 – Pass 2: Test Coverage

**Agent ID:** A19
**Audit Run:** 2026-02-28-01
**Pass:** 2 – Test Coverage
**Branch confirmed:** master (verified via `git branch --show-current`)
**Date:** 2026-02-28

---

## Files Under Audit

| Source File | Header File |
|---|---|
| `ui/checkcompleteddialog.cpp` | `ui/checkcompleteddialog.h` |
| `ui/checkconfirmationdialog.cpp` | `ui/checkconfirmationdialog.h` |
| `ui/checkquestiondialog.cpp` | `ui/checkquestiondialog.h` |

**Primary test file examined:** `test/test_dialog.cpp` + `test/test_dialog.h`
**Other test files checked:** `test/test_backgroundworker.cpp`, `test/test_canbus.cpp`, `test/test_ota.cpp` (no relevant references found in any of these).

---

## Reading Evidence

### CheckCompletedDialog (`ui/checkcompleteddialog.h` / `ui/checkcompleteddialog.cpp`)

**Includes:**
- `<QDialog>`, `<QTimer>`, `"app/cigconfigs.h"` (header)
- `"checkcompleteddialog.h"`, `"ui_checkcompleteddialog.h"`, `"app/globalconfigs.h"` (implementation)

**Class:** `CheckCompletedDialog : public QDialog`

**`UNIT_TEST` friend:** `friend class TestDialog;` (line 26 of header)

**Public methods (with line numbers in header/implementation):**

| Method | Header Line | Implementation Line |
|---|---|---|
| `CheckCompletedDialog(QWidget *parent = 0)` | 17 | cpp:7 |
| `~CheckCompletedDialog()` | 18 | cpp:62 |
| `void languageChanged(void)` | 20 | cpp:67 |
| `bool isTimerActive()` | 21 | cpp:135 |
| `void stopTimer()` | 22 | cpp:140 |
| `void setCheckResponses(QList<CIGCONF::CheckResponse> &responses)` | 23 (inline) | — |

**Signals:**
| Signal | Header Line |
|---|---|
| `void openPreopNotes()` | 31 |

**Protected methods:**
| Method | Header Line | Implementation Line |
|---|---|---|
| `void showEvent(QShowEvent *event = 0)` | 33 | cpp:75 |

**Internal timer constant:** `NO_ACTIVITY_TIME 10000` (10-second auto-accept timer, cpp:5)

**Button connections in constructor (implementation):**
- `btnSend` clicked → stop timer + `accept()` (cpp:28–31)
- `btnRepeat` clicked → stop timer + `reject()` (cpp:33–36)
- `btnSend_2` clicked → stop timer + `accept()` (cpp:38–41)
- `btnRepeat_2` clicked → stop timer + `reject()` (cpp:43–46)
- `btnNotes` clicked → stop timer + emit `openPreopNotes()` (cpp:48–51)
- `btnNotes_2` clicked → stop timer + emit `openPreopNotes()` (cpp:53–56)
- `m_timer` timeout → `accept()` (cpp:58)

---

### CheckConfirmationDialog (`ui/checkconfirmationdialog.h` / `ui/checkconfirmationdialog.cpp`)

**Includes:**
- `<QDialog>`, `"ui/dialog.h"` (header)
- `"checkconfirmationdialog.h"`, `"ui_checkconfirmationdialog.h"` (implementation)

**Class:** `CheckConfirmationDialog : public QDialog`

**No `UNIT_TEST` friend class declared.**

**No signals declared.**

**Public methods:**

| Method | Header Line | Implementation Line |
|---|---|---|
| `CheckConfirmationDialog(QWidget *parent = 0)` | 16 | cpp:4 |
| `~CheckConfirmationDialog()` | 17 | cpp:24 |
| `void confirm(bool yes)` | 19 | cpp:29 |
| `void setQuestion(const QString &question)` | 20 | cpp:40 |
| `void languageChanged(void)` | 21 | cpp:45 |

**Button connections in constructor:**
- `btnBack` clicked → `reject()` (cpp:18)
- `btnNext` clicked → `accept()` (cpp:19)
- `btnNext_2` clicked → `accept()` (cpp:20)
- `btnBack_2` clicked → `reject()` (cpp:21)

**Note:** The constructor body in `dialog.cpp` (line 349–356) shows that `CheckConfirmationDialog` usage is entirely commented out. The dialog's `confirm()` and `setQuestion()` are no longer called from any active code path; `onCheckQuestionDialogFinished` now bypasses `CheckConfirmationDialog` entirely and calls `onCheckConfirmationDialogFinished` directly.

---

### CheckQuestionDialog (`ui/checkquestiondialog.h` / `ui/checkquestiondialog.cpp`)

**Includes:**
- `<QDialog>`, `<QTimer>`, `"ui/dialog.h"` (header)
- `"checkquestiondialog.h"`, `"ui_checkquestiondialog.h"` (implementation)

**Class:** `CheckQuestionDialog : public QDialog`

**`UNIT_TEST` friend:** `friend class TestDialog;` (line 23 of header)

**Public methods:**

| Method | Header Line | Implementation Line |
|---|---|---|
| `CheckQuestionDialog(QWidget *parent = 0)` | 17 | cpp:4 |
| `~CheckQuestionDialog()` | 18 | cpp:14 |
| `const QString &question() const` | 20 (inline) | — |
| `void setQuestion(const QString &question, bool critical = false)` | 21 | cpp:19 |

**Signals:**
| Signal | Header Line |
|---|---|
| `void shown(void)` | 28 |

**Protected methods:**
| Method | Header Line | Implementation Line |
|---|---|---|
| `void showEvent(QShowEvent *event)` | 31 | cpp:39 |

**Button connections in constructor:**
- `btnYes` clicked → `accept()` (cpp:10)
- `btnNo` clicked → `reject()` (cpp:11)

**Notable behavior:** `setQuestion()` calls `qrand() % 2` (cpp:24) to randomly swap Yes/No button positions.

---

## Test Coverage Analysis

### Test file: `test/test_dialog.cpp`

**Relevant test slots declared in `test/test_dialog.h`:**
```
void test_enums();
void test_globalConfigs();
void test_idleLockout();
void test_showPreopSummary();
void test_unlockMode1();
void test_showTime();
```

No dedicated test slot exists for `CheckCompletedDialog`, `CheckConfirmationDialog`, or `CheckQuestionDialog` in isolation. Coverage is only incidental through integration-level tests.

---

### CheckCompletedDialog – Coverage Detail

| Item | Covered? | Evidence |
|---|---|---|
| Construction | Indirect only | Created as `m_dialog->m_checkCompletedDialog` inside `Dialog` constructor; no direct standalone construction test |
| `setCheckResponses()` | Yes | `test_dialog.cpp:433, 442, 451` |
| `showEvent()` with `showPreopSummary OFF` | Yes | `test_dialog.cpp:424–425` (via `onCheckConfirmationDialogFinished`) |
| `showEvent()` with `showPreopSummary ON`, 0 failures | Yes | `test_dialog.cpp:434–437` |
| `showEvent()` with `showPreopSummary ON`, 1 failure | Yes | `test_dialog.cpp:443–446` |
| `showEvent()` with `showPreopSummary ON`, 2 failures | Yes | `test_dialog.cpp:451–455` |
| `showEvent()` with `showPreopComment ON` | No | Branch at `checkcompleteddialog.cpp:86` (`gCfg->showPreopComment()`) never exercised in tests |
| `isTimerActive()` | No | Method never called in any test |
| `stopTimer()` | No | Method never called in any test (only called from `dialog.cpp:878`) |
| `languageChanged()` | No | Method never called in any test |
| Auto-accept timer fires (`m_timer` timeout → `accept()`) | No | The 10-second auto-accept timer is never tested |
| `openPreopNotes` signal emission | No | Signal never captured by a `QSignalSpy` in any test |
| `btnNotes` / `btnNotes_2` click | No | Not exercised |
| `btnRepeat` / `btnRepeat_2` click (reject) | Indirect | `test_dialog.cpp:520` uses `btnSend->clicked()` (accept path); reject path untested at button level |
| `accept()` on `btnSend` | Yes (indirect) | `test_dialog.cpp:520` emits `btnSend->clicked()` |
| Singular vs plural summary text | Yes | 0, 1, 2 failure cases verified |
| Red/black stylesheet on `lblSummaryCritical` | No | Stylesheet value never asserted |
| Button layout for `showPreopComment` on vs off | No | Pixel positions never verified |

---

### CheckConfirmationDialog – Coverage Detail

| Item | Covered? | Evidence |
|---|---|---|
| Construction | Indirect only | Created inside `Dialog` constructor (`dialog.cpp:46`); no standalone test |
| `confirm(true)` | No | Never called in any test |
| `confirm(false)` | No | Never called in any test |
| `setQuestion()` | No | Never called in any test |
| `languageChanged()` | No | Never called in any test |
| `btnNext` / `btnNext_2` click → accept | No | Never exercised |
| `btnBack` / `btnBack_2` click → reject | No | Never exercised |
| No `UNIT_TEST` friend class | — | This class has no `friend class TestDialog;` guard, so internals cannot be inspected in tests |
| Active code path | No | The entire dialog is bypassed: `dialog.cpp:349–356` (the calls to `confirm()`, `setQuestion()`, `open()`) are commented out |

---

### CheckQuestionDialog – Coverage Detail

| Item | Covered? | Evidence |
|---|---|---|
| Construction | Indirect only | Created inside `Dialog` constructor (`dialog.cpp:45`); no standalone test |
| `setQuestion()` with `critical = false` | No | Not directly tested; only via integration (`dialog.cpp:384, 747`) |
| `setQuestion()` with `critical = true` | No | Not directly tested |
| `question()` accessor | No | Never called in any test |
| `showEvent()` → emits `shown` | No | Signal never captured by a `QSignalSpy` |
| `shown` signal | No | Never captured |
| Random button swap (`qrand() % 2`) | No | Never tested for either position |
| `btnYes` click → accept | Indirect | `test_dialog.cpp:516` calls `m_checkQuestionDialog->accept()` directly, bypassing button |
| `btnNo` click → reject | No | Not exercised in any test |
| `isVisible()` check after `open()` | Yes | `test_dialog.cpp:514` |
| Empty question string | No | Not tested |
| Very long question string | No | Not tested |
| Special characters in question | No | Not tested |
| `lblCritical` show/hide logic | No | Not asserted in any test |

---

## Findings

**A19-1** · HIGH · Missing Coverage – Untested Signal
**File:** `ui/checkcompleteddialog.cpp:48–55` / `ui/checkcompleteddialog.h:31`
**Description:** The `openPreopNotes` signal is emitted when either `btnNotes` or `btnNotes_2` is clicked. No test uses a `QSignalSpy` to verify this signal is emitted, nor are either button's click events exercised in any test. This signal drives navigation to the pre-op notes screen; an untested signal path could silently break under refactoring.
**Fix:** Add a dedicated test that creates a `CheckCompletedDialog`, calls `showEvent()` with `gCfg->showPreopComment()` returning true so the Notes buttons are shown, attaches a `QSignalSpy` to `openPreopNotes`, programmatically clicks `btnNotes` (and separately `btnNotes_2`), and asserts that the spy count reaches 1 in each case.

---

**A19-2** · HIGH · Missing Coverage – Auto-Accept Timer Never Tested
**File:** `ui/checkcompleteddialog.cpp:58–59` / `ui/checkcompleteddialog.h:21–22`
**Description:** The 10-second `QTimer` auto-accepts the dialog (`m_timer` timeout → `accept()`). The methods `isTimerActive()` and `stopTimer()` also exist to manage this timer. No test verifies that: (a) the timer starts on `showEvent()`, (b) `isTimerActive()` correctly reflects timer state, (c) `stopTimer()` halts the timer, or (d) expiry causes `accept()` to be signalled. A regression that accidentally removed the timer start or broke the connection would go undetected.
**Fix:** Add tests that call `showEvent()` and immediately assert `isTimerActive() == true`; call `stopTimer()` and assert `isTimerActive() == false`; separately let the timer fire (using `QTest::qWait(11000)` or a shorter test-only timeout) and verify the dialog emits `accepted`.

---

**A19-3** · HIGH · Missing Coverage – CheckConfirmationDialog Entirely Untested
**File:** `ui/checkconfirmationdialog.cpp` / `ui/checkconfirmationdialog.h`
**Description:** `CheckConfirmationDialog` has zero direct test coverage. None of its three public methods (`confirm()`, `setQuestion()`, `languageChanged()`) appear in any test. No button interaction is exercised. Additionally, the class has no `UNIT_TEST` friend guard, so private internals remain inaccessible to tests. While the dialog is currently bypassed in production code (the call site in `dialog.cpp:349–356` is commented out), the class is still compiled and shipped. If the code path is re-enabled, there is no safety net.
**Fix:** Add a dedicated test slot (e.g., `test_checkConfirmationDialog`) that: constructs `CheckConfirmationDialog` directly; calls `setQuestion()` with a normal string and verifies the label text; calls `confirm(true)` and verifies `labelYes` is visible and `labelNo` is hidden; calls `confirm(false)` and verifies the inverse; calls `languageChanged()` without crashing; simulates button clicks for accept and reject paths. Also add `friend class TestDialog;` inside a `#ifdef UNIT_TEST` guard to allow widget inspection.

---

**A19-4** · HIGH · Missing Coverage – CheckQuestionDialog `shown` Signal Never Tested
**File:** `ui/checkquestiondialog.cpp:39–43` / `ui/checkquestiondialog.h:28`
**Description:** `showEvent()` emits the `shown` signal, which in production is used by `dialog.cpp:187` to trigger an idle timer. No test attaches a `QSignalSpy` to this signal to verify it is emitted on `show()`. A regression disconnecting or removing this emission would be undetectable.
**Fix:** Add a test that constructs a `CheckQuestionDialog`, attaches `QSignalSpy spy(dlg, &CheckQuestionDialog::shown)`, calls `dlg->show()`, calls `QTest::qWait()`, and asserts `spy.count() == 1`.

---

**A19-5** · MEDIUM · Missing Coverage – `setQuestion()` Critical vs Non-Critical Path
**File:** `ui/checkquestiondialog.cpp:19–37`
**Description:** `setQuestion()` has two distinct branches controlled by the `critical` parameter: `lblCritical` is shown when `critical == true` and hidden when `false`. No test verifies either branch. The `critical` label visibility is safety-relevant (it visually alerts the driver that a question has critical consequences). Additionally the random button position swap (`qrand() % 2`, line 24) is never tested.
**Fix:** Add tests that call `setQuestion("Question?", false)` and assert `lblCritical` is not visible; call `setQuestion("Question?", true)` and assert `lblCritical` is visible. For the button swap, seed `qsrand` with a known value or test both swap outcomes across multiple calls, asserting that both button positions are encountered.

---

**A19-6** · MEDIUM · Missing Coverage – `languageChanged()` on CheckCompletedDialog Never Tested
**File:** `ui/checkcompleteddialog.cpp:67–73`
**Description:** `languageChanged()` updates four UI labels. This method is never called in any test. A typo or missing label update would be undetected. Note that `showEvent()` also sets the same labels (lines 81–84), so there is also a risk of divergence between the two paths.
**Fix:** Add a test that calls `languageChanged()` on a `CheckCompletedDialog` instance (with a known locale) and asserts each of the four label texts: `label_2`, `btnSend_2`, `btnRepeat_2`, `btnNotes_2`.

---

**A19-7** · MEDIUM · Missing Coverage – `showPreopComment` Branch in `showEvent()` Never Tested
**File:** `ui/checkcompleteddialog.cpp:86–102`
**Description:** `showEvent()` branches on `gCfg->showPreopComment()`. All tests call `showEvent()` with `showPreopComment` returning false (its default reset value). The true branch (which shows Notes buttons and repositions all buttons) is never tested. This means button visibility changes and layout calculations for the notes-enabled configuration are entirely untested.
**Fix:** Add a test that sets `gCfg->showPreopComment()` to true before calling `showEvent()` and asserts that `btnNotes->isVisible() == true` and `btnNotes_2->isVisible() == true`. Conversely assert these are hidden when the flag is false.

---

**A19-8** · MEDIUM · Missing Coverage – `setQuestion()` Input Validation Not Tested
**File:** `ui/checkconfirmationdialog.cpp:40–43` / `ui/checkquestiondialog.cpp:19–37`
**Description:** Neither `CheckConfirmationDialog::setQuestion()` nor `CheckQuestionDialog::setQuestion()` is tested with boundary inputs: empty string (`""`), a very long string (e.g., 10,000 characters), or strings containing special/HTML characters (e.g., `"<b>Test</b>"`, `"\n\t"`). Qt's `QLabel::setText()` interprets some HTML by default depending on the label's `textFormat` setting; unexpected rich-text injection could cause display corruption.
**Fix:** Add parameterised tests for each `setQuestion()` with empty string, a 10,000-character string, and a string containing `<b>`, `&`, and newline characters. Assert that the label's `text()` matches the input exactly (or is safely escaped).

---

**A19-9** · MEDIUM · Missing Coverage – `btnNo` Click on CheckQuestionDialog Never Exercised
**File:** `ui/checkquestiondialog.cpp:11`
**Description:** `test_unlockMode1` calls `m_checkQuestionDialog->accept()` directly (line 516) rather than simulating a button click. This means `btnNo->clicked()` → `reject()` path is never exercised, and the button connection itself is never tested.
**Fix:** Add a test that calls `setQuestion()`, then programmatically emits `ui->btnNo->clicked()` (accessible via `UNIT_TEST` friend), and asserts the dialog result is `QDialog::Rejected`.

---

**A19-10** · LOW · Missing Coverage – `question()` Accessor Never Tested
**File:** `ui/checkquestiondialog.h:20` / `ui/checkquestiondialog.cpp:35`
**Description:** The inline `question()` const accessor returns `m_question`, which is set by `setQuestion()`. This accessor is used by the (now commented-out) confirmation flow in `dialog.cpp:350`. No test verifies that calling `setQuestion("text")` causes `question()` to return `"text"`.
**Fix:** Add an assertion `QCOMPARE(dlg->question(), QString("text"))` immediately after calling `dlg->setQuestion("text", false)`.

---

**A19-11** · LOW · Missing Coverage – `btnRepeat` / `btnRepeat_2` (Reject Path) Not Button-Tested
**File:** `ui/checkcompleteddialog.cpp:33–46`
**Description:** The test at line 520 of `test_dialog.cpp` only exercises the accept path via `btnSend->clicked()`. The reject path (`btnRepeat` / `btnRepeat_2` clicked → `reject()`) is never triggered by any button simulation in any test. This leaves the timer-stop-on-reject branch unverified.
**Fix:** Add a test that programmatically emits `btnRepeat->clicked()` on a visible `CheckCompletedDialog`, uses `QSignalSpy` on the `rejected()` signal, and asserts the spy count reaches 1 and `isTimerActive()` returns false afterward.

---

**A19-12** · LOW · Dead / Commented-Out Code Path Masks Coverage Gap
**File:** `ui/dialog.cpp:349–356`
**Description:** The entire `CheckConfirmationDialog` integration flow is commented out in `onCheckQuestionDialogFinished()`. The dialog is constructed, connected, and resized/moved but is never actually opened in production. This means any test of the integrated flow (e.g., `test_unlockMode1`) can never reach `CheckConfirmationDialog`'s UI, so any coverage of that dialog through integration routes is structurally impossible without first restoring or redesigning the commented code. The commented block also leaves `m_checkConfirmationDialog` as a permanently unused allocated object.
**Fix:** Either remove `CheckConfirmationDialog` and its allocations from `dialog.cpp` entirely (and mark it for deletion), or restore and test its integration path. If kept, add a clear `// DEAD CODE` comment with a ticket reference and ensure the unit tests cover the class standalone (see A19-3).

---

## Summary Table

| Finding | Severity | Category | Dialog |
|---|---|---|---|
| A19-1 | HIGH | Untested Signal (`openPreopNotes`) | CheckCompletedDialog |
| A19-2 | HIGH | Untested Auto-Accept Timer | CheckCompletedDialog |
| A19-3 | HIGH | Class Entirely Untested | CheckConfirmationDialog |
| A19-4 | HIGH | Untested Signal (`shown`) | CheckQuestionDialog |
| A19-5 | MEDIUM | Critical Label Branch Untested | CheckQuestionDialog |
| A19-6 | MEDIUM | `languageChanged()` Untested | CheckCompletedDialog |
| A19-7 | MEDIUM | `showPreopComment` Branch Untested | CheckCompletedDialog |
| A19-8 | MEDIUM | No Input Validation / Boundary Tests | CheckConfirmationDialog, CheckQuestionDialog |
| A19-9 | MEDIUM | `btnNo` Click Path Untested | CheckQuestionDialog |
| A19-10 | LOW | `question()` Accessor Untested | CheckQuestionDialog |
| A19-11 | LOW | Reject Button Path Untested | CheckCompletedDialog |
| A19-12 | LOW | Commented-Out Code Masks Coverage Gap | CheckConfirmationDialog |

**Total findings: 12** (4 HIGH, 5 MEDIUM, 3 LOW)

---

## Coverage Summary by Dialog

| Dialog | Construction Tested | Signals Tested | Public Methods Tested | Button Paths Tested | Input Validation |
|---|---|---|---|---|---|
| CheckCompletedDialog | No (indirect only) | No | Partial (setCheckResponses, showEvent partially) | Accept only | None |
| CheckConfirmationDialog | No (indirect only) | N/A (no signals) | None | None | None |
| CheckQuestionDialog | No (indirect only) | No | None directly | Accept only (via direct call) | None |
# Audit Report — Agent A20 · Pass 2 (Test Coverage)

**Audit run:** 2026-02-28-01
**Agent:** A20
**Branch confirmed:** master (verified: `git branch --show-current` returned `master`)

---

## Files Examined

| Source file | Lines | Role |
|---|---|---|
| `ui/checkstartdialog.h` | 28 | Header for pre-op check start prompt dialog |
| `ui/checkstartdialog.cpp` | 42 | Implementation of CheckStartDialog |
| `ui/commentdialog.h` | 56 | Header for unlock-reason / preop-comment text-entry dialog |
| `ui/commentdialog.cpp` | 218 | Implementation of CommentDialog |
| `ui/dialog.h` | 219 | Header for the central UI orchestrator class |
| `ui/dialog.cpp` | ~1326 | Implementation of Dialog |
| `test/test_dialog.h` | 34 | Test class declaration |
| `test/test_dialog.cpp` | 683 | Test implementations |

---

## Step 4 – Reading Evidence

### CheckStartDialog (`ui/checkstartdialog.h`, `ui/checkstartdialog.cpp`)

**Class:** `CheckStartDialog : public QDialog`

**Includes:** `<QDialog>`, `"ui_checkstartdialog.h"`, `<QDebug>`

**Public methods:**

| Line | Method |
|---|---|
| h:15 | `explicit CheckStartDialog(QWidget *parent = 0)` |
| h:16 | `~CheckStartDialog()` |
| h:17 | `void setMandatory(bool mandatory)` |
| h:18 | `void languageChanged(void)` |

**Signals:** none declared (inherits `QDialog::accepted`, `QDialog::rejected`, `QDialog::finished`)

**Key behaviour:**
- Constructor (cpp:15): sets up UI, sets icon, connects `btnStart::clicked` → `accept()`.
- `setMandatory(bool)` (cpp:23): toggles two UI labels to show "optional" or "mandatory".
- `languageChanged()` (cpp:34): re-translates five label strings.

**UNIT_TEST friend class:** `TestDialog` (h:21)

---

### CommentDialog (`ui/commentdialog.h`, `ui/commentdialog.cpp`)

**Class:** `CommentDialog : public QDialog`

**Includes:** `<QDialog>`, `<QTimer>`, `"ui/onScreenKeyboard.h"`, `"app/cigconfigs.h"`, `<QString>`, `<QListWidgetItem>`, `"ui/unlockreasondialog.h"`

**Preprocessor constants:**
- `NO_ACTIVITY_TIME 10000` (h:12)
- `MAX_CHARACTER 100` (h:13)

**Enum:** `CommentDialogType { Unlock, Preop }` (h:15)

**Public methods:**

| Line | Method |
|---|---|
| h:26 | `explicit CommentDialog(CommentDialogType type, QWidget *parent = nullptr)` |
| h:27 | `~CommentDialog()` |
| h:29 | `void UpdateTextInput(QString str, onScreenKeyboard::CtrlButton ctrl)` |
| h:30 | `void onkeyboardClosed()` |
| h:31 | `void onUnlkReasonSelected()` |
| h:32 | `void languageChanged()` |

**Protected overrides:** `showEvent(QShowEvent*)` (h:47), `hideEvent(QHideEvent*)` (h:48)

**Private slots:** `run_keyboard_lineEdit()` (h:51), `onDone()` (h:52), `onSkip()` (h:53)

**Private helpers:** `debounce()` (h:37), `reset()` (h:38), `showWidgets()` (h:39)

**Key signals used:** inherits `QDialog::accepted` (emitted from `onDone()` via `accept()`), `QDialog::rejected` (emitted from `onSkip()` via `reject()`).

**Key behaviour:**
- Dual-mode: `Unlock` vs `Preop`, controlled by `m_dlgType`.
- `onDone()` (cpp:134): double-tap confirm pattern; validates non-empty text; writes to `gCfg->setUnlkReasonString()` / `gCfg->setPreopCommentString()`; debounced.
- `onSkip()` (cpp:168): double-tap confirm; clears config strings; calls `reject()`.
- `debounce()` (cpp:188): rejects calls within 200 ms of previous press.
- `reset()` (cpp:199): fires on 10-second inactivity timer; re-runs `showWidgets()`.
- `UpdateTextInput()` (cpp:104): handles Backspace / Delete / character insert with MAX_CHARACTER cap.
- `onUnlkReasonSelected()` (cpp:205): populates text box from `UnlockReasonDialog`.

---

### Dialog (`ui/dialog.h`, `ui/dialog.cpp`)

**Class:** `Dialog : public QDialog`

**Includes (dialog.cpp):** `"dialog.h"`, `"ui_dialog.h"`, all child dialog headers, platform headers (`wiegandrfid.h`, `internalrfid.h`, `pwmbeeper.h`), `<QMouseEvent>`, `<QTimer>`, `<QTime>`, `<QDebug>`, `<QApplication>`, `<QPixmap>`, `"ui/keyfilter.h"`, `"ui/vorwarningdialog.h"`, `"mytranslator.h"`, `"ui/preopscreenoverlay.h"`, `"ui/amberimpactalertdialog.h"`

**Public methods (dialog.h):**

| Line | Method |
|---|---|
| h:44 | `explicit Dialog(QWidget *parent = 0)` |
| h:45 | `~Dialog()` |
| h:47 | `void onPowerChanged(CIGCONF::PowerState powerState)` |
| h:48 | `void onReboot()` |
| h:49 | `void onBleReady(bool yes)` |
| h:50 | `void onNetworkReady(bool yes)` |
| h:51 | `void onCardAuthorised(bool yes, quint64)` |
| h:52 | `void onCmdLogin(quint64 id)` |
| h:53 | `void onIdleTimeout()` |
| h:54 | `void lockScreen(CIGCONF::MaintLockedCode code, bool remote)` |
| h:55 | `void ambertImpactScreen()` |
| h:57 | `void updateLux(int lux)` |
| h:58 | `void updateStatus(...)` |
| h:59 | `void updateBatteryStatus(...)` |
| h:60 | `void updateExpModInfo(QByteArray mainVersion)` |
| h:61 | `void onBroadcastMsgReceived(CIGCONF::BroadcastMessage m)` |
| h:62 | `void showInformationScreen()` |
| h:63 | `void updateLoginImage()` |
| h:64 | `void quickPowerUpdate(bool on)` |
| h:66 | `void onDemandStarted(quint32, quint32, quint64, CIGCONF::OnDemandCmdSrc)` |
| h:67 | `void onDemandExtended(quint32, quint32, quint64, CIGCONF::OnDemandCmdSrc)` |
| h:68 | `void onDemandEnded(quint32, quint64, CIGCONF::OnDemandCmdSrc)` |
| h:70 | `void onLanguageChanged(void)` |
| h:72 | `void updateCamera()` |

**Signals (dialog.h):**

| Line | Signal |
|---|---|
| h:79 | `driverChanged(quint64 id)` |
| h:80 | `lastCheckDriverChanged(quint64 id)` |
| h:81 | `screenLocked(CIGCONF::MaintLockedCode code)` |
| h:82 | `setRelayOut(bool on1, bool on2)` |
| h:83 | `setRelay2Out(bool on)` |
| h:84 | `sendGmtpMessage(CIGCONF::GmtpMessage msg, const QByteArray &extra)` |
| h:85 | `resetCanStates(bool resetLast)` |
| h:86 | `forceBroadcastUIClose()` |
| h:87 | `log(QByteArray &msg)` |
| h:88 | `updatePreopTimer(QString timeout)` |
| h:89 | `amberDialogAboutToShow(bool isLocked)` |

**Private methods (dialog.h, implemented in dialog.cpp):**

| Approx. line | Method |
|---|---|
| h:99 | `onPinCode()` |
| h:100 | `onCardSwiped(...)` |
| h:102 | `onPinDialogAccepted()` |
| h:103 | `onAuthorisedDialogAccepted()` |
| h:104 | `onAuthorisedUserLogout()` |
| h:105 | `onOptionalCheckConfirmed()` |
| h:106 | `onCheckStartDialogAccepted()` |
| h:107 | `onCheckQuestionDialogFinished(int)` |
| h:108 | `onCheckConfirmationDialogFinished(int)` |
| h:109 | `onCheckCompletedDialogAccepted()` |
| h:110 | `onCheckCompletedDialogRejected()` |
| h:111 | `onUnlockedDialogAccepted()` |
| h:112 | `onProcessUnlock()` |
| h:113 | `onPreopCommentDone()` |
| h:114 | `onBroadcastDialogDone(int)` |
| h:116 | `isValidId(quint64)` |
| h:117 | `isChecklistEmpty(bool)` |
| h:118 | `bypassChecklist()` |
| h:119 | `clearWidgets()` |
| h:121 | `login(quint64)` |
| h:122 | `postLogin()` |
| h:123 | `postMaintenanceLogin()` |
| h:124 | `logout()` |
| h:125 | `openMenuDialog()` |
| h:127 | `startCheck(bool restartTimer=true)` |
| h:128 | `sendStartCheck()` |
| h:130 | `superListUpdated(bool)` |
| h:131 | `updateOnDemand()` |
| h:133 | `convorStatusUpdated()` |
| h:135 | `isOnDemandExpired()` |
| h:137 | `fullLockStart()` |
| h:138 | `updateFullLock()` |
| h:140 | `updateTime()` |
| h:201 | `writeMsgToQueue(CIGCONF::BroadcastMessage)` |
| h:202 | `displayNextBroadcastMessage()` |
| h:203 | `clearMsgQueue()` |
| h:207 | `initOnScreenPreopTimer(quint16)` |
| h:208 | `showCustomTimeFormat(quint32)` |
| h:212 | `adjustPreopDialogs(bool)` |
| h:214 | `updateBLEConSpinner(quint8)` |

---

## Step 5 – Findings

### Coverage Summary for Dialog

**Test cases in `test_dialog.cpp`:** `test_enums`, `test_globalConfigs`, `test_idleLockout`, `test_showPreopSummary`, `test_unlockMode1`, `test_showTime` (6 tests).

#### Dialog public methods – coverage status

| Method | Covered | Notes |
|---|---|---|
| `Dialog()` constructor | YES | `initTestCase()` constructs Dialog |
| `onPowerChanged()` | NO | Never called in any test |
| `onReboot()` | NO | Never called in any test |
| `onBleReady()` | NO | Never called in any test |
| `onNetworkReady()` | NO | Never called in any test |
| `onCardAuthorised()` | NO | Never called in any test |
| `onCmdLogin()` | NO | Never called in any test |
| `onIdleTimeout()` | PARTIAL | Called in `test_idleLockout` – idle-lock and no-lock paths tested; MaintIdle GMTP payload verified |
| `lockScreen()` | PARTIAL | Called in `test_idleLockout` and `test_unlockMode1`; only `MaintRedImpact` and `MaintIdle` codes tested; `MaintNormal` remote-unlock path untested |
| `ambertImpactScreen()` | NO | Never called in any test |
| `updateLux()` | NO | Never called |
| `updateStatus()` | NO | Never called |
| `updateBatteryStatus()` | NO | Never called |
| `updateExpModInfo()` | NO | Never called |
| `onBroadcastMsgReceived()` | NO | Never called |
| `showInformationScreen()` | NO | Never called |
| `updateLoginImage()` | INDIRECT | Called internally by `showEvent()` on Dialog show |
| `quickPowerUpdate()` | NO | Never called |
| `onDemandStarted()` | NO | Never called |
| `onDemandExtended()` | NO | Never called |
| `onDemandEnded()` | NO | Never called |
| `onLanguageChanged()` | NO | Never called |
| `updateCamera()` | NO | Never called |

#### Dialog signals – coverage status

| Signal | Verified in tests |
|---|---|
| `driverChanged` | NO |
| `lastCheckDriverChanged` | NO |
| `screenLocked` | NO |
| `setRelayOut` | NO |
| `setRelay2Out` | NO |
| `sendGmtpMessage` | PARTIAL – spy verifies IDLE and MAINT GMTP payloads in `test_idleLockout` only |
| `resetCanStates` | NO |
| `forceBroadcastUIClose` | NO |
| `log` | NO |
| `updatePreopTimer` | NO |
| `amberDialogAboutToShow` | NO |

#### Untested major state transitions in Dialog

1. **Power-off / reboot flow** – `onPowerChanged(DimState)`, `onPowerChanged(SleepActiveState)`, `onReboot()`.
2. **Card/PIN authentication** – `onCardSwiped()`, `onPinDialogAccepted()`, `onCardAuthorised()`.
3. **Preop comment flow** – `m_preopCommentDlg` open/accept/reject cycle; `onPreopCommentDone()` is an empty stub.
4. **Broadcast message flow** – `onBroadcastMsgReceived()`, `displayNextBroadcastMessage()`, `onBroadcastDialogDone()`, queue management (`writeMsgToQueue`, `clearMsgQueue`).
5. **On-demand mode** – `onDemandStarted()`, `onDemandExtended()`, `onDemandEnded()`, `updateOnDemand()`, `isOnDemandExpired()`.
6. **BLE readiness** – `onBleReady()`, `updateBLEConSpinner()`.
7. **Check confirmation dialog** – `onCheckConfirmationDialogFinished()` is called indirectly via `onCheckQuestionDialogFinished()` in `test_showPreopSummary`, but the rejected path is not tested.
8. **Check completed dialog rejected** (restart checklist path) – `onCheckCompletedDialogRejected()`.
9. **Language change** – `onLanguageChanged()`.
10. **Supervisor / maintenance login path** – `postMaintenanceLogin()`.
11. **Preop timer / overlay** – `initOnScreenPreopTimer()`, `adjustPreopDialogs()`, timer countdown lambda.
12. **Convor (VOR) status** – `convorStatusUpdated()`, related `bypassChecklist()` branch.
13. **Full lockout** – `fullLockStart()`, `updateFullLock()` (declared in header but no implementation visible; suggests dead/stub code).

### CheckStartDialog coverage

- `CheckStartDialog` is **included** (`test_dialog.cpp:10`) and its `m_checkStartDialog` pointer is accessed at lines 508 and 511.
- `isVisible()` is asserted once (line 508) and `accept()` is called once (line 511) inside `test_unlockMode1` to simulate the user pressing Start.
- **`setMandatory()`** is called in production code (`dialog.cpp:645`) but is **never called or asserted in any test**. The `mandatory=false` path is entirely untested.
- **`languageChanged()`** is called in production code (`dialog.cpp:1278`) but is **never exercised in any test**.
- No test constructs a standalone `CheckStartDialog` or verifies its UI state changes.

### CommentDialog coverage

- `CommentDialog` header is **not included** in `test_dialog.cpp`.
- `m_unlockReasonDlg` and `m_preopCommentDlg` (both `CommentDialog*`) are referenced only through `Dialog`'s private members; neither is accessed directly by any test.
- No test opens, accepts, rejects, or inspects a `CommentDialog` instance.
- The signal connections for `CommentDialog::accepted` → `Dialog::onProcessUnlock()` and `CommentDialog::rejected` → `Dialog::onProcessUnlock()` are **completely untested**.
- The preop comment path (`m_preopCommentDlg` → `onCheckCompletedDialogAccepted()`) is **untested**.
- The `Unlock` vs `Preop` type distinction, double-tap confirm logic, debounce logic, inactivity timer, MAX_CHARACTER cap, and the `UnlockReasonDialog` dropdown integration are all **untested**.

---

## Findings

**A20-1** · HIGH · Missing Test Coverage
**File:** `ui/commentdialog.cpp:134` (`onDone()`), `ui/commentdialog.cpp:168` (`onSkip()`)
**Description:** `CommentDialog` has zero test coverage. Its header is not included in `test_dialog.cpp` and no test accesses either of its two `Dialog`-member instances (`m_unlockReasonDlg`, `m_preopCommentDlg`). The double-tap confirm pattern in both `onDone()` and `onSkip()` is a custom UI contract that is entirely unverified. Both `accept()` and `reject()` paths go untested, meaning the unlock-reason and preop-comment flows – which gate machine unlock – carry no automated regression protection.
**Fix:** Add test cases that construct a `CommentDialog` in `Unlock` and `Preop` modes, simulate first and second button presses for both Done and Skip, assert the correct `gCfg` side-effects (`setUnlkReasonString`, `setUnlkOption`, `setPreopCommentString`), and verify `accepted`/`rejected` signals fire appropriately.

---

**A20-2** · HIGH · Missing Test Coverage
**File:** `ui/commentdialog.cpp:188` (`debounce()`), `ui/commentdialog.cpp:199` (`reset()`)
**Description:** The debounce guard (200 ms minimum between presses) and the 10-second inactivity reset timer are untested. If the debounce threshold is regressed to zero or the timer interval changed, no test would catch it. The `reset()` path (which wipes partial input and re-runs `showWidgets()`) could silently discard a user's in-progress unlock reason.
**Fix:** Add timed tests using `QTest::qWait()` to verify that rapid double-calls to `onDone()` are rejected by debounce, and that after `NO_ACTIVITY_TIME` ms the dialog resets to its initial state.

---

**A20-3** · HIGH · Missing Test Coverage
**File:** `ui/commentdialog.cpp:104` (`UpdateTextInput()`), `ui/commentdialog.h:13` (`MAX_CHARACTER 100`)
**Description:** The `MAX_CHARACTER` cap (100 characters) that limits the unlock-reason text entry is untested. If this constant or the guard condition is accidentally removed or changed, no test will detect the regression. Backspace and Delete handling paths are similarly untested.
**Fix:** Add unit tests that fill the text box to exactly 100 characters, attempt to insert a 101st character, and verify the text length does not exceed the limit. Also test Backspace and Delete control paths.

---

**A20-4** · MEDIUM · Missing Test Coverage
**File:** `ui/checkstartdialog.cpp:23` (`setMandatory()`)
**Description:** `setMandatory(false)` is never exercised in any test. Only the `mandatory=true` branch is reachable in `test_unlockMode1` (via the indirect path through `Dialog::postLogin()` at `dialog.cpp:645`), and even that branch is not explicitly asserted on the label visibility. The optional-vs-mandatory label toggle is purely UI state that should be verified.
**Fix:** In a test that exercises the optional checklist path, assert `m_checkStartDialog->ui->labelTip12->isVisible()` is `true` and `ui->labelTip21->isVisible()` is `false` (and vice versa for mandatory). Alternatively, call `setMandatory()` directly on a standalone instance.

---

**A20-5** · MEDIUM · Missing Test Coverage
**File:** `ui/checkstartdialog.cpp:34` (`languageChanged()`), `ui/commentdialog.cpp:214` (`languageChanged()`), `ui/dialog.cpp:1260` (`onLanguageChanged()`)
**Description:** `onLanguageChanged()` in `Dialog` (which delegates to `m_checkStartDialog->languageChanged()` at line 1278 and `m_unlockReasonDlg->languageChanged()` at line 1281) is never called in any test. Language-change regressions – such as missing `tr()` calls or incorrect string assignments – cannot be caught.
**Fix:** Add a test that calls `m_dialog->onLanguageChanged()` and verifies that key labels on child dialogs are non-empty strings.

---

**A20-6** · MEDIUM · Missing Test Coverage
**File:** `ui/dialog.cpp:481` (`onProcessUnlock()`)
**Description:** `onProcessUnlock()` orchestrates the transition from locked → unlocked and decides whether to show the unlock-reason `CommentDialog`. The path where `gCfg->unlkScr()` is non-zero (i.e., `m_unlockReasonDlg->open()` is called) is never tested. The test `test_unlockMode1` uses `gCfg->setUnlkScr(CIGCONF::Disabled)` precisely to bypass this path. A regression here could allow unlock without a required reason being collected.
**Fix:** Add a test scenario with `gCfg->setUnlkScr()` set to a non-Disabled value, trigger a supervisor unlock, and verify that `m_unlockReasonDlg` becomes visible, that its acceptance causes `onProcessUnlock()` to proceed, and that the correct GMTP messages are emitted.

---

**A20-7** · MEDIUM · Missing Test Coverage
**File:** `ui/dialog.cpp:517` (`onBroadcastDialogDone()`), `ui/dialog.cpp:1155` (`onBroadcastMsgReceived()`), `ui/dialog.cpp:1177` (`displayNextBroadcastMessage()`), `ui/dialog.cpp:1169` (`writeMsgToQueue()`)
**Description:** The entire broadcast message flow – receiving a message, enqueueing it, displaying it, and recording the GMTP response – has zero test coverage. This flow includes priority queue ordering (urgent vs normal) and the no-driver edge case (`MsgResultNoDriver` response).
**Fix:** Add tests that call `onBroadcastMsgReceived()` with urgent and normal message types, verify queue ordering via `displayNextBroadcastMessage()`, simulate `BroadcastUIDialog::finished`, and assert the `sendGmtpMessage` signal carries the correct `GMTP_MSG_RSP` payload.

---

**A20-8** · MEDIUM · Missing Test Coverage
**File:** `ui/dialog.cpp:899` (`onPowerChanged()`), `ui/dialog.cpp:927` (`onReboot()`)
**Description:** Power-state transitions are never exercised. `DimState` triggers `clearWidgets()`, `logout()`, and a re-lock; `SleepActiveState` opens a PowerOff message; `NormalPowerState` re-enables RFID. `onReboot()` shows a Reboot message and logs out. All are zero-coverage.
**Fix:** Add tests calling `onPowerChanged()` with each `PowerState` enum value and `onReboot()`, asserting the correct child dialog visibility and that relay-out and GMTP messages are emitted appropriately.

---

**A20-9** · MEDIUM · Missing Test Coverage
**File:** `ui/dialog.cpp:934` (`onBleReady()`), `ui/dialog.cpp:212` (`updateBLEConSpinner()`)
**Description:** `onBleReady(false)` and `onBleReady(true)` are never called in tests. The BLE-not-ready state blocks PIN-code login (`onPinCode()` at line 271 checks `m_bleReady`). If this guard is removed, unauthenticated logins could succeed silently.
**Fix:** Add tests that call `onBleReady(false)`, attempt a pin-dialog open, verify it does not open, then call `onBleReady(true)` and verify it does open.

---

**A20-10** · LOW · Missing Test Coverage
**File:** `ui/dialog.cpp:792` (`bypassChecklist()`)
**Description:** `bypassChecklist()` contains complex logic covering time-slot, driver-based, once-per-day, master-only-driver, and convor-status checks. Only the `forceChecklist=1` path is exercised via `test_unlockMode1`. The time-slot evaluation loop, `preopOncePerDayEn()` branch, and driver-based 24-hour window logic are all untested.
**Fix:** Parameterise tests over different `checkTimeSlot` configurations and `preopOncePerDayEn` settings to exercise all branches of `bypassChecklist()`.

---

**A20-11** · LOW · Declared but Unimplemented Method
**File:** `ui/dialog.h:137`, `ui/dialog.cpp:513` (`onPreopCommentDone()`); `ui/dialog.h:137-138` (`fullLockStart()`, `updateFullLock()`)
**Description:** `onPreopCommentDone()` has a body that is completely empty (cpp:513–515). `fullLockStart()` and `updateFullLock()` are declared in the header but no corresponding implementation is visible anywhere in `dialog.cpp`. These are either dead code or incomplete features. In both cases there are no tests, and the absence of tests means the dead/stub status is invisible to CI.
**Fix:** Either implement or remove these methods. Add a test that verifies the full-lockout timeout signal (`setRelayOut(false, false)`) fires from the `LockedDialog::fullLockoutTimerEnded` connection, which is the closest covered path.

---

**A20-12** · HIGH · Missing Test Coverage — Pre-op Comment Dialog Signal Paths
**File:** `ui/dialog.cpp:108–127` (constructor signal connections for `m_preopCommentDlg`), `ui/dialog.cpp:412` (`onCheckCompletedDialogAccepted()`)
**Description:** Two signal paths for `m_preopCommentDlg` (CommentDialog, Preop type) are wired in the constructor but never exercised in tests. First, the `openPreopNotes` signal from `m_checkCompletedDialog` opens `m_preopCommentDlg` and hides `m_checkCompletedDialog` (cpp:108–111). Second, `m_preopCommentDlg->rejected` re-opens `m_checkCompletedDialog` (cpp:122–124). Third, `m_preopCommentDlg->accepted` calls `onCheckCompletedDialogAccepted()` (cpp:125–127), which at line 412–413 emits `sendGmtpMessage(CIGCONF::GMTP_AUTH_OPCMNT)` when a preop comment string is present. The condition `gCfg->showPreopComment()` is also never exercised.
**Fix:** Add a test that: (1) completes a checklist and triggers `openPreopNotes` on `m_checkCompletedDialog`; (2) verifies `m_preopCommentDlg->isVisible()`; (3) accepts with a non-empty comment, then verifies `sendGmtpMessage(GMTP_AUTH_OPCMNT)` was emitted; (4) repeats the flow and rejects on `m_preopCommentDlg`, verifying `m_checkCompletedDialog` re-appears.

---

**A20-13** · MEDIUM · Dialog Signals Never Verified with QSignalSpy
**File:** `ui/dialog.h:79–89`
**Description:** Nine of the eleven signals emitted by `Dialog` are never verified with `QSignalSpy` in `test_dialog.cpp`: `driverChanged`, `lastCheckDriverChanged`, `screenLocked`, `setRelay2Out`, `resetCanStates`, `forceBroadcastUIClose`, `log`, `updatePreopTimer`, and `amberDialogAboutToShow`. Only `sendGmtpMessage` (partially, through the BackgroundWorker wrapper spy) is checked at all. The `setRelayOut` signal is emitted directly from `test_canbus.cpp` to test downstream effects — it is never verified as an *output* of `Dialog`. The absence of signal spies means that lock transitions, relay switching, and GMTP emission can silently regress with no test failure.
**Fix:** For each safety-relevant signal add a `QSignalSpy` in the appropriate test: `driverChanged` on every `login()` / `logout()` call; `screenLocked` on every `lockScreen()` call; `setRelayOut` on checklist-complete and unlock paths; `setRelay2Out` on lock transitions. The `updatePreopTimer` signal path can be verified by checking its connection to `PreopScreenOverlay::onUpdatePreopTimer` via a spy on the overlay slot.

---

## Summary Table

| ID | Severity | Category | Subject |
|---|---|---|---|
| A20-1 | HIGH | Missing Coverage | CommentDialog – zero test coverage; unlock/preop gating untested |
| A20-2 | HIGH | Missing Coverage | CommentDialog debounce and inactivity-reset timer untested |
| A20-3 | HIGH | Missing Coverage | CommentDialog MAX_CHARACTER cap and keyboard control paths untested |
| A20-12 | HIGH | Missing Coverage | Pre-op comment dialog signal paths (openPreopNotes, accepted, rejected) untested |
| A20-4 | MEDIUM | Missing Coverage | CheckStartDialog::setMandatory(false) path untested |
| A20-5 | MEDIUM | Missing Coverage | languageChanged() for all three classes untested |
| A20-6 | MEDIUM | Missing Coverage | onProcessUnlock() unlock-reason dialog path untested |
| A20-7 | MEDIUM | Missing Coverage | Broadcast message receive/queue/response flow untested |
| A20-8 | MEDIUM | Missing Coverage | onPowerChanged() / onReboot() power-state transitions untested |
| A20-9 | MEDIUM | Missing Coverage | onBleReady() / BLE-gated login path untested |
| A20-13 | MEDIUM | Missing Coverage | Dialog signals (9 of 11) never verified with QSignalSpy |
| A20-10 | LOW | Missing Coverage | bypassChecklist() time-slot and once-per-day branches untested |
| A20-11 | LOW | Dead / Stub Code | onPreopCommentDone() is empty; fullLockStart/updateFullLock unimplemented |

**Total findings: 13 (4 HIGH, 6 MEDIUM, 3 LOW)**

**Overall assessment:** Of the 23 public methods on `Dialog`, only 3 (`onIdleTimeout`, `lockScreen`, and the constructor) have meaningful direct test coverage. `CommentDialog` has zero test coverage despite guarding a safety-critical flow — machine unlock requires collection of an unlock reason. `CheckStartDialog` coverage is superficial (visibility assertion and accept signal only). Of the 11 `Dialog` signals, 9 are never verified with `QSignalSpy`. The test suite covers approximately 10–15% of the behavioural surface area of these three files combined, and 0% of `CommentDialog`.
# Audit Report — Agent A21 — Pass 2: Test Coverage

**Agent:** A21
**Audit run:** 2026-02-28-01
**Branch confirmed:** master (verified via `git branch --show-current`)
**Date:** 2026-02-28
**Pass:** 2 — Test Coverage

---

## Files Under Audit

| # | Source file | Header |
|---|-------------|--------|
| 1 | `ui/informationdialog.cpp` | `ui/informationdialog.h` |
| 2 | `ui/keyfilter.cpp` | `ui/keyfilter.h` |
| 3 | `ui/languagedialog.cpp` | `ui/languagedialog.h` |

**Primary test file read:** `test/test_dialog.cpp` + `test/test_dialog.h`
**Additional test files searched:** `test/test_backgroundworker.cpp/.h`, `test/test_canbus.cpp/.h`, `test/test_ota.cpp/.h`

---

## Step 4 — Reading Evidence

### 4.1 `ui/informationdialog.h` / `ui/informationdialog.cpp`

**Includes (h):** `<QDialog>`, `<QMap>`, `<QString>`, `<QByteArray>`, `<QObject>`, `<QLabel>`, `<QTimer>`

**Includes (cpp):** `informationdialog.h`, `ui_informationdialog.h`, `app/globalconfigs.h`, `utils/barcode128.h`, `<QBluetoothAddress>`, `<QProcess>`, `<QFile>`

**Class:** `InformationDialog : public QDialog` (h:16) — `Q_OBJECT`

**Public methods:**

| Line (h) | Line (cpp) | Method |
|----------|------------|--------|
| 21 | 11 | `explicit InformationDialog(QWidget *parent = 0)` |
| 22 | 101 | `~InformationDialog()` |
| 23 | 233 | `void updateInformationScreen()` |
| 24 | 106 | `void setLux(int lux)` |
| 25 | 111 | `void setStatus(QByteArray IO, bool Rly1, bool Rly2, QByteArray can, const QByteArray &rssi, const QByteArray &moni, bool netStat, bool mdemStat, bool wifiStat, qint8 sat, qint32 lat, qint32 lon)` |
| 26 | 137 | `void setConfigParam()` |
| 27 | 126 | `void setBatteryStatus(bool avail, int state, int fault, quint16 voltage, qint16 current, quint16 temp, quint16 remainingCapacity)` |
| 28 | 195 | `void setExpModInfo(QByteArray mainVersion)` |
| 29 | 200 | `void setSuperMasterStatus()` |
| 30 | 220 | `void setVOR()` |
| 31 | 228 | `void setLastWiegand(quint64 id)` |
| 32 | 240 | `void languageChanged()` |

**Protected methods:**

| Line (h) | Line (cpp) | Method |
|----------|------------|--------|
| 35 | 89 | `void showEvent(QShowEvent *)` |
| 36 | 94 | `void hideEvent(QHideEvent *)` |

**Signals/Slots:** None declared explicitly. `accept()` connected to `btnHide` click (cpp:38). `updateInformationScreen` connected to `m_updateConfigTmr` timeout (cpp:39).

**Private members:** `Ui::InformationDialog *ui`, `QMap<int,QString> m_chargeStatusMap`, `QMap<int,QString> m_chargeFaultMap`, `QTimer *m_updateConfigTmr`

**Notable constructor behaviour (cpp:11–87):**
- Reads `/proc/version` (cpp:44) and `/home/root_version` (cpp:58) from the filesystem.
- Computes `qChecksum` over a concatenated Latin-1 string and generates a barcode pixmap (cpp:74–76).
- Charge status/fault maps populated with keys 0–3 (cpp:78–86); out-of-range keys return `tr("Unknown")` via `QMap::value` default.

**Notable `showEvent` behaviour (cpp:94–100):** Calls `languageChanged()`, `setConfigParam()`, `setSuperMasterStatus()`, starts 5 000 ms timer.

**Notable `setSuperMasterStatus` behaviour (cpp:200–218):** Unsigned subtraction `end - gCfg->localTimestamp()` at cpp:209 — underflows when session has expired.

**Notable `languageChanged` behaviour (cpp:240–310):** Retranslates all labels; also opens `/sys/class/net/wlan0/address` and sets the WiFi MAC label to `tr("na")` if the file is absent (cpp:306–309) — duplicating logic already in `setConfigParam` (cpp:164–169) with inconsistent fallback behaviour.

---

### 4.2 `ui/keyfilter.h` / `ui/keyfilter.cpp`

**Includes (h):** `<QObject>`, `<QSet>`, `<QTimer>`

**Includes (cpp):** `keyfilter.h`, `<QEvent>`, `<QKeyEvent>`, `<QTimer>`

**Class:** `KeyFilter : public QObject` (h:8) — `Q_OBJECT`

**Public methods:**

| Line (h) | Line (cpp) | Method |
|----------|------------|--------|
| 12 | 8 | `explicit KeyFilter(QObject *parent = nullptr)` |
| 13 | — (inline) | `static bool isPowerKeyPressed()` |

**Signal:**

| Line (h) | Signal |
|----------|--------|
| 16 | `void showInfoDialog()` |

**Protected method:**

| Line (h) | Line (cpp) | Method |
|----------|------------|--------|
| 18 | 20 | `bool eventFilter(QObject *obj, QEvent *event)` |

**Private methods:**

| Line (h) | Line (cpp) | Method |
|----------|------------|--------|
| 34 | 66 | `void resetKeyCount()` |
| 35 | 76 | `void incrementKeyCount(int key)` |
| 36 | 101 | `int getKeyCount(int key)` |
| 37 | 114 | `void resetKeyCounter(int key)` |
| 39 | 126 | `void setPressState(int key, bool state)` |
| 38 | 145 | `bool getPressState(int key)` |

**Private members:** `static bool m_powerKeyPressed`, `QSet<int> m_pressedKeys`, `QTimer *m_timer`, `int m_leftKeyCount`, `int m_rightKeyCount`, `int m_upKeyCount`, `int m_downKeyCount`, `bool m_leftKeyPressed`, `bool m_rightKeyPressed`, `bool m_upKeyPressed`, `bool m_downKeyPressed`

**Constructor initializer list (cpp:8–14):** Initializes `m_timer`, `m_leftKeyCount(0)`, `m_rightKeyCount(0)`, `m_upKeyCount(0)`, `m_downKeyCount(0)`, `m_leftKeyPressed(false)`. Members `m_rightKeyPressed` (h:30), `m_upKeyPressed` (h:31), and `m_downKeyPressed` (h:32) are **absent** from the initializer list and hold indeterminate values until first written.

**`eventFilter` logic (cpp:20–63):**
- Two trigger paths for `showInfoDialog` signal:
  1. Three keys simultaneously: `Key_Left + Key_Up + Key_Down` (cpp:26–30).
  2. Same single arrow key pressed 4 times within 1.5 s (cpp:31–43); `incrementKeyCount` is mutually exclusive — pressing a different arrow resets all other counters (cpp:76–98).
- `Key_Return` press sets `m_powerKeyPressed = true` (cpp:46–47); release sets `false` (cpp:55–56).
- Returns `true` for every `KeyPress` and every `KeyRelease` (cpp:49, 60) — consuming all keyboard events regardless of key code. Non-key events delegated to base class (cpp:63).

---

### 4.3 `ui/languagedialog.h` / `ui/languagedialog.cpp`

**Includes (h):** `<QDialog>`

**Includes (cpp):** `languagedialog.h`, `ui_languagedialog.h`, `app/globalconfigs.h`, `mytranslator.h`, `ui/dialog.h`, `<QTimer>`, `<QLocale>`, `<QDebug>`

**Class:** `LanguageDialog : public QDialog` (h:10) — `Q_OBJECT`

**Public methods:**

| Line (h) | Line (cpp) | Method |
|----------|------------|--------|
| 15 | 12 | `explicit LanguageDialog(QWidget *parent = nullptr)` |
| 16 | 25 | `~LanguageDialog()` |
| 17 | 76 | `void languageChanged()` |
| 18 | 84 | `void startScreenTimeout()` |

**Signal:**

| Line (h) | Signal |
|----------|--------|
| 21 | `void sigLanguageChanged()` |

**Private slots:**

| Line (h) | Line (cpp) | Slot |
|----------|------------|------|
| 24 | 30 | `void on_btnEnglish_clicked()` |
| 25 | 42 | `void on_btnSpanish_clicked()` |
| 26 | 54 | `void on_btnQuit_clicked()` |

**Protected method:**

| Line (h) | Line (cpp) | Method |
|----------|------------|--------|
| 29 | 59 | `void showEvent(QShowEvent *event = 0)` |

**Private members/methods:** `Ui::LanguageDialog *ui`, `QTimer *m_timer`, `bool debounce()` (cpp:65), `quint32 m_lastPress`

**Key logic:**
- Timer connected to `reject()` (cpp:20) — 10 s inactivity auto-dismisses dialog.
- `on_btnEnglish_clicked` / `on_btnSpanish_clicked`: debounce guard (200 ms via `gCfg->clockTime()`); emits `sigLanguageChanged` only if `setLanguage` returns >= 0 (cpp:35, 47).
- `setLanguage` (mytranslator.cpp:177–188): returns -1 for any locale other than `QLocale::English` or `QLocale::Spanish`.
- `on_btnQuit_clicked`: calls `accept()` directly (cpp:56).

---

## Step 3/5 — Coverage Search Results

Grep searches performed across `C:/Projects/cig-audit/repos/mark3-pvd/test/` for:

- Class names: `InformationDialog`, `KeyFilter`, `LanguageDialog`
- All public method names: `setLux`, `setStatus`, `setConfigParam`, `setBatteryStatus`, `setExpModInfo`, `setSuperMasterStatus`, `setVOR`, `setLastWiegand`, `updateInformationScreen`, `languageChanged`, `showInfoDialog`, `isPowerKeyPressed`, `eventFilter`, `resetKeyCount`, `incrementKeyCount`, `getKeyCount`, `resetKeyCounter`, `setPressState`, `getPressState`, `sigLanguageChanged`, `startScreenTimeout`, `debounce`, `on_btnEnglish`, `on_btnSpanish`, `on_btnQuit`

**Result: zero matches in any test file.**

The four test classes in the suite (`TestDialog`, `TestBackgroundWorker`, and the canbus/OTA suites) do not reference `InformationDialog`, `KeyFilter`, or `LanguageDialog` by any name. No method, signal, or slot from any of the three audited classes is invoked from any test.

---

## Findings

---

**A21-1** · HIGH · Missing Test Coverage
**File:** `ui/informationdialog.cpp` / `ui/informationdialog.h` (all lines)
**Description:** `InformationDialog` has zero test coverage. None of its twelve public methods are exercised in any test. The class is instantiated in production code (`ui/dialog.cpp:51`) and used throughout the application lifecycle. Untested behaviors include: constructor handling of absent or malformed `/proc/version` and `/home/root_version` filesystem entries; `setBatteryStatus` map lookup with out-of-range `state`/`fault` values (expected to return `tr("Unknown")` — never verified); `updateInformationScreen` periodic timer start/stop lifecycle; `setVOR`, `setLux`, `setExpModInfo`, `setLastWiegand` label-update paths; and the `languageChanged` retranslation of all 30+ UI labels.
**Fix:** Add a `TestInformationDialog` test class. Cover: (1) construct with null `gCfg` or controlled stub — verify no crash when proc files absent; (2) call `setBatteryStatus` with `state`/`fault` values 0–3 and verify correct label text; (3) call `setBatteryStatus` with value 99 and verify "Unknown" fallback; (4) call `setLux(0)`, `setLux(INT_MAX)`, `setLux(-1)` and verify label text; (5) verify timer starts on `showEvent` and stops on `hideEvent`.

---

**A21-2** · HIGH · Missing Test Coverage — Key Event Filtering
**File:** `ui/keyfilter.cpp:20–63`
**Description:** `KeyFilter::eventFilter()` — the application's sole keyboard security gate — has zero test coverage. This method controls access to the diagnostic information screen and manages the power-key state flag read elsewhere in production code. Specific untested paths include:
- The three-key chord (`Key_Left + Key_Up + Key_Down` simultaneously) triggering `showInfoDialog` (cpp:26–30).
- The four-sequential-press path for each arrow key within 1.5 s triggering `showInfoDialog` (cpp:31–43).
- The mutual-exclusion counter reset: pressing a different arrow key resets all other counters (cpp:76–98). No test verifies that interleaving arrow keys does not erroneously trigger the signal.
- `Key_Return` press/release state machine for `isPowerKeyPressed()` (cpp:46–47, 55–56).
- The 1.5 s timer reset path (cpp:66–73) — timer expiry before the 4th press should reset the counter and prevent the signal.
- Partial key sequences (2 of 3 chord keys, 3 of 4 sequential presses) must not emit the signal.
**Fix:** Add a `TestKeyFilter` test class. Use `QSignalSpy` on `showInfoDialog`. Use `QTest::keyPress`/`QTest::keyRelease` or construct `QKeyEvent` directly. Cover all four arrow keys for the 4-press path, the chord path, the timer-reset path, and the `Key_Return` state machine.

---

**A21-3** · MEDIUM · Uninitialized Member Variables — Undefined Behavior
**File:** `ui/keyfilter.cpp:8–14`
**Description:** The `KeyFilter` constructor initializer list at cpp:8–14 initializes `m_leftKeyPressed(false)` but does not initialize `m_rightKeyPressed` (h:30), `m_upKeyPressed` (h:31), or `m_downKeyPressed` (h:32). These are `bool` members of a `QObject` subclass. In C++ they hold indeterminate values until explicitly written. `getPressState()` (cpp:145–156) reads all four before any `KeyPress` event has occurred. The `eventFilter` at cpp:31 guards `setPressState` calls with `!getPressState(key)` — if any of the three uninitialized flags happens to hold a non-zero value at startup, the very first press of that key will not call `setPressState` and will not start the counter, silently breaking the 4-press detection path. This is undefined behavior per the C++ standard and is not covered by any test.
**Fix:** Add `m_rightKeyPressed(false)`, `m_upKeyPressed(false)`, `m_downKeyPressed(false)` to the constructor member-initializer list at `ui/keyfilter.cpp:14`. Add a test that constructs a fresh `KeyFilter`, sends one press of `Key_Right` / `Key_Up` / `Key_Down` without any prior events, and verifies the count increments correctly.

---

**A21-4** · HIGH · Missing Test Coverage — Language Selection
**File:** `ui/languagedialog.cpp:30–57` / `ui/languagedialog.h`
**Description:** `LanguageDialog` has zero test coverage. The three button slots, the debounce guard, the inactivity timer, and the `sigLanguageChanged` signal are all untested. Critical untested behaviors:
- `on_btnEnglish_clicked` and `on_btnSpanish_clicked`: `sigLanguageChanged` is only emitted when `setLanguage` returns >= 0. No test verifies the signal fires on a valid selection or does not fire on a failed one.
- `debounce()`: 200 ms guard (cpp:65–73) silently discards rapid presses. No test documents this as intentional behavior.
- Inactivity timer: 10 s timeout calls `reject()` (cpp:20). `startScreenTimeout()` (cpp:84–87) restarts the timer. Neither is tested.
- `showEvent` (cpp:59–63) calls `languageChanged()` to retranslate UI labels. No test verifies labels are set correctly.
- `on_btnQuit_clicked` (cpp:54–57) calls `accept()`. Not tested.
**Fix:** Add a `TestLanguageDialog` test class. Cover: (1) click English/Spanish buttons — spy on `sigLanguageChanged`, verify emitted exactly once per click; (2) rapid double-click within 200 ms — verify signal emitted exactly once; (3) `startScreenTimeout()` then advance time 10+ s — verify dialog no longer visible; (4) `on_btnQuit_clicked` — verify dialog accepted; (5) `show()` dialog — verify all labels non-empty in English and after switching to Spanish.

---

**A21-5** · MEDIUM · Unsigned Integer Underflow — Untested Edge Case
**File:** `ui/informationdialog.cpp:208–215`
**Description:**
```cpp
quint32 end = gCfg->onDemandEndTime();
quint32 timeRemaining = end - gCfg->localTimestamp();   // cpp:209
QDateTime d = QDateTime::fromSecsSinceEpoch(timeRemaining);
```
When an on-demand session has expired (`end < localTimestamp()`), this `quint32` subtraction wraps to approximately 4 294 967 295, and `QDateTime::fromSecsSinceEpoch` receives a value corresponding to the year ~2106. The resulting time string displayed on screen is meaningless. No test exercises this path. The condition `gCfg->onDemandActive() && gCfg->onDemandVehicleEnabled()` must both be true to reach the subtraction, so the bug is reachable in production when a session expires while the information dialog is visible.
**Fix:** Add an expiry guard before the subtraction: `quint32 timeRemaining = (end > gCfg->localTimestamp()) ? (end - gCfg->localTimestamp()) : 0;`. Add a test setting `onDemandEndTime()` to a value less than `localTimestamp()` and verifying the displayed string does not show a year in the far future.

---

**A21-6** · MEDIUM · Duplicate Inconsistent WiFi MAC Label Logic — Untested
**File:** `ui/informationdialog.cpp:164–169` (in `setConfigParam`) and `cpp:306–309` (in `languageChanged`)
**Description:** `setConfigParam` (cpp:164–169) opens `/sys/class/net/wlan0/address` and, if successful, sets `ui->lblMacAddress_2` to the MAC address; if the file is absent the label is left with whatever text it previously held. `languageChanged` (cpp:306–309) opens the same file and, if it cannot be opened, sets the same label to `tr("na")`. Both methods are called from `showEvent` (cpp:96–98), meaning the label is set twice on every show event with inconsistent fallback semantics. A test environment where the file is absent would see "na" from `languageChanged` regardless of what `setConfigParam` had just set. No test covers either branch.
**Fix:** Extract WiFi MAC address label update into a single private method. Define the authoritative fallback value ("na") in one place. Add tests for both file-present and file-absent branches verifying the label shows the MAC address or "na" respectively.

---

**A21-7** · LOW · `qChecksum` Length Argument Mismatch — Latent Out-of-Bounds Read
**File:** `ui/informationdialog.cpp:74`
**Description:**
```cpp
quint16 checksum = qChecksum(string.toLatin1().constData(), string.size());
```
`string.size()` returns the number of UTF-16 `QChar` code units in the `QString`. The buffer passed is `string.toLatin1()` — a `QByteArray` whose size is `string.toLatin1().size()`. For pure ASCII content these are equal. However if any component of the concatenated version string (hardware version, kernel version, rootfs version, app version) ever contains a non-ASCII character, `string.size()` exceeds `string.toLatin1().size()`, causing `qChecksum` to read past the end of the allocated byte array — an out-of-bounds read producing undefined behavior and a different checksum than intended. No test covers this code path.
**Fix:** Store the `QByteArray` in a named local variable and use its `size()`: `QByteArray la = string.toLatin1(); quint16 checksum = qChecksum(la.constData(), la.size());`. Add a test using a version string containing at least one non-ASCII character and verify the checksum is computed without crash.

---

**A21-8** · LOW · `showEvent` Default Argument on Virtual Override — API Misuse
**File:** `ui/languagedialog.h:29`
**Description:**
```cpp
protected:
    void showEvent(QShowEvent *event = 0);
```
The base class `QWidget::showEvent(QShowEvent*)` declares no default argument. Adding a default argument to a virtual function override compiles but is semantically misleading: the default applies only when the method is called directly through the derived type, not through the base class vtable. The `Q_UNUSED(event)` annotation in the implementation (cpp:61) confirms the argument is not used, but the default `= 0` invites callers to pass a null pointer directly without realizing it. No test calls `showEvent(nullptr)` to verify null-safety.
**Fix:** Remove the `= 0` default argument from the `showEvent` override declaration in `ui/languagedialog.h:29`. If null-safety for direct calls is required, add a null check in the implementation.

---

## Coverage Summary

| Class | Test files referencing it | Public methods with any test | Signals tested | Total public methods/signals |
|-------|--------------------------|------------------------------|----------------|------------------------------|
| `InformationDialog` | 0 | 0 / 12 | 0 / 0 | 12 |
| `KeyFilter` | 0 | 0 / 2 | 0 / 1 | 2 + 1 signal |
| `LanguageDialog` | 0 | 0 / 4 | 0 / 1 | 4 + 1 signal |

**Overall test coverage for all three audited classes: 0%.**

All three classes are instantiated and connected in production code (`ui/dialog.cpp:51,57`; `main.cpp:79,130`) and are active throughout the application's critical UI path. No automated regression protection exists for any of their behaviors.

---

## Summary Table

| ID | Severity | Category | File | Lines | Description |
|----|----------|----------|------|-------|-------------|
| A21-1 | HIGH | Missing Coverage | `ui/informationdialog.cpp/.h` | all | All 12 public methods of `InformationDialog` untested |
| A21-2 | HIGH | Missing Coverage | `ui/keyfilter.cpp` | 20–63 | `eventFilter` key-event logic entirely untested |
| A21-3 | MEDIUM | Uninitialized Members / UB | `ui/keyfilter.cpp` | 8–14 | `m_rightKeyPressed`, `m_upKeyPressed`, `m_downKeyPressed` not in initializer list |
| A21-4 | HIGH | Missing Coverage | `ui/languagedialog.cpp/.h` | 30–87 | All slots, signal, debounce, and timer behavior of `LanguageDialog` untested |
| A21-5 | MEDIUM | Defect / Unsigned Underflow | `ui/informationdialog.cpp` | 208–215 | `quint32` underflow in `setSuperMasterStatus` when session expired; untested |
| A21-6 | MEDIUM | Code Quality / Defect | `ui/informationdialog.cpp` | 164–169, 306–309 | Duplicate, inconsistent WiFi MAC label logic with differing fallback; untested |
| A21-7 | LOW | Latent Defect | `ui/informationdialog.cpp` | 74 | `qChecksum` passed `QString::size()` instead of `QByteArray::size()` |
| A21-8 | LOW | Code Quality | `ui/languagedialog.h` | 29 | Default argument on virtual override is misleading |

**Total findings: 8**
- HIGH: 3 (A21-1, A21-2, A21-4)
- MEDIUM: 3 (A21-3, A21-5, A21-6)
- LOW: 2 (A21-7, A21-8)

---

*End of report — Agent A21*
# Audit Report — Agent A22 (Pass 2: Test Coverage)

**Audit Run:** 2026-02-28-01
**Agent:** A22
**Branch confirmed:** master (verified via `git branch --show-current`)
**Date:** 2026-02-28

---

## Assigned Files

| File | Role |
|---|---|
| `ui/lockeddialog.h` | Lock-screen dialog header |
| `ui/lockeddialog.cpp` | Lock-screen dialog implementation |
| `ui/messagedialog.h` | Status/auth message dialog header |
| `ui/messagedialog.cpp` | Status/auth message dialog implementation |
| `ui/onScreenKeyboard.h` | On-screen keyboard widget header |
| `ui/onScreenKeyboard.cpp` | On-screen keyboard widget implementation |

Primary test file examined: `test/test_dialog.cpp` + `test/test_dialog.h`
Additional test files scanned: `test/test_backgroundworker.cpp`, `test/test_canbus.cpp`, `test/test_ota.cpp`

---

## Reading Evidence

### LockedDialog (`ui/lockeddialog.h` + `ui/lockeddialog.cpp`)

**Class:** `LockedDialog : public QDialog`

**Includes:**
- `lockeddialog.h` (self)
- `ui_lockeddialog.h` (generated)
- `platform/pwmbeeper.h`
- `platform/seriallogger.h`
- `app/globalconfigs.h`
- `app/cigconfigs.h`
- `<QDialog>`, `<QTimer>`

**Public methods (with line numbers):**

| Line | Method |
|---|---|
| h:18 | `explicit LockedDialog(QWidget *parent = 0)` — constructor |
| h:19 | `~LockedDialog()` — destructor |
| h:20 | `void setLockedReason(CIGCONF::MaintLockedCode lockedCode)` |
| h:21 | `void languageChanged(void)` |
| h:22 | `void setTimeRemaining(quint32 secs)` |
| h:23 | `void clearTimerText()` |
| h:24 | `void stopTimer()` |
| h:25 | `void startTimer()` |

**Signals (with line numbers):**

| Line | Signal |
|---|---|
| h:32 | `void fullLockoutTimerEnded(bool on1, bool on2)` |
| h:33 | `void beeperOn()` |

**Protected method (critical):**

| Line | Method |
|---|---|
| h:36 | `void mouseReleaseEvent(QMouseEvent *) {accept();}` |

**Private methods:**

| Line | Method |
|---|---|
| cpp:77 | `void fullLockStart()` |
| cpp:84 | `void updateFullLock()` (slot, private) |

**UNIT_TEST friend:** `friend class TestDialog;` at h:28 (conditionally compiled under `#ifdef UNIT_TEST`), granting access to `ui` member.

**`setLockedReason` switch cases:** `MaintCriticalQuestion`, `MaintRedImpact`, `MaintSurveyTimeout`, `MaintIdle`, `default`.

---

### MessageDialog (`ui/messagedialog.h` + `ui/messagedialog.cpp`)

**Class:** `MessageDialog : public QDialog`

**Includes:**
- `messagedialog.h` (self)
- `ui_messagedialog.h` (generated)
- `<QMovie>`, `<QTimer>`, `<QDebug>`
- `<QDialog>`

**Defines:** `WAIT_AUTH_TIME 10000`, `NOT_AUTH_TIME 5000`

**Public enum `MessageType`** (h:18-27):
`NoMessage`, `ExpansionConnecting`, `WaitForAuthorised`, `NotAuthorised`, `OnDemandNotAuthorised`, `PowerOff`, `Reboot`, `VehicleOutOfService`

**Public methods (with line numbers):**

| Line | Method |
|---|---|
| h:29 | `explicit MessageDialog(QWidget *parent = 0)` — constructor |
| h:30 | `~MessageDialog()` — destructor |
| h:31 | `void openWithMessage(MessageType type)` — inline; calls `setMessageType(type); open()` |
| h:33 | `void setMessageType(MessageType type)` |
| h:34 | `MessageType messageType() const` — inline getter |

**Protected method:**

| Line | Method |
|---|---|
| h:37 / cpp:35 | `void hideEvent(QHideEvent *)` — stops timer and movie, resets `m_messageType` to `NoMessage` |

**UNIT_TEST friend:** None declared.

**Timer behaviour:** `WaitForAuthorised` starts a 10-second single-shot timer; on timeout transitions to `NotAuthorised`. `NotAuthorised`, `OnDemandNotAuthorised`, and `VehicleOutOfService` start a 5-second single-shot timer; on timeout calls `reject()`.

---

### onScreenKeyboard (`ui/onScreenKeyboard.h` + `ui/onScreenKeyboard.cpp`)

**Class:** `onScreenKeyboard : public QWidget`

**Includes:**
- `onScreenKeyboard.h` (self)
- `ui_onScreenKeyboard.h` (generated)
- `<QtGui>`, `<QWidget>`, `<QPushButton>`

**Public enums:**
- `KeyToggleState { Normal, Upper, Lower }` (h:17)
- `CaseButton { AllButtons, CapsButton, ShiftButton, SymbolButton }` (h:18)
- `CtrlButton { None, Backspace, Delete }` (h:19)

**Public methods (with line numbers):**

| Line | Method |
|---|---|
| h:20 | `explicit onScreenKeyboard(QWidget *parent = 0)` — constructor |
| h:21 | `~onScreenKeyboard()` — destructor |
| h:22 | `QPushButton *enterButton` — public data member |
| h:24 | `void setInitialText(QString str)` |
| h:25 | `void languageChanged(void)` |

**Signals (with line numbers):**

| Line | Signal |
|---|---|
| h:36 | `void updateText(QString str, CtrlButton ctrl)` |
| h:37 | `void onScreenKeyboardClose()` |

**Private slots (with line numbers):**

| Line | Slot |
|---|---|
| h:28 / cpp:61 | `void keyboardHandler()` — dispatches character key presses |
| h:29 / cpp:113 | `void on_btnShift_clicked(bool checked)` |
| h:30 / cpp:184 | `void on_btnEnter_clicked()` — clears `outputText`, resets case buttons, calls `close()` |
| h:31 / cpp:192 | `void on_btnBack_clicked()` — emits `updateText("", Backspace)` |
| h:32 / cpp:197 | `void on_btnCaps_toggled(bool checked)` |
| h:33 / cpp:202 | `void on_btnHideKeyboard_clicked()` — resets case, calls `close()` |
| h:34 / cpp:243 | `void on_btnDelete_clicked()` — emits `updateText("", Delete)` |

**Protected method:**

| Line | Method |
|---|---|
| h:40 / cpp:107 | `void closeEvent(QCloseEvent *event)` — emits `onScreenKeyboardClose()`, accepts event |

**Private methods (with line numbers):**

| Line | Method |
|---|---|
| h:43 / cpp:145 | `void toggle()` — updates all button labels based on Caps/Shift state |
| h:44 / cpp:127 | `QString dualCharCase(QString ch, int toggleState)` |
| h:45 / cpp:119 | `QString singleCharCase(QString ch, int toggleState)` |
| h:46 / cpp:209 | `void setCaseButton(CaseButton btn, bool set)` |

**Key behaviours of note:**
- `keyboardHandler()` reads `button->text()`, splits on `"\n"` for dual-character keys, applies caps/shift logic, then emits `updateText(outputText, None)`. There is no maximum input length guard.
- `on_btnBack_clicked()` emits `updateText("", Backspace)` — backspace is delegated to the receiver.
- `on_btnDelete_clicked()` emits `updateText("", Delete)` — delete (clear) is also delegated.
- `setInitialText()` sets `outputText` but does not pre-fill the display widget; no truncation.
- The SPACE button sets `outputText = " "` (a single space), not appending.
- The `"\\"` case at cpp:75-77 retrieves `ui->Buttonr->text()` rather than a literal backslash — this is a logic error with no test to catch it.

**UNIT_TEST friend:** None declared.

---

## Test Coverage Analysis

### Search results across the entire `test/` directory

**`LockedDialog` symbol hits:**
- `test_dialog.cpp:386` — `QVERIFY(!m_dialog->m_lockedDialog->isVisible())` — negative visibility check only
- `test_dialog.cpp:399` — `QVERIFY(m_dialog->m_lockedDialog->isVisible())` — positive visibility check
- `test_dialog.cpp:400` — `QVERIFY(m_dialog->m_lockedDialog->ui->labelReason->text().contains("Idle"))` — reason text, MaintIdle only

**`MessageDialog` symbol hits:** Zero matches in any test file.

**`onScreenKeyboard` symbol hits:** Zero matches in any test file.

**LockedDialog methods with any test coverage:**
- `startTimer()` — indirectly exercised when `lockScreen()` is called in `test_idleLockout()` and `test_unlockMode1()`, but only as a side-effect with no assertions on timer state.
- `setLockedReason()` — called indirectly via `lockScreen()`; the Idle reason label is checked once at line 400; no other codes are asserted.
- `stopTimer()` — no test assertions.
- `clearTimerText()` — no test assertions.
- `setTimeRemaining()` — no test assertions.
- `languageChanged()` — no test assertions.
- `fullLockStart()` / `updateFullLock()` — no test assertions.
- `fullLockoutTimerEnded` signal — no test assertions.
- `beeperOn` signal — no test assertions.
- `mouseReleaseEvent` — zero tests.

**MessageDialog methods with zero test coverage:** All — constructor, `openWithMessage`, `setMessageType` (all 7 enum paths), `messageType`, `hideEvent`.

**onScreenKeyboard methods with zero test coverage:** All — constructor, `setInitialText`, `languageChanged`, `keyboardHandler`, all button slots, `closeEvent`, all private helpers.

---

## Findings

---

**A22-1** · CRITICAL · Missing Security Test — Lock Bypass via Touch

**File:** `ui/lockeddialog.h:36`

**Description:** The `mouseReleaseEvent` override unconditionally calls `accept()` on any touch anywhere on the lock screen. This causes `LockedDialog::accepted` to fire, which is connected at `ui/dialog.cpp:112` to `Dialog::onPinCode()` — opening the PIN entry dialog. A prior security audit identified this as a touch-bypass vulnerability. Not a single test in the suite verifies that the lock screen enforces any authentication gate before the PIN dialog is opened. There is no test that simulates a raw touch or click event on `LockedDialog` and confirms the expected flow (PIN prompt required) versus an unexpected flow (immediate unlock). The `TestDialog` friend declaration (`h:28`) is conditionally compiled under `#ifdef UNIT_TEST`, meaning the test harness already has the access required to write such a test, yet none exists.

**Fix:** Add a dedicated test (e.g., `test_lockScreenBypass`) that:
1. Calls `m_dialog->lockScreen(CIGCONF::MaintRedImpact, true)` and verifies `m_lockedDialog->isVisible()` is true.
2. Uses `QTest::mouseClick(m_dialog->m_lockedDialog, Qt::LeftButton)` to simulate a tap on the locked dialog.
3. Asserts that `gCfg->maintCode()` remains `MaintRedImpact` and `m_dialog->m_authorisedDialog->isVisible()` is false — confirming that a PIN prompt (not an immediate unlock) is the result of the touch.
4. Verifies that submitting an incorrect PIN keeps the lock active and that `m_lockedDialog` is re-shown.
Additionally, consider whether `mouseReleaseEvent` should be guarded by `m_bleReady` or another precondition matching the guard already present in `Dialog::onPinCode()` at `ui/dialog.cpp:271`.

---

**A22-2** · HIGH · No Tests for Lock Reason Label (Non-Idle Codes)

**File:** `ui/lockeddialog.cpp:36–58`

**Description:** `setLockedReason()` has five distinct branches (`MaintCriticalQuestion`, `MaintRedImpact`, `MaintSurveyTimeout`, `MaintIdle`, and `default`). Only the `MaintIdle` branch is incidentally checked via a `.contains("Idle")` assertion at `test_dialog.cpp:400`. The remaining four branches — including the safety-critical `MaintRedImpact` and `MaintCriticalQuestion` codes — have zero test coverage. A regression could silently corrupt the label text shown to the operator for any non-idle lock reason without the test suite catching it.

**Fix:** Add parameterised test cases that directly call `m_dialog->m_lockedDialog->setLockedReason(code)` for each `MaintLockedCode` enum value and assert the exact `ui->labelReason->text()` string. The `friend class TestDialog` declaration in the header (h:28, compiled under `#ifdef UNIT_TEST`) grants access to the `ui` pointer, so no additional access mechanism is required.

---

**A22-3** · HIGH · No Tests for Full Lock Countdown Timer

**File:** `ui/lockeddialog.cpp:77–95`

**Description:** `fullLockStart()` and `updateFullLock()` implement a countdown that ultimately emits `fullLockoutTimerEnded(false, false)` — a signal connected in `ui/dialog.cpp:113–115` that closes vehicle relays and physically shuts down the machine. This safety-critical path has zero test coverage. No test verifies: that the timer fires with the correct 1-second interval; that `setTimeRemaining()` updates `lblLockOutTime` correctly; that the countdown decrements `m_timeCntr` to zero; that `fullLockoutTimerEnded` is emitted with `(false, false)` at expiry; or that `stopTimer()` halts the countdown. The `beeperOn` signal emitted from `startTimer()` is also never captured by any `QSignalSpy`.

**Fix:** Add a `test_fullLockTimer()` test that:
1. Sets `gCfg->fullLockoutEnable()` to true and `gCfg->fullLockoutTimeout()` to a small value (e.g., 2 seconds).
2. Calls `m_dialog->m_lockedDialog->startTimer()`.
3. Uses `QSignalSpy` on `beeperOn` to assert it fires exactly once.
4. Uses `QSignalSpy` on `fullLockoutTimerEnded` combined with `QTest::qWait(3000)` to assert the signal fires with arguments `(false, false)`.
5. Verifies intermediate `lblLockOutTime` label text during the countdown.
6. In a separate sub-test, calls `stopTimer()` mid-count and asserts `fullLockoutTimerEnded` does not fire.

---

**A22-4** · HIGH · MessageDialog Has Zero Test Coverage

**File:** `ui/messagedialog.cpp` (entire file), `ui/messagedialog.h` (entire file)

**Description:** `MessageDialog` is used in at least two security-relevant flows: showing `WaitForAuthorised` while the system connects to the server to validate a driver (cpp:62–75), and showing `NotAuthorised` after a failed authorisation attempt (cpp:77–88). The 10-second `WaitForAuthorised` → `NotAuthorised` auto-transition and the 5-second `NotAuthorised` auto-reject are entirely untested. No test verifies: that any message type sets the correct label text; that timers fire within expected windows; that `hideEvent` stops the timer and resets `m_messageType` to `NoMessage`; that `openWithMessage` invokes `open()`; or that `messageType()` returns the correct enum after `setMessageType()`. `MessageDialog` has no `UNIT_TEST` friend declaration, complicating white-box testing.

**Fix:** Create a `test_messageDialog()` test suite covering:
- Each `MessageType` variant: assert `messageType()` returns the expected value and the message label text matches the expected string.
- Timer auto-transitions: set `WaitForAuthorised`, use `QTest::qWait(11000)` (or a mocked timer interval) and assert `messageType() == NotAuthorised`.
- Auto-reject: set `NotAuthorised`, wait past `NOT_AUTH_TIME`, assert the dialog is no longer visible.
- `hideEvent`: call `hide()`, assert `messageType() == NoMessage`.
- Add `friend class TestDialog;` under `#ifdef UNIT_TEST` in `messagedialog.h` to allow inspection of private members.

---

**A22-5** · HIGH · onScreenKeyboard Has Zero Test Coverage

**File:** `ui/onScreenKeyboard.cpp` (entire file), `ui/onScreenKeyboard.h` (entire file)

**Description:** The on-screen keyboard is the primary text-input mechanism for PIN and driver-ID entry in the application. It has zero test coverage across all test files. Untested behaviours include: character key output; Shift toggle producing uppercase; Caps Lock toggle and its interaction with Shift (Caps+Shift = lowercase); number-row dual-character mode (e.g., `!` vs `1`); the `&&` special-character encoding at cpp:72 and cpp:80; the backslash edge case at cpp:75-77 that incorrectly returns `ui->Buttonr->text()` instead of a literal backslash; Backspace emitting `updateText("", Backspace)`; Delete emitting `updateText("", Delete)`; Enter resetting state and closing; Hide Keyboard resetting state and closing; `closeEvent` emitting `onScreenKeyboardClose`; and `setInitialText`.

**Fix:** Add a `test_onScreenKeyboard()` test suite with `QSignalSpy` on the `updateText` and `onScreenKeyboardClose` signals, covering:
1. Standard key press: click a letter button, assert `updateText("a", None)` is emitted.
2. Shift toggle: click Shift then a letter, assert uppercase output.
3. Caps Lock: toggle Caps on, assert uppercase; toggle Caps+Shift together, assert lowercase.
4. Numeric dual-char: click a number button without Shift, assert digit; with Shift, assert symbol (e.g., `!` for key `0`).
5. Backspace: click the back button, assert `updateText("", Backspace)` is emitted.
6. Delete: click the delete button, assert `updateText("", Delete)` is emitted.
7. Enter: spy on close, click Enter, assert `onScreenKeyboardClose` is emitted and `outputText` is reset.
8. `setInitialText`: call with a known string, verify `outputText` is set (requires `UNIT_TEST` friend or an accessor).
9. Maximum input length: verify behaviour when called with an oversized string (see A22-6).

---

**A22-6** · MEDIUM · No Maximum Input Length Enforcement or Test in onScreenKeyboard

**File:** `ui/onScreenKeyboard.cpp:56–59`, `ui/onScreenKeyboard.h:48`

**Description:** `setInitialText(QString str)` assigns `outputText = str` without any length limit. The class also has no guard in `keyboardHandler()` preventing emission when the accumulated text exceeds a sensible bound. No test exercises large-input behaviour. This could cause UI rendering anomalies or interact poorly with fixed-length backend fields (e.g., PIN codes or driver IDs that have maximum lengths defined elsewhere in the system).

**Fix:** Define a maximum length constant (e.g., `MAX_INPUT_LENGTH`) appropriate to the field type (e.g., 20 characters for a driver name, 8 for a PIN). Enforce it in `setInitialText()` by truncating the input and in `keyboardHandler()` by suppressing `updateText` emission when the current length is at the maximum. Add a test that calls `setInitialText()` with a string exceeding the limit, asserts the stored value is truncated, and confirms that additional key presses at the limit do not emit `updateText`.

---

**A22-7** · MEDIUM · No Test for Lock Screen Visibility Across All Lock Codes

**File:** `ui/lockeddialog.cpp:36–58`, `test/test_dialog.cpp`

**Description:** `test_idleLockout` only exercises the `MaintIdle` lock code (test_dialog.cpp:398). `test_unlockMode1` only exercises `MaintRedImpact` (test_dialog.cpp:474, 492). The codes `MaintCriticalQuestion` and `MaintSurveyTimeout` are never passed to `lockScreen()` in any test, meaning no test confirms that calling `lockScreen()` with these codes shows the lock screen, sets the correct `maintCode`, and displays the correct reason string.

**Fix:** Extend `test_unlockMode1` or add a new `test_lockScreenAllCodes` that calls `m_dialog->lockScreen(code, false)` for each `MaintLockedCode` value, asserts `m_dialog->m_lockedDialog->isVisible()` is true, and asserts `m_dialog->m_lockedDialog->ui->labelReason->text()` matches the expected string for that code.

---

**A22-8** · LOW · onScreenKeyboard Backslash Key Logic Error Is Untested

**File:** `ui/onScreenKeyboard.cpp:75–77`

**Description:** The branch `else if (inputText == "\\") { outputText = ui->Buttonr->text(); }` produces the current text label of the `r`/`R` button rather than a literal backslash character. This is almost certainly a logic error — a button labelled `\\` should emit `"\"`, not whatever `Buttonr` currently displays (which varies with Caps/Shift state). This defect goes undetected because no test routes a backslash button click through `keyboardHandler`.

**Fix:** Add a test that directly invokes the keyboard handler for the backslash button (or sets `sender()` equivalent via the button's `clicked()` signal) and asserts the emitted `updateText` signal carries the string `"\\"` (a single backslash character). Additionally, correct the production code: `outputText = "\\";` is the correct assignment, replacing the `ui->Buttonr->text()` reference.

---

## Summary Table

| Finding | Severity | Category | File:Line | Area |
|---|---|---|---|---|
| A22-1 | CRITICAL | Missing Security Test — Lock Bypass | `ui/lockeddialog.h:36` | `mouseReleaseEvent` unconditional `accept()`, zero tests |
| A22-2 | HIGH | Insufficient Coverage — Lock Reason Labels | `ui/lockeddialog.cpp:36–58` | `setLockedReason()` — 4 of 5 branches untested |
| A22-3 | HIGH | Missing Safety Test — Full Lock Countdown | `ui/lockeddialog.cpp:77–95` | `fullLockStart`, `updateFullLock`, `fullLockoutTimerEnded` signal |
| A22-4 | HIGH | Zero Coverage — MessageDialog | `ui/messagedialog.cpp` (entire) | All methods, all `MessageType` paths, timer transitions |
| A22-5 | HIGH | Zero Coverage — onScreenKeyboard | `ui/onScreenKeyboard.cpp` (entire) | All key handlers, signals, case/shift logic |
| A22-6 | MEDIUM | No Input Length Enforcement or Test | `ui/onScreenKeyboard.cpp:56–59` | `setInitialText`, `keyboardHandler` — no max-length guard |
| A22-7 | MEDIUM | Incomplete Lock Code Coverage | `test/test_dialog.cpp:474,492` | `MaintCriticalQuestion`, `MaintSurveyTimeout` never exercised |
| A22-8 | LOW | Logic Error Untested — Backslash Key | `ui/onScreenKeyboard.cpp:75–77` | Backslash branch emits `Buttonr->text()` not `"\\"` |

---

## Coverage Estimate by Class

| Class | Public Methods | Methods With Any Coverage | Estimated Coverage |
|---|---|---|---|
| `LockedDialog` | 6 public + 2 private | 1 partially (`startTimer` side-effect only) | ~5% |
| `MessageDialog` | 4 public + 1 protected | 0 | 0% |
| `onScreenKeyboard` | 4 public + 7 private slots + 1 protected | 0 | 0% |

**Overall assessment:** The three classes collectively have 0–5% meaningful test coverage. The most critical gap is the complete absence of any test validating that the unconditional `mouseReleaseEvent -> accept()` pathway in `LockedDialog` does not permit unauthenticated bypass of the lock screen — a vulnerability already identified by a prior security audit. The `fullLockoutTimerEnded` signal that triggers physical relay shutdown is likewise untested. `MessageDialog` and `onScreenKeyboard` are entirely uncovered. Immediate action is warranted on findings A22-1 through A22-5.
# Audit Report — Agent A23 — Pass 2: Test Coverage

**Agent:** A23
**Audit run:** 2026-02-28-01
**Branch confirmed:** master (verified via `git branch --show-current`)
**Date:** 2026-02-28

---

## Files Reviewed

| File | Lines |
|------|-------|
| `ui/ondemanddialog.h` | 49 |
| `ui/ondemanddialog.cpp` | 139 |
| `ui/optionalcheckconfirmationdialog.h` | 28 |
| `ui/optionalcheckconfirmationdialog.cpp` | 49 |
| `ui/pindialog.h` | 35 |
| `ui/pindialog.cpp` | 126 |
| `test/test_dialog.h` | 34 |
| `test/test_dialog.cpp` | 683 |

---

## Reading Evidence

### OnDemandDialog (`ui/ondemanddialog.h` + `ui/ondemanddialog.cpp`)

**Class:** `OnDemandDialog` — inherits `QDialog`

**Includes:**
- header: `<QDialog>`, `<QMap>`, `<QString>`, `<QPushButton>`, `<QTimer>`, `app/cigconfigs.h`
- cpp: `ondemanddialog.h`, `ui_ondemanddialog.h`, `app/globalconfigs.h`, `<QPalette>`

**Public methods:**

| Method | Line (header) | Notes |
|--------|--------------|-------|
| `OnDemandDialog(QWidget *parent = 0)` | h:20 | Constructor |
| `~OnDemandDialog()` | h:21 | Destructor |
| `setSuperMasterId(quint64 id)` | h:23 | Inline setter |
| `reset()` | h:24 | Resets state and calls `showEvent()` |
| `setTimeRemaining(quint32 secs)` | h:25 | Updates UI label |
| `showCustomTimeFormat(quint32 time)` | h:26 | Formats HH:MM:SS string |

**Signals:**

| Signal | Line |
|--------|------|
| `onDemandStarted(quint32 start, quint32 end, quint64 id, CIGCONF::OnDemandCmdSrc src)` | h:29 |
| `onDemandExtended(quint32 start, quint32 end, quint64 id, CIGCONF::OnDemandCmdSrc src)` | h:30 |
| `onDemandEnded(quint32 end, quint64 id, CIGCONF::OnDemandCmdSrc src)` | h:31 |

**Protected methods (connected as slots):**

| Method | Line (cpp) | Notes |
|--------|-----------|-------|
| `showEvent(QShowEvent *event = 0)` | cpp:31 | Sets UI text, enables/disables buttons based on active session, starts inactivity timer |
| `onStart()` | cpp:57 | Two-tap confirm pattern; emits `onDemandStarted` |
| `onExtend()` | cpp:74 | Two-tap confirm pattern; emits `onDemandExtended` |
| `onEnd()` | cpp:91 | Two-tap confirm pattern; emits `onDemandEnded` |

**Private methods:**

| Method | Line (cpp) | Notes |
|--------|-----------|-------|
| `debounce()` | cpp:106 | Returns false if same button pressed within 200 ms |

**Constants:** `NO_ACTIVITY_TIME = 10000` (10-second inactivity timer causes dialog to reject/close)

---

### OptionalCheckConfirmationDialog (`ui/optionalcheckconfirmationdialog.h` + `ui/optionalcheckconfirmationdialog.cpp`)

**Class:** `OptionalCheckConfirmationDialog` — inherits `QDialog`

**Includes:**
- header: `<QDialog>`
- cpp: `optionalcheckconfirmationdialog.h`, `ui_optionalcheckconfirmationdialog.h`, `<QTimer>`, `<QDebug>`

**Public methods:**

| Method | Line (header) | Notes |
|--------|--------------|-------|
| `OptionalCheckConfirmationDialog(QWidget *parent = 0)` | h:15 | Constructor |
| `~OptionalCheckConfirmationDialog()` | h:16 | Destructor |
| `onRefreshLanguage(void)` | h:17 | Refreshes all UI label text via `tr()` |

**Protected methods:**

| Method | Line | Notes |
|--------|------|-------|
| `hideEvent(QHideEvent *)` | h:24 / cpp:31 | Stops the 5-second auto-close timer |
| `showEvent(QShowEvent *event = 0)` | h:25 / cpp:19 | Sets UI labels, starts 5-second single-shot timer |

**Constants:** 5000 ms auto-reject timer (cpp:28)

---

### PinDialog (`ui/pindialog.h` + `ui/pindialog.cpp`)

**Class:** `PinDialog` — inherits `QDialog`; **security-critical** (controls vehicle access)

**Includes:**
- header: `<QDialog>`, forward-decl `QTimer`
- cpp: `pindialog.h`, `ui_pindialog.h`, `app/globalconfigs.h`, `<QDebug>`, `<QTimer>`, `<QThread>`, `<QApplication>`

**Public methods:**

| Method | Line (header) | Notes |
|--------|--------------|-------|
| `PinDialog(QWidget *parent = 0)` | h:17 | Constructor; connects btn0-btn9, btnStar, btnClear, btnBack to `keyPressed()`; btnHash and btnEnter to `accept()`; btnCancel to `reject()`; timer to `reject()` |
| `~PinDialog()` | h:18 | Destructor |
| `pinCode() const` | h:20 / cpp:97 | Returns `quint32`; iterates chars, stops at first non-digit (handles trailing '#') |
| `clearPinCode()` | h:21 / cpp:112 | Clears `lineEdit` and `labelPin` |
| `languageChanged()` | h:22 / cpp:118 | Refreshes UI button labels via `tr()` |

**Protected methods:**

| Method | Line |
|--------|------|
| `showEvent(QShowEvent *)` | cpp:92 — starts 30-second activity timer |
| `hideEvent(QHideEvent *)` | cpp:87 — stops activity timer |

**Private methods:**

| Method | Line (cpp) | Notes |
|--------|-----------|-------|
| `keyPressed()` | cpp:47 | Static debounce (50 ms). Handles btnClear, btnBack, digit/star insertion. Auto-accepts when `maxLength` (5) reached. Star ('*') can be inserted as a character. |

**UI-level constraints:**
- `lineEdit` `maxLength` = 5 (set in `pindialog.ui`:503)
- `lineEdit` `echoMode` = `QLineEdit::PasswordEchoOnEdit` (ui:506)

**Constants:**
- `PIN_MAX_LENGTH = 5` (cpp:9) — defined but not used in code; actual limit comes from `ui->lineEdit->maxLength()` which is also 5
- `ACTIVITY_TIME = 30000` ms auto-reject (cpp:10)

**Authentication flow:**
- `onPinDialogAccepted()` in `dialog.cpp:319` calls `pinCode()`, converts to `quint64`, passes to `login()` via `WiegandRfid::wiegandData(0, code)` (dialog.cpp:322)
- No attempt-counter, no PIN-level lockout, no rate-limiting beyond the 50 ms debounce in `keyPressed()`
- `btnEnter` and `btnHash` are wired directly to `QDialog::accept()`, bypassing `keyPressed()` entirely — so they can submit with an empty PIN field

---

## Test Coverage Analysis

**Primary test file:** `test/test_dialog.cpp` + `test/test_dialog.h`

**Test cases declared in `test_dialog.h`:**
- `test_enums`
- `test_globalConfigs`
- `test_idleLockout`
- `test_showPreopSummary`
- `test_unlockMode1`
- `test_showTime`

**Grep for `OnDemandDialog`, `OptionalCheckConfirmationDialog`, `PinDialog` in `test/`:** **Zero matches found.**

**Grep for method names** (`pinCode`, `clearPinCode`, `languageChanged`, `keyPressed`, `onStart`, `onExtend`, `onEnd`, `debounce`, `setTimeRemaining`, `showCustomTimeFormat`, `onRefreshLanguage`) **in `test/`:** **Zero matches found.**

All other test files (`test_backgroundworker.cpp`, `test_canbus.cpp`, `test_ota.cpp`) also contain no references to any of the three dialog classes.

**Conclusion:** None of the three assigned classes have any automated test coverage whatsoever.

---

## Findings

---

**A23-1** · CRITICAL · Missing Test Coverage — Security-Critical Class Entirely Untested
**File:** `ui/pindialog.cpp:1` (entire class)
**Description:** `PinDialog` is the sole software mechanism by which a driver enters a PIN code to authenticate with the vehicle control system. A correct PIN causes `Dialog::login()` to be called with a Wiegand-encoded credential, granting access to vehicle relays. The entire class — including `pinCode()`, `clearPinCode()`, `keyPressed()`, the auto-accept-on-max-length behaviour at `cpp:81-84`, the 30-second activity timeout, and the full submission path — has zero test coverage. There is not a single reference to `PinDialog`, `pinCode`, `clearPinCode`, or `keyPressed` anywhere in the `test/` directory.
**Fix:** Add a dedicated `TestPinDialog` test suite in `test/test_dialog.cpp` or a new `test/test_pindialog.cpp` that instantiates `PinDialog` directly and exercises: (1) correct PIN accepted and `pinCode()` returns expected value; (2) incorrect/wrong PIN results in a downstream rejection; (3) PIN with non-digit characters (especially `*`) returns only the numeric prefix from `pinCode()`; (4) PIN exactly at max-length (5 digits) triggers auto-accept; (5) entering more than 5 characters is blocked by `maxLength`; (6) the 30-second inactivity timeout fires `reject()`; (7) `clearPinCode()` resets both `lineEdit` and `labelPin`; (8) `languageChanged()` updates label text.

---

**A23-2** · HIGH · Missing Test Coverage — No Wrong-PIN Rejection Test
**File:** `ui/dialog.cpp:319` (`onPinDialogAccepted`)
**Description:** There is no test verifying that entering a wrong PIN causes login to fail and access to be denied. `onPinDialogAccepted()` calls `login()` unconditionally with whatever `pinCode()` returns; it is the `login()` function's `isValidId()` check that rejects unknown IDs. No test exercises the path where a PIN is entered, `pinCode()` returns a value not in the configured driver/master lists, and the system correctly shows "Not Authorised" without granting vehicle access.
**Fix:** Add a test that configures a known valid PIN driver ID, has the PIN dialog accept with a different (wrong) PIN value, and then verifies the rejection message dialog is shown and the authorised screen is not visible.

---

**A23-3** · HIGH · Missing Test Coverage — No Brute-Force / Max-Attempts / Lockout Test
**File:** `ui/pindialog.cpp:47` (`keyPressed`) and `ui/dialog.cpp:319` (`onPinDialogAccepted`)
**Description:** There is no lockout mechanism for repeated wrong PIN attempts, and consequently no test for one. A physical attacker with access to the touchscreen can try all 100,000 possible 5-digit PINs (00000-99999) limited only by the 50 ms debounce, permitting approximately 20 attempts per second. At that rate exhaustive search takes under 90 minutes. No test verifies any rate-limiting, attempt-counting, or lockout policy after N consecutive wrong PINs.
**Fix:** Implement a failed-attempt counter in `Dialog::onPinDialogAccepted()` or in `PinDialog`; lock out further PIN attempts (e.g., clear and disable the dialog for a configurable duration) after a threshold such as 5 failures. Add tests that simulate reaching the threshold and verify the lockout is applied, and that it resets correctly after the timeout or supervisor intervention.

---

**A23-4** · HIGH · Missing Test Coverage — Star ('*') Character Insertable into PIN Field
**File:** `ui/pindialog.cpp:29` + `cpp:70-71`
**Description:** `btnStar` (UI text `"*"`) is connected to `keyPressed()`. Inside `keyPressed()`, only `btnClear` and `btnBack` are handled specially; all other buttons — including `btnStar` — call `ui->lineEdit->insert(btn->text())` without digit validation (cpp:71). `pinCode()` (cpp:101-103) stops parsing at the first non-digit, so a PIN of `"1*234"` (5 characters, maxLength satisfied) would auto-accept the dialog and yield `pinCode() == 1` — a value that may match a configured driver ID of `1`, bypassing the intended PIN. No test covers this non-digit-insertion path.
**Fix:** In `keyPressed()`, validate that the sender's button text is a single decimal digit before calling `insert()`; alternatively apply a `QIntValidator` on `lineEdit`. Add tests that simulate pressing `btnStar` followed by digits and verify the star is not inserted and `pinCode()` returns the correct value.

---

**A23-5** · HIGH · Missing Test Coverage — Empty PIN Submission via ENTER / HASH
**File:** `ui/pindialog.cpp:34-35`
**Description:** `btnEnter` and `btnHash` are connected directly to `QDialog::accept()`, not to `keyPressed()`. This means a user can press ENTER or `#` with an empty `lineEdit` (zero characters), which emits `accepted` and causes `onPinDialogAccepted()` to call `pinCode()`, which returns `0` for an empty field. If a driver with the Wiegand-encoded form of PIN `0` exists in configuration, the vehicle is unlocked with a zero-length PIN entry. No test validates that an empty-PIN submission is either prevented or correctly rejected downstream.
**Fix:** Either disable `btnEnter`/`btnHash` when the PIN field is empty (connect to a slot that checks `lineEdit->text().isEmpty()` before calling `accept()`), or validate in `onPinDialogAccepted()` that `pinCode() != 0` or that `lineEdit` is non-empty before calling `login()`. Add a test simulating ENTER with an empty PIN and verifying no authorised screen appears.

---

**A23-6** · MEDIUM · Missing Test Coverage — OnDemandDialog Entirely Untested
**File:** `ui/ondemanddialog.cpp:1` (entire class)
**Description:** `OnDemandDialog` controls On Demand mode — a high-privilege operation that starts, extends, or ends a 24-hour operational session that enables vehicle use. The two-tap confirm pattern in `onStart()`, `onExtend()`, `onEnd()` (cpp:62,79,96), the 10-second inactivity auto-close (cpp:54), `debounce()` (cpp:106-115), `setTimeRemaining()` (cpp:131-138), and `showCustomTimeFormat()` (cpp:123-129) all have zero test coverage. In particular the two-tap confirm guard is a security-relevant UI pattern preventing accidental session activation and is never tested.
**Fix:** Add tests covering: (1) single tap sets button to "Confirm?" but does not emit the signal; (2) two taps in succession emit the correct signal with correct timestamps; (3) the 10-second inactivity timer cancels a pending "Confirm?" state; (4) `debounce()` suppresses a double-tap within 200 ms; (5) `setTimeRemaining(0)` and `setTimeRemaining(N)` display correct label text; (6) `showCustomTimeFormat()` correctly formats boundary values (0, 3599, 3600, 86399).

---

**A23-7** · MEDIUM · Missing Test Coverage — OnDemandDialog Button State Logic Untested
**File:** `ui/ondemanddialog.cpp:44-52` (`showEvent`)
**Description:** `showEvent()` enables/disables Start, Extend, and End buttons based on whether `gCfg->onDemandStartTime()` is set and whether `gCfg->onDemandEndTime() > gCfg->localTimestamp()`. No test verifies that the correct button combination is enabled when a session is active versus when no session exists. A bug in this logic could allow operators to start duplicate sessions or prevent ending an active session.
**Fix:** In the `OnDemandDialog` test suite, configure global config to simulate an active session and verify `btnStart` is disabled while `btnExtend` and `btnEnd` are enabled; then do the inverse with no active session.

---

**A23-8** · MEDIUM · Missing Test Coverage — OptionalCheckConfirmationDialog Entirely Untested
**File:** `ui/optionalcheckconfirmationdialog.cpp:1` (entire class)
**Description:** `OptionalCheckConfirmationDialog` is presented to ask a driver whether they wish to perform an optional pre-operation safety check. It has a 5-second auto-reject timer (cpp:28) that silently skips the optional check if it fires. The `onRefreshLanguage()` method, the `showEvent` timer start, and the `hideEvent` timer stop are all untested. No test verifies that the 5-second timeout produces a `rejected()` signal, that YES produces `accepted()`, or that NO produces `rejected()`.
**Fix:** Add tests for: (1) YES button emits `accepted()`; (2) NO button emits `rejected()`; (3) 5-second timer expiry emits `rejected()`; (4) `onRefreshLanguage()` correctly updates label text; (5) hiding the dialog stops the timer so it does not fire after the dialog is already closed.

---

**A23-9** · LOW · Missing Test Coverage — `showCustomTimeFormat` Boundary and Overflow Values
**File:** `ui/ondemanddialog.cpp:123`
**Description:** `showCustomTimeFormat()` is public and performs integer arithmetic with a `quint32` input. The method is used in both `OnDemandDialog` (cpp:136) and `Dialog` (dialog.cpp:1052, 1212). For very large values (e.g., near `UINT32_MAX`), the hours division could produce a value exceeding the `qint32` signed range since `h` is declared `qint32` (cpp:124). No test exercises boundary values, zero, large values, or exactly 3600 seconds.
**Fix:** Add unit tests for `showCustomTimeFormat(0)` == `"00:00:00"`, `showCustomTimeFormat(59)` == `"00:00:59"`, `showCustomTimeFormat(3600)` == `"01:00:00"`, `showCustomTimeFormat(86399)` == `"23:59:59"`, and `showCustomTimeFormat(UINT32_MAX)` to verify correct output and absence of overflow or formatting errors. Consider changing `h`, `m`, `s` to `quint32` to avoid signed/unsigned mismatch.

---

## Summary Table

| ID | Severity | Category | File | Description |
|----|----------|----------|------|-------------|
| A23-1 | CRITICAL | Missing Coverage | `ui/pindialog.cpp:1` | Entire `PinDialog` class has zero tests |
| A23-2 | HIGH | Missing Coverage | `ui/dialog.cpp:319` | No test for wrong-PIN rejection |
| A23-3 | HIGH | Missing Coverage | `ui/pindialog.cpp:47` | No brute-force / max-attempts / lockout test |
| A23-4 | HIGH | Missing Coverage | `ui/pindialog.cpp:29,70` | Star ('*') insertable into PIN field; not tested |
| A23-5 | HIGH | Missing Coverage | `ui/pindialog.cpp:34` | Empty PIN submittable via ENTER/HASH; not tested |
| A23-6 | MEDIUM | Missing Coverage | `ui/ondemanddialog.cpp:1` | Entire `OnDemandDialog` class has zero tests |
| A23-7 | MEDIUM | Missing Coverage | `ui/ondemanddialog.cpp:44` | Button enable/disable state logic on `showEvent` untested |
| A23-8 | MEDIUM | Missing Coverage | `ui/optionalcheckconfirmationdialog.cpp:1` | Entire `OptionalCheckConfirmationDialog` has zero tests |
| A23-9 | LOW | Missing Coverage | `ui/ondemanddialog.cpp:123` | `showCustomTimeFormat()` not tested for boundary/overflow values |
# Audit Report — Agent A24 — Pass 2: Test Coverage

**Agent:** A24
**Audit Run:** 2026-02-28-01
**Pass:** 2 — Test Coverage
**Branch confirmed:** master (verified via `git branch --show-current`)
**Date:** 2026-02-28

---

## Files Under Audit

| # | Source File | Header File |
|---|-------------|-------------|
| 1 | `ui/preopscreenoverlay.cpp` | `ui/preopscreenoverlay.h` |
| 2 | `ui/supervisordialog.cpp` | `ui/supervisordialog.h` |
| 3 | `ui/unlockeddialog.cpp` | `ui/unlockeddialog.h` |

**Primary test file read:** `test/test_dialog.cpp` + `test/test_dialog.h`
**Additional test files searched:** `test/test_backgroundworker.cpp`, `test/test_canbus.cpp`, `test/test_ota.cpp`

---

## Reading Evidence

### File Set 1 — PreopScreenOverlay

**Class:** `PreopScreenOverlay` extends `QDialog`

**Includes (preopscreenoverlay.cpp):**
- `"preopscreenoverlay.h"` (line 1)
- `"ui_preopscreenoverlay.h"` (line 2)

**Public methods:**

| Method | .h line | .cpp line | Notes |
|--------|---------|-----------|-------|
| `explicit PreopScreenOverlay(QWidget *parent = 0)` | 15 | 4 | Constructor; calls `ui->setupUi(this)` |
| `~PreopScreenOverlay()` | 16 | 16 | Deletes `ui` |
| `void onUpdatePreopTimer(QString time)` | 18 | 11 | Sets `lblPreopTimer` text to `tr("Time Remaining") + ": " + time` |

**Signals:** None declared.
**Slots:** None declared (no `Q_OBJECT` slots; `onUpdatePreopTimer` is a plain public method used as a slot target via `connect` in `dialog.cpp:142`).
**Private members:** `Ui::PreopScreenOverlay *ui` (line 21, .h)
**No `#ifdef UNIT_TEST` friend class declared.**

---

### File Set 2 — SupervisorDialog

**Class:** `SupervisorDialog` extends `QDialog`

**Includes (supervisordialog.cpp):**
- `"supervisordialog.h"` (line 1)
- `"ui_supervisordialog.h"` (line 2)
- `"app/globalconfigs.h"` (line 3)
- `"ui/vorconfirmationdialog.h"` (line 4)
- `"ui/warningdialog.h"` (line 5)

**Includes (supervisordialog.h):**
- `"app/cigconfigs.h"` (line 4)
- `<QDialog>` (line 5)
- `<QTimer>` (line 6)

**Public methods:**

| Method | .h line | .cpp line | Notes |
|--------|---------|-----------|-------|
| `explicit SupervisorDialog(QWidget *parent = nullptr)` | 20 | 10 | Constructor; wires all button connections and timers |
| `~SupervisorDialog()` | 21 | 47 | Deletes `ui` |
| `void setMasterOptions(CIGCONF::MasterId m)` | 23 | 172 | Sets button visibility by option bitmask |
| `void setTransportOptions()` | 24 | 202 | Hides VOR/Unlock/Maintenance; shows NormalDriver |

**Signals:**

| Signal | .h line | Notes |
|--------|---------|-------|
| `void startMasterSession()` | 31 | Emitted on unlock vehicle / normal driver confirm |
| `void startMaintenanceSession()` | 32 | Emitted on maintenance mode confirm |
| `void onVORUpdate()` | 33 | Emitted after VOR toggled |

**Protected slots:**

| Method | .h line | .cpp line | Notes |
|--------|---------|-----------|-------|
| `void showEvent(QShowEvent *event = 0)` | 49 | 52 | Refreshes UI text, starts 10 s inactivity timer |

**Private slots:**

| Method | .h line | .cpp line | Notes |
|--------|---------|-----------|-------|
| `void onUnlkVehicle()` | 52 | 88 | Two-tap confirm pattern; emits `startMasterSession` on confirm |
| `void onNormalDriverAccess()` | 53 | 106 | Two-tap confirm pattern; opens warning dialog, emits `startMasterSession` |
| `void onActivateVOR()` | 54 | 144 | Toggles VOR via `gCfg->setConvor`; emits `onVORUpdate` |
| `void openConfirmationDialog()` | 55 | 126 | Two-tap confirm pattern; opens VOR confirmation dialog |
| `void on_btnMaintenanceMode_clicked()` | 56 | 211 | Two-tap confirm pattern; opens maintenance warning dialog |

**Private methods:**

| Method | .h line | .cpp line | Notes |
|--------|---------|-----------|-------|
| `bool debounce()` | 37 | 155 | Returns false if < 200 ms since last press |
| `void reset()` | 38 | 166 | Resets `m_lastPress = 0`; calls `showEvent()` |

**Private members:** `Ui::SupervisorDialog *ui`, `QTimer *m_timer` (10 s inactivity), `QTimer *m_resetTimer` (2 s confirm reset), `quint32 m_lastPress`, `CIGCONF::MasterId m_master`, `VORConfirmationDialog *m_vorConfirmationDialog`, `WarningDialog *m_maintWarningDialog`, `WarningDialog *m_warningDialog`

**`#ifdef UNIT_TEST` friend class `TestDialog` declared at line 27, .h.**

**Defined constants:**
- `NO_ACTIVITY_TIME 10000` ms (line 7, .cpp)
- `RESET_TIME 2000` ms (line 8, .cpp)

---

### File Set 3 — UnlockedDialog

**Class:** `UnlockedDialog` extends `QDialog`

**Includes (unlockeddialog.cpp):**
- `"unlockeddialog.h"` (line 1)
- `"ui_unlockeddialog.h"` (line 2)
- `"app/globalconfigs.h"` (line 3)

**Includes (unlockeddialog.h):**
- `<QDialog>` (line 4)

**Public enum:**

| Enum value | .h line | Meaning |
|------------|---------|---------|
| `UnlockNoChecklist` | 15 | No checklist needed — hide labels, show "No questions" tip |
| `UnlockChecklist` | 15 | Checklist required — show unlock and warning labels |
| `UnlockOnly` | 15 | Unlock only — show unlock and warning labels, return-to-login tip |

**Public methods:**

| Method | .h line | .cpp line | Notes |
|--------|---------|-----------|-------|
| `explicit UnlockedDialog(QWidget *parent = 0)` | 17 | 5 | Constructor; sets OK icon; connects `btnOk` to `accept()` |
| `~UnlockedDialog()` | 18 | 18 | Deletes `ui` |
| `void setMode(Mode m)` | 20 | 23 | Switches label text/visibility by mode |
| `void languageChanged()` | 21 | 42 | Updates `label_3` text to `tr("OK")` |

**Signals:** None.
**Slots:** None explicitly declared; `accept()` is inherited from `QDialog`.
**Private members:** `Ui::UnlockedDialog *ui`
**`#ifdef UNIT_TEST` friend class `TestDialog` declared at line 23, .h.**

---

## Test Coverage Analysis

### Test Suite Inventory

`test/test_dialog.h` declares the following test slots:
- `test_enums()` — enum value checks
- `test_globalConfigs()` — config read/write/reset
- `test_idleLockout()` — idle lockout lock/unlock flow
- `test_showPreopSummary()` — checklist summary display
- `test_unlockMode1()` — unlock mode 0 and mode 1 flows (main test touching all three dialogs)
- `test_showTime()` — time display formats

No additional test files in `test/` contain references to `PreopScreenOverlay`, `SupervisorDialog`, or `UnlockedDialog`.

### SupervisorDialog — Coverage Matrix

| Method / Behaviour | Tested | Test Location |
|--------------------|--------|---------------|
| Constructor | Indirectly (via `m_dialog` setup) | `initTestCase` |
| `setMasterOptions()` | **No** | — |
| `setTransportOptions()` | **No** | — |
| `showEvent()` | **No** (never called directly) | — |
| `onUnlkVehicle()` — first tap (set "Confirm?") | **No** | — |
| `onUnlkVehicle()` — second tap (emit `startMasterSession`) | Partial (button text pre-set by test) | `test_unlockMode1` lines 477–478, 494–495 |
| `onNormalDriverAccess()` | **No** | — |
| `openConfirmationDialog()` / `onActivateVOR()` | **No** | — |
| `on_btnMaintenanceMode_clicked()` | **No** | — |
| `debounce()` | **No** | — |
| `reset()` | **No** | — |
| Inactivity timer auto-dismiss (10 s) | **No** | — |
| `startMasterSession` signal verified | **No** (signal not spy'd) | — |
| `startMaintenanceSession` signal verified | **No** | — |
| `onVORUpdate` signal verified | **No** | — |
| Two-tap confirm resets on timer | **No** | — |

### UnlockedDialog — Coverage Matrix

| Method / Behaviour | Tested | Test Location |
|--------------------|--------|---------------|
| `setMode(UnlockOnly)` | Indirectly (checked `isVisible()` + label text) | `test_unlockMode1` lines 497–498 |
| `setMode(UnlockChecklist)` | **No** | — |
| `setMode(UnlockNoChecklist)` | **No** | — |
| `languageChanged()` | **No** | — |
| `accept()` triggers correct downstream state | Partial (mode 0 and mode 1 post-accept states checked) | `test_unlockMode1` lines 481–484, 499–504 |
| `setMode(UnlockOnly)` label hide/show verified | **No** (only text checked, not visibility of labelLocked/labelWarning) | — |
| Dialog visibility after accept (locked back to login) | Checked indirectly | `test_unlockMode1` lines 501–502 |

### PreopScreenOverlay — Coverage Matrix

| Method / Behaviour | Tested | Test Location |
|--------------------|--------|---------------|
| Constructor | **No** | — |
| `onUpdatePreopTimer()` — valid time string | **No** | — |
| `onUpdatePreopTimer()` — empty string | **No** | — |
| `onUpdatePreopTimer()` — very long string | **No** | — |
| Dialog show / hide lifecycle | **No** | — |

---

## Findings

---

**A24-1** · HIGH · Missing Test Coverage — Security-Sensitive Flow
**File:** `ui/supervisordialog.cpp:88` / `test/test_dialog.cpp` (absent)
**Description:** The `onUnlkVehicle()` two-tap confirmation path is never tested starting from the first tap. The test suite pre-sets `ui->btnUnlkVehicle->setText("Confirm?")` before calling `onUnlkVehicle()`, bypassing the first-tap code path (lines 96–99 of `supervisordialog.cpp`). This means the normal user-facing flow — where the first tap changes the label to "Confirm?" and the confirm reset timer arms — is entirely untested. An error in this branch (e.g., the reset timer failing to arm, or the UI string comparison failing under a locale change) would go undetected.
**Fix:** Add a test case that calls `onUnlkVehicle()` twice in sequence without pre-setting the button text, verifying the intermediate "Confirm?" state after the first call and the `startMasterSession` signal emission after the second call.

---

**A24-2** · HIGH · Missing Test Coverage — Security-Sensitive Flow
**File:** `ui/supervisordialog.cpp:106` / `test/test_dialog.cpp` (absent)
**Description:** `onNormalDriverAccess()` is never exercised by any test. This slot both emits `startMasterSession` (granting normal driver access) and opens a `WarningDialog`. Neither the two-tap confirmation pattern, nor the signal emission, nor the warning dialog interaction, is verified. A regression in this code path could grant unauthorised access silently.
**Fix:** Add a dedicated test that simulates both taps of the Normal Driver Access button, uses `QSignalSpy` to confirm `startMasterSession` is emitted exactly once, and checks that the `m_warningDialog` is opened.

---

**A24-3** · HIGH · Missing Test Coverage — Security-Sensitive Flow
**File:** `ui/supervisordialog.cpp:211` / `test/test_dialog.cpp` (absent)
**Description:** `on_btnMaintenanceMode_clicked()` is completely untested. This slot triggers `startMaintenanceSession`, which is a privileged session type. The two-tap confirmation, the `m_maintWarningDialog` interaction, and the `startMaintenanceSession` signal are all untested. A defect here could allow unintended elevation to maintenance mode or prevent legitimate maintenance access.
**Fix:** Add a test case that triggers `on_btnMaintenanceMode_clicked()` twice, spies on `startMaintenanceSession`, and verifies the maintenance warning dialog is shown before the session starts.

---

**A24-4** · HIGH · Missing Test Coverage — Security-Sensitive Flow
**File:** `ui/supervisordialog.cpp:126` / `test/test_dialog.cpp` (absent)
**Description:** `openConfirmationDialog()` and `onActivateVOR()` are never tested. VOR (Vehicle Off Road) status is a safety-critical system flag. Neither the toggle logic (`gCfg->setConvor`) nor the `onVORUpdate` signal emission is verified. The `VORConfirmationDialog` interaction path (both accepted and rejected) is also untested.
**Fix:** Add tests that: (1) invoke `openConfirmationDialog()` twice to reach the VOR confirmation dialog; (2) simulate accept and reject on `m_vorConfirmationDialog`; (3) use `QSignalSpy` to confirm `onVORUpdate` is emitted only on accept; (4) verify the `convorStatus` toggled correctly via `gCfg`.

---

**A24-5** · MEDIUM · Missing Test Coverage — Inactivity Timer Dismiss
**File:** `ui/supervisordialog.cpp:38-41, 85` / `test/test_dialog.cpp` (absent)
**Description:** The 10-second inactivity timer that auto-dismisses the SupervisorDialog via `reject()` is never tested. If this timer fires incorrectly (e.g., during an active two-tap confirmation sequence), it would reset the dialog and potentially allow a partial-confirm state to persist undetected. No test verifies that the dialog is dismissed after inactivity.
**Fix:** Add a test that shows the `SupervisorDialog`, waits at least `NO_ACTIVITY_TIME` (10 000 ms) or directly calls `m_timer->timeout()`, and asserts `isVisible()` returns false.

---

**A24-6** · MEDIUM · Missing Test Coverage — Confirm Reset Timer
**File:** `ui/supervisordialog.cpp:102, 121, 141, 228` / `test/test_dialog.cpp` (absent)
**Description:** The 2-second reset timer (`m_resetTimer`) that cancels the "Confirm?" state (via `reset()`) is never tested. If this timer fires prematurely or fails to fire, a stale "Confirm?" label would allow a single tap to complete a privileged action, bypassing the intended two-tap confirmation guard.
**Fix:** Add a test that initiates the first tap (entering "Confirm?" state), waits at least `RESET_TIME` (2 000 ms) or directly triggers `m_resetTimer->timeout()`, and verifies the button text has reverted to its original value.

---

**A24-7** · MEDIUM · Missing Test Coverage — `debounce()` Not Tested
**File:** `ui/supervisordialog.cpp:155` / `test/test_dialog.cpp` (absent)
**Description:** The `debounce()` function, which rejects any button press within 200 ms of the last, is never directly exercised. All tests call `onUnlkVehicle()` once with a pre-set button label, so the debounce guard is passed only incidentally. There is no test that sends two rapid calls and confirms the second is rejected, nor one that confirms the function returns `true` after the 200 ms window.
**Fix:** Add a test that calls an action slot twice within < 200 ms and verifies the second call is a no-op (e.g., `startMasterSession` spy count remains 0); then call again after > 200 ms and verify the action proceeds.

---

**A24-8** · MEDIUM · Missing Test Coverage — `setMasterOptions()` Bitmask Permutations
**File:** `ui/supervisordialog.cpp:172` / `test/test_dialog.cpp` (absent)
**Description:** `setMasterOptions()` controls which action buttons are visible based on a `CIGCONF::MasterId.option` bitmask (`UnlockVehicle=1`, `NormalDriverAccess=2`, `ActivateVOR=4`, `MaintenanceMode=8`). No test exercises this method with any permutation of the bitmask. If a button is incorrectly made visible (or hidden) for a given master role, the error is invisible to the test suite.
**Fix:** Add tests covering at least: (a) `option = 0` (all buttons hidden); (b) each single-bit option (one button visible); (c) `DefaultMasterMenu=7` (UnlockVehicle + NormalDriverAccess + ActivateVOR visible, MaintenanceMode hidden); (d) `UnassignedMasterMenu=255` (all visible).

---

**A24-9** · MEDIUM · Missing Test Coverage — `setTransportOptions()`
**File:** `ui/supervisordialog.cpp:202` / `test/test_dialog.cpp` (absent)
**Description:** `setTransportOptions()` is never tested. This method hides VOR, UnlockVehicle, and MaintenanceMode buttons and shows only NormalDriverAccess. An error here could expose restricted controls to transport-mode operators.
**Fix:** Add a test that calls `setTransportOptions()` and asserts visibility: `btnActivateVOR` = hidden, `btnUnlkVehicle` = hidden, `btnMaintenanceMode` = hidden, `btnNormalDriver` = visible.

---

**A24-10** · MEDIUM · Missing Test Coverage — `UnlockedDialog::setMode()` All Modes
**File:** `ui/unlockeddialog.cpp:23` / `test/test_dialog.cpp` (absent)
**Description:** `setMode()` has three branches (`UnlockOnly`, `UnlockChecklist`, `UnlockNoChecklist`). Only `UnlockOnly` is exercised in `test_unlockMode1`, and even that test only checks label text — not the visibility of `labelLocked` and `labelWarning`. The `UnlockChecklist` and `UnlockNoChecklist` modes are completely untested. A regression in label visibility logic (e.g., `hide()` / `show()`) would not be caught.
**Fix:** Add three dedicated sub-cases within a test for `UnlockedDialog::setMode()`: verify text content and `isVisible()` state of `labelLocked`, `labelWarning`, and `labelTip` for each of the three modes.

---

**A24-11** · MEDIUM · Missing Test Coverage — `UnlockedDialog::languageChanged()`
**File:** `ui/unlockeddialog.cpp:42` / `test/test_dialog.cpp` (absent)
**Description:** `languageChanged()` is never called in any test. This method updates `label_3` with `tr("OK")`. If a Qt translation install causes the wrong widget to be updated (e.g., a refactor changes the UI object name from `label_3`), the bug would go undetected.
**Fix:** Call `languageChanged()` in a test and verify that `ui->label_3->text()` equals the expected "OK" string.

---

**A24-12** · LOW · Missing Test Coverage — `PreopScreenOverlay` Completely Untested
**File:** `ui/preopscreenoverlay.cpp:11` / `test/test_dialog.cpp` (absent)
**Description:** `PreopScreenOverlay` has zero test coverage. The class has no `#ifdef UNIT_TEST` friend declaration, and no test file anywhere in `test/` references `PreopScreenOverlay`, `m_overlay`, or `onUpdatePreopTimer`. The single substantive method — `onUpdatePreopTimer(QString time)` — concatenates the raw `time` parameter directly into a label without validation. There is no test for: normal time string display; empty string behaviour; or a pathologically long string that could break UI layout.
**Fix:** Add `#ifdef UNIT_TEST friend class TestDialog; #endif` to `preopscreenoverlay.h`, then add tests verifying: (1) `onUpdatePreopTimer("5:23")` results in label text `"Time Remaining: 5:23"`; (2) empty string `""` results in label `"Time Remaining: "`; (3) the overlay is visible when shown by `Dialog`.

---

**A24-13** · LOW · Missing Signal Emission Verification — `startMasterSession`
**File:** `ui/supervisordialog.cpp:94, 114` / `test/test_dialog.cpp:478, 495`
**Description:** Although `test_unlockMode1` calls `onUnlkVehicle()` and observes downstream effects (e.g., `m_unlockedDialog->isVisible()`), it never uses `QSignalSpy` to directly verify that `startMasterSession` is emitted. Downstream dialog state may change for reasons other than the signal (e.g., a direct method call), masking a missing signal emission.
**Fix:** Wrap each `onUnlkVehicle()` call in the test with a `QSignalSpy` on `startMasterSession` and assert `spy.count() == 1` after the action.

---

## Summary Table

| ID | Severity | Category | Affected Class | Method / Behaviour |
|----|----------|----------|----------------|--------------------|
| A24-1 | HIGH | Missing Coverage — Security | `SupervisorDialog` | `onUnlkVehicle()` first-tap path untested |
| A24-2 | HIGH | Missing Coverage — Security | `SupervisorDialog` | `onNormalDriverAccess()` entirely untested |
| A24-3 | HIGH | Missing Coverage — Security | `SupervisorDialog` | `on_btnMaintenanceMode_clicked()` entirely untested |
| A24-4 | HIGH | Missing Coverage — Security | `SupervisorDialog` | `openConfirmationDialog()` / `onActivateVOR()` untested |
| A24-5 | MEDIUM | Missing Coverage — Timer | `SupervisorDialog` | Inactivity auto-dismiss timer untested |
| A24-6 | MEDIUM | Missing Coverage — Timer | `SupervisorDialog` | Confirm reset timer untested |
| A24-7 | MEDIUM | Missing Coverage — Logic | `SupervisorDialog` | `debounce()` rapid-fire rejection untested |
| A24-8 | MEDIUM | Missing Coverage — Logic | `SupervisorDialog` | `setMasterOptions()` bitmask permutations untested |
| A24-9 | MEDIUM | Missing Coverage — Logic | `SupervisorDialog` | `setTransportOptions()` entirely untested |
| A24-10 | MEDIUM | Missing Coverage — Logic | `UnlockedDialog` | `setMode()` — only 1 of 3 modes partially tested |
| A24-11 | MEDIUM | Missing Coverage — Logic | `UnlockedDialog` | `languageChanged()` entirely untested |
| A24-12 | LOW | Missing Coverage — Display | `PreopScreenOverlay` | Entire class has zero test coverage |
| A24-13 | LOW | Missing Coverage — Signal | `SupervisorDialog` | `startMasterSession` signal never spy-verified |

**Totals: 4 HIGH, 6 MEDIUM, 3 LOW — 13 findings**

---

## Notes on Test Architecture

- `SupervisorDialog` and `UnlockedDialog` both declare `friend class TestDialog` under `#ifdef UNIT_TEST`, giving the test class access to private members and UI internals. This infrastructure is in place but is used only for `m_supervisorDialog->ui->btnUnlkVehicle` manipulation.
- `PreopScreenOverlay` has no `UNIT_TEST` friend declaration, making direct white-box testing of its `ui` members impossible without modifying the header.
- The test pattern of pre-setting `ui->btnUnlkVehicle->setText("Confirm?")` before calling `onUnlkVehicle()` bypasses the first confirmation tap. This is a structural test design weakness: the test exercises only the post-confirmation path, not the full two-tap user journey.
- No `QSignalSpy` usage is present for any of the three dialogs' emitted signals in any test file.
# Audit Report — Agent A25 — Pass 2: Test Coverage

**Agent ID:** A25
**Audit Run:** 2026-02-28-01
**Pass:** 2 — Test Coverage
**Branch confirmed:** master (verified via `git branch --show-current`)
**Date:** 2026-02-28

---

## Assigned Files

| File | Role |
|---|---|
| `ui/unlockreasondialog.cpp` | Implementation |
| `ui/unlockreasondialog.h` | Header |
| `ui/vorconfirmationdialog.cpp` | Implementation |
| `ui/vorconfirmationdialog.h` | Header |
| `ui/vorwarningdialog.cpp` | Implementation |
| `ui/vorwarningdialog.h` | Header |

---

## Reading Evidence

### UnlockReasonDialog

**Class:** `UnlockReasonDialog` extends `QDialog`

**Includes (cpp):**
- `unlockreasondialog.h` (line 1)
- `ui_unlockreasondialog.h` (line 2)
- `<QPushButton>` (line 3)

**Includes (h):**
- `<QDialog>` (line 4)
- `<QString>` (line 5)

**Public methods:**
- `explicit UnlockReasonDialog(QWidget *parent = 0)` — h:16, cpp:5
- `~UnlockReasonDialog()` — h:17, cpp:34
- `QString getReason()` — h:18, cpp:45
- `void languageChanged(void)` — h:19, cpp:50

**Private methods:**
- `void setReason()` — h:23, cpp:39

**Private members:**
- `Ui::UnlockReasonDialog *ui` — h:22
- `QString m_reason` — h:24 (initialised to `""` at cpp:8)

**Signal/slot wiring in constructor (cpp:12–31):**
- 10 x `QPushButton::clicked` -> `setReason` for Red Impact buttons (R1–R10)
- 2 x `QPushButton::clicked` -> `setReason` for Checklist Timeout buttons (R1–R2)
- 2 x `QPushButton::clicked` -> `setReason` for Checklist Lockout buttons (R1–R2)
- `btnDone::clicked` -> `reject` (cpp:31)

**Key logic:**
- `setReason()` (cpp:39–43): casts `sender()` to `QPushButton*` via C-style cast and reads `.text()`, then calls `emit accept()`.
- `getReason()` (cpp:45–48): returns `m_reason`.
- `languageChanged()` (cpp:50–71): retranslates all button labels.
- No `accept()` signal override; the class calls `emit accept()` directly inside `setReason()`. The `m_reason` default is `""` if the dialog is dismissed via `btnDone` (which calls `reject()`).

**Caller context:** `ui/commentdialog.cpp:205–211` — `onUnlkReasonSelected()` calls `getReason()` and guards against the empty-string case. The `UnlockReasonDialog` is instantiated and managed by `CommentDialog`.

---

### VORConfirmationDialog

**Class:** `VORConfirmationDialog` extends `QDialog`

**Includes (cpp):**
- `vorconfirmationdialog.h` (line 1)
- `ui_vorconfirmationdialog.h` (line 2)
- `../mytranslator.h` (line 3)
- `<QTimer>` (line 4)

**Includes (h):**
- `<QDialog>` (line 4)

**Public methods:**
- `explicit VORConfirmationDialog(QWidget *parent = 0)` — h:15, cpp:6
- `~VORConfirmationDialog()` — h:16, cpp:30
- `void isBeingTurnOn(bool on)` — h:18, cpp:35

**Protected methods:**
- `void hideEvent(QHideEvent *)` — h:25, cpp:25
- `void showEvent(QShowEvent *event = 0)` — h:26, cpp:19

**Private members:**
- `Ui::VORConfirmationDialog *ui` — h:21
- `QTimer *m_timer` — h:22

**Signal/slot wiring (cpp:13–15):**
- `btnCancel::clicked` -> `reject`
- `btnTurnOn::clicked` -> `accept`
- `m_timer::timeout` -> `reject`

**Key logic:**
- Timer is single-shot (cpp:16), starts at 10 000 ms on `showEvent` (cpp:22), stopped on `hideEvent` (cpp:27).
- `isBeingTurnOn(bool on)` sets UI label text differently for turn-on vs. turn-off. Note: the `on == false` branch (VOR being turned ON) and the `on == true` branch (VOR being turned OFF) both set the same `lblCornfirm` text when language is English (`langEnglish`) — both show `"Please confirm that you want to turn VOR mode"` (missing "on"/"off") due to the logic inversion at cpp:40 vs. cpp:49.

**Caller context:** `ui/supervisordialog.cpp:16,26–28` — `VORConfirmationDialog` is embedded in `SupervisorDialog`; `accepted` -> `onActivateVOR`, `rejected` -> `showEvent()` (return to supervisor screen), `finished` -> `reset`.

---

### VORWarningDialog

**Class:** `VORWarningDialog` extends `QDialog`

**Includes (cpp):**
- `vorwarningdialog.h` (line 1)
- `ui_vorwarningdialog.h` (line 2)
- `<QTimer>` (line 3)

**Includes (h):**
- `<QDialog>` (line 4)

**Public methods:**
- `explicit VORWarningDialog(QWidget *parent = 0)` — h:15, cpp:5
- `~VORWarningDialog()` — h:16, cpp:66

**Protected methods:**
- `void hideEvent(QHideEvent *)` — h:23, cpp:61
- `void showEvent(QShowEvent *event = 0)` — h:24, cpp:17

**Private members:**
- `Ui::VORWarningDialog *ui` — h:19
- `QTimer *m_timer` — h:20

**Signal/slot wiring (cpp:12–13):**
- `btnACK::clicked` -> `accept`
- `m_timer::timeout` -> `reject`

**Key logic:**
- Timer is single-shot (cpp:14), started at 30 000 ms on `showEvent` (cpp:57), stopped on `hideEvent` (cpp:63).
- `showEvent` (cpp:17–58): builds full HTML body with three translated strings and sets them into `textEdit`.
- No Cancel button — user can only acknowledge (accept) or let the timer expire (reject). There is no explicit way to cancel without waiting.

**Caller context:** `ui/dialog.cpp:75,183` — instantiated in `Dialog`, with `accepted` signal connected to `openMenuDialog`.

---

## Test Coverage Analysis

### Primary test file examined

- `test/test_dialog.h` — declares `TestDialog` with slots: `test_enums`, `test_globalConfigs`, `test_idleLockout`, `test_showPreopSummary`, `test_unlockMode1`, `test_showTime`.
- `test/test_dialog.cpp` — full implementation read.

### Grep results — all test files

Grep for `UnlockReasonDialog`, `VORConfirmationDialog`, `VORWarningDialog` across all files under `test/`: **zero matches**.

Grep for method names `getReason`, `setReason`, `languageChanged`, `isBeingTurnOn`, `showEvent`, `hideEvent` across `test/`: only three hits, all for `m_checkCompletedDialog->showEvent(nullptr)` in `test_showPreopSummary` — unrelated to the three audited classes.

**Conclusion: none of the three dialog classes has any test coverage whatsoever.**

---

## Findings

---

**A25-1** · HIGH · Missing Test Coverage
**File:** `ui/unlockreasondialog.cpp:39–43`
**Description:** `UnlockReasonDialog` has zero test coverage. The core interaction — a user clicking a reason button triggering `setReason()`, which casts `sender()` to `QPushButton*` and calls `emit accept()` — is completely untested. The 14 distinct reason buttons across three categories (10 Red Impact, 2 Checklist Timeout, 2 Checklist Lockout) are never exercised. No test verifies that `getReason()` returns the expected button text after each click, nor that the `accept()` signal is actually emitted.
**Fix:** Add a `TestUnlockReasonDialog` test class. Instantiate the dialog; for each of the 14 buttons, simulate a click (or call `setReason()` via a `QTest::mouseClick` / direct `clicked()` emission), then assert `getReason()` equals the expected localised string and that `QSignalSpy` on `accepted()` fires exactly once per click.

---

**A25-2** · HIGH · Missing Test Coverage — Empty/No-Selection Path
**File:** `ui/unlockreasondialog.cpp:45–48`, `ui/commentdialog.cpp:205–211`
**Description:** When the user presses the BACK button (`btnDone`), the dialog calls `reject()` without setting `m_reason`, leaving `m_reason` as the empty string `""`. The caller (`CommentDialog::onUnlkReasonSelected`) guards against this, but no test verifies that: (a) `getReason()` returns `""` when rejected, (b) the guard in `onUnlkReasonSelected` correctly suppresses text insertion, or (c) the `rejected()` signal fires when BACK is pressed.
**Fix:** Add a test case that calls `reject()` on the dialog (or simulates a `btnDone` click) and asserts `getReason() == ""`. Add a companion test for `CommentDialog::onUnlkReasonSelected` to confirm no text is inserted into `pteMessageBox` on empty reason.

---

**A25-3** · HIGH · Missing Test Coverage
**File:** `ui/vorconfirmationdialog.cpp`
**Description:** `VORConfirmationDialog` has zero test coverage. No test exercises: (a) the confirm (TURN ON / TURN OFF) accept path; (b) the cancel path (`btnCancel` emitting `rejected`); (c) the auto-timeout path (10-second timer expiring and calling `reject`); (d) `isBeingTurnOn(true)` vs. `isBeingTurnOn(false)` label states; or (e) the interaction between `showEvent` starting the timer and `hideEvent` stopping it. The VOR mode is a safety-critical feature that locks out drivers, making untested confirmation flow a significant risk.
**Fix:** Add a `TestVORConfirmationDialog` class. Use `QSignalSpy` on `accepted()` and `rejected()`. Test: (1) calling `isBeingTurnOn(false)` then clicking TURN ON — spy on `accepted`; (2) clicking CANCEL — spy on `rejected`; (3) calling `showEvent`, advancing timer via `QTest::qWait(10100)`, asserting `rejected` fires. Check label text for both `isBeingTurnOn` states.

---

**A25-4** · HIGH · Missing Test Coverage
**File:** `ui/vorwarningdialog.cpp`
**Description:** `VORWarningDialog` has zero test coverage. No test exercises: (a) the acknowledge path (`btnACK` accepted signal); (b) the 30-second auto-timeout path (timer expiry calling `reject`); (c) the HTML content construction in `showEvent` (three translated strings assembled with inline HTML templates — a bug in string escaping or template concatenation would be silent); or (d) the timer start/stop lifecycle across `showEvent`/`hideEvent`. This dialog is displayed to a driver when VOR mode is active, serving as a mandatory safety warning.
**Fix:** Add a `TestVORWarningDialog` class. Instantiate the dialog, call `showEvent(nullptr)`, use `QSignalSpy` to verify the timer eventually fires `rejected()` after ~30 s (or short-circuit with `m_timer->setInterval(50)` before `showEvent`). Separately test that clicking `btnACK` emits `accepted()`. Inspect `ui->textEdit->toHtml()` to confirm all three warning paragraphs are present.

---

**A25-5** · MEDIUM · Missing Test Coverage — `languageChanged` Not Tested
**File:** `ui/unlockreasondialog.cpp:50–71`
**Description:** `UnlockReasonDialog::languageChanged()` retranslates 15 UI elements (header label, BACK button, group box titles, and all 14 reason buttons). No test verifies that after calling `languageChanged()`, the button texts match the expected translated strings, or that `setReason()` returns the post-translation text (since it reads from `sender()->text()` at call time, this is a live dependency).
**Fix:** In the `TestUnlockReasonDialog` class, call `languageChanged()` on a freshly constructed dialog and assert each button's `text()` matches the expected English string. After simulating a button click, assert `getReason()` equals the (potentially translated) button text.

---

**A25-6** · MEDIUM · Logic Inversion Bug in `isBeingTurnOn` — Not Caught by Tests
**File:** `ui/vorconfirmationdialog.cpp:35–57`
**Description:** The parameter `on` is documented (by the method name `isBeingTurnOn`) to represent whether VOR is currently on. However, the branch `if (!on)` (cpp:39) sets the label "turn on VOR mode" and "TURN ON", while `else` (cpp:48) sets "turn off VOR mode". This means `on = false` displays "TURN ON" and `on = true` displays "TURN OFF" — which is inverted relative to the method name's implication. Furthermore, in the English-language branch, both `if (!on)` and `else` set the same truncated `lblCornfirm` text: `"Please confirm that you want to turn VOR mode"` (missing "on" or "off") — making it impossible to distinguish turn-on from turn-off intent on an English device. Because no tests exist for this method, this logical defect has gone undetected.
**Fix:** Write tests for both `isBeingTurnOn(true)` and `isBeingTurnOn(false)` that assert: (1) `btnTurnOn->text()` is "TURN OFF" when `on=true` and "TURN ON" when `on=false`; (2) `lblCornfirm->text()` contains "off" when `on=true` and "on" when `on=false` in the non-English path; (3) review whether the English label logic is intentional (i.e., deliberate omission of "on"/"off" per spec) or is a copy-paste bug.

---

**A25-7** · LOW · No Integration Test for VOR Flow in `test_dialog.cpp`
**File:** `test/test_dialog.cpp`
**Description:** `test_dialog.cpp` tests `SupervisorDialog` interactions indirectly (e.g., `m_supervisorDialog->onUnlkVehicle()` in `test_unlockMode1`), but never exercises the VOR path through `SupervisorDialog` that triggers `VORConfirmationDialog::accepted` -> `onActivateVOR`. The end-to-end VOR activation sequence (supervisor presses VOR toggle, confirmation dialog appears, supervisor confirms, VOR mode is set) has no integration-level coverage.
**Fix:** Extend `test_dialog.cpp` with a `test_vorActivation` test. Use `QSignalSpy`, trigger the VOR button in `SupervisorDialog`, then call `m_vorConfirmationDialog->accept()` and assert the correct GMTP message is posted and VOR state is set in `gCfg`.

---

## Summary Table

| ID | Severity | Category | File | Summary |
|---|---|---|---|---|
| A25-1 | HIGH | Missing Test Coverage | `ui/unlockreasondialog.cpp:39–43` | No tests for any of 14 reason buttons or `setReason`/`getReason` |
| A25-2 | HIGH | Missing Test Coverage | `ui/unlockreasondialog.cpp:45–48` | No test for empty-reason / BACK-button (reject) path |
| A25-3 | HIGH | Missing Test Coverage | `ui/vorconfirmationdialog.cpp` | Zero coverage: confirm, cancel, timeout, and label state paths |
| A25-4 | HIGH | Missing Test Coverage | `ui/vorwarningdialog.cpp` | Zero coverage: acknowledge, timeout, and HTML construction |
| A25-5 | MEDIUM | Missing Test Coverage | `ui/unlockreasondialog.cpp:50–71` | `languageChanged()` retranslation never verified |
| A25-6 | MEDIUM | Logic Bug (undetected by tests) | `ui/vorconfirmationdialog.cpp:35–57` | Parameter inversion in `isBeingTurnOn`; English label missing "on"/"off" |
| A25-7 | LOW | Missing Integration Test | `test/test_dialog.cpp` | No end-to-end test for VOR activation flow through supervisor dialog |

**Total findings: 7** (4 HIGH, 2 MEDIUM, 1 LOW)

---

## Coverage Summary by Class

| Class | Any Tests? | Constructor tested? | Core logic tested? | Timer behaviour tested? | All paths tested? |
|---|---|---|---|---|---|
| `UnlockReasonDialog` | NO | NO | NO | N/A | NO |
| `VORConfirmationDialog` | NO | NO | NO | NO | NO |
| `VORWarningDialog` | NO | NO | NO | NO | NO |
# Pass 2 Audit — Test Coverage — A26
**Repository:** mark3-pvd
**Branch:** master (confirmed — `git branch --show-current` returned `master`)
**Auditor:** A26
**Audit Run:** 2026-02-28-01
**Pass:** 2 (Test Coverage)
**Date:** 2026-02-28
**Status:** COMPLETE — all assigned files read; test directory fully searched

---

## Assigned Files

| File | Role |
|---|---|
| `ui/warningdialog.cpp` | WarningDialog implementation |
| `ui/warningdialog.h` | WarningDialog header |
| `utils/barcode128.cpp` | Barcode128 / BarcodeChar implementation |
| `utils/barcode128.h` | Barcode128 / BarcodeChar header |
| `utils/bytearray.h` | ByteArray header-only utility class |
| `utils/logger.cpp` | Logger singleton implementation |
| `utils/logger.h` | Logger header |
| `utils/zconf.h` | Third-party zlib configuration header (v1.3.1) |
| `utils/zlib.h` | Third-party zlib public API header (v1.3.1) |

---

## Reading Evidence

### `ui/warningdialog.h` — Class and Public Interface

**Class:** `WarningDialog` — inherits `QDialog`

**Enum defined at file scope:**
- `WarningDialogType { VOR, Transport, Maintenance }` — line 10

**Public methods:**
- `explicit WarningDialog(WarningDialogType type, QWidget *parent = 0)` — line 17 (constructor)
- `~WarningDialog()` — line 18 (destructor)

**Protected methods (event overrides):**
- `void hideEvent(QHideEvent *)` — line 29
- `void showEvent(QShowEvent *event = 0)` — line 30

**Private methods (internal HTML builders):**
- `QString showVorWarning()` — line 24
- `QString showTransportWarning()` — line 25
- `QString showMaintenanceWarning()` — line 26

**Private members:**
- `Ui::WarningDialog *ui` — line 21
- `QTimer *m_timer` — line 22
- `WarningDialogType m_type` — line 23

---

### `ui/warningdialog.cpp` — Implementation

- Constructor (lines 5–16): wires `btnACK` clicked → `accept()`, timer `timeout` → `reject()`, sets timer single-shot.
- `showEvent` (lines 18–45): dispatches to one of three private HTML-builder methods based on `m_type`, sets `textEdit` HTML, starts 45-second auto-close timer.
- `showTransportWarning` (lines 47–82): builds and returns HTML string for Transport warning (three paragraphs).
- `showVorWarning` (lines 84–118): builds and returns HTML string for VOR warning.
- `showMaintenanceWarning` (lines 120–154): builds and returns HTML string for Maintenance warning.
- `hideEvent` (lines 156–159): stops the timer.
- Destructor (lines 161–164): deletes `ui`.

No WarningDialog constructor is invoked from Dialog::Dialog() in `ui/dialog.cpp`. The production code instead uses a `VORWarningDialog` (line 75 of dialog.cpp). `WarningDialog` has no visible instantiation in the tested dialog infrastructure.

---

### `utils/barcode128.h` — Classes and Public Interface

**Class `BarcodeChar`:**
- Default constructor (line 10–15): initialises to INVALID sentinel
- Copy constructor (line 17–22)
- Parameterised constructor `BarcodeChar(int value, QString name, QString pattern)` (line 24–29)
- `operator=` (line 31–37)
- Private members: `m_value`, `m_name`, `m_pattern` (lines 40–42); `friend class Barcode128`

**Class `Barcode128`:**
- Public:
  - `Barcode128(const QString &info, int height = 100, int sizeMult = 2)` — line 50 (constructor)
  - `~Barcode128()` — line 51
  - `static int width(const QString &info, int sizeMult)` — line 52
  - `QPixmap pixmap()` — line 54
- Private methods: `initChar`, `initChars`, `encodeChar`, `drawBlackVerticalLineAtPos`, `drawEmptyVerticalLineAtPos`
- Private members: `m_valueToChar` (QMap<int, BarcodeChar>), `m_nameToChar` (QMap<QString, BarcodeChar>), `m_image` (QImage*), `m_pos` (int), `m_sizeMult` (int)

---

### `utils/barcode128.cpp` — Implementation

**Preprocessor constants:**
- `#define START_CODE 104` — line 5 (Code B — upper/lower case + digits; active branch)
- `#define END_CODE 106` — line 6
- `#define MODULO_VAL 103` — line 7

**Constructor** (lines 9–37):
- Allocates QImage of size `width(info, sizeMult)` × `height` (line 16)
- Draws 15 leading quiet-zone pixels (lines 18–19)
- Encodes START_CODE (104), iterates characters, accumulates weighted checksum, encodes checksum and STOP code (lines 21–33)
- Draws 15 trailing quiet-zone pixels (lines 35–36)

**`width()` static method** (lines 320–323):
- Returns `(info.length() * 11 + 13 + 11 + 11) * sizeMult + 30`
- Note: formula counts start+stop+checksum patterns (35 modules) plus data (11 modules/char) plus 30 pixels of quiet zone.

**`initChars()`** (lines 61–281):
- Active branch: `#elif START_CODE == 104` — initialises Code B character table (values 0–106), covering ASCII 0x20–0x7E plus special function/control codes.
- Duplicate name keys for value 12 and value 16 (both mapped to "0") — only the second `insert` for name "0" will survive in `m_nameToChar`. This means character with barcode value 12 (pattern "10110011100") is unreachable by name lookup.

**`encodeChar()`** (lines 283–296): iterates pattern string, draws black or white vertical lines per pixel.

**`drawBlackVerticalLineAtPos()` / `drawEmptyVerticalLineAtPos()`** (lines 298–318): bounds-check `m_pos` before writing, increment `m_pos`.

---

### `utils/bytearray.h` — Class and Methods

**Class `ByteArray`:** header-only static utility class.

**Macros defined:**
- `LE_INT(c1,c2,c3,c4)` — line 6: little-endian 32-bit assembly
- `BE_INT(c1,c2,c3,c4)` — line 7: big-endian 32-bit assembly
- `LE_SHORT(c1,c2)` — line 8: little-endian 16-bit assembly
- `BE_SHORT(c1,c2)` — line 9: big-endian 16-bit assembly
- `BE_LONG(c1,c2,c3,c4,c5,c6,c7,c8)` — line 11: big-endian 64-bit assembly

**Public static methods:**
- `static QByteArray asprintf(const char *cformat, ...)` — lines 16–27
- `static int sscanf(const QByteArray &ba, const char *cformat, ...)` — lines 30–37

**Critical defect in `asprintf` (confirmed from Pass 1):**
- Line 19: `va_start(ap, cformat)` — opens va_list
- Line 20: `size = vsnprintf(nullptr, 0, cformat, ap)` — consumes va_list to measure size
- Line 21: `va_end(ap)` — closes and invalidates va_list
- Line 24: `ba.resize(size)` — note: does NOT add 1 for NUL terminator; `vsnprintf` returns count excluding NUL, so `vsprintf` at line 25 will write one byte past the end of the QByteArray buffer
- Line 25: `vsprintf(ba.data(), cformat, ap)` — **CRITICAL**: `ap` was already consumed and closed; reusing it after `va_end` is undefined behaviour per C99/C++11 §7.15/§18.10. Additionally, `vsprintf` writes NUL to `ba.data()[size]`, one byte past the allocated buffer.

---

### `utils/logger.h` and `utils/logger.cpp` — Summary (Cross-reference from Pass 1)

**Class `Logger`:** singleton, no Q_OBJECT.

**Enum:** `LogLevel { LogDebug, LogInfo, LogWarning, LogCritical, LogFatal, LogNone }` — logger.h:8

**Public methods:**
- `static Logger* instance()` — logger.h:13 / logger.cpp:54
- `void close()` — logger.h:14 / logger.cpp:62
- `void setLogThreshold(LogLevel level)` — logger.h:15 / logger.cpp:70
- `LogLevel logThreshold() const` — logger.h:16 / logger.cpp:75
- `void log(LogLevel level, const QString &message)` — logger.h:17 / logger.cpp:80

**Protected:**
- `Logger()` — logger.h:20 / logger.cpp:13
- `virtual ~Logger()` — logger.h:21 / logger.cpp:46
- `static void logMessageHandler(...)` — logger.h:22 / logger.cpp:117

---

### `utils/zconf.h` and `utils/zlib.h` — Third-Party Headers

Both are the zlib 1.3.1 distribution headers (released 2024-01-22). No project-written code is present. They are included by `app/backgroundworker.cpp` (line 37: `#include "utils/zlib.h"`) which uses `inflate` / `inflateInit` / `inflateEnd` for OTA firmware decompression (the `streamUncompress` function, backgroundworker.cpp lines 49–123).

---

## Test File Survey

**Primary test files examined:**
- `test/test_dialog.cpp` + `test/test_dialog.h` — 684 lines
- `test/test_backgroundworker.cpp` + `test/test_backgroundworker.h`
- `test/test_canbus.cpp` + `test/test_canbus.h`
- `test/test_ota.cpp` + `test/test_ota.h`

**Grep results for assigned classes/symbols in `test/`:**

| Symbol | Matches in test/ |
|---|---|
| `Barcode128`, `barcode128`, `BarcodeChar` | **0** |
| `ByteArray`, `bytearray`, `asprintf`, `sscanf`, `LE_INT`, `BE_INT`, `LE_SHORT`, `BE_SHORT`, `BE_LONG` | **0** |
| `Logger`, `logger`, `LogLevel`, `LogDebug`, `LogInfo`, `LogWarning`, `LogCritical`, `LogFatal` | **0** |
| `WarningDialog`, `warningdialog` | **0** |

**QByteArray** (Qt class, not ByteArray) appears extensively in test files as signal spy argument comparisons — these are unrelated to `utils/bytearray.h`.

**Zlib / inflate / compress** in test files: `test/test_ota.cpp` line 65 comment mentions "compressed file"; the `TestOta::test_unpack()` test calls `m_worker->updateSelf()` which exercises the `streamUncompress` inflate path in backgroundworker.cpp. This provides indirect, integration-level coverage of the zlib inflate API.

---

## Findings

**A26-N1** · CRITICAL · Missing Test Coverage — ByteArray::asprintf Undefined Behaviour
**File:** `utils/bytearray.h:25`
**Description:** Pass 1 identified two compounding defects in `ByteArray::asprintf`: (1) `va_list ap` is consumed by `vsnprintf` on line 20, then closed by `va_end` on line 21, then passed to `vsprintf` on line 25 — reusing a va_list after `va_end` is undefined behaviour per the C++ standard; (2) `ba.resize(size)` allocates exactly `size` bytes but `vsprintf` writes `size+1` bytes (including the NUL terminator), causing a one-byte heap buffer overwrite. No test in `test/` exercises `ByteArray::asprintf` at all. Because `asprintf` is a variadic function with undefined behaviour triggered on every call, only a test that calls the function with a format string and arguments would expose the crash or memory corruption. The complete absence of any test means this critical defect has never been caught by the test suite, is invisible to CI, and remains latent in production code that calls it (e.g. `platform/gnssreceiver.cpp` lines 178, 187, 238, 260, 303, 320, 411).
**Fix:** Add unit tests that call `ByteArray::asprintf` with representative format strings and verify the returned `QByteArray` content and length. After adding tests and observing the failure, fix the implementation: (a) use a second `va_start`/`va_end` pair for the `vsprintf` call, and (b) resize the buffer to `size + 1` and then trim the trailing NUL with `ba.resize(size)` after the `vsprintf`.

---

**A26-N2** · HIGH · No Tests for Barcode128 Encoding Correctness
**File:** `utils/barcode128.cpp:9`
**Description:** The `Barcode128` class encodes strings as Code 128 barcodes and is used in the production application (via `ui/informationdialog.cpp`). The encoding process — character lookup, checksum accumulation, pixel drawing — has zero test coverage. There are no known-value tests verifying that a given input string produces the correct barcode pixel pattern, no test for an empty string input, no test for the maximum practical input length, and no test for characters outside the Code B character set. An encoding error in the checksum logic (e.g. the weighted modulo-103 calculation) or in the character lookup (e.g. the duplicate "0" key mapping that silently discards value 12) would go undetected. In a safety-critical fleet management system where barcodes may be used for driver identification or asset tracking, a silently wrong barcode is a functional correctness defect.
**Fix:** Add a test class (e.g. `TestBarcode128`) that: (a) constructs `Barcode128` with a known string, extracts the QPixmap/QImage, and verifies specific pixel columns correspond to the expected bar pattern for the START, data characters, checksum, and STOP codes; (b) tests with an empty string; (c) tests with a string containing a character whose Code B value produces a known checksum; (d) tests `Barcode128::width()` static method output against the formula for a known input length.

---

**A26-N3** · HIGH · No Tests for Barcode128 Empty String / Boundary Inputs
**File:** `utils/barcode128.cpp:16`
**Description:** When `info` is an empty string, `width(info, sizeMult)` returns `(0 * 11 + 13 + 11 + 11) * sizeMult + 30 = 35 * sizeMult + 30` pixels, which is positive, so a QImage is allocated and only the start code, a zero-value checksum (START_CODE % MODULO_VAL = 104 % 103 = 1), and STOP code are encoded. This has never been tested. When `info` contains a character not present in the Code B table, `m_nameToChar[QString(qc)]` returns a default-constructed `BarcodeChar` with pattern `"1111111"` (7 chars) instead of the standard 11-char pattern. The constructor then draws only 7 pixels for that character instead of 11, causing every subsequent character, checksum, and stop code to be drawn at the wrong horizontal position. This produces a barcode that cannot be decoded by any reader — silently. No test exercises non-ASCII or unmapped input characters.
**Fix:** Add tests for: (a) empty string input — verify pixmap dimensions and that no crash occurs; (b) a character not in the Code B table (e.g. a Unicode character or ASCII DEL) — verify the resulting pixmap has a deterministic width and that the function does not crash or overwrite memory.

---

**A26-N4** · HIGH · No Tests for Logger — Any Method
**File:** `utils/logger.cpp:80`
**Description:** `Logger::instance()`, `Logger::log()`, `Logger::setLogThreshold()`, `Logger::logThreshold()`, and `Logger::close()` have zero test coverage. Specifically: (a) log level filtering — the guard `if (level < m_logThreshold) return` at line 87 is never tested to confirm that messages below the threshold are suppressed; (b) log writes — no test verifies that calling `log()` with a valid level actually writes a line to the output file; (c) null/empty message — `log()` is never called with an empty `QString` to confirm no crash or spurious output; (d) very long message — no test verifies behaviour when `msg` is thousands of characters long; (e) `logMessageHandler` — the Qt message handler integration (qDebug/qWarning passthrough) is untested. The Logger is used in production by at least 15 source files (comm/, platform/, app/ layers). If the threshold filter is inverted or the stream flush is missing, log data would silently disappear.
**Fix:** Add a `TestLogger` test class that: (a) instantiates a Logger writing to a known temporary file path; (b) verifies that `log(LogDebug, "msg")` with threshold `LogDebug` writes the message; (c) verifies that `log(LogDebug, "msg")` with threshold `LogWarning` does not write the message; (d) verifies that `log()` with an empty string does not crash; (e) verifies that `logThreshold()` returns the value set by `setLogThreshold()`; (f) verifies that `close()` and re-instantiation via `instance()` work correctly.

---

**A26-N5** · MEDIUM · No Tests for WarningDialog
**File:** `ui/warningdialog.cpp:5`
**Description:** `WarningDialog` is a safety-critical UI component: it displays mandatory warnings for Transport, VOR (Vehicle Off Road), and Maintenance operating modes — modes where "UNAUTHORISED OPERATION MAY LEAD TO SERIOUS INJURY" is displayed. The dialog has a 45-second auto-close timer (`m_timer->start(45000)` at line 43). None of the following are tested: (a) that the correct HTML body is shown for each `WarningDialogType`; (b) that the ACK button triggers `accept()`; (c) that the timer fires after ~45 seconds and triggers `reject()`; (d) that `hideEvent` stops the timer (preventing spurious rejection after hide); (e) that the `WarningDialogType` enum values `VOR`, `Transport`, and `Maintenance` map to the correct text bodies. `test/test_dialog.cpp` does not include `warningdialog.h` and does not create any `WarningDialog` instance. Note: `ui/dialog.cpp` uses a `VORWarningDialog` (a distinct class), not `WarningDialog` directly — so integration tests of `Dialog` do not exercise `WarningDialog` either.
**Fix:** Add test cases to `test/test_dialog.cpp` (or a dedicated `TestWarningDialog` class) that: (a) construct `WarningDialog(Transport)` and verify `showEvent` sets the text edit to HTML containing the transport warning text; (b) construct `WarningDialog(VOR)` and verify VOR warning text; (c) construct `WarningDialog(Maintenance)` and verify maintenance warning text; (d) simulate the ACK button click and verify `accepted()` signal is emitted; (e) verify that the timer causes automatic rejection after the timeout period (using QSignalSpy on `rejected()`).

---

**A26-N6** · MEDIUM · ByteArray::sscanf va_list Reuse After va_end
**File:** `utils/bytearray.h:34`
**Description:** `ByteArray::sscanf` has the same structural defect as `asprintf` in the va_list lifecycle, though less severe: `va_start(ap, cformat)` at line 33, `vsscanf(ba.constData(), cformat, ap)` at line 34, `va_end(ap)` at line 35. In this case the single `vsscanf` call does consume `ap` only once, so there is no double-use UB. However, the function is not tested at all. A test is needed to confirm correct field parsing and to serve as a regression baseline if the implementation is ever modified.
**Fix:** Add tests that call `ByteArray::sscanf` with a known `QByteArray` and format string, verify the number of fields parsed, and verify the values of the parsed output variables.

---

**A26-N7** · LOW · Zlib Inflate Path Has Only Integration-Level Coverage
**File:** `app/backgroundworker.cpp:49` (uses `utils/zlib.h`)
**Description:** The zlib inflate path (`streamUncompress` in backgroundworker.cpp) is exercised only through `TestOta::test_unpack()`, which is a full end-to-end test that writes a real compressed firmware binary to `/mnt/sd/FleetIQ360App`, calls `m_worker->updateSelf()`, waits for an OTA worker thread, and checks for the existence of `/home/FleetFocusOTA` and its MD5 hash. While this test does cover the happy path (Test 1) and a truncated/corrupted file (Test 2), it provides no unit-level coverage of the inflate stream logic itself: there are no tests for: (a) a stream that requires multiple inflate calls to complete (chunked input); (b) a stream with the Z_DATA_ERROR or Z_MEM_ERROR error codes; (c) the Qt 4-byte header skip logic at lines 79–85 of backgroundworker.cpp. The tests are also environment-dependent (require `/mnt/sd` mount point and `/home/` path), making them unlikely to run in CI on a development host.
**Fix:** Extract `streamUncompress` into a testable free function or a class method. Add unit tests that supply small, synthetically constructed zlib-compressed buffers directly to the function and verify the output, independently of the filesystem and the OTA worker thread.

---

## Summary Table

| ID | Severity | Category | File | Issue |
|---|---|---|---|---|
| A26-N1 | CRITICAL | Missing Test — UB Coverage | `utils/bytearray.h:25` | `ByteArray::asprintf` va_list UB + heap overflow never tested |
| A26-N2 | HIGH | Missing Test — Correctness | `utils/barcode128.cpp:9` | No known-value encoding tests for Barcode128 |
| A26-N3 | HIGH | Missing Test — Boundary | `utils/barcode128.cpp:16` | No empty string or unmapped character tests for Barcode128 |
| A26-N4 | HIGH | Missing Test — Logger | `utils/logger.cpp:80` | Logger: zero test coverage for any method |
| A26-N5 | MEDIUM | Missing Test — Safety UI | `ui/warningdialog.cpp:5` | WarningDialog: zero test coverage; safety-critical component untested |
| A26-N6 | MEDIUM | Missing Test — ByteArray | `utils/bytearray.h:34` | `ByteArray::sscanf` entirely untested |
| A26-N7 | LOW | Partial Test — Zlib | `app/backgroundworker.cpp:49` | Zlib inflate covered only by environment-dependent OTA integration test |

---

## Coverage Summary by Component

| Component | Test Coverage | Notes |
|---|---|---|
| `WarningDialog` | **None** | Not referenced in any test file; not exercised indirectly via Dialog tests |
| `Barcode128` / `BarcodeChar` | **None** | No reference in any test file |
| `ByteArray::asprintf` | **None** | Called in production (15+ call sites); never tested; contains CRITICAL UB |
| `ByteArray::sscanf` | **None** | No test coverage |
| `ByteArray` macros (`LE_INT`, etc.) | **None** | No test coverage |
| `Logger::log` | **None** | No test coverage |
| `Logger::setLogThreshold` | **None** | No test coverage |
| `Logger::logThreshold` | **None** | No test coverage |
| `Logger::instance` | **None** | No test coverage |
| `Logger::close` | **None** | No test coverage |
| `Logger::logMessageHandler` | **None** | No test coverage |
| `zlib` inflate (via backgroundworker) | **Partial** | Integration test in `test_ota.cpp`; no unit-level coverage |

---

## Pass 3 — Documentation Findings

# Pass 3 Agent A01 — Documentation

**Audit run:** 2026-02-28-01
**Branch:** master
**Auditor:** Agent A01
**Files reviewed:** `run_tests`, `netcfg.json`, `.gitignore`, `mk3.pro`, `mk3-test.pro`

---

## Reading Evidence

### `run_tests` (shell script)

- **Purpose:** Executes the compiled `FleetFocus` binary and pipes its output through `awk` to apply ANSI colour codes to PASS/FAIL/DEBUG/WARN lines.
- **Functions/procedures defined:** None (single inline `awk` program).
- **Named constants/variables:** None declared explicitly; ANSI escape sequences `\033[32m` (green), `\033[31m` (red), and `\033[0m` (reset) are embedded as literals.
- **Commands used:**
  - Line 2: `./FleetFocus | awk '...'` — runs the application binary directly and pipes stdout to awk.
  - Lines 3–7: `awk` pattern-action rules for colouring output lines.
- **Existing comments:** Inline `awk` comments on lines 3–7 describe what each colour rule does; no file-level header comment exists.

---

### `netcfg.json`

- **Purpose:** Wi-Fi network configuration file supplying the SSID and password used by the device to join its wireless network. Listed as a `DISTFILES` entry in both `.pro` files (deployed alongside the application binary).
- **Fields defined:**
  - `"password"` (line 2): Wi-Fi pre-shared key — value `"P@ssMK3!"`.
  - `"ssid"` (line 3): Wi-Fi network name — value `"cigSecureConnect"`.
- **Functions/types/constants:** None (JSON data file; no comments are valid JSON syntax).
- **Existing documentation:** None. JSON does not support comments, but no companion documentation file or README references this file.

---

### `.gitignore`

- **Purpose:** Tells Git which files and directories to exclude from version control.
- **Entries defined:**
  - Line 1: `Makefile` — excludes the generated Qt Makefile.
  - Line 2: `FleetFocus` — excludes the compiled application binary.
  - Line 3: `.*` — excludes all dot-files and dot-directories.
  - Line 5: `/tmp` — excludes the top-level `tmp/` directory (used by Qt for intermediate build artefacts).
  - Line 7: `!.gitignore` — re-includes `.gitignore` itself (negation of the `.*` rule above).
  - Line 8: `*.bak` — excludes backup files.
- **Functions/types/constants:** None (configuration file).
- **Existing comments:** None.

---

### `mk3.pro` (Qt project file — production build)

- **Purpose:** qmake project descriptor for the production `FleetFocus` application. Specifies Qt modules, include paths, library paths, intermediate-output directories, source/header/form/resource/translation file lists, and a `DISTFILES` entry for `netcfg.json`.
- **Key settings (line numbers):**
  - Line 6: `DEFINES += "TEST_MODE=0"` — disables test mode for production build.
  - Line 8: `QT += core gui serialport serialbus bluetooth network` — Qt modules required.
  - Line 10: `greaterThan(QT_MAJOR_VERSION, 4): QT += widgets` — adds widgets module for Qt 5+.
  - Lines 12–16: `linux:` block — Linux-only SDK include/lib paths.
  - Lines 18–21: Intermediate build output directory assignments (`RCC_DIR`, `MOC_DIR`, `UI_DIR`, `OBJECTS_DIR`).
  - Line 23: `TARGET = FleetFocus` — output binary name.
  - Line 24: `TEMPLATE = app` — builds as a standalone application.
  - Line 30: `DEFINES += QT_DEPRECATED_WARNINGS` — enables deprecation warnings.
  - Lines 38–96: `SOURCES` list (58 `.cpp` files).
  - Lines 98–157: `HEADERS` list (note: `utils/logger.h` appears at both line 112 and line 122 — duplicate entry).
  - Lines 160–184: `FORMS` list (23 `.ui` files).
  - Line 186–187: `RESOURCES` — `mk3.qrc`.
  - Line 189: `TRANSLATIONS = lang_es_ES.ts` — Spanish (Spain) translation file.
  - Lines 191–192: `DISTFILES` — `netcfg.json`.
- **Functions/types/constants:** None (qmake variable-assignment file).
- **Existing comments:** Auto-generated QtCreator header (lines 1–5); boilerplate Qt deprecation-warning block comment (lines 26–35). No project-specific explanatory comments.

---

### `mk3-test.pro` (Qt project file — unit-test build)

- **Purpose:** qmake project descriptor for the unit-test build of `FleetFocus`. Mirrors `mk3.pro` almost exactly but adds `Qt testlib` module, defines `UNIT_TEST`, and prepends four test source/header files (`test/test_ota`, `test/test_dialog`, `test/test_backgroundworker`, `test/test_canbus`). Does **not** include `main.cpp` (test harness entry point is presumably inside one of the test files).
- **Key settings (line numbers):**
  - Line 6: `DEFINES += "TEST_MODE=0"` — test-mode flag; value is `0` despite this being the test project file (see finding A01-5).
  - Line 7: `DEFINES += UNIT_TEST` — preprocessor flag enabling unit-test code paths.
  - Line 9: `QT += core gui serialport serialbus bluetooth network testlib` — adds `testlib` vs production.
  - Lines 40–43: Four test `.cpp` files prefixed to `SOURCES`.
  - Lines 103–106: Four test `.h` files prefixed to `HEADERS`.
  - Lines 168–200: `FORMS`, `RESOURCES`, `TRANSLATIONS`, `DISTFILES` — identical to `mk3.pro`.
- **Duplicate header entry:** `utils/logger.h` appears at both line 120 and line 130 (same as `mk3.pro`).
- **Functions/types/constants:** None (qmake variable-assignment file).
- **Existing comments:** Same auto-generated header and Qt boilerplate as `mk3.pro`; no test-specific explanatory comments.

---

## Findings

**A01-1** · HIGH · `netcfg.json` stores a plaintext credential with no documentation

**Description:** `netcfg.json` contains a Wi-Fi pre-shared key (`"P@ssMK3!"`) and SSID in plaintext. There is no header comment, companion README, or inline annotation explaining what network this credential is for, whether it is a default/placeholder that must be changed before deployment, or what tool reads or writes this file. Developers and deployers have no documented guidance about the credential's lifecycle or sensitivity. (Note: the credential exposure itself is a security concern reported separately in the security passes; this finding addresses the absence of documentation about it.)

**Fix:** Add a companion `netcfg.json.example` (with redacted credential) and a comment block in the nearest README or deployment guide explaining: the file's purpose, which component reads it, whether the password is a factory default that must be rotated per deployment, and how to provision the file securely on the target device.

---

**A01-2** · MEDIUM · `run_tests` has no file-level header comment

**Description:** The script has no header comment explaining what it does, what prerequisites it requires (the `FleetFocus` binary must already be built and present in the current directory), how to run it, or what its exit behaviour is. A developer encountering it for the first time has to infer all of this from the code.

**Fix:** Add a header comment block immediately after the shebang line that states the script's purpose, prerequisite (a built `FleetFocus` binary in `./`), expected working directory, and a brief note on the awk colour-coding convention used.

---

**A01-3** · MEDIUM · `.gitignore` has no comments explaining non-obvious rules

**Description:** The `.gitignore` file contains several rules that are not self-explanatory to a new contributor:
- Line 3 (`.*`) — silently excludes all dot-files and dot-directories; the line 7 negation (`!.gitignore`) is the only safeguard keeping the file itself tracked. The relationship between these two rules is opaque without a comment.
- Line 5 (`/tmp`) — it is not obvious that this corresponds to the `tmp/` intermediate-build-output directories declared in the `.pro` files (`RCC_DIR`, `MOC_DIR`, `UI_DIR`, `OBJECTS_DIR`).
- Line 2 (`FleetFocus`) — it is not obvious that this is the built binary name rather than a directory or source file.

**Fix:** Add brief inline or section comments explaining each rule group, e.g.: `# Qt build intermediate artefacts`, `# Compiled application binary`, `# Exclude all dot-files except this file`, `# Qt intermediate output dirs (see RCC_DIR/MOC_DIR/UI_DIR/OBJECTS_DIR in .pro)`.

---

**A01-4** · MEDIUM · `mk3.pro` and `mk3-test.pro` share no comment explaining the relationship between the two project files

**Description:** Neither `.pro` file contains any comment explaining that one is for production builds and the other for unit testing, how to choose between them, or what the `UNIT_TEST` / `TEST_MODE` defines control at runtime. A developer checking out the repository for the first time cannot determine from the files themselves which project file to open in Qt Creator for normal development vs running tests.

**Fix:** Add a single-line comment near the top of each file (below the auto-generated header) stating its role: e.g., `# Production build — use this project for device deployment` in `mk3.pro` and `# Unit-test build — includes Qt testlib and test/ sources; use with run_tests script` in `mk3-test.pro`.

---

**A01-5** · LOW · `TEST_MODE=0` in `mk3-test.pro` is misleading and undocumented

**Description:** `mk3-test.pro` sets `DEFINES += "TEST_MODE=0"` (line 6), the same value as the production `mk3.pro`. Because `UNIT_TEST` is also defined (line 7), the intent of having two separate defines is unclear. There is no comment explaining what `TEST_MODE` controls vs what `UNIT_TEST` controls, or why `TEST_MODE` remains `0` in the test project. A developer may assume setting `TEST_MODE=1` is required for testing and be confused to find it is not.

**Fix:** Add a comment on or above the `TEST_MODE` line in both `.pro` files clarifying the distinction: e.g., `# TEST_MODE controls hardware-stub behaviour at runtime; UNIT_TEST enables compile-time test-only code paths`.

---

**A01-6** · LOW · Duplicate `utils/logger.h` entry in both `.pro` files is undocumented

**Description:** `utils/logger.h` appears twice in the `HEADERS` list of `mk3.pro` (lines 112 and 122) and twice in `mk3-test.pro` (lines 120 and 130). While qmake silently deduplicates this, the duplication suggests a copy-paste error and may confuse maintainers who try to understand the full header set or search for where a header was intentionally included. There is no comment marking it as intentional.

**Fix:** Remove the duplicate entry from both files. If the duplication is somehow intentional, add a comment explaining why.

---

**A01-7** · LOW · `mk3.pro` and `mk3-test.pro` have no comment on the Linux-only SDK block

**Description:** Lines 12–16 in both `.pro` files introduce a `linux:` conditional block that adds external SDK include and library paths (`../sdk/kernel_include`, `../sdk/3rd/include`, `../sdk//3rd/lib`). There is no comment explaining what SDK this is, why it is Linux-only, or where the SDK is obtained. This makes cross-platform development and build environment setup unnecessarily opaque.

**Fix:** Add a comment above the `linux:` block identifying the SDK (e.g., board vendor SDK name/version), why it is conditionally included for Linux only, and pointing to any setup instructions.

---

**A01-8** · INFO · `TRANSLATIONS` entry is present but undocumented in both `.pro` files

**Description:** `TRANSLATIONS = lang_es_ES.ts` (line 189 of `mk3.pro`, line 197 of `mk3-test.pro`) registers a Spanish (Spain) translation file. There is no comment explaining how to update translations (i.e., when to run `lupdate`/`lrelease`), why only Spanish is listed, or whether additional locales are planned. New contributors may not know translations exist or how to maintain them.

**Fix:** Add a brief comment above the `TRANSLATIONS` line, e.g.: `# Supported translations; run 'lupdate mk3.pro' to update and 'lrelease' to compile`.

---

## Summary Table

| ID     | Severity | Title                                                                 |
|--------|----------|-----------------------------------------------------------------------|
| A01-1  | HIGH     | `netcfg.json` stores a plaintext credential with no documentation    |
| A01-2  | MEDIUM   | `run_tests` has no file-level header comment                         |
| A01-3  | MEDIUM   | `.gitignore` has no comments explaining non-obvious rules            |
| A01-4  | MEDIUM   | No comment explains the relationship between the two `.pro` files    |
| A01-5  | LOW      | `TEST_MODE=0` in `mk3-test.pro` is misleading and undocumented       |
| A01-6  | LOW      | Duplicate `utils/logger.h` entry in both `.pro` files is undocumented|
| A01-7  | LOW      | Linux-only SDK block has no comment identifying the SDK              |
| A01-8  | INFO     | `TRANSLATIONS` entry is present but undocumented                     |

**Total findings:** 8 (1 HIGH, 3 MEDIUM, 3 LOW, 1 INFO)
# Pass 3 Agent A02 — Documentation

**Audit run:** 2026-02-28-01
**Branch:** master
**Auditor:** A02
**Files reviewed:** `mk3.pro`, `mk3-test.pro`

---

## Reading Evidence

### mk3.pro

**File purpose:** The main Qt project file for the FleetFocus application (the production build). It defines all Qt modules, compiler output directories, the application target, preprocessor defines, and enumerates every source file, header, UI form, resource file, translation file, and distribution file that make up the production build.

**Variables/settings and their line numbers:**

| Line(s) | Variable / Setting | Value |
|---|---|---|
| 6 | `DEFINES += "TEST_MODE=0"` | Disables test mode at compile time |
| 8 | `QT` | `core gui serialport serialbus bluetooth network` |
| 10 | `QT += widgets` (conditional) | Added when Qt major version > 4 |
| 13 | `INCLUDEPATH` | `../sdk/kernel_include` (linux only) |
| 14 | `INCLUDEPATH` | `../sdk/3rd/include` (linux only) |
| 15 | `LIBS` | `-L../sdk/3rd/lib` (linux only) |
| 18 | `RCC_DIR` | `tmp/rcc` |
| 19 | `MOC_DIR` | `tmp/moc` |
| 20 | `UI_DIR` | `tmp/ui` |
| 21 | `OBJECTS_DIR` | `tmp/obj` |
| 23 | `TARGET` | `FleetFocus` |
| 24 | `TEMPLATE` | `app` |
| 30 | `DEFINES += QT_DEPRECATED_WARNINGS` | Enables Qt deprecation warnings |
| 35 (commented out) | `DEFINES += QT_DISABLE_DEPRECATED_BEFORE=0x060000` | Would disable all APIs deprecated before Qt 6.0.0 |
| 38–96 | `SOURCES` | 58 `.cpp` source files across `platform/`, `app/`, `ui/`, `comm/`, `utils/` subdirectories |
| 98–157 | `HEADERS` | 57 `.h` header files |
| 160–184 | `FORMS` | 24 Qt Designer `.ui` form files |
| 186–187 | `RESOURCES` | `mk3.qrc` |
| 189 | `TRANSLATIONS` | `lang_es_ES.ts` |
| 191–192 | `DISTFILES` | `netcfg.json` |

**Constants / defines:**

- `TEST_MODE=0` (line 6) — explicit zero value, suppresses test-only code paths
- `QT_DEPRECATED_WARNINGS` (line 30) — Qt-provided macro to enable deprecation warnings
- `QT_DISABLE_DEPRECATED_BEFORE=0x060000` (line 35, commented out) — Qt-provided macro

---

### mk3-test.pro

**File purpose:** The Qt project file for the unit test build of FleetFocus. It is structurally nearly identical to `mk3.pro` but adds `testlib` to the Qt modules, defines `UNIT_TEST`, and prepends four test-specific source and header files (`test/test_ota`, `test/test_dialog`, `test/test_backgroundworker`, `test/test_canbus`). It does not include `main.cpp` (relies on `testlib`'s own entry point or one of the test files providing it). The `TARGET` is identically named `FleetFocus`, which is a potential build-system hazard.

**Variables/settings and their line numbers:**

| Line(s) | Variable / Setting | Value |
|---|---|---|
| 6 | `DEFINES += "TEST_MODE=0"` | Same as production — test mode flag set to 0 despite this being the test project |
| 7 | `DEFINES += UNIT_TEST` | Enables conditional compilation of unit-test-only code |
| 9 | `QT` | `core gui serialport serialbus bluetooth network testlib` |
| 11 | `QT += widgets` (conditional) | Added when Qt major version > 4 |
| 13 | `INCLUDEPATH` | `../sdk/kernel_include` (linux only) |
| 14 | `INCLUDEPATH` | `../sdk/3rd/include` (linux only) |
| 15 | `LIBS` | `-L../sdk/3rd/lib` (linux only) |
| 19 | `RCC_DIR` | `tmp/rcc` |
| 20 | `MOC_DIR` | `tmp/moc` |
| 21 | `UI_DIR` | `tmp/ui` |
| 22 | `OBJECTS_DIR` | `tmp/obj` |
| 24 | `TARGET` | `FleetFocus` (same name as production binary) |
| 25 | `TEMPLATE` | `app` |
| 31 | `DEFINES += QT_DEPRECATED_WARNINGS` | Enables Qt deprecation warnings |
| 36 (commented out) | `DEFINES += QT_DISABLE_DEPRECATED_BEFORE=0x060000` | Would disable all APIs deprecated before Qt 6.0.0 |
| 39–100 | `SOURCES` | 4 test `.cpp` files + 57 production `.cpp` files (no `main.cpp`) |
| 102–165 | `HEADERS` | 4 test `.h` files + 57 production `.h` files |
| 168–192 | `FORMS` | 24 `.ui` form files (identical to production) |
| 194–195 | `RESOURCES` | `mk3.qrc` |
| 197 | `TRANSLATIONS` | `lang_es_ES.ts` |
| 199–200 | `DISTFILES` | `netcfg.json` |

**Constants / defines:**

- `TEST_MODE=0` (line 6) — value is 0; inconsistent with being the test project
- `UNIT_TEST` (line 7) — enables test-specific compilation branches
- `QT_DEPRECATED_WARNINGS` (line 31) — Qt-provided macro
- `QT_DISABLE_DEPRECATED_BEFORE=0x060000` (line 36, commented out) — Qt-provided macro

---

## Findings

**A02-1** · LOW · No project header comment in either .pro file
**Description:** Both `mk3.pro` and `mk3-test.pro` carry only the boilerplate QtCreator creation timestamp header (lines 1–5). There is no comment describing what the project builds, its purpose, the target hardware/OS, or any build prerequisites. A developer unfamiliar with the project cannot determine from the file alone what `FleetFocus` is, what platform it runs on, or how it relates to `mk3-test.pro`.
**Fix:** Replace the boilerplate header in each file with a descriptive block, for example:
```
# mk3.pro — FleetFocus production build
# Target: embedded Linux (CIG Mark3 hardware) and Windows (development)
# Prerequisites: Qt 5.x with serialport, serialbus, bluetooth, network modules;
#                ../sdk containing kernel headers and third-party libraries.
# Do NOT build this project for unit testing; use mk3-test.pro instead.
```

---

**A02-2** · LOW · `TEST_MODE=0` is unexplained in both files
**Description:** Line 6 of both `mk3.pro` and `mk3-test.pro` sets `TEST_MODE=0` with no comment. In the test project file this is particularly confusing because a reader would expect the test project to activate test-mode paths, not suppress them. The relationship between `TEST_MODE` and the separate `UNIT_TEST` define (test project, line 7) is not explained anywhere in either file.
**Fix:** Add a comment above line 6 in both files explaining the define, and in `mk3-test.pro` clarify why it remains 0. For example:
```
# TEST_MODE: reserved for future hardware-simulation paths; not currently active.
# Note: unit test compilation is controlled by UNIT_TEST, not TEST_MODE.
DEFINES += "TEST_MODE=0"
```

---

**A02-3** · LOW · Linux-specific SDK block is uncommented
**Description:** Lines 12–16 of both files add `INCLUDEPATH` and `LIBS` entries unconditionally on Linux. There is no comment explaining where this SDK comes from, what it provides (kernel headers, third-party libraries), why it is Linux-only, or what the expected directory layout is relative to the repository root. New contributors on Linux will receive cryptic linker errors if the SDK is absent.
**Fix:** Add a comment above the `linux:` block, for example:
```
# Linux cross-compilation: include CIG SDK headers and third-party libs.
# The SDK must be checked out at ../sdk (sibling to this repository).
linux: {
```

---

**A02-4** · LOW · Intermediate-output directory variables are uncommented
**Description:** Lines 18–21 (both files) redirect Qt's intermediate build artefacts (`RCC_DIR`, `MOC_DIR`, `UI_DIR`, `OBJECTS_DIR`) to a `tmp/` subdirectory. There is no comment explaining why these are redirected (e.g., to keep the source tree clean, to support parallel production/test builds from the same tree). The fact that both project files share the same `tmp/` path means they will overwrite each other's intermediate files when building both configurations from the same directory — this is a latent build correctness issue, but it is also a documentation gap because the intent is not stated.
**Fix:** Add a comment explaining the redirect and, ideally, use distinct subdirectories such as `tmp/release/` and `tmp/test/` in the respective files.

---

**A02-5** · MEDIUM · `TEST_MODE=0` in the test project is functionally misleading
**Description:** `mk3-test.pro` defines both `UNIT_TEST` (line 7) and `TEST_MODE=0` (line 6). The name `TEST_MODE` strongly implies a boolean that should be `1` in a test build. If any source file guards behaviour with `#if TEST_MODE`, test-specific paths will be silently disabled even in the unit test binary. This is a correctness concern that is also a documentation failure: the choice is not justified by any comment.
**Fix:** Audit all `#if TEST_MODE` / `#ifdef TEST_MODE` usages in the source tree. If `TEST_MODE` is truly independent of `UNIT_TEST`, rename it to a name that does not suggest a test toggle (e.g., `HARDWARE_SIM_MODE`), and add a comment in both project files clarifying the distinction.

---

**A02-6** · LOW · `SOURCES`, `HEADERS`, and `FORMS` sections have no organisational comments
**Description:** Each of the three file-list sections in both project files contains 50+ entries spanning five architectural layers (`platform/`, `app/`, `ui/`, `comm/`, `utils/`). None of the entries have inline comments, and there are no section-header comments to group files by subsystem. This makes it difficult to verify completeness at a glance (e.g., when adding a new module) or to understand the role of a file from the project file alone.
**Fix:** Insert inline grouping comments within `SOURCES`, `HEADERS`, and `FORMS`, for example:
```
SOURCES += \
    main.cpp \
    mytranslator.cpp \
    # --- Platform abstraction layer ---
    platform/internalrfid.cpp \
    ...
    # --- Application logic ---
    app/globalconfigs.cpp \
    ...
```

---

**A02-7** · LOW · `TRANSLATIONS` and `DISTFILES` entries are unexplained
**Description:** `TRANSLATIONS = lang_es_ES.ts` (line 189/197) is the sole translation file, implying the application ships only in Spanish alongside the default language. `DISTFILES += netcfg.json` (lines 191–192/199–200) adds a network configuration file to the project but does not explain its purpose or deployment destination. Neither entry has a comment.
**Fix:** Add brief comments:
```
# Spanish (Spain) translation file; update with Qt Linguist before each release.
TRANSLATIONS = lang_es_ES.ts

# Deployment-time network configuration; copied to device by the installer.
DISTFILES += \
    netcfg.json
```

---

**A02-8** · MEDIUM · `mk3-test.pro` has no comment distinguishing it from `mk3.pro`
**Description:** `mk3-test.pro` replicates virtually the entire content of `mk3.pro` with three additions: `testlib` in the `QT` line, `DEFINES += UNIT_TEST`, and four test-specific source/header pairs. There is no header comment, no inline comment, and no section comment that explains this relationship. A developer opening the file in isolation cannot determine how it differs from the production project, whether the two files are meant to be kept in sync manually, or why a single combined project with a configuration variable was not used instead.
**Fix:** Add a header comment to `mk3-test.pro` explaining the relationship:
```
# mk3-test.pro — FleetFocus unit test build
# Mirrors mk3.pro but adds Qt testlib, the UNIT_TEST define, and test
# source files under test/. Keep SOURCES/HEADERS/FORMS in sync with mk3.pro
# when adding production modules.
# Build with: qmake mk3-test.pro && make
```

---

**A02-9** · LOW · Duplicate `utils/logger.h` entry in HEADERS (both files)
**Description:** `utils/logger.h` appears twice in the `HEADERS` list: at line 112 and line 122 in `mk3.pro`, and at lines 120 and 130 in `mk3-test.pro`. While qmake silently deduplicates this, the redundancy indicates that the file lists have been maintained by manual copy-paste without review. This is a documentation/maintenance quality issue.
**Fix:** Remove the duplicate entry and add a comment in the `HEADERS` block reminding maintainers to check for duplicates when editing: `# Note: keep entries unique; qmake deduplicates but duplicates indicate copy-paste errors.`

---

**A02-10** · INFO · QtCreator boilerplate timestamp is the only version/ownership information
**Description:** Both files retain only the auto-generated creation timestamp (`Project created by QtCreator 2018-10-17T08:42:55`). There is no author, project name, copyright, licence reference, or product version recorded in either project file. This is common practice for Qt projects but means there is no single canonical place to find this metadata.
**Fix:** Consider adding a copyright or ownership line to the header comment of each file for traceability, particularly given the product is deployed on safety-relevant industrial hardware.

---

## Summary Table

| ID | Severity | Title | File(s) |
|---|---|---|---|
| A02-1 | LOW | No descriptive project header comment | `mk3.pro`, `mk3-test.pro` |
| A02-2 | LOW | `TEST_MODE=0` define is unexplained | `mk3.pro`, `mk3-test.pro` |
| A02-3 | LOW | Linux SDK block has no explanatory comment | `mk3.pro`, `mk3-test.pro` |
| A02-4 | LOW | Intermediate output directory redirects are uncommented | `mk3.pro`, `mk3-test.pro` |
| A02-5 | MEDIUM | `TEST_MODE=0` in test project is functionally misleading | `mk3-test.pro` |
| A02-6 | LOW | File-list sections lack organisational/grouping comments | `mk3.pro`, `mk3-test.pro` |
| A02-7 | LOW | `TRANSLATIONS` and `DISTFILES` entries are unexplained | `mk3.pro`, `mk3-test.pro` |
| A02-8 | MEDIUM | `mk3-test.pro` has no comment distinguishing it from `mk3.pro` | `mk3-test.pro` |
| A02-9 | LOW | Duplicate `utils/logger.h` entry in `HEADERS` | `mk3.pro`, `mk3-test.pro` |
| A02-10 | INFO | No author/ownership/version information in project files | `mk3.pro`, `mk3-test.pro` |

**Totals:** 0 CRITICAL, 0 HIGH, 2 MEDIUM, 7 LOW, 1 INFO
# Pass 3 Agent A03 — Documentation

**Audit run:** 2026-02-28-01
**Branch:** master
**Files reviewed:**
- `app/backgroundworker.h` + `app/backgroundworker.cpp`
- `app/checklist.h` + `app/checklist.cpp`

---

## 1. Reading Evidence

### 1.1 `backgroundworker.h`

#### Class: `OtaWorker` (line 38)
Inherits `QObject`.

**Public methods:**

| Line | Method |
|------|--------|
| 42 | `explicit OtaWorker(QObject *parent = nullptr)` |
| 43 | `void unpack()` |

**Public member variables:**

| Line | Name | Type |
|------|------|------|
| 45 | `m_isRunning` | `QAtomicInteger<quint32>` |

**Signals:**

| Line | Signal |
|------|--------|
| 48 | `sendGmtpMessage(CIGCONF::GmtpMessage msg, const QByteArray &extra)` |
| 49 | `started()` |
| 50 | `ready()` |
| 51 | `failed()` |

**Types / Enums / Constants:** None defined within this class.

---

#### Class: `BackgroundWorker` (line 62)
Inherits `QObject`.

**Public methods:**

| Line | Method |
|------|--------|
| 68 | `explicit BackgroundWorker(QObject *parent = nullptr)` |
| 69 | `void setUI(Dialog *ui)` |
| 70 | `bool networkStatus()` (inline) |

**Public enums:**

| Line | Enum | Values |
|------|------|--------|
| 66 | `QuitMode` | `QuitReboot`, `QuitPowerOff`, `QuitApp` |

**Signals:**

| Line | Signal |
|------|--------|
| 80 | `powerStateChanged(CIGCONF::PowerState state)` |
| 81 | `reboot()` |
| 82 | `lockScreen(CIGCONF::MaintLockedCode code, bool remote)` |
| 83 | `ambertImpactScreen()` |
| 84 | `cardAuthorised(bool yes, quint64 id)` |
| 85 | `updateStatusInfo(QByteArray IO, bool Rly1, bool Rly2, QByteArray can, const QByteArray& rssi, const QByteArray& moni, bool netStat, bool modemStat, bool wifiStat, qint8 sat, qint32 lat, qint32 lon)` |
| 86 | `cmdMsgReceived(CIGCONF::BroadcastMessage m)` |
| 87 | `onDemandStarted(quint32 start, quint32 end, quint64 id, CIGCONF::OnDemandCmdSrc)` |
| 88 | `onDemandExtended(quint32 start, quint32 end, quint64 id, CIGCONF::OnDemandCmdSrc)` |
| 89 | `onDemandEnded(quint32 end, quint64 id, CIGCONF::OnDemandCmdSrc)` |
| 90 | `sigLanguageChanged()` |
| 91 | `cmdLogin(quint64 id)` |
| 92 | `unpackOta()` |
| 93 | `cameraSettingsUpdated()` |

**Private enum (internal):**

| Line | Enum | Values |
|------|------|--------|
| 100 | `EthernetInterface` | `EthModem`, `EthWifi` |

**Slots:** All slots are private (no explicit `slots:` label in the public interface; private methods wired via `connect()` serve as slots).

---

### 1.2 `checklist.h`

#### Class: `Checklist` (line 6)
Plain C++ class (no `QObject`).

**Nested type:**

| Line | Type | Description |
|------|------|-------------|
| 9 | `struct CheckItem` | Represents a single checklist question. Contains a union with a bitfield (`qId:31`, `doNotRandomize:1`) aliased over `questionId`, a `CIGCONF::ChecklistType type`, `quint8 questionLen`, and `char question[CHECKLIST_QUESTION_LEN_100+1]`. |

**Public methods:**

| Line | Method |
|------|--------|
| 23 | `Checklist()` (constructor) |
| 25 | `static bool isValidCheckItem(const CheckItem &item)` (inline) |
| 27 | `void readChecklist()` |
| 29 | `void saveChecklist()` |
| 30 | `void clear()` |
| 31 | `void shuffleChecklist()` |
| 34 | `const CheckItem & checkItem(int index, bool query = false) const` |
| 35 | `bool setCheckItem(int index, const CheckItem &item)` |
| 36 | `quint32 checksum() const` |

**Types / Enums / Constants:** None additional beyond `CheckItem` struct. Uses `CIGCONF::ChecklistType` (defined elsewhere).

**Signals / Slots:** None (not a `QObject`).

---

## 2. Documentation Findings

### 2.1 `backgroundworker.h` / `backgroundworker.cpp`

**A03-1** · LOW · `OtaWorker::unpack()` has no doc comment

**Description:** `unpack()` is a public method that decompresses a downloaded OTA firmware file, verifies its CRC-16, and emits `started`/`ready`/`failed` signals. It is the primary entry point for triggering an over-the-air update and involves file I/O, zlib decompression, and CRC validation. No comment of any kind appears above the declaration on line 43.

**Fix:** Add a doc comment above line 43 explaining the purpose, the precondition (firmware file must be present on disk), the signals emitted on each outcome, and that the method is re-entry-safe via `m_mutex.tryLock()`.

---

**A03-2** · INFO · `OtaWorker::OtaWorker()` constructor has no doc comment

**Description:** The constructor on line 42 has no doc comment. It is a trivial delegating constructor; the absence of documentation is low impact.

**Fix:** A one-line `// Constructs an OtaWorker; call unpack() from a worker thread.` is sufficient.

---

**A03-3** · HIGH · `OtaWorker::m_isRunning` public atomic member has no doc comment

**Description:** `m_isRunning` (line 45) is a publicly exposed `QAtomicInteger<quint32>` that is read and written by `unpack()` to signal whether the OTA operation is in progress. Public mutable state that is shared across threads (the `OtaWorker` runs in `m_otaThread`) warrants clear documentation of ownership, valid values (0 = idle, 1 = running), thread-safety guarantees, and intended readers. None is present.

**Fix:** Add a comment such as:
```cpp
// Atomic flag indicating whether unpack() is currently executing.
// 0 = idle, 1 = running. Read-only from outside this class.
QAtomicInteger<quint32> m_isRunning;
```

---

**A03-4** · LOW · `BackgroundWorker::setUI(Dialog *ui)` has no doc comment

**Description:** `setUI()` (line 69) is a non-trivial public method that wires all Qt signal/slot connections between `BackgroundWorker` and the `Dialog` UI. It must be called exactly once after construction and before the background worker's event loop starts processing events. The order-of-call constraint and the side-effect of establishing all cross-thread connections are undocumented.

**Fix:** Add a doc comment noting the precondition (must be called before event processing begins), the parameter (`ui` must be non-null and already constructed), and the fact that this call establishes all UI-to-worker signal/slot wiring.

---

**A03-5** · INFO · `BackgroundWorker::networkStatus()` inline method has no doc comment

**Description:** `networkStatus()` (line 70) is a simple public getter returning `m_wifiState || m_modemState`. It is trivially understandable from its name and body, but no description of what "network status" means (true = at least one WAN interface is up) appears at the call site.

**Fix:** A one-line comment such as `// Returns true if at least one WAN interface (Wi-Fi or modem) is currently connected.` would be sufficient.

---

**A03-6** · LOW · `BackgroundWorker::QuitMode` enum values have no doc comments

**Description:** The `QuitMode` enum (line 66) has three values — `QuitReboot`, `QuitPowerOff`, `QuitApp` — with no explanation of the difference in behaviour between them. Callers invoking `quit()` (private) need to know when each mode is appropriate. The difference between `QuitReboot` (reboot the OS), `QuitPowerOff` (power down the hardware), and `QuitApp` (exit the Qt application without a system-level shutdown) is not self-evident from the names alone.

**Fix:** Add inline comments for each enumerator:
```cpp
enum QuitMode {
    QuitReboot,    // Reboot the OS after ACKs are sent
    QuitPowerOff,  // Power off the hardware after ACKs are sent
    QuitApp        // Exit the Qt application only (no OS-level shutdown)
};
```

---

**A03-7** · LOW · `BackgroundWorker` constructor has no doc comment

**Description:** The constructor (line 68) initialises numerous subsystem objects and timers, and wires OTA-related signal/slot connections. No comment explains the construction sequence, ownership model, or the fact that `setUI()` must be called separately before the object is fully operational.

**Fix:** Add a brief doc comment noting that `setUI()` must be called before the worker is ready to process events.

---

**A03-8** · LOW · All `BackgroundWorker` signals lack doc comments

**Description:** None of the 13 signals declared in lines 80-93 have any documentation. Several carry non-obvious semantics:
- `lockScreen(CIGCONF::MaintLockedCode code, bool remote)` — the meaning of the `remote` flag is undocumented.
- `onDemandStarted` / `onDemandExtended` / `onDemandEnded` — the `start`/`end` parameters are Unix timestamps, and the default `CIGCONF::OnDemandCmdSrc` values are silent.
- `updateStatusInfo` — carries 12 parameters with abbreviated names (`IO`, `Rly1`, `Rly2`, `rssi`, `moni`) whose semantics are not explained.

**Fix:** Add at minimum a one-line comment per signal. For signals with non-trivial parameter semantics (`lockScreen`, `updateStatusInfo`, `onDemandStarted`/`Extended`/`Ended`), describe each parameter.

---

### 2.2 `checklist.h` / `checklist.cpp`

**A03-9** · HIGH · `Checklist::CheckItem` struct and its bitfield union have no doc comment

**Description:** `CheckItem` (line 9) uses a union containing a named bitfield (`qId:31`, `doNotRandomize:1`) aliased over `questionId`. This pattern is non-trivial: `doNotRandomize` occupies bit 31 of `questionId`, meaning any code that reads `questionId` as a plain 32-bit integer will silently include the randomization flag in the value. There is no comment explaining this aliasing, the meaning of `doNotRandomize`, the significance of the 31-bit question ID space, or the fact that `questionId` and the bitfield struct must not be used simultaneously without masking.

**Fix:** Add a block comment above the struct and inline comments on each union member explaining the layout, the purpose of `doNotRandomize`, and how callers should read the question ID (via `qId`, not `questionId`, when the flag needs to be excluded).

---

**A03-10** · MEDIUM · `Checklist::checkItem()` `query` parameter behaviour is undocumented and potentially misleading

**Description:** `checkItem(int index, bool query = false)` (line 34) has a one-line comment `//Moved the implementation in the cpp file to fix circular dependency` which describes an implementation detail unrelated to the method's semantics. The `query` parameter controls whether the method returns the canonical (unshuffled) item or respects the shuffle/randomisation state. When `query == true`, the raw unshuffled item is always returned regardless of the `preopRandom()` setting; when `query == false`, the shuffled array is used if randomisation is enabled. This distinction is safety-relevant for checklist integrity: callers that intend to present questions to the driver must use `query = false`, while callers that need to inspect the configured question (e.g., for saving or transmitting) must use `query = true`. The existing comment does not mention any of this.

**Fix:** Replace the existing comment with one that documents:
- The `index` valid range (0 to `CHECKLIST_MAX_IDX - 1`).
- The meaning of `query`: `true` returns the unshuffled source item; `false` returns the item as it should be presented to the driver (shuffled if `preopRandom()` is active).
- The return value (a const reference — callers must not store it past the object's lifetime).

---

**A03-11** · LOW · `Checklist::shuffleChecklist()` has no doc comment

**Description:** `shuffleChecklist()` (line 31) populates the internal `m_checkItems_shuffled` array using a cryptographically seeded Mersenne Twister (`std::random_device` + `std::mt19937`). It only shuffles items where `doNotRandomize == 0`. No comment explains when this must be called relative to `readChecklist()`, whether it is idempotent, or what effect it has on the `checkItem()` accessor.

**Fix:** Add a doc comment explaining the shuffle algorithm preconditions, post-conditions, and the relationship to `checkItem(index, false)`.

---

**A03-12** · LOW · `Checklist::checksum()` has no doc comment

**Description:** `checksum()` (line 36) computes an XOR of all valid `questionId` values. The choice of XOR as a checksum is weak (it does not detect reordering or even-number substitutions) and the purpose of the checksum — used to detect whether the checklist has changed — is not stated. No documentation explains what value callers should compare against, when stale checksums indicate a sync problem, or the limitations of the algorithm.

**Fix:** Add a doc comment describing the return value, the algorithm (XOR fold over valid question IDs), the intended use (change detection), and the known limitation that XOR does not detect all substitution attacks.

---

**A03-13** · INFO · `Checklist::readChecklist()`, `saveChecklist()`, and `clear()` have no doc comments

**Description:** These three methods (lines 27, 29, 30) are public lifecycle operations with no documentation. `readChecklist()` silently does nothing if `m_dirty` is true; `saveChecklist()` silently does nothing if `m_dirty` is false and also deletes the legacy v50 file on a successful save; `clear()` marks the object dirty without saving. These side-effects are not documented.

**Fix:**
- `readChecklist()`: document the `m_dirty` guard (reads are skipped if unsaved changes exist) and the v50 fallback behaviour.
- `saveChecklist()`: document the no-op guard, the atomic-save via `QSaveFile`, and the legacy-file deletion.
- `clear()`: document that this marks the in-memory state dirty and that `saveChecklist()` must be called to persist the clear.

---

**A03-14** · INFO · `Checklist::setCheckItem()` has no doc comment

**Description:** `setCheckItem(int index, const CheckItem &item)` (line 35) returns a `bool` indicating success or failure (returns `false` for out-of-bounds index). No documentation describes the valid index range, the return value semantics, or the fact that the change is only persisted after a subsequent `saveChecklist()` call.

**Fix:** Add a doc comment describing the index range, the return value, and the deferred-persistence model.

---

**A03-15** · INFO · `Checklist::isValidCheckItem()` inline has no doc comment

**Description:** The static inline `isValidCheckItem(const CheckItem &item)` (line 25) returns `item.questionLen` treated as a boolean. This implies that an item with `questionLen == 0` is considered invalid (empty/unpopulated slot). This is used as the canonical emptiness test throughout the class but is not documented.

**Fix:** Add a one-line comment: `// Returns true if item is populated (questionLen > 0).`

---

## 3. Summary Table

| ID | Severity | File | Location | Title |
|----|----------|------|----------|-------|
| A03-1 | LOW | `backgroundworker.h` | line 43 | `OtaWorker::unpack()` missing doc comment |
| A03-2 | INFO | `backgroundworker.h` | line 42 | `OtaWorker` constructor missing doc comment |
| A03-3 | HIGH | `backgroundworker.h` | line 45 | Public atomic `m_isRunning` missing thread-safety documentation |
| A03-4 | LOW | `backgroundworker.h` | line 69 | `BackgroundWorker::setUI()` missing doc comment |
| A03-5 | INFO | `backgroundworker.h` | line 70 | `BackgroundWorker::networkStatus()` missing doc comment |
| A03-6 | LOW | `backgroundworker.h` | line 66 | `QuitMode` enum values undocumented |
| A03-7 | LOW | `backgroundworker.h` | line 68 | `BackgroundWorker` constructor missing doc comment |
| A03-8 | LOW | `backgroundworker.h` | lines 80-93 | All signals missing doc comments |
| A03-9 | HIGH | `checklist.h` | line 9 | `CheckItem` bitfield union aliasing undocumented |
| A03-10 | MEDIUM | `checklist.h` | line 34 | `checkItem()` `query` parameter semantics undocumented / misleading comment |
| A03-11 | LOW | `checklist.h` | line 31 | `shuffleChecklist()` missing doc comment |
| A03-12 | LOW | `checklist.h` | line 36 | `checksum()` missing doc comment; algorithm weakness unstated |
| A03-13 | INFO | `checklist.h` | lines 27/29/30 | `readChecklist()`, `saveChecklist()`, `clear()` side-effects undocumented |
| A03-14 | INFO | `checklist.h` | line 35 | `setCheckItem()` return value and persistence model undocumented |
| A03-15 | INFO | `checklist.h` | line 25 | `isValidCheckItem()` validity criterion undocumented |
# Pass 3 Agent A04 — Documentation

**Audit run:** 2026-02-28-01
**Branch:** master
**Files reviewed:**
- `app/cigconfigs.h` (no corresponding .cpp — header-only)
- `app/crctable.cpp` (no corresponding .h)
- `app/driverlist.h` + `app/driverlist.cpp`

---

## Reading Evidence

### `app/cigconfigs.h`

**No class is defined.** The file is a pure header providing preprocessor definitions, namespace-scoped enumerations, and plain structs used throughout the codebase. There is no `.cpp` counterpart.

**Preprocessor constants (all at file scope or inside namespace `CIGCONF`):**

| Constant | Value / purpose |
|---|---|
| `LFF_VERSION` | 5 |
| `SFF_VERSION` | 2 |
| `UFF_VERSION` | 2 |
| `ENG_VERSION` | "J" |
| `F_BUILD` | 6 — IQ360 |
| `C_BUILD` | 5 — MK3 LCD |
| `BROADCASTMSG_TEXT_LEN` | 100 |
| `GMTP_ID_LEN` | 33 |
| `GMTP_SERVER_CNT` | 3 |
| `SERVER_ADDR_LEN` | 33 |
| `MODEM_DIAL_NUMBER_LEN` | 9 |
| `MODEM_APN_LEN` | 33 |
| `MODEM_APN_USER_LEN` | 33 |
| `MODEM_ICCID_LEN` | 32 |
| `MODEM_APN_PASSWORD_LEN` | 66 (comment: "must >= 64 (WPA key max length)") |
| `MAX_POLY_POINTS` | 6 |
| `MAX_POLY` | 4 |
| `CHECKLIST_TIME_SLOTS` | 4 |
| `CHECKLIST_MAX_IDX` | 32 |
| `CHECKLIST_QUESTION_LEN` | 50 |
| `CHECKLIST_ITEM_SIZE` | computed |
| `CHECKLIST_QUESTION_LEN_100` | 100 |
| `CHECKLIST_ITEM_SIZE_100` | computed |
| `DRIVER_MAX_ID_IDX` | 3000 |
| `MASTER_MAX_ID_IDX` | 1024 |
| `SUPER_MAX_ID_IDX` | 100 |
| `TECH_MAX_ID_IDX` | 1000 |
| CAN bus constants | `CAN_MAX_HW_PGN`, `CAN_MAX_PGN_IDX`, `CAN_MAX_SPN_IDX`, `CAN_MAX_LINK_IDX`, `CAN_MAX_ATT_IDX`, `CAN_ATT_NAME_LEN`, `CAN_MSG_TYPE`, `CAN_MSG_DLC`, `CAN_SIG_STATUS` |
| `ON_DEMAND_DURATION` | 24*60*60 (24 hours) |
| WiFi constants | `WIFI_MAX_NETWORKS` (10), `WIFI_CONF_FILE` |
| File path constants | `FILE_DRIVER_IDS`, `FILE_MASTER_IDS`, `FILE_SUPER_IDS`, `FILE_TECH_IDS`, `FILE_CHECKLIST`, `FILE_CHECKLIST_100`, `FILE_FLEETMS_FW`, `FILE_FLEETMS_FW_RD`, `FILE_LOGIN_SCREEN`, `FILE_LOGIN_SCREEN_RD`, `FILE_ONCEPERDAY_PREOP_IDS`, `DIR_GMTP_MSG` |
| `SHOW_ALL_MASTER_MENU` | 255 (inside `CIGCONF` namespace) |

**Enumerations (all inside namespace `CIGCONF`):**

| Enum | Enumerators |
|---|---|
| `MasterMenuOptions` | `UnlockVehicle=1`, `NormalDriverAccess=2`, `ActivateVOR=4`, `MaintenanceMode=8`, `DefaultMasterMenu=7`, `UnassignedMasterMenu=255` |
| `PowerState` | `NormalPowerState`, `PreDimState`, `DimState`, `SleepActiveState`, `SleepState`, `PowerOffState` |
| `ConfigErrorCode` | `NoConfigError`, `ConfigCrcError`, `ConfigAddressError`, `ConfigSizeError`, `ConfigSectorError` |
| `FtpErrorCode` | `NoFtpError`, `FtpGenericError`, `FtpServerError`, `FtpIncompleteFileError`, `FtpSaveFileError`, `FtpNoFileError`, `FtpOSError`, `FtpParamError`, `FtpCorruptFileError`, `FtpRetryExceedError` |
| `LeaderCmdType` | `QueryCmd`, `RemoteSetCmd`, `LocalSetCmd` |
| `UnlockReasonScreen` | `Disabled`, `EnabledOptional`, `EnabledMandatory` |
| `RealImpact` | `Unconfirmed`, `No`, `Yes` |
| `DigitalInputMode` | `Default`, `Overload`, `Battery`, `SeenSafety` |
| `LeaderCmd` | ~70 command codes including `CMD_SAVE`, `CMD_KALV`, `CMD_SHTD`, `CMD_IDNT`, etc.; `CMD_UNKNOWN=0xff` |
| `GmtpMessage` | `GMTP_REGISTER`, `GMTP_AUTH_PSTAT`, `GMTP_AUTH_EOS`, `GMTP_AUTH_OPCKS`, `GMTP_AUTH_PROMPT`, `GMTP_AUTH_SHOCK`, `GMTP_AUTH_IDLETO`, `GMTP_CARD`, `GMTP_GPSE`, `GMTP_POS`, `GMTP_PAR`, `GMTP_UNLK`, `GMTP_USAGE`, `GMTP_FTPF`, `GMTP_MK3DBG`, `GMTP_SMAST`, `GMTP_CONVOR`, `GMTP_MSG_RSP`, `GMTP_WIFIPOS`, `GMTP_AUTH_SURTO`, `GMTP_AUTH_SEEN`, `GMTP_MAINT`, `GMTP_AUTH_OPCMNT`, `GMTP_OPDCHK`, `GMTP_MONIT` |
| `CheckReason` | `OptionalCheckReason=1`, `TimeBasedCheckReason=2`, `DriverBasedCheckReason=3`, `UnlockedCheckReason=4`, `OncePerDayCheckReason=5` |
| `CheckResponses` | `UndefinedCheckResponse`, `CheckResponsedYes=1`, `CheckResponsedNo=2` |
| `ChecklistType` | `NotCritical`, `CriticalByYes=1`, `CriticalByNo=2` |
| `OnDemandCmdType` | `OnDemandStart`, `OnDemandExtend=1`, `OnDemandEnd=2` |
| `OnDemandCmdSrc` | `OnDemandLocal`, `OnDemandRemote` |
| `MaintLockedCode` | `MaintNormal=0x00`, `MaintIdle=0xea`, `MaintCriticalQuestion=0xfb`, `MaintRedImpact=0xfd`, `MaintSurveyTimeout=0xfe` |
| `ShowTimeFormat` | `ShowTimeOff=0`, `ShowTime12=1`, `ShowTime24=2` |
| `BleExpansionDI` | `BleExpDI1`, `BleExpDI2`, `BleExpDI3`, `BleExpDI4` |
| `BleExpansionRelay` | `BleExpRelay1`, `BleExpRelay2` |
| `BleExpansionConnectionStatus` | `BleDisconnected`, `BleConnected` |
| `CanProtocol` | `LindeNormal`, `J1939`, `LindeExtended`, `BydCan`, `Linde1202` |
| `CanAttributeType` | `NotCanAttribute`, `CanAttributeLast`, `CanAttributeCount`, `CanAttributeTime`, `CanAttributeAlert`, `CanAttributeLast2` |
| `WifiPosSource` | `WifiPosInternal`, `WifiPosXpico240` |
| `CameraMode` | `CameraOff=0`, `CameraForced=1`, `CameraOn=2` |

**Structs (all inside namespace `CIGCONF`):**

| Struct | Fields |
|---|---|
| `CanMsgLink` | `spnIndex` (quint16), `pos` (quint8) |
| `CanMsgPara` | `identifier`, `type`, `dlc`, `sigNum`, `sigList[CAN_MAX_LINK_IDX]` |
| `CanSigPara` | `status`, `width`, `addr32`, `unused2` |
| `CigCanConfig` | `processType`, `txEnable`, `busInfo` (extended, baudRate), `unused1`, `unused2[]`, union of `unused10[]` / `CanSignalInfo` |
| `BroadcastMessage` | `id`, `text`, `type`, `res`, `timeout` |
| `WifiNetwork` | `ssid`, `pw` |
| `PreopDriverId` | `id` (quint64), `lastPreopTimestamp` (quint32) |
| `DriverId` | `id` (quint64), `name` (QString) |
| `MasterId` | `id` (quint64), `option` (quint8), `name` (QString) |
| `gpsPosStruct` | `latitude` (qint32), `longitude` (qint32) |
| `polygonStruct` | `nPoints` (quint8), `polyVertices[MAX_POLY_POINTS]` |
| `position` | `lat`, `lon`, `latrad`, `lonrad` (all double) |
| `AccessPoint` | `mac`, `rssi`, `lastSeen`, `ssid`, `channel` |
| `CheckResponse` | `id` (quint32), `type` (quint16), `response` (quint16), `text` (QString) |

No functions, signals, or slots are declared in this file.

---

### `app/crctable.cpp`

No class, no functions, no signals, no slots. The file contains only two pre-computed lookup tables exposed via `extern` linkage:

| Symbol | Type | Description |
|---|---|---|
| `crc32Table` | `const quint32[256]` | 256-entry lookup table for CRC-32 (polynomial 0xEDB88320, reflected input) |
| `crc16Table` | `const quint16[16]` | 16-entry lookup table for CRC-16 (nibble-at-a-time variant) |

No header file exists for this translation unit. The `extern` declarations at lines 3-4 are redundant (they appear immediately before the definitions in the same file).

---

### `app/driverlist.h` + `app/driverlist.cpp`

**Class:** `DriverList` (line 9, `driverlist.h`)

No signals or slots are declared.

**Public methods — complete list with line numbers (header):**

| Method | Line | Return type |
|---|---|---|
| `DriverList()` | 12 | constructor |
| `readDriverIds()` | 14 | void |
| `readMasterIds()` | 15 | void |
| `readSuperIds()` | 16 | void |
| `readTechIds()` | 17 | void |
| `saveDriverIds()` | 18 | void |
| `saveMasterIds()` | 19 | void |
| `saveSuperIds()` | 20 | void |
| `saveTechIds()` | 21 | void |
| `readPreopDriverIds()` | 22 | void |
| `savePreopDriverIds()` | 23 | void |
| `driverIds()` | 25 | `QList<CIGCONF::DriverId>` (inline) |
| `masterIds()` | 26 | `QList<CIGCONF::MasterId>` (inline) |
| `superIds()` | 27 | `QList<quint64>` (inline) |
| `techIds()` | 28 | `QList<CIGCONF::DriverId>` (inline) |
| `preopDriverIds()` | 29 | `QList<CIGCONF::PreopDriverId>` (inline) |
| `driverId(int index)` | 31 | `CIGCONF::DriverId` (inline) |
| `masterId(int index)` | 32 | `CIGCONF::MasterId` (inline) |
| `masterIdById(quint64 id)` | 33 | `CIGCONF::MasterId` |
| `superId(int index)` | 34 | `quint64` (inline) |
| `techId(int index)` | 35 | `CIGCONF::DriverId` (inline) |
| `setDriverId(int index, quint64 id, QString name)` | 37 | bool |
| `setMasterId(int index, quint64 id, quint8 option, QString name)` | 38 | bool |
| `setSuperId(int index, quint64 id)` | 39 | bool |
| `setTechId(int index, quint64 id, QString name)` | 40 | bool |
| `containsDriverId(quint64 id)` | 42 | bool (inline) |
| `containsMasterId(quint64 id, quint8 permissions)` | 50 | bool (inline) |
| `containsSuperId(quint64 id)` | 63 | bool (inline) |
| `containsTechId(quint64 id)` | 69 | bool (inline) |
| `addDriverId(quint64 id, QString name)` | 77 | bool |
| `addSuperId(quint64 id)` | 78 | bool |
| `addTechId(quint64 id, QString name)` | 79 | bool |
| `addPreopDriverId(quint64 id, quint32 timestamp)` | 80 | bool |
| `removeDriverId(quint64 id)` | 82 | bool |
| `removeMasterId(quint64 id)` | 83 | bool |
| `removeSuperId(quint64 id)` | 84 | bool |
| `removeTechId(quint64 id)` | 85 | bool |
| `clearDriverIds()` | 87 | void |
| `clearMasterIds()` | 88 | void |
| `clearSuperIds()` | 89 | void |
| `clearTechIds()` | 90 | void |
| `clearPreopDriverIds()` | 91 | void |
| `driverChecksum()` | 93 | quint32 |
| `masterChecksum()` | 94 | quint32 |
| `superChecksum()` | 95 | quint32 |
| `techChecksum()` | 96 | quint32 |
| `superIsEmpty()` | 98 | bool |
| `getMasterIdIndex(quint64 id)` | 100 | int |
| `getDriverIdIndex(quint64 id)` | 101 | int |
| `getTechIdIndex(quint64 id)` | 102 | int |
| `getPreopDriverIdIndex(quint64 id)` | 103 | int |
| `getPreopDriverId(quint64 id)` | 104 | `CIGCONF::PreopDriverId` |

**Private data members:**

| Member | Type |
|---|---|
| `m_driverIds` | `QList<CIGCONF::DriverId>` |
| `m_masterIds` | `QList<CIGCONF::MasterId>` |
| `m_superIds` | `QList<quint64>` |
| `m_techIds` | `QList<CIGCONF::DriverId>` |
| `m_preopDriverIds` | `QList<CIGCONF::PreopDriverId>` |
| `m_driverIdsDirty` | bool |
| `m_masterIdsDirty` | bool |
| `m_superIdsDirty` | bool |
| `m_techIdsDirty` | bool |
| `m_preopDriverDirty` | bool |

---

## Documentation Check Results

### cigconfigs.h — public API surface

No functions are declared; there is nothing to check for per-method documentation. The items below apply to the constant and type declarations.

| Item | Has doc comment? | Notes |
|---|---|---|
| `MODEM_APN_PASSWORD_LEN` | Partial — inline comment explains the minimum size constraint | Adequate |
| File-path macros block | Block comment at lines 59-63 | Explains FTP-update threading concern; accurate |
| `CAN_MAX_PGN_IDX`, `CAN_MAX_SPN_IDX`, `CAN_MAX_LINK_IDX`, `CAN_MAX_ATT_IDX` | Inline comments giving valid index ranges | Adequate |
| `LeaderCmd` enum | Comment "note: register the string in hash on new command adding" at line 102 | Only for the first enumerator group; the second block (after `CMD_UNKNOWN`) has no such reminder |
| All other enumerations and structs | None | No explanatory comments |
| `CanSigPara::unused2` | `void *unused2; // set to nullptr` | Correct but does not explain why the field exists |
| `CigCanConfig` union | Fields named `unused*` throughout | Intent of the union overlay is completely undocumented |
| `MaintLockedCode` hex values | No explanation of what each numeric code means in the FSM | Values like `0xea`, `0xfb`, `0xfd`, `0xfe` are opaque |
| `ON_DEMAND_DURATION` | Inline comment shows the arithmetic decomposition | Adequate |

### crctable.cpp — public API surface

No functions or class members are declared. The two `extern` array declarations at lines 3-4 have no comments at all. No header file exists.

### driverlist.h — all public methods

Every single public method in `DriverList` lacks any doc comment. The inline bodies of `containsDriverId`, `containsMasterId`, `containsSuperId`, `containsTechId` contain no explanatory comments either.

---

## Findings

**A04-1** · HIGH · No documentation on security-critical authentication methods

**Description:** `containsDriverId`, `containsMasterId`, `containsSuperId`, and `containsTechId` are the four gatekeeping methods that determine whether a presented credential authorises vehicle access, master-level control, supervisor control, or technician access respectively. None of the four has any doc comment. Critically, all four contain a non-obvious special case: the value `id == 1` is always rejected regardless of whether it appears in the list (`return id != 1 ? true : false`). This sentinel behaviour — which silently denies access for ID `0x0000000000000001` — is undocumented. A maintainer adding a new authentication path (e.g. BLE) could trivially omit this check. `containsMasterId` has an additional undocumented behaviour: the `permissions` parameter performs a bitmask AND against `m_masterIds[i].option`; when `permissions == 0` the check is skipped entirely, which is also undocumented.

**Fix:** Add a doc comment above each of these four methods that (1) states the purpose, (2) documents all parameters, (3) explicitly calls out that `id == 1` is always treated as unauthorised, and (4) for `containsMasterId`, explains that `permissions == 0` means "no permission filter".

---

**A04-2** · HIGH · No documentation on ID-list file I/O methods

**Description:** `readDriverIds`, `readMasterIds`, `readSuperIds`, `readTechIds`, `readPreopDriverIds`, `saveDriverIds`, `saveMasterIds`, `saveSuperIds`, `saveTechIds`, and `savePreopDriverIds` all read from or write to persistent flat files that control which operators are authorised to use the vehicle. None has any doc comment. Important behavioural details are invisible from the header: the save methods silently no-op when the in-memory dirty flag is false; `savePreopDriverIds` filters out entries whose `lastPreopTimestamp` date does not match today's local date, permanently discarding stale entries; `savePreopDriverIds` uses plain `QFile` (not `QSaveFile`) so a crash mid-write will corrupt the once-per-day pre-op list; all read methods accept hex-encoded IDs; `readMasterIds` expects up to three comma-separated fields while `readDriverIds`/`readTechIds` expect up to two.

**Fix:** Add doc comments to all ten methods documenting: the file path constant used, the on-disk format, dirty-flag semantics, and any filtering or side-effects on save.

---

**A04-3** · MEDIUM · `savePreopDriverIds` inconsistency between description implied by dirty-flag pattern and actual date-filtering behaviour

**Description:** Every other `save*` method in `DriverList` persists all in-memory entries unchanged. `savePreopDriverIds` (lines 233-265, `driverlist.cpp`) silently discards any `PreopDriverId` whose `lastPreopTimestamp` does not fall on the current local date before writing. This is a material behavioural difference — it is a purge operation disguised as a save. There is no comment on this method explaining the purge, its rationale, or that the `gCfg->localTime()` call is used to determine "today". A caller that expects all entries to survive a round-trip will be surprised.

**Fix:** Add a doc comment to `savePreopDriverIds` stating that it acts as both a save and a garbage-collection step, that only entries matching the current local date are retained, and that `gCfg->localTime()` supplies the reference time.

---

**A04-4** · MEDIUM · Undocumented sentinel value `id == 1` is never authorised in any list

**Description:** In `containsDriverId` (line 42), `containsMasterId` (line 50), `containsSuperId` (line 63), and `containsTechId` (line 69), the expression `return id != 1 ? true : false` silently denies any credential with raw ID value `1` even if that ID is present in the list. The value `0x1` is treated as a reserved/invalid credential. This logic is present in all four methods but is explained nowhere — not in the header, not in the implementation, and not in `cigconfigs.h`. It is distinct from the `id == 0` guard used in `addDriverId`/`addSuperId`/etc. which guards against the zero/empty entry.

**Fix:** Add an inline comment at each occurrence and a header-level doc comment on each `contains*` method stating that ID `1` is reserved and is unconditionally denied regardless of list contents. Additionally, define a named constant (e.g. `RESERVED_INVALID_ID`) or add a comment in `cigconfigs.h` explaining the reservation.

---

**A04-5** · MEDIUM · `masterIdById` undocumented option-field rewrite

**Description:** `masterIdById` (line 645, `driverlist.cpp`) performs a non-obvious mutation: when it finds the requested master ID and that record's `option` field equals `UnassignedMasterMenu` (255), it silently replaces the `option` in the **returned copy** with `DefaultMasterMenu` (7) before returning. This substitution is not mentioned in the header declaration (line 33) and there is no comment in the implementation. A caller that stores the returned `MasterId` and later compares `option` against the original list value will observe a discrepancy.

**Fix:** Add a doc comment to the declaration and implementation of `masterIdById` stating that a stored `option` value of `UnassignedMasterMenu` (255) is normalised to `DefaultMasterMenu` (7) in the return value.

---

**A04-6** · LOW · No documentation on checksum methods

**Description:** `driverChecksum`, `masterChecksum`, `superChecksum`, and `techChecksum` (lines 93-96, header) compute a 32-bit value over the respective ID lists. No doc comment explains the algorithm used (XOR folding of the 64-bit IDs into two 32-bit halves), what the checksum is used for (synchronisation with a remote server), or whether it provides integrity guarantees. The inline comment in the implementation (`// or ignore id that equals 0?`) reveals an unresolved design question that should be in a doc comment or a tracked issue, not an implementation comment.

**Fix:** Add doc comments stating the algorithm, the use-case (e.g. change-detection for remote sync), and resolve or escalate the open question about whether zero-valued entries should be excluded.

---

**A04-7** · LOW · No documentation on `addPreopDriverId` upsert behaviour

**Description:** `addPreopDriverId` (line 80, header) behaves as an upsert: if the `id` already exists in `m_preopDriverIds`, the existing entry's timestamp is updated in-place rather than a duplicate being appended. If the `id` is `0`, the method returns `false` immediately. Neither behaviour is documented. The method name suggests append-only semantics to a reader unfamiliar with the implementation.

**Fix:** Add a doc comment noting the upsert semantics, the zero-ID guard, and that `timestamp` should be a Unix epoch second.

---

**A04-8** · LOW · `getPreopDriverIdIndex` contains a dead forward-declaration in its body

**Description:** At line 433 of `driverlist.cpp`, inside the body of `getPreopDriverIdIndex`, there is:
```cpp
CIGCONF::PreopDriverId getPreopDriverId(quint64 id);
```
This is a local function declaration (not a call) and is completely inert — it does not invoke `getPreopDriverId` and the return value is discarded. It appears to be a cut-and-paste residue. Although this is primarily a code-quality issue, it constitutes misleading inline documentation because a reader of `getPreopDriverIdIndex` will assume this declaration serves a purpose.

**Fix:** Remove the dead declaration at line 433. Add a brief comment to `getPreopDriverIdIndex` explaining that it returns `-1` when the ID is not found or when `id == 0`.

---

**A04-9** · LOW · No documentation on `crctable.cpp` lookup tables and no header file

**Description:** `crctable.cpp` exposes `crc32Table` and `crc16Table` via `extern` linkage with no corresponding header file. Any translation unit that uses these tables must redeclare them manually using `extern const quint32/quint16`. There are no comments identifying the CRC polynomial, the bit ordering (reflected vs. normal), or the intended usage context (which functions should call these). The redundant `extern` declarations at the top of the same file that defines the symbols (lines 3-4) are also unexplained.

**Fix:** Create `app/crctable.h` with `extern` declarations and a doc comment identifying the CRC-32 polynomial (0xEDB88320, reflected), the CRC-16 variant (nibble-at-a-time), and which code modules consume each table. Remove the redundant self-`extern` declarations from `crctable.cpp`.

---

**A04-10** · LOW · `CigCanConfig` union overlay is completely undocumented

**Description:** The `CigCanConfig` struct (lines 195-243, `cigconfigs.h`) contains an anonymous union whose first member is a large array of `unused*` fields and whose second member (`CanSignalInfo`) is the live data. The purpose of the union overlay — presumably backward-compatibility with an older on-disk or on-wire layout — is nowhere explained. Field names `unused1` through `unused10` provide no context. The struct has no doc comment.

**Fix:** Add a block comment above `CigCanConfig` explaining: the struct's purpose (CAN bus configuration storage), the role of the union (legacy layout compatibility or reserved space), and ideally the version of the configuration format it corresponds to.

---

**A04-11** · LOW · `MaintLockedCode` hex values undocumented

**Description:** The `MaintLockedCode` enum (lines 142-148, `cigconfigs.h`) uses non-sequential hex values (`0xea`, `0xfb`, `0xfd`, `0xfe`) with no explanation. It is unclear whether these are protocol wire values, persistent storage codes, or internal FSM states. There is no doc comment on the enum.

**Fix:** Add a comment above the enum stating the context in which these values appear (wire protocol, EEPROM, FSM), the significance of each hex value, and why they are non-sequential.

---

**A04-12** · INFO · Inline getters lack doc comments

**Description:** The five bulk-getter methods — `driverIds()`, `masterIds()`, `superIds()`, `techIds()`, `preopDriverIds()` (lines 25-29) — and the five indexed single-item getters — `driverId(int)`, `masterId(int)`, `superId(int)`, `techId(int)`, and the lookup `masterIdById(quint64)` (lines 31-35) — have no doc comments. For the inline single-item getters, the return value on out-of-range `index` (a zero-initialised struct) is not documented.

**Fix:** Add brief doc comments to the indexed getters noting the out-of-range return value. The bulk list getters are self-explanatory and require only a single-line description.

---

**A04-13** · INFO · `LeaderCmd` second block lacks the "register string in hash" reminder

**Description:** At line 102, a comment reads `// note: register the string in hash on new command adding`. This reminder applies to the entire `LeaderCmd` enum but appears only above the first block of enumerators. A second block of enumerators begins after `CMD_UNKNOWN = 0xff` (line 121) with no such reminder. A developer adding a command to the second block could miss the registration requirement.

**Fix:** Move the registration reminder to the enum-level doc comment rather than embedding it inside the enumerator list, or repeat it at the start of the second block.

---

## Summary Table

| ID | Severity | Title |
|---|---|---|
| A04-1 | HIGH | No documentation on security-critical authentication methods |
| A04-2 | HIGH | No documentation on ID-list file I/O methods |
| A04-3 | MEDIUM | `savePreopDriverIds` date-filtering purge behaviour undocumented |
| A04-4 | MEDIUM | Undocumented sentinel: `id == 1` is never authorised in any list |
| A04-5 | MEDIUM | `masterIdById` undocumented option-field rewrite |
| A04-6 | LOW | No documentation on checksum methods |
| A04-7 | LOW | No documentation on `addPreopDriverId` upsert behaviour |
| A04-8 | LOW | Dead forward-declaration inside `getPreopDriverIdIndex` body |
| A04-9 | LOW | No documentation on CRC lookup tables; no header file |
| A04-10 | LOW | `CigCanConfig` union overlay completely undocumented |
| A04-11 | LOW | `MaintLockedCode` hex values undocumented |
| A04-12 | INFO | Inline getters lack doc comments; out-of-range return value undocumented |
| A04-13 | INFO | `LeaderCmd` registration reminder missing from second enumerator block |
# Pass 3 Agent A05 — Documentation

**Audit run:** 2026-02-28-01
**Branch:** master
**Assigned files:**
- `app/globalconfigs.h` (866 lines)
- `app/globalconfigs.cpp` (819 lines)
- `app/globalconfigsfilemanager.h` — **FILE NOT FOUND** (does not exist in repository)
- `app/globalconfigsfilemanager.cpp` — **FILE NOT FOUND** (does not exist in repository)

---

## 1. Reading Evidence

### 1.1 `app/globalconfigs.h` / `app/globalconfigs.cpp`

#### Class

| Class | Base | Line |
|-------|------|------|
| `GlobalConfigs` | `QObject` | 15 |

#### Macro / Global Accessor

| Name | Line | Description |
|------|------|-------------|
| `gCfg` | 13 | Macro expanding to `GlobalConfigs::instance()` |

#### Public Methods (header line numbers)

| Method | Line | Notes |
|--------|------|-------|
| `GlobalConfigs(QObject *parent = nullptr)` | 20 | Constructor |
| `static GlobalConfigs *instance()` | 21 | Singleton accessor |
| `static quint32 crc32(const void *buf, int len)` | 22 | CRC-32 utility |
| `void readConfigs()` | 24 | Loads all config sub-systems |
| `void saveConfigs()` | 25 | Saves all config sub-systems |
| `void saveOpdDriverList()` | 26 | Saves once-per-day preop driver list |
| `void resetConfigs(bool resetAll = false)` | 27 | Resets config to defaults |
| `quint32 keepAliveTime() const` | 30 | Getter |
| `bool setKeepAliveTime(quint32 time)` | 31 | Setter — validates 0 < time <= 60000 |
| `quint32 shutdownTime() const` | 40 | Getter |
| `bool setShutdownTime(quint32 time)` | 41 | Setter — validates 0 < time <= 255 |
| `QByteArray gmtpId() const` | 50 | Getter |
| `bool setGmtpId(const QByteArray &id)` | 51 | Setter — validates non-empty, size < GMTP_ID_LEN |
| `CIGCONF::MaintLockedCode maintCode() const` | 60 | Getter |
| `quint64 maintDriverId() const` | 61 | Getter |
| `quint32 maintTimestamp() const` | 62 | Getter |
| `bool setMaintCode(CIGCONF::MaintLockedCode code)` | 64 | Setter — validates code whitelist; blocks overwrite of non-zero code |
| `quint64 unlockId() const` | 81 | Getter |
| `bool setUnlockId(quint64 id)` | 82 | Setter — always returns true |
| `QByteArray dialNumber() const` | 87 | Getter |
| `bool setDialNumber(const QByteArray &number)` | 88 | Setter — validates size < MODEM_DIAL_NUMBER_LEN |
| `QByteArray apn() const` | 97 | Getter |
| `bool setApn(const QByteArray &apn)` | 98 | Setter |
| `QByteArray apnUser() const` | 107 | Getter |
| `bool setApnUser(const QByteArray &user)` | 108 | Setter |
| `QByteArray apnPassword() const` | 117 | Getter |
| `bool setApnPassword(const QByteArray &password)` | 118 | Setter |
| `QByteArray gmtpServerAddress(int index) const` | 127 | Getter — no bounds check on read |
| `bool setGmtpServerAddress(int index, const QByteArray &addr)` | 128 | Setter — validates index, addr size |
| `quint16 gmtpServerPort(int index) const` | 137 | Getter — no bounds check on read |
| `bool setGmtpServerPort(int index, quint16 port)` | 138 | Setter — validates index, port != 0 |
| `quint64 expansionModMac() const` | 147 | Getter |
| `bool setExpansionModMac(quint64 mac)` | 148 | Setter — validates mac != 0 |
| `void resetSimCardID()` | 157 | Clears SIM ICCID buffer |
| `QByteArray getSimCardID() const` | 158 | Getter |
| `bool setSimCardID(const QByteArray &iccid)` | 159 | Setter — validates size < MODEM_ICCID_LEN |
| `QList<CIGCONF::DriverId> driverIds() const` | 168 | Getter |
| `QList<CIGCONF::MasterId> masterIds() const` | 169 | Getter |
| `QList<quint64> superIds() const` | 170 | Getter |
| `QList<CIGCONF::DriverId> techIds() const` | 171 | Getter |
| `QList<CIGCONF::PreopDriverId> preopDriverIds() const` | 172 | Getter |
| `CIGCONF::DriverId driverId(int index) const` | 174 | Getter by index |
| `CIGCONF::MasterId masterId(int index) const` | 175 | Getter by index |
| `CIGCONF::MasterId masterIdById(quint64 id) const` | 176 | Getter by ID |
| `quint64 superId(int index) const` | 177 | Getter by index |
| `CIGCONF::DriverId techId(int index) const` | 178 | Getter by index |
| `bool setDriverId(int index, quint64 id, QString name)` | 180 | Setter — delegates to DriverList |
| `bool setMasterId(int index, quint64 id, quint8 option, QString name)` | 181 | Setter |
| `bool setSuperId(int index, quint64 id)` | 182 | Setter — emits superListChanged |
| `bool setTechId(int index, quint64 id, QString name)` | 183 | Setter |
| `bool containsDriverId(quint64 id) const` | 185 | Lookup |
| `bool containsMasterId(quint64 id, quint8 permissions=0) const` | 186 | Lookup |
| `bool containsSuperId(quint64 id) const` | 187 | Lookup |
| `bool containsTechId(quint64 id) const` | 188 | Lookup |
| `bool addDriverId(quint64 id, QString name)` | 190 | Add to driver list |
| `bool addSuperId(quint64 id)` | 191 | Add to super list — emits superListChanged |
| `bool addTechId(quint64 id, QString name)` | 192 | Add to tech list |
| `bool addPreopDriverId(quint64 id, quint32 timestamp)` | 193 | Add preop driver |
| `bool removeDriverId(quint64 id)` | 195 | Remove from driver list |
| `bool removeMasterId(quint64 id)` | 196 | Remove from master list |
| `bool removeSuperId(quint64 id)` | 197 | Remove — emits superListChanged |
| `bool removeTechId(quint64 id)` | 198 | Remove from tech list |
| `void clearDriverIds()` | 200 | Clear driver list |
| `void clearMasterIds()` | 201 | Clear master list |
| `void clearSuperIds()` | 202 | Clear super list — emits superListChanged |
| `void clearTechIds()` | 203 | Clear tech list |
| `void clearPreopDriverIds()` | 204 | Clear preop driver list |
| `int getMasterIdIndex(quint64 id)` | 206 | Index lookup |
| `int getDriverIdIndex(quint64 id)` | 207 | Index lookup |
| `int getTechIdIndex(quint64 id)` | 208 | Index lookup |
| `int getPreopDriverIdIndex(quint64 id)` | 209 | Index lookup |
| `CIGCONF::PreopDriverId getPreopDriverId(quint64 id)` | 210 | Lookup by ID |
| `bool preopOncePerDayEn() const` | 212 | Getter |
| `bool setPreopOncePerDayEn(bool en)` | 213 | Setter — emits preopOncePerDayStatusChanged |
| `QString getDriverName(quint64 id)` | 220 | Returns name from any driver list |
| `bool superIsEmpty()` | 233 | Returns whether super list is empty |
| `quint8 digitalInputMode1() const` | 235 | Getter |
| `quint8 digitalInputMode2() const` | 236 | Getter |
| `quint8 digitalInputMode3() const` | 237 | Getter |
| `quint8 digitalInputMode4() const` | 238 | Getter |
| `void setDigInputMode(...)` | 240 | Setter for all 4 digital input modes |
| `quint32 seenDebounceTime() const` | 248 | Getter |
| `quint32 seenHoldTime() const` | 249 | Getter |
| `bool setSeenParam(quint32 debounce, quint32 hTime)` | 250 | Setter |
| `quint8 convorStatus() const` | 257 | Getter |
| `quint64 convorId() const` | 258 | Getter |
| `bool setConvor(quint8 convor, quint64 id)` | 259 | Setter — emits convorStatusChanged; side-effect: clears last check timestamp |
| `quint8 fullLockoutEnable() const` | 270 | Getter |
| `bool setFullLockoutEnable(quint8 lockOutEnable)` | 271 | Setter |
| `quint32 fullLockoutTimeout() const` | 277 | Getter |
| `bool setFullLockoutTimeout(quint32 lockOutTimeout)` | 278 | Setter |
| `quint8 unlkScr() const` | 284 | Getter |
| `bool setUnlkScr(quint8 scr)` | 285 | Setter — validates scr <= EnabledMandatory |
| `quint8 scrSavMode() const` | 294 | Getter |
| `bool setScrSavMode(quint8 mode)` | 295 | Setter — validates mode <= 1 |
| `quint16 checkTimeSlot(int index) const` | 304 | Getter — no bounds check on read |
| `bool setCheckTimeSlot(int index, quint16 hm)` | 305 | Setter |
| `quint16 checklistTimeout() const` | 314 | Getter |
| `bool setChecklistTimeout(quint16 time)` | 315 | Setter — validates time <= 6000 |
| `quint64 lastTimeServerUpdate() const` | 324 | Getter |
| `bool setLastTimeServerUpdate(quint64 ts)` | 325 | Setter |
| `qint64 timeError() const` | 330 | Getter |
| `bool setTimeError(qint64 ts)` | 331 | Setter |
| `quint32 lastPreopOncePerDayTimestamp() const` | 336 | Getter |
| `bool setlastPreopOncePerDayTimestamp(quint32 ts)` | 337 | Setter — persists immediately |
| `quint32 lastCheckTimestamp() const` | 344 | Getter |
| `bool setLastCheckTimestamp(quint32 ts)` | 345 | Setter — persists immediately |
| `quint64 lastCheckDriverId() const` | 352 | Getter |
| `bool setLastCheck(quint64 id, quint32 ts)` | 353 | Setter — updates both timestamp and driver ID, persists |
| `void clearChecklist()` | 361 | Clears checklist |
| `Checklist::CheckItem checkItem(int index, bool query = false)` | 362 | Getter |
| `bool setCheckItem(int index, const Checklist::CheckItem item)` | 363 | Setter |
| `int nextValidCheckItemIndex(int start = 0, bool queryOrigList = false)` | 367 | Returns next valid checklist item index |
| `void shuffleChecklist()` | 374 | Randomizes checklist order |
| `quint8 preopRandom() const` | 375 | Getter |
| `bool setPreopRandom(quint8 isRandom)` | 376 | Setter |
| `quint32 shockThreshold() const` | 382 | Getter |
| `bool setShockThreshold(quint32 data)` | 383 | Setter |
| `quint32 shockRedImpact() const` | 389 | Getter |
| `bool setShockRedImpact(quint32 data)` | 390 | Setter |
| `quint32 shockPeriod() const` | 396 | Getter |
| `bool setShockPeriod(quint32 data)` | 397 | Setter |
| `quint32 shockTimer() const` | 403 | Getter |
| `bool setShockTimer(quint32 data)` | 404 | Setter |
| `qint16 timeZoneInMinutes() const` | 410 | Getter |
| `bool setTimeZoneInMinutes(qint16 zone)` | 411 | Setter — validates -720 <= zone <= 840 |
| `QByteArray timeServerAddress() const` | 419 | Getter |
| `bool setTimeServerAddress(const QByteArray &addr)` | 420 | Setter |
| `quint32 gpsUpdateTime() const` | 429 | Getter |
| `bool setGpsUpdateTime(quint32 time)` | 430 | Setter — validates time != 0 |
| `qint16 gpsDistanceMark() const` | 439 | Getter |
| `bool setGpsDistanceMark(qint16 mark)` | 440 | Setter — validates mark != 0 |
| `quint16 satNum() const` | 449 | Getter |
| `bool setSatNum(quint16 n)` | 450 | Setter — validates 0 < n < 21 |
| `quint16 idleTimeout() const` | 459 | Getter |
| `bool setIdleTimeout(quint16 time)` | 460 | Setter — no validation |
| `quint16 getGmtpWaitTimeout() const` | 466 | Getter |
| `bool setGmtpWaitTimeout(quint16 time)` | 467 | Setter — no validation |
| `bool idleInputPolarity() const` | 473 | Getter |
| `bool setIdleInputPolarity(bool high)` | 474 | Setter |
| `quint8 idleInputSource() const` | 480 | Getter |
| `bool setIdleInputSource(quint8 src)` | 481 | Setter — validates allowed bitmask values |
| `CIGCONF::polygonStruct polygon(int n) const` | 490 | Getter — no bounds check |
| `quint8 polygonNPoints(int n) const` | 492 | Getter — no bounds check |
| `bool setPolygonNPoints(int n, quint8 vect)` | 493 | Setter |
| `quint32 polygonLatitude(int n, int vect) const` | 502 | Getter — no bounds check |
| `bool setPolygonLatitude(int n, int vect, quint32 lat)` | 503 | Setter |
| `quint32 polygonLongitude(int n, int vect) const` | 512 | Getter — no bounds check |
| `bool setPolygonLongitude(int n, int vect, quint32 lon)` | 513 | Setter |
| `quint32 configVersion() const` | 524 | Getter |
| `quint8 backlight() const` | 526 | Getter |
| `quint32 checksum() const` | 527 | Getter |
| `CIGCONF::ConfigErrorCode configErrorCode() const` | 529 | Getter |
| `void readPreopDriverIds()` | 531 | Triggers preop driver list read |
| `void readDriverIds()` | 532 | Triggers driver list read |
| `void readMasterIds()` | 533 | Triggers master list read |
| `void readSuperIds()` | 534 | Triggers super list read — emits superListChanged |
| `void readTechIds()` | 535 | Triggers tech list read |
| `void readChecklist()` | 536 | Triggers checklist read |
| `quint32 driverChecksum() const` | 537 | Getter |
| `quint32 masterChecksum() const` | 538 | Getter |
| `quint32 superChecksum() const` | 539 | Getter |
| `quint32 questionChecksum() const` | 540 | Getter |
| `quint32 timestamp() const` | 542 | Returns current UTC Unix epoch (seconds) |
| `quint32 localTimestamp() const` | 543 | Returns local time Unix epoch (seconds) |
| `QDateTime localTime() const` | 545 | Returns local QDateTime adjusted by timezone |
| `quint64 clockTime() const` | 547 | Returns monotonic clock in ms (ARM only; returns 0 on other platforms) |
| `QString preopCommentString() const` | 557 | Getter |
| `void setPreopCommentString(QString msg)` | 558 | Setter |
| `QString UnlkReasonString() const` | 560 | Getter |
| `void setUnlkReasonString(QString msg)` | 561 | Setter |
| `CIGCONF::RealImpact UnlkOption() const` | 563 | Getter |
| `void setUnlkOption(CIGCONF::RealImpact option)` | 564 | Setter |
| `quint64 currentDriverId() const` | 566 | Getter |
| `void setCurrentDriverId(quint64 id)` | 567 | Setter |
| `quint64 fwVersion()` | 569 | Returns packed firmware version |
| `QString fwVersionString()` | 570 | Returns firmware version as human-readable string |
| `quint32 onDemandStartTime() const` | 573 | Getter |
| `quint32 onDemandEndTime() const` | 574 | Getter |
| `quint64 onDemandSmId() const` | 575 | Getter |
| `void setOnDemand(quint32 start, quint32 end, quint64 id)` | 577 | Setter — persists immediately |
| `void clearOnDemand()` | 583 | Clears on-demand config — persists immediately |
| `bool onDemandActive()` | 585 | Returns true if super list is non-empty |
| `bool onDemandVehicleEnabled()` | 586 | Returns true if on-demand window is active |
| `bool setWifiNetwork(quint32 index, const QByteArray &ssid, const QByteArray &pw)` | 588 | Setter — validates SSID/pw lengths |
| `CIGCONF::WifiNetwork wifiNetwork(quint32 index) const` | 589 | Getter |
| `bool setWifiCountry(const QByteArray &country)` | 591 | Setter — validates 2-char country code |
| `QByteArray wifiCountry() const` | 592 | Getter |
| `void clearWifiConfig()` | 594 | Resets Wi-Fi config to defaults |
| `quint8 wifiPos() const` | 596 | Getter |
| `quint16 wifiPosInterval() const` | 597 | Getter |
| `CIGCONF::WifiPosSource wifiPosSource() const` | 598 | Getter |
| `bool setWifiPos(...)` | 599 | Setter |
| `bool isRs232AccessoryActive()` | 606 | Returns true if RS-232 accessory is in use |
| `qint16 debugMsg() const` | 608 | Getter |
| `void setDebugMsg(qint16 n)` | 609 | Setter |
| `qint16 debugSpn() const` | 611 | Getter |
| `void setDebugSpn(qint16 n)` | 612 | Setter |
| `quint32 geofenceState() const` | 614 | Getter |
| `void setGeofenceState(quint32 state)` | 615 | Setter |
| `quint8 showDriverName() const` | 617 | Getter |
| `bool setShowDriverName(quint8 show)` | 618 | Setter |
| `bool GPSMsgLogEn() const` | 624 | Getter |
| `void setGPSMsgLogEn(bool en)` | 625 | Setter |
| `quint8 showPreopComment() const` | 630 | Getter |
| `void setShowPreopComment(quint8 show)` | 631 | Setter |
| `quint8 amberImpactAlertActive() const` | 636 | Getter |
| `void setAmberImpactAlertActive(quint8 state)` | 637 | Setter |
| `quint8 idleLockout() const` | 642 | Getter |
| `bool setIdleLockout(quint8 en)` | 643 | Setter |
| `quint8 showPreopSummary() const` | 649 | Getter |
| `void setShowPreopSummary(quint8 show)` | 650 | Setter |
| `quint8 unlockMode() const` | 655 | Getter |
| `void setUnlockMode(quint8 mode)` | 656 | Setter — no validation of mode value |
| `quint8 forceChecklist() const` | 661 | Getter |
| `bool setForceChecklist(quint8 force)` | 662 | Setter — persists immediately |
| `quint8 showTime() const` | 669 | Getter |
| `void setShowTime(quint8 format)` | 670 | Setter |
| `quint8 vdiMode() const` | 675 | Getter |
| `void setVdiMode(quint8 mode)` | 676 | Setter |
| `CIGCONF::CameraMode cameraMode() const` | 681 | Getter |
| `void setCameraMode(CIGCONF::CameraMode mode)` | 682 | Setter |
| `quint8 cameraFlip() const` | 687 | Getter |
| `void setCameraFlip(quint8 flip)` | 688 | Setter |
| `QByteArray lastSessionDriver() const` | 693 | Getter |
| `QByteArray lastSessionStart() const` | 694 | Getter |
| `QByteArray lastSessionEnd() const` | 695 | Getter |
| `void setLastSessionDriver(const QByteArray& driver)` | 696 | Setter — marks dynDirty but does not persist immediately |
| `void setLastSessionStart(const QByteArray& start)` | 700 | Setter — marks dynDirty but does not persist immediately |
| `void setLastSessionEnd(const QByteArray& end)` | 704 | Setter — marks dynDirty but does not persist immediately |

#### Signals

| Signal | Line | Description |
|--------|------|-------------|
| `superListChanged(bool empty)` | 710 | Emitted when super (supervisor) driver list changes |
| `convorStatusChanged()` | 711 | Emitted when VOR/convor status changes |
| `preopOncePerDayStatusChanged()` | 712 | Emitted when once-per-day preop enable flag changes |

#### Private Types (inner structs defined in header)

| Type | Line | Description |
|------|------|-------------|
| `ConfigsData` (struct) | 715 | Binary-serialized primary config block with magic code and CRC |
| `ConfigsDataExt` (struct) | 760 | Extension config (unlock screen setting) |
| `OnDemandData` (struct) | 764 | On-demand access window config |
| `ConvorData` (struct) | 780 | VOR/convor status |
| `DigitalInputCfg` (struct) | 788 | 4-channel digital input configuration |
| `FullLockoutData` (struct) | 835 | Full lockout enable + timeout |

#### Enums / Constants (from `app/cigconfigs.h`, consumed throughout)

Key types visible and used in `GlobalConfigs` interface:

| Name | Kind | Relevant values |
|------|------|-----------------|
| `CIGCONF::MaintLockedCode` | enum | `MaintNormal`, `MaintIdle`, `MaintCriticalQuestion`, `MaintRedImpact`, `MaintSurveyTimeout` |
| `CIGCONF::ConfigErrorCode` | enum | `NoConfigError`, `ConfigCrcError`, `ConfigAddressError`, `ConfigSizeError`, `ConfigSectorError` |
| `CIGCONF::RealImpact` | enum | `Unconfirmed`, `No`, `Yes` |
| `CIGCONF::UnlockReasonScreen` | enum | `Disabled`, `EnabledOptional`, `EnabledMandatory` |
| `CIGCONF::CameraMode` | enum | `CameraOff`, `CameraForced`, `CameraOn` |
| `CIGCONF::ShowTimeFormat` | enum | `ShowTimeOff`, `ShowTime12`, `ShowTime24` |
| `CIGCONF::WifiPosSource` | enum | `WifiPosInternal`, `WifiPosXpico240` |
| `CIGCONF::DriverId` | struct | `id`, `name` |
| `CIGCONF::MasterId` | struct | `id`, `option`, `name` |
| `CIGCONF::PreopDriverId` | struct | `id`, `lastPreopTimestamp` |
| `CIGCONF::polygonStruct` | struct | `nPoints`, `polyVertices[]` |
| `CIGCONF::WifiNetwork` | struct | `ssid`, `pw` |
| `GMTP_ID_LEN` | macro constant | 33 |
| `GMTP_SERVER_CNT` | macro constant | 3 |
| `CHECKLIST_TIME_SLOTS` | macro constant | 4 |
| `CHECKLIST_MAX_IDX` | macro constant | 32 |
| `MAX_POLY` | macro constant | 4 |
| `MAX_POLY_POINTS` | macro constant | 6 |
| `WIFI_MAX_NETWORKS` | macro constant | 10 |
| `MODEM_ICCID_LEN` | macro constant | 32 |
| `MODEM_APN_PASSWORD_LEN` | macro constant | 66 |

### 1.2 `app/globalconfigsfilemanager.h` / `app/globalconfigsfilemanager.cpp`

These files were listed as assigned targets but **do not exist** in the repository. A filesystem search (`Glob`) for `**/globalconfigsfilemanager*` returned no results. No findings can be raised for absent files.

---

## 2. Documentation Check Results

No doc comments of any form (`///`, `/** */`, `//`) appear above any public method declaration in `globalconfigs.h`. The only inline comments present are:

- A section boundary comment `// --> AT command` (line 29) and `// <-- AT command` (line 522) that mark a group of AT-configurable setters/getters as a block, but provide no per-method documentation.
- The comment `//MK3-301` (line 156) is a ticket reference, not a doc comment.
- Inline member-variable comments exist inside private structs (`ConfigsData`, etc.) but these are not doc comments on public methods.

With zero doc comments on any public method, all findings below address missing documentation at the appropriate severity level determined by method complexity and safety criticality.

---

## 3. Findings

**A05-1** · HIGH · No documentation on `crc32()` — security-critical integrity function

**Description:** `static quint32 crc32(const void *buf, int len)` (line 22) is used directly in `readConfigs()` and `saveConfigs()` to validate the integrity of the primary binary config block (`fmscfg.dat`). There is no doc comment describing the algorithm used (table-driven CRC-32/ISO-HDLC as confirmed in the implementation), the expected input, the meaning of the return value, or the fact that CRC-32 is a non-cryptographic integrity check. Callers who add future integrity checks may incorrectly assume collision-resistance properties that CRC-32 does not provide.

**Fix:** Add a comment above the declaration documenting: (1) algorithm identity (CRC-32/ISO-HDLC); (2) parameters `buf` (pointer to data) and `len` (byte count); (3) return value (32-bit checksum); (4) a note that this is an integrity check only and is not a cryptographic hash.

---

**A05-2** · HIGH · No documentation on `setMaintCode()` — safety-critical access-control method

**Description:** `bool setMaintCode(CIGCONF::MaintLockedCode code)` (line 64) implements non-trivial business logic that directly controls the maintenance lock state of the vehicle access system: it validates the code against an explicit whitelist, prevents overwriting a non-zero code unless the new code is zero, records the current driver ID and a timestamp, marks the dynamic config dirty, and immediately persists the change. None of this behaviour is described. Developers maintaining the maintenance-lock workflow cannot determine the state-transition rules from the declaration alone.

**Fix:** Add a doc comment above the declaration describing: (1) which codes are valid and why `MaintForceChecklist` or similar hypothetical codes are absent; (2) the one-way state-change rule (`if (m_configs.maint.code && code != 0) return false`); (3) that the change is immediately persisted; (4) what the return value means.

---

**A05-3** · HIGH · No documentation on `resetConfigs()` — data-destructive factory-reset method

**Description:** `void resetConfigs(bool resetAll = false)` (line 27) is a data-destructive operation that zeroes all config structs and restores factory defaults. The `resetAll` parameter controls whether driver lists, super lists, and on-demand/VOR data are also wiped. This distinction is undocumented. Callers cannot determine what `resetAll = false` preserves (APN credentials are preserved; driver lists are not wiped; OD/VOR data are preserved) versus what `resetAll = true` destroys.

**Fix:** Add a doc comment documenting: (1) what is always reset (FMS config block, digital inputs, timers, Wi-Fi, defaults); (2) what `resetAll = true` additionally resets (driver/master/super/tech lists, OD config, VOR config); (3) that APN credentials are intentionally preserved even when `resetAll = false`.

---

**A05-4** · HIGH · No documentation on `readConfigs()` and `saveConfigs()` — primary persistence entry points

**Description:** `void readConfigs()` (line 24) and `void saveConfigs()` (line 25) are the top-level entry points for loading and persisting all device configuration. `readConfigs()` has a non-obvious fallback path: it first tries the INI-format `fms.ini`, and only falls back to the legacy binary `fmscfg.dat` if the INI read fails; it also conditionally shuffles the checklist and loads preop driver IDs based on runtime flags. `saveConfigs()` orchestrates saves across six subsystems. Neither method has any documentation. The dual-format read path is particularly risky because a future developer unaware of the fallback could corrupt or ignore the binary config silently.

**Fix:** Add doc comments for both methods describing the read order, the INI-first/binary-fallback strategy for `readConfigs()`, error outcomes, and the list of subsystems persisted by `saveConfigs()`.

---

**A05-5** · MEDIUM · Inaccurate/misleading name and no documentation on `onDemandActive()`

**Description:** `bool onDemandActive()` (line 585) is documented only by its name, which implies it returns true when an on-demand access window is currently active. However, the implementation returns `!gCfg->superIsEmpty()` — i.e., it returns true whenever the supervisor list is non-empty, regardless of whether the on-demand time window (`startTime` / `endTime`) has expired or even been set. The adjacent `onDemandVehicleEnabled()` (line 586) performs the time-window check. The mismatch between the name and behaviour creates a risk that callers will use the wrong predicate to gate on-demand access decisions.

**Fix:** Add a doc comment making the distinction explicit: "`onDemandActive()` returns true if any supervisor ID is enrolled (super list non-empty). It does NOT check the time window. Use `onDemandVehicleEnabled()` to test whether the on-demand window is currently open." Additionally, consider renaming the method to `hasSupervisors()` in a future refactor.

---

**A05-6** · MEDIUM · No documentation on `setConvor()` — undocumented side-effect clears checklist timestamp

**Description:** `bool setConvor(quint8 convor, quint64 id)` (line 259) has a hidden side-effect: unconditionally calls `gCfg->setLastCheckTimestamp(0)` on every call, even when the convor status has not changed. This causes the last-check timestamp to be cleared and immediately persisted to disk regardless of the new convor value. This side-effect is nowhere documented and is surprising: a setter for VOR status silently resets the checklist timestamp. The method also emits `convorStatusChanged()` only when the status actually changes, creating an asymmetry between the two effects that is undocumented.

**Fix:** Add a doc comment describing: (1) that `convorStatusChanged()` is emitted only on status change; (2) that `lastCheckTimestamp` is unconditionally reset to 0 on every call; (3) the meaning of the `id` parameter (the driver or entity initiating the VOR change).

---

**A05-7** · MEDIUM · No documentation on `setMaintCode()` state-transition guard (duplicate aspect of A05-2, separate concern)

*(Merged into A05-2 above — not repeated as a separate finding.)*

---

**A05-8** · LOW · No documentation on `setWifiNetwork()` — non-trivial validation logic

**Description:** `bool setWifiNetwork(quint32 index, const QByteArray &ssid, const QByteArray &pw)` (line 588) enforces several constraints drawn from WPA2 spec: password must be 8–63 bytes, SSID must be 1–32 bytes, and `index` must be within bounds. None of these constraints are documented on the declaration. A caller setting a Wi-Fi network who receives `false` has no way to determine which constraint failed.

**Fix:** Add a doc comment listing the validation rules and indicating that `false` is returned on any violation.

---

**A05-9** · LOW · No documentation on `clockTime()` — platform-conditional return

**Description:** `quint64 clockTime() const` (line 547) returns the monotonic clock in milliseconds on ARM targets and always returns 0 on all other platforms (the non-ARM branch is an empty `return 0`). This platform dependency is undocumented on the declaration. Code that uses `clockTime()` for elapsed-time calculations on non-ARM builds (e.g., host-side tests or a future Linux port) will silently receive 0.

**Fix:** Add a doc comment noting that the return value is in milliseconds, that it uses `CLOCK_MONOTONIC`, and that it returns 0 on non-ARM platforms.

---

**A05-10** · LOW · No documentation on `nextValidCheckItemIndex()` — non-obvious iteration semantics

**Description:** `int nextValidCheckItemIndex(int start = 0, bool queryOrigList = false)` (line 367) searches for the next index `>= start` in the checklist that passes `Checklist::isValidCheckItem()`. It returns -1 if none is found. The `queryOrigList` parameter controls whether the shuffled or the original list is consulted. Neither the return convention (`-1` on not-found) nor the `queryOrigList` semantics are documented.

**Fix:** Add a doc comment documenting: the search range, the -1 sentinel return, and the meaning of `queryOrigList`.

---

**A05-11** · LOW · No documentation on `setLastCheck()` — dual-field atomic update with immediate persistence

**Description:** `bool setLastCheck(quint64 id, quint32 ts)` (line 353) atomically updates both `lastCheckDriverId` and `lastCheckTimestamp` and immediately persists the dynamic config. Callers who need to update only one field might use the separate `setLastCheckTimestamp()` and be unaware that `setLastCheck()` exists as a combined form. The immediate persistence (vs. deferred dirty flag) is also undocumented.

**Fix:** Add a doc comment noting: (1) that both fields are updated atomically; (2) that the dynamic config is persisted immediately; (3) when to prefer this over calling the individual setters.

---

**A05-12** · LOW · No documentation on `fwVersion()` — opaque bitfield packing

**Description:** `quint64 fwVersion()` (line 569) returns a 64-bit value whose bit layout (`F_BUILD << 56 | C_BUILD << 48 | LFF_VERSION << 32 | SFF_VERSION << 16 | UFF_VERSION`) is entirely undocumented. The complementary `fwVersionString()` exists but it omits `F_BUILD` and `C_BUILD` from its output. A receiver of the `quint64` value must reverse-engineer the packing to decode version components.

**Fix:** Add a doc comment documenting the bit-field layout: bits 63–56 = F_BUILD, bits 55–48 = C_BUILD, bits 47–32 = LFF_VERSION, bits 31–16 = SFF_VERSION, bits 15–0 = UFF_VERSION.

---

**A05-13** · INFO · Missing doc comments on simple getter/setter pairs (bulk)

**Description:** The following groups of public methods have no doc comments, but are simple getters or setters whose names and types are reasonably self-explanatory. Documenting them is desirable but low priority:

- All `keepAliveTime` / `shutdownTime` / `gmtpId` getter/setter pairs (lines 30–58)
- All APN credential getter/setter pairs (lines 97–125)
- All shock-parameter getter/setter pairs (lines 382–408)
- All session-tracking getter/setter pairs (`lastSessionDriver`, `lastSessionStart`, `lastSessionEnd`, lines 693–707)
- All display-mode getter/setter pairs (`showDriverName`, `showPreopComment`, `showPreopSummary`, `showTime`, lines 617–673)
- All driver-list `contains*`, `add*`, `remove*`, `clear*` and `get*Index` wrappers (lines 185–210)

**Fix:** Consider adding brief one-line doc comments, especially for the validation constraints embedded in the setters (e.g., `setShutdownTime` accepts 1–255; `setChecklistTimeout` accepts 0–6000).

---

**A05-14** · INFO · `saveOpdDriverList()` name does not match its documented comment section

**Description:** `void saveOpdDriverList()` (line 26) is grouped with `readConfigs()` / `saveConfigs()` / `resetConfigs()` as a lifecycle method, but it has no comment explaining that "OPD" stands for "Once Per Day" preop, or that it conditionally saves only when `preopOncePerDayEn()` is true. The abbreviation "Opd" is used inconsistently alongside "OncePerDay" in the codebase.

**Fix:** Add a brief comment: "Saves the once-per-day preop driver list if the once-per-day feature is enabled."

---

## 4. Summary Table

| ID | Severity | Title |
|----|----------|-------|
| A05-1 | HIGH | No documentation on `crc32()` — security-critical integrity function |
| A05-2 | HIGH | No documentation on `setMaintCode()` — safety-critical access-control method |
| A05-3 | HIGH | No documentation on `resetConfigs()` — data-destructive factory-reset method |
| A05-4 | HIGH | No documentation on `readConfigs()` / `saveConfigs()` — primary persistence entry points |
| A05-5 | MEDIUM | Inaccurate/misleading semantics and no documentation on `onDemandActive()` |
| A05-6 | MEDIUM | No documentation on `setConvor()` — undocumented side-effect clears checklist timestamp |
| A05-8 | LOW | No documentation on `setWifiNetwork()` — non-trivial validation logic |
| A05-9 | LOW | No documentation on `clockTime()` — platform-conditional return value |
| A05-10 | LOW | No documentation on `nextValidCheckItemIndex()` — non-obvious iteration semantics |
| A05-11 | LOW | No documentation on `setLastCheck()` — dual-field atomic update with immediate persistence |
| A05-12 | LOW | No documentation on `fwVersion()` — opaque bitfield packing |
| A05-13 | INFO | Missing doc comments on simple getter/setter pairs (bulk) |
| A05-14 | INFO | `saveOpdDriverList()` name does not match abbreviated purpose |

**Counts:** 4 HIGH, 2 MEDIUM, 5 LOW, 2 INFO

**Note on assigned files:** `app/globalconfigsfilemanager.h` and `app/globalconfigsfilemanager.cpp` were listed as assigned targets but do not exist in the repository. No findings are raised for absent files.
# Pass 3 Agent A06 — Documentation

**Audit run:** 2026-02-28-01
**Branch:** master
**Files reviewed:**
- `comm/bleexpansion.h`
- `comm/bleexpansion.cpp`
- `comm/bleexpansionuuid.h`

---

## Reading Evidence

### `comm/bleexpansion.h` — class `BleExpansion : public QObject`

#### Public Methods / Functions

| Line | Name | Signature |
|------|------|-----------|
| 32 | Constructor | `explicit BleExpansion(EM070::BleCentral *bleCentral)` |
| 34 | `setEnabled` | `void setEnabled(bool enable)` |
| 36 | `deviceName` | `const QByteArray &deviceName() const` (inline) |
| 37 | `bleVersion` | `const QByteArray &bleVersion() const` (inline) |
| 38 | `mainVersion` | `const QByteArray &mainVersion() const` (inline) |
| 39 | `manufacture` | `const QByteArray &manufacture() const` (inline) |
| 40 | `modelNumber` | `const QByteArray &modelNumber() const` (inline) |
| 42 | `digitalInput` | `bool digitalInput(CIGCONF::BleExpansionDI di) const` (inline) |
| 44 | `relayOutput` | `bool relayOutput(CIGCONF::BleExpansionRelay relay) const` (inline) |
| 47 | `setRelayOutput` | `void setRelayOutput(CIGCONF::BleExpansionRelay relay, bool state)` |
| 49 | `setShockThreshold` | `void setShockThreshold(quint32 threshold)` |
| 50 | `setShockPeriod` | `void setShockPeriod(quint32 period)` |
| 52 | `isShockQueueEmpty` | `bool isShockQueueEmpty()` (inline) |
| 53 | `shockEvent` | `ShockEvent shockEvent()` (inline) |
| 55 | `setCurrentTime` | `void setCurrentTime(const QDateTime &time)` |
| 57 | `generateShockMessage` | `bool generateShockMessage(bool force)` |

#### Signals

| Line | Name | Signature |
|------|------|-----------|
| 60 | `accessible` | `void accessible(bool yes)` |
| 61 | `inputStateChanged` | `void inputStateChanged(CIGCONF::BleExpansionDI input, bool state)` |
| 62 | `shockOccurred` | `void shockOccurred()` |
| 63 | `amberImpactOccurred` | `void amberImpactOccurred()` |
| 64 | `redImpactOccurred` | `void redImpactOccurred()` |

#### Protected Slots / Overrides

| Line | Name |
|------|------|
| 67 | `timerEvent(QTimerEvent *)` |

#### Types, Structs, and Unions Defined

| Location | Name | Description |
|----------|------|-------------|
| Header line 27 | `struct ShockEvent` | Public aggregate: `quint32 timestamp`, `quint32 magnitude` |
| Header line 71 | `union RtcTime` (private) | BLE GATT Current Time characteristic layout (10 bytes) |
| Header line 85 | `union WritePending` (private) | Bit-map of outstanding BLE writes awaiting confirmation |

#### Macros / Constants (defined in `bleexpansion.cpp`)

| Name | Value | Purpose |
|------|-------|---------|
| `AUTH_CODE` | `"uS8MgpklMx"` | Hard-coded authentication token written to `authUuid` characteristic |
| `MAX_SHOCK_COUNT` | `10000` | Maximum number of shock events (declared but not referenced in visible code) |
| `RELAY1_TIMEOUT` | `60` | Relay 1 auto-off timeout in seconds |
| `RELAY2_TIMEOUT` | `60` | Relay 2 auto-off timeout in seconds |

---

### `comm/bleexpansionuuid.h` — class `BleExpansionUuid`

#### Public Methods / Functions

| Line | Name | Signature |
|------|------|-----------|
| 9 | `equals128` | `static inline bool equals128(const quint128 *v1, const quint128 *v2)` |

#### Private Static Members (BLE GATT UUIDs, all `quint128`)

`authUuid`, `deviceName`, `appearance`, `bleVersion`, `mainVersion`, `manufactureName`, `modelNumber`, `currentRtc`, `inputTimerReset`, `inputD0`–`inputD3`, `inputPullUp0`–`inputPullUp3`, `outputReset`, `outputRelay0`, `outputRelay1`, `relay0Timeout`, `relay1Timeout`, `outputD0`–`outputD3`, `openCollector0`–`openCollector3`, `shockCount`, `shockPeek`, `shockPop`, `shockThreshold`, `shockPeriod`, `shockMaxMagnitude`, `shockCountNotifyDesc`

All 36 UUID members are declared in lines 20–56. No definitions (actual UUID values) appear in the header; definitions reside in an unreviewed `.cpp` file.

---

## Documentation Findings

---

**A06-1** · LOW · No doc comment on constructor `BleExpansion(EM070::BleCentral *)`

**Description:** The constructor at line 32 has no comment of any kind. It performs several non-trivial side effects on construction: it sets the peripheral MAC address from global config, writes an authorization code to the BLE central, wires up multiple signal–slot connections, and initialises a pop-timer with a 10-second timeout. A caller reading only the header cannot know any of this from the declaration alone.

**Fix:** Add a comment above the declaration explaining that `bleCentral` must already exist and be configured, that the constructor installs the peripheral MAC and auth code immediately, and that the caller must subsequently call `setEnabled(true)` to start scanning (as shown in the existing usage block at lines 12–17).

---

**A06-2** · INFO · File-level usage comment exists but is incomplete

**Description:** Lines 12–17 of `bleexpansion.h` show a brief usage snippet. It correctly shows construction order but omits that `setShockThreshold`, `setShockPeriod`, and `setCurrentTime` are called automatically when the device becomes accessible, which could mislead a caller into calling them redundantly (or relying on the order).

**Fix:** Expand the usage comment to note automatic initialisation performed inside `setAccessible(true)` so callers know which manual setup steps are already handled.

---

**A06-3** · LOW · No doc comment on `setEnabled(bool enable)` (line 34)

**Description:** This method delegates directly to `m_bleCentral->setEnabled(enable)`. The header gives no hint that this controls BLE scanning/advertising on the underlying central, nor what the consequences of calling it `false` mid-session are. No comment at all is present.

**Fix:** Add a short comment: explain that `true` starts BLE scanning for the configured peripheral and `false` stops it; note that accessibility state is preserved until the next connection attempt.

---

**A06-4** · INFO · No doc comments on accessor group `deviceName`, `bleVersion`, `mainVersion`, `manufacture`, `modelNumber` (lines 36–40)

**Description:** These five inline getters return cached `QByteArray` values read from the BLE peripheral after connection. No comment explains when these values become valid (i.e., only after the `accessible(true)` signal has been emitted and `readDeviceInfo()` has completed asynchronously). A caller inspecting these values before the device is accessible will receive empty byte arrays silently.

**Fix:** Add a single group comment above the accessors noting that values are populated after `accessible(true)` is signalled and may be empty before that point.

---

**A06-5** · LOW · No doc comment on `digitalInput(CIGCONF::BleExpansionDI di)` (line 42)

**Description:** The parameter type `CIGCONF::BleExpansionDI` is an enum with values `BleExpDI1`–`BleExpDI4` (defined in `app/cigconfigs.h` line 156). The inline body uses `di - CIGCONF::BleExpDI1` as an array index, which means passing a value outside the `BleExpDI1`–`BleExpDI4` range will produce an out-of-bounds array access. There is no precondition documented and no range check in the implementation.

**Fix:** Add a comment stating the valid range of `di` is `BleExpDI1` through `BleExpDI4`, that the return reflects the last polled value (updated every 1-second timer tick when accessible), and that an out-of-range argument causes undefined behaviour.

---

**A06-6** · LOW · No doc comment on `relayOutput(CIGCONF::BleExpansionRelay relay)` (line 44)

**Description:** Returns the locally cached relay state, not a live read from hardware. There is no comment indicating this is a cached value, nor that the cache may lag the physical relay state until the 1-second timer polls `outputRelay0`/`outputRelay1` and reconciles. The parameter's valid range (`BleExpRelay1` or `BleExpRelay2`) is also undocumented.

**Fix:** Document that this returns the cached desired state, that discrepancies between desired and physical state are corrected by the polling loop, and list the two valid `relay` enum values.

---

**A06-7** · LOW · No doc comment on `setRelayOutput(CIGCONF::BleExpansionRelay relay, bool state)` (line 47)

**Description:** This is a functional control method that writes to physical hardware over BLE. The implementation silently logs a debug warning if called while not accessible but still updates the local cache (`m_outputRelay`), so the desired state will be applied when `initRelays()` is called upon reconnection. This silent queuing behaviour is not documented and could surprise a caller.

**Fix:** Document the relay enum parameter, the boolean state (true = closed, false = open), and the queuing behaviour: the desired state is cached and applied on BLE reconnection even if the device is not currently accessible.

---

**A06-8** · MEDIUM · No doc comment on `setShockThreshold(quint32 threshold)` (line 49); units and range undocumented

**Description:** No comment exists at all. The implementation writes a raw `quint32` to the `shockThreshold` BLE characteristic. Without documentation, callers cannot know the units (the value is compared directly against `event.magnitude` in `popShockEvent`), the valid range, or the effect of setting zero. A zero threshold would cause every shock event to pass the `event.magnitude > m_shockThreshold` comparison. This is a safety-relevant parameter for impact alerting.

**Fix:** Document the units (should match whatever the expansion module hardware reports — likely raw ADC counts or mg), the valid range, and that setting zero effectively disables threshold filtering. Note that the write is silently skipped if `m_accessible` is false at call time (the threshold is then not applied to the device until the next reconnection).

---

**A06-9** · MEDIUM · No doc comment on `setShockPeriod(quint32 period)` (line 50); units undocumented

**Description:** No comment exists. The parameter `period` is written directly to the `shockPeriod` BLE characteristic. It is distinct from `gCfg->shockTimer()` (the debounce window used in `generateShockMessage`). Without documentation, callers cannot distinguish the two concepts or know the units for this parameter.

**Fix:** Document what `period` configures on the expansion module hardware (the hardware-side shock detection window), its units (seconds, milliseconds, or counts), and its relationship to the software-side `shockTimer()` debounce.

---

**A06-10** · LOW · No doc comment on `shockEvent()` (line 53); destructive dequeue behaviour undocumented

**Description:** `ShockEvent shockEvent()` dequeues and returns the front element of `m_shockEvents`. The name alone does not convey that the call is destructive (removing the item from the queue). A caller who calls this without first calling `isShockQueueEmpty()` on an empty queue will call `QQueue::dequeue()` on an empty container, which asserts in Qt debug builds and is undefined behaviour in release.

**Fix:** Add a comment stating that this method dequeues (removes and returns) the oldest shock event, that the queue must be non-empty before calling (check with `isShockQueueEmpty()`), and that calling on an empty queue is undefined.

---

**A06-11** · MEDIUM · No doc comment on `setCurrentTime(const QDateTime &time)` (line 55); timezone contract undocumented

**Description:** No comment exists. The implementation formats the `QDateTime` directly into the GATT Current Time struct fields using `.date().year()`, `.date().month()`, etc. with no timezone conversion. The call site in `setAccessible()` passes `QDateTime::currentDateTimeUtc()`, correctly using UTC. However, the public API does not document the expected timezone, so a different caller could pass a local-time `QDateTime`, silently setting the peripheral RTC to the wrong time. An incorrect RTC time directly affects shock event timestamps stored on the device.

**Fix:** Document that `time` must be in UTC, that the method silently returns if the device is not accessible, and that the RTC is used to timestamp shock events on the hardware.

---

**A06-12** · MEDIUM · No doc comment on `generateShockMessage(bool force)` (line 57); side-effect and return value semantics undocumented

**Description:** This is a non-trivial public method with complex state mutation. It inspects `m_shockEvent1`, compares timestamps against `gCfg->shockTimer()`, enqueues a `ShockEvent` into `m_shockEvents`, and resets the accumulator fields. The `bool` return value (`true` = a message was enqueued) is also what the timer loop uses to emit `shockOccurred()`. The `force` parameter bypasses the timer check. None of this is documented.

**Fix:** Document: (1) return value semantics — `true` if a shock event was enqueued and the caller should emit `shockOccurred()`; (2) `force = true` flushes any pending shock event immediately regardless of debounce period; (3) the method is idempotent if no shock has been accumulated (`m_shockEvent1.timestamp == 0`); (4) callers are responsible for subsequently draining the queue via `shockEvent()`.

---

**A06-13** · LOW · No doc comment on signal `accessible(bool yes)` (line 60)

**Description:** This signal conveys a critical lifecycle event: whether the BLE expansion peripheral is reachable. Callers need to know that `yes = true` means the peripheral is connected and initialised (RTC set, shock config applied, relays initialised), while `yes = false` means the connection was lost. No comment documents this.

**Fix:** Add a comment noting the signal is emitted when the expansion module connects (`true`) or disconnects (`false`), and that when `true` is emitted the RTC time, shock threshold/period, and relay states have already been applied to the hardware.

---

**A06-14** · LOW · No doc comment on signals `amberImpactOccurred()` and `redImpactOccurred()` (lines 63–64)

**Description:** These two signals represent distinct severity tiers for impact events. The logic in `popShockEvent()` defines amber as `(redImpact/2 < magnitude < redImpact)` and red as `magnitude > redImpact`, but this threshold logic is nowhere documented at the signal declarations.

**Fix:** Add comments to each signal declaration explaining the magnitude range that triggers it and its relationship to the `shockRedImpact()` configuration value.

---

**A06-15** · LOW · No doc comment on `equals128` in `BleExpansionUuid` (line 9)

**Description:** This utility function performs a 128-bit UUID comparison by casting to four `quint32` words and comparing sequentially. No comment explains the purpose, the expected byte layout of `quint128`, or why a manual loop is used instead of `memcmp`. The function is inline in the header and used extensively throughout `bleexpansion.cpp`.

**Fix:** Add a comment explaining that it compares two 128-bit Bluetooth UUIDs for equality by comparing four 32-bit words, and that the `quint128` layout is assumed to be 16 contiguous bytes in the platform-native representation used by Qt's Bluetooth stack.

---

**A06-16** · LOW · UUID constants in `BleExpansionUuid` have no documentation

**Description:** All 36 private `quint128` static UUID members (lines 20–56) are named only. No comment associates any UUID name with its actual 128-bit value, its GATT characteristic description, its read/write/notify properties, or which BLE peripheral service it belongs to. The actual values reside in an unreviewed `.cpp` definition file with no documentation. Because `BleExpansionUuid` is a friend-access-only class, this is an internal concern, but it significantly hampers maintainability.

**Fix:** Add a header-level comment block describing the UUID naming convention and peripheral service layout. Individually, each UUID member should have a brief comment giving the full UUID value and the characteristic's access type (R/W/Notify). At minimum, `authUuid` (used for authentication) and `shockCount`, `shockPeek`, `shockPop` (used for safety-critical impact data) should have values documented inline.

---

**A06-17** · HIGH · Authentication credential `AUTH_CODE` is a hard-coded plain-text string with no documentation

**Description:** Line 9 of `bleexpansion.cpp` defines `#define AUTH_CODE "uS8MgpklMx"`. This token is written verbatim to the `authUuid` BLE characteristic to authenticate with the expansion module (line 40 of the constructor). There is no comment explaining what the value is, how it was derived, whether it is shared across all deployed units, how it can be rotated, or what the consequences of its compromise are. Given that authentication controls access to relay outputs and shock threshold configuration, this is a security-relevant credential.

**Fix:** At minimum add a comment above the `#define` explaining its role, that it is a shared secret for the EM070 peripheral, and referencing any key-management process or hardware documentation. Longer-term, the credential should be moved out of source code into a configuration or provisioning mechanism, and this finding should be tracked as a security issue.

---

**A06-18** · INFO · `MAX_SHOCK_COUNT` macro is defined but apparently unused

**Description:** Line 11 of `bleexpansion.cpp` defines `#define MAX_SHOCK_COUNT 10000`. No usage of this constant was found in the file. There is no comment explaining its intended use or whether it was planned as a cap for the `m_shockEvents` queue or the hardware shock counter.

**Fix:** Either add a comment documenting its purpose and where it should be enforced, or remove it if it is a dead constant.

---

## Summary Table

| ID | Severity | Title |
|----|----------|-------|
| A06-1 | LOW | No doc comment on constructor |
| A06-2 | INFO | File-level usage comment is incomplete |
| A06-3 | LOW | No doc comment on `setEnabled` |
| A06-4 | INFO | No doc comments on device-info accessor group |
| A06-5 | LOW | No doc comment on `digitalInput`; out-of-range precondition missing |
| A06-6 | LOW | No doc comment on `relayOutput`; cached-value nature undocumented |
| A06-7 | LOW | No doc comment on `setRelayOutput`; silent-queue behaviour undocumented |
| A06-8 | MEDIUM | `setShockThreshold` units and range undocumented; safety-relevant |
| A06-9 | MEDIUM | `setShockPeriod` units and relationship to software timer undocumented |
| A06-10 | LOW | `shockEvent()` destructive dequeue behaviour undocumented |
| A06-11 | MEDIUM | `setCurrentTime` timezone contract undocumented; RTC accuracy affected |
| A06-12 | MEDIUM | `generateShockMessage` return-value and side-effect semantics undocumented |
| A06-13 | LOW | Signal `accessible` lifecycle semantics undocumented |
| A06-14 | LOW | Signals `amberImpactOccurred`/`redImpactOccurred` threshold logic undocumented |
| A06-15 | LOW | `BleExpansionUuid::equals128` has no doc comment |
| A06-16 | LOW | All 36 UUID constants undocumented |
| A06-17 | HIGH | Hard-coded authentication credential `AUTH_CODE` undocumented and unmanaged |
| A06-18 | INFO | `MAX_SHOCK_COUNT` defined but apparently unused and undocumented |

**Totals:** 1 HIGH, 4 MEDIUM, 9 LOW, 4 INFO
# Pass 3 Agent A07 — Documentation

**Audit run:** 2026-02-28-01
**Branch:** master
**Files reviewed:**
- `comm/bleinputhandler.h` + `comm/bleinputhandler.cpp`
- `comm/canexpansion.h` + `comm/canexpansion.cpp`

---

## Reading Evidence

### File: `comm/bleinputhandler.h` / `comm/bleinputhandler.cpp`

**Class name:** `BleInputHandler`

**Public methods (header line numbers):**

| Line | Method |
|------|--------|
| 20 | `explicit BleInputHandler(CanExpansion *canExpansion)` — constructor |
| 22 | `void updateIgnition(CIGCONF::PowerState state)` |
| 23 | `void updateBleInput(CIGCONF::BleExpansionDI input, bool state)` |
| 24 | `void changeBleState(bool connected)` |
| 26 | `void updateIdleTimer()` |
| 28 | `QByteArray digitalInputs(DigitalFormat format, bool autoReset)` |

**Signals:**

| Line | Signal |
|------|--------|
| 31 | `void idleTimeout()` |
| 32 | `void sendGmtpMessage(CIGCONF::GmtpMessage msg, const QByteArray &extra = QByteArray())` |

**Slots:** None declared explicitly. `updateBleInput` and `changeBleState` are connected as slots via `connect()` calls in the constructor (bleinputhandler.cpp lines 18–19), but are not declared with `public slots:` — they are ordinary public methods wired as slots.

**Types, enums, and constants defined:**

| Kind | Name | Line |
|------|------|------|
| enum | `DigitalFormat { SessionFormat, UsageFormat, OnDemandFormat }` | 18 |
| private struct | `InputState` | 39–48 |

**File-level comment (bleinputhandler.h, lines 1–4):**
```
/*
 * Besides the 4 inputs of BLE expansion module,
 * ignition input is handled here
 */
```
This is the only descriptive comment in the entire header/source pair.

---

### File: `comm/canexpansion.h` / `comm/canexpansion.cpp`

**Class name:** `CanExpansion`

**Public methods (header line numbers):**

| Line | Method |
|------|--------|
| 42 | `explicit CanExpansion(EM070::CanBus *canBus, EM070::PowerSupply *ps)` — constructor |
| 44 | `void setEnabled(bool enable)` |
| 46 | `const QByteArray &deviceName() const` — inline getter |
| 47 | `const QByteArray &bleVersion() const` — inline getter |
| 48 | `const QByteArray &mainVersion() const` — inline getter |
| 49 | `const QByteArray &manufacture() const` — inline getter |
| 50 | `const QByteArray &modelNumber() const` — inline getter |
| 52 | `bool relayOutput(CIGCONF::BleExpansionRelay relay) const` — inline getter |
| 55 | `void setRelayOutput(CIGCONF::BleExpansionRelay relay, bool state)` |
| 57 | `quint16 relayTimeout(CIGCONF::BleExpansionRelay relay) const` — inline getter |
| 60 | `void setRelayTimeout(CIGCONF::BleExpansionRelay relay, quint16 timeout_in_sec)` |
| 62 | `void setCurrentTime(quint32 time)` |
| 64 | `bool digitalInput(CIGCONF::BleExpansionDI di) const` — inline getter |
| 66 | `void setShockThreshold(quint32 threshold)` |
| 67 | `void setShockPeriod(quint32 period)` |
| 69 | `bool isShockQueueEmpty()` — inline |
| 70 | `ShockEvent shockEvent()` — inline, dequeues |
| 72 | `bool generateShockMessage(bool force)` |
| 74 | `void setGnssReceiver(EM070::GnssReceiver* gnss)` |

**Signals:**

| Line | Signal |
|------|--------|
| 77 | `void inputStateChanged(CIGCONF::BleExpansionDI input, bool state)` |
| 78 | `void shockOccurred()` |
| 79 | `void amberImpactOccurred()` |
| 80 | `void redImpactOccurred()` |
| 81 | `void accessible(bool yes)` |
| 82 | `void expModInfo(QByteArray mainVersion)` |
| 83 | `void inactiveNotification(bool inactive, quint32 secs)` |
| 84 | `void relayStateChanged(bool relay1, bool relay2)` |

**Types, enums, and constants defined:**

| Kind | Name | Line |
|------|------|------|
| public struct | `ShockEvent` | 25–40 |

**No file-level or class-level comment exists** in either `canexpansion.h` or `canexpansion.cpp`. There is a single inline comment at canexpansion.cpp line 194 (`// initial or re-assign clock`) and one at line 110 (`// Start reconection process quickly`). No method has any doc comment.

---

## Documentation Checks

### BleInputHandler

#### `BleInputHandler(CanExpansion *canExpansion)` (line 20)
- Doc comment: No.
- The constructor wires three signal-slot connections (canExpansion::inputStateChanged, canExpansion::accessible, m_digInputModeTimer::timeout), sets up a single-shot timer, and calls resetStates(). The side-effects and ownership of the passed pointer are not described anywhere.

#### `void updateIgnition(CIGCONF::PowerState state)` (line 22)
- Doc comment: No.
- Non-trivial: accumulates on/off time, manages rising edge count, conditionally resets all state, starts/stops the idle timer depending on configuration. The `m_bypassReset` interaction in particular is subtle and undocumented.

#### `void updateBleInput(CIGCONF::BleExpansionDI input, bool state)` (line 23)
- Doc comment: No.
- Non-trivial: accumulates per-input timing and rising counts, triggers the seen-safety debounce timer for input 2 if the digital mode is `SeenSafety`, and manages the idle timer. All of this behaviour is undocumented.

#### `void changeBleState(bool connected)` (line 24)
- Doc comment: No.
- Non-trivial: when `connected` is false, finalises elapsed time for all four BLE inputs before the device goes offline. The accounting freeze-and-resume semantics are entirely undocumented.

#### `void updateIdleTimer()` (line 26)
- Doc comment: No.
- Non-trivial: creates or destroys the idle QTimer according to current configuration, maps the encoded `idleInputSource()` integer values (1, 2, 4, 8, 16) to specific inputs, and starts the timer only when the polarity condition is met. No documentation exists for the bitmask encoding scheme or the conditions under which the timer is created/destroyed.

#### `QByteArray digitalInputs(DigitalFormat format, bool autoReset)` (line 28)
- Doc comment: No.
- Non-trivial: produces a formatted ASCII byte array representing on/off time and rising edge counts for ignition and four BLE inputs in one of three serialisation formats. The `autoReset` flag side-effectfully zeroes counters. The output format itself (e.g., `"0: %d %x %x 1: %d %x %x ... 10: 0 0 0"`) is undocumented, as are the special-cased slots 5 and 10 in the output.

#### `DigitalFormat` enum (line 18)
- Doc comment: No.
- The three values (`SessionFormat`, `UsageFormat`, `OnDemandFormat`) are not explained; the difference between session, usage, and on-demand formatting is not obvious from the names alone.

#### Signal `idleTimeout()` (line 31)
- Doc comment: No. No description of what triggers it or what consumers are expected to do.

#### Signal `sendGmtpMessage(...)` (line 32)
- Doc comment: No. The GMTP protocol, the meaning of the `msg` parameter types, and when this signal fires are undocumented.

---

### CanExpansion

#### `CanExpansion(EM070::CanBus *canBus, EM070::PowerSupply *ps)` (line 42)
- Doc comment: No.
- Constructor defers CAN bus initialisation by 500 ms via a single-shot timer. This is a non-obvious design choice with no documentation.

#### `void setEnabled(bool enable)` (line 44)
- Doc comment: No.
- Non-trivial: when disabling, cuts CAN power and signals `accessible(false)`. When enabling, restores power and immediately begins re-handshake sequence. The asymmetry (disable is fully synchronous; enable is asynchronous) is undocumented.

#### Inline getters: `deviceName`, `bleVersion`, `mainVersion`, `manufacture`, `modelNumber` (lines 46–50)
- Doc comment: No. Acceptable for simple getters (INFO severity).

#### `bool relayOutput(CIGCONF::BleExpansionRelay relay) const` (line 52)
- Doc comment: No. Inline getter; acceptable at INFO severity.

#### `void setRelayOutput(CIGCONF::BleExpansionRelay relay, bool state)` (line 55)
- Doc comment: No.
- Non-trivial: writes to the CAN bus if transfer is enabled, emits `relayStateChanged` for both relays regardless of which was changed, and updates local shadow state. The unconditional dual-relay emission in the signal and the silent no-op when CAN is disabled are undocumented.

#### `quint16 relayTimeout(CIGCONF::BleExpansionRelay relay) const` (line 57)
- Doc comment: No. Inline getter; acceptable at INFO severity.

#### `void setRelayTimeout(CIGCONF::BleExpansionRelay relay, quint16 timeout_in_sec)` (line 60)
- Doc comment: No.
- Non-trivial: silently does not write to the CAN bus when transfer is disabled, but does update shadow state (unlike `setRelayOutput`, which also updates shadow state when disabled). Units are not documented in the parameter name alone.

#### `void setCurrentTime(quint32 time)` (line 62)
- Doc comment: No.
- Non-trivial: silently no-ops if CAN transfer is disabled. The `time` parameter type, epoch, and encoding are not documented.

#### `bool digitalInput(CIGCONF::BleExpansionDI di) const` (line 64)
- Doc comment: No. Inline getter; acceptable at INFO severity.

#### `void setShockThreshold(quint32 threshold)` (line 66)
- Doc comment: No.
- Non-trivial: silently no-ops if CAN transfer is disabled. The units and meaning of the threshold value are undocumented.

#### `void setShockPeriod(quint32 period)` (line 67)
- Doc comment: No.
- Non-trivial: same silent-no-op pattern. The units and meaning of `period` are undocumented.

#### `bool isShockQueueEmpty()` (line 69)
- Doc comment: No. Simple delegation; INFO severity.

#### `ShockEvent shockEvent()` (line 70)
- Doc comment: No.
- Non-trivial: dequeues and returns by value, so the queue is destructively modified. The caller must check `isShockQueueEmpty()` first to avoid undefined behaviour from dequeuing an empty QQueue. This precondition is undocumented.

#### `bool generateShockMessage(bool force)` (line 72)
- Doc comment: No.
- Non-trivial and safety-relevant: controls whether a pending shock event is promoted to the outbound queue. The `force` flag bypasses normal timing/counter guards. The conditions under which `true` is returned (enqueue occurred), the interaction with `m_redImpactCounter`, and the time-sync regression guard are all undocumented.

#### `void setGnssReceiver(EM070::GnssReceiver* gnss)` (line 74)
- Doc comment: No. Simple setter but the pointer ownership and lifetime contract (the object does not take ownership) is not documented.

#### `ShockEvent` struct (lines 25–40)
- Doc comment: No. None of the 13 fields carry any description. Units for `magnitude`, `speed`, `sumOfDistance`, `course`, and coordinate fields are not documented.

#### Signals: all 8 signals (lines 77–84)
- Doc comments: None. Signals like `amberImpactOccurred`, `redImpactOccurred`, `accessible`, and `inactiveNotification` carry safety or connectivity semantics that are not described.

---

## Findings

**A07-1** · LOW · No doc comments on any `BleInputHandler` public methods
**Description:** None of the six public methods of `BleInputHandler` (`BleInputHandler()`, `updateIgnition()`, `updateBleInput()`, `changeBleState()`, `updateIdleTimer()`, `digitalInputs()`) carries any doc comment. Parameters and return values are entirely undescribed. The only documentation in the file is a four-line file-level comment that partially describes the class purpose.
**Fix:** Add at minimum a single-line comment above each declaration describing purpose, non-obvious parameters, and any side-effects. For `digitalInputs()` in particular, document the output format string, the meaning of `autoReset`, and each `DigitalFormat` variant.

---

**A07-2** · LOW · `DigitalFormat` enum values undocumented
**Description:** The `DigitalFormat` enum (bleinputhandler.h line 18) defines `SessionFormat`, `UsageFormat`, and `OnDemandFormat`. The distinction between session and usage counters (session counters reset per ignition cycle; usage counters persist across cycles) is critical to correct interpretation of the `digitalInputs()` output, but is explained nowhere in the header or source.
**Fix:** Add a comment above the enum and/or above each enumerator explaining what data subset each format serialises and when each should be used.

---

**A07-3** · LOW · `updateIdleTimer()` input-source encoding undocumented
**Description:** `updateIdleTimer()` interprets the integer returned by `gCfg->idleInputSource()` as a bitmask-like encoding where 1 = ignition, 2 = BLE DI1, 4 = BLE DI2, 8 = BLE DI3, 16 = BLE DI4. This encoding is non-obvious (it is a power-of-two positional scheme, not a true bitmask). The internal comment in the `.cpp` (`// per spec., 1 for ignition; 2,4,8,16 for BLE expansion module input`) exists only in the implementation and is not surfaced in the header. Callers reading only the header have no indication of valid values.
**Fix:** Move or duplicate the encoding explanation into a comment above the `updateIdleTimer()` declaration in the header, or at minimum reference the specification by name.

---

**A07-4** · MEDIUM · `digitalInputs()` output format is undocumented; `autoReset` side-effect is invisible
**Description:** `digitalInputs()` (bleinputhandler.h line 28) returns a structured ASCII payload whose format is defined only by the implementation. The output contains fixed slot indices (0 for ignition, 1–4 for BLE inputs, 5 as a constant zero entry, 6–9 for rising-edge counts, 10 as a constant zero entry). The `autoReset` parameter destructively zeroes session or usage counters, a side-effect that is invisible from the declaration. A caller who passes `autoReset = true` without understanding this will lose accumulated telemetry data.
**Fix:** Document the output format in a comment above the declaration, list the slot layout, and explicitly warn that `autoReset = true` clears the corresponding counters. This is the primary data-export method of the class and requires full documentation.

---

**A07-5** · LOW · No doc comments on any `CanExpansion` public methods
**Description:** None of the 19 public methods of `CanExpansion` carries any doc comment. The header file has no file-level or class-level comment at all. The `.cpp` implementation contains only two brief inline remarks and serial-log strings.
**Fix:** Add doc comments to all non-trivial public methods. At minimum: `setEnabled()`, `setRelayOutput()`, `setRelayTimeout()`, `setCurrentTime()`, `setShockThreshold()`, `setShockPeriod()`, `generateShockMessage()`, and the constructor.

---

**A07-6** · LOW · `ShockEvent` struct fields undocumented
**Description:** The `ShockEvent` struct (canexpansion.h lines 25–40) contains 13 fields including `magnitude`, `speed`, `sumOfDistance`, `course`, `longitude`, `latitude`, `distance`, and `satelliteCount`. None of the fields carries a comment describing units, encoding, or range. For example: whether coordinates are in millionths of a degree or another fixed-point encoding, what units `speed` is in, and what `distance` vs `sumOfDistance` represent are all opaque.
**Fix:** Add a comment to each field in the struct specifying units and encoding. At minimum document `magnitude` (acceleration units), coordinate fields (fixed-point encoding and resolution), `speed` (units), and `distance`/`sumOfDistance` (units and semantic distinction).

---

**A07-7** · LOW · `generateShockMessage(bool force)` preconditions and return semantics undocumented
**Description:** `generateShockMessage()` (canexpansion.h line 72) returns `true` when a shock event has been enqueued and `false` otherwise. It has a non-trivial internal state machine involving `m_redImpactCounter` and `m_shockTimestamp`. The `force` parameter bypasses normal deferral logic. Neither the return value meaning, the `force` semantics, the precondition (a pending shock must exist in `m_shockEvent1`), nor the interaction with `isShockQueueEmpty()`/`shockEvent()` is documented.
**Fix:** Add a doc comment explaining: what `force = true` does relative to `force = false`, the return value meaning, and that callers should drain the queue via `shockEvent()` after a `true` return.

---

**A07-8** · LOW · `shockEvent()` missing precondition documentation
**Description:** `shockEvent()` (canexpansion.h line 70) is an inline method that calls `m_shockEvents.dequeue()`. Calling `QQueue::dequeue()` on an empty queue is undefined behaviour. The contract that callers must first check `isShockQueueEmpty()` is not documented anywhere.
**Fix:** Add a comment stating that this method must only be called when `isShockQueueEmpty()` returns `false`.

---

**A07-9** · INFO · Inline getters lack doc comments
**Description:** The five string-returning getters (`deviceName`, `bleVersion`, `mainVersion`, `manufacture`, `modelNumber` — lines 46–50) and the two query methods (`relayOutput`, `relayTimeout`, `digitalInput`, `isShockQueueEmpty` — lines 52, 57, 64, 69) have no doc comments. These are trivial accessors; absence of documentation is low risk.
**Fix:** At minimum add a one-line comment describing the provenance of each value (e.g., that `deviceName` and `bleVersion` are populated during the CAN handshake sequence and may be empty until the module becomes accessible).

---

**A07-10** · LOW · Signals in both classes carry no documentation
**Description:** All 8 signals in `CanExpansion` (lines 77–84) and both signals in `BleInputHandler` (lines 31–32) have no doc comments. Several carry safety-relevant semantics: `redImpactOccurred`, `amberImpactOccurred`, `accessible`, `inactiveNotification`, and `sendGmtpMessage` all affect vehicle-safety or reporting behaviour. Consumers connecting to these signals have no in-code description of when they fire or what the parameters mean.
**Fix:** Add a one-line comment above each signal declaration describing the emission condition and, for signals with parameters, the meaning of each parameter.

---

## Summary Table

| ID | Severity | Location | Title |
|----|----------|----------|-------|
| A07-1 | LOW | `bleinputhandler.h` lines 20–28 | No doc comments on any `BleInputHandler` public methods |
| A07-2 | LOW | `bleinputhandler.h` line 18 | `DigitalFormat` enum values undocumented |
| A07-3 | LOW | `bleinputhandler.h` line 26 | `updateIdleTimer()` input-source encoding undocumented in header |
| A07-4 | MEDIUM | `bleinputhandler.h` line 28 | `digitalInputs()` output format and `autoReset` side-effect invisible |
| A07-5 | LOW | `canexpansion.h` lines 42–74 | No doc comments on any `CanExpansion` public methods |
| A07-6 | LOW | `canexpansion.h` lines 25–40 | `ShockEvent` struct fields undocumented (units and encoding) |
| A07-7 | LOW | `canexpansion.h` line 72 | `generateShockMessage()` preconditions and return semantics undocumented |
| A07-8 | LOW | `canexpansion.h` line 70 | `shockEvent()` missing precondition (empty-queue UB) |
| A07-9 | INFO | `canexpansion.h` lines 46–50, 52, 57, 64, 69 | Inline getters lack doc comments |
| A07-10 | LOW | `bleinputhandler.h` lines 31–32; `canexpansion.h` lines 77–84 | Signals carry no documentation |

**Totals:** 1 MEDIUM, 7 LOW, 1 INFO
# Pass 3 Agent A08 — Documentation

**Audit run:** 2026-02-28-01
**Branch:** master
**Files reviewed:**
- `comm/canmonitor.h` (150 lines)
- `comm/canmonitor.cpp` (1657 lines)
- `comm/canstatehandler.h` (53 lines)
- `comm/canstatehandler.cpp` (207 lines)

---

## Reading Evidence

### canmonitor.h / canmonitor.cpp

**Class:** `CanMonitor` (inherits `QObject`)

**Public methods — header line numbers:**

| Line | Method / Inline |
|------|----------------|
| 20 | `explicit CanMonitor(EM070::CanBus *canBus)` |
| 22 | `bool readCanConfig()` |
| 23 | `bool readOldCanConfig()` |
| 24 | `void saveCanConfig()` |
| 25 | `void calculateCanCrc()` |
| 28 | `quint32 canCrc32() const` (inline getter) |
| 30 | `void setEnabled(bool enable)` |
| 32 | `void clearCanConfig()` |
| 33 | `QByteArray canBusConfig() const` |
| 34 | `bool setCanBusConfig(const QByteArray &config)` |
| 35 | `QByteArray canPgnConfig() const` |
| 36 | `bool setCanPgnConfig(const QByteArray &config)` |
| 37 | `QByteArray canSpnConfig() const` |
| 38 | `bool setCanSpnConfig(const QByteArray &config)` |
| 39 | `QByteArray canAttConfig() const` |
| 40 | `bool setCanAttConfig(const QByteArray &config)` |
| 41 | `QByteArray canLinConfig() const` |
| 42 | `bool setCanLinConfig(const QByteArray &config)` |
| 43 | `QByteArray canBydConfig() const` |
| 44 | `bool setCanBydConfig(const QByteArray &config)` |
| 45 | `QByteArray canLin2Config() const` |
| 46 | `bool setCanLin2Config(const QByteArray &config)` |
| 48 | `bool isXferEnabled() const` (inline getter) |
| 49 | `QByteArray attributeName(quint8 index) const` (inline getter) |
| 50 | `CIGCONF::CanAttributeType attributeType(quint8 index) const` (inline getter) |
| 52 | `void setVdiAccess(bool access, bool inhibit)` |
| 53 | `void enableVdi(bool enable)` |

**Signals:**

| Line | Signal |
|------|--------|
| 60 | `void resetCanStates(bool resetLast)` |
| 61 | `void stateUpdated(quint8 index, quint32 state)` |

**Private structs (internal types):**

| Name | Purpose |
|------|---------|
| `BusConfig` | CAN bus configuration (protocol, baud rate, extended, enabled) |
| `PgnConfig` | PGN descriptor (extended, pgn, priority, sourceAddress, pollingX10ms) |
| `SpnConfig` | SPN descriptor (pgnIndex, siblingIndex, spn, response mask, width, offset, opcode, operand) |
| `AttConfig` | Named attribute config (name, type, spn index/op union, spnMask/spnIndex2 union, spnState) |

**Enums/constants:** None defined in this file. Uses `CIGCONF::CanProtocol`, `CIGCONF::CanAttributeType`, and constants `CAN_ATT_NAME_LEN`, `CAN_MAX_PGN_IDX`, `CAN_MAX_SPN_IDX`, `CAN_MAX_ATT_IDX`, `CAN_MAX_LINK_IDX` from `cigconfigs.h`.

**File-scope compile-time constants (canmonitor.cpp):**

| Macro | Value |
|-------|-------|
| `CAN_CONF_FILE_OLD` | `"cancfg.dat"` |
| `CAN_CONF_FILE` | `"cancfgnew.dat"` |
| `UPDATE_DEFER` | `3000` (ms) |
| `RULE_*_RATE` | Polling rates for named attributes (2000 ms or 60000 ms) |
| `LIN_CANID_OFFSET` | `0x10` |
| `LIN_ADDR_OFFSET` | `0x4000` |
| `BYD_CANID_XOR` | `0x380` |
| `BYD_ADDR_OFFSET` | `0x0B000000` |

---

### canstatehandler.h / canstatehandler.cpp

**Class:** `CanStateHandler` (inherits `QObject`)

**Public enum:**

| Line | Name | Enumerators |
|------|------|-------------|
| 14 | `DigitalFormat` | `SessionFormat`, `UsageFormat`, `OnDemandFormat` |

**Public methods — header line numbers:**

| Line | Method |
|------|--------|
| 16 | `explicit CanStateHandler(CanMonitor *canMonitor)` |
| 17 | `void updateIdleTimer()` |
| 18 | `QByteArray canStates(DigitalFormat format, bool autoReset)` |
| 19 | `void resetStates(bool resetLast)` |

**Signals:**

| Line | Signal |
|------|--------|
| 22 | `void idleTimeout()` |

**Private struct:**

| Name | Fields |
|------|--------|
| `CanState` | `state`, union `time` (`sessionOnTime`, `sessionOffTime`, `usageOnTime`, `usageOffTime`) / `count` (`sessionRisings`, `sessionFallings`, `usageRisings`, `usageFallings`), `clock` |

---

## Documentation Checks

### CanMonitor — public methods

1. **`CanMonitor(EM070::CanBus *canBus)`** — No doc comment. Constructor wires up CAN bus read slot, deferred-update timer, and calls `readCanConfig()` with fallback to `clearCanConfig()`+`saveCanConfig()`. Non-trivial initialization; not documented.

2. **`readCanConfig()`** — No doc comment. Reads `cancfgnew.dat` (versions 1 or 2) or falls back to old format. Validates CRC32. Handles VDI mode shortcut. Non-trivial; no description of return value or side effects.

3. **`readOldCanConfig()`** — No doc comment. Reads legacy `cancfg.dat` format and up-converts `SpnConfig0` to the current `SpnConfig`. Return value semantics (true = success, false = size/CRC failure) undocumented.

4. **`saveCanConfig()`** — No doc comment. Serializes all config structs with a CIG-format CRC and a file-level CRC32 to `cancfgnew.dat`. This is a write to persistent storage affecting device behaviour; no documentation.

5. **`calculateCanCrc()`** — Has inline implementation comment block (commented-out code showing alternative struct-based approach) but **no explanatory doc comment**. The function computes `m_canCrc32` differently depending on whether the protocol is `Linde1202` (XOR of individual CRCs) or anything else (CRC over a `CigCanConfig`). The distinction is significant and undocumented.

6. **`canCrc32() const`** — Has a trailing inline comment `// for CIG CAN format CRC` on line 27. Acceptable as a minimal descriptor for a trivial getter. No parameter/return description needed.

7. **`setEnabled(bool enable)`** — No doc comment. When `enable` is false, powers down the CAN bus and zeroes SPN state. When `enable` is true, only activates bus if `m_busConfig.enabled` is also true. The conditional logic is not obvious; undocumented.

8. **`clearCanConfig()`** — No doc comment. Zeroes all config tables, resets to default LindeExtended/250kbps/enabled settings, starts deferred-update timer, emits `resetCanStates(true)`. Has a single inline comment `// CMD_CLRCAN:` which is an AT-command tag, not a description.

9. **`canBusConfig() const`** — Has inline comment showing the response format `"^CANCFG: ..."` inside the implementation. No doc comment in header. Format string documents what is returned but only if you read the .cpp.

10. **`setCanBusConfig(const QByteArray &config)`** — Implementation has inline comment `// "<can_type>,<baud_rate>,<id_size>,<tx_enable>"`. No header doc comment. Validates protocol (0–4), baud rate (0–1,000,000), etc. Return value meaning (true = applied, false = parse error) is undocumented.

11. **`canPgnConfig() const`** — Implementation has inline comment showing response format. No header doc comment.

12. **`setCanPgnConfig(const QByteArray &config)`** — Implementation has inline comment for format. No header doc comment. Also silently rejects calls when protocol is not J1939 or LindeExtended; this rejection is undocumented.

13. **`canSpnConfig() const`** — Implementation has inline comment. No header doc comment.

14. **`setCanSpnConfig(const QByteArray &config)`** — Implementation has inline comment. No header doc comment. Protocol restriction (J1939/LindeExtended only) undocumented.

15. **`canAttConfig() const`** — Implementation has inline comment (note: comment says `^CANSPN:` but function emits `^CANATT:`). No header doc comment.

16. **`setCanAttConfig(const QByteArray &config)`** — Implementation has inline comment. No header doc comment. Protocol restriction (J1939, LindeExtended, BydCan, Linde1202) undocumented.

17. **`canLinConfig() const`** — Implementation has inline comment. No header doc comment.

18. **`setCanLinConfig(const QByteArray &config)`** — Implementation has inline comment. No header doc comment. Protocol restriction (LindeExtended only) undocumented.

19. **`canBydConfig() const`** — Implementation has inline comment. No header doc comment.

20. **`setCanBydConfig(const QByteArray &config)`** — Implementation has inline comment. No header doc comment. Protocol restriction (BydCan only) undocumented.

21. **`canLin2Config() const`** — Implementation has inline comment. No header doc comment.

22. **`setCanLin2Config(const QByteArray &config)`** — Implementation has inline comment (contains a stray trailing `"` at end of comment on line 1099). No header doc comment. Protocol restriction (Linde1202 only) undocumented.

23. **`isXferEnabled() const`** — No doc comment; trivial inline getter. INFO severity.

24. **`attributeName(quint8 index) const`** — No doc comment; unchecked index — passing `index >= CAN_MAX_ATT_IDX` causes undefined behaviour. No bounds documentation.

25. **`attributeType(quint8 index) const`** — Same issue as `attributeName`.

26. **`setVdiAccess(bool access, bool inhibit)`** — No doc comment. Controls VDI node access by writing byte 0x05, 0x01, or 0x00 to CAN ID 0x215 at 1 Hz. Both parameters (`access`, `inhibit`) are undescribed. Safety-relevant (controls physical access).

27. **`enableVdi(bool enable)`** — No doc comment. `enable=true` calls `initVdi()` which hard-codes a full CAN config; `enable=false` wipes config via `clearCanConfig()`. Significant side effects; undocumented.

### CanMonitor — signals

28. **`resetCanStates(bool resetLast)`** — No doc comment. `resetLast` distinguishes between a full reset (including Last-type attributes) and a partial reset. Callers need to know this distinction; it is undocumented.

29. **`stateUpdated(quint8 index, quint32 state)`** — No doc comment. Emitted when a monitored SPN attribute changes. `index` is the attribute index (0-based), `state` is the computed attribute state. Undocumented.

### CanStateHandler — public methods

30. **`CanStateHandler(CanMonitor *canMonitor)`** — No doc comment. Connects `stateUpdated` and `resetCanStates` signals, calls `resetStates(true)`.

31. **`updateIdleTimer()`** — Has inline comment inside the implementation (`/* per spec., 64 means input is CAN SEAT state... */`) but no header doc comment. The method is re-evaluated from config each call: it creates or destroys the idle timer and may start it immediately. The comment references a spec but the spec is not identified. No header doc comment.

32. **`canStates(DigitalFormat format, bool autoReset)`** — No doc comment. Returns a formatted byte string of all active CAN attribute states. The `format` parameter controls which counters/times are included and their scope. The `autoReset` parameter causes destructive zeroing of session or usage counters. The destructive nature of `autoReset` is not documented anywhere.

33. **`resetStates(bool resetLast)`** — Has an inline comment on line 19 in the header: `// once CAN rules is changed or disabled, reset all states`. This is the only doc comment present across all four files. However, the comment does not explain that `resetLast=false` preserves `CanAttributeLast`, `CanAttributeLast2`, and `CanAttributeTime` entries. The parameter semantics are under-described.

### CanStateHandler — signals

34. **`idleTimeout()`** — No doc comment. Emitted by a single-shot timer when the SEAT-type CAN input has been in the configured polarity for `idleTimeout()` seconds. Undocumented.

---

## Findings

**A08-1** · LOW · No doc comment on `CanMonitor` constructor
**Description:** The constructor (`canmonitor.h` line 20) performs non-trivial initialization: it connects CAN bus read and timer signals, sets defaults, and attempts to load configuration from persistent storage with a fallback write. None of this is described. A maintainer cannot determine expected usage or what preconditions `canBus` must satisfy.
**Fix:** Add a doc comment explaining the constructor's behaviour, the ownership of `canBus` (parent is set to `canBus`), and the fact that configuration is loaded immediately.

---

**A08-2** · LOW · No doc comment on `readCanConfig()` / `readOldCanConfig()`
**Description:** Both methods (`canmonitor.h` lines 22–23) read binary configuration files, validate a CRC32, and up-convert older formats. The return value (`true` on success, `false` on file-not-found, size mismatch, or CRC failure) is not documented. The VDI-mode shortcut in `readCanConfig()` (which bypasses file reading entirely) is also not described.
**Fix:** Add doc comments to each method documenting the return value, the file names consulted, the CRC check, and the VDI-mode shortcut.

---

**A08-3** · LOW · No doc comment on `saveCanConfig()`
**Description:** `saveCanConfig()` (`canmonitor.h` line 24) serialises all four config tables plus the CIG CRC and a file-level CRC32 to `cancfgnew.dat`. The function has no header doc comment and no inline description of what it writes or any failure conditions (e.g. `qCritical` on `open` failure, but no return value).
**Fix:** Add a doc comment describing what is written, when the caller should invoke this method, and note that failures are logged but silently swallowed.

---

**A08-4** · LOW · No doc comment on `calculateCanCrc()`
**Description:** `calculateCanCrc()` (`canmonitor.h` line 25) computes `m_canCrc32` using two distinct algorithms: for `Linde1202`, it XORs four independent CRC32 values; for all other protocols, it converts to a `CigCanConfig` struct and CRCs that. This behavioural fork is undocumented. The commented-out code in the implementation adds confusion rather than clarity.
**Fix:** Add a doc comment stating the two code paths and why they differ. Remove or clearly explain the commented-out dead code.

---

**A08-5** · LOW · No doc comment on `setEnabled(bool enable)`
**Description:** `setEnabled()` (`canmonitor.h` line 30) controls CAN bus power and transfer enable. When `enable=false` it always powers down; when `enable=true` it only powers up if `m_busConfig.enabled` is also true. This conditional makes the method more than a simple toggle, but it has no doc comment. A caller setting `enable=true` after a config change that disabled the bus will see silent no-operation.
**Fix:** Add a doc comment describing the power/xfer state machine and the dependency on `m_busConfig.enabled`.

---

**A08-6** · LOW · No doc comment on `clearCanConfig()`
**Description:** `clearCanConfig()` (`canmonitor.h` line 32) zeroes all config tables, then unconditionally resets defaults (`LindeExtended`, 250 kbps, enabled), starts the deferred-update timer, and emits `resetCanStates(true)`. The inline comment `// CMD_CLRCAN:` is an AT-command reference, not a description. The side effects on the running CAN bus are not documented.
**Fix:** Add a doc comment stating that all config is zeroed and default values are restored, and that this will eventually reconfigure the live bus.

---

**A08-7** · MEDIUM · Inaccurate inline comment in `canAttConfig()` implementation
**Description:** `canAttConfig()` (`canmonitor.cpp` line 707) contains the comment `// "^CANSPN: <att_index>,<name>,<type>,<spn_index>,<spn_mask>,<spn_state>[,<opcode>]"`. The response prefix is `^CANATT:`, not `^CANSPN:`. This is a copy-paste error. A developer relying on this comment to understand the wire protocol will be misled.
**Fix:** Correct the comment to read `// "^CANATT: <att_index>,<name>,<type>,<spn_index>,<spn_mask>,<spn_state>[,<opcode>]"`.

---

**A08-8** · LOW · No doc comments on the entire `setCanXxxConfig` / `canXxxConfig` family (10 methods)
**Description:** The ten getter/setter pairs (`canBusConfig`, `setCanBusConfig`, `canPgnConfig`, `setCanPgnConfig`, `canSpnConfig`, `setCanSpnConfig`, `canAttConfig`, `setCanAttConfig`, `canLinConfig`, `setCanLinConfig`, `canBydConfig`, `setCanBydConfig`, `canLin2Config`, `setCanLin2Config`, lines 33–46) each have inline format-string comments only inside the `.cpp` file. The header declares them with no documentation at all. Critically, each setter silently returns `false` when the current protocol does not match — this protocol restriction is not documented anywhere accessible from the header.
**Fix:** Add a brief doc comment to each pair in the header describing the expected format, the return value, and any protocol precondition. Moving or duplicating the existing format comments from the `.cpp` to the header would satisfy this.

---

**A08-9** · LOW · No doc comment on `setVdiAccess(bool access, bool inhibit)`
**Description:** `setVdiAccess()` (`canmonitor.h` line 52) is a safety-relevant method that controls physical machine access via the VDI CAN node (CAN ID 0x215). The two boolean parameters interact: `access=true, inhibit=true` → byte 0x05; `access=true, inhibit=false` → byte 0x01; otherwise → byte 0x00. This three-state output is entirely undocumented. The method is a no-op outside VDI mode, which is also undocumented.
**Fix:** Add a doc comment describing the VDI-mode precondition, the meaning of each parameter, the resulting CAN message byte values, and the periodic 1 Hz transmission.

---

**A08-10** · LOW · No doc comment on `enableVdi(bool enable)`
**Description:** `enableVdi()` (`canmonitor.h` line 53) calls `initVdi()` on enable (hard-coding a fixed set of CAN channel, PGN, SPN, and attribute configurations) or `clearCanConfig()` on disable. Calling this method with `enable=true` destroys any previously loaded configuration. This destructive side effect is not documented.
**Fix:** Add a doc comment describing the VDI hard-coded config applied on `enable=true` and the config wipe on `enable=false`.

---

**A08-11** · LOW · Undocumented bounds requirement on `attributeName()` and `attributeType()` inline getters
**Description:** Both inline getters (`canmonitor.h` lines 49–50) directly index `m_attConfigs[index]` without bounds checking. Passing `index >= CAN_MAX_ATT_IDX` produces undefined behaviour. There is no doc comment warning callers of the precondition, and no assertion in the implementation. `CanStateHandler` calls both from a loop bounded by `CAN_MAX_ATT_IDX`, so the immediate risk is low, but the interface is silently unsafe.
**Fix:** Add a doc comment stating the precondition `index < CAN_MAX_ATT_IDX`. Consider adding a bounds assertion in the implementation.

---

**A08-12** · LOW · No doc comment on `resetCanStates` signal; `resetLast` parameter semantics undocumented
**Description:** The `resetCanStates(bool resetLast)` signal (`canmonitor.h` line 60) is emitted in two contexts: from `clearCanConfig()` with `resetLast=true` (full reset) and potentially with `resetLast=false` (partial reset preserving certain attribute types). The slot `CanStateHandler::resetStates` treats the parameter to preserve `CanAttributeLast`, `CanAttributeLast2`, and `CanAttributeTime` entries when false. This semantics is visible only by cross-referencing the slot implementation; neither the signal nor the slot declaration has any documentation.
**Fix:** Add a doc comment to the signal declaration, and expand the existing minimal comment on `resetStates()` in `canstatehandler.h` to describe the `resetLast` parameter.

---

**A08-13** · LOW · No doc comment on `canStates()` and the destructive `autoReset` parameter
**Description:** `canStates(DigitalFormat format, bool autoReset)` (`canstatehandler.h` line 18) serialises accumulated CAN attribute states. When `autoReset=true`, it **zeroes** the session or usage counters/times immediately after sampling. This destructive behaviour means a second call to `canStates` for the same format will return different data. There is no doc comment warning callers that the call mutates state.
**Fix:** Add a doc comment to the declaration describing the three `DigitalFormat` values, the effect of `autoReset=true` (zeroing of accumulated counters/times for the selected scope), and the return format.

---

**A08-14** · LOW · No doc comment on `updateIdleTimer()`
**Description:** `updateIdleTimer()` (`canstatehandler.h` line 17) checks whether idle-timeout is configured and creates, destroys, or starts a single-shot timer accordingly. The inline comment inside the implementation references "per spec., 64 means input is CAN SEAT state" but names no spec document. The method is called externally after config changes, but there is no doc comment explaining when a caller should invoke it.
**Fix:** Add a doc comment stating that this must be called whenever idle-timeout configuration changes, and identify or remove the unnamed spec reference.

---

**A08-15** · INFO · Stray trailing double-quote in `setCanLin2Config` implementation comment
**Description:** `canmonitor.cpp` line 1099 reads:
```cpp
// "<spn_index>,<rsp_id>,<req_id>,<addr>,<rsp_frame>,<rsp_mask>,<width>,<offset>,<opcode>,<operand>""
```
There is an extra `"` at the end of the format string comment. This is a cosmetic defect but can cause confusion when using the comment as a copy-paste template for test code.
**Fix:** Remove the trailing `"` character from the comment.

---

## Summary Table

| ID | Severity | Location | Title |
|----|----------|----------|-------|
| A08-1 | LOW | `canmonitor.h:20` | No doc comment on `CanMonitor` constructor |
| A08-2 | LOW | `canmonitor.h:22-23` | No doc comment on `readCanConfig()` / `readOldCanConfig()` |
| A08-3 | LOW | `canmonitor.h:24` | No doc comment on `saveCanConfig()` |
| A08-4 | LOW | `canmonitor.h:25` | No doc comment on `calculateCanCrc()` |
| A08-5 | LOW | `canmonitor.h:30` | No doc comment on `setEnabled()` |
| A08-6 | LOW | `canmonitor.h:32` | No doc comment on `clearCanConfig()` |
| A08-7 | MEDIUM | `canmonitor.cpp:707` | `canAttConfig()` comment says `^CANSPN:` instead of `^CANATT:` |
| A08-8 | LOW | `canmonitor.h:33-46` | No header doc comments on 10 `canXxxConfig` / `setCanXxxConfig` methods |
| A08-9 | LOW | `canmonitor.h:52` | No doc comment on `setVdiAccess()` |
| A08-10 | LOW | `canmonitor.h:53` | No doc comment on `enableVdi()` |
| A08-11 | LOW | `canmonitor.h:49-50` | No bounds precondition documented on `attributeName()` / `attributeType()` |
| A08-12 | LOW | `canmonitor.h:60` | `resetCanStates` signal `resetLast` parameter undocumented |
| A08-13 | LOW | `canstatehandler.h:18` | Destructive `autoReset` parameter in `canStates()` undocumented |
| A08-14 | LOW | `canstatehandler.h:17` | No doc comment on `updateIdleTimer()` |
| A08-15 | INFO | `canmonitor.cpp:1099` | Stray trailing `"` in `setCanLin2Config` format comment |

**Total findings: 15** (1 MEDIUM, 13 LOW, 1 INFO)
# Pass 3 Agent A09 — Documentation

**Audit run:** 2026-02-28-01
**Branch:** master
**Files reviewed:**
- `comm/ftpclient.h`
- `comm/ftpclient.cpp`
- `comm/gmtpchat.h`
- `comm/gmtpchat.cpp`

---

## Reading Evidence

### File: `comm/ftpclient.h` + `comm/ftpclient.cpp`

**Class:** `FtpClient` (extends `QObject`)

**Public methods (header line numbers):**

| Method | Line | Doc comment present? |
|--------|------|----------------------|
| `FtpClient(BackgroundWorker *parent)` | 17 | No |
| `void download(const QUrl &url)` | 18 | No |
| `void startTransfer()` | 19 | No |
| `void writeQueue()` | 21 | No |
| `void readQueue()` | 22 | No |
| `void setPowerState(CIGCONF::PowerState state)` | 24 | No |

**Signals:**

| Signal | Line |
|--------|------|
| `void fileUpdated(const QString &fileName)` | 27 |
| `void sendGmtpMessage(CIGCONF::GmtpMessage msg, const QByteArray &extra)` | 28 |
| `void nextTransfer()` | 29 |

**Slots:** None declared (private methods are connected internally via `connect()`)

**Types, enums, constants (defined in `.cpp`):**

| Name | Value | Location |
|------|-------|----------|
| `MAX_FILE_SIZE` | `16 * 1024 * 1024` (16 MB) | `ftpclient.cpp` line 14 |
| `FTP_QUEUE_FILE` | `"/home/ftpqueue.txt"` | `ftpclient.cpp` line 15 |
| `FTP_RETRIES` | `5` | `ftpclient.cpp` line 16 |

**No doc comments exist anywhere in ftpclient.h or ftpclient.cpp** (the only inline comment is a note on line 33: `// note: QNetworkReply::setReadBufferSize doesn't work`).

---

### File: `comm/gmtpchat.h` + `comm/gmtpchat.cpp`

**Class:** `GmtpChat` (extends `QObject`)

**Enums:**

| Enum | Values |
|------|--------|
| `Priority` | `NormalPriority = 0`, `HighPriority` |
| `PduType` | `PduId = 1`, `PduData = 2`, `PduIdExt = 3`, `PduDataExt = 4`, `PduAck = 5` |

**Public methods (header line numbers):**

| Method | Line | Doc comment present? |
|--------|------|----------------------|
| `GmtpChat(ModemChat *parent)` | 21 | No |
| `void setPowerState(CIGCONF::PowerState state)` | 22 | No |
| `void connectServer()` | 23 | No |
| `void sendMessage(const QByteArray &msgData, Priority priority = NormalPriority)` | 24 | No |
| `void sendAck(quint16 msgId)` | 25 | No |
| `void clearGMTPMsgQueue()` | 26 | No |
| `bool sleeping()` | 27 | No |
| `void setEthernetState(bool up)` | 28 | No |
| `bool acksRemaining()` | 29 | No |

**Signals:**

| Signal | Line |
|--------|------|
| `void cmdReceived(const QByteArray &ba)` | 32 |
| `void socketStateChanged(bool state)` | 33 |
| `void allMessagesSent()` | 34 |
| `void allAcksSent()` | 35 |
| `void gmtpHotStartReconnect()` | 36 |
| `void disconnectSocket()` | 37 |

**Slots:** None declared in the public interface (private methods wired internally).

**Constants (defined in `.cpp`):**

| Name | Value | Location |
|------|-------|----------|
| `MAX_MESSAGE_CNT` | `1000` | `gmtpchat.cpp` line 16 |
| `MAX_RETRIES` | `3` | `gmtpchat.cpp` line 17 |
| `DEF_MSOCKET_TIMEOUT` | `10000` (ms) | `gmtpchat.cpp` line 18 |
| `MAX_GMTP_RECONNECT_CNT` | `20` | `gmtpchat.cpp` line 19 |

**Doc comments in the implementation:** One Doxygen-style block comment exists above `disconnectFromHost()` in `gmtpchat.cpp` (lines 521–524): `/** @brief Gracefully disconnect from socket if connected */`. This is a private method; no equivalent comment appears in the header. All public methods and signals are undocumented.

---

## Findings

**A09-1** · LOW · `FtpClient::download()` — no documentation on queueing behaviour or network precondition

**Description:** `download(const QUrl &url)` enqueues the URL but silently returns without starting the transfer when the network is unavailable (checked via `m_worker->networkStatus()`). The caller receives no indication that the download was deferred. The parameter `url` is not described, and the silent-defer behaviour is not documented anywhere.

**Fix:** Add a doc comment above the declaration in `ftpclient.h` explaining that the URL is enqueued for download, that the transfer is deferred when the network is offline, and that the `fileUpdated` signal is emitted on success.

---

**A09-2** · LOW · `FtpClient::startTransfer()` — no documentation on power-state guard or retry logic

**Description:** `startTransfer()` is a public method that is also called internally via the `nextTransfer` signal. It silently returns when `m_powerState >= SleepState`, when a transfer is already in progress, or when the queue is empty. It also triggers a file-system read of the persistent queue (`readQueue()`) if the queue-file flag is set. None of this behaviour is described for callers.

**Fix:** Add a doc comment explaining the idempotency guarantee, the power-state precondition, and that it reads the persistent queue on startup.

---

**A09-3** · LOW · `FtpClient::writeQueue()` / `FtpClient::readQueue()` — no documentation on persistent queue file contract

**Description:** These two public methods implement persistence of the pending download queue to `/home/ftpqueue.txt`. `writeQueue()` appends URLs to the file and clears the in-memory queue; `readQueue()` restores the queue from the file and deletes the file. The fact that `readQueue()` is destructive (removes the file) and that it resets `m_retries` to zero is not documented. Callers that invoke these methods directly (or indirectly via `setPowerState`) are given no guidance on ordering or side-effects.

**Fix:** Add doc comments to both declarations noting the file path used, the destructive read behaviour, and the retry-counter reset performed by `readQueue()`.

---

**A09-4** · HIGH · `FtpClient::setPowerState()` — safety-critical method, no documentation

**Description:** `setPowerState(CIGCONF::PowerState state)` is called by the system to signal impending sleep. When `state >= SleepState`, it calls `writeQueue()`, which persists pending downloads and clears the in-memory queue. Calling this method with the wrong state value or at the wrong time can result in queued file transfers (including firmware updates identified by `FILE_FLEETMS_FW`) being silently discarded or persisted incomplete. There is no doc comment explaining what states are valid, what side-effects are triggered, or that the persistent queue is modified.

**Fix:** Add a doc comment to the declaration that enumerates valid `CIGCONF::PowerState` values, explicitly states that calling with `state >= SleepState` flushes the queue to disk, and warns that no further transfers will be initiated until the power state is restored.

---

**A09-5** · HIGH · `GmtpChat::setPowerState()` — safety-critical method, no documentation

**Description:** `GmtpChat::setPowerState(CIGCONF::PowerState state)` aborts the TCP socket (`m_tcpSocket->abort()`), flushes both the upload and recent message queues to disk, and stops all timers when `state >= SleepState`. An abrupt socket abort (rather than graceful disconnect) and queue flushing have direct consequences for message delivery. No doc comment exists to describe the state transition, the abort-vs-disconnect choice, or the file-system side-effects.

**Fix:** Add a doc comment explaining the abort behaviour, that both upload and recent message queues are written to persistent storage, and which power states trigger the shutdown path.

---

**A09-6** · LOW · `GmtpChat::connectServer()` — no documentation on server rotation or mutex guard

**Description:** `connectServer()` selects the GMTP server using `m_serverIndex` (rotated on each reconnect attempt) and is guarded by a mutex to prevent concurrent connection attempts. The public interface gives no indication of these semantics, nor of the fact that calling this when already connected or connecting is handled silently.

**Fix:** Add a doc comment explaining that server selection is managed internally, that the method is safe to call from any thread (mutex-guarded), and that duplicate calls are silently ignored.

---

**A09-7** · LOW · `GmtpChat::sendMessage()` — no documentation on priority semantics or queue overflow behaviour

**Description:** `sendMessage()` accepts an optional `Priority` parameter whose effect is non-obvious: `HighPriority` prepends the message to the in-memory queue, bypassing the 1000-message limit and the file-based overflow. When `NormalPriority` is used and the queue is full, messages are spilled to disk via `writeQueue(true)`. None of this is described in a comment, nor are the `msgData` format expectations or the sleep-state guard.

**Fix:** Add a doc comment describing the `Priority` enum semantics, the in-memory queue limit (`MAX_MESSAGE_CNT = 1000`), the disk-spill behaviour for normal priority messages, and the sleep-state early return.

---

**A09-8** · LOW · `GmtpChat::sendAck()` — no documentation on parameter meaning

**Description:** `sendAck(quint16 msgId)` enqueues a PDU-Ack frame for the given `msgId`. The parameter name `msgId` matches what a caller might interpret as the outgoing message ID, when in fact it is the server-assigned ID being acknowledged. This inversion is a common source of misuse. No doc comment clarifies the direction (server-to-device message ID being acknowledged).

**Fix:** Add a doc comment clarifying that `msgId` is the ID of an inbound server message being acknowledged, not an outbound message ID.

---

**A09-9** · INFO · `GmtpChat::clearGMTPMsgQueue()` — no documentation on scope of clearing

**Description:** `clearGMTPMsgQueue()` clears the in-memory file-index list, the recent message queue, and the upload message queue. It does not remove any files already persisted to disk. This distinction is not documented, which could mislead a caller into thinking the operation is complete.

**Fix:** Add a brief comment noting that only in-memory queues are cleared, and that already-persisted queue files on disk are not removed.

---

**A09-10** · INFO · `GmtpChat::sleeping()` / `GmtpChat::acksRemaining()` / `GmtpChat::setEthernetState()` — inline one-liner methods, no doc comments

**Description:** These three inline public methods are defined directly in the header without any explanatory comments. While individually simple, `sleeping()` returns `!m_connect` (not a power-state check as the name implies), and `setEthernetState(bool up)` emits `disconnectSocket()` when `up` is false, which is a non-obvious side-effect for a setter.

**Fix:** At minimum, add a brief comment to `setEthernetState()` noting the side-effect of emitting `disconnectSocket()` when the link goes down. Add a comment to `sleeping()` clarifying that it reflects the GMTP connection intent flag, not the system power state.

---

**A09-11** · MEDIUM · `disconnectFromHost()` is documented only in the `.cpp`, not in the header; the sole Doxygen comment in the codebase is misplaced

**Description:** The only formal doc comment in either file pair is the Doxygen `/** @brief ... */` block on `disconnectFromHost()` in `gmtpchat.cpp` (lines 521–524). However, `disconnectFromHost()` is a private method, so the doc comment is not attached to any declaration that an IDE or documentation tool would surface to API consumers. All public methods that callers actually use remain undocumented. This illustrates an inverted documentation priority.

**Fix:** Move or duplicate the Doxygen comment to the private declaration in the header if desired, but more importantly apply the same documentation discipline to the public API.

---

## Summary Table

| ID | Severity | Location | Title |
|----|----------|----------|-------|
| A09-1 | LOW | `ftpclient.h:18` | `download()` — no documentation on queueing or network precondition |
| A09-2 | LOW | `ftpclient.h:19` | `startTransfer()` — no documentation on power-state guard or retry logic |
| A09-3 | LOW | `ftpclient.h:21-22` | `writeQueue()` / `readQueue()` — persistent queue file contract undocumented |
| A09-4 | HIGH | `ftpclient.h:24` | `setPowerState()` — safety-critical method, fully undocumented |
| A09-5 | HIGH | `gmtpchat.h:22` | `GmtpChat::setPowerState()` — safety-critical method, fully undocumented |
| A09-6 | LOW | `gmtpchat.h:23` | `connectServer()` — server rotation and mutex guard undocumented |
| A09-7 | LOW | `gmtpchat.h:24` | `sendMessage()` — priority semantics and overflow behaviour undocumented |
| A09-8 | LOW | `gmtpchat.h:25` | `sendAck()` — parameter direction ambiguous, undocumented |
| A09-9 | INFO | `gmtpchat.h:26` | `clearGMTPMsgQueue()` — disk-vs-memory clearing distinction undocumented |
| A09-10 | INFO | `gmtpchat.h:27-29` | Inline methods `sleeping()`, `acksRemaining()`, `setEthernetState()` undocumented |
| A09-11 | MEDIUM | `gmtpchat.cpp:521-524` | Only doc comment in codebase is on a private method; public API has none |

**Total findings: 11** (2 HIGH, 5 LOW, 2 LOW/INFO boundary, 2 INFO, 1 MEDIUM)
# Pass 3 Agent A10 — Documentation

**Audit run:** 2026-02-28-01
**Branch:** master
**Files reviewed:**
- `comm/modemchat.h` + `comm/modemchat.cpp`
- `comm/ntpsync.h` + `comm/ntpsync.cpp`

---

## Reading Evidence

### comm/modemchat.h + comm/modemchat.cpp

**Class:** `ModemChat` (inherits `QObject`)

**Enum defined:**
| Name | Line (header) | Values |
|------|--------------|--------|
| `NetworkState` | 22 | `NetworkStopped`, `NetworkHome`, `NetworkSearching`, `NetworkDenied`, `NetworkUnknown`, `NetworkRoaming` |

**Private struct defined:**
| Name | Location |
|------|----------|
| `apnData` | Lines 50–54 (header, private) — holds `apn`, `apnUser`, `apnPassword` |

**Public methods (header):**
| Method | Line | Has doc comment? |
|--------|------|-----------------|
| `ModemChat(EM070::ModemPort *modemPort)` | 24 | No |
| `void portStateChanged(bool open)` | 25 | No |
| `void setGnssEnabled(bool enable)` | 26 | No |
| `void rssiRefresh()` | 27 | No |
| `void qmiCheck()` | 28 | No |
| `void networkCheck()` | 29 | No |
| `void updateApn()` | 30 | No |
| `void detach(bool send = true)` | 31 | No |
| `void requestDetach()` | 32 | No |
| `const QByteArray &cgmi() const` | 34 | No |
| `const QByteArray &cgmm() const` | 35 | No |
| `const QByteArray &cgmr() const` | 36 | No |
| `const QByteArray &cgsn() const` | 37 | No |
| `const QByteArray &iccid() const` | 38 | No |
| `const QByteArray &rssi() const` | 39 | No |
| `const QByteArray &mobileOperator() const` | 40 | No |
| `const QByteArray &moni() const` | 41 | No |
| `NetworkState networkState() const` | 42 | No |
| `bool isEthernetReady() const` | 43 | No |

**Signals:**
| Signal | Line (header) |
|--------|--------------|
| `void simError()` | 46 |
| `void ethernetStateChanged(bool ready)` | 47 |

**File-level comment (lines 1–4):**
```
/* Required by GMTP:
 *     ICCID, signal strength (CSQ rssi), modem version (CGMR)
 */
```
This is the only doc-level comment in the header. It describes what data the GMTP protocol requires but says nothing about the class itself or any method.

**Notes on implementation-only doc comments:**
- `onUqmiProcessComplete` (cpp, line 759–764): Has a `/** @brief ... */` stub in the `.cpp` file, but it is a private method not declared in the header. The stub is empty — it lists `exitCode` and `exitStatus` parameters with no descriptions.
- `reconnectNetwork` (cpp, line 813–818): Has a `/** @brief ... */` stub in the `.cpp` file (also private), similarly empty; the `@return true` / `@return false` annotations are present but the function return type is `void`, making them incorrect.
- Private method inline comment (header line 68): `// to save the parsing time, only QByteArray/QString/int/bool are supported` — documents the private `args()` helper only.

---

### comm/ntpsync.h + comm/ntpsync.cpp

**Class:** `NtpSync` (inherits `QObject`)

**Constants defined (cpp only):**
| Name | Value | Description |
|------|-------|-------------|
| `EPOCH_DIFF` | `0x83aa7e80UL` | Difference between NTP epoch (1900) and Unix epoch (1970) |

**Public methods (header):**
| Method | Line | Has doc comment? |
|--------|------|-----------------|
| `NtpSync(ModemChat *parent)` | 14 | No |
| `void connectServer()` | 15 | No |
| `void abortConnection()` | 16 | No |

**Signals:**
| Signal | Line (header) |
|--------|--------------|
| `void synchronized(bool yes)` | 19 |

**Private methods (not declared in header, implemented in cpp):**
| Method | Notes |
|--------|-------|
| `void writeSocket()` | No doc comment |
| `void readSocket()` | No doc comment; contains an inline comment at line 95–97 explaining the sign convention of `timeError`, which is the only substantive inline documentation in either file |

**Constructor comment (cpp, lines 20–23):**
```
/*
 * on connected, restart timer
 * in a timer interval, if still out of sync, reset socket
 */
```
This is a block comment inside the constructor body; not a doc comment above the declaration.

**Inline comment accuracy note (ntpsync.cpp, line 31):**
```cpp
// -1 means time has in sync yet
```
The comment contains a typo/grammatical error ("has in sync" should be "has not synced" or "is already in sync"). This causes the comment to be misleading: the intent is that `-1` is the sentinel value meaning "already synchronized", but the comment as written is ambiguous.

---

## Findings

**A10-1** · LOW · No doc comments on any public method in `ModemChat`

**Description:** The `ModemChat` class exposes 19 public methods (constructor + 18 methods/accessors) plus 2 signals. None of them carry any form of doc comment in the header. Several methods have non-obvious behavior: `detach(bool send = true)` pushes a sequence of AT commands whose effect depends on `isWwx()` state; `qmiCheck()` conditionally either checks QMI data-link state or executes a shell reconnect script; `networkCheck()` implements a countdown timer that forces a network detach if the device cannot connect within 180 seconds; `requestDetach()` sets a deferred flag rather than detaching immediately. These subtleties are completely undocumented at the API level.

**Fix:** Add at minimum a one-line `//` comment above each non-trivial public method in `modemchat.h` describing its purpose, side effects, and the meaning of parameters. Priority should be given to `detach()`, `qmiCheck()`, `networkCheck()`, `requestDetach()`, `portStateChanged()`, and `updateApn()`.

---

**A10-2** · LOW · No doc comments on any public method in `NtpSync`

**Description:** `NtpSync` has three public methods (`NtpSync()`, `connectServer()`, `abortConnection()`) and one signal (`synchronized(bool yes)`), none of which carry a doc comment. The semantics of `synchronized(bool yes)` — that `false` means the sync was abandoned after 3 retries rather than that synchronization definitively failed — are not documented. `abortConnection()` has a subtle asymmetry: it only resets `m_syncTimes` to zero if it is positive (already-synchronized state `-1` is preserved), which is not obvious without reading the implementation.

**Fix:** Add doc comments in `ntpsync.h` above each public declaration. In particular document: the `bool yes` parameter of `synchronized` (true = synced, false = gave up after retry limit); the retry-and-abandon behavior of `connectServer()`; and the preserving-of-negative-state behavior of `abortConnection()`.

---

**A10-3** · MEDIUM · Inaccurate `@return` annotations on private `reconnectNetwork()` stub

**Description:** In `modemchat.cpp` at lines 813–818, a Doxygen-style comment block on `reconnectNetwork()` includes:
```
 * @return true
 * @return false
```
The function is declared and implemented as `void ModemChat::reconnectNetwork()` — it returns nothing. The copy-pasted stub implies a boolean return value that does not exist. Any developer reading this comment while maintaining the function may incorrectly assume a result is available or that error handling is performed.

**Fix:** Remove the erroneous `@return` lines from the `reconnectNetwork()` doc stub, and add meaningful `@brief` text describing what the function does (selects the APN and launches the `qmi_reconnect` shell script via `QProcess`).

---

**A10-4** · INFO · Misleading/typo inline comment in `NtpSync::connectServer()`

**Description:** `ntpsync.cpp` line 31 reads:
```cpp
// -1 means time has in sync yet
```
This comment contains a grammatical error ("has in sync yet") that makes its meaning ambiguous. The actual logic uses `-1` as a sentinel meaning "synchronization has already been achieved" (set at line 90 when a valid NTP response is received). A developer reading this comment might interpret it as "time has not synced yet", which is the opposite of the intended meaning.

**Fix:** Correct the comment to accurately state the sentinel's meaning, for example:
```cpp
// m_syncTimes == -1 means the clock has already been successfully synchronized
```

---

**A10-5** · INFO · Empty `@brief` on `onUqmiProcessComplete()` Doxygen stub

**Description:** `modemchat.cpp` lines 759–764 contain:
```cpp
/**
 * @brief onUqmiProcessComplete
 *
 * @param exitCode
 * @param exitStatus
 */
```
The `@brief` has no descriptive text (only the function name repeated), and the `@param` entries have no descriptions. This is a stub placeholder that provides no information to a maintainer. While the method is private, the presence of an empty Doxygen block is worse than no comment because it gives the appearance of documentation while conveying nothing.

**Fix:** Populate the `@brief` and `@param` descriptions. Suggested text: `@brief Handles completion of the uqmi data-status or reconnect process; updates Ethernet state based on output or resets the reconnect flag.` Describe `exitCode` (process exit code, non-zero indicates failure) and `exitStatus` (normal vs. crashed exit).

---

**A10-6** · HIGH · No documentation on security/safety-relevant credential handling in `selectAPN()` and `reconnectNetwork()`

**Description:** `selectAPN()` (private, `modemchat.cpp` lines 270–314) selects APN credentials — including username and password — based on ICCID prefix matching. `reconnectNetwork()` (lines 819–839) passes those credentials as shell arguments to an external script (`/etc/ci/qmi_reconnect`). Neither function has any documentation describing: (a) how credentials are sourced (ICCID auto-selection vs. `gCfg`); (b) that credentials may be passed as plaintext shell arguments (visible in process listings); (c) the security implication that a misconfigured or tampered ICCID prefix could cause incorrect or attacker-chosen credentials to be submitted to a network. Since these are private methods the finding is rated HIGH due to the security relevance of the behavior, not the public API exposure.

**Fix:** Add doc comments to both `selectAPN()` and `reconnectNetwork()` in the `.cpp` file that: (1) explain the ICCID-based APN selection logic and its limitations; (2) note that credentials are passed as process arguments and are therefore visible in `/proc/<pid>/cmdline`; (3) cross-reference the shell script being invoked. Consider whether the credential-passing mechanism should be replaced with environment variables or a credentials file to avoid process-argument exposure.

---

## Summary Table

| ID | Severity | Location | Title |
|----|----------|----------|-------|
| A10-1 | LOW | `modemchat.h` | No doc comments on any public method in `ModemChat` |
| A10-2 | LOW | `ntpsync.h` | No doc comments on any public method in `NtpSync` |
| A10-3 | MEDIUM | `modemchat.cpp:813–818` | Inaccurate `@return` annotations on void `reconnectNetwork()` |
| A10-4 | INFO | `ntpsync.cpp:31` | Misleading typo in inline comment for `-1` sentinel value |
| A10-5 | INFO | `modemchat.cpp:759–764` | Empty `@brief`/`@param` Doxygen stub on `onUqmiProcessComplete()` |
| A10-6 | HIGH | `modemchat.cpp:270–314, 819–839` | No documentation on credential handling in `selectAPN()` and `reconnectNetwork()` |
# Pass 3 Agent A11 — Documentation

**Audit run:** 2026-02-28-01
**Branch:** master
**Files reviewed:** `main.cpp`, `mytranslator.h`, `mytranslator.cpp`

---

## Reading Evidence

### `main.cpp`

**File purpose:** Application entry point. Initialises `QApplication`, installs a key event filter, loads the locale, registers Qt meta-types for cross-thread signals, configures hardware GPIOs for video switch and flip, creates the main `Dialog` window and a `BackgroundWorker` on a dedicated thread, then enters the Qt event loop.

**Free functions defined in this file:**

| Name | Line | Notes |
|---|---|---|
| `hideBootProgress()` | 24 | Writes `-1` to the NUC970 framebuffer `progress` sysfs node to suppress the boot animation |
| `configureCrashLogging()` | 38 | Writes and launches a shell watchdog script to `/mnt/sd/app_monitor`; call is commented-out in `main` |
| `main(int argc, char *argv[])` | 71 | Entry point |

**Signals / slots:** None defined in this file.

**Types / enums / constants defined:** None; uses types from included headers (`CIGCONF::PowerState`, `CIGCONF::GmtpMessage`, etc. are only registered here via `qRegisterMetaType`).

**Preprocessor symbols used:**
- `CONSTRAINED_MEMORY_TEST` (line 17, commented out) — reserves and locks 10 MB with `mlock`
- `__arm__` — guards ARM-specific DPI attribute and `hideBootProgress` sysfs write

---

### `mytranslator.h` + `mytranslator.cpp`

**File purpose:** Manages application locale/translation: loading a saved language preference on startup, switching languages at runtime, querying the current language, and removing the active translator.

**Constants defined (header, lines 11–12):**

| Name | Value | Line |
|---|---|---|
| `langEnglish` | `"EN"` | 11 |
| `langSpanish` | `"ES"` | 12 |

**Global variable declared (header, line 14):**

| Name | Type | Line |
|---|---|---|
| `mTranslator` | `QTranslator` | 14 |

**Free functions declared (header) / defined (implementation):**

| Name | Header line | Impl line | Brief purpose |
|---|---|---|---|
| `loadLocalLanguage(void)` | 15 | 15 | Reads `local.dat`, looks up the language code in `lang.dat`, loads the matching `.qm` file; deletes `local.dat` if the code is not found |
| `updateLocalLanguage(const QString &arg1)` | 16 | 74 | Searches `lang.dat` for `arg1`; if found, loads the translator and writes the code to `local.dat`; if not found, removes the translator and deletes `local.dat` |
| `getCurrentLanguage(void)` | 17 | 132 | Returns the current language code string (defaults to `"EN"` when no valid preference is stored) |
| `queryLanguage(void)` | 18 | 167 | Returns `QLocale::English`, `QLocale::Spanish`, or `-1` based on the stored preference |
| `setLanguage(int local)` | 19 | 177 | Changes the stored language to the given `QLocale` integer value; no-ops if already set; returns the value applied or `-1` for unsupported locales |
| `removeTranslator()` | 20 | 190 | Removes `mTranslator` from `QCoreApplication` if it is non-empty |

**Signals / slots:** None (not a QObject subclass).

**Types / enums:** None beyond the constants listed above.

---

## Documentation Findings

### A11-1 · LOW · `main.cpp` has no file-level comment explaining the startup sequence

**Description:** The file contains no file-level block or line comment describing its purpose, the overall startup sequence, or the threading model. Readers must trace through the entire body of `main()` to understand that a `BackgroundWorker` is moved to a separate thread, that GPIO lines are driven unconditionally on every launch, and that `configureCrashLogging` is intentionally disabled. The two helper functions `hideBootProgress` and `configureCrashLogging` also lack any comment above their definitions.

**Fix:** Add a file-level block comment (or `/** @file */` Doxygen header) at the top of `main.cpp` summarising: (1) the application entry point, (2) the startup sequence (locale load -> meta-type registration -> hardware GPIO init -> UI creation -> background thread launch), and (3) the threading model. Add a one-line comment above each helper function explaining what it does and on which platform it is active.

---

### A11-2 · INFO · `hideBootProgress()` has no doc comment

**Description:** The function is defined in `main.cpp` at line 24 without any comment above it. Its purpose (disabling the NUC970 framebuffer boot-progress animation by writing `-1` to a sysfs node) and its ARM-only scope are not documented. The function name is reasonably self-describing, which limits severity.

**Fix:** Add a short comment above the definition: what sysfs node is written, what value and effect, and that the function is a no-op on non-ARM builds.

---

### A11-3 · LOW · `configureCrashLogging()` has no doc comment and is dead code with no explanation

**Description:** The function at line 38 has no comment above it. Its call at line 101 is commented out with no explanation of why it is disabled. The function writes a shell watchdog script to `/mnt/sd/app_monitor` and then launches it with `QProcess::startDetached`. The absence of a comment leaves it unclear whether this is intentionally disabled for a release build, a work-in-progress, or dead code that should be removed.

**Fix:** Add a doc comment above the definition explaining its purpose, the crash-detection mechanism, and the reason the call is commented out in `main`. If permanently disabled, add an inline comment at the call site (e.g., `// disabled: see <ticket> — watchdog conflicts with systemd supervisor`).

---

### A11-4 · MEDIUM · Doc comment for `loadLocalLanguage` is empty (stub only)

**Description:** The implementation at `mytranslator.cpp` lines 12–14 contains:
```cpp
/**
 * @brief loadLocalLanguage
 */
```
This provides no information beyond the function name. The function has a non-trivial side-effect: it reads `local.dat`, validates the language code against `lang.dat`, installs a Qt translator, and — importantly — **deletes `local.dat`** if the stored language code is not found. None of this behaviour, nor the two data files it depends on, is documented. There are no `@param` or `@return` annotations (though both are `void`, the file-dependency side-effect warrants description).

**Fix:** Expand the comment to describe: what `local.dat` and `lang.dat` contain, the fallback-to-English behaviour, and the destructive side-effect of removing `local.dat` on an unrecognised language code.

---

### A11-5 · MEDIUM · Doc comment for `updateLocalLanguage` is empty (stub only)

**Description:** The implementation at `mytranslator.cpp` lines 71–73 contains:
```cpp
/**
 * @brief updateLocalLanguage
 */
```
The `@param arg1` is not described. The function performs two distinct actions — installing a new translator into `QCoreApplication` and persisting the choice to `local.dat` — and also has a destructive fallback (removes the translator and deletes `local.dat` for unknown codes). None of this is documented.

**Fix:** Add `@param arg1` description (language code string, e.g. `"EN"` or `"ES"`), describe the persistence mechanism, and note the fallback behaviour when the code is not found in `lang.dat`.

---

### A11-6 · MEDIUM · Doc comment for `getCurrentLanguage` is incomplete (missing `@return`)

**Description:** The implementation at `mytranslator.cpp` lines 128–131 contains:
```cpp
/**
 * @brief getCurrentLanguage
 * @return
 */
```
The `@return` tag is present but its value is blank — it documents nothing. The function returns the stored language code string (e.g. `"EN"`) or defaults to `langEnglish` (`"EN"`) when no valid preference exists. The default-to-English fallback behaviour is not noted.

**Fix:** Complete the `@return` annotation: `@return The current language code string (e.g. "EN", "ES"); defaults to "EN" if no valid preference is stored.`

---

### A11-7 · LOW · `queryLanguage()` has no doc comment

**Description:** The function is declared in the header at line 18 and defined at `mytranslator.cpp` line 167 with no comment of any kind. It returns a `QLocale` enum integer (`QLocale::English`, `QLocale::Spanish`, or `-1`), which is non-obvious from the name alone. The sentinel value `-1` for unsupported/unknown languages is undocumented.

**Fix:** Add a comment above the declaration in `mytranslator.h` and/or above the definition in `mytranslator.cpp` describing the return type semantics: `@return QLocale::English, QLocale::Spanish, or -1 if the current language is unrecognised.`

---

### A11-8 · LOW · `setLanguage()` has no doc comment

**Description:** The function is declared in the header at line 19 and defined at `mytranslator.cpp` line 177 with no comment. The parameter is a `QLocale` integer, the no-op condition (`local == queryLanguage()`), the unsupported-language sentinel return of `-1`, and the fact that it delegates to `updateLocalLanguage` are all undocumented. The distinction between `setLanguage` and `updateLocalLanguage` (public API vs. internal implementation) is unclear without comments.

**Fix:** Add `@param local` (QLocale integer, e.g. `QLocale::English`), `@return` (the value applied, or `-1` for unsupported locales), and note the no-op behaviour when the language is already set.

---

### A11-9 · INFO · `removeTranslator()` has no doc comment

**Description:** The function is declared in the header at line 20 and defined at `mytranslator.cpp` line 190 with no comment. The function is simple — it removes `mTranslator` from `QCoreApplication` if non-empty — but it is a public API function and its pre-condition (the translator must already have been loaded) and side-effect are undocumented.

**Fix:** Add a brief one-line comment: when this should be called (e.g. before a language switch or application shutdown) and what it does if the translator is already empty (silent no-op).

---

### A11-10 · INFO · Constants `langEnglish` and `langSpanish` have no doc comments

**Description:** The two string constants declared in `mytranslator.h` at lines 11–12 have no comments. Their values (`"EN"`, `"ES"`) are clear from inspection, but the format convention (ISO 639-1 two-letter codes, case-insensitive as used in comparisons) is not documented.

**Fix:** Add a brief inline or block comment noting that these constants represent ISO 639-1 language codes used in `local.dat` and `lang.dat`, and that comparisons are case-insensitive.

---

### A11-11 · INFO · Global `mTranslator` has no doc comment

**Description:** The global `QTranslator mTranslator` is declared `extern` in `mytranslator.h` line 14 and defined in `mytranslator.cpp` line 10 with no comment. Its scope (global, shared across all translation functions), ownership (managed by `mytranslator.cpp`), and lifetime are undocumented.

**Fix:** Add a brief comment explaining that this is the single application-wide translator instance managed by the `mytranslator` module, and that callers should not install or remove it directly.

---

## Summary Table

| ID | Severity | File | Symbol | Issue |
|---|---|---|---|---|
| A11-1 | LOW | `main.cpp` | (file level) | No file-level comment; no comments on helper functions |
| A11-2 | INFO | `main.cpp` | `hideBootProgress()` | No doc comment |
| A11-3 | LOW | `main.cpp` | `configureCrashLogging()` | No doc comment; disabled call unexplained |
| A11-4 | MEDIUM | `mytranslator.cpp` | `loadLocalLanguage()` | Stub `@brief` only; destructive side-effect undocumented |
| A11-5 | MEDIUM | `mytranslator.cpp` | `updateLocalLanguage()` | Stub `@brief` only; param and side-effects undocumented |
| A11-6 | MEDIUM | `mytranslator.cpp` | `getCurrentLanguage()` | `@return` tag present but blank; default behaviour undocumented |
| A11-7 | LOW | `mytranslator.h/.cpp` | `queryLanguage()` | No doc comment; `-1` sentinel undocumented |
| A11-8 | LOW | `mytranslator.h/.cpp` | `setLanguage()` | No doc comment; param, return, and no-op condition undocumented |
| A11-9 | INFO | `mytranslator.h/.cpp` | `removeTranslator()` | No doc comment |
| A11-10 | INFO | `mytranslator.h` | `langEnglish`, `langSpanish` | No comment on format convention |
| A11-11 | INFO | `mytranslator.h/.cpp` | `mTranslator` | No comment on ownership or lifetime |

**Totals:** 3 MEDIUM, 3 LOW, 5 INFO
# Pass 3 Agent A12 — Documentation

**Audit run:** 2026-02-28-01
**Branch:** master
**Files reviewed:**
- `platform/aescrypto.h` + `platform/aescrypto.cpp`
- `platform/blecentral.h` + `platform/blecentral.cpp`

---

## Reading Evidence

### `platform/aescrypto.h` / `platform/aescrypto.cpp`

**Class:** `EM070::AesCrypto`

**Public methods (header):**

| Line | Signature |
|------|-----------|
| 16 | `static QByteArray encrypt(const QByteArray &in)` |
| 17 | `static QByteArray descrypt(const QByteArray &in)` |

**Private methods (header):**

| Line | Signature |
|------|-----------|
| 20 | `bool enableMtp()` |
| 21 | `QByteArray aes(const QByteArray &in, bool encrypt)` |

**Private static data members:**

| Line | Name | Type |
|------|------|------|
| 22 | `m_mtpEnabled` | `static bool` |

**Types, enums, constants defined:** None in header. The `.cpp` defines two non-standard preprocessor macros:
- `AF_ALG 38` (line 10)
- `SOL_ALG 279` (line 13)

**Signals / Slots:** None. `AesCrypto` does not inherit from `QObject`.

**Existing comments:**

- Lines 11–15: Block comment above `encrypt` stating that only some segments are encrypted rather than the whole file, for performance reasons.

---

### `platform/blecentral.h` / `platform/blecentral.cpp`

**Classes:**

1. `EM070::CharacteristicInfo` (inner helper, inherits `QObject`)
2. `EM070::DescriptorInfo` (inner helper, inherits `QObject`)
3. `EM070::BleCentral` (main class, inherits `QObject`)

**`CharacteristicInfo` — public methods (header):**

| Line | Signature |
|------|-----------|
| 17–18 | Constructor: `CharacteristicInfo(const QLowEnergyCharacteristic &, QLowEnergyService *parent)` |
| 20 | `QBluetoothUuid uuid() const` |
| 21 | `bool isReadable() const` |
| 22 | `bool isWritable() const` |
| 23 | `const QLowEnergyCharacteristic &characteristic() const` |
| 24 | `QLowEnergyService *parentService() const` |

**`DescriptorInfo` — public methods (header):**

| Line | Signature |
|------|-----------|
| 34–35 | Constructor: `DescriptorInfo(const QLowEnergyDescriptor &, CharacteristicInfo *parent)` |
| 37 | `QBluetoothUuid uuid() const` |
| 38 | `const QLowEnergyDescriptor &descriptor() const` |
| 39 | `const CharacteristicInfo *parentInfo() const` |

**`BleCentral` — public methods (header):**

| Line | Signature |
|------|-----------|
| 51 | `explicit BleCentral(QObject *parent = nullptr)` |
| 52 | `~BleCentral()` |
| 54 | `void setEnabled(bool enable)` |
| 56 | `void setPeripheralAddress(const quint64 &address)` |
| 57 | `void setAuthorizationCode(const quint128 &uuid, const QByteArray &code)` |
| 59 | `State state() const` |
| 61 | `QByteArrayList servicesUuid() const` |
| 62 | `QByteArrayList characteristicsUuid() const` |
| 63 | `QByteArrayList descriptionsUuid() const` |
| 65 | `bool readCharacteristic(const quint128 &uuid)` |
| 66 | `bool writeCharacteristic(const quint128 &uuid, const QByteArray &ba)` |
| 67 | `bool readDescriptor(const quint128 &uuid)` |
| 68 | `bool writeDescriptor(const quint128 &uuid, const QByteArray &ba)` |

**`BleCentral` — enum:**

| Line | Name | Values |
|------|------|--------|
| 49 | `State` | `Disabled`, `Discovering`, `Ready` |

**`BleCentral` — signals:**

| Line | Signature |
|------|-----------|
| 71 | `void accessible(bool yes)` |
| 74 | `void error(QBluetoothDeviceDiscoveryAgent::Error newError)` |
| 77 | `void error(QLowEnergyController::Error newError)` |
| 80 | `void error(QLowEnergyService::ServiceError newError)` |
| 81 | `void characteristicChanged(const quint128 &uuid, const QByteArray &newValue)` |
| 82 | `void characteristicRead(const quint128 &uuid, const QByteArray &value)` |
| 83 | `void characteristicWritten(const quint128 &uuid, const QByteArray &newValue)` |
| 84 | `void descriptorRead(const quint128 &uuid, const QByteArray &value)` |
| 85 | `void descriptorWritten(const quint128 &uuid, const QByteArray &newValue)` |

**Existing comments in header:**

- Lines 73, 76, 79: Category comments (`// for QBluetoothDeviceDiscoveryAgent`, `// for QLowEnergyController`, `// for QLowEnergyService`) group the overloaded `error` signals. These are organisational, not doc comments.

**Macros defined in `.cpp`:**

| Line | Name | Value |
|------|------|-------|
| 7 | `DISCOVERY_RETRY_WAIT` | `3000` |
| 8 | `RECONNECT_RETRY_WAIT` | `2000` |
| 9 | `WAIT_FOR_CONNECTED` | `10000` |
| 10 | `WAIT_FOR_READY` | `30000` |

---

## Findings

**A12-1** · HIGH · No documentation on `AesCrypto::encrypt`

**Description:** The public static method `encrypt` (aescrypto.h line 16) is the primary encryption entry point for the `AesCrypto` class. No doc comment exists directly above its declaration. The only comment present (lines 11–15) is a general design note explaining *why* partial encryption is used; it does not describe the method contract: what the input format/size constraints are, what the return value represents on failure (an empty `QByteArray`), that the method is a no-op on non-ARM builds, that it is backed by CBC-AES using a fixed IV, or any thread-safety considerations. For a security-critical API this is a significant documentation gap.

**Fix:** Add a doc comment immediately above the declaration that describes: (1) the input data format and any size/alignment requirements; (2) that the method returns an empty `QByteArray` on failure (including on non-ARM platforms); (3) that encryption uses CBC-AES with a hardware-managed key via the AF_ALG kernel interface; (4) that a fixed IV is employed (with a cross-reference to the security implications of IV reuse); (5) thread-safety guarantees or lack thereof (the static `m_mtpEnabled` flag is not protected).

---

**A12-2** · HIGH · No documentation on `AesCrypto::descrypt`

**Description:** The public static method `descrypt` (aescrypto.h line 17) has no doc comment at all. The same concerns as A12-1 apply. Additionally, the method name itself is a misspelling of "decrypt", which makes the API harder to use correctly without documentation. There is nothing to alert callers that calling `descrypt` on data that was not produced by `encrypt` will silently return garbage output rather than an error.

**Fix:** Add a doc comment above the declaration describing: (1) the expected input (output of `encrypt`); (2) failure return value; (3) platform restriction; (4) the IV reuse note. Also consider renaming the method to `decrypt` in a future API cleanup (though that is a separate issue).

---

**A12-3** · MEDIUM · Existing comment on `AesCrypto::encrypt` is inaccurate / misleading

**Description:** The block comment at lines 11–15 of aescrypto.h states:

> "Normally, don't need to encrypt the whole file in case file has big size, as which costs much time and memory, choose some segments to encrypt is sufficient for secure purpose"

This comment is misleading for three reasons. First, it implies the method encrypts only a subset ("some segments") of the input, but the implementation in aescrypto.cpp lines 131–141 processes the entire input buffer in 1024-byte chunks — the whole input is encrypted. Second, the comment was apparently written for a different design and retained in error. Third, it sits above both `encrypt` and `descrypt` without being tied to either, creating ambiguity. A reader trusting this comment could incorrectly assume the ciphertext covers only partial plaintext.

**Fix:** Remove or replace this comment with accurate documentation for both methods as described in A12-1 and A12-2.

---

**A12-4** · LOW · No documentation on `BleCentral::setAuthorizationCode`

**Description:** `setAuthorizationCode` (blecentral.h line 57) is a non-trivial security-relevant method that stores a UUID and a byte-array credential used to authenticate to the BLE peripheral (see blecentral.cpp line 274–275, where the stored `m_authCode` is automatically written to the characteristic matching `m_authUuid` during service discovery). No doc comment explains: (1) the intended call sequence relative to `setEnabled`; (2) whether the code is written in plaintext over the BLE link; (3) what happens if called while the device is already connected (the new values are stored but the write to the peripheral does not re-trigger until the next reconnect).

**Fix:** Add a comment above the declaration describing the parameter semantics, the automatic write-on-discovery behaviour, and any security implications of transmitting the code over an unencrypted BLE channel.

---

**A12-5** · LOW · No documentation on `BleCentral::setEnabled`

**Description:** `setEnabled` (blecentral.h line 54) controls the entire BLE lifecycle: when `true` it starts device discovery and begins a connection attempt chain; when `false` it stops all timers, halts discovery, and disconnects the controller. The method is idempotent (repeated calls with the same value are no-ops). None of this is documented. The side effects on internal state machine transitions are non-obvious to a caller.

**Fix:** Add a comment above the declaration describing the state transitions triggered, the idempotency guarantee, and that disabling resets the device to the `Disabled` state emitting `accessible(false)`.

---

**A12-6** · LOW · No documentation on `BleCentral::setPeripheralAddress`

**Description:** `setPeripheralAddress` (blecentral.h line 56) accepts a `quint64` raw address. No comment documents: (1) the expected byte order or encoding; (2) that passing a null address is silently ignored; (3) that passing a different address while connected causes an implicit disable/re-enable cycle that drops the existing connection.

**Fix:** Add a comment describing address format expectations, null-address behaviour, and the implicit reconnect side effect.

---

**A12-7** · LOW · No documentation on `BleCentral::readCharacteristic` / `writeCharacteristic` / `readDescriptor` / `writeDescriptor`

**Description:** The four GATT I/O methods (blecentral.h lines 65–68) return `bool` to indicate whether the operation was submitted, but there is no documentation stating: (1) that `false` can mean the UUID was not found, the characteristic is not readable/writable, or the parent service is unavailable; (2) that the actual data is returned asynchronously via the corresponding signal rather than as a return value; (3) that the UUID parameter must be a 128-bit GATT UUID in the same byte order used by Qt's `QLowEnergyCharacteristic::uuid().toUInt128()`.

**Fix:** Add a doc comment to each method describing the `false` failure cases and the asynchronous result delivery via signals.

---

**A12-8** · LOW · No documentation on `BleCentral::accessible` signal

**Description:** The `accessible(bool yes)` signal (blecentral.h line 71) is the primary connectivity status signal for consumers of `BleCentral`. No comment explains: when `true` is emitted (after all services and characteristics are discovered, line 291); that `false` is emitted both on disable and on disconnect; or that it may fire multiple times with `false` during a discovery/reconnect cycle.

**Fix:** Add a comment above the signal declaration explaining both the `true` and `false` emission conditions.

---

**A12-9** · INFO · No documentation on `CharacteristicInfo` and `DescriptorInfo` helper classes

**Description:** `CharacteristicInfo` and `DescriptorInfo` (blecentral.h lines 13–43) are thin wrapper classes with no class-level comment explaining their purpose or ownership model. Their public accessor methods (`uuid`, `isReadable`, `isWritable`, `characteristic`, `descriptor`, `parentService`, `parentInfo`) are all simple one-liners and individually undocumented, though their names are reasonably self-explanatory.

**Fix:** Add a brief class-level comment to each wrapper class explaining that they are cache objects built during service discovery and owned by the `BleCentral` instance. Individual accessor documentation is not strictly required given the clarity of the names, but a note on ownership (parent is the associated `QLowEnergyService` or `CharacteristicInfo`) would be helpful.

---

**A12-10** · INFO · No documentation on `BleCentral::State` enum values

**Description:** The `State` enum (blecentral.h line 49) has three values — `Disabled`, `Discovering`, `Ready` — with no comment on each value's semantics or the valid transition order. While the names are readable in isolation, it is not clear from the header alone that `Discovering` covers both the device-scan phase and the GATT service-discovery phase, or that `Ready` means all services and characteristics have been enumerated and `accessible(true)` has been emitted.

**Fix:** Add inline comments or a preceding block comment on the enum clarifying each state's meaning and valid transitions.

---

## Summary Table

| ID | Severity | Location | Title |
|----|----------|----------|-------|
| A12-1 | HIGH | aescrypto.h:16 | No documentation on `AesCrypto::encrypt` |
| A12-2 | HIGH | aescrypto.h:17 | No documentation on `AesCrypto::descrypt` |
| A12-3 | MEDIUM | aescrypto.h:11–15 | Existing comment is inaccurate — implies partial encryption but full input is encrypted |
| A12-4 | LOW | blecentral.h:57 | No documentation on `BleCentral::setAuthorizationCode` |
| A12-5 | LOW | blecentral.h:54 | No documentation on `BleCentral::setEnabled` |
| A12-6 | LOW | blecentral.h:56 | No documentation on `BleCentral::setPeripheralAddress` |
| A12-7 | LOW | blecentral.h:65–68 | No documentation on GATT I/O methods (readCharacteristic, writeCharacteristic, readDescriptor, writeDescriptor) |
| A12-8 | LOW | blecentral.h:71 | No documentation on `accessible` signal emission conditions |
| A12-9 | INFO | blecentral.h:13–43 | No class-level comment on `CharacteristicInfo` / `DescriptorInfo` helper classes |
| A12-10 | INFO | blecentral.h:49 | No documentation on `BleCentral::State` enum values |

**Totals:** 2 HIGH, 1 MEDIUM, 4 LOW, 2 INFO
# Pass 3 Agent A13 — Documentation

**Audit run:** 2026-02-28-01
**Branch:** master
**Files reviewed:**
- `platform/canbus.h` (80 lines)
- `platform/canbus.cpp` (295 lines)
- `platform/gnssreceiver.h` (93 lines)
- `platform/gnssreceiver.cpp` (455 lines)

---

## Reading Evidence

### canbus.h / canbus.cpp

**Class:** `EM070::CanBus` (inherits `QObject`)

**Enum defined:**

| Name | Line (header) | Values |
|------|--------------|--------|
| `CanDeviceId` | 16 | `CAN2 = 0`, `CAN1 = 1` |

**Struct defined:**

| Name | Line (header) | Fields |
|------|--------------|--------|
| `Request` | 18–23 | `QCanBusFrame frame`, `quint32 interval`, `qint32 timer` |

**Public methods — header line numbers:**

| Line | Declaration |
|------|-------------|
| 25 | `explicit CanBus(CanDeviceId id = CAN1, QObject *parent = nullptr)` |
| 26 | `~CanBus()` |
| 28 | `void initialize()` |
| 30 | `void setXferEnabled(bool enable)` |
| 31 | `bool isXferEnabled() const` (inline) |
| 33 | `void setPower(bool on)` |
| 34 | `bool isEnabled() const` (inline) |
| 36 | `bool setBaudRate(int baudRate)` |
| 37 | `int baudRate() const` (inline) |
| 39 | `void addRequest(quint32 id, const QByteArray &ba, quint32 interval)` |
| 40 | `QList<Request> getRequests()` (inline) |
| 41 | `void clearRequests()` |
| 43 | `void addFilter(quint32 identifier)` |
| 44 | `void clearFilters()` |
| 45 | `void applyFilters()` |
| 47 | `void writeFrameDirect(quint32 id, const QByteArray &ba)` |
| 49 | `void removeRequests(quint32 id)` |

**Protected methods:**

| Line | Declaration |
|------|-------------|
| 58 | `void sendRequest()` |

**Signals:**

| Line | Name | Signature |
|------|------|-----------|
| 54 | `error` | `void error(QCanBusDevice::CanBusError canBusError)` |
| 55 | `read` | `void read(quint32 identifier, const QByteArray &ba)` |

**Macro constants (canbus.cpp):**

| Name | Value | Meaning |
|------|-------|---------|
| `REQUEST_TIMER` | 100 | Timer interval in ms between CAN send attempts |
| `CANBUS_DEBUG` | 0 | Debug logging toggle (compile-time) |

---

### gnssreceiver.h / gnssreceiver.cpp

**Class:** `EM070::GnssReceiver` (inherits `QObject`)

**Macro constant (header):**

| Name | Value | Meaning |
|------|-------|---------|
| `MAX_POINTS` | 8 | Maximum number of GPS path waypoints stored |

**Macro constants (gnssreceiver.cpp):**

| Name | Value | Meaning |
|------|-------|---------|
| `FILE_GNSS_PORT` | `/dev/ttyUSB1` | Default serial port for GNSS on ARM |
| `EARTH_R` | 6371000UL | Earth radius in metres |

**Public methods — header line numbers:**

| Line | Declaration |
|------|-------------|
| 17 | `explicit GnssReceiver(QObject *parent = nullptr)` |
| 18 | `void portStateChanged(bool open)` |
| 19 | `void reset()` |
| 20 | `void changeUpdateTime()` |
| 22 | `quint8 satelliteCount() const` (inline) |
| 23 | `qint32 latitude() const` (inline) |
| 24 | `qint32 longitude() const` (inline) |
| 25 | `qint32 lastLatitude() const` (inline) |
| 26 | `qint32 lastLongitude() const` (inline) |
| 27 | `qint16 speed() const` (inline) |
| 28 | `qint16 course() const` (inline) |
| 29 | `quint32 distance() const` (inline) |
| 30 | `quint32 sumOfDistance() const` (inline) |
| 31 | `quint32 altitude() const` (inline) |
| 32 | `bool locked() const` (inline) |
| 33 | `quint32 hpe() const` (inline, with embedded comment) |
| 34 | `quint32 hdop() const` (inline) |
| 35 | `qint64 age()` |
| 36 | `quint8 warn() const` (inline) |
| 37 | `void setWarn(quint8 n)` (inline) |
| 38 | `quint8 quality() const` (inline) |
| 39 | `void setQuality(quint8 n)` (inline) |
| 40 | `quint16 markerCnt() const` (inline) |
| 41 | `void setMarkerCnt(quint16 n)` (inline) |
| 42 | `quint32 pathLatitude(int n)` |
| 43 | `void setPathLatitude(int n, quint32 lat)` |
| 44 | `quint32 pathLongitude(int n)` |
| 45 | `void setPathLongitude(int n, quint32 lon)` |
| 46 | `void gpsDebugPrint()` |
| 47 | `bool inPoly2(const CIGCONF::gpsPosStruct *gpsPos, const CIGCONF::polygonStruct *polygon)` |
| 48 | `bool pointInPolygon(int polyCorners, CIGCONF::position me, CIGCONF::position *points)` |
| 49 | `double degrees2radians(double degrees)` |

**Protected methods:**

| Line | Declaration |
|------|-------------|
| 51 | `void timerEvent(QTimerEvent *)` |

**Signals:**

| Line | Name | Signature |
|------|------|-----------|
| 54 | `sendGmtpMessage` | `void sendGmtpMessage(CIGCONF::GmtpMessage msg, const QByteArray &extra = QByteArray())` |

---

## Documentation Audit

### Documentation present per method

The following table records whether any doc comment exists above each public declaration in the header, and whether it is accurate.

#### CanBus (canbus.h)

| Method | Has Doc Comment | Comment Text / Location | Accurate? | Params/Return Described? |
|--------|----------------|------------------------|-----------|--------------------------|
| `CanBus()` constructor | Inline only — `// if m_canBusDevice allocated in constructor, it can't moveToThread` is on `initialize()`, not the constructor | No comment on constructor itself | N/A | No |
| `~CanBus()` | No | — | N/A | No |
| `initialize()` | Partial — inline trailing comment `// if m_canBusDevice allocated in constructor, it can't moveToThread` | Partially accurate (explains the deferred-allocation design decision) but is a single trailing remark, not a proper doc comment; does not describe behaviour on second call (idempotent) | Partially | No |
| `setXferEnabled(bool)` | No | — | N/A | No |
| `isXferEnabled() const` | No | — | N/A | No |
| `setPower(bool on)` | No | — | N/A | No |
| `isEnabled() const` | No | — | N/A | No |
| `setBaudRate(int)` | No | — | N/A | No |
| `baudRate() const` | No | — | N/A | No |
| `addRequest(quint32, QByteArray&, quint32)` | No | — | N/A | No |
| `getRequests()` | No | — | N/A | No |
| `clearRequests()` | No | — | N/A | No |
| `addFilter(quint32)` | No | — | N/A | No |
| `clearFilters()` | No | — | N/A | No |
| `applyFilters()` | No | — | N/A | No |
| `writeFrameDirect(quint32, QByteArray&)` | No | — | N/A | No |
| `removeRequests(quint32)` | No | — | N/A | No |
| `sendRequest()` (protected) | No | — | N/A | No |
| Signal: `error` | No | — | N/A | No |
| Signal: `read` | No | — | N/A | No |

#### GnssReceiver (gnssreceiver.h)

| Method | Has Doc Comment | Comment Text / Location | Accurate? | Params/Return Described? |
|--------|----------------|------------------------|-----------|--------------------------|
| `GnssReceiver()` constructor | No | — | N/A | No |
| `portStateChanged(bool)` | No | — | N/A | No |
| `reset()` | No | — | N/A | No |
| `changeUpdateTime()` | No | — | N/A | No |
| `satelliteCount()` through `locked()` (8 simple getters) | No | — | N/A | No |
| `hpe()` | Inline trailing comment: `// Convert HDOP to 68% (1 stddev) accuracy. LE910C1 accuracy is 0.8m.` | Present and accurate for the formula intent, but inaccurate about the units returned (returns a `quint32` expressing metres, not described). The formula `m_hdop*0.8/(2.0*100.0)` produces a value in metres CEP but the `qRound` and integer cast suppress fractional precision — this is not mentioned. | Partially accurate | No — return unit not stated |
| `hdop()` | Private field comment `// (0.5~99.9) * 100` is on the member variable, not the accessor | Explains the encoding scale but is on the data member, not the getter declaration | N/A | No |
| `age()` | No | — | N/A | No |
| `warn()` / `setWarn()` | No | — | N/A | No |
| `quality()` / `setQuality()` | No | — | N/A | No |
| `markerCnt()` / `setMarkerCnt()` | No | — | N/A | No |
| `pathLatitude(int n)` | `/** @brief GnssReceiver::pathLatitude @param n @return */` (in .cpp, lines 365–368) | Stub-only: `@param n` and `@return` have no descriptions whatsoever | Not useful | No — param and return are blank |
| `setPathLatitude(int n, quint32 lat)` | `/** @brief GnssReceiver::setPathLatitude @param n @param lat */` (in .cpp, lines 376–379) | Stub-only | Not useful | No |
| `pathLongitude(int n)` | `/** @brief GnssReceiver::pathLongitude @param n @return */` (in .cpp, lines 386–389) | Stub-only | Not useful | No |
| `setPathLongitude(int n, quint32 lon)` | `/** @brief GnssReceiver::setPathLongitude @param n @param lon */` (in .cpp, lines 397–400) | Stub-only | Not useful | No |
| `gpsDebugPrint()` | `/** @brief GnssReceiver::gpsDebugPrint */` (in .cpp, line 407–408) | Stub-only | Not useful | No |
| `inPoly2(...)` | No | — | N/A — **no implementation exists** | No |
| `pointInPolygon(...)` | No | — | N/A | No |
| `degrees2radians(double)` | No | — | N/A | No |
| Signal: `sendGmtpMessage` | No | — | N/A | No |

---

## Findings

**A13-1** · INFO · No doc comments on any `CanBus` public methods
**Description:** The `CanBus` class (platform/canbus.h) has 17 public methods, one protected method, and two signals. None has any form of doc comment. The only comment present is a single trailing inline remark on `initialize()` (`// if m_canBusDevice allocated in constructor, it can't moveToThread`) which explains an implementation constraint but does not describe the method's contract. For simple getters (`isXferEnabled`, `isEnabled`, `baudRate`) the absence of comments is a minor issue.
**Fix:** Add at minimum a one-line description above each non-trivial public method. Getters may remain undocumented if their names are fully self-explaining.

---

**A13-2** · LOW · Missing doc comment on `CanBus::initialize()`
**Description:** `initialize()` has a non-trivial contract: it must be called after construction (before the object is moved to a thread), it is idempotent (silently returns if `m_canBusDevice` is already allocated), and failure to call it leaves the bus permanently inoperative. None of this is documented. The single trailing inline comment explains only the threading constraint. Callers have no indication that the method is idempotent or that omitting it is a silent failure.
**Fix:** Add a doc comment above the declaration in canbus.h explaining: (1) that it must be called before use, (2) that it is idempotent, and (3) what happens on device creation failure.

---

**A13-3** · LOW · Missing doc comment on `CanBus::setPower(bool)`
**Description:** `setPower` performs several non-obvious side effects: it silently forces `on = false` when `m_baudRate <= 0`; it executes `ifconfig` and a proprietary `ip link` command via `QProcess`, writing to two GPIO sysfs paths; and it connects or disconnects the `QCanBusDevice`. None of this is documented. A caller who passes `true` without first calling `setBaudRate` will not achieve the expected result and will receive no error.
**Fix:** Document the pre-condition (baud rate must be set), the side-effect of bringing the network interface up/down, and the GPIO pin manipulation.

---

**A13-4** · LOW · Missing doc comment on `CanBus::applyFilters()`
**Description:** `applyFilters()` silently does nothing when `m_canBusDevice` is null. It also deduplicates filter IDs internally, which is a meaningful behaviour callers should know about. Additionally, it inspects bit 29 of the identifier to determine whether to apply an extended-format filter with a different mask (`0x3ffff00`) versus a base-format filter (`0x3ff`). This bit-field protocol is not documented anywhere in the header.
**Fix:** Document the null-device early return, the deduplication, and the bit-29 convention for extended-frame identifiers.

---

**A13-5** · LOW · Missing doc comment on `CanBus::addRequest()`
**Description:** `addRequest` silently auto-detects extended frame format (sets extended format if `id > 0x7ff`). The `interval` parameter is in milliseconds (governed by `REQUEST_TIMER = 100 ms`), but this is not stated. Setting `interval = 0` is a valid way to enqueue a one-shot frame (the scheduler only counts down when `request.interval != 0`), but this is undocumented.
**Fix:** Document the auto-detection of extended frame format, the unit of `interval`, and the meaning of `interval = 0`.

---

**A13-6** · LOW · Missing doc comment on `CanBus::writeFrameDirect()`
**Description:** `writeFrameDirect` bypasses the request queue and sends immediately, but only when `m_xferEnabled` is true. If `m_xferEnabled` is false the frame is silently discarded with no error or return value. This silent discard on a write call is a significant contract detail that is completely undocumented.
**Fix:** Document that the method is a direct (queue-bypassing) write, that it silently discards the frame if transfer is disabled, and that no error is reported.

---

**A13-7** · INFO · `CanBus` signal names are ambiguous — no doc comments
**Description:** The signal `read(quint32 identifier, const QByteArray &ba)` uses the name `read`, which shadows the common Qt/C++ concept of a read operation but gives no indication of what triggered it (frame received from bus). The signal `error(QCanBusDevice::CanBusError)` is similarly bare. Neither signal has a doc comment. While the parameter types partially convey meaning, the rate-limiting behaviour in `handleError` (suppresses repeated reports within 10 seconds) is invisible to slots connected to `error`.
**Fix:** Add doc comments to both signals describing when they are emitted and, for `error`, noting the 10-second suppression window.

---

**A13-8** · LOW · Missing doc comment on `GnssReceiver::portStateChanged(bool)`
**Description:** `portStateChanged` is the primary lifecycle method that opens/closes the serial port and starts/stops the internal timer. When `open = true` it opens the port, clears buffers, and starts a timer whose period comes from `gCfg->gpsUpdateTime()`. When `open = false` it closes the port and stops the timer. None of this is documented, including the dependency on the global config object.
**Fix:** Document both branches, the timer start/stop behaviour, and the dependency on `gCfg->gpsUpdateTime()`.

---

**A13-9** · LOW · Missing doc comment on `GnssReceiver::changeUpdateTime()`
**Description:** `changeUpdateTime()` kills the existing timer but contains a commented-out line that would restart it with the new period (`//m_timerId = startTimer(gCfg->gpsUpdateTime() * 1000)`). The method therefore currently does nothing useful beyond stopping updates permanently. This silent, incomplete behaviour is not documented at all. A caller invoking this method to change the update rate will inadvertently stop GPS reporting entirely.
**Fix:** At minimum document the current (broken) behaviour. The commented-out restart line should be either restored or removed, and the method's intent should be stated clearly.

---

**A13-10** · LOW · Missing doc comment on `GnssReceiver::reset()`
**Description:** `reset()` zeroes all position, speed, distance, and state fields. It is called from the constructor and may be called externally to reinitialise the receiver mid-operation. The scope of what is reset — notably that `m_positionValid`, `m_satelliteCount`, and `m_locked` are all cleared — is not documented. Callers need to know this will trigger the "location acquired" log path again on next valid fix.
**Fix:** Document that `reset()` clears all accumulated position and distance data and that `m_positionValid` is set to false, which will cause a new "location acquired" event to be emitted.

---

**A13-11** · MEDIUM · Stub-only Doxygen comments on `pathLatitude`, `pathLongitude`, `setPathLatitude`, `setPathLongitude`, `gpsDebugPrint` give no information
**Description:** Five methods in gnssreceiver.cpp have `/** @brief ... @param n @return */` Doxygen blocks where every tag is present but contains no text. Examples:
```cpp
/**
 * @brief GnssReceiver::pathLatitude
 * @param n
 * @return
 */
```
These comments are syntactically valid Doxygen but are informationally empty — they are worse than no comment because they create the false appearance of documentation. For `pathLatitude(int n)` and `pathLongitude(int n)` there is a meaningful bound check (`if((n < MAX_POINTS) && (n > -1))`) and an out-of-range fallback return of `0` that is not described. For the setter variants, writing to an out-of-range index is silently ignored, which is also not described.
**Fix:** Fill in the `@brief`, `@param`, and `@return` fields with real content. For `pathLatitude`/`pathLongitude`, document the valid range of `n` (0 to `MAX_POINTS - 1`) and the `0` return on out-of-range. For setters, document the silent no-op on out-of-range input.

---

**A13-12** · MEDIUM · `GnssReceiver::hpe()` inline comment is partially inaccurate
**Description:** The inline comment on `hpe()` (gnssreceiver.h, line 33) reads:
```cpp
// Convert HDOP to 68% (1 stddev) accuracy. LE910C1 accuracy is 0.8m.
```
The formula is `qRound((double)m_hdop * 0.8 / (2.0 * 100.0))`. `m_hdop` is stored as HDOP × 100 (per the member variable comment `// (0.5~99.9) * 100`), so the actual computation is `HDOP × 0.8 / 2.0` metres, rounded to the nearest integer metre. The comment says "68% (1 stddev)" but the divisor of 2 in the formula corresponds to 50th-percentile CEP, not 68th-percentile (1σ). The two conventions differ by approximately 1.2×. The comment therefore misrepresents the statistical confidence level of the output. Additionally, the return unit (metres, integer) is not stated.
**Fix:** Correct the statistical claim: the divisor of 2.0 yields a CEP (50th percentile) estimate, not 1σ (68%). If 68% accuracy is intended, the divisor should be approximately 1.67. State the return unit (integer metres).

---

**A13-13** · HIGH · `GnssReceiver::inPoly2()` is declared but has no implementation and no documentation
**Description:** `inPoly2(const CIGCONF::gpsPosStruct *gpsPos, const CIGCONF::polygonStruct *polygon)` is declared as a public method in gnssreceiver.h (line 47) but has no corresponding definition anywhere in the codebase. A search of the entire repository confirms only the single declaration. Any translation unit that calls this method will produce an unresolved-symbol linker error. The method name suggests it is a geofence point-in-polygon test — directly safety-critical for fleet tracking. There is no doc comment, no rationale, and no indication of whether this is intentionally stubbed, accidentally omitted, or a dead placeholder.
**Fix:** Either (1) provide a correct implementation with full documentation of parameters and return value, or (2) remove the declaration if the method is no longer intended. Do not leave an unimplemented safety-critical function silently in a public API.

---

**A13-14** · LOW · Missing doc comment on `GnssReceiver::pointInPolygon()`
**Description:** `pointInPolygon` implements a ray-casting (Jordan curve) algorithm to determine whether a GPS coordinate is inside a polygon. This is a security- and safety-relevant method (geofence enforcement). The algorithm has a known edge-case limitation: points exactly on a polygon edge can produce unpredictable results. There is a single inline comment `//oddNodes = 1 means within the polygon, oddNodes = 0 outside the polygon.` inside the function body, but no doc comment above the declaration in the header. The coordinate system (radian-space, not degree-space), parameter ownership of `points`, and the edge-case behaviour are not documented.
**Fix:** Add a doc comment above the declaration describing: the algorithm (ray-casting), the coordinate space expected (radian-space `latrad`/`lonrad` fields of `CIGCONF::position`), the edge-case limitation, and the meaning of the return value.

---

**A13-15** · LOW · Missing doc comment on `GnssReceiver::degrees2radians()`
**Description:** `degrees2radians` is a simple utility function but its presence in the public interface of a `QObject` subclass without any documentation means callers have no indication of expected input range or precision. It is trivially self-evident, so this is low severity.
**Fix:** Either move it to a private or static utility scope, or add a minimal one-line doc comment.

---

**A13-16** · LOW · Missing doc comment on `GnssReceiver::age()`
**Description:** `age()` returns the time in milliseconds since the last valid NMEA sentence was parsed, computed from `QDateTime::currentMSecsSinceEpoch() - m_timestamp`. The return value is clamped to `0` for negative results (which would occur before the first fix). The unit (milliseconds) is not stated, the clamping behaviour is not documented, and the initial state (`m_timestamp` is uninitialised in the reset path — `reset()` does not zero `m_timestamp`) is not addressed.
**Fix:** Document the return unit (milliseconds), the zero-clamp for pre-first-fix state, and note that `m_timestamp` is not reset by `reset()`.

---

**A13-17** · MEDIUM · `GnssReceiver::age()` — `m_timestamp` not initialised by `reset()`, undocumented
**Description:** `reset()` (gnssreceiver.cpp, lines 192–210) zeroes all position and state fields but does not initialise `m_timestamp`. `m_timestamp` is first set during `parseData` when a valid GPRMC sentence is received (line 168). If `age()` is called before the first valid fix, `m_timestamp` contains an uninitialised or stale value, causing `age()` to return an arbitrary large number (which is then clamped to 0 only if negative). This is a documentation deficiency compounded by a latent bug: the negative-clamp guard protects against future timestamps but not against a very large stale positive value that would make the data appear fresh when it is not. Neither the initialisation gap nor the clamping logic is documented.
**Fix:** Document that `age()` is unreliable before the first valid fix, and separately fix the initialisation by setting `m_timestamp = 0` in `reset()` and updating the clamp condition to also handle the zero case.

---

## Summary Table

| ID | Severity | Title | Location |
|----|----------|-------|----------|
| A13-1 | INFO | No doc comments on any `CanBus` public methods | `platform/canbus.h` (all public methods) |
| A13-2 | LOW | Missing doc comment on `CanBus::initialize()` | `platform/canbus.h:28` |
| A13-3 | LOW | Missing doc comment on `CanBus::setPower()` | `platform/canbus.h:33` |
| A13-4 | LOW | Missing doc comment on `CanBus::applyFilters()` | `platform/canbus.h:45` |
| A13-5 | LOW | Missing doc comment on `CanBus::addRequest()` | `platform/canbus.h:39` |
| A13-6 | LOW | Missing doc comment on `CanBus::writeFrameDirect()` | `platform/canbus.h:47` |
| A13-7 | INFO | `CanBus` signals undocumented; `error` suppression window invisible | `platform/canbus.h:54–55` |
| A13-8 | LOW | Missing doc comment on `GnssReceiver::portStateChanged()` | `platform/gnssreceiver.h:18` |
| A13-9 | LOW | Missing doc comment on `GnssReceiver::changeUpdateTime()` — method silently broken | `platform/gnssreceiver.h:20` |
| A13-10 | LOW | Missing doc comment on `GnssReceiver::reset()` | `platform/gnssreceiver.h:19` |
| A13-11 | MEDIUM | Stub-only Doxygen blocks on five methods — informationally empty | `platform/gnssreceiver.cpp:365–408` |
| A13-12 | MEDIUM | `hpe()` comment claims 68% (1σ) accuracy but formula computes CEP (50th pct) | `platform/gnssreceiver.h:33` |
| A13-13 | HIGH | `inPoly2()` declared, no implementation anywhere, no documentation | `platform/gnssreceiver.h:47` |
| A13-14 | LOW | Missing doc comment on safety-critical `pointInPolygon()` | `platform/gnssreceiver.h:48` |
| A13-15 | LOW | Missing doc comment on `degrees2radians()` | `platform/gnssreceiver.h:49` |
| A13-16 | LOW | Missing doc comment on `age()` — unit and clamping undocumented | `platform/gnssreceiver.h:35` |
| A13-17 | MEDIUM | `m_timestamp` not initialised by `reset()`; `age()` unreliable before first fix, undocumented | `platform/gnssreceiver.cpp:192–210`, `448–455` |

**Totals:** 2 HIGH, 3 MEDIUM, 10 LOW, 2 INFO
# Pass 3 Agent A14 — Documentation

**Audit run:** 2026-02-28-01
**Branch:** master
**Files reviewed:**
- `platform/internalrfid.h`
- `platform/internalrfid.cpp`
- `platform/internalrtc.h`
- `platform/internalrtc.cpp`

---

## Reading Evidence

### `platform/internalrfid.h` — Class `EM070::InternalRfid`

**Class:** `EM070::InternalRfid` (inherits `QObject`)

**Public methods:**

| Line | Method | Doc comment present? |
|------|--------|----------------------|
| 14 | `explicit InternalRfid(QObject *parent = 0)` | No |
| 15 | `void setEnabled(bool enabled)` | No |

**Signals:**

| Line | Signal | Doc comment present? |
|------|--------|----------------------|
| 18 | `void response()` | No |
| 19 | `void cardData(quint64 wiegand, quint16 facility, quint32 number, QByteArray &readerOutput)` | No |
| 20 | `void error(const QString &text)` | No |

**Private methods (for implementation reference):**

| Line | Method |
|------|--------|
| 23 | `void readData()` |
| 24 | `void parseData()` |

**Types, enums, constants:** None defined in this header. The `.cpp` file defines:
- `FILE_SERIAL_PORT` — `"/dev/ttyS2"` (macro, line 7)
- `RECEIVER_MAX_SIZE` — `128` (macro, line 8)

---

### `platform/internalrtc.h` — Class `EM070::InternalRtc`

**Class:** `EM070::InternalRtc` (plain class, no QObject)

**Public methods:**

| Line | Method | Doc comment present? |
|------|--------|----------------------|
| 11 | `static void setRtcTime(QDateTime dateTime = QDateTime())` | No |
| 12 | `static void setSystemTime()` | Partial — inline comment only: `// no need to call this as which will be done on OS booting` |
| 13 | `static quint64 euiAddress()` | No |

**Signals/Slots:** None — class does not inherit QObject.

**Types, enums, constants:** None defined in this header. The `.cpp` file defines:
- `FILE_RTC_DEVICE` — `"/dev/rtc1"` (macro, line 5)
- `FILE_RTC_EUI` — `"/sys/devices/platform/nuc970-i2c0/i2c-0/0-006f/eui"` (macro, line 6)

---

## Documentation Findings

---

**A14-1** · HIGH · No documentation on `InternalRfid` constructor

**Description:** The constructor `InternalRfid(QObject *parent)` has no doc comment of any kind. The implementation is non-trivial: it reads the environment variable `QT_RFID_SERIAL_PORT` to optionally override the default serial port, configures the serial port at 115200 8N1, opens it for read/write, and connects the `readyRead` signal to the internal `readData` slot. The override mechanism via `QT_RFID_SERIAL_PORT` is particularly important for testing and deployment but is completely undocumented. Callers have no indication of what happens on construction failure (the port failing to open is silently swallowed after a `qCritical` log), nor that a post-construction check on port state may be necessary before relying on RFID reads.

**Fix:** Add a doc comment above the declaration explaining: (a) that the constructor opens and configures the serial port, (b) that the port name can be overridden via the `QT_RFID_SERIAL_PORT` environment variable, and (c) that if the port fails to open the object remains partially constructed and no signals will be emitted.

---

**A14-2** · HIGH · No documentation on `setEnabled(bool enabled)`

**Description:** `setEnabled` is the sole control surface for enabling or disabling RFID card reads. It transmits the AT command `AT+LFID=ON` or `AT+LFID=OFF` to the EM070 hardware module. There is no doc comment describing the parameter, the effect, the AT command protocol used, or the silent no-op behaviour when the serial port is not open. In an authentication system, enabling/disabling the RFID reader is a security-critical operation; an undocumented no-op when the port is closed could lead a caller to believe RFID is disabled when it is not (or vice versa).

**Fix:** Add a doc comment describing: (a) that `true` sends `AT+LFID=ON` and `false` sends `AT+LFID=OFF`, (b) that the method silently does nothing if the serial port is not open, and (c) the 10 ms blocking write wait.

---

**A14-3** · HIGH · No documentation on `cardData` signal

**Description:** `cardData(quint64 wiegand, quint16 facility, quint32 number, QByteArray &readerOutput)` is the primary signal carrying authenticated card identity information. It is emitted with different semantics depending on which card format was parsed:
- For `#6:` (26-bit Wiegand): `facility` is 8-bit (read into `quint8`, then widened), `number` is 16-bit.
- For `#8:` (34-bit Wiegand): `facility` is 16-bit, `number` is 16-bit (note: parsed into `quint32` but only 4 hex digits are read).
- For `#R:` raw Wiegand: `facility` and `number` are both 0; only `wiegand` carries data.
- For any other non-empty line: `wiegand`, `facility`, and `number` are all 0.

None of this is documented. Consumers of this signal cannot reliably distinguish these cases from the signal signature alone, which is a correctness and security risk.

**Fix:** Add a doc comment to the signal declaration in the header describing each parameter, the three distinct emission modes (26-bit, 34-bit, raw), the meaning of zero values for `facility`/`number` in the raw case, and the `readerOutput` parameter content (raw log bytes including `\r\n`).

---

**A14-4** · MEDIUM · No documentation on `response()` signal

**Description:** The `response()` signal is emitted when the string `"OK"` is received from the serial port. There is no doc comment explaining when this signal fires, what it means (acknowledgement of an AT command), or how callers are expected to use it in relation to `setEnabled()`. Without documentation, a caller cannot know whether to wait for this signal after calling `setEnabled()` or whether it serves another purpose.

**Fix:** Add a doc comment clarifying that `response()` is emitted when the hardware module responds with `"OK"`, typically as an acknowledgement of an AT command such as `AT+LFID=ON/OFF`.

---

**A14-5** · MEDIUM · No documentation on `error()` signal

**Description:** The `error(const QString &text)` signal is emitted when a non-empty card data line is received but cannot be successfully parsed (e.g. zero facility or number in a `#6:`/`#8:` record, unparseable hex in a `#R:` record). The `text` parameter carries the raw trimmed line from the hardware. There is no documentation describing when the signal fires, what `text` contains, or the distinction between a parse error and a hardware fault. This is relevant to security because repeated `error()` emissions could indicate tampering or a malfunctioning RFID module.

**Fix:** Add a doc comment clarifying that `error()` is emitted on parse failures, that `text` contains the raw hardware response line, and that it is not emitted for serial port I/O errors (those are logged via `qCritical`/`qWarning`).

---

**A14-6** · HIGH · No documentation on `setRtcTime(QDateTime dateTime)`

**Description:** `setRtcTime` performs two distinct privileged operations: (1) on ARM targets it calls `::stime()` to set the POSIX system clock (a privileged syscall), and (2) unconditionally it calls `hwclock -w -f /dev/rtc1` via `QProcess::execute()` to write the hardware RTC. The default parameter (`QDateTime()`) is an invalid `QDateTime`, meaning calling `setRtcTime()` with no argument skips the system clock update but still writes the hardware RTC from the current system time. This default-argument behaviour is subtle and potentially dangerous — a caller passing an invalid datetime does not set the system time yet does write back to the RTC. None of this is documented.

**Fix:** Add a doc comment describing: (a) what `setRtcTime` does with a valid vs. invalid (default) `QDateTime`, (b) that it calls `::stime()` on ARM, (c) that it always runs `hwclock -w` to sync the hardware RTC regardless of whether the datetime argument was valid, and (d) that elevated system privileges are required.

---

**A14-7** · LOW · Inaccurate/incomplete inline comment on `setSystemTime()`

**Description:** The sole documentation for `setSystemTime()` is the inline comment `// no need to call this as which will be done on OS booting`. This comment is grammatically malformed ("as which will be done") and is incomplete: it describes a usage constraint but says nothing about what the method actually does (reads the hardware RTC at `/dev/rtc1` via `hwclock -s` and sets the system clock from it). The comment also does not state whether the method is safe to call manually at runtime or whether calling it outside of boot could cause problems.

**Fix:** Replace the malformed inline comment with a proper doc comment explaining that this method reads `/dev/rtc1` via `hwclock -s` to synchronise the system clock to the hardware RTC, and that it is normally invoked automatically at boot. Clarify whether runtime calls are safe.

---

**A14-8** · HIGH · No documentation on `euiAddress()`

**Description:** `euiAddress()` reads the device's EUI-64 hardware identifier from the sysfs path `/sys/devices/platform/nuc970-i2c0/i2c-0/0-006f/eui`. This value is a globally unique device identity used for authentication and fleet tracking. The method returns `0` on any failure (file not found, read error, or hex parse failure). A return value of `0` is indistinguishable from a genuine parse result of zero and could silently propagate an invalid device identity through the system. There is no documentation on the method, its return value, the failure modes, or the security significance of the result.

**Fix:** Add a doc comment explaining: (a) that the returned value is the device EUI-64 address read from the RTC module via sysfs, (b) that `0` is returned on any failure (file not open, empty or non-hex content), (c) that callers must validate the return value is non-zero before using it for identity purposes, and (d) the sysfs path dependency.

---

## Summary Table

| ID | Severity | File | Subject |
|----|----------|------|---------|
| A14-1 | HIGH | `internalrfid.h:14` | `InternalRfid` constructor undocumented; silent failure mode and env-var override not described |
| A14-2 | HIGH | `internalrfid.h:15` | `setEnabled()` undocumented; silent no-op and AT command protocol not described |
| A14-3 | HIGH | `internalrfid.h:19` | `cardData` signal undocumented; three distinct emission modes with different parameter semantics |
| A14-4 | MEDIUM | `internalrfid.h:18` | `response()` signal undocumented; purpose and relationship to AT commands not described |
| A14-5 | MEDIUM | `internalrfid.h:20` | `error()` signal undocumented; trigger conditions and parameter content not described |
| A14-6 | HIGH | `internalrtc.h:11` | `setRtcTime()` undocumented; privileged syscall, RTC write, and default-argument behaviour not described |
| A14-7 | LOW | `internalrtc.h:12` | `setSystemTime()` has only a grammatically malformed, incomplete inline comment |
| A14-8 | HIGH | `internalrtc.h:13` | `euiAddress()` undocumented; failure returns 0 indistinguishable from valid zero; security-critical identity value |
# Pass 3 Agent A15 — Documentation

**Audit run:** 2026-02-28-01
**Branch:** master
**Files reviewed:**
- `platform/modemport.h`
- `platform/modemport.cpp`
- `platform/powersupply.h`
- `platform/powersupply.cpp`

---

## Reading Evidence

### modemport.h / modemport.cpp

**Class:** `EM070::ModemPort` (extends `QObject`)

**Public methods (header line numbers):**

| Line | Method / Inline definition |
|------|---------------------------|
| 14 | `explicit ModemPort(QObject *parent = nullptr)` |
| 15 | `bool sendCmd(const QByteArray &cmd)` |
| 16 | `void resetModem()` |
| 17 | `void setEnabled(bool enable)` |
| 18 | `void setEcho(bool enable)` (inline) |
| 19 | `bool isWwx()` (inline) |
| 20 | `void setWwx(bool isWwx)` (inline) |

**Signals:**

| Line | Signal |
|------|--------|
| 23 | `void portStateChanged(bool open)` |
| 24 | `void response(bool ok, const QByteArrayList &content)` |

**Private methods:**

| Line | Method |
|------|--------|
| 27 | `void openPort()` |
| 28 | `void portError()` |
| 29 | `void readData()` |
| 30 | `void parseData(const QByteArray &line)` |

**Types / enums / constants:** None defined in the header. The implementation file defines two file-path macros:
- `FILE_MODEM_PORT_WWX` — `/dev/ttyUSB2`
- `FILE_MODEM_PORT` — `/dev/ttyUSB3`

**Doc comments present:** None. There are no `///`, `/**`, or descriptive `//` comments above any public declaration in the header.

---

### powersupply.h / powersupply.cpp

**Class:** `EM070::PowerSupply` (extends `QObject`)

**Enumerations (header lines 16–18):**

| Line | Enum | Values |
|------|------|--------|
| 16 | `BlankMode` | `UnBlank = 0`, `BlankPowerDown = 4` |
| 17 | `ChargeState` | `NotCharging = 0`, `PreCharging = 1`, `FastCharging = 2`, `ChargeDone = 3` |
| 18 | `ChargeFault` | `NoFault = 0`, `InputFault = 1`, `ThermalShutdown = 2`, `ChargeTimerExpired = 3` |

**Public methods (header line numbers):**

| Line | Method / Inline definition |
|------|---------------------------|
| 19 | `explicit PowerSupply(QObject *parent = nullptr)` |
| 21 | `bool isIgnitionOn() const` (inline) |
| 23 | `bool isPowerGood() const` (inline) |
| 24 | `bool isBatteryAvailable() const` (inline) |
| 25 | `ChargeState chargeState() const` (inline) |
| 26 | `ChargeFault chargeFault() const` (inline) |
| 27 | `quint16 voltage() const` (inline) |
| 28 | `qint16 current() const` (inline) |
| 29 | `quint16 temperature() const` (inline) |
| 30 | `quint16 remainingCapacity() const` (inline) |
| 31 | `quint16 designCapacity() const` (inline) |
| 32 | `quint16 timeToEmpty() const` (inline) |
| 33 | `quint16 timeToFull() const` (inline) |
| 35 | `static void reboot()` |
| 36 | `static void poweroff()` |
| 37 | `static void setBlankMode(BlankMode mode)` |
| 38 | `static void setTouchPower(bool on)` |
| 39 | `static void charge(bool enable)` |
| 40 | `static void setBatteryEnabled(bool enable)` |

**Signals:**

| Line | Signal |
|------|--------|
| 43 | `void ignitionStateChanged(bool on)` |
| 44 | `void batteryStatusRead(bool avail, int state, int fault, quint16 voltage, qint16 current, quint16 temp, quint16 remainingCapacity)` |

**Private methods:**

| Line | Method |
|------|--------|
| 47 | `void readIgnitionState()` |
| 48 | `void readChargerStatus()` |
| 49 | `void readGaugeStatus()` |

**Types / enums / constants defined in implementation file:**

- `QUERY_INTERVAL` — `6000` (ms), the polling interval for charger/gauge status.
- Sysfs path macros: `FILE_IGNITION`, `FILE_FB_BLANK`, `FILE_TOUCH_POWER`, `FILE_CHARGE_EN`, `FILE_BATFET_DISABLE`, `FILE_PG_STAT`, `FILE_VSYS_STAT`, `FILE_CHRG_STAT`, `FILE_CHRG_FAULT`, `FILE_NTC_FAULT`, `FILE_GAUGE_REGS`.

**Doc comments present (partial):**

- Line 37: Inline comment `// will turn off lcd/backlight/touch` on `setBlankMode` declaration — only comment on any public method in this header.
- Line 40: Inline comment `// enable == false will turn off BAT FET` on `setBatteryEnabled` declaration.
- Private member comments in header (lines 57, 60–66) document units for the data fields.
- Implementation of `reboot()` (cpp lines 183–203) contains a block comment describing the script that is executed.

---

## Findings

**A15-1** · LOW · No doc comment on `ModemPort::sendCmd`
**Description:** `sendCmd(const QByteArray &cmd)` is the primary public interface for issuing AT commands to the modem. The method is non-trivial: it requires the port to be open, trims the command, stores it internally for echo-matching, clears the previous response buffer, and writes the command with a `\r\n` terminator. None of this behaviour is described anywhere in the header. There is no indication that the method returns `false` when the port is closed, or that the caller must wait for the `response` signal to get the result.
**Fix:** Add a doc comment above the declaration explaining the method's preconditions (port must be open), the meaning of the return value (`false` if port is closed, `true` if the write was dispatched), and that results are delivered asynchronously via the `response` signal.

---

**A15-2** · LOW · No doc comment on `ModemPort::resetModem`
**Description:** `resetModem()` has significant side effects: it runs `ps` to detect whether the mobile process is already running, calls `setEnabled(false)` to close the serial port, and launches `/etc/pvd/mobile -r` as a detached process before restarting the reconnect timer. None of this is described in the header. A caller has no way to know about the external process execution or the guard against double-reset from the header alone.
**Fix:** Add a doc comment describing the guard condition (no-op if `/etc/pvd/mobile` is already running), the side effects (closes the port, launches a detached reset process), and the subsequent automatic reconnect attempt.

---

**A15-3** · LOW · No doc comment on `ModemPort::setEnabled`
**Description:** `setEnabled(bool enable)` controls whether the serial port is open and the reconnect timer is active. When `enable` is `false` it closes the port and emits `portStateChanged(false)`; when `enable` is `true` it starts the reconnect timer (but is a no-op if the port is already open or the timer is already active). These semantics, including the idempotency behaviour and the emitted signal, are undocumented.
**Fix:** Add a doc comment describing both branches, the idempotency guard, and the fact that disabling emits `portStateChanged(false)`.

---

**A15-4** · INFO · No doc comments on `ModemPort` inline getters/setters (`setEcho`, `isWwx`, `setWwx`)
**Description:** The inline methods `setEcho`, `isWwx`, and `setWwx` are simple one-liner getters/setters with no doc comments. Their purpose is inferable from their names and the member variable names, but the `m_wwx` flag has no explanation of what "wwx" means anywhere in the header.
**Fix:** Add a brief comment explaining the meaning of the "wwx" flag (appears to indicate a Huawei EM070W/WWX modem variant that uses `/dev/ttyUSB2` instead of `/dev/ttyUSB3`).

---

**A15-5** · LOW · No doc comment on `ModemPort` signals `portStateChanged` and `response`
**Description:** Neither signal has any documentation. `response(bool ok, const QByteArrayList &content)` has a non-obvious contract: it is emitted both for normal command completions (where `content` contains intermediate response lines, not including the echo or the final OK/ERROR) and also for unsolicited `+CGEV:` events (where `ok` is always `false` and `content` has one element). This dual-purpose use is invisible at the signal declaration.
**Fix:** Document both signals. For `response`, describe the two emission contexts (command reply vs unsolicited `+CGEV:` event), the meaning of `ok`, and what `content` contains in each case. For `portStateChanged`, document that it is emitted both when the port opens and when it closes or encounters an error.

---

**A15-6** · HIGH · No doc comment on `PowerSupply::reboot` and `PowerSupply::poweroff` — safety-critical methods
**Description:** `reboot()` and `poweroff()` are static methods that invoke `/etc/pvd/reboot` (and `/etc/pvd/reboot -p` respectively), which performs a controlled modem shutdown sequence before issuing a system reboot or poweroff. These are safety-critical operations for an in-vehicle device. Neither method has a doc comment in the header. Callers have no documented indication that these calls are synchronous and blocking (via `QProcess::execute`), that they take several seconds to complete, or that calling them will terminate all running services on the device.
**Fix:** Add doc comments to both methods stating: (1) the call is blocking and may take several seconds, (2) the method triggers a full device reboot/poweroff, (3) callers should ensure any pending state has been persisted before calling, and (4) the method does not return to the caller in normal operation.

---

**A15-7** · MEDIUM · Inaccurate/misleading inline comment on `PowerSupply::setBlankMode`
**Description:** The header comment on line 37 reads `// will turn off lcd/backlight/touch`. However, the implementation of `setBlankMode` only writes to `FILE_FB_BLANK` (the framebuffer blank sysfs node). It does not control the touchscreen power — that is a separate method (`setTouchPower`). The comment creates a false impression that a single call to `setBlankMode` is sufficient to power down the display system including touch input.
**Fix:** Correct the comment to describe only what the method actually does: writes to the framebuffer blank sysfs node to blank or unblank the LCD and backlight. Note that touch power must be managed separately via `setTouchPower`. Also document the `BlankMode` enum values so callers understand what `UnBlank` vs `BlankPowerDown` actually do.

---

**A15-8** · LOW · No doc comment on `PowerSupply::charge` — inverted polarity undocumented
**Description:** `charge(bool enable)` has an inverted hardware polarity: calling `charge(true)` writes `"0"` to the charge-enable GPIO, and `charge(false)` writes `"1"`. This is a low-active signal. The method name and parameter suggest straightforward enable/disable semantics, but the inversion is hidden in the implementation with no explanatory comment on the declaration. Only the inline comment `// enable == false will turn off BAT FET` on `setBatteryEnabled` hints that this pattern exists in the file, but `charge` itself has no such note.
**Fix:** Add a doc comment to the declaration explaining that the enable parameter maps to an active-low hardware GPIO (writing `0` enables charging, writing `1` disables it), and document the sysfs path or hardware component being controlled (bq24190 charger chip, charge-enable GPIO).

---

**A15-9** · LOW · No doc comment on `PowerSupply::setBatteryEnabled` — hardware consequence undocumented
**Description:** The inline comment `// enable == false will turn off BAT FET` describes only the false case. The declaration does not document: (1) that this controls the battery FET on the bq24190 charger via the `f_batfet_disable` sysfs node, (2) that disabling the battery FET (`enable=false`) disconnects the battery from the system entirely, which is a destructive hardware action, or (3) that the method is automatically called with `enable=true` whenever ignition turns on (see `readIgnitionState`).
**Fix:** Expand the comment to describe both states, the underlying hardware mechanism (battery FET on the bq24190), and the consequence of disabling (battery physically disconnected from the system bus).

---

**A15-10** · INFO · Units missing from getter declarations in `PowerSupply` header
**Description:** The inline getters `voltage()`, `current()`, `temperature()`, `remainingCapacity()`, `designCapacity()`, `timeToEmpty()`, and `timeToFull()` have no doc comments on their declarations. The units are documented only in the private member variable comments further down in the header (e.g., `// in mV`, `// in mA`, `// in Celsius degree`, `// in minitues`). Callers who see only the public interface lack unit information without scrolling to the private section.
**Fix:** Add brief unit annotations to each getter declaration (e.g., `// Returns voltage in mV`). This is especially important for `temperature()` since its unit (Celsius) differs from the raw sensor value, and for `timeToEmpty()`/`timeToFull()` where the misspelling "minitues" in the private comment also needs correction to "minutes".

---

**A15-11** · INFO · `batteryStatusRead` signal parameters are unnamed/undescribed
**Description:** The `batteryStatusRead` signal (line 44) has seven parameters, several of which are untyped `int` rather than the enum types used internally (`ChargeState`, `ChargeFault`). There is no doc comment explaining which parameter corresponds to which measured value or what units they carry. Callers connecting to this signal must cross-reference the private member variables and their comments to understand what each argument contains.
**Fix:** Add a doc comment listing each parameter name, its type semantics (e.g., that `state` maps to `ChargeState` and `fault` maps to `ChargeFault`), and units where applicable. Consider whether `state` and `fault` should be typed as their respective enums rather than `int`.

---

**A15-12** · INFO · Typo "minitues" in private member comments (`powersupply.h`)
**Description:** Lines 65 and 66 in the header contain the comment `// in minitues` for both `m_timeToEmpty` and `m_timeToFull`. While these are private member comments rather than public API documentation, the typo ("minitues" instead of "minutes") is present in two places and would propagate into any documentation generated from the header.
**Fix:** Correct both occurrences of `// in minitues` to `// in minutes`.

---

## Summary Table

| ID | Severity | Location | Title |
|----|----------|----------|-------|
| A15-1 | LOW | `modemport.h:15` | No doc comment on `ModemPort::sendCmd` |
| A15-2 | LOW | `modemport.h:16` | No doc comment on `ModemPort::resetModem` |
| A15-3 | LOW | `modemport.h:17` | No doc comment on `ModemPort::setEnabled` |
| A15-4 | INFO | `modemport.h:18-20` | No doc comments on inline getters/setters; "wwx" meaning unexplained |
| A15-5 | LOW | `modemport.h:23-24` | No doc comments on signals `portStateChanged` and `response` |
| A15-6 | HIGH | `powersupply.h:35-36` | No doc comments on safety-critical `reboot` and `poweroff` |
| A15-7 | MEDIUM | `powersupply.h:37` | Inaccurate comment on `setBlankMode` claims touch is also controlled |
| A15-8 | LOW | `powersupply.h:39` | No doc comment on `charge`; inverted GPIO polarity undocumented |
| A15-9 | LOW | `powersupply.h:40` | `setBatteryEnabled` comment incomplete; hardware consequence undocumented |
| A15-10 | INFO | `powersupply.h:27-33` | Units absent from getter declarations in public interface |
| A15-11 | INFO | `powersupply.h:44` | `batteryStatusRead` signal parameters unnamed and undescribed |
| A15-12 | INFO | `powersupply.h:65-66` | Typo "minitues" in private member comments |
# Pass 3 Agent A16 — Documentation

**Audit run:** 2026-02-28-01
**Branch:** master
**Files reviewed:**
- `platform/pwmbacklight.h` / `platform/pwmbacklight.cpp`
- `platform/pwmbeeper.h` / `platform/pwmbeeper.cpp`
- `platform/seriallogger.h` / `platform/seriallogger.cpp`

---

## Reading Evidence

### `platform/pwmbacklight.h` — Class `EM070::PwmBacklight`

**Class:** `EM070::PwmBacklight` (inherits `QObject`)

**Enums / Types / Constants:**
- `enum State { NoChange, Brighter, Darker }` — line 15

**Public methods (with line numbers):**

| Line | Declaration |
|------|-------------|
| 16 | `explicit PwmBacklight(QObject *parent = nullptr)` |
| 17 | `~PwmBacklight()` |
| 18 | `void setAutoBrightness(bool enable)` |
| 19 | `bool isAutoBrightness() const` (inline) |
| 21 | `static quint8 brightness()` |
| 22 | `static void setBrightness(quint8 val)` |

**Signals:**
- `void luxRead(int lux)` — line 25

**Protected methods:**
- `void timerEvent(QTimerEvent *)` — line 28

**Private methods:**
- `void parse(int lux)` — line 31
- `void adjust(int lux)` — line 32
- `int readLux()` — line 33

**Doc comments present:** None. Not a single comment appears above any declaration in the header.

---

### `platform/pwmbeeper.h` — Class `EM070::PwmBeeper`

**Class:** `EM070::PwmBeeper` (inherits `QObject`)

**Enums / Types / Constants:**
- `enum BeepType { BeepOn, BeepSilent, BeepOff }` — line 15

**Public methods (with line numbers):**

| Line | Declaration |
|------|-------------|
| 18 | `explicit PwmBeeper(bool autoDelete = false, QObject *parent = nullptr)` |
| 19 | `~PwmBeeper()` |
| 20 | `void setFrequency(quint16 frequency)` (inline) |
| 21 | `void beep(quint16 milliseconds)` |
| 22 | `void beep(quint16 frequency, quint16 milliseconds)` |
| 23 | `void beep(qint16 count, quint16 msecOn, quint16 msecOff)` |
| 24 | `void stop()` |

**Signals:** None.

**Private methods:**
- `void timeout()` — line 27
- `void setBeep(bool on)` — line 28

**Doc comments present:**
- Line 17: `// if autoDelete is enabled, instance will be deleted when beep time is expired` — an inline comment above the constructor describing the `autoDelete` parameter.
- No other doc comments.

---

### `platform/seriallogger.h` — Class `SerialLogger`

**Class:** `SerialLogger` (plain class, no QObject)

**Public methods (with line numbers):**

| Line | Declaration |
|------|-------------|
| 9 | `static void log(const QByteArray &message)` |
| 10 | `static void setSerialPort(EM070::UserPort *serial)` |

**Signals:** None.

**Enums / Types / Constants:**
- `ENABLE_SL_FILE` (preprocessor macro, value `0`) — defined in `.cpp`, line 5
- `SERIAL_LOG_FILE` (`"/mnt/sd/sl.log"`) — defined in `.cpp`, line 6

**Doc comments present:** None.

---

## Findings

**A16-1** · LOW · No doc comment on `PwmBacklight::setAutoBrightness`
**Description:** `setAutoBrightness(bool enable)` starts or stops the ambient-light-sensor polling loop, powers the ALS sensor on or off via sysfs, and immediately adjusts the backlight level. None of this behaviour is documented in the header. A caller has no indication that enabling auto-brightness powers up hardware, clears internal state, or fires an immediate brightness adjustment.
**Fix:** Add a comment above the declaration explaining that `enable = true` powers up the ALS sensor, resets the lux queue and state machine, performs an initial brightness adjustment, and starts a 250 ms polling timer; that `enable = false` kills the timer and powers down the sensor.

---

**A16-2** · INFO · No doc comment on `PwmBacklight::isAutoBrightness`
**Description:** Trivial const getter; the name is self-describing. Missing documentation is minor.
**Fix:** A one-line comment `// Returns true if the automatic brightness adjustment loop is currently active.` is sufficient.

---

**A16-3** · LOW · No doc comment on `static PwmBacklight::brightness()`
**Description:** `brightness()` reads the current backlight level directly from the sysfs node `/sys/devices/platform/pwm-backlight.0/…/brightness`. The implementation returns `255` on failure to open the file (a valid brightness value, not an error sentinel), which is non-obvious behaviour. No documentation exists.
**Fix:** Document the return range (0–255), the sysfs source, and the error-return convention (returns 255 if the sysfs file cannot be opened).

---

**A16-4** · LOW · No doc comment on `static PwmBacklight::setBrightness(quint8 val)`
**Description:** `setBrightness` writes directly to sysfs to control the hardware backlight. Callers need to know the valid range, the absence of range-clamping, and the silent failure mode (write failures are logged to `qCritical` but not propagated). None of this is documented.
**Fix:** Add a comment stating the valid range (0–255), that the value is written directly to the PWM backlight sysfs node without clamping, and that failures are logged but not returned to the caller.

---

**A16-5** · LOW · No doc comment on `PwmBacklight::luxRead` signal
**Description:** The signal `void luxRead(int lux)` is emitted on every 250 ms timer tick with the raw lux value from the sensor. The header carries no description of when it fires, the unit of the argument, or its range. Slot writers have no guidance.
**Fix:** Add a comment: `// Emitted every ~250 ms with the raw ambient light level in lux (0–4000) when auto-brightness is active.`

---

**A16-6** · MEDIUM · Guard macro mismatch in `pwmbacklight.h`
**Description:** The include guard at line 1 is `#ifndef PWMBACKLIGHT_H` but the macro defined at line 2 is `#define BRIGHTNESS_H`. These do not match, so the guard is non-functional: the `#define BRIGHTNESS_H` never satisfies the `#ifndef PWMBACKLIGHT_H` check on re-inclusion. This is a documentation / correctness defect in the guard itself. While not a doc-comment issue, it falls squarely in the header's structural documentation.
**Fix:** Change line 2 to `#define PWMBACKLIGHT_H` so the guard macro matches the `#ifndef` condition, and update the closing comment on line 48 if needed.

---

**A16-7** · LOW · `BeepType` enum is declared but never used
**Description:** `enum BeepType { BeepOn, BeepSilent, BeepOff }` is defined in the public interface at line 15 of `pwmbeeper.h`. It is not referenced anywhere in `pwmbeeper.cpp` or in any `beep()` overload signature. There is no comment explaining its intended purpose or whether it is reserved for future use. This creates confusion for integrators who may attempt to pass `BeepType` values to the beep API and find no accepting overload.
**Fix:** Either add a comment stating the enum is reserved / unused (e.g., `// Reserved for future use; not yet accepted by any beep() overload.`), or remove the enum if it serves no purpose.

---

**A16-8** · LOW · No doc comment on `PwmBeeper::beep(quint16 milliseconds)`
**Description:** The single-argument `beep` overload is undocumented. From the implementation it plays one beep at the previously configured frequency (`m_frequency`, default 4000 Hz) for `milliseconds` milliseconds. The relationship to `setFrequency` and the default frequency is invisible to callers.
**Fix:** Add a comment noting that this plays a single beep at the current frequency (set via `setFrequency`, default 4000 Hz) for the specified duration.

---

**A16-9** · LOW · No doc comment on `PwmBeeper::beep(quint16 frequency, quint16 milliseconds)`
**Description:** Two-argument overload that sets the frequency and plays one beep. No documentation. The side-effect of permanently updating `m_frequency` (i.e., subsequent calls to the one-argument `beep()` will use the new frequency) is invisible.
**Fix:** Document parameters and note that calling this overload permanently updates the object's stored frequency.

---

**A16-10** · LOW · No doc comment on `PwmBeeper::beep(qint16 count, quint16 msecOn, quint16 msecOff)`
**Description:** The three-argument overload is the most complex: it plays `count` beep pulses separated by `msecOff` silent gaps. The sign of `count` (it is `qint16`, not `quint16`) is undocumented. From the implementation `count` is decremented to zero; negative or zero values are never clamped, which means passing `count <= 0` results in no beep but also triggers `deleteLater()` if `autoDelete` is set. None of this is documented.
**Fix:** Document all three parameters, note that `count` must be positive, explain the beep/pause cycle, and warn that `count <= 0` causes immediate silent deletion when `autoDelete` is true.

---

**A16-11** · LOW · No doc comment on `PwmBeeper::stop()`
**Description:** `stop()` silences the beeper, cancels both timers, and — if `autoDelete` is set — schedules `deleteLater()`. The auto-delete side-effect is a memory-management concern that callers must know about. No documentation is present.
**Fix:** Add a comment explaining that `stop()` immediately silences the beeper and, when `autoDelete` was set on construction, schedules the object for deletion.

---

**A16-12** · LOW · No doc comment on `PwmBeeper::setFrequency(quint16 frequency)`
**Description:** Inline setter with no comment. The valid range, unit (Hz), and the default value (4000 Hz, set in the constructor) are not described.
**Fix:** Add a comment: `// Sets the beep frequency in Hz. Default is 4000 Hz. Takes effect on the next call to beep().`

---

**A16-13** · LOW · No doc comment on `SerialLogger::log(const QByteArray &message)`
**Description:** `log()` prepends a millisecond-epoch timestamp to `message` and forwards it via `UserPort::response()`. It is conditionally compiled to also write to `/mnt/sd/sl.log` (controlled by `ENABLE_SL_FILE`). The header has no comment describing the timestamp format, the output destination, null-safety (silently no-ops if `setSerialPort` was never called), or the file-logging capability. Because this is used for serial-level diagnostic logging, incomplete documentation can lead to misuse in field diagnostics.
**Fix:** Document the timestamp format (`[<epoch_ms>]`), the requirement to call `setSerialPort` before use, the silent no-op behaviour when no port is set, and the compile-time file-log option.

---

**A16-14** · LOW · No doc comment on `SerialLogger::setSerialPort(EM070::UserPort *serial)`
**Description:** `setSerialPort` sets the single static destination for all subsequent `log()` calls. Passing `nullptr` is allowed and silences logging (log becomes a no-op). There is no documentation of nullptr semantics, thread-safety, or whether the class takes ownership of the pointer.
**Fix:** Add a comment noting: accepts nullptr to disable logging; the class does not take ownership of the pointer; not thread-safe (static state with no locking).

---

## Summary Table

| ID | Severity | File | Subject |
|----|----------|------|---------|
| A16-1 | LOW | `pwmbacklight.h` | Missing doc on `setAutoBrightness` |
| A16-2 | INFO | `pwmbacklight.h` | Missing doc on `isAutoBrightness` |
| A16-3 | LOW | `pwmbacklight.h` | Missing doc on `brightness()` — non-obvious error return |
| A16-4 | LOW | `pwmbacklight.h` | Missing doc on `setBrightness()` — range and failure mode |
| A16-5 | LOW | `pwmbacklight.h` | Missing doc on `luxRead` signal |
| A16-6 | MEDIUM | `pwmbacklight.h` | Include guard macro mismatch (`PWMBACKLIGHT_H` vs `BRIGHTNESS_H`) |
| A16-7 | LOW | `pwmbeeper.h` | `BeepType` enum declared but never used, no comment |
| A16-8 | LOW | `pwmbeeper.h` | Missing doc on `beep(quint16 milliseconds)` |
| A16-9 | LOW | `pwmbeeper.h` | Missing doc on `beep(quint16 frequency, quint16 milliseconds)` — permanent frequency side-effect |
| A16-10 | LOW | `pwmbeeper.h` | Missing doc on `beep(qint16 count, …)` — signed count, auto-delete edge case |
| A16-11 | LOW | `pwmbeeper.h` | Missing doc on `stop()` — auto-delete side-effect |
| A16-12 | LOW | `pwmbeeper.h` | Missing doc on `setFrequency()` — unit and default undocumented |
| A16-13 | LOW | `seriallogger.h` | Missing doc on `log()` — timestamp format, null-port no-op, file log option |
| A16-14 | LOW | `seriallogger.h` | Missing doc on `setSerialPort()` — nullptr semantics, ownership, thread-safety |

**Totals:** 1 MEDIUM, 12 LOW, 1 INFO
# Pass 3 Agent A17 — Documentation

**Audit run:** 2026-02-28-01
**Branch:** master
**Files reviewed:**
- `platform/userport.h` / `platform/userport.cpp`
- `platform/wiegandrfid.h` / `platform/wiegandrfid.cpp`
- `platform/wifi.h` / `platform/wifi.cpp`

---

## Reading Evidence

### `platform/userport.h` — Class `EM070::UserPort`

**Class:** `EM070::UserPort` (extends `QObject`)

**Public methods:**

| Line | Method |
|------|--------|
| 15 | `explicit UserPort(QObject *parent = nullptr)` |
| 16 | `void response(const QByteArray &ba)` |
| 18 | `void setBaudRate(QSerialPort::BaudRate baudRate)` |

**Signals:**

| Line | Signal |
|------|--------|
| 21 | `void cmdReceived(const QByteArray &ba)` |

**Private methods:** `readData()`

**Private members:** `m_serialPort` (`QSerialPort*`), `m_receiver` (`QByteArray`)

**Types / enums / constants defined in header:** none (uses `QSerialPort::BaudRate` from Qt)

**Macro in .cpp:** `FILE_USER_PORT` = `"/dev/ttyS1"`

---

### `platform/wiegandrfid.h` — Class `EM070::WiegandRfid`

**Class:** `EM070::WiegandRfid` (extends `QObject`)

**Public methods:**

| Line | Method |
|------|--------|
| 14 | `explicit WiegandRfid(QObject *parent = 0)` |
| 15 | `void setEnabled(bool enable)` |
| 17 | `static quint64 wiegandData(quint8 facility, quint32 number)` |

**Signals:**

| Line | Signal |
|------|--------|
| 20 | `void cardData(quint64 wiegand, quint16 facility, quint32 number, QByteArray &readerOutput)` |
| 21 | `void error(const QString &text)` |

**Private methods:** `activated()`

**Private members:** `m_cardReadyFile` (`QFile`), `m_notifier` (`QSocketNotifier*`)

**Types / enums / constants defined in header:** none

**Macros in .cpp:**
- `FILE_CARD_READY` = `"/sys/devices/platform/wiegand-gpio.0/card_ready"`
- `FILE_CARD_DATA`  = `"/sys/devices/platform/wiegand-gpio.0/card_data"`
- `FILE_RAW_DATA`   = `"/sys/devices/platform/wiegand-gpio.0/raw_data"`

---

### `platform/wifi.h` — Class `EM070::Wifi`

**Class:** `EM070::Wifi` (extends `QObject`)

**Public methods:**

| Line | Method |
|------|--------|
| 26 | `explicit Wifi(EM070::UserPort *userPort)` |
| 27 | `~Wifi() {}` |
| 29 | `void writeConf()` |
| 30 | `void restart()` |
| 32 | `bool status()` (inline getter) |
| 34 | `bool startPositioning()` |
| 36 | `void parseResponse(const QByteArray &ba)` |
| 38 | `QList<CIGCONF::AccessPoint> accessPoints()` (inline getter) |
| 40 | `void setCellularState(bool state)` |
| 42 | `void setPowerState(CIGCONF::PowerState state)` |

**Signals:**

| Line | Signal |
|------|--------|
| 46 | `void ethernetStateChanged(bool ready)` |
| 47 | `void wifiReconnectionFailed()` |
| 48 | `void wifiScanFinished(QList<CIGCONF::AccessPoint> list)` |

**Private methods:** `attemptReconnectToWifi()`, `checkStatus()`, `scanAccessPoints()`, `scanFinished(int, QProcess::ExitStatus)`

**Private members:** `m_userPort`, `m_configurationManager`, `m_status`, `m_wifiStatus`, `m_cellularStatus`, `m_posTimer`, `m_reconnectTimer`, `m_ps`, `m_accessPoints`, `m_powerState`

**Types used from `CIGCONF`:** `CIGCONF::AccessPoint`, `CIGCONF::PowerState`, `CIGCONF::WifiNetwork` (in .cpp)

**Macros in .cpp:**
- `SCAN_WATCHDOG` = `300000` ms (5 minutes)
- `RECONNECT_TIMEOUT` = `210000` ms (3.5 minutes)

---

## Documentation Check per Method

### `EM070::UserPort`

| Method | Doc comment? | Accurate? | Params/return described? |
|--------|-------------|-----------|--------------------------|
| `UserPort(QObject *parent)` | No | — | — |
| `response(const QByteArray &ba)` | No | — | — |
| `setBaudRate(QSerialPort::BaudRate baudRate)` | No | — | — |
| Signal: `cmdReceived(const QByteArray &ba)` | No | — | — |

No doc comments exist anywhere in `userport.h` or `userport.cpp`.

### `EM070::WiegandRfid`

| Method | Doc comment? | Accurate? | Params/return described? |
|--------|-------------|-----------|--------------------------|
| `WiegandRfid(QObject *parent)` | No | — | — |
| `setEnabled(bool enable)` | No | — | — |
| `static wiegandData(quint8 facility, quint32 number)` | No (block comment inside body only) | — | — |
| Signal: `cardData(quint64, quint16, quint32, QByteArray&)` | No | — | — |
| Signal: `error(const QString &text)` | No | — | — |

The only comment in `wiegandrfid.cpp` is an internal block comment inside `wiegandData()` (lines 113–122) that partially explains the encoding algorithm; it is not a doc comment above the declaration and does not describe parameters or return value.

### `EM070::Wifi`

| Method | Doc comment? | Accurate? | Params/return described? |
|--------|-------------|-----------|--------------------------|
| `Wifi(EM070::UserPort *userPort)` | No | — | — |
| `~Wifi()` | No | — | — |
| `writeConf()` | No | — | — |
| `restart()` | No | — | — |
| `status()` | No | — | — |
| `startPositioning()` | No | — | — |
| `parseResponse(const QByteArray &ba)` | No | — | — |
| `accessPoints()` | No | — | — |
| `setCellularState(bool state)` | No | — | — |
| `setPowerState(CIGCONF::PowerState state)` | No | — | — |
| Signal: `ethernetStateChanged(bool ready)` | No | — | — |
| Signal: `wifiReconnectionFailed()` | No | — | — |
| Signal: `wifiScanFinished(...)` | No | — | — |

No doc comments exist anywhere in `wifi.h` or `wifi.cpp`.

---

## Findings

**A17-1** · HIGH · No documentation on WiegandRfid constructor

**Description:** `WiegandRfid::WiegandRfid(QObject *parent)` has no doc comment. The constructor opens the sysfs `card_ready` file and registers an exception-mode `QSocketNotifier`. If the file cannot be opened the object is silently left in a non-functional state (`m_notifier` is never initialised), yet the caller has no way to detect this failure. Without documentation, callers do not know the object may be partially constructed, what sysfs path is required, or that they must not call `setEnabled()` on a failed instance (which would dereference a null `m_notifier`).

**Fix:** Add a doc comment above the declaration in `wiegandrfid.h` describing the sysfs dependency, the silent-failure behaviour on missing hardware, and that callers should guard against a non-functional instance. Also add a `bool isValid()` accessor (or throw / use a factory) so callers can detect construction failure.

---

**A17-2** · HIGH · No documentation on `WiegandRfid::setEnabled(bool enable)`

**Description:** `setEnabled()` enables or disables the `QSocketNotifier` that fires on RFID card presentation, directly gating whether vehicle-access authentication events are delivered. No doc comment exists. The name `setEnabled` is generic and does not convey that disabling it suppresses all card reads; a caller who misuses this could silently disable access control.

**Fix:** Add a doc comment stating that `enable = false` suppresses all RFID card-read notifications, that calling this on a construction-failed instance will crash (null pointer dereference on `m_notifier`), and under what conditions callers are expected to disable the reader.

---

**A17-3** · HIGH · No documentation on `static WiegandRfid::wiegandData(quint8 facility, quint32 number)`

**Description:** `wiegandData()` is the sole function that converts facility/card-number pairs into the canonical Wiegand credential integer used throughout the access-control system. It handles three distinct encoding formats (Wiegand-26, Wiegand-42, and an unimplemented path for numbers > 99999) with parity bit computation. There is a partial inline comment inside the function body that describes some edge-case behaviour but does not appear above the declaration, does not document parameters, does not document the return value, and does not warn that numbers > 99999 produce only a `qCritical` log and return `0`. This is a security-relevant function: incorrect or undocumented encoding rules can cause legitimate credentials to be silently rejected or two distinct credentials to map to the same integer.

**Fix:** Add a doc comment above the declaration in `wiegandrfid.h` that: (a) describes `facility` (8-bit site code) and `number` (card number, valid range 1–99999); (b) documents the return value as the packed Wiegand integer including parity bits; (c) explicitly states the unimplemented range (number > 99999) returns `0` and logs a critical error; (d) references the encoding specification URL already present in the body comment.

---

**A17-4** · HIGH · No documentation on `cardData` signal

**Description:** The `cardData` signal carries the raw authentication credential (`quint64 wiegand`, `quint16 facility`, `quint32 number`, `QByteArray &readerOutput`). The relationship between the four parameters is non-obvious: `wiegand` is the computed canonical value from `wiegandData()`, while `facility`/`number` are the raw decoded fields, and `readerOutput` is the raw byte string read from sysfs. When `facility == 0 && number == 0` (raw-data fall-through path for ≥ 26-bit cards), `wiegand` carries the verbatim raw integer rather than the computed canonical value. No documentation exists to explain this dual-mode emission, which is security-relevant: a consumer that always passes `wiegand` to the access-control lookup will behave differently from one that uses `facility`/`number`.

**Fix:** Add a doc comment above the signal declaration describing each parameter, the conditions under which `facility` and `number` may both be zero, and how the `wiegand` value is populated in each case.

---

**A17-5** · HIGH · No documentation on `error` signal (WiegandRfid)

**Description:** The `error` signal is emitted when a card swipe produces bit-count data but cannot be decoded into a recognised credential (bit count < 26, or the 34-bit path yields facility == 0 or number == 0). The `text` parameter actually carries the raw sysfs byte string (`ba`), not a human-readable error description. No documentation exists. A consumer expecting `text` to be a human-readable message string (as the parameter name implies) may log or display raw binary data, and critically may not connect this signal to a denied-access handler.

**Fix:** Add a doc comment clarifying that `text` is the raw sysfs data that could not be parsed, not a descriptive string, and that this signal indicates a card presentation that could not be authenticated.

---

**A17-6** · LOW · No documentation on `UserPort::response(const QByteArray &ba)`

**Description:** `response()` writes `ba` directly to the serial port. There is no doc comment describing what type of data is expected, whether the port must be open, or the echo behaviour controlled by `gCfg->isRs232AccessoryActive()` that interacts with input echoing in `readData()`. The behaviour when the port is closed is silently a no-op.

**Fix:** Add a doc comment describing the parameter, the silent no-op when the port is closed, and the dependency on the accessory-active state for echo behaviour.

---

**A17-7** · LOW · No documentation on `UserPort::setBaudRate(QSerialPort::BaudRate baudRate)`

**Description:** `setBaudRate()` delegates directly to `QSerialPort::setBaudRate()`. No doc comment exists. While the method is simple, it is called by `Wifi::startPositioning()` to switch between 9600 baud (Xpico-240 positioning mode) and 115200 baud (normal mode). Without documentation the coupling between `UserPort` baud rate changes and the Wifi positioning subsystem is invisible to maintainers.

**Fix:** Add an INFO-level doc comment noting the expected callers and valid baud rate values in this system context.

---

**A17-8** · LOW · No documentation on `UserPort::cmdReceived` signal

**Description:** `cmdReceived` is emitted when a CR or LF terminates an incoming line on the serial port. The emitted `QByteArray` does not include the terminator. Backspace handling (`\b`) has already been applied. No doc comment exists describing the line-termination rule, the backspace pre-processing, or what protocol is expected on the serial port.

**Fix:** Add a doc comment describing when the signal fires, that the terminator is stripped, that backspace editing has already been applied, and the expected serial protocol context.

---

**A17-9** · LOW · No documentation on `Wifi::writeConf()`

**Description:** `writeConf()` writes `wpa_supplicant.conf` to `WIFI_CONF_FILE`. It silently skips networks with empty SSIDs, SSIDs longer than 32 characters, and treats passwords shorter than 8 or longer than 63 characters as open (no authentication) networks. The silent open-network fallback is a security-relevant behaviour: a misconfigured password causes the device to associate with the named SSID using no encryption rather than refusing to configure the network. No documentation exists.

**Fix:** Add a doc comment describing the file written, the SSID length constraints, and explicitly noting that an out-of-range password causes the network to be written as `key_mgmt=NONE` (open).

---

**A17-10** · LOW · No documentation on `Wifi::restart()`

**Description:** `restart()` either sends SIGHUP to a running `wpa_supplicant` process (triggering a re-read of config) or starts a new `wpa_supplicant` instance. It has no return value and provides no indication of success or failure. No doc comment exists describing the side effects, the dependency on `wpa_supplicant` being installed, the hardcoded interface name `wlan0`, or the 3-second blocking wait on `ps`.

**Fix:** Add a doc comment describing both code paths, the 3-second synchronous block, and the hardcoded interface assumption.

---

**A17-11** · LOW · No documentation on `Wifi::startPositioning()`

**Description:** `startPositioning()` starts or stops WiFi-based positioning depending on configuration. It returns `true` when positioning is started and `false` when stopped, but no doc comment exists. The method also has the side effect of changing the `UserPort` baud rate, which affects unrelated serial communication. This cross-subsystem side effect is invisible without documentation.

**Fix:** Add a doc comment describing the return value semantics, the baud-rate side effect, and the dependency on global configuration values `wifiPos()` and `wifiPosInterval()`.

---

**A17-12** · LOW · No documentation on `Wifi::parseResponse(const QByteArray &ba)`

**Description:** `parseResponse()` is only active when `wifiPosSource == WifiPosXpico240`. For all other sources it returns immediately. The method parses a fixed-offset binary/text frame from the Xpico-240 device: SSID at bytes 0–31, MAC at bytes 33–49, channel at bytes 51–53, RSSI at bytes 55–58. A `'>'` byte in position 0 signals end-of-scan. None of this protocol detail is documented. Callers from other subsystems will not know this method is a no-op for non-Xpico sources.

**Fix:** Add a doc comment describing the Xpico-240 frame format, the end-of-scan sentinel, and the condition under which the method is a no-op.

---

**A17-13** · LOW · No documentation on `Wifi::setCellularState(bool state)`

**Description:** `setCellularState()` updates `m_cellularStatus` and, when the reconnect timer is not already running, starts a 3.5-minute reconnect timer. The interaction between cellular state and WiFi reconnect logic is not obvious, and the timer start side effect is undocumented.

**Fix:** Add a doc comment explaining that this informs the WiFi subsystem whether cellular is available (so that WiFi reconnection urgency changes), and that it arms the reconnect timer as a side effect.

---

**A17-14** · LOW · No documentation on `Wifi::setPowerState(CIGCONF::PowerState state)`

**Description:** `setPowerState()` sets `m_powerState`. When not in `NormalPowerState`, `checkStatus()` returns immediately, effectively disabling all WiFi connection monitoring. This has an operational impact (the device stops reacting to WiFi drops during non-normal power states) that is entirely undocumented.

**Fix:** Add a doc comment stating that non-normal power states suppress WiFi status monitoring, and referencing the `CIGCONF::PowerState` enum values.

---

**A17-15** · LOW · No documentation on `Wifi` signals

**Description:** None of the three signals (`ethernetStateChanged`, `wifiReconnectionFailed`, `wifiScanFinished`) have doc comments. In particular: (a) `ethernetStateChanged` carries a `bool ready` but the signal name says "ethernet" while the implementation monitors `wlan0` — callers may be confused about when this fires for wired vs wireless; (b) `wifiReconnectionFailed` is defined but never emitted in the current implementation (the reconnect body is entirely commented out); (c) `wifiScanFinished` is defined but also never emitted anywhere in the implementation.

**Fix:** Add doc comments for each signal. Mark `wifiReconnectionFailed` and `wifiScanFinished` as currently unused/unimplemented. Clarify that `ethernetStateChanged` tracks WiFi (`wlan0`) state only despite the name.

---

**A17-16** · INFO · `Wifi::status()` inline getter undocumented and misleading

**Description:** `status()` returns `m_status`, which is initialised to `false` in the constructor and never updated anywhere in the implementation. It therefore always returns `false`. No doc comment exists. The field `m_wifiStatus` is separately used to track actual WiFi connection state. The existence of a permanently-false `status()` alongside a meaningful `m_wifiStatus` is a documentation gap that is also indicative of a stale API surface.

**Fix:** Add a doc comment noting that this accessor reflects `m_status` (not `m_wifiStatus`). Investigate whether `m_status` is intended to represent something distinct; if not, mark it as deprecated.

---

**A17-17** · INFO · `Wifi::accessPoints()` inline getter undocumented

**Description:** `accessPoints()` returns the last scanned list of `CIGCONF::AccessPoint`. No doc comment exists describing when the list is populated, its relationship to the `wifiScanFinished` signal, or whether it may be empty before the first scan completes.

**Fix:** Add a brief doc comment stating that the list is populated after the first successful scan and may be empty until then.

---

## Summary Table

| ID | Severity | File | Symbol | Issue |
|----|----------|------|--------|-------|
| A17-1 | HIGH | `wiegandrfid.h:14` | `WiegandRfid::WiegandRfid()` | No documentation; silent construction failure leaves null `m_notifier` |
| A17-2 | HIGH | `wiegandrfid.h:15` | `WiegandRfid::setEnabled()` | No documentation; disables all RFID auth events; null-ptr crash risk |
| A17-3 | HIGH | `wiegandrfid.h:17` | `WiegandRfid::wiegandData()` | No documentation on security-critical credential encoding; silent zero return for invalid input |
| A17-4 | HIGH | `wiegandrfid.h:20` | Signal `cardData` | No documentation; dual-mode emission (parsed vs raw) undescribed |
| A17-5 | HIGH | `wiegandrfid.h:21` | Signal `error` | No documentation; parameter carries raw binary, not a message string |
| A17-6 | LOW | `userport.h:16` | `UserPort::response()` | No documentation; silent no-op and echo behaviour undescribed |
| A17-7 | LOW | `userport.h:18` | `UserPort::setBaudRate()` | No documentation; cross-subsystem baud-rate coupling invisible |
| A17-8 | LOW | `userport.h:21` | Signal `cmdReceived` | No documentation; termination/backspace processing undescribed |
| A17-9 | LOW | `wifi.h:29` | `Wifi::writeConf()` | No documentation; silent open-network fallback for bad passwords |
| A17-10 | LOW | `wifi.h:30` | `Wifi::restart()` | No documentation; blocking wait and hardcoded interface undescribed |
| A17-11 | LOW | `wifi.h:34` | `Wifi::startPositioning()` | No documentation; return value and baud-rate side effect undescribed |
| A17-12 | LOW | `wifi.h:36` | `Wifi::parseResponse()` | No documentation; Xpico-240 frame format and no-op condition undescribed |
| A17-13 | LOW | `wifi.h:40` | `Wifi::setCellularState()` | No documentation; timer side effect undescribed |
| A17-14 | LOW | `wifi.h:42` | `Wifi::setPowerState()` | No documentation; suppression of WiFi monitoring undescribed |
| A17-15 | LOW | `wifi.h:46–48` | Signals `ethernetStateChanged`, `wifiReconnectionFailed`, `wifiScanFinished` | No documentation; two signals never emitted; misleading signal name |
| A17-16 | INFO | `wifi.h:32` | `Wifi::status()` | No documentation; returns permanently-false `m_status` |
| A17-17 | INFO | `wifi.h:38` | `Wifi::accessPoints()` | No documentation; population timing undescribed |

**Total findings: 17**
- HIGH: 5 (all in `WiegandRfid`, the security-critical RFID authentication class)
- LOW: 10 (spread across `UserPort` and `Wifi`)
- INFO: 2 (trivial getters in `Wifi`)
# Pass 3 Agent A18 — Documentation

**Audit run:** 2026-02-28-01
**Branch:** master
**Repo root:** C:/Projects/cig-audit/repos/mark3-pvd

---

## Reading Evidence

### File: `ui/amberimpactalertdialog.h` + `ui/amberimpactalertdialog.cpp`

**Class:** `AmberImpactAlertDialog` (extends `QDialog`)

**Public methods (header line numbers):**

| Line | Method | Has Doc Comment? |
|------|--------|-----------------|
| 15 | `explicit AmberImpactAlertDialog(QWidget *parent = nullptr)` | No |
| 16 | `~AmberImpactAlertDialog()` | No |
| 18 | `bool isOpen() const` | Yes — `// Method to check if the dialog is open` |
| 19 | `void closeWindow()` | No |
| 20 | `void languageChanged()` | No |

**Signals:** None declared.

**Public slots:**

| Line | Slot | Has Doc Comment? |
|------|------|-----------------|
| 23 | `void amberAlertDialogShowEvent(bool isLocked)` | No |

**Protected overrides:**

| Line | Method |
|------|--------|
| 26 | `void mouseReleaseEvent(QMouseEvent *)` |
| 27 | `void showEvent(QShowEvent *event = 0)` |

**Types, enums, constants defined:** None.

**Private data members:** `bool dialogOpenFlag`

**Implementation notes relevant to documentation accuracy:**
- `isOpen()` comment says "check if the dialog is open" — returns `dialogOpenFlag`, which is set to `true` only after `showEvent` confirms `gCfg->amberImpactAlertActive()` is true. So the flag does not strictly reflect `QDialog::isVisible()`; it is a safety interlock state flag. The comment is incomplete/potentially misleading.
- `closeWindow()` guards on `dialogOpenFlag` before calling `close()`. Without documentation this guard condition is invisible to callers.
- `amberAlertDialogShowEvent(bool isLocked)` is the primary safety-critical entry point: it suppresses the dialog when the system is locked. No documentation exists.
- `languageChanged()` updates UI strings for localisation; no comment.

---

### File: `ui/authoriseddialog.h` + `ui/authoriseddialog.cpp`

**Class:** `AuthorisedDialog` (extends `QDialog`)

**Public methods (header line numbers):**

| Line | Method | Has Doc Comment? |
|------|--------|-----------------|
| 17 | `explicit AuthorisedDialog(QWidget *parent = 0)` | No |
| 18 | `~AuthorisedDialog()` | No |
| 19 | `void setHasChecklist(bool yes)` | No |
| 20 | `void setDriverId(quint64 id)` | No |
| 21 | `void setTime(const QString s)` | No |
| 22 | `void setPower(bool on)` | No |
| 23 | `void updateCamera()` | No |

**Signals:**

| Line | Signal | Has Doc Comment? |
|------|--------|-----------------|
| 30 | `void userLogout()` | No |

**Protected overrides:**

| Line | Method |
|------|--------|
| 33 | `void showEvent(QShowEvent *)` |
| 34 | `void hideEvent(QHideEvent *)` |

**Private slots:**

| Line | Slot |
|------|------|
| 54 | `void rstLogout()` |
| 55 | `void onLogoutRequest()` |

**Types, enums, constants defined:**
- `#define RESET_TIMEOUT 2000` (in .cpp, not header)

**Private data members:** `m_waking`, `m_resetTimer`, `m_lastPress`, `m_pendingDriverId`, `m_showCamera`, `m_power`

**Implementation notes relevant to documentation accuracy:**
- `setDriverId(quint64 id)` stores the ID into `m_pendingDriverId`; it is consumed in `showEvent` to look up the driver name. The "pending" semantics — that the ID is buffered and applied on show — are not documented.
- `setPower(bool on)` affects camera state indirectly via `updateCamera()`; the camera control side-effect is undocumented.
- `updateCamera()` is public and writes directly to Linux sysfs GPIO paths (`/sys/class/gpio/gpio37/value`, `/sys/class/gpio/gpio39/value`). This hardware interaction is entirely undocumented.
- `setHasChecklist(bool yes)` controls visibility of the optional pre-op check button; no comment.
- `setTime(const QString s)` conditionally shows/hides the time label based on config; no comment.
- `userLogout()` signal is the primary authorisation exit path; emitted after two-press confirmation with debounce. No documentation.

---

### File: `ui/broadcastuidialog.h` + `ui/broadcastuidialog.cpp`

**Class:** `BroadcastUIDialog` (extends `QDialog`)

**Public methods (header line numbers):**

| Line | Method | Has Doc Comment? |
|------|--------|-----------------|
| 19 | `explicit BroadcastUIDialog(QWidget *parent = nullptr)` | No |
| 20 | `~BroadcastUIDialog()` | No |
| 22 | `void setUIParam(CIGCONF::BroadcastMessage m)` | No |

**Signals:**

| Line | Signal | Has Doc Comment? |
|------|--------|-----------------|
| 25 | `void messageClosed(CIGCONF::BroadcastMessage m)` | No |

**Private slots:** `onYes()`, `onNo()`, `onOK()`

**Types, enums, constants defined:**

| Line | Name | Values |
|------|------|--------|
| 17 | `enum MessageResult` | `MsgResultOK`, `MsgResultYes`, `MsgResultNo`, `MsgResultTimeout`, `MsgResultLogout`, `MsgResultNoDriver` |

**Implementation notes relevant to documentation accuracy:**
- `setUIParam(CIGCONF::BroadcastMessage m)` configures the entire dialog from a `BroadcastMessage` struct: truncates text to `BROADCASTMSG_TEXT_LEN`, shows a warning label based on `m.type`, toggles Yes/No vs OK buttons based on `m.res`, and starts an auto-dismiss timer if `m.timeout` is non-zero. None of this behaviour is documented.
- `MessageResult` enum contains `MsgResultLogout` and `MsgResultNoDriver` values that are never emitted within this file; callers may not know they can be returned. The enum is entirely uncommented.
- `messageClosed` signal carries back the `BroadcastMessage` but the relationship between signal and `done()` is non-obvious (the slots emit `done(int)` using enum values — the overload `done(int)` emits `finished(int)` from `QDialog`, not `messageClosed`). The signal `messageClosed` is declared but appears to never be emitted in the implementation; this is a documentation gap that could mislead callers who connect to it.

---

## Findings

**A18-1** · LOW · Missing doc comment on `AmberImpactAlertDialog::closeWindow()`
**Description:** `closeWindow()` is a public method that only closes the dialog if `dialogOpenFlag` is true. The guard condition is invisible to callers. There is no comment explaining when calling this method will have no effect.
**Fix:** Add a comment explaining that the method is a no-op when the dialog has not been opened via the safety interlock (`amberAlertDialogShowEvent`), e.g., `// Closes the dialog only if it was opened via amberAlertDialogShowEvent; no-op otherwise.`

---

**A18-2** · MEDIUM · Inaccurate doc comment on `AmberImpactAlertDialog::isOpen()`
**Description:** The comment `// Method to check if the dialog is open` (header line 18) implies it reflects general visibility state. The implementation returns `dialogOpenFlag`, which is only set to `true` when `showEvent` confirms `gCfg->amberImpactAlertActive()`. It can return `false` even when the `QDialog` is currently visible (e.g., if the dialog was opened by another code path). The comment misleads callers about what "open" means.
**Fix:** Replace the comment with an accurate description, e.g., `// Returns true if the dialog was opened through the amber alert safety interlock and has not yet been acknowledged.`

---

**A18-3** · HIGH · No documentation on `AmberImpactAlertDialog::amberAlertDialogShowEvent(bool isLocked)`
**Description:** This public slot is the safety-critical entry point for the amber impact alert. When `isLocked` is `true`, the alert is suppressed; when `false` and the global amber alert is active, `exec()` is called blocking the UI until the driver acknowledges. The `isLocked` parameter enforces a key safety precondition. None of this is documented — not the parameter meaning, not the blocking call behaviour, and not the guard on `gCfg->amberImpactAlertActive()`.
**Fix:** Add a doc comment explaining the parameter, the precondition check, and that the method blocks via `exec()`. E.g.:
```cpp
// Conditionally displays the amber impact alert dialog in a blocking modal loop.
// isLocked: when true, the alert is suppressed (vehicle is locked/unavailable).
// The dialog is only shown if the global amber alert is currently active and the
// dialog is not already open. Blocks until the driver acknowledges by tapping the screen.
```

---

**A18-4** · LOW · Missing doc comment on `AmberImpactAlertDialog::languageChanged()`
**Description:** The public `languageChanged()` method updates UI label text for localisation. There is no comment indicating this method must be called when the application language changes or that it retranslates the two primary visible labels.
**Fix:** Add a brief comment: `// Retranslates UI labels to the current application language. Call when the locale changes.`

---

**A18-5** · LOW · Missing doc comment on `AuthorisedDialog::setHasChecklist(bool yes)`
**Description:** This method shows or hides the optional pre-operation check button. The parameter name `yes` is non-descriptive and there is no comment explaining what a "checklist" is in this context or how the visibility change affects the driver workflow.
**Fix:** Add a comment: `// Shows the optional pre-op checklist button if yes is true; hides it otherwise.`

---

**A18-6** · LOW · Missing doc comment on `AuthorisedDialog::setDriverId(quint64 id)`
**Description:** The method stores the driver ID as `m_pendingDriverId`. The ID is only consumed during `showEvent` to look up the driver's display name. This deferred/pending semantics is entirely undocumented.
**Fix:** Add a comment: `// Sets the driver ID used to look up the driver name displayed on show. Must be set before the dialog is shown.`

---

**A18-7** · LOW · Missing doc comment on `AuthorisedDialog::setTime(const QString s)`
**Description:** The method updates the time label but also conditionally shows or hides it based on the global configuration `showTime()`. The conditional hide behaviour is undocumented; callers may not realise the label can be suppressed regardless of what value is passed.
**Fix:** Add a comment: `// Updates the displayed time string. The label is hidden if ShowTime is configured off, regardless of the value passed.`

---

**A18-8** · HIGH · No documentation on `AuthorisedDialog::setPower(bool on)` and `updateCamera()`
**Description:** `setPower(bool on)` and `updateCamera()` together control hardware GPIO lines on the target device (`/sys/class/gpio/gpio37/value` and `/sys/class/gpio/gpio39/value`) that switch a physical camera on or off, including a flip control. Both methods are public with no documentation. The hardware side-effect (raw sysfs GPIO writes) is critical for safety — incorrect use could leave a reversing camera disabled. Neither method has a comment, parameter description, or explanation of the GPIO pin mapping or the conditions under which the camera is forced on regardless of arguments (`CameraForced` mode).
**Fix:** Add doc comments to both methods describing the hardware interaction, the GPIO pin semantics, the CameraForced mode override behaviour, and the role of `m_power`/`m_showCamera` flags. Example for `setPower`:
```cpp
// Sets the power state used in camera visibility decisions.
// on: true when vehicle power is on. When false, camera is turned off via GPIO
// regardless of other settings (unless CameraForced mode is active).
// See updateCamera() for full decision logic.
```

---

**A18-9** · LOW · No documentation on `AuthorisedDialog::userLogout()` signal
**Description:** The `userLogout()` signal is the primary authorisation exit event. It is emitted only after a two-press confirmation sequence with a 200 ms debounce and a 2-second confirm-state reset timer. These preconditions and the confirmation flow are not documented anywhere in the header.
**Fix:** Add a comment above the signal declaration: `// Emitted after the driver confirms logout via a two-press confirmation sequence. Connected to the main application to revoke driver authorisation.`

---

**A18-10** · LOW · Missing doc comment on `BroadcastUIDialog::setUIParam(CIGCONF::BroadcastMessage m)`
**Description:** This is the only non-trivial public configuration method on `BroadcastUIDialog`. It controls text content, warning visibility, button layout (OK vs Yes/No), and auto-dismiss timeout — all derived from fields of the `BroadcastMessage` struct. None of these behaviours are documented.
**Fix:** Add a doc comment:
```cpp
// Configures the dialog from a BroadcastMessage:
//   m.text    - message body (truncated to BROADCASTMSG_TEXT_LEN)
//   m.type    - non-zero shows the warning icon
//   m.res     - non-zero shows Yes/No buttons; zero shows OK button
//   m.timeout - non-zero starts an auto-dismiss timer (value in seconds)
```

---

**A18-11** · MEDIUM · `MessageResult` enum values `MsgResultLogout` and `MsgResultNoDriver` are undocumented and never emitted
**Description:** The `MessageResult` enum (header line 17) declares six values. `MsgResultLogout` and `MsgResultNoDriver` are never emitted in `broadcastuidialog.cpp`. There are no comments on any enum values. Callers connecting to `done(int)` or iterating result codes have no guidance on when these values can occur, which can lead to incomplete result handling.
**Fix:** Add inline comments on each enum value explaining its meaning and which code path produces it. Clarify in the header (or in associated documentation) that `MsgResultLogout` and `MsgResultNoDriver` are reserved for use by external callers or future expansion.

---

**A18-12** · MEDIUM · `messageClosed` signal declared but never emitted; no documentation
**Description:** The `messageClosed(CIGCONF::BroadcastMessage m)` signal (header line 25) is declared as the public notification interface for dialog closure. However, the implementation slots (`onYes`, `onNo`, `onOK`, and the timer lambda) all emit `done(int)` (the `QDialog` base-class mechanism), not `messageClosed`. There is no documentation explaining this discrepancy. Callers who connect to `messageClosed` will never receive the notification, silently losing message results.
**Fix:** Either emit `messageClosed` from the relevant slots or remove the signal and document that callers should connect to `QDialog::finished(int)` using `MessageResult` cast values. Add a comment regardless so the design intent is clear.

---

## Summary Table

| ID | Severity | File | Short Title |
|----|----------|------|-------------|
| A18-1 | LOW | amberimpactalertdialog.h/.cpp | Missing doc on `closeWindow()` — guard condition undocumented |
| A18-2 | MEDIUM | amberimpactalertdialog.h/.cpp | Inaccurate comment on `isOpen()` — misrepresents flag semantics |
| A18-3 | HIGH | amberimpactalertdialog.h/.cpp | No documentation on safety-critical slot `amberAlertDialogShowEvent()` |
| A18-4 | LOW | amberimpactalertdialog.h/.cpp | Missing doc on `languageChanged()` |
| A18-5 | LOW | authoriseddialog.h/.cpp | Missing doc on `setHasChecklist()` |
| A18-6 | LOW | authoriseddialog.h/.cpp | Missing doc on `setDriverId()` — pending/deferred semantics undocumented |
| A18-7 | LOW | authoriseddialog.h/.cpp | Missing doc on `setTime()` — conditional hide behaviour undocumented |
| A18-8 | HIGH | authoriseddialog.h/.cpp | No documentation on `setPower()`/`updateCamera()` — hardware GPIO side-effects |
| A18-9 | LOW | authoriseddialog.h/.cpp | No documentation on `userLogout()` signal — two-press confirmation undocumented |
| A18-10 | LOW | broadcastuidialog.h/.cpp | Missing doc on `setUIParam()` — all configuration fields undocumented |
| A18-11 | MEDIUM | broadcastuidialog.h/.cpp | `MessageResult` enum values undocumented; two values never emitted |
| A18-12 | MEDIUM | broadcastuidialog.h/.cpp | `messageClosed` signal declared but never emitted — silent connection failure |

**Totals:** 2 HIGH, 3 MEDIUM, 7 LOW
# Pass 3 Agent A19 — Documentation

**Audit run:** 2026-02-28-01
**Branch:** master
**Files reviewed:**
- `ui/checkcompleteddialog.h` + `ui/checkcompleteddialog.cpp`
- `ui/checkconfirmationdialog.h` + `ui/checkconfirmationdialog.cpp`
- `ui/checkquestiondialog.h` + `ui/checkquestiondialog.cpp`

---

## Reading Evidence

### 1. `CheckCompletedDialog` (checkcompleteddialog.h / checkcompleteddialog.cpp)

**Class name:** `CheckCompletedDialog` — inherits `QDialog`

**Public methods (header):**

| Line | Signature |
|------|-----------|
| 17 | `explicit CheckCompletedDialog(QWidget *parent = 0)` |
| 18 | `~CheckCompletedDialog()` |
| 20 | `void languageChanged(void)` |
| 21 | `bool isTimerActive()` |
| 22 | `void stopTimer()` |
| 23 | `void setCheckResponses(QList<CIGCONF::CheckResponse> &responses)` (inline) |

**Signals:**

| Name | Declared at line |
|------|-----------------|
| `openPreopNotes()` | 30 |

**Protected methods:**

| Line | Signature |
|------|-----------|
| 33 | `void showEvent(QShowEvent *event = 0)` |

**Types / constants used (from implementation):**

- `NO_ACTIVITY_TIME` — preprocessor constant defined at cpp line 5, value `10000` (milliseconds). Controls the auto-accept inactivity timeout.
- `CIGCONF::CheckResponse` — struct from `app/cigconfigs.h` with fields `id`, `type` (maps to `CIGCONF::ChecklistType`), `response` (maps to `CIGCONF::CheckResponses`), and `text`.
- `CIGCONF::ChecklistType` — enum: `NotCritical`, `CriticalByYes = 1`, `CriticalByNo = 2`
- `CIGCONF::CheckResponses` — enum: `UndefinedCheckResponse`, `CheckResponsedYes = 1`, `CheckResponsedNo = 2`

**Doc comments present:** None on any declaration.

---

### 2. `CheckConfirmationDialog` (checkconfirmationdialog.h / checkconfirmationdialog.cpp)

**Class name:** `CheckConfirmationDialog` — inherits `QDialog`

**Public methods (header):**

| Line | Signature |
|------|-----------|
| 16 | `explicit CheckConfirmationDialog(QWidget *parent = 0)` |
| 17 | `~CheckConfirmationDialog()` |
| 19 | `void confirm(bool yes)` |
| 20 | `void setQuestion(const QString &question)` |
| 21 | `void languageChanged(void)` |

**Signals:** None declared.

**Types / enums / constants:** None defined locally.

**Doc comments present:** None on any declaration.

---

### 3. `CheckQuestionDialog` (checkquestiondialog.h / checkquestiondialog.cpp)

**Class name:** `CheckQuestionDialog` — inherits `QDialog`

**Public methods (header):**

| Line | Signature |
|------|-----------|
| 17 | `explicit CheckQuestionDialog(QWidget *parent = 0)` |
| 18 | `~CheckQuestionDialog()` |
| 20 | `const QString &question() const` (inline) |
| 21 | `void setQuestion(const QString &question, bool critical = false)` |

**Signals:**

| Name | Declared at line |
|------|-----------------|
| `shown(void)` | 28 |

**Protected methods:**

| Line | Signature |
|------|-----------|
| 31 | `void showEvent(QShowEvent *event)` |

**Types / enums / constants:** None defined locally.

**Doc comments present:** None on any declaration.

---

## Documentation Findings

**A19-1** · LOW · No doc comment on `CheckCompletedDialog::languageChanged()`
**Description:** `languageChanged()` is a non-trivial method that retranslates all UI strings. The method is called externally (it is public) when the application language changes at runtime. There is no comment explaining when callers are expected to invoke it, nor that it updates UI labels. The method also duplicates the same label-setting logic that appears in `showEvent()`, which is a subtle maintenance hazard, but there is no comment alerting maintainers to this duplication.
**Fix:** Add a doc comment above the declaration, e.g.:
```
// Called by the parent widget when the application language changes at runtime.
// Re-applies translated strings to all UI labels. Note: duplicates the label
// updates in showEvent(); both must be kept in sync.
void languageChanged(void);
```

---

**A19-2** · HIGH · No doc comment on `CheckCompletedDialog::setCheckResponses()`
**Description:** `setCheckResponses()` accepts a `QList<CIGCONF::CheckResponse>` by non-const reference and stores it in `m_checkResponses`. This list is consumed during `showEvent()` to compute how many critical safety-check questions the driver failed, and the result is displayed visibly on the completion dialog. The method has no documentation explaining: (a) what constitutes a valid response list, (b) that it must be called before `show()` / `exec()` for the summary to be accurate, (c) that the parameter is taken by non-const lvalue reference (a subtle interface oddity — callers cannot pass a temporary or const list), or (d) the safety significance of the data (this is a pre-operation safety check summary visible to the operator). Missing documentation on a method that feeds safety-critical display logic is a HIGH concern.
**Fix:** Add a doc comment, e.g.:
```
// Sets the list of checklist responses used to compute the critical-question
// failure summary displayed in showEvent(). Must be called before show()/exec().
// The list is stored by value; the caller's list must remain valid until the
// dialog is shown. 'responses' is taken by non-const reference; passing a
// temporary or const list will not compile.
void setCheckResponses(QList<CIGCONF::CheckResponse> &responses) { ... }
```

---

**A19-3** · HIGH · No doc comment on `CheckCompletedDialog::stopTimer()` and `isTimerActive()`
**Description:** `CheckCompletedDialog` contains an auto-accept inactivity timer (`NO_ACTIVITY_TIME = 10000 ms`). When the timer fires it calls `accept()`, automatically advancing the workflow without any user interaction. `stopTimer()` and `isTimerActive()` are the external control points for this timer, yet neither has any documentation. Callers cannot determine: (a) what the timer does when it expires (auto-accept), (b) what side effects `stopTimer()` has versus simply hiding the dialog, or (c) why querying `isTimerActive()` is useful. Auto-accepting a safety-check completion dialog without user interaction is safety-relevant; the absence of documentation on the methods that govern this timer is a HIGH concern.
**Fix:** Add doc comments above both declarations, e.g.:
```
// Returns true if the inactivity auto-accept timer is currently running.
// The timer automatically accepts the dialog after NO_ACTIVITY_TIME ms of
// inactivity, advancing the workflow without explicit user confirmation.
bool isTimerActive();

// Stops the inactivity auto-accept timer if it is running. Call this before
// programmatically closing or hiding the dialog to prevent a spurious accept().
void stopTimer();
```

---

**A19-4** · LOW · No doc comment on `CheckCompletedDialog::openPreopNotes` signal
**Description:** The `openPreopNotes()` signal is emitted when either of the "Add notes" buttons is pressed (and the inactivity timer is stopped). There is no comment describing this signal's purpose, when it fires, or what behavior the connected slot is expected to implement. Consumers connecting to this signal must infer its semantics from the button label text, which may not be available at connection time.
**Fix:** Add a brief comment above the signal declaration:
```
// Emitted when the user taps the "Add notes" button. The inactivity timer is
// stopped before emission. Connected slot should open the pre-op notes editor.
void openPreopNotes();
```

---

**A19-5** · LOW · No doc comment on `CheckConfirmationDialog::confirm(bool yes)`
**Description:** `confirm()` is a non-trivial method that mutates the visible state of the dialog by showing either a "YES" label or a "NO" label depending on the argument. It is not merely a setter — it directly manipulates which UI element is visible. There is no comment explaining its purpose (to reflect back to the user the answer they just gave to the preceding question), when it must be called relative to `show()`, or what the `yes` parameter controls.
**Fix:** Add a doc comment, e.g.:
```
// Displays either the "YES" or "NO" confirmation label to reflect the user's
// prior answer. Pass true if the user answered yes, false for no.
// Should be called before show()/exec().
void confirm(bool yes);
```

---

**A19-6** · LOW · No doc comment on `CheckConfirmationDialog::setQuestion(const QString &question)`
**Description:** `setQuestion()` sets the question text in the confirmation dialog. There is no documentation explaining that this is the same question already answered by the user (displayed here as a reminder before they confirm), or that it must be called before `show()`.
**Fix:** Add a doc comment, e.g.:
```
// Sets the question text displayed in the confirmation dialog. Typically this
// is the same question the user just answered, shown for confirmation purposes.
// Must be called before show()/exec().
void setQuestion(const QString &question);
```

---

**A19-7** · HIGH · `CheckQuestionDialog::setQuestion()` — undocumented button-randomisation side effect
**Description:** `setQuestion()` does significantly more than set the question text. Its implementation at cpp line 24-28 uses `qrand() % 2` to randomly swap the physical screen positions of the YES and NO buttons on each call. This is a deliberate UX safety mechanism (to prevent muscle-memory tapping without reading), but it is entirely undocumented. Callers, testers, and reviewers reading only the header cannot know: (a) that button positions are randomised, (b) that `qrand()` is used (an older, non-thread-safe PRNG), or (c) that the `critical` parameter controls visibility of a "critical question" indicator label. The button-randomisation behaviour is safety-relevant: if it were inadvertently removed during a refactor the change would appear innocuous from the header alone.
**Fix:** Add a doc comment that explicitly documents the randomisation side effect and the `critical` parameter:
```
// Sets the displayed question text and configures the dialog state.
// The YES and NO button positions are randomly swapped on each call to
// prevent habitual tapping without reading. If 'critical' is true, a
// "critical question" indicator label is shown; it is hidden otherwise.
// Must be called before show()/exec().
void setQuestion(const QString &question, bool critical = false);
```

---

**A19-8** · LOW · No doc comment on `CheckQuestionDialog::shown` signal
**Description:** The `shown()` signal is emitted from `showEvent()` each time the dialog becomes visible. There is no comment describing its purpose or expected use. Consumers must inspect the implementation to understand it is a post-show notification (e.g., to trigger external timing or logging).
**Fix:** Add a brief comment:
```
// Emitted each time the dialog is shown (from showEvent). Can be used by
// callers to start timing or trigger other actions after display.
void shown(void);
```

---

**A19-9** · INFO · No doc comment on `CheckQuestionDialog::question()` getter
**Description:** The inline `question()` getter returns the last question string set via `setQuestion()`. It is a simple getter and the absence of documentation is low impact, but it is undocumented.
**Fix:** Add a brief comment:
```
// Returns the question text currently displayed in the dialog.
const QString &question() const { return m_question; }
```

---

**A19-10** · INFO · `languageChanged()` undocumented on both `CheckConfirmationDialog` and `CheckQuestionDialog` (no `languageChanged` in `CheckQuestionDialog`, but present in both others)
**Description:** `CheckConfirmationDialog::languageChanged()` has the same pattern as the other dialogs — it is a public, externally-called method that re-applies translated UI strings — yet carries no documentation. (Note: `CheckQuestionDialog` does not expose a `languageChanged()` method, but its counterpart in `setQuestion()` re-applies `tr("YES")` / `tr("NO")` on each call, so language changes are handled implicitly there.)
**Fix:** Add a doc comment above `CheckConfirmationDialog::languageChanged()`:
```
// Called by the parent widget when the application language changes at runtime.
// Re-applies translated strings to all UI labels and buttons.
void languageChanged(void);
```

---

## Summary Table

| ID | Severity | File | Method / Symbol | Issue |
|----|----------|------|-----------------|-------|
| A19-1 | LOW | checkcompleteddialog.h | `languageChanged()` | No doc comment; duplicated logic not flagged |
| A19-2 | HIGH | checkcompleteddialog.h | `setCheckResponses()` | No doc on safety-critical data-setter; non-const ref interface undocumented |
| A19-3 | HIGH | checkcompleteddialog.h | `stopTimer()` / `isTimerActive()` | No doc on auto-accept timer control — safety-relevant behaviour |
| A19-4 | LOW | checkcompleteddialog.h | `openPreopNotes` signal | No doc comment on signal semantics |
| A19-5 | LOW | checkconfirmationdialog.h | `confirm(bool yes)` | No doc on UI-mutating method |
| A19-6 | LOW | checkconfirmationdialog.h | `setQuestion()` | No doc comment |
| A19-7 | HIGH | checkquestiondialog.h | `setQuestion()` | Undocumented safety-critical button-randomisation side effect |
| A19-8 | LOW | checkquestiondialog.h | `shown` signal | No doc comment |
| A19-9 | INFO | checkquestiondialog.h | `question()` getter | No doc comment |
| A19-10 | INFO | checkconfirmationdialog.h | `languageChanged()` | No doc comment |

**Totals:** 3 HIGH, 4 LOW, 3 INFO
# Pass 3 Agent A20 — Documentation

**Audit run:** 2026-02-28-01
**Branch:** master
**Files reviewed:**
- `ui/checkstartdialog.h` + `ui/checkstartdialog.cpp`
- `ui/commentdialog.h` + `ui/commentdialog.cpp`
- `ui/dialog.h` + `ui/dialog.cpp`

---

## Reading Evidence

### `ui/checkstartdialog.h` / `ui/checkstartdialog.cpp`

**Class:** `CheckStartDialog` (extends `QDialog`)

**Public methods:**

| Line (header) | Method | Doc comment present? |
|---|---|---|
| 15 | `explicit CheckStartDialog(QWidget *parent = 0)` | No |
| 16 | `~CheckStartDialog()` | No |
| 17 | `void setMandatory(bool mandatory)` | No |
| 18 | `void languageChanged(void)` | No |

**Signals:** None declared.

**Slots:** None declared (uses `QDialog::accept` directly via `connect`).

**Types, enums, constants:** None.

**Implementation notes:**
- `setMandatory(bool mandatory)`: Shows/hides two UI label widgets (`labelTip12` for optional, `labelTip21` for mandatory) to change the on-screen message that precedes the pre-op safety check start prompt. This has a direct safety implication — it controls whether the operator sees "optional" or "mandatory" wording before a pre-op check.
- `languageChanged()`: Updates all translatable strings in the dialog.

---

### `ui/commentdialog.h` / `ui/commentdialog.cpp`

**Class:** `CommentDialog` (extends `QDialog`)

**Public methods:**

| Line (header) | Method | Doc comment present? |
|---|---|---|
| 26 | `explicit CommentDialog(CommentDialogType type, QWidget *parent = nullptr)` | No |
| 27 | `~CommentDialog()` | No |
| 29 | `void UpdateTextInput(QString str, onScreenKeyboard::CtrlButton ctrl)` | No |
| 30 | `void onkeyboardClosed()` | No |
| 31 | `void onUnlkReasonSelected()` | No |
| 32 | `void languageChanged()` | No |

**Signals:** None explicitly declared (inherits `QDialog::accepted` / `QDialog::rejected`).

**Private slots:**
- `run_keyboard_lineEdit()` (line 51)
- `onDone()` (line 52)
- `onSkip()` (line 53)

**Protected overrides:**
- `showEvent(QShowEvent *event = 0)` (line 47)
- `hideEvent(QHideEvent *)` (line 48)

**Types, enums, constants:**
- `enum CommentDialogType { Unlock, Preop }` (line 15) — no doc comment
- `#define NO_ACTIVITY_TIME 10000` (line 12) — no doc comment (units are milliseconds; value is 10 seconds inactivity timeout)
- `#define MAX_CHARACTER 100` (line 13) — no doc comment (maximum text input length)

**Implementation notes:**
- Constructor takes a `CommentDialogType` to configure the dialog for either unlock-reason or pre-op comment entry.
- `UpdateTextInput` is called by the on-screen keyboard to insert or delete characters; it enforces `MAX_CHARACTER` limit.
- `onkeyboardClosed()` is called as a signal handler to reconnect the selection-changed signal after the keyboard closes; it is declared `public` but functions as an event sink.
- `onUnlkReasonSelected()` is called when the user picks a reason from the `UnlockReasonDialog` dropdown and copies the selected text into the text box; declared `public` but functions as a slot.
- `onDone()` and `onSkip()` implement a two-tap confirm pattern and a 200 ms debounce. `onDone` persists the unlock reason or pre-op comment string to `gCfg` before accepting. `onSkip` clears the stored strings and rejects.
- `reset()`: Resets `m_lastPress` to zero and re-runs `showEvent()` after the `NO_ACTIVITY_TIME` inactivity timer fires.

---

### `ui/dialog.h` / `ui/dialog.cpp`

**Class:** `Dialog` (extends `QDialog`) — central UI orchestrator for the entire application.

**Public methods:**

| Line (header) | Method | Doc comment present? |
|---|---|---|
| 44 | `explicit Dialog(QWidget *parent = 0)` | No |
| 45 | `~Dialog()` | No |
| 47 | `void onPowerChanged(CIGCONF::PowerState powerState)` | No |
| 48 | `void onReboot()` | No |
| 49 | `void onBleReady(bool yes)` | No |
| 50 | `void onNetworkReady(bool yes)` | No |
| 51 | `void onCardAuthorised(bool yes, quint64)` | No |
| 52 | `void onCmdLogin(quint64 id)` | No |
| 53 | `void onIdleTimeout()` | No |
| 54 | `void lockScreen(CIGCONF::MaintLockedCode code, bool remote)` | No |
| 55 | `void ambertImpactScreen()` (note: typo — "ambert") | No |
| 57 | `void updateLux(int lux)` | No |
| 58 | `void updateStatus(QByteArray IO, bool Rly1, bool Rly2, QByteArray can, const QByteArray &rssi, const QByteArray &moni, bool netStat, bool modemStat, bool wifiStat, qint8 sat, qint32 lat, qint32 lon)` | No |
| 59 | `void updateBatteryStatus(bool avail, int state, int fault, quint16 voltage, qint16 current, quint16 temp, quint16 remainingCapacity)` | No |
| 60 | `void updateExpModInfo(QByteArray mainVersion)` | No |
| 61 | `void onBroadcastMsgReceived(CIGCONF::BroadcastMessage m)` | No |
| 62 | `void showInformationScreen()` | No |
| 63 | `void updateLoginImage()` | No |
| 64 | `void quickPowerUpdate(bool on)` | No |
| 66 | `void onDemandStarted(quint32 start, quint32 end, quint64 id, CIGCONF::OnDemandCmdSrc src)` | No |
| 67 | `void onDemandExtended(quint32 start, quint32 end, quint64 id, CIGCONF::OnDemandCmdSrc src)` | No |
| 68 | `void onDemandEnded(quint32 end, quint64 id, CIGCONF::OnDemandCmdSrc src)` | No |
| 70 | `void onLanguageChanged(void)` | No |
| 72 | `void updateCamera()` | No |

Total public methods (excluding constructor/destructor): 23.

**Signals (lines 79–89):**

| Line | Signal | Doc comment present? |
|---|---|---|
| 79 | `void driverChanged(quint64 id)` | No |
| 80 | `void lastCheckDriverChanged(quint64 id)` | No |
| 81 | `void screenLocked(CIGCONF::MaintLockedCode code)` | No |
| 82 | `void setRelayOut(bool on1, bool on2)` | No |
| 83 | `void setRelay2Out(bool on)` | No |
| 84 | `void sendGmtpMessage(CIGCONF::GmtpMessage msg, const QByteArray &extra = QByteArray())` | No |
| 85 | `void resetCanStates(bool resetLast)` | No |
| 86 | `void forceBroadcastUIClose()` | No |
| 87 | `void log(QByteArray &msg)` | No |
| 88 | `void updatePreopTimer(QString timeout)` | No |
| 89 | `void amberDialogAboutToShow(bool isLocked)` | No |

Total signals: 11. None have doc comments.

**Types, enums, constants defined:** None directly in `dialog.h` (all referenced types are from `app/globalconfigs.h` and other headers).

**Private struct:**
- `BroadcastMessageResponse { quint32 id; quint64 driverId; quint32 dispTimestamp; }` — no doc comment.

**Key implementation notes for safety/security-critical public methods:**
- `lockScreen(CIGCONF::MaintLockedCode code, bool remote)`: Controls vehicle lock/unlock state. When `code != MaintNormal`, sets `m_locked = true`, opens the locked dialog, de-asserts relay 2, and emits `screenLocked`. When `code == MaintNormal` and `remote == true` and already locked, performs logout and clears the lock state. Skips locking if a power-off/reboot message is displayed or if convor status is active.
- `onCardAuthorised(bool yes, quint64 id)`: Processes the authorisation response from the server. Only acts if the pending message type is `WaitForAuthorised` and the ID matches the pending driver. Grants access (`openMenuDialog`) or sets `NotAuthorised`.
- `onCmdLogin(quint64 id)`: Simulates a card swipe by forwarding to `onCardSwiped` with `beep = false`; allows remote command login.
- `onIdleTimeout()`: Clears all UI widgets, logs an idle timeout GMTP message, optionally locks the screen (`MaintIdle`), and logs out the driver.
- `quickPowerUpdate(bool on)`: Directly gates card-reading capability by setting `m_power`; if `m_power == false`, `onCardSwiped` returns immediately without processing.
- `onDemandStarted/Extended/Ended`: Manage a timed vehicle access window; emit GMTP messages and mutate `gCfg` on-demand state.
- `setRelayOut(bool on1, bool on2)` (signal): Controls physical output relays that gate vehicle power/start.

---

## Findings

**A20-1** · HIGH · No documentation on any `Dialog` public method

**Description:** The `Dialog` class is the central UI orchestrator of the entire application. It exposes 23 public methods and 11 signals, none of which have any form of doc comment in the header. Several of these methods have direct safety and security implications: `lockScreen` controls the physical vehicle lock state and relay outputs; `onCardAuthorised` processes driver authorisation results; `onCmdLogin` accepts a remote login command; `quickPowerUpdate` gates whether card swipes are processed; and the relay signals `setRelayOut`/`setRelay2Out` directly control hardware that enables vehicle operation. The absence of documentation makes it impossible to verify intended preconditions, parameter semantics, or expected caller behaviour from the header alone.

**Fix:** Add a doc comment above every public method declaration in `ui/dialog.h`. At minimum, describe: (1) the purpose of the method; (2) the meaning and valid range of each parameter; (3) any preconditions or state the caller must ensure; (4) what side-effects or signals are emitted as a result. For safety-critical methods (`lockScreen`, `onCardAuthorised`, `onCmdLogin`, `quickPowerUpdate`, relay signals), include explicit notes about security boundaries and failure modes.

---

**A20-2** · HIGH · No documentation on `Dialog` signals

**Description:** All 11 signals emitted by `Dialog` are undocumented. These signals cross the boundary between the UI layer and the application/hardware layer: `setRelayOut` and `setRelay2Out` control physical vehicle relays; `sendGmtpMessage` sends protocol messages over the communications stack; `screenLocked` propagates lock-state changes to subscribers; `driverChanged` and `lastCheckDriverChanged` notify subscribers of driver identity changes. Without documentation, callers cannot determine the sequence in which signals are expected to fire, what state invariants hold when they fire, or whether they may fire from non-main threads.

**Fix:** Add a doc comment above each signal in `ui/dialog.h` describing: what event triggers the signal; what each parameter represents; whether the signal is guaranteed to fire on the main/GUI thread; and any ordering constraints relative to other signals.

---

**A20-3** · HIGH · No documentation on `lockScreen` — safety-critical access-control method

**Description:** `lockScreen(CIGCONF::MaintLockedCode code, bool remote)` is the single entry point that transitions the device between locked and unlocked physical states. Its behaviour is non-trivial and non-obvious: the `remote` parameter changes the method's logic significantly (a remote `MaintNormal` lock triggers a full logout; a local `MaintNormal` code is silently ignored if the device is not already locked). The conditions under which locking is suppressed (active power-off message, convor status active) are invisible to callers reading only the header. A maintenance engineer reading the header cannot determine safe calling conventions.

**Fix:** Document `lockScreen` with: the meaning of `code` (reference the `CIGCONF::MaintLockedCode` enum values and their effect); the meaning of `remote` (remote vs local trigger path, and how it affects `MaintNormal` handling); the conditions under which the call is a no-op; which signals are emitted as a result; and any preconditions (e.g. must be called from the main thread).

---

**A20-4** · HIGH · No documentation on `onCmdLogin` — remote login entry point

**Description:** `onCmdLogin(quint64 id)` accepts a driver ID from an external command source and directly invokes the card-swipe login path (`onCardSwiped`) with the beeper suppressed. There is no documentation indicating: the source of the `id`; whether the `id` has been validated or sanitised by the caller; what authentication or authorisation checks are applied; or what happens if the device is in a locked state when the command arrives. The method's public visibility means it is part of the class's contract surface, yet it performs security-relevant actions without any explanatory text.

**Fix:** Document the caller contract: specify who may call this method (e.g. GMTP command handler); state whether `id` is expected to be a pre-validated identifier; clarify that the same `isValidId` / authorisation flow as a physical card swipe is applied; and note that no beep is emitted.

---

**A20-5** · HIGH · No documentation on `setRelayOut` / `setRelay2Out` signals — hardware control

**Description:** `setRelayOut(bool on1, bool on2)` and `setRelay2Out(bool on)` are signals that, when connected in the application, directly control physical output relays governing vehicle power or start circuits. They are emitted from multiple call sites inside `Dialog` with varying `on1`/`on2` values (e.g. `(true, false)` during checklist, `(true, true)` after authorisation, `(false, false)` on logout or lock). There is no documentation explaining what relay 1, relay 2, or the second relay-only signal control in hardware terms, nor any description of the safety implications of incorrect emission.

**Fix:** Document each signal to explain what physical output each boolean controls, what the safe default state is, and under what application conditions each relay should be asserted or de-asserted.

---

**A20-6** · MEDIUM · `onkeyboardClosed` and `onUnlkReasonSelected` declared public but function as internal event sinks

**Description:** In `ui/commentdialog.h`, `onkeyboardClosed()` (line 30) and `onUnlkReasonSelected()` (line 31) are declared `public`. Both are wired up solely via `connect()` in the constructor and are never intended to be called directly by external code. Their public visibility is misleading — a caller may attempt to invoke them directly, which would reconnect a signal/slot pair that should only be reconnected once the keyboard closes, or copy the selected unlock reason value at an unexpected time. No documentation warns against direct invocation.

**Fix:** Move `onkeyboardClosed` and `onUnlkReasonSelected` to `private slots:` (they are already effectively slots). If the public visibility is required for the `connect` call, add a comment explaining the coupling. At minimum, add a doc comment on each stating "Do not call directly; connected as a signal handler."

---

**A20-7** · MEDIUM · `CommentDialogType` enum and `NO_ACTIVITY_TIME` / `MAX_CHARACTER` macros are undocumented

**Description:** The `CommentDialogType` enum (`Unlock`, `Preop`) at line 15 of `commentdialog.h` controls whether the dialog collects an unlock reason (persisted to `gCfg->unlkReasonString`) or a pre-op comment (persisted to `gCfg->preopCommentString`). The distinction affects which GMTP messages are sent and whether the "real impact" buttons are shown. The macros `NO_ACTIVITY_TIME` (10000 ms inactivity before reset) and `MAX_CHARACTER` (100 character input limit) impose security-relevant constraints with no explanation. Without documentation, a developer modifying the timeout or character limit may not appreciate the downstream effects.

**Fix:** Add a brief comment above the `CommentDialogType` enum explaining the two modes. Add inline comments on the macros explaining their units (`NO_ACTIVITY_TIME` is in milliseconds) and the rationale for the chosen values (e.g. why 100 characters, why 10 seconds).

---

**A20-8** · LOW · `setMandatory` in `CheckStartDialog` is undocumented

**Description:** `setMandatory(bool mandatory)` (line 17 of `checkstartdialog.h`) controls whether the pre-op check start dialog displays "optional" or "mandatory" text to the operator. This has a direct operator-facing safety implication: showing the wrong label may cause an operator to believe a mandatory safety check is optional. There is no doc comment explaining the parameter or the UI effect.

**Fix:** Add a comment above the declaration, e.g.: `// Sets whether the pre-op check is presented as mandatory (true) or optional (false). // Controls which tip label is shown on the start dialog.`

---

**A20-9** · LOW · `UpdateTextInput` in `CommentDialog` is undocumented

**Description:** `UpdateTextInput(QString str, onScreenKeyboard::CtrlButton ctrl)` (line 29 of `commentdialog.h`) is the keyboard input handler. It processes Backspace, Delete, and character insertion, and silently truncates input beyond `MAX_CHARACTER`. The parameter types are non-obvious to a caller who is not familiar with the `onScreenKeyboard::CtrlButton` enum. No documentation describes expected values or the truncation behaviour.

**Fix:** Add a doc comment describing the `ctrl` parameter values and their effect, the role of `str` (text to insert for non-control keys), and the `MAX_CHARACTER` truncation behaviour.

---

**A20-10** · LOW · `quickPowerUpdate` is undocumented and its gating role is non-obvious

**Description:** `quickPowerUpdate(bool on)` (line 64 of `dialog.h`) sets `m_power` and forwards the state to `m_authorisedDialog`. What is non-obvious from the name alone is that when `on == false`, the `onCardSwiped` handler returns immediately without processing any card data, effectively disabling all RFID authentication. This is a security-relevant side effect that is invisible without reading the implementation.

**Fix:** Add a doc comment clarifying that this method controls whether the device accepts card-swipe authentication events, in addition to updating the authorised-dialog power indicator.

---

**A20-11** · LOW · `onBroadcastMsgReceived` is undocumented and has a non-obvious no-driver path

**Description:** `onBroadcastMsgReceived(CIGCONF::BroadcastMessage m)` (line 61 of `dialog.h`) silently discards broadcast message display and sends a `MsgResultNoDriver` GMTP response when no driver is logged in, instead of queuing the message for later display. This behaviour is a deliberate design decision but is completely invisible from the header.

**Fix:** Add a doc comment noting the no-driver fast-path: when no driver is currently logged in, the message is not queued and an immediate no-driver response is emitted.

---

**A20-12** · INFO · `languageChanged` methods are undocumented across all three classes

**Description:** `CheckStartDialog::languageChanged()`, `CommentDialog::languageChanged()`, and `Dialog::onLanguageChanged()` all re-translate UI strings but have no doc comment. These are low-risk but form part of the public/notification API.

**Fix:** Add a one-line comment on each stating that the method must be called when the application locale changes to refresh all displayed strings.

---

## Summary Table

| ID | Severity | Title |
|---|---|---|
| A20-1 | HIGH | No documentation on any `Dialog` public method (23 methods) |
| A20-2 | HIGH | No documentation on any `Dialog` signal (11 signals) |
| A20-3 | HIGH | `lockScreen` — safety-critical access-control method undocumented |
| A20-4 | HIGH | `onCmdLogin` — remote login entry point undocumented |
| A20-5 | HIGH | `setRelayOut` / `setRelay2Out` — hardware relay control signals undocumented |
| A20-6 | MEDIUM | `onkeyboardClosed` and `onUnlkReasonSelected` misleadingly public without documentation |
| A20-7 | MEDIUM | `CommentDialogType` enum and `NO_ACTIVITY_TIME` / `MAX_CHARACTER` macros undocumented |
| A20-8 | LOW | `setMandatory` in `CheckStartDialog` undocumented |
| A20-9 | LOW | `UpdateTextInput` in `CommentDialog` undocumented |
| A20-10 | LOW | `quickPowerUpdate` gating role undocumented |
| A20-11 | LOW | `onBroadcastMsgReceived` no-driver discard path undocumented |
| A20-12 | INFO | `languageChanged` methods undocumented across all three classes |

**Totals:** 5 HIGH, 2 MEDIUM, 4 LOW, 1 INFO
# Pass 3 Agent A21 — Documentation

**Audit run:** 2026-02-28-01
**Branch:** master
**Repo root:** C:/Projects/cig-audit/repos/mark3-pvd
**Files reviewed:**
- `ui/informationdialog.h` + `ui/informationdialog.cpp`
- `ui/keyfilter.h` + `ui/keyfilter.cpp`
- `ui/languagedialog.h` + `ui/languagedialog.cpp`

---

## Reading Evidence

### `ui/informationdialog.h` — Class: `InformationDialog`

Inherits: `QDialog`

**Public methods (header line numbers):**

| Line | Method |
|------|--------|
| 21 | `explicit InformationDialog(QWidget *parent = 0)` |
| 22 | `~InformationDialog()` |
| 23 | `void updateInformationScreen()` |
| 24 | `void setLux(int lux)` |
| 25 | `void setStatus(QByteArray IO, bool Rly1, bool Rly2, QByteArray can, const QByteArray &rssi, const QByteArray &moni, bool netStat, bool mdemStat, bool wifiStat, qint8 sat, qint32 lat, qint32 lon)` |
| 26 | `void setConfigParam()` |
| 27 | `void setBatteryStatus(bool avail, int state, int fault, quint16 voltage, qint16 current, quint16 temp, quint16 remainingCapacity)` |
| 28 | `void setExpModInfo(QByteArray mainVersion)` |
| 29 | `void setSuperMasterStatus()` |
| 30 | `void setVOR()` |
| 31 | `void setLastWiegand(quint64 id)` |
| 32 | `void languageChanged()` |

**Protected methods:**

| Line | Method |
|------|--------|
| 35 | `void showEvent(QShowEvent *)` |
| 36 | `void hideEvent(QHideEvent *)` |

**Signals:** None declared.

**Slots:** None declared (timer slot is connected anonymously via `connect`).

**Types / enums / constants defined:** None in header.
`UPDATE_CONFIG_TIMER_MS` (value: 5000) defined in `.cpp` at line 9 as a `#define`.

**Private members:**
- `Ui::InformationDialog *ui`
- `QMap<int, QString> m_chargeStatusMap` — maps charge state integer to translated string
- `QMap<int, QString> m_chargeFaultMap` — maps fault integer to translated string
- `QTimer *m_updateConfigTmr` — periodic refresh timer

---

### `ui/keyfilter.h` — Class: `KeyFilter`

Inherits: `QObject`

**Public methods (header line numbers):**

| Line | Method |
|------|--------|
| 12 | `explicit KeyFilter(QObject *parent = nullptr)` |
| 13 | `static bool isPowerKeyPressed()` — inline, returns `m_powerKeyPressed` |

**Signals:**

| Line | Signal |
|------|--------|
| 16 | `void showInfoDialog()` |

**Protected methods:**

| Line | Method |
|------|--------|
| 18 | `bool eventFilter(QObject *obj, QEvent *event)` |

**Private methods:**

| Line | Method |
|------|--------|
| 34 | `void resetKeyCount()` |
| 35 | `void incrementKeyCount(int key)` |
| 36 | `int getKeyCount(int key)` |
| 37 | `void resetKeyCounter(int key)` |
| 38 | `bool getPressState(int key)` |
| 39 | `void setPressState(int key, bool state)` |

**Private static members:**
- `static bool m_powerKeyPressed` — tracks whether the Return key (mapped to power key) is currently held

**Private instance members:**
- `QSet<int> m_pressedKeys` — set of currently depressed key codes
- `QTimer *m_timer` — 1.5-second debounce/sequence timer
- `int m_leftKeyCount`, `m_rightKeyCount`, `m_upKeyCount`, `m_downKeyCount` — consecutive single-key press counters
- `bool m_leftKeyPressed`, `m_rightKeyPressed`, `m_upKeyPressed`, `m_downKeyPressed` — per-key press state flags (note: `m_rightKeyPressed`, `m_upKeyPressed`, `m_downKeyPressed` are not initialised in constructor)

**Types / enums / constants defined:** None.

---

### `ui/languagedialog.h` — Class: `LanguageDialog`

Inherits: `QDialog`

**Public methods (header line numbers):**

| Line | Method |
|------|--------|
| 15 | `explicit LanguageDialog(QWidget *parent = nullptr)` |
| 16 | `~LanguageDialog()` |
| 17 | `void languageChanged()` |
| 18 | `void startScreenTimeout()` |

**Signals:**

| Line | Signal |
|------|--------|
| 21 | `void sigLanguageChanged()` |

**Private slots:**

| Line | Slot |
|------|------|
| 24 | `void on_btnEnglish_clicked()` |
| 25 | `void on_btnSpanish_clicked()` |
| 26 | `void on_btnQuit_clicked()` |

**Protected methods:**

| Line | Method |
|------|--------|
| 29 | `void showEvent(QShowEvent *event = 0)` |

**Private methods:**

| Line | Method |
|------|--------|
| 34 | `bool debounce()` |

**Types / enums / constants defined:** None in header.
`NO_ACTIVITY_TIME` (value: 10000) defined in `.cpp` at line 10 as a `#define`.

**Private members:**
- `Ui::LanguageDialog *ui`
- `QTimer *m_timer` — auto-reject timer fired after `NO_ACTIVITY_TIME` ms of inactivity
- `quint32 m_lastPress` — timestamp of last button press, used by `debounce()`

---

## Documentation Checks

### InformationDialog

1. **`InformationDialog(QWidget *parent = 0)`** — No doc comment. Constructor initialises the UI, reads `/proc/version` and `/home/root_version` from the filesystem, generates a version barcode, and sets up a periodic refresh timer. Non-trivial behaviour; not documented.
2. **`~InformationDialog()`** — No doc comment. Simple destructor; INFO-level only.
3. **`updateInformationScreen()`** — No doc comment. Called periodically by `m_updateConfigTmr`; refreshes config params, super-master status, and VOR status.
4. **`setLux(int lux)`** — No doc comment. Simple setter displaying lux value.
5. **`setStatus(...)`** — No doc comment. 12-parameter method updating relay state, signal strength, network/modem/WiFi connection state, digital IO, CAN, MONI, and GPS data. Very non-trivial; none of the parameters are described.
6. **`setConfigParam()`** — No doc comment. Reads from global config and populates the Configuration tab; also reads `/sys/class/net/wlan0/address` directly. Non-trivial side effects not documented.
7. **`setBatteryStatus(...)`** — No doc comment. 7-parameter method covering battery presence, charge state, fault code, voltage, current, temperature, and remaining capacity. None described.
8. **`setExpModInfo(QByteArray mainVersion)`** — No doc comment. Simple one-line setter.
9. **`setSuperMasterStatus()`** — No doc comment. Reads on-demand/super-master state from global config and derives remaining time; non-trivial logic.
10. **`setVOR()`** — No doc comment. Simple display toggle for VOR (Vehicle Off Road?) status.
11. **`setLastWiegand(quint64 id)`** — No doc comment. Displays last scanned Wiegand credential ID. Wiegand IDs are security-relevant data.
12. **`languageChanged()`** — No doc comment. Retranslates all UI strings and also re-opens `/sys/class/net/wlan0/address`; the file I/O side effect is not obvious from the signature.

### KeyFilter

1. **`KeyFilter(QObject *parent = nullptr)`** — No doc comment. Sets up a 1.5-second key-sequence timer.
2. **`isPowerKeyPressed()`** — No doc comment. Returns static flag tracking whether the Return/power key is currently held. The mapping of Qt::Key_Return to a "power key" concept is entirely undocumented; this is safety-relevant (vehicle power control).
3. **`showInfoDialog` (signal)** — No doc comment. Emitted under two conditions: (a) simultaneous Left+Up+Down chord, or (b) any single directional key pressed 4 times within 1.5 seconds. Neither trigger condition is documented.
4. **`eventFilter(QObject *obj, QEvent *event)`** — No doc comment. This is the core logic method; handles both key-press and key-release events, drives the power-key state machine, and triggers the info dialog. Completely undocumented.

### LanguageDialog

1. **`LanguageDialog(QWidget *parent = nullptr)`** — No doc comment. Standard constructor.
2. **`~LanguageDialog()`** — No doc comment. Simple destructor.
3. **`languageChanged()`** — No doc comment. Re-applies translated strings to all UI elements.
4. **`startScreenTimeout()`** — No doc comment. Starts a 10-second single-shot timer that calls `reject()` on expiry (closing the dialog). The caller-facing behaviour (auto-dismiss after 10 s) is not documented.
5. **`sigLanguageChanged` (signal)** — No doc comment. Emitted when English or Spanish is successfully set.

---

## Findings

**A21-1** · LOW · No documentation on `InformationDialog` constructor

**Description:** The constructor (`informationdialog.h` line 21) has no doc comment. Its behaviour extends well beyond field initialisation: it reads two system files (`/proc/version`, `/home/root_version`), generates a barcode checksum from combined version strings, populates charge-status and fault lookup maps, and wires the periodic refresh timer. None of these responsibilities are signalled by the declaration.

**Fix:** Add a comment above the declaration summarising the constructor's responsibilities, particularly the filesystem reads and barcode generation, so maintainers understand why the constructor can fail or produce different visual output in restricted environments.

---

**A21-2** · LOW · No documentation on `updateInformationScreen()`

**Description:** `updateInformationScreen()` (`informationdialog.h` line 23) is called on a timer every 5 seconds. There is no comment explaining its purpose, its trigger mechanism, or which subset of the display it refreshes (config params, super-master status, VOR — but not hardware versions or battery status).

**Fix:** Add a brief comment noting that this is the periodic-refresh callback and listing which sub-methods it invokes.

---

**A21-3** · LOW · No documentation on `setStatus()` — 12-parameter method with no parameter descriptions

**Description:** `setStatus()` (`informationdialog.h` line 25) takes 12 parameters covering physically distinct subsystems: relay states, CAN bus attributes, RSSI (supplied as a hex-encoded `QByteArray`), MONI data, network/modem/WiFi connection booleans, and GPS coordinates encoded as raw `qint32` values. None of the parameters are described. The encoding of `rssi` as a hex-ASCII `QByteArray` (converted via `.toInt(nullptr,16)` at runtime) is particularly opaque.

**Fix:** Add a parameter-level comment block describing each argument, including the hex-encoding convention for `rssi` and the raw fixed-point/integer units for `lat`/`lon`.

---

**A21-4** · LOW · No documentation on `setBatteryStatus()` — 7-parameter method with no parameter descriptions

**Description:** `setBatteryStatus()` (`informationdialog.h` line 27) accepts battery presence flag, charge-state code, fault code, voltage (mV), current (mA), temperature (degC), and remaining capacity (%). The units and the expected integer ranges for `state` and `fault` (valid values 0–3 per the lookup maps) are not documented anywhere in the header.

**Fix:** Add a comment above the declaration enumerating the valid range and unit for each parameter, particularly the integer code parameters `state` and `fault`.

---

**A21-5** · LOW · No documentation on `setConfigParam()`

**Description:** `setConfigParam()` (`informationdialog.h` line 26) populates the entire Configuration tab from the global config object. A notable undocumented side effect is that it also reads `/sys/class/net/wlan0/address` directly to populate the WiFi MAC label. This filesystem access is not apparent from the declaration.

**Fix:** Add a comment noting that this method reads from `gCfg` for most fields, but also directly reads the WiFi MAC address from the sysfs interface.

---

**A21-6** · LOW · No documentation on `setSuperMasterStatus()`

**Description:** `setSuperMasterStatus()` (`informationdialog.h` line 29) implements non-trivial logic: it checks on-demand active state, vehicle-enabled state, and computes remaining time by subtracting the local timestamp from the end time. The result is formatted as a `QDateTime` from `fromSecsSinceEpoch(timeRemaining)` — a potentially confusing calculation that treats a duration as an epoch. None of this is documented.

**Fix:** Add a comment describing the three display states (Inactive / Active-Vehicle-Disabled / Active-with-countdown) and note the timestamp arithmetic.

---

**A21-7** · MEDIUM · `languageChanged()` documentation omits file I/O side effect

**Description:** `languageChanged()` (`informationdialog.h` line 32) is named and appears to only re-translate UI strings. However, the implementation (`informationdialog.cpp` lines 306–309) also opens `/sys/class/net/wlan0/address` and sets the WiFi MAC label to `"na"` if the file cannot be opened. This file I/O side effect is entirely absent from the declaration and from any comment. Additionally, this is the second place this file is read (the first being `setConfigParam()`), but the two calls handle the absent-interface case differently: `setConfigParam()` simply skips the label update, while `languageChanged()` actively writes `"na"`.

**Fix:** Add a comment documenting the file I/O side effect and the divergent fallback behaviour relative to `setConfigParam()`. Ideally the inconsistency should be resolved, but at minimum it must be documented.

---

**A21-8** · HIGH · `isPowerKeyPressed()` has no documentation; Qt::Key_Return mapped to power key silently

**Description:** `isPowerKeyPressed()` (`keyfilter.h` line 13) is the sole public API by which other components determine whether the physical power key is currently held. There is no comment anywhere explaining that `Qt::Key_Return` is the hardware mapping for the power button on this device. A developer unfamiliar with the hardware would have no reason to associate the Return key with power state. The function is also a static accessor on `m_powerKeyPressed`, yet the class name and method name give no hint about this mapping. This is safety-relevant: incorrect interpretation of this flag could affect vehicle power management decisions.

**Fix:** Add a doc comment above the declaration stating that on this hardware platform Qt::Key_Return is the power key, explaining what "pressed" means (key held down, not a single press event), and noting the static scope.

---

**A21-9** · HIGH · `eventFilter()` has no documentation; dual trigger conditions for `showInfoDialog` are undocumented

**Description:** `eventFilter()` (`keyfilter.h` line 18) is the class's core logic method. It intercepts all key events for the application and implements two separate activation sequences for `showInfoDialog`: (1) simultaneous chord of Left+Up+Down, and (2) any single directional key pressed 4 consecutive times within 1.5 seconds. It also manages the power-key state machine. None of this is documented. The security implication is that an undocumented key sequence grants access to the information/diagnostic dialog, which could expose sensitive system configuration (GMTP server addresses, APN credentials, maintenance codes, Wiegand IDs).

**Fix:** Add a doc comment above the declaration describing both activation sequences, the power-key tracking responsibility, and a note that the method always returns `true` for all key events (consuming them, preventing propagation), which has UI-wide implications.

---

**A21-10** · LOW · `showInfoDialog` signal has no documentation

**Description:** The `showInfoDialog` signal (`keyfilter.h` line 16) is emitted under two distinct key-sequence conditions that are opaque from the name alone. There is no comment.

**Fix:** Add a comment above the signal declaration listing both trigger conditions (Left+Up+Down chord; 4× single directional key within 1.5 s).

---

**A21-11** · LOW · `startScreenTimeout()` has no documentation

**Description:** `startScreenTimeout()` (`languagedialog.h` line 18) starts a timer that auto-dismisses the dialog via `reject()` after 10 seconds of inactivity. The timeout duration and the dismissal mechanism (`reject()` vs `accept()`) are not documented. Callers cannot determine the timeout period or the returned dialog result code without reading the implementation.

**Fix:** Add a comment stating the timeout period (10 s, sourced from `NO_ACTIVITY_TIME`) and that expiry calls `reject()`.

---

**A21-12** · LOW · `sigLanguageChanged` signal has no documentation

**Description:** `sigLanguageChanged` (`languagedialog.h` line 21) is emitted only when `setLanguage()` returns a non-negative value (success). The condition for emission (successful language change, not merely a button click) is not documented.

**Fix:** Add a brief comment noting that the signal is emitted only when the language change succeeds (i.e., `setLanguage()` returns >= 0).

---

**A21-13** · INFO · Destructor, simple setter, and trivial accessor declarations lack doc comments

**Description:** The following declarations have no doc comments but are simple enough that the omission is informational only:
- `InformationDialog::~InformationDialog()` (line 22) — standard UI delete
- `InformationDialog::setLux(int lux)` (line 24) — single-label setter
- `InformationDialog::setExpModInfo(QByteArray mainVersion)` (line 28) — single-label setter
- `InformationDialog::setLastWiegand(quint64 id)` (line 31) — single-label setter
- `InformationDialog::setVOR()` (line 30) — binary display toggle
- `LanguageDialog::~LanguageDialog()` (line 16) — standard UI delete
- `LanguageDialog::languageChanged()` (line 17) — retranslates UI strings
- `KeyFilter::KeyFilter(...)` (line 12) — standard constructor

**Fix:** No immediate action required; consider adding one-line comments if a project-wide documentation standard is adopted.

---

## Summary Table

| ID | Severity | Location | Title |
|----|----------|----------|-------|
| A21-1 | LOW | `informationdialog.h:21` | No documentation on constructor |
| A21-2 | LOW | `informationdialog.h:23` | No documentation on `updateInformationScreen()` |
| A21-3 | LOW | `informationdialog.h:25` | No documentation on 12-parameter `setStatus()` |
| A21-4 | LOW | `informationdialog.h:27` | No documentation on 7-parameter `setBatteryStatus()` |
| A21-5 | LOW | `informationdialog.h:26` | No documentation on `setConfigParam()` (hidden sysfs read) |
| A21-6 | LOW | `informationdialog.h:29` | No documentation on `setSuperMasterStatus()` |
| A21-7 | MEDIUM | `informationdialog.h:32` | `languageChanged()` has undocumented file I/O side effect inconsistent with `setConfigParam()` |
| A21-8 | HIGH | `keyfilter.h:13` | `isPowerKeyPressed()` undocumented; Qt::Key_Return → power key mapping invisible |
| A21-9 | HIGH | `keyfilter.h:18` | `eventFilter()` undocumented; dual info-dialog trigger sequences and key-consumption policy invisible |
| A21-10 | LOW | `keyfilter.h:16` | `showInfoDialog` signal trigger conditions undocumented |
| A21-11 | LOW | `languagedialog.h:18` | `startScreenTimeout()` timeout period and dismissal mode undocumented |
| A21-12 | LOW | `languagedialog.h:21` | `sigLanguageChanged` emission condition undocumented |
| A21-13 | INFO | multiple | Simple getters/setters/destructors lack doc comments |
# Pass 3 Agent A22 — Documentation

**Audit run:** 2026-02-28-01
**Branch:** master
**Files reviewed:**
- `ui/lockeddialog.h` + `ui/lockeddialog.cpp`
- `ui/messagedialog.h` + `ui/messagedialog.cpp`
- `ui/onScreenKeyboard.h` + `ui/onScreenKeyboard.cpp`

---

## Reading Evidence

### File: `ui/lockeddialog.h` + `ui/lockeddialog.cpp`

**Class:** `LockedDialog` (extends `QDialog`)

**Public methods (header line numbers):**

| Line | Method | Signature |
|------|--------|-----------|
| 18 | Constructor | `explicit LockedDialog(QWidget *parent = 0)` |
| 19 | Destructor | `~LockedDialog()` |
| 20 | `setLockedReason` | `void setLockedReason(CIGCONF::MaintLockedCode lockedCode)` |
| 21 | `languageChanged` | `void languageChanged(void)` |
| 22 | `setTimeRemaining` | `void setTimeRemaining(quint32 secs)` |
| 23 | `clearTimerText` | `void clearTimerText()` |
| 24 | `stopTimer` | `void stopTimer()` |
| 25 | `startTimer` | `void startTimer()` |

**Protected methods:**

| Line | Method |
|------|--------|
| 36 | `mouseReleaseEvent(QMouseEvent *)` — inline; calls `accept()` |

**Signals:**

| Name | Signature |
|------|-----------|
| `fullLockoutTimerEnded` | `void fullLockoutTimerEnded(bool on1, bool on2)` |
| `beeperOn` | `void beeperOn()` |

**Private methods:**

| Name | Purpose (from implementation) |
|------|-------------------------------|
| `updateFullLock()` | Per-second timer tick; decrements counter, emits `fullLockoutTimerEnded` when expired |
| `fullLockStart()` | Initialises `m_timeCntr` from config, starts 1-second `m_fullLockTimer` |

**Private members:**
- `Ui::LockedDialog *ui`
- `QTimer *m_fullLockTimer`
- `quint32 m_timeCntr`

**Types / enums referenced (defined in `app/cigconfigs.h`):**
- `CIGCONF::MaintLockedCode` — enum with values: `MaintNormal`, `MaintIdle (0xea)`, `MaintCriticalQuestion (0xfb)`, `MaintRedImpact (0xfd)`, `MaintSurveyTimeout (0xfe)`

**Doc comments present:** None on any declaration.

---

### File: `ui/messagedialog.h` + `ui/messagedialog.cpp`

**Class:** `MessageDialog` (extends `QDialog`)

**Enum defined in class (header lines 18-27):**

```
enum MessageType {
    NoMessage,
    ExpansionConnecting,
    WaitForAuthorised,
    NotAuthorised,
    OnDemandNotAuthorised,
    PowerOff,
    Reboot,
    VehicleOutOfService
};
```

**Public methods (header line numbers):**

| Line | Method | Signature |
|------|--------|-----------|
| 29 | Constructor | `explicit MessageDialog(QWidget *parent = 0)` |
| 30 | Destructor | `~MessageDialog()` |
| 31 | `openWithMessage` | `void openWithMessage(MessageType type)` — inline; calls `setMessageType(type); open()` |
| 33 | `setMessageType` | `void setMessageType(MessageType type)` |
| 34 | `messageType` | `MessageType messageType() const` — inline getter |

**Protected methods:**

| Line | Method |
|------|--------|
| 37 | `hideEvent(QHideEvent *)` — stops timer and movie, resets `m_messageType` to `NoMessage` |

**Signals:** None declared.

**Private members:**
- `Ui::MessageDialog *ui`
- `QTimer *m_timer`
- `QMovie *m_movie`
- `MessageType m_messageType`

**Macro constants (defined in `messagedialog.cpp`):**
- `WAIT_AUTH_TIME 10000` — timeout (ms) before transitioning `WaitForAuthorised` to `NotAuthorised`
- `NOT_AUTH_TIME 5000` — auto-dismiss timeout (ms) for `NotAuthorised`, `OnDemandNotAuthorised`, `VehicleOutOfService`

**Doc comments present:** None on any declaration.

---

### File: `ui/onScreenKeyboard.h` + `ui/onScreenKeyboard.cpp`

**Class:** `onScreenKeyboard` (extends `QWidget`)

**Enums defined in class (header lines 17-19):**

```
enum KeyToggleState { Normal, Upper, Lower };
enum CaseButton     { AllButtons, CapsButton, ShiftButton, SymbolButton };
enum CtrlButton     { None, Backspace, Delete };
```

**Public members:**
- `QPushButton *enterButton` — public raw pointer (no encapsulation), line 22

**Public methods (header line numbers):**

| Line | Method | Signature |
|------|--------|-----------|
| 20 | Constructor | `explicit onScreenKeyboard(QWidget *parent = 0)` |
| 21 | Destructor | `~onScreenKeyboard()` |
| 24 | `setInitialText` | `void setInitialText(QString str)` |
| 25 | `languageChanged` | `void languageChanged(void)` |

**Signals:**

| Name | Signature |
|------|-----------|
| `updateText` | `void updateText(QString str, CtrlButton ctrl)` |
| `onScreenKeyboardClose` | `void onScreenKeyboardClose()` |

**Private slots:**

| Name |
|------|
| `keyboardHandler()` |
| `on_btnShift_clicked(bool checked)` |
| `on_btnEnter_clicked()` |
| `on_btnBack_clicked()` |
| `on_btnCaps_toggled(bool checked)` |
| `on_btnHideKeyboard_clicked()` |
| `on_btnDelete_clicked()` |

**Protected methods:**
- `closeEvent(QCloseEvent *event)` — emits `onScreenKeyboardClose()` then accepts

**Private methods:**

| Name | Purpose |
|------|---------|
| `toggle()` | Redraws all alpha key labels based on current Caps/Shift state |
| `dualCharCase(QString ch, int toggleState)` | Returns symbol vs. digit representation for number-row dual-label keys |
| `singleCharCase(QString ch, int toggleState)` | Returns upper or lower case of a single character |
| `setCaseButton(CaseButton btn, bool set)` | Applies/removes highlight border stylesheet on Caps or Shift buttons |

**Private members:**
- `Ui::onScreenKeyboard *ui`
- `QString outputText`
- `QString m_capsStylesheet`
- `QString m_symbolStylesheet`
- `QString m_shiftStylesheet`

**Doc comments present:** None on any declaration.

---

## Findings

**A22-1** · HIGH · No documentation on `startTimer()` — safety-critical vehicle shutdown initiator

**Description:** `LockedDialog::startTimer()` (header line 25, implemented in `lockeddialog.cpp` lines 21-28) does three distinct safety-critical things in sequence: it clears any displayed countdown text, emits the `beeperOn()` signal to activate an audible alert, and — when `fullLockoutEnable` is set in configuration — calls `fullLockStart()`, which begins a countdown that ultimately emits `fullLockoutTimerEnded(false, false)` to shut down both output relays on the vehicle. There is no comment of any kind above the declaration. A caller reading only the header has no indication that invoking this method can trigger an irreversible vehicle shutdown sequence.

**Fix:** Add a doc comment above the declaration in `lockeddialog.h` that states: the method arms the beeper, and when full-lockout is enabled and not already running, starts a countdown whose expiry will emit `fullLockoutTimerEnded(false, false)` to de-energise both relays. Document the precondition that `setLockedReason` should have already been called, and that calling `stopTimer()` before expiry is the only way to abort the shutdown.

---

**A22-2** · HIGH · No documentation on `fullLockoutTimerEnded` signal — relay-control contract undocumented

**Description:** The signal `fullLockoutTimerEnded(bool on1, bool on2)` (header line 32) is always emitted with `(false, false)` (cpp line 88), meaning both relay outputs are to be de-energised. The parameter names `on1` and `on2` provide no indication of what physical outputs they control, what the `false` value means in each case, or whether any future caller could legitimately emit this signal with `(true, …)`. No comment exists anywhere in either file explaining these parameters or the physical effect of this signal.

**Fix:** Add a doc comment above the signal in `lockeddialog.h` describing: what `on1` and `on2` represent (the two relay channels), that `false` means the relay should be opened (de-energised), and that this signal is always emitted at the end of the full-lockout countdown. Cross-reference `startTimer()` and `stopTimer()`.

---

**A22-3** · HIGH · No documentation on `setLockedReason()` — lockout-code-to-UI mapping undocumented

**Description:** `setLockedReason(CIGCONF::MaintLockedCode lockedCode)` (header line 20) controls which safety lockout message is shown to the operator. The `CIGCONF::MaintLockedCode` enum contains values representing different operational failure modes (critical checklist failure, red-level safety impact, survey timeout, idle timeout). There is no comment explaining what the parameter represents, the expected set of valid values, or the consequence of passing an unrecognised code (the `default` branch silently shows a generic "Unit Locked" message). The enum value names themselves (`0xea`, `0xfb`, `0xfd`, `0xfe`) are not self-explanatory to maintainers reading the header in isolation.

**Fix:** Add a doc comment above the declaration referencing `CIGCONF::MaintLockedCode` enum values and noting that any value not matching a known enum case will produce the generic "Unit Locked" message. Describe the intended call ordering (call before `startTimer()`).

---

**A22-4** · MEDIUM · `stopTimer()` documentation absent — abort-of-shutdown semantics invisible

**Description:** `stopTimer()` (header line 24) not only stops `m_fullLockTimer` but also calls `clearTimerText()`. More importantly, calling it is the only mechanism to abort the full-lockout countdown before it fires. There is no comment indicating that this method is the cancellation path for a vehicle shutdown sequence, nor that it also clears the displayed countdown text as a side effect.

**Fix:** Add a doc comment stating: stops the full-lockout countdown timer (aborting a pending shutdown if active) and clears the countdown display label. Note that this is the only abort path once `startTimer()` has been called.

---

**A22-5** · LOW · No documentation on `setTimeRemaining()` — parameter unit and UI side-effect undescribed

**Description:** `setTimeRemaining(quint32 secs)` (header line 22) updates the on-screen countdown label with a translated string of the form "CAUTION: This vehicle will shut down in N seconds". The parameter name `secs` is reasonable but neither the unit, the expected range, nor the fact that this method only modifies a label (it does not affect the timer) is documented. It is not obvious from the header alone whether this method also starts/resets any timer.

**Fix:** Add a brief comment stating the parameter is a count in seconds, that it only updates the display label, and that callers should not rely on this method to drive the timer countdown (which is driven by `m_fullLockTimer`).

---

**A22-6** · LOW · No documentation on `MessageDialog::setMessageType()` — timer side-effects and auto-dismiss behaviour undocumented

**Description:** `setMessageType(MessageType type)` (header line 33) does far more than set a field: depending on the `type` value it reconfigures UI geometry, starts/stops a `QMovie`, and starts a `QTimer` that will either auto-transition from `WaitForAuthorised` to `NotAuthorised` after 10 seconds or auto-dismiss the dialog after 5 seconds. None of these side effects — including the automatic state machine transition and the auto-dismiss timers — are described anywhere in the header or above the implementation.

**Fix:** Add a doc comment above the declaration describing: (a) that this method also reconfigures the UI and movie; (b) which `MessageType` values start a timer and what the timer does (`WaitForAuthorised` transitions to `NotAuthorised` after `WAIT_AUTH_TIME` ms; `NotAuthorised`, `OnDemandNotAuthorised`, and `VehicleOutOfService` auto-dismiss after `NOT_AUTH_TIME` ms); (c) that the timer constants are defined in the .cpp file.

---

**A22-7** · LOW · `MessageDialog::openWithMessage()` inline convenience method undocumented

**Description:** `openWithMessage(MessageType type)` (header line 31) is a convenience method that composes `setMessageType` and `open()`. Because `setMessageType` carries timer-starting side effects, callers who use `openWithMessage` vs. calling the two separately may be surprised that the timer starts before the dialog is fully visible. There is no comment explaining the call order or the interaction with `hideEvent`, which resets `m_messageType` to `NoMessage` and stops the timer when the dialog is hidden.

**Fix:** Add a one-line comment noting that this method sets the message type (which may start an auto-dismiss timer) and then opens the dialog modally. Cross-reference `hideEvent` as the teardown path.

---

**A22-8** · LOW · `onScreenKeyboard::updateText` signal — `CtrlButton` parameter semantics undocumented

**Description:** The signal `updateText(QString str, CtrlButton ctrl)` (header line 36) is emitted in three distinct scenarios: a regular character key (emits the character with `ctrl = None`), the backspace key (emits empty string with `ctrl = Backspace`), and the delete key (emits empty string with `ctrl = Delete`). When `ctrl` is `Backspace` or `Delete`, the `str` parameter is always an empty string, but there is no documentation stating this convention. Receivers must inspect the implementation to understand when `str` is meaningful.

**Fix:** Add a doc comment above the signal declaration stating: `str` carries the character to append when `ctrl == None`; `str` is empty and should be ignored when `ctrl` is `Backspace` or `Delete`. Clarify that `Backspace` removes the previous character and `Delete` removes the next character (consistent with implementation in `on_btnBack_clicked` and `on_btnDelete_clicked`).

---

**A22-9** · LOW · `onScreenKeyboard::setInitialText()` — purpose and relationship to `outputText` undocumented

**Description:** `setInitialText(QString str)` (header line 24) sets the private `outputText` member. The name implies it pre-populates the keyboard's internal text buffer. However, there is no comment explaining: whether the dialog will echo this initial text back via `updateText` on the next keypress, whether callers should call this before or after `show()`, or how it interacts with the `on_btnEnter_clicked` handler that resets `outputText` to empty. Without a comment, callers cannot safely predict the behaviour of the first keypress after initialisation.

**Fix:** Add a doc comment stating: sets the internal output-text buffer to `str`; the next character key press will replace this value (not append to it), and calling `on_btnEnter_clicked` resets the buffer to empty regardless. Clarify the intended call order relative to `show()`.

---

**A22-10** · INFO · `LockedDialog::languageChanged()` and `onScreenKeyboard::languageChanged()` undocumented

**Description:** Both classes expose a `languageChanged()` method (lockeddialog.h line 21; onScreenKeyboard.h line 25) with no comments. These are simple retranslation methods that update displayed strings when the application locale changes. They are low-risk but follow no established calling convention visible from the headers.

**Fix:** Add a brief `// Call when the application language changes to retranslate all visible strings.` comment above each declaration.

---

**A22-11** · INFO · `MessageDialog::messageType()` getter undocumented

**Description:** The inline getter `messageType() const` (header line 34) has no comment. It is a simple accessor; the omission is minor.

**Fix:** Add a one-line comment: `// Returns the currently displayed message type, or NoMessage when the dialog is hidden.`

---

**A22-12** · INFO · `onScreenKeyboard::enterButton` public raw pointer undocumented

**Description:** `enterButton` (header line 22) is a public raw `QPushButton *` with no comment explaining its purpose, who owns it, or why it is exposed publicly rather than accessed through a method. It appears to be used by an external caller to connect to the enter button's signal directly, but this intent is entirely undocumented.

**Fix:** Add a comment above the member stating its purpose (e.g., exposed to allow callers to connect directly to the enter button's signals) and clarifying ownership (owned by the UI, not by the caller).

---

## Summary Table

| ID | Severity | Title |
|----|----------|-------|
| A22-1 | HIGH | No documentation on `startTimer()` — safety-critical vehicle shutdown initiator |
| A22-2 | HIGH | No documentation on `fullLockoutTimerEnded` signal — relay-control contract undocumented |
| A22-3 | HIGH | No documentation on `setLockedReason()` — lockout-code-to-UI mapping undocumented |
| A22-4 | MEDIUM | `stopTimer()` documentation absent — abort-of-shutdown semantics invisible |
| A22-5 | LOW | No documentation on `setTimeRemaining()` — parameter unit and UI side-effect undescribed |
| A22-6 | LOW | No documentation on `MessageDialog::setMessageType()` — timer side-effects and auto-dismiss behaviour undocumented |
| A22-7 | LOW | `MessageDialog::openWithMessage()` inline convenience method undocumented |
| A22-8 | LOW | `onScreenKeyboard::updateText` signal — `CtrlButton` parameter semantics undocumented |
| A22-9 | LOW | `onScreenKeyboard::setInitialText()` — purpose and relationship to `outputText` undocumented |
| A22-10 | INFO | `languageChanged()` methods undocumented in both `LockedDialog` and `onScreenKeyboard` |
| A22-11 | INFO | `MessageDialog::messageType()` getter undocumented |
| A22-12 | INFO | `onScreenKeyboard::enterButton` public raw pointer undocumented |

**Totals:** 3 HIGH, 1 MEDIUM, 5 LOW, 3 INFO
# Pass 3 Agent A23 — Documentation

**Audit run:** 2026-02-28-01
**Branch:** master
**Auditor:** Agent A23
**Files reviewed:**
- `ui/ondemanddialog.h` / `ui/ondemanddialog.cpp`
- `ui/optionalcheckconfirmationdialog.h` / `ui/optionalcheckconfirmationdialog.cpp`
- `ui/pindialog.h` / `ui/pindialog.cpp`

---

## Reading Evidence

### `OnDemandDialog` (`ui/ondemanddialog.h`)

**Class:** `OnDemandDialog` (extends `QDialog`)

**Public methods:**

| Line | Method | Doc comment present? |
|------|--------|----------------------|
| 20 | `explicit OnDemandDialog(QWidget *parent = 0)` | No |
| 21 | `~OnDemandDialog()` | No |
| 23 | `void setSuperMasterId(quint64 id)` | No |
| 24 | `void reset()` | No |
| 25 | `void setTimeRemaining(quint32 secs)` | No |
| 26 | `QString showCustomTimeFormat(quint32 time)` | No |

**Signals:**

| Line | Signal |
|------|--------|
| 29 | `onDemandStarted(quint32 start, quint32 end, quint64 id, CIGCONF::OnDemandCmdSrc src)` |
| 30 | `onDemandExtended(quint32 start, quint32 end, quint64 id, CIGCONF::OnDemandCmdSrc src)` |
| 31 | `onDemandEnded(quint32 end, quint64 id, CIGCONF::OnDemandCmdSrc src)` |

**Protected methods (slots/overrides):**

| Line | Method |
|------|--------|
| 34 | `void showEvent(QShowEvent *event = 0)` |
| 36 | `void onStart()` |
| 37 | `void onExtend()` |
| 38 | `void onEnd()` |

**Private methods:**

| Line | Method |
|------|--------|
| 41 | `bool debounce()` |

**Types, enums, constants defined in translation unit:**
- `#define NO_ACTIVITY_TIME 10000` (cpp, line 7) — inactivity timeout in milliseconds (10 seconds)

**No doc comments exist anywhere in this file pair.**

---

### `OptionalCheckConfirmationDialog` (`ui/optionalcheckconfirmationdialog.h`)

**Class:** `OptionalCheckConfirmationDialog` (extends `QDialog`)

**Public methods:**

| Line | Method | Doc comment present? |
|------|--------|----------------------|
| 15 | `explicit OptionalCheckConfirmationDialog(QWidget *parent = 0)` | No |
| 16 | `~OptionalCheckConfirmationDialog()` | No |
| 17 | `void onRefreshLanguage(void)` | No |

**Signals:** None declared.

**Protected methods:**

| Line | Method |
|------|--------|
| 24 | `void hideEvent(QHideEvent *)` |
| 25 | `void showEvent(QShowEvent *event = 0)` |

**Types, enums, constants:** None.

**No doc comments exist anywhere in this file pair.**

---

### `PinDialog` (`ui/pindialog.h`)

**Class:** `PinDialog` (extends `QDialog`)

**Public methods:**

| Line | Method | Doc comment present? |
|------|--------|----------------------|
| 17 | `explicit PinDialog(QWidget *parent = 0)` | No |
| 18 | `~PinDialog()` | No |
| 20 | `quint32 pinCode() const` | No |
| 21 | `void clearPinCode()` | No |
| 22 | `void languageChanged()` | No |

**Signals:** None declared.

**Protected methods:**

| Line | Method |
|------|--------|
| 25 | `void showEvent(QShowEvent *)` |
| 26 | `void hideEvent(QHideEvent *)` |

**Private methods:**

| Line | Method |
|------|--------|
| 29 | `void keyPressed()` |

**Types, enums, constants defined in translation unit:**
- `#define PIN_MAX_LENGTH 5` (cpp, line 9) — maximum number of PIN digits accepted
- `#define ACTIVITY_TIME 30000` (cpp, line 10) — inactivity auto-dismiss timeout in milliseconds (30 seconds)

**No doc comments exist anywhere in this file pair.**

---

## Findings

**A23-1** · HIGH · `PinDialog::pinCode()` has no documentation

**Description:** `pinCode()` is the sole public accessor that retrieves the numeric PIN value entered by the user. It is called by callers after `exec()` returns `Accepted` to perform vehicle-access authentication. The method has non-obvious behaviour: it silently stops accumulating digits at the first non-digit character (e.g. `#`), effectively stripping any trailing `#` that the hardware keypad appends when `btnHash` triggers `accept()`. This silent truncation is critical to understand for any caller verifying the PIN value and is completely undocumented. There is no description of the parameter, return value, the accepted character set, or the truncation rule.

**Fix:** Add a doc comment above the declaration in `pindialog.h` explaining: (1) what value is returned (the numeric portion of the PIN as entered via the keypad); (2) that trailing non-digit characters (e.g. `#`) are silently discarded; (3) that the return value is `0` when the field is empty; (4) that `clearPinCode()` must be called before re-showing the dialog if the previous result is to be discarded.

---

**A23-2** · HIGH · `PinDialog::clearPinCode()` has no documentation

**Description:** `clearPinCode()` resets both the internal `QLineEdit` and the masking `QLabel` to empty. Callers must invoke this before re-presenting the dialog to a new authentication attempt; failure to do so would leave the previous PIN pre-populated in the input, potentially granting unintended access. The method has no doc comment explaining when it must be called or what state it clears.

**Fix:** Add a doc comment above the declaration in `pindialog.h` stating that this method clears the entered PIN from both the input field and the display mask and that it should be called before each new authentication session.

---

**A23-3** · HIGH · `PinDialog::languageChanged()` has no documentation

**Description:** `languageChanged()` repopulates all UI button and label text using `tr()` for runtime locale switching. It is part of the `PinDialog` public API and must be called by the parent at the correct time (after language selection but before or while the dialog is visible). The method has no doc comment, no explanation of when it must be called, and no indication of what UI elements it modifies. Calling it at the wrong time (e.g. while `pinCode()` is being read) could produce a race condition on the display state.

**Fix:** Add a doc comment in `pindialog.h` stating that this method refreshes all translatable UI strings and should be called when the application language changes, ideally while the dialog is hidden.

---

**A23-4** · LOW · `OnDemandDialog::setSuperMasterId()` has no documentation

**Description:** `setSuperMasterId()` stores a `quint64` identifier that is subsequently embedded in every emitted signal (`onDemandStarted`, `onDemandExtended`, `onDemandEnded`) as the `id` parameter. The name "super master ID" is opaque and the relationship between this stored value and the signals is not documented anywhere. There is no indication that the dialog must be configured with this value before it is shown, nor what value `0` or an unset ID would mean to the backend.

**Fix:** Add a doc comment above the declaration explaining that this sets the super-master device identifier to be reported in On Demand lifecycle signals, and that it should be set before the dialog is shown.

---

**A23-5** · LOW · `OnDemandDialog::reset()` has no documentation

**Description:** `reset()` clears `m_lastPress` (debounce timestamp) and then calls `showEvent()` directly to rebuild UI state. This means it re-evaluates `gCfg->onDemandStartTime()` and re-enables or disables buttons accordingly. Calling `showEvent()` directly (rather than relying on Qt's normal show mechanism) is an unusual pattern. There is no doc comment describing the intended use case, what state is reset, or the side-effect of internally calling `showEvent()`.

**Fix:** Add a doc comment above the declaration describing that `reset()` reinitialises the dialog to reflect the current on-demand session state and resets the debounce timer, and that it is intended for use when the dialog is re-shown without being destroyed and recreated.

---

**A23-6** · LOW · `OnDemandDialog::setTimeRemaining()` has no documentation

**Description:** `setTimeRemaining()` accepts a `quint32` value in seconds and updates the status label. When `secs == 0` it shows a generic header string; otherwise it appends a formatted time string. The units (seconds), the zero-case behaviour, and the label update mechanism are all undocumented.

**Fix:** Add a doc comment above the declaration in `ondemanddialog.h` stating: (1) the parameter is in seconds; (2) passing `0` reverts the label to the default "On Demand Mode Control Panel" text; (3) non-zero values append the remaining time in `HH:MM:SS` format.

---

**A23-7** · LOW · `OnDemandDialog::showCustomTimeFormat()` has no documentation

**Description:** `showCustomTimeFormat()` converts a `quint32` number of seconds into a zero-padded `HH:MM:SS` string. The method name suggests it may be intended as a display-only utility. Its return type, parameter units, and formatting contract are all undocumented. The method is public, making it part of the class API surface.

**Fix:** Add a doc comment above the declaration stating that the parameter is a duration in seconds and the return value is a formatted string in `HH:MM:SS` notation with zero-padded fields.

---

**A23-8** · LOW · `OnDemandDialog` signals have no documentation

**Description:** The three signals `onDemandStarted`, `onDemandExtended`, and `onDemandEnded` carry `quint32 start`, `quint32 end`, and `quint64 id` parameters, plus a `CIGCONF::OnDemandCmdSrc` default argument. There is no documentation describing the epoch or time base for `start`/`end` (local Unix timestamp per the implementation), the meaning of `id`, or the purpose of `src`. These signals are consumed by backend components to control vehicle access scheduling; the lack of documentation makes correct consumption error-prone.

**Fix:** Add doc comments above each signal declaration describing the time base (local Unix timestamp in seconds), the role of `id` (super-master device identifier), and the purpose of `src` (command source for local vs remote origination).

---

**A23-9** · INFO · `OptionalCheckConfirmationDialog::onRefreshLanguage()` has no documentation

**Description:** `onRefreshLanguage()` re-applies all `tr()` translated strings to the dialog's UI widgets. It duplicates the same assignments made in `showEvent()`. The method has no doc comment explaining when it is called or why it is needed in addition to `showEvent()`.

**Fix:** Add a brief comment above the declaration noting that this method refreshes translatable strings and is called when the application locale changes at runtime.

---

**A23-10** · INFO · Constructor and destructor doc comments absent across all three classes

**Description:** None of the three constructors or destructors in `OnDemandDialog`, `OptionalCheckConfirmationDialog`, or `PinDialog` have doc comments. For the constructors this is low risk, but noting it for completeness per the audit scope.

**Fix:** At minimum, add a brief comment to `PinDialog(QWidget *parent)` noting that the constructor wires all keypad button signals and sets up the inactivity timer (30 s). Constructors for the other two classes are straightforward enough that an INFO classification is appropriate.

---

## Summary Table

| ID | Severity | Location | Title |
|----|----------|----------|-------|
| A23-1 | HIGH | `pindialog.h:20` | `PinDialog::pinCode()` has no documentation |
| A23-2 | HIGH | `pindialog.h:21` | `PinDialog::clearPinCode()` has no documentation |
| A23-3 | HIGH | `pindialog.h:22` | `PinDialog::languageChanged()` has no documentation |
| A23-4 | LOW | `ondemanddialog.h:23` | `OnDemandDialog::setSuperMasterId()` has no documentation |
| A23-5 | LOW | `ondemanddialog.h:24` | `OnDemandDialog::reset()` has no documentation |
| A23-6 | LOW | `ondemanddialog.h:25` | `OnDemandDialog::setTimeRemaining()` has no documentation |
| A23-7 | LOW | `ondemanddialog.h:26` | `OnDemandDialog::showCustomTimeFormat()` has no documentation |
| A23-8 | LOW | `ondemanddialog.h:29-31` | `OnDemandDialog` signals have no documentation |
| A23-9 | INFO | `optionalcheckconfirmationdialog.h:17` | `onRefreshLanguage()` has no documentation |
| A23-10 | INFO | All three headers | Constructor and destructor doc comments absent |

**Totals:** 3 HIGH, 5 LOW, 2 INFO
# Pass 3 Agent A24 — Documentation

**Audit run:** 2026-02-28-01
**Branch:** master
**Auditor:** Agent A24
**Files reviewed:**
- `ui/preopscreenoverlay.h` / `ui/preopscreenoverlay.cpp`
- `ui/supervisordialog.h` / `ui/supervisordialog.cpp`
- `ui/unlockeddialog.h` / `ui/unlockeddialog.cpp`

---

## Reading Evidence

### 1. `PreopScreenOverlay` (`ui/preopscreenoverlay.h`)

**Class:** `PreopScreenOverlay` (inherits `QDialog`)

**Public methods:**

| Line | Method |
|------|--------|
| 15 | `explicit PreopScreenOverlay(QWidget *parent = 0)` |
| 16 | `~PreopScreenOverlay()` |
| 18 | `void onUpdatePreopTimer(QString time)` |

**Signals:** none declared

**Slots:** none declared

**Types / enums / constants:** none

**Implementation notes (`preopscreenoverlay.cpp`):**
- Constructor initialises the Qt Designer UI.
- `onUpdatePreopTimer(QString time)` sets a label to `"Time Remaining: <time>"`.

---

### 2. `SupervisorDialog` (`ui/supervisordialog.h`)

**Class:** `SupervisorDialog` (inherits `QDialog`)

**Public methods:**

| Line | Method |
|------|--------|
| 20 | `explicit SupervisorDialog(QWidget *parent = nullptr)` |
| 21 | `~SupervisorDialog()` |
| 23 | `void setMasterOptions(CIGCONF::MasterId m)` |
| 24 | `void setTransportOptions()` |

**Signals (line 31–33):**
- `startMasterSession()` — emitted when the supervisor authorises a master/normal-driver session or unlocks the vehicle.
- `startMaintenanceSession()` — emitted when maintenance mode is confirmed.
- `onVORUpdate()` — emitted after VOR (Vehicle Out of Repair) status is toggled.

**Protected method:**
- `showEvent(QShowEvent *event = 0)` (line 49)

**Private slots:**
- `onUnlkVehicle()` — handles two-tap unlock-vehicle confirmation.
- `onNormalDriverAccess()` — handles two-tap normal-driver-access confirmation; also opens a transport warning dialog.
- `onActivateVOR()` — writes the new VOR state to config and saves.
- `openConfirmationDialog()` — handles two-tap VOR activate/deactivate, then opens `VORConfirmationDialog`.
- `on_btnMaintenanceMode_clicked()` — handles two-tap maintenance-mode confirmation; opens a maintenance warning dialog.

**Private methods:**
- `debounce()` — returns false if two presses occur within 200 ms.
- `reset()` — resets `m_lastPress` to 0 and calls `showEvent()`.

**Private members:**
- `Ui::SupervisorDialog *ui`
- `QTimer *m_timer` — auto-dismiss timer (10 000 ms inactivity).
- `QTimer *m_resetTimer` — button-text reset timer (2 000 ms).
- `quint32 m_lastPress` — timestamp of last button press for debounce.
- `CIGCONF::MasterId m_master` — the authenticated master record (contains `id` and `option` bitmask).
- `VORConfirmationDialog *m_vorConfirmationDialog`
- `WarningDialog *m_maintWarningDialog`
- `WarningDialog *m_warningDialog`

**Types / enums / constants used (from `app/cigconfigs.h`):**

`CIGCONF::MasterId` struct:
```cpp
struct MasterId {
    quint64 id;
    quint8  option;   // bitmask of MasterMenuOptions
    QString name;
};
```

`CIGCONF::MasterMenuOptions` enum:
```cpp
enum MasterMenuOptions {
    UnlockVehicle       = 1,
    NormalDriverAccess  = 2,
    ActivateVOR         = 4,
    MaintenanceMode     = 8,
    DefaultMasterMenu   = 7,
    UnassignedMasterMenu= 255
};
```

Macro constants defined in `supervisordialog.cpp`:
- `NO_ACTIVITY_TIME` = 10 000 (ms)
- `RESET_TIME` = 2 000 (ms)

---

### 3. `UnlockedDialog` (`ui/unlockeddialog.h`)

**Class:** `UnlockedDialog` (inherits `QDialog`)

**Public methods:**

| Line | Method |
|------|--------|
| 17 | `explicit UnlockedDialog(QWidget *parent = 0)` |
| 18 | `~UnlockedDialog()` |
| 20 | `void setMode(Mode m)` |
| 21 | `void languageChanged()` |

**Signals:** none declared

**Slots:** none declared

**Types / enums / constants:**

`Mode` enum (line 15):
```cpp
enum Mode { UnlockNoChecklist, UnlockChecklist, UnlockOnly };
```

**Implementation notes (`unlockeddialog.cpp`):**
- `setMode(Mode m)` configures visible labels based on the three `Mode` values:
  - `UnlockOnly`: "Machine unlocked" + warning visible; tip = "Press OK to return to login screen".
  - `UnlockChecklist`: "Machine unlocked" + warning visible; tip = "Operational check list required\nPress OK to continue".
  - `UnlockNoChecklist` (default): locked/warning labels hidden; tip = "No questions available.\nPress OK to continue".
- `languageChanged()` updates the OK label text for locale changes.

---

## Findings

**A24-1** · INFO · Missing doc comment on `PreopScreenOverlay` constructor

**Description:** The constructor `PreopScreenOverlay(QWidget *parent = 0)` has no doc comment. The implementation only sets up the designer UI. This is a trivial boilerplate constructor with no non-obvious behaviour.

**Fix:** Add a brief one-line comment noting the parent widget requirement, e.g.:
```cpp
// Constructs the pre-op screen overlay dialog; parent is passed to QDialog.
explicit PreopScreenOverlay(QWidget *parent = 0);
```

---

**A24-2** · LOW · Missing doc comment on `PreopScreenOverlay::onUpdatePreopTimer`

**Description:** `onUpdatePreopTimer(QString time)` has no doc comment. The method is non-trivial in context: it is the sole mechanism for updating the on-screen pre-operation countdown timer displayed to the driver. Neither the expected format of `time`, nor the fact that it sets the label text as `"Time Remaining: <time>"`, is described anywhere in the header.

**Fix:** Add a comment above the declaration describing the parameter and its expected format:
```cpp
// Updates the countdown label with the remaining pre-op time.
// @param time Formatted time string (e.g., "MM:SS") to display.
void onUpdatePreopTimer(QString time);
```

---

**A24-3** · HIGH · No documentation on any public method of `SupervisorDialog`

**Description:** `SupervisorDialog` is the primary security-critical UI component in the system. It controls:
- Unlocking a vehicle for a master session (`startMasterSession` signal).
- Granting normal driver access (`startMasterSession` signal).
- Activating or deactivating VOR (Vehicle Out of Repair) status (`onVORUpdate` signal; calls `gCfg->setConvor()`).
- Entering maintenance mode (`startMaintenanceSession` signal).

Neither public method (`setMasterOptions` or `setTransportOptions`) has any doc comment of any kind in the header. There is no class-level comment describing the dialog's role, the security model it enforces, the expected call order, or what the `CIGCONF::MasterId` parameter means in `setMasterOptions`. A maintainer reading only the header cannot determine:
- That `setMasterOptions` must be called before showing the dialog (the option bitmask controls which buttons are visible and the `m_master.id` is used as the authorising master ID when persisting the VOR state).
- That `setTransportOptions` hides all privileged actions except Normal Driver Access, configuring the dialog for transport/non-privileged-master context.
- The consequence of not calling either method before `show()`.

**Fix:** Add a class-level doc comment and per-method doc comments to the header:
```cpp
/**
 * SupervisorDialog — Security-critical dialog for supervisor/master actions.
 *
 * Must be configured before display by calling either setMasterOptions() or
 * setTransportOptions(). Controls vehicle unlock, normal driver access,
 * VOR (Vehicle Out of Repair) activation/deactivation, and maintenance mode.
 * Auto-dismisses after NO_ACTIVITY_TIME ms of inactivity.
 */

/**
 * Configures which action buttons are visible based on the authenticated
 * master's permission bitmask (CIGCONF::MasterMenuOptions).
 * The supplied MasterId is stored and used as the authorising ID when
 * persisting a VOR state change.
 * @param m  The authenticated master record; m.option is a bitmask of
 *           CIGCONF::MasterMenuOptions flags.
 */
void setMasterOptions(CIGCONF::MasterId m);

/**
 * Configures the dialog for a transport/non-privileged context:
 * only the Normal Driver Access button is shown; VOR, Unlock Vehicle,
 * and Maintenance Mode buttons are hidden.
 */
void setTransportOptions();
```

---

**A24-4** · HIGH · No documentation on any signal of `SupervisorDialog`

**Description:** The three signals — `startMasterSession()`, `startMaintenanceSession()`, and `onVORUpdate()` — carry security-critical semantics. No comments exist on any of them. Specifically:
- `startMasterSession()` is emitted in two distinct code paths (Unlock Vehicle and Normal Driver Access), meaning callers cannot distinguish which action triggered the session start from the signal alone.
- `onVORUpdate()` is emitted after `gCfg->saveConfigs()` has already committed the VOR state change; callers connecting to this signal cannot roll back.
- The naming `onVORUpdate` violates Qt convention (signals should not be named with `on` prefix, which is reserved for slots), which is a secondary documentation/naming clarity issue.

**Fix:** Add comments above each signal declaration:
```cpp
signals:
    // Emitted when the supervisor authorises either an Unlock Vehicle or
    // Normal Driver Access action. Callers should begin a master session.
    void startMasterSession();

    // Emitted when the supervisor confirms entry into Maintenance Mode.
    void startMaintenanceSession();

    // Emitted after VOR status has been toggled and configuration saved.
    // The new status can be read from gCfg->convorStatus().
    void onVORUpdate();
```

---

**A24-5** · HIGH · Missing documentation on `SupervisorDialog::showEvent` (protected)

**Description:** `showEvent(QShowEvent *event = 0)` is overridden in `SupervisorDialog` but carries no comment. Its role is non-obvious and security-relevant: it not only performs UI reset (button text, visibility, last-session labels) but also starts the inactivity auto-dismiss timer (`m_timer`). Any subclass or test code that overrides or calls this method without understanding the timer side-effect could inadvertently disable the inactivity lockout. The default parameter `= 0` on a Qt event handler is unusual and unexplained.

**Fix:** Add a comment above the declaration:
```cpp
// Resets dialog UI state and (re)starts the NO_ACTIVITY_TIME inactivity
// auto-dismiss timer. Called on every show and on internal state resets.
// Note: event may be nullptr when called internally (e.g., from reset()).
void showEvent(QShowEvent *event = 0);
```

---

**A24-6** · LOW · Missing doc comment on `UnlockedDialog::setMode`

**Description:** `setMode(Mode m)` controls which combination of warning labels and instructional text is shown to the driver after a machine-unlock event. The `Mode` enum has three values but no doc comment explains what each value means in operational terms or when each should be used. In particular, the distinction between `UnlockNoChecklist` and `UnlockOnly` is not self-evident from names alone (`UnlockNoChecklist` hides the lock/warning labels entirely, whereas `UnlockOnly` shows them).

**Fix:** Add comments to the enum and the method:
```cpp
enum Mode {
    UnlockNoChecklist,  // No checklist available; shows minimal tip only.
    UnlockChecklist,    // Checklist required; shows unlock confirmation + checklist prompt.
    UnlockOnly          // Unlock without checklist; shows unlock confirmation + login tip.
};

// Configures the dialog's displayed message for the given unlock scenario.
// Must be called before the dialog is shown.
void setMode(Mode m);
```

---

**A24-7** · INFO · Missing doc comment on `UnlockedDialog::languageChanged`

**Description:** `languageChanged()` has no doc comment. Its implementation updates a single label (`label_3`) with the translated "OK" string. It is a locale-refresh hook but nothing in the header or implementation describes when it should be called, which labels it refreshes, or why only `label_3` is updated (other translatable strings are handled via `tr()` on construction or in `setMode`).

**Fix:** Add a brief one-line comment:
```cpp
// Re-applies translated strings to UI elements after a language change.
void languageChanged();
```

---

## Summary Table

| ID | Severity | File | Subject |
|----|----------|------|---------|
| A24-1 | INFO | `preopscreenoverlay.h` | Missing doc comment on constructor |
| A24-2 | LOW | `preopscreenoverlay.h` | Missing doc comment on `onUpdatePreopTimer` — parameter format undocumented |
| A24-3 | HIGH | `supervisordialog.h` | No documentation on any public method of security-critical `SupervisorDialog` |
| A24-4 | HIGH | `supervisordialog.h` | No documentation on any signal of `SupervisorDialog`; ambiguous `startMasterSession` semantics |
| A24-5 | HIGH | `supervisordialog.h` | Missing documentation on `showEvent` — inactivity lockout side-effect undocumented |
| A24-6 | LOW | `unlockeddialog.h` | Missing doc comment on `setMode`; `Mode` enum values not explained |
| A24-7 | INFO | `unlockeddialog.h` | Missing doc comment on `languageChanged` |

**Totals:** 3 HIGH, 2 LOW, 2 INFO
# Pass 3 Agent A25 — Documentation

**Audit run:** 2026-02-28-01
**Branch:** master
**Auditor:** A25
**Files reviewed:**
- `ui/unlockreasondialog.h` + `ui/unlockreasondialog.cpp`
- `ui/vorconfirmationdialog.h` + `ui/vorconfirmationdialog.cpp`
- `ui/vorwarningdialog.h` + `ui/vorwarningdialog.cpp`

---

## Reading Evidence

### UnlockReasonDialog (`ui/unlockreasondialog.h`)

**Class:** `UnlockReasonDialog` (inherits `QDialog`)

**Public methods (header):**

| Line | Method |
|------|--------|
| 16 | `explicit UnlockReasonDialog(QWidget *parent = 0)` — constructor |
| 17 | `~UnlockReasonDialog()` — destructor |
| 18 | `QString getReason()` |
| 19 | `void languageChanged(void)` |

**Private methods:**

| Line | Method |
|------|--------|
| 23 | `void setReason()` — connected to every reason-button clicked signal; captures sender button text into `m_reason` and emits `accept()` |

**Signals:** None declared.

**Slots:** None declared with `slots:` keyword; `setReason()` is used as a slot via `connect()` but is declared only as a private method.

**Types / enums / constants:** None.

**Private members:** `Ui::UnlockReasonDialog *ui`, `QString m_reason`.

---

### VORConfirmationDialog (`ui/vorconfirmationdialog.h`)

**Class:** `VORConfirmationDialog` (inherits `QDialog`)

**Public methods (header):**

| Line | Method |
|------|--------|
| 15 | `explicit VORConfirmationDialog(QWidget *parent = 0)` — constructor |
| 16 | `~VORConfirmationDialog()` — destructor |
| 18 | `void isBeingTurnOn(bool on)` |

**Protected methods:**

| Line | Method |
|------|--------|
| 25 | `void hideEvent(QHideEvent *)` — stops the auto-close timer |
| 26 | `void showEvent(QShowEvent *event = 0)` — starts a 10-second single-shot auto-reject timer |

**Signals:** None declared.

**Slots:** None declared with `slots:` keyword; `reject()` and `accept()` are used as slots via `connect()` (inherited from `QDialog`).

**Types / enums / constants:** None.

**Private members:** `Ui::VORConfirmationDialog *ui`, `QTimer *m_timer`.

---

### VORWarningDialog (`ui/vorwarningdialog.h`)

**Class:** `VORWarningDialog` (inherits `QDialog`)

**Public methods (header):**

| Line | Method |
|------|--------|
| 15 | `explicit VORWarningDialog(QWidget *parent = 0)` — constructor |
| 16 | `~VORWarningDialog()` — destructor |

**Protected methods:**

| Line | Method |
|------|--------|
| 23 | `void hideEvent(QHideEvent *)` — stops the auto-close timer |
| 24 | `void showEvent(QShowEvent *event = 0)` — populates the safety warning text in HTML, starts a 30-second single-shot auto-reject timer |

**Signals:** None declared.

**Slots:** None declared with `slots:` keyword.

**Types / enums / constants:** None.

**Private members:** `Ui::VORWarningDialog *ui`, `QTimer *m_timer`.

---

## Documentation Check Results

### UnlockReasonDialog

| Method | Doc comment present? | Accurate? | Parameters/return described? |
|--------|----------------------|-----------|------------------------------|
| Constructor | No | N/A | N/A |
| Destructor | No | N/A | N/A |
| `getReason()` | No | N/A | N/A |
| `languageChanged()` | No | N/A | N/A |
| `setReason()` (private) | No | N/A | N/A |

No doc comments of any form exist in either the header or the implementation file for this class.

`getReason()` returns the text of the most recently clicked reason button (set by `setReason()`). The name suggests a simple getter, but the side effect context (the dialog accepts on button click and the caller retrieves the reason afterwards) is non-obvious.

`languageChanged()` performs a complete UI retranslation of all labels and buttons — a non-trivial responsibility that is not documented.

`setReason()` (private) is connected as a slot to 14 different buttons, captures the sender's text, and emits `accept()` to close the dialog. Its role as a multi-purpose slot and its side effect of emitting `accept()` is undocumented.

---

### VORConfirmationDialog

| Method | Doc comment present? | Accurate? | Parameters/return described? |
|--------|----------------------|-----------|------------------------------|
| Constructor | No | N/A | N/A |
| Destructor | No | N/A | N/A |
| `isBeingTurnOn(bool on)` | No | N/A | N/A |
| `hideEvent()` | No | N/A | N/A |
| `showEvent()` | No | N/A | N/A |

No doc comments of any form exist in either file for this class.

`isBeingTurnOn(bool on)` has a previously identified inverted boolean logic defect: when `on == false`, the method sets the UI to the "turn ON" state, and when `on == true`, the method sets the UI to the "turn OFF" state. The absence of any documentation means:

1. A reader of the header cannot determine the correct interpretation of the `on` parameter without reading the implementation.
2. The inverted logic cannot be flagged as an intentional design choice versus a defect by documentation alone.
3. Callers in other translation units have no indication that passing `true` will render a "turn OFF" confirmation and passing `false` will render a "turn ON" confirmation.

The auto-close timer behaviour (10-second timeout triggers `reject()`) is also completely undocumented in both the header and implementation, which is safety-relevant: if the operator does not respond within 10 seconds the dialog silently closes with a rejection result.

---

### VORWarningDialog

| Method | Doc comment present? | Accurate? | Parameters/return described? |
|--------|----------------------|-----------|------------------------------|
| Constructor | No | N/A | N/A |
| Destructor | No | N/A | N/A |
| `hideEvent()` | No | N/A | N/A |
| `showEvent()` | No | N/A | N/A |

No doc comments of any form exist in either file for this class.

`showEvent()` contains the entirety of the safety-warning text population logic including translatable legal disclaimer text and a 30-second auto-reject timer. None of this is described. A single inline comment `// wait 30 second before closing the dialog` exists at line 57 of the `.cpp` only, which partially documents the timer start but does not explain the consequence (dialog auto-closes via `reject()`, which means the VOR warning is dismissed without operator acknowledgement if no interaction occurs within 30 seconds).

---

## Findings

**A25-1** · LOW · No documentation on `UnlockReasonDialog` public interface

**Description:** Neither the header nor the implementation file for `UnlockReasonDialog` contains any doc comments for its four public methods. The constructor's connection of 14 buttons to a single slot, `getReason()`'s dependency on a prior slot invocation for meaningful return value, and `languageChanged()`'s role as a full UI retranslation method are all undescribed.

**Fix:** Add a class-level comment explaining the dialog's purpose (capturing an operator-selected unlock reason after an impact or checklist lockout). Add a comment above `getReason()` noting that the return value is only meaningful after the dialog has been accepted (i.e., after a reason button was clicked). Add a comment above `languageChanged()` describing its role and when it must be called.

---

**A25-2** · LOW · No documentation on `UnlockReasonDialog::setReason()` slot behaviour

**Description:** `setReason()` is a private method used as a slot that performs two non-obvious actions: it captures the text of the clicked button via `sender()` cast to `QPushButton*`, and it emits `accept()` directly (rather than calling `QDialog::accept()`). This dual responsibility — recording state and closing the dialog — is completely undocumented. Any future maintainer editing this slot is at risk of breaking the accept flow or the reason capture.

**Fix:** Add a comment above the `setReason()` declaration in the header (or at minimum above the definition in the `.cpp`) explaining that it reads `sender()` to extract the button label into `m_reason` and then accepts the dialog.

---

**A25-3** · HIGH · `VORConfirmationDialog::isBeingTurnOn(bool on)` has inverted boolean logic with no documentation

**Description:** The method `isBeingTurnOn(bool on)` is the sole public configuration method of the VOR Confirmation Dialog, a safety-critical dialog that either tags out a vehicle (denying driver access) or removes a tag-out (restoring driver access). The boolean parameter `on` is inverted in the implementation:

- `on == false` → UI displays "turn ON VOR mode", "TURN ON" button, note about tagging out equipment and denying access.
- `on == true` → UI displays "turn OFF VOR mode", "TURN OFF" button, note about restoring driver access.

This is the opposite of what the method name `isBeingTurnOn` and the parameter name `on` suggest. There is no doc comment, no parameter description, no note about this inversion, and no `// intentional` or similar annotation anywhere in the file. Any caller reading only the header will assume `on = true` configures the dialog for a VOR activation (turn-on) and `on = false` for a VOR deactivation (turn-off), which is precisely backwards. If a call site passes the parameter based on its intuitive meaning, the operator will be presented with the wrong confirmation dialog — potentially resulting in unintended VOR mode changes on safety-critical equipment.

**Fix:** At minimum, add a doc comment above the declaration in the header that explicitly states the inverted semantics: e.g., `// NOTE: pass on=false to configure for VOR activation; pass on=true to configure for VOR deactivation`. However, the correct remediation is to fix the boolean inversion in the implementation (addressed in the logic/correctness pass) and then document the corrected semantics with a standard doc comment describing the parameter.

---

**A25-4** · HIGH · Auto-close timer behaviour undocumented in VOR dialogs

**Description:** Both `VORConfirmationDialog` and `VORWarningDialog` implement auto-close timers via `QTimer` that trigger `reject()` if the operator does not interact within a fixed timeout period (10 seconds and 30 seconds respectively). In `VORConfirmationDialog`, a 10-second timeout silently rejects the confirmation dialog, meaning no VOR mode change occurs — but this is not documented anywhere in the header or implementation (no comment at all). In `VORWarningDialog`, the 30-second timeout dismisses the safety warning without acknowledgement; there is only a partial comment (`// wait 30 second before closing the dialog`) at the timer start line in the `.cpp`, which does not explain the safety implication of rejection (the caller must handle `Rejected` to determine whether the operator actually read and acknowledged the warning).

For safety-critical dialogs, the auto-close timeout and its consequence (rejection rather than acceptance) must be documented so that callers know they cannot treat a closed dialog as an implicit acceptance.

**Fix:** Add a class-level comment to both `VORConfirmationDialog` and `VORWarningDialog` headers explaining: (a) that a timer auto-closes the dialog via `reject()`, (b) the timeout duration, and (c) that callers must check the dialog result code to distinguish operator acceptance from a timeout rejection.

---

**A25-5** · MEDIUM · `showEvent()` in VORWarningDialog used as primary initialisation method — undocumented

**Description:** `VORWarningDialog::showEvent()` is the only place where the dialog's safety-warning text, legal disclaimer, and timer are initialised. This is a non-standard pattern: Qt's `showEvent` is a lifecycle hook expected to handle show-time side effects, not primary content population. The implementation builds three large translatable strings and a substantial HTML payload on every show event. There is no comment explaining why initialisation was placed in `showEvent()` rather than the constructor (likely to allow `tr()` to use the current locale at show time rather than construction time). Without documentation, a maintainer might move content initialisation to the constructor, breaking runtime language switching, or might add duplicate content population in both locations.

**Fix:** Add a comment above `showEvent()` in the header (and/or `.cpp`) stating that content is initialised here rather than in the constructor to ensure translatable strings reflect the locale active at display time.

---

**A25-6** · INFO · No class-level documentation on any of the three dialog classes

**Description:** None of the three classes (`UnlockReasonDialog`, `VORConfirmationDialog`, `VORWarningDialog`) has a class-level comment describing its purpose, usage contract, or caller responsibilities. For the two VOR dialogs especially, a brief description of the VOR feature context, the dialog's role in the operator confirmation flow, and how result codes should be interpreted would materially reduce the risk of misuse by future maintainers.

**Fix:** Add a brief class-level comment above each class definition in its header file describing: (a) the dialog's purpose in the application workflow, (b) how it is intended to be invoked, and (c) what the result codes mean in the application context.

---

## Summary Table

| ID | Severity | Title |
|----|----------|-------|
| A25-1 | LOW | No documentation on `UnlockReasonDialog` public interface |
| A25-2 | LOW | No documentation on `UnlockReasonDialog::setReason()` slot behaviour |
| A25-3 | HIGH | `VORConfirmationDialog::isBeingTurnOn(bool on)` has inverted boolean logic with no documentation |
| A25-4 | HIGH | Auto-close timer behaviour undocumented in VOR dialogs |
| A25-5 | MEDIUM | `showEvent()` in `VORWarningDialog` used as primary initialisation method — undocumented |
| A25-6 | INFO | No class-level documentation on any of the three dialog classes |

**Finding counts:** HIGH: 2, MEDIUM: 1, LOW: 2, INFO: 1
# Pass 3 Agent A26 — Documentation

**Audit run:** 2026-02-28-01
**Branch:** master
**Repo root:** C:/Projects/cig-audit/repos/mark3-pvd

---

## Reading Evidence

### `ui/warningdialog.h` + `ui/warningdialog.cpp`

**Class:** `WarningDialog` (extends `QDialog`)

**Enum defined:**
- `WarningDialogType` (line 10, warningdialog.h) — values: `VOR`, `Transport`, `Maintenance`

**Public methods (warningdialog.h):**

| Line | Method | Doc comment present |
|------|--------|---------------------|
| 17 | `explicit WarningDialog(WarningDialogType type, QWidget *parent = 0)` | No |
| 18 | `~WarningDialog()` | No |

**Protected methods (warningdialog.h):**

| Line | Method | Doc comment present |
|------|--------|---------------------|
| 29 | `void hideEvent(QHideEvent *)` | No |
| 30 | `void showEvent(QShowEvent *event = 0)` | No |

**Private methods (warningdialog.h):**

| Line | Method | Doc comment present |
|------|--------|---------------------|
| 24 | `QString showVorWarning()` | No |
| 25 | `QString showTransportWarning()` | No |
| 26 | `QString showMaintenanceWarning()` | No |

**Signals:** None declared.
**Slots:** None explicitly declared (uses `QDialog::accept` and `QDialog::reject` via `connect`).

**Implementation notes:**
- Constructor connects `btnACK` clicked to `accept()`, and a QTimer timeout to `reject()`.
- `showEvent` starts a 45-second auto-dismiss timer (`m_timer->start(45000)`).
- `hideEvent` stops the timer.
- The three private `show*Warning()` methods each return an HTML string containing safety-critical warning text.
- The `WarningDialogType` enum controls which message is shown.

---

### `utils/barcode128.h` + `utils/barcode128.cpp`

**Classes:** `BarcodeChar`, `Barcode128`

**Macros/constants defined (barcode128.cpp):**
- `START_CODE 104` — selects Code B (uppercase + lowercase + digits)
- `END_CODE 106`
- `MODULO_VAL 103`

**`BarcodeChar` public methods (barcode128.h):**

| Line | Method | Doc comment present |
|------|--------|---------------------|
| 10 | `BarcodeChar()` (default ctor) | No |
| 17 | `BarcodeChar(const BarcodeChar &other)` (copy ctor) | No |
| 24 | `BarcodeChar(int value, QString name, QString pattern)` (value ctor) | No |
| 31 | `BarcodeChar &operator=(const BarcodeChar &other)` | No |

**`Barcode128` public methods (barcode128.h):**

| Line | Method | Doc comment present |
|------|--------|---------------------|
| 50 | `Barcode128(const QString &info, int height = 100, int sizeMult = 2)` | No |
| 51 | `~Barcode128()` | No |
| 52 | `static int width(const QString &info, int sizeMult)` | No |
| 54 | `QPixmap pixmap()` | No |

**Signals/Slots:** None.
**Types/Enums:** None beyond the two classes.

**Implementation notes:**
- Constructor builds the barcode image into a `QImage` at construction time; `pixmap()` converts it.
- `width()` uses a fixed formula: `(info.length() * 11 + 13 + 11 + 11) * sizeMult + 30`. The magic numbers (11 modules per data char, 13 for start, 11 for checksum, 11 for stop, 30 for quiet zones) are undocumented.
- The `#define START_CODE 104` chooses Code B; there is a comment in Chinese noting type A/B/C, but no English explanation.
- The `.cpp` file has an inline comment `// 103 for type A (大写+数字), 104 for type B (大小写+数字), 105 for type C (数字)` on line 5 — this is the only documentation present for the mode selection.
- `initChars()` is gated on `START_CODE` via `#if`/`#elif`; the `#else` block is a stub with `// todo type c`.

---

### `utils/bytearray.h` (header-only)

**Class:** `ByteArray`

**Macros defined (lines 6–11):**
- `LE_INT(c1, c2, c3, c4)` — little-endian 32-bit integer assembly
- `BE_INT(c1, c2, c3, c4)` — big-endian 32-bit integer assembly
- `LE_SHORT(c1, c2)` — little-endian 16-bit integer assembly
- `BE_SHORT(c1, c2)` — big-endian 16-bit integer assembly
- `BE_LONG(c1, c2, c3, c4, c5, c6, c7, c8)` — big-endian 64-bit integer assembly

**`ByteArray` public static methods:**

| Line | Method | Doc comment present |
|------|--------|---------------------|
| 16 | `static QByteArray asprintf(const char *cformat, ...)` | Partial (inline comment line 15: "actually, do not recommend as not type safe") |
| 30 | `static int sscanf(const QByteArray &ba, const char *cformat, ...)` | Partial (inline comment line 29: "not recommend too") |

**Implementation notes — previously identified UB in `asprintf`:**
- Line 20: `va_start(ap, cformat)` is called to size the output.
- Line 21: `va_end(ap)` terminates the first va_list traversal.
- Line 25: `vsprintf(ba.data(), cformat, ap)` is called with `ap` **after** `va_end` — this is undefined behaviour (UB) per C standard; `va_list` must be re-initialized with `va_start` before reuse.
- The comment on line 15 says only "do not recommend as not type safe". The UB is **not documented or warned about**.
- The macros perform left-shift operations; `LE_INT` casts `c1` without `(uchar)`, meaning a signed `char` first argument would invoke UB via a left-shift of a negative value. This is also undocumented.
- `sscanf` uses `vsscanf` without a corresponding second `va_start`, but `va_end` is called at line 36 after the single `va_start` at line 33 — the `sscanf` variant does not re-use `ap` after `va_end`, so it does not share the same UB as `asprintf`.

---

### `utils/logger.h` + `utils/logger.cpp`

**Class:** `Logger` (singleton)

**Enum defined:**
- `LogLevel` (line 8, logger.h) — values: `LogDebug`, `LogInfo`, `LogWarning`, `LogCritical`, `LogFatal`, `LogNone`

**Public methods (logger.h):**

| Line | Method | Doc comment present |
|------|--------|---------------------|
| 13 | `static Logger* instance()` | No |
| 14 | `void close()` | No |
| 15 | `void setLogThreshold(LogLevel level)` | No |
| 16 | `LogLevel logThreshold() const` | No |
| 17 | `void log(LogLevel level, const QString &message)` | No |

**Protected methods (logger.h):**

| Line | Method | Doc comment present |
|------|--------|---------------------|
| 21 | `virtual ~Logger()` | No |
| 22 | `static void logMessageHandler(QtMsgType type, const QMessageLogContext &context, const QString &msg)` | No |

**Signals/Slots:** None.

**Implementation notes:**
- `instance()` is a non-thread-safe singleton (no mutex on construction, though `m_mutex` is used inside `log()`).
- `close()` deletes the singleton and sets `m_instance` to `nullptr`.
- Constructor opens a dated log file under `/mnt/sd` on ARM, `log.txt` otherwise; retains 7 days of logs.
- `logMessageHandler` is installed as the global Qt message handler, routing `qDebug`/`qWarning`/etc. to the file. On `QtFatalMsg` it calls `QCoreApplication::quit()`.
- The `log()` method is mutex-protected; `instance()` is not.
- The `#define LOG_FILE_DIR "/mnt/sd"` hardcodes the SD card path with no documentation.

---

### `utils/zconf.h` (third-party zlib 1.3.1)

Standard upstream zlib configuration header. No project-specific additions, modifications, or custom code were detected. The file matches the canonical zlib 1.3.1 release. No findings required.

---

### `utils/zlib.h` (third-party zlib 1.3.1)

Standard upstream zlib public interface header (version 1.3.1, January 22, 2024). No project-specific additions, modifications, or custom code were detected. No findings required.

---

## Findings

**A26-1** · LOW · `WarningDialog` constructor undocumented — safety-critical behaviour not described

**Description:** `WarningDialog::WarningDialog(WarningDialogType type, QWidget *parent)` has no doc comment. The constructor establishes a 45-second auto-dismiss timer (visible only in `showEvent`, not here) and connects the ACK button to `accept()`. The `type` parameter controls which legal/safety warning message is shown (VOR, Transport, or Maintenance). Because this dialog is displayed when a restricted operational mode is activated, developers unfamiliar with the code may not realise the dialog auto-dismisses (calling `reject()`) after 45 seconds, which has safety implications: the warning disappears even without operator acknowledgement.

**Fix:** Add a doc comment above the declaration in `warningdialog.h` that describes: (1) the `type` parameter and its effect on message content; (2) the auto-dismiss behaviour and its 45-second timeout; (3) that `accept` is returned when ACK is pressed and `reject` when the timer fires.

---

**A26-2** · LOW · `showEvent` timer start behaviour undocumented

**Description:** `WarningDialog::showEvent` is overridden to populate warning text and start the 45-second auto-dismiss timer. There is no doc comment on either the declaration (line 30, `warningdialog.h`) or in the implementation. The timer behaviour — that the dialog will auto-close even without user interaction — is a non-obvious side effect of `showEvent`.

**Fix:** Add a comment above the `showEvent` declaration explaining that it initialises the displayed warning message (based on `m_type`) and starts the auto-dismiss timer.

---

**A26-3** · LOW · `hideEvent` timer stop behaviour undocumented

**Description:** `WarningDialog::hideEvent` (line 29, `warningdialog.h`) stops the auto-dismiss timer. This pairing with `showEvent` is not obvious from the declaration. No comment exists.

**Fix:** Add a comment above the declaration noting that `hideEvent` stops the auto-dismiss timer to prevent spurious `reject()` calls if the dialog is hidden by other means.

---

**A26-4** · LOW · `Barcode128` constructor: magic numbers and encoding selection undocumented

**Description:** `Barcode128::Barcode128(const QString &info, int height, int sizeMult)` (line 50, `barcode128.h`) has no doc comment. The implementation hardcodes `START_CODE 104` (Code B) via a preprocessor define. The `height` and `sizeMult` parameters have no description. More critically, the encoding type (Code A / Code B / Code C) is controlled by a compile-time `#define` that can only be found in the `.cpp` file; this is not mentioned anywhere in the header or in any English comment.

**Fix:** Add a doc comment describing: `info` as the string to encode (Code B: printable ASCII); `height` as image height in pixels; `sizeMult` as the pixel width multiplier per module; and a note that the encoding type is fixed at compile time via `START_CODE` in `barcode128.cpp`.

---

**A26-5** · LOW · `Barcode128::width()` formula undocumented

**Description:** The static method `width(const QString &info, int sizeMult)` (line 52, `barcode128.h`) returns the pixel width required for a barcode image. The formula `(info.length() * 11 + 13 + 11 + 11) * sizeMult + 30` contains five magic numbers: 11 (modules per Code B character), 13 (start symbol modules), 11 (checksum character modules), 11 (stop symbol modules including termination bar), and 30 (quiet zone pixels — 15 each side). None of these are explained anywhere.

**Fix:** Add a doc comment above the declaration and/or a block comment in the implementation explaining each term in the width formula, referencing the Code 128 specification.

---

**A26-6** · HIGH · `ByteArray::asprintf` — undefined behaviour not documented; existing comment is misleading

**Description:** `ByteArray::asprintf` (line 16, `bytearray.h`) contains a critical undefined-behaviour bug: `va_end(ap)` is called on line 21 after the sizing call to `vsnprintf`, and then `vsprintf` is called on line 25 using the same `ap` without a second `va_start`. Per the C standard (C11 §7.16.1), using a `va_list` after `va_end` is undefined behaviour. The existing comment ("actually, do not recommend as not type safe") is inaccurate — the primary hazard is UB causing potential stack corruption, wrong output, or a crash, not merely type safety. Any caller that passes this function a format string with arguments may receive silently corrupted output or a crash, with no runtime indication.

**Fix:** At minimum, add a prominent warning comment directly above the function body describing the UB (use of `ap` after `va_end`) and directing callers to use `QString::asprintf` or `QByteArray::asprintf` (Qt 5.5+) instead. In a proper fix, the function body should re-initialize `ap` with a second `va_start` before the `vsprintf` call. Consider deprecating or removing this method entirely.

---

**A26-7** · MEDIUM · `ByteArray` macro `LE_INT` — missing cast on first argument creates latent sign-extension UB

**Description:** The macros `LE_INT`, `BE_INT`, `LE_SHORT`, and `BE_SHORT` (lines 6–9, `bytearray.h`) cast all arguments except the first (`c1`) with `(uchar)`. For `LE_INT`, the first operand `(c1)` is placed in the least-significant byte position via bitwise OR and is not shifted; however, for `BE_INT` and `BE_SHORT`, `c1` is left-shifted. If `c1` is a signed `char` holding a value above 0x7F, the left-shift of a negative integer is undefined behaviour (C++14 §5.8/2). None of the macros document their expected argument types or warn about this hazard. `BE_LONG` compounds this by deferring to `BE_INT`.

**Fix:** Add a comment block above these macros documenting that all arguments must be of type `unsigned char` (or be explicitly cast to `uchar` at the call site). Alternatively, add explicit `(uchar)` casts to all first arguments to eliminate the UB at the source.

---

**A26-8** · LOW · `Logger::instance()` — singleton thread-safety and lifetime not documented

**Description:** `Logger::instance()` (line 13, `logger.h`) has no doc comment. The implementation performs a non-atomic check-then-act on `m_instance` without holding `m_mutex`. While `log()` itself is mutex-protected, concurrent first calls to `instance()` from multiple threads could construct two `Logger` objects (double construction, double handler registration). The intended usage pattern — call `instance()` once from the main thread before spawning worker threads — is not documented anywhere.

**Fix:** Add a doc comment stating that `instance()` is not thread-safe for construction and must be called from the main thread before any threads that may call `log()` are started. Also document that `close()` must not be called while other threads may still be logging.

---

**A26-9** · LOW · `Logger::close()` — destruction semantics not documented

**Description:** `Logger::close()` (line 14, `logger.h`) deletes the singleton instance and resets `m_instance` to `nullptr`. This also restores the previous Qt message handler. There is no doc comment. Callers cannot know from the header that: (1) calling `close()` invalidates all subsequent `log()` calls (the file will not be open); (2) any queued Qt messages after `close()` will be silently dropped; (3) calling `instance()` after `close()` creates a new Logger instance with a fresh log file.

**Fix:** Add a doc comment noting that `close()` permanently shuts down the logger singleton, restores the previous Qt message handler, and that calling `instance()` afterwards will reopen/recreate the log file.

---

**A26-10** · LOW · `Logger::log()` — threshold semantics and thread-safety not documented

**Description:** `Logger::log(LogLevel level, const QString &message)` (line 17, `logger.h`) has no doc comment. The implementation silently discards messages below `m_logThreshold` and silently discards all messages if the log file is not open. The method is mutex-protected, but this is not stated in the header. Callers cannot know from the API contract that messages may be silently dropped.

**Fix:** Add a doc comment explaining: that messages with `level < logThreshold()` are silently discarded; that the method is thread-safe; and that if the log file failed to open at construction time, all calls are no-ops.

---

**A26-11** · INFO · `Logger::setLogThreshold()` / `logThreshold()` — no doc comment

**Description:** `setLogThreshold(LogLevel level)` (line 15) and `logThreshold() const` (line 16) in `logger.h` have no doc comments. These are simple setter/getter methods for the minimum logging level. The relationship between `LogLevel` enum values and their relative severity ordering is not documented.

**Fix:** Add a brief comment above the setter noting that only messages at or above `level` will be written to file, and documenting that the enum is ordered lowest-to-highest from `LogDebug` to `LogFatal`.

---

**A26-12** · INFO · `BarcodeChar` constructors — no doc comments

**Description:** The three constructors of `BarcodeChar` (default, copy, value-initialising) at lines 10, 17, and 24 of `barcode128.h` have no doc comments. As an internal helper class (`Barcode128` is declared `friend`), this is low severity, but the value constructor's parameter semantics (`value` = numeric Code 128 value, `name` = character name key, `pattern` = module width string of '1' and '0' characters) are not obvious.

**Fix:** Add a brief comment to the value constructor explaining the three parameters, particularly that `pattern` is a string of `'1'`s (bar) and `'0'`s (space) representing module widths in the Code 128 specification.

---

**A26-13** · INFO · `WarningDialog` private warning-message methods — no doc comments

**Description:** `showVorWarning()`, `showTransportWarning()`, and `showMaintenanceWarning()` (lines 24–26, `warningdialog.h`) are private methods with no doc comments. Each returns a complete HTML-formatted safety warning string. The return type `QString` and the HTML nature of the returned content are undocumented at the declaration site.

**Fix:** Add a single-line comment above each private method noting that it returns an HTML-formatted warning string for the respective mode. This aids maintainers who may need to update the warning text.

---

## Summary Table

| ID | Severity | Title |
|----|----------|-------|
| A26-1 | LOW | `WarningDialog` constructor undocumented — safety-critical auto-dismiss behaviour |
| A26-2 | LOW | `showEvent` timer-start behaviour undocumented |
| A26-3 | LOW | `hideEvent` timer-stop behaviour undocumented |
| A26-4 | LOW | `Barcode128` constructor: encoding type and parameter semantics undocumented |
| A26-5 | LOW | `Barcode128::width()` formula magic numbers undocumented |
| A26-6 | HIGH | `ByteArray::asprintf` — UB not documented; existing comment is misleading |
| A26-7 | MEDIUM | `ByteArray` endian macros — missing cast on first argument not warned about |
| A26-8 | LOW | `Logger::instance()` — singleton thread-safety and lifetime not documented |
| A26-9 | LOW | `Logger::close()` — destruction and re-creation semantics not documented |
| A26-10 | LOW | `Logger::log()` — silent-discard behaviour and thread-safety not documented |
| A26-11 | INFO | `Logger::setLogThreshold()` / `logThreshold()` — no doc comments |
| A26-12 | INFO | `BarcodeChar` value constructor parameters undocumented |
| A26-13 | INFO | `WarningDialog` private warning-message methods — no doc comments |

---

## Pass 4 — Code Quality Findings

# Pass 4 Agent A01 — Code Quality

**Audit run:** 2026-02-28-01
**Branch:** master
**Repo root:** C:/Projects/cig-audit/repos/mark3-pvd
**Assigned files:** `run_tests`, `netcfg.json`, `.gitignore`

---

## Reading Evidence

### `run_tests`

**File purpose:** A POSIX shell script that runs the compiled test binary `FleetFocus` and post-processes its output by colourising lines based on their content (PASS, FAIL, DEBUG, WARN).

**Functions/methods:** None defined. The script is a single pipeline with no functions.

**Constants defined:** None. ANSI escape codes are embedded as string literals inline in the `awk` program.

**Types/errors defined:** None.

**Full content (9 lines):**

```sh
#!/bin/sh
./FleetFocus | awk '
    /PASS/ {print "\033[32m" $0 "\033[0m"}    # Green for PASS
    /FAIL/ {print "\033[31m" $0 "\033[0m"}    # Red for FAIL
    /DEBUG/ {print $0}                         # Leave debug as-is (yellow from handler)
    /WARN/ {print $0}                          # Leave warn as-is (magenta from handler)
    !/PASS|FAIL|DEBUG|WARN/ {print $0}        # Other lines unchanged
'
```

Line 1: shebang `#!/bin/sh`
Line 2–8: Single pipeline — `./FleetFocus` piped into an inline `awk` program.

---

### `netcfg.json`

**File purpose:** A JSON configuration file providing default Wi-Fi provisioning credentials (SSID and password). The file is embedded in the Qt resource bundle (`mk3.qrc` line 29) at compile time and listed in the `DISTFILES` variable of both `mk3.pro` (line 192) and `mk3-test.pro` (line 200). Git history shows it was introduced in commit `5fdc821` ("Implement default Wifi SSID & Pass (MK3-289)") and modified in `2adcd83` ("Fix missing SSID and password").

**Functions/methods:** None (data file).

**Constants/types/errors:** None (data file).

**Keys defined:**

| Line | Key | Value |
|------|-----|-------|
| 2 | `password` | `P@ssMK3!` |
| 3 | `ssid` | `cigSecureConnect` |

---

### `.gitignore`

**File purpose:** Tells git which files and patterns to exclude from version control in this repository.

**Functions/methods:** None (configuration file).

**Constants/types/errors:** None (configuration file).

**Rules defined (7 effective lines):**

| Line | Pattern | Effect |
|------|---------|--------|
| 1 | `Makefile` | Ignores the generated production Makefile |
| 2 | `FleetFocus` | Ignores the compiled test/production binary |
| 3 | `.*` | Ignores all dot-files/directories |
| 5 | `/tmp` | Ignores the `/tmp` directory at repo root |
| 7 | `!.gitignore` | Re-includes `.gitignore` itself (negates line 3) |
| 8 | `*.bak` | Ignores all `.bak` backup files |

Note: Line 4 and line 6 are blank separator lines.

---

## Findings

---

**A01-1** · CRITICAL · Plaintext credential committed to version control and compiled into firmware

**Description:** `netcfg.json` contains a plaintext Wi-Fi password (`P@ssMK3!`) and SSID (`cigSecureConnect`) committed to the repository (first introduced in commit `5fdc821`, modified in `2adcd83`). The file is also bundled into the Qt resource archive via `mk3.qrc` (line 29), meaning the credential is compiled directly into every firmware binary. Any party with repository read access or a firmware binary can trivially extract the credential using `strings` or Qt resource tools. The credential cannot be rotated without a code change and a new commit, and the old value remains permanently in git history. This is a provisioning or default network credential that has no business being stored in version control or baked into firmware.

**Fix:** (1) Remove `netcfg.json` from the repository immediately and rotate the password. (2) Add `netcfg.json` to `.gitignore`. (3) Remove `netcfg.json` from `mk3.qrc` and from `DISTFILES` in both `.pro` files. (4) Inject the credential at device provisioning time (written to protected on-device storage, not compiled in). (5) Purge the file from git history using `git filter-repo --path netcfg.json --invert-paths` or an equivalent tool, then force-push and notify all collaborators to re-clone.

---

**A01-2** · HIGH · `run_tests` script has no error handling and silently swallows test-runner failures

**Description:** The script uses `#!/bin/sh` and contains no `set -e`, `set -o pipefail`, or any explicit exit-code propagation. The test binary `./FleetFocus` is piped directly into `awk`. In any POSIX shell without `pipefail`, the exit status of the entire pipeline is that of the last command (`awk`), not of `./FleetFocus`. If `./FleetFocus` crashes, exits non-zero, or cannot be found, the script still exits 0 as long as `awk` exits 0. This means CI or any automated caller will see a success even when all tests have crashed. Additionally, if `./FleetFocus` does not exist in the current working directory (the script is run from a directory other than the one containing the binary) it fails with a non-actionable `./FleetFocus: not found` message with no diagnostic context.

**Fix:** (1) Replace `#!/bin/sh` with `#!/bin/bash` (or use `set -o pipefail` if `sh` must be kept, though `pipefail` is not specified by POSIX). (2) Add `set -euo pipefail` at the top of the script. (3) Capture and propagate the exit code of `./FleetFocus` explicitly, e.g.:

```bash
#!/bin/bash
set -euo pipefail
./FleetFocus | awk '...'
exit "${PIPESTATUS[0]}"
```

(4) Add a guard to verify the binary exists before running it.

---

**A01-3** · MEDIUM · `run_tests` uses a relative path to the test binary

**Description:** The script invokes the test binary as `./FleetFocus` (a path relative to the current working directory at the time the script is run). If the script is executed from any directory other than the one containing the compiled `FleetFocus` binary, it will fail. There is no documentation, comment, or guard indicating the required working directory. The `.gitignore` ignores `FleetFocus` (the binary) but the script assumes it is co-located with itself. The Makefile.test confirms the binary is produced in the same root as `run_tests`, but this is an implicit coupling.

**Fix:** Derive the binary path relative to the script's own location rather than the caller's working directory. For example:

```bash
SCRIPT_DIR="$(cd "$(dirname "$0")" && pwd)"
"${SCRIPT_DIR}/FleetFocus" | awk '...'
```

---

**A01-4** · MEDIUM · `netcfg.json` embeds no schema version and has no validation mechanism

**Description:** `netcfg.json` contains two fields (`ssid`, `password`) with no schema version field, no required-field marker, and no indication of expected value constraints (e.g., SSID must be 1–32 bytes, WPA2 password must be 8–63 bytes). The application code in `wifi.cpp` and `globalconfigs.cpp` validates Wi-Fi parameters at the point of use, but there is no validation path visible for the values loaded from `netcfg.json` itself (no `.cpp` or `.h` file references `netcfg.json` by name). If either key is absent, has an empty value, or has an invalid length, the failure mode is silent or undefined. The absence of a schema version means any future addition of new configuration fields provides no forward- or backward-compatibility signal.

**Fix:** Add a `"version"` field to `netcfg.json` (e.g., `"version": 1`). Add explicit parsing and validation of the file in the code that consumes it, checking that both `ssid` and `password` are present, non-empty, and within specification limits. Return a clear error if validation fails.

---

**A01-5** · MEDIUM · `.gitignore` rule `.*` is overly broad and masks developer tooling files

**Description:** The pattern `.*` on line 3 matches every dot-file and dot-directory at every level of the repository, including — but not limited to — `.env`, `.env.local`, IDE project files (`.idea/`, `.vscode/`), and secret key files (`.ssh/`, `.netrc`). While the rule `!.gitignore` on line 7 correctly re-includes `.gitignore` itself, any other configuration or tooling file that developers may legitimately want to track (e.g., `.clang-format`, `.editorconfig`, `.clang-tidy`) is silently excluded. Developers may not notice that their tooling configuration files are not being tracked, leading to inconsistent development environments across the team.

**Fix:** Replace the single `.*` wildcard with an explicit allowlist/denylist approach. Keep denying clearly sensitive patterns, and explicitly allow known tooling dot-files that should be tracked:

```
# Explicitly ignore sensitive files
.env
.env.*
.netrc

# Allow tracked dot-files
!.gitignore
!.clang-format
!.editorconfig
```

---

**A01-6** · LOW · `.gitignore` ignores `Makefile` but not `Makefile.test`

**Description:** Line 1 of `.gitignore` ignores `Makefile` (the generated production Makefile). However, `Makefile.test` (the generated test Makefile) is not ignored and is tracked in the repository. `Makefile.test` is a fully generated file produced by `qmake -o Makefile.test mk3-test.pro` and contains machine-specific absolute paths (e.g., `/home/ryanharm/git/sdk/qt/...`, `/home/ryanharm/git/mark3-pvd/...`) embedded throughout. Committing generated files with developer-specific absolute paths pollutes the repository history, causes spurious diffs on every developer machine, and leaks details about the development environment layout.

**Fix:** Add `Makefile.test` to `.gitignore` and remove it from the repository index (`git rm --cached Makefile.test`).

---

**A01-7** · LOW · `Makefile.test` (tracked file) contains hardcoded developer home directory paths

**Description:** Although `Makefile.test` is not one of the three directly assigned files, it is a tracked file in the repository and its presence is directly caused by the gap in `.gitignore` noted in A01-6. The file contains multiple absolute paths rooted in `/home/ryanharm/git/...`, including SDK paths and build output directories. These paths are specific to a single developer's workstation. Any other developer or CI system must regenerate this file or patch all paths before building tests. This is a leaky abstraction — the build system's internal layout is exported into version control.

**Fix:** Add `Makefile.test` to `.gitignore` (see A01-6). Document the `qmake` command to regenerate it in a `README` or build script. All developers regenerate it locally; it is never committed.

---

**A01-8** · LOW · `run_tests` script has no usage comment or documentation

**Description:** The script is nine lines long with no header comment explaining its purpose, prerequisites (the `FleetFocus` binary must be pre-built), how to build it, or what the coloured output means. A new developer reading the repository has no context for when or how to run it, whether it is meant to be run manually or by a CI step, or what a passing run looks like.

**Fix:** Add a short comment block at the top of the script:

```sh
#!/bin/sh
# run_tests - Execute the compiled FleetFocus test binary and colourise output.
# Prerequisites: build the test binary first with: make -f Makefile.test
# Usage: ./run_tests
# Exit code mirrors the exit code of the FleetFocus binary (requires bash + pipefail).
```

---

**A01-9** · INFO · `netcfg.json` is listed in `DISTFILES` but no source code reads it

**Description:** `netcfg.json` is listed in the `DISTFILES` variable of both `mk3.pro` and `mk3-test.pro`, and is included in `mk3.qrc` (compiled into the Qt resource bundle). However, no `.cpp` or `.h` file in the repository references `netcfg.json` by name, nor does any code read from the `qrc:/netcfg.json` resource path. It is possible the file is read via a generic path that was not found in this search, or that the feature that reads it was removed while the file itself was not cleaned up. This is dead configuration — a file that is compiled into every firmware image but appears to serve no live code path.

**Fix:** Audit whether any code actually loads `netcfg.json` at runtime. If no code reads it, remove it from `mk3.qrc`, from `DISTFILES` in both `.pro` files, and from the repository. If code does read it, add a source-level comment or search tag so it can be located by future auditors.

---

**A01-10** · INFO · `run_tests` awk patterns are case-sensitive and may miss mixed-case output

**Description:** The `awk` patterns `/PASS/`, `/FAIL/`, `/DEBUG/`, `/WARN/` are all uppercase and case-sensitive. If any test or log output uses mixed case (e.g., `Pass`, `fail`, `Warning`), those lines will fall through to the uncolourised default case (`!/PASS|FAIL|DEBUG|WARN/`). This is a minor robustness gap rather than a security issue, but it can result in failures being displayed without the red colouring that would make them immediately visible.

**Fix:** Use case-insensitive matching in awk (`/[Pp][Aa][Ss][Ss]/` or `tolower($0) ~ /pass/`) or document the required output format contract in the test framework.

---

## Summary Table

| ID | Severity | Title |
|----|----------|-------|
| A01-1 | CRITICAL | Plaintext credential committed to version control and compiled into firmware |
| A01-2 | HIGH | `run_tests` has no error handling and silently swallows test-runner failures |
| A01-3 | MEDIUM | `run_tests` uses a relative path to the test binary |
| A01-4 | MEDIUM | `netcfg.json` embeds no schema version and has no validation mechanism |
| A01-5 | MEDIUM | `.gitignore` rule `.*` is overly broad and masks developer tooling files |
| A01-6 | LOW | `.gitignore` ignores `Makefile` but not `Makefile.test` |
| A01-7 | LOW | `Makefile.test` (tracked file) contains hardcoded developer home directory paths |
| A01-8 | LOW | `run_tests` script has no usage comment or documentation |
| A01-9 | INFO | `netcfg.json` is listed in `DISTFILES` but no source code reads it |
| A01-10 | INFO | `run_tests` awk patterns are case-sensitive and may miss mixed-case output |
# Pass 4 Agent A02 — Code Quality

**Audit run:** 2026-02-28-01
**Branch:** master
**Files reviewed:** `mk3.pro`, `mk3-test.pro`

---

## Reading Evidence

### mk3.pro

**Purpose:** Main Qt application project file for the FleetFocus production build. Controls what source, header, UI, and resource files are compiled into the `FleetFocus` binary.

| Setting | Line(s) | Value |
|---|---|---|
| `DEFINES += "TEST_MODE=0"` | 6 | Disables test mode for production build |
| `QT` modules | 8 | `core gui serialport serialbus bluetooth network` |
| `QT += widgets` (conditional) | 10 | Added when Qt major version > 4 |
| `linux:` block — `INCLUDEPATH` | 13–14 | `../sdk/kernel_include`, `../sdk/3rd/include` |
| `linux:` block — `LIBS` | 15 | `-L../sdk/3rd/lib` |
| `RCC_DIR` | 18 | `tmp/rcc` |
| `MOC_DIR` | 19 | `tmp/moc` |
| `UI_DIR` | 20 | `tmp/ui` |
| `OBJECTS_DIR` | 21 | `tmp/obj` |
| `TARGET` | 23 | `FleetFocus` |
| `TEMPLATE` | 24 | `app` |
| `DEFINES += QT_DEPRECATED_WARNINGS` | 30 | Enables deprecation warnings |
| `SOURCES` | 38–96 | 57 source files |
| `HEADERS` | 98–157 | 59 header entries (includes one duplicate) |
| `FORMS` | 160–184 | 23 UI form files |
| `RESOURCES` | 186–187 | `mk3.qrc` |
| `TRANSLATIONS` | 189 | `lang_es_ES.ts` |
| `DISTFILES` | 191–192 | `netcfg.json` |

**Commented-out define (line 35):**
```
#DEFINES += QT_DISABLE_DEPRECATED_BEFORE=0x060000
```

**Defines:**
- `TEST_MODE=0` (line 6)
- `QT_DEPRECATED_WARNINGS` (line 30)

---

### mk3-test.pro

**Purpose:** Qt test project file for the FleetFocus unit test build. Mirrors the production project but adds the `testlib` Qt module, the `UNIT_TEST` define, and four test source/header file pairs from `test/`.

| Setting | Line(s) | Value |
|---|---|---|
| `DEFINES += "TEST_MODE=0"` | 6 | Same as production — test mode disabled at macro level |
| `DEFINES += UNIT_TEST` | 7 | Enables unit-test code paths |
| `QT` modules | 9 | `core gui serialport serialbus bluetooth network testlib` |
| `QT += widgets` (conditional) | 11 | Added when Qt major version > 4 |
| `linux:` block — `INCLUDEPATH` | 13–14 | `../sdk/kernel_include`, `../sdk/3rd/include` |
| `linux:` block — `LIBS` | 15 | `-L../sdk/3rd/lib` |
| `RCC_DIR` | 19 | `tmp/rcc` |
| `MOC_DIR` | 20 | `tmp/moc` |
| `UI_DIR` | 21 | `tmp/ui` |
| `OBJECTS_DIR` | 22 | `tmp/obj` |
| `TARGET` | 24 | `FleetFocus` |
| `TEMPLATE` | 25 | `app` |
| `DEFINES += QT_DEPRECATED_WARNINGS` | 31 | Enables deprecation warnings |
| `SOURCES` | 39–100 | 61 source files (57 production + 4 test) |
| `HEADERS` | 102–165 | 63 header entries (59 production entries + 4 test, includes one duplicate) |
| `FORMS` | 168–192 | 23 UI form files (identical to production) |
| `RESOURCES` | 194–195 | `mk3.qrc` |
| `TRANSLATIONS` | 197 | `lang_es_ES.ts` |
| `DISTFILES` | 199–200 | `netcfg.json` |

**Commented-out define (line 36):**
```
#DEFINES += QT_DISABLE_DEPRECATED_BEFORE=0x060000
```

**Defines:**
- `TEST_MODE=0` (line 6)
- `UNIT_TEST` (line 7)
- `QT_DEPRECATED_WARNINGS` (line 31)

**Test-specific sources/headers (lines 40–43 / 103–106):**
- `test/test_ota.cpp` / `test/test_ota.h`
- `test/test_dialog.cpp` / `test/test_dialog.h`
- `test/test_backgroundworker.cpp` / `test/test_backgroundworker.h`
- `test/test_canbus.cpp` / `test/test_canbus.h`

---

## Findings

**A02-1** · MEDIUM · Duplicate HEADERS entry: `utils/logger.h` in both project files

**Description:** `utils/logger.h` appears twice in the `HEADERS` list in both `mk3.pro` (lines 112 and 122) and `mk3-test.pro` (lines 120 and 130). While qmake silently ignores duplicates and this does not cause a build failure, it indicates the file lists were assembled by successive concatenation rather than managed as a whole. It may cause redundant MOC processing depending on the Qt version and tool.

**Fix:** Remove the second occurrence of `utils/logger.h` from the `HEADERS` block in both `mk3.pro` and `mk3-test.pro`.

---

**A02-2** · MEDIUM · Hardcoded relative SDK path outside the repository tree

**Description:** Both project files include a `linux:` block (lines 12–16 in `mk3.pro`; lines 13–17 in `mk3-test.pro`) that adds `../sdk/kernel_include` and `../sdk/3rd/include` to `INCLUDEPATH` and `../sdk/3rd/lib` to `LIBS`. The path `../sdk/` is a sibling directory of the repository root that does not exist in the audited checkout (confirmed absent from `C:/Projects/cig-audit/repos/`). This creates an invisible build dependency on an undocumented directory layout on the developer's machine. Any developer or CI system that clones only this repository will silently get missing-include errors on Linux builds, potentially masking header resolution problems.

**Fix:** Document the required SDK checkout location in a `README` or `BUILD.md`. Consider using a qmake variable (e.g. `SDK_ROOT`) that can be overridden on the command line (`qmake SDK_ROOT=/path/to/sdk`), or use a `.prf` feature file so the dependency is explicit and version-controlled.

---

**A02-3** · MEDIUM · Test project TARGET name collides with production TARGET

**Description:** Both `mk3.pro` and `mk3-test.pro` set `TARGET = FleetFocus` (line 23 / line 24 respectively). If both projects are built in the same shadow-build directory, the test binary will overwrite the production binary without warning. In a CI pipeline that builds both projects this can silently ship a test binary to the deployment stage.

**Fix:** Set `TARGET = FleetFocusTest` (or similar) in `mk3-test.pro` to produce a distinctly named binary.

---

**A02-4** · LOW · `TEST_MODE=0` define is misleading in the test project

**Description:** `mk3-test.pro` defines `TEST_MODE=0` on line 6, identical to the production project, while simultaneously defining `UNIT_TEST` on line 7. If `TEST_MODE` is intended to gate test-only code paths (distinct from `UNIT_TEST`), the value `0` in the test project is contradictory. If `TEST_MODE` is not used for this purpose, carrying it into the test project with the same value adds confusion about what distinguishes the two build configurations at the macro level.

**Fix:** Either remove `TEST_MODE=0` from `mk3-test.pro` if it is irrelevant to the test build, or set it to `1` if it is supposed to activate test-specific code paths. Add a comment explaining the intended distinction between `TEST_MODE` and `UNIT_TEST`.

---

**A02-5** · LOW · Commented-out `QT_DISABLE_DEPRECATED_BEFORE` define is boilerplate noise

**Description:** Both files carry the QtCreator-generated comment block (lines 33–35 in `mk3.pro`; lines 33–36 in `mk3-test.pro`) with a commented-out `#DEFINES += QT_DISABLE_DEPRECATED_BEFORE=0x060000`. This is copy-paste boilerplate from project creation in 2018 and has never been activated. Combined with the active `QT_DEPRECATED_WARNINGS` define, the project emits warnings for deprecated APIs but does not enforce that deprecated APIs are absent. In a codebase targeting embedded Linux hardware this means deprecation warnings can accumulate unnoticed.

**Fix:** Either remove the comment block entirely to reduce noise, or enable `QT_DISABLE_DEPRECATED_BEFORE` for the Qt version in use to make the build fail on deprecated API usage. At minimum, document explicitly why it remains disabled.

---

**A02-6** · LOW · Inconsistent indentation in SOURCES block between the two project files

**Description:** In `mk3.pro`, the first entry in `SOURCES` uses 8-space indentation (`        main.cpp`, line 39), while all subsequent entries use 4-space indentation (e.g. `    mytranslator.cpp`, line 40). This same asymmetry is replicated in `mk3-test.pro`. The inconsistency suggests `main.cpp` was the original auto-generated entry and all later files were appended with a different editor setting. This is a cosmetic issue but indicates the project files are not reviewed as part of code review.

**Fix:** Normalise all SOURCES entries to 4-space indentation. The corrected first line should read `    main.cpp \`.

---

**A02-7** · LOW · `OBJECTS_DIR`, `MOC_DIR`, `RCC_DIR`, `UI_DIR` share the same `tmp/` prefix with no platform conditioning

**Description:** Both project files write intermediate files to `tmp/rcc`, `tmp/moc`, `tmp/ui`, and `tmp/obj` (lines 18–21 / 19–22). Because both projects share the same relative path and the production and test binaries use the same `TARGET` name, a `make clean` in a shared shadow build can remove intermediate files from both builds simultaneously. On Windows this path is relative to the `.pro` file location, meaning parallel builds of the two projects will collide if invoked from the same directory.

**Fix:** Use distinct subdirectories per project, for example `tmp_test/` in `mk3-test.pro`, or rely on Qt's shadow build mechanism and remove the explicit `*_DIR` overrides.

---

**A02-8** · INFO · `FleetIQ360App_5.2.2F.h` present in `test/` but not referenced in either project file

**Description:** The file `test/FleetIQ360App_5.2.2F.h` exists on disk inside the `test/` directory but is not listed in `HEADERS` or `SOURCES` in either `mk3.pro` or `mk3-test.pro`. This suggests it may be a leftover artefact from a previous release or an accidentally committed file. It is not a build defect but it is dead weight in the repository.

**Fix:** Determine whether `test/FleetIQ360App_5.2.2F.h` is still needed. If not, remove it from the repository to keep the `test/` directory clean.

---

**A02-9** · INFO · Style inconsistency: section ordering differs between the two files

**Description:** Both files follow the same overall structure (DEFINES, QT, platform block, build dirs, TARGET/TEMPLATE, SOURCES, HEADERS, FORMS, RESOURCES, TRANSLATIONS, DISTFILES). However, `mk3-test.pro` places `DEFINES += UNIT_TEST` (line 7) before the `QT` assignment rather than grouping all DEFINES together or placing them after QT as done in `mk3.pro`. This minor ordering inconsistency makes it harder to diff the two files and to confirm they are otherwise identical.

**Fix:** Group `DEFINES += UNIT_TEST` together with `DEFINES += "TEST_MODE=0"` and `DEFINES += QT_DEPRECATED_WARNINGS` in a single DEFINES section for clarity.

---

## Summary Table

| ID | Severity | Title |
|---|---|---|
| A02-1 | MEDIUM | Duplicate `utils/logger.h` entry in HEADERS in both project files |
| A02-2 | MEDIUM | Hardcoded relative SDK path (`../sdk/`) outside repository tree |
| A02-3 | MEDIUM | Test project TARGET collides with production TARGET (`FleetFocus`) |
| A02-4 | LOW | `TEST_MODE=0` in test project is contradictory / misleading |
| A02-5 | LOW | Commented-out `QT_DISABLE_DEPRECATED_BEFORE` boilerplate in both files |
| A02-6 | LOW | Inconsistent indentation on first SOURCES entry in both files |
| A02-7 | LOW | Shared `tmp/` intermediate directories cause collision between the two builds |
| A02-8 | INFO | `test/FleetIQ360App_5.2.2F.h` exists on disk but is unreferenced in any project file |
| A02-9 | INFO | Minor section-ordering inconsistency between `mk3.pro` and `mk3-test.pro` |
# Pass 4 Agent A03 — Code Quality

**Audit run:** 2026-02-28-01
**Branch:** master
**Files reviewed:**
- `app/backgroundworker.h`
- `app/backgroundworker.cpp`
- `app/checklist.h`
- `app/checklist.cpp`

---

## 1. Reading Evidence

### `app/backgroundworker.h`

**Classes defined:**

- `OtaWorker` (line 38) — QObject subclass responsible for OTA firmware decompression.
- `BackgroundWorker` (line 62) — QObject subclass; central coordinator for all background hardware and network operations.

**Types / enums defined:**

| Name | Kind | Location |
|------|------|----------|
| `OtaWorker::QuitMode` | — | (not here; see BackgroundWorker) |
| `BackgroundWorker::QuitMode` | enum | line 66 — values: `QuitReboot`, `QuitPowerOff`, `QuitApp` |
| `BackgroundWorker::EthernetInterface` | enum (private) | line 100 — values: `EthModem`, `EthWifi` |

**`OtaWorker` methods (with line numbers):**

| Method | Line |
|--------|------|
| `OtaWorker(QObject *parent = nullptr)` (constructor) | 42 |
| `unpack()` | 43 |

**`OtaWorker` member variables:**

| Name | Type | Line |
|------|------|------|
| `m_isRunning` | `QAtomicInteger<quint32>` (public) | 45 |
| `m_mutex` | `QMutex` (private) | 58 |

**`BackgroundWorker` methods (all, with line numbers):**

| Method | Visibility | Line |
|--------|------------|------|
| `BackgroundWorker(QObject *parent = nullptr)` (constructor) | public | 68 |
| `setUI(Dialog *ui)` | public | 69 |
| `networkStatus()` | public inline | 70 |
| `initHash()` | private | 102 |
| `ignitionStateChanged(bool on)` | private | 103 |
| `parseLeaderCmd(const QByteArray &ba, bool local)` | private | 104 |
| `dispatchLeaderCmd(CIGCONF::LeaderCmdType type, const QByteArray &header, const QByteArray &content)` | private | 105 |
| `sendGmtpMessage(CIGCONF::GmtpMessage msg, const QByteArray &ba = QByteArray())` | private | 106 |
| `powerTimerEvent()` | private | 107 |
| `onTimerEvent()` | private | 108 |
| `changePowerState()` | private | 109 |
| `updateFile(const QString &file)` | private | 110 |
| `updateSelf(bool wait = false)` | private | 111 |
| `updateFromRamdisk()` | private | 112 |
| `timeChanged()` | private | 113 |
| `quit(const QuitMode qm)` | private | 114 |
| `quitWaitForAcks(const QuitMode qm)` | private | 115 |
| `printDateBatt()` | private | 116 |
| `getKernelBuildDate()` | private | 117 |
| `convert2UTC(QString tzone, quint64 time)` | private | 118 |
| `pointInPolygon(int polyCorners, CIGCONF::position me, CIGCONF::position *points)` | private | 119 |
| `degrees2radians(double degrees)` | private | 120 |
| `testGeofence(qint32 lat, qint32 lon)` | private | 121 |
| `checkAppCrash()` | private | 122 |
| `checkSdSpace()` | private | 123 |
| `checkFotaFail()` | private | 124 |
| `dataTest()` | private | 126 |
| `ethernetStateChanged(EthernetInterface interface, bool state)` | private | 128 |
| `sendGmtpWifiPos()` | private | 129 |
| `onAllAcksSent()` | private | 131 |
| `handleModemConnection()` | private | 132 |
| `handleNtpSynchronization(EthernetInterface interface, bool newState, bool &reconnect)` | private | 133 |
| `handleWiFiConnection()` | private | 134 |
| `monitTimer()` | private | 136 |
| `initialiseCanbus1()` | private | 138 |
| `initialiseCanbus2()` | private | 139 |

**`BackgroundWorker` signals (line numbers):**

| Signal | Line |
|--------|------|
| `powerStateChanged(CIGCONF::PowerState state)` | 80 |
| `reboot()` | 81 |
| `lockScreen(CIGCONF::MaintLockedCode code, bool remote)` | 82 |
| `ambertImpactScreen()` | 83 |
| `cardAuthorised(bool yes, quint64 id)` | 84 |
| `updateStatusInfo(...)` | 85 |
| `cmdMsgReceived(CIGCONF::BroadcastMessage m)` | 86 |
| `onDemandStarted(...)` | 87 |
| `onDemandExtended(...)` | 88 |
| `onDemandEnded(...)` | 89 |
| `sigLanguageChanged()` | 90 |
| `cmdLogin(quint64 id)` | 91 |
| `unpackOta()` | 92 |
| `cameraSettingsUpdated()` | 93 |

---

### `app/backgroundworker.cpp`

**Free functions defined:**

| Function | Line |
|----------|------|
| `streamUncompress(QByteArray &chunk, z_stream &strm, bool &finished)` | 49 |
| `crc16(quint16& state, const QByteArray &chunk)` | 130 |

**Method definitions (with line numbers in .cpp):**

| Method | Line |
|--------|------|
| `OtaWorker::OtaWorker(QObject *parent)` | 144 |
| `OtaWorker::unpack()` | 146 |
| `BackgroundWorker::BackgroundWorker(QObject *parent)` | 264 |
| `BackgroundWorker::initHash()` | 341 |
| `BackgroundWorker::parseLeaderCmd(const QByteArray &ba, bool local)` | 442 |
| `BackgroundWorker::dispatchLeaderCmd(LeaderCmdType type, const QByteArray &header, const QByteArray &content)` | 512 |
| `BackgroundWorker::sendGmtpMessage(GmtpMessage msg, const QByteArray &extra)` | 2128 |
| `BackgroundWorker::degrees2radians(double degrees)` | 2446 |
| `BackgroundWorker::pointInPolygon(int polyCorners, CIGCONF::position me, CIGCONF::position *points)` | 2450 |
| `BackgroundWorker::testGeofence(qint32 lat, qint32 lon)` | 2470 |
| `BackgroundWorker::setUI(Dialog *ui)` | 2533 |
| `BackgroundWorker::ignitionStateChanged(bool on)` | 2575 |
| `BackgroundWorker::powerTimerEvent()` | 2604 |
| `BackgroundWorker::changePowerState()` | 2645 |
| `BackgroundWorker::onTimerEvent()` | 2913 |
| `BackgroundWorker::updateFile(const QString &file)` | 2920 |
| `BackgroundWorker::updateSelf(bool wait)` | 2943 |
| `BackgroundWorker::updateFromRamdisk()` | 2960 |
| `BackgroundWorker::timeChanged()` | 2969 |
| `BackgroundWorker::quitWaitForAcks(const QuitMode qm)` | 2977 |
| `BackgroundWorker::onAllAcksSent()` | 2990 |
| `BackgroundWorker::quit(const QuitMode qm)` | 2998 |
| `BackgroundWorker::printDateBatt()` | 3040 |
| `BackgroundWorker::convert2UTC(QString tzone, quint64 time)` | 3060 |
| `BackgroundWorker::getKernelBuildDate()` | 3070 |
| `BackgroundWorker::dataTest()` | 3111 |
| `BackgroundWorker::ethernetStateChanged(EthernetInterface interface, bool state)` | 3121 |
| `BackgroundWorker::handleModemConnection()` | 3158 |
| `BackgroundWorker::handleWiFiConnection()` | 3168 |
| `BackgroundWorker::handleNtpSynchronization(EthernetInterface interface, bool newState, bool &reconnect)` | 3173 |
| `BackgroundWorker::sendGmtpWifiPos()` | 3193 |
| `BackgroundWorker::checkAppCrash()` | 3243 |
| `BackgroundWorker::checkSdSpace()` | 3261 |
| `BackgroundWorker::monitTimer()` | 3300 |
| `BackgroundWorker::checkFotaFail()` | 3316 |
| `BackgroundWorker::initialiseCanbus1()` | 3351 |
| `BackgroundWorker::initialiseCanbus2()` | 3372 |

---

### `app/checklist.h`

**Class defined:** `Checklist` (line 6)

**Nested types:**

| Name | Kind | Location |
|------|------|----------|
| `Checklist::CheckItem` | struct (with anonymous union) | lines 9–21 |

`CheckItem` fields:
- Anonymous union containing:
  - Anonymous struct with bitfields: `quint32 qId : 31`, `quint32 doNotRandomize : 1`
  - `quint32 questionId`
- `CIGCONF::ChecklistType type`
- `quint8 questionLen`
- `char question[CHECKLIST_QUESTION_LEN_100+1]`

**`Checklist` methods:**

| Method | Visibility | Line |
|--------|------------|------|
| `Checklist()` (constructor) | public | 23 |
| `isValidCheckItem(const CheckItem &item)` (static inline) | public | 25 |
| `readChecklist()` | public | 27 |
| `saveChecklist()` | public | 30 |
| `clear()` | public | 31 |
| `shuffleChecklist()` | public | 32 |
| `checkItem(int index, bool query = false) const` | public | 34 |
| `setCheckItem(int index, const CheckItem &item)` | public | 35 |
| `checksum() const` | public | 36 |
| `readChecklist50()` | private | 39 |
| `readChecklist100()` | private | 40 |
| `copyAllRandomPreop(CheckItem *randomPreop)` | private | 41 |

**`Checklist` member variables:**

| Name | Type | Line |
|------|------|------|
| `m_checkItems[CHECKLIST_MAX_IDX]` | `CheckItem` | 43 |
| `m_checkItems_shuffled[CHECKLIST_MAX_IDX]` | `CheckItem` | 44 |
| `m_dirty` | `bool` | 45 |
| `m_isShuffled` | `bool` | 46 |

---

### `app/checklist.cpp`

**Method definitions:**

| Method | Line |
|--------|------|
| `Checklist::Checklist()` | 9 |
| `Checklist::readChecklist()` | 13 |
| `Checklist::readChecklist50()` | 22 |
| `Checklist::readChecklist100()` | 65 |
| `Checklist::saveChecklist()` | 139 |
| `Checklist::clear()` | 172 |
| `Checklist::setCheckItem(int index, const CheckItem &item)` | 178 |
| `Checklist::checksum() const` | 188 |
| `Checklist::shuffleChecklist()` | 198 |
| `Checklist::copyAllRandomPreop(CheckItem *randomPreop)` | 227 |
| `Checklist::checkItem(int index, bool query) const` | 238 |

---

## 2. Findings

---

**A03-1** · HIGH · `streamUncompress` uses a `static` local variable for cross-call state

**Description:** `streamUncompress` (backgroundworker.cpp line 58) uses `static bool headerSkipped = false;` to track whether the Qt qCompress 4-byte header has been skipped. Because it is a static local, the variable is shared across all call sites and all threads. If `OtaWorker::unpack()` were ever invoked concurrently on two threads, or if the function is called from a second context before a previous decompress cycle fully resets the flag, the header-skip logic would misbehave and corrupt the output. Even in the single-call path the flag is reset in multiple `return` paths but never inside a destructor or RAII guard, so any future early-return code path risks leaving it in the wrong state. The correct approach is to pass this flag as part of the `z_stream` wrapper or as an explicit parameter, not as a hidden static.

**Fix:** Remove the `static` qualifier and pass `headerSkipped` as a plain local that is passed by reference alongside `z_stream`, or embed it in a small context struct. Alternatively, since Qt's own 4-byte header is only ever prepended to the first chunk, unconditionally strip it before the first `inflateInit` call in `OtaWorker::unpack()` and remove the flag entirely.

---

**A03-2** · HIGH · Dead function `dataTest()` is production-compiled and self-schedules

**Description:** `BackgroundWorker::dataTest()` (backgroundworker.cpp lines 3111–3119) sends arbitrary incrementing GMTP messages over the production connection and reschedules itself indefinitely via `QTimer::singleShot`. Its only call site is a commented-out line at line 2796 (`//QTimer::singleShot(1000, [this](){dataTest();});`). The function itself is not guarded by `#ifdef`, so it is compiled into the release binary, is reachable via the call at line 3118 (self-recursion through singleShot), and is exposed to any code that might accidentally uncomment line 2796. A self-scheduling debug function that transmits data over the modem link must not exist in production code.

**Fix:** Delete `dataTest()` from both the header declaration (backgroundworker.h line 126) and the implementation, and remove the commented-out call site at line 2796.

---

**A03-3** · HIGH · Unreachable `break` after `return true` in multiple `dispatchLeaderCmd` cases

**Description:** Several `switch` cases in `dispatchLeaderCmd` contain `return true;` followed immediately by `break;` on the next line (backgroundworker.cpp lines 1876–1877 for `CMD_OPRNDM`, lines 1887–1888 for `CMD_SHOWNAMES`). The `break` statements are unreachable dead code. This pattern indicates the cases were likely refactored from fall-through to early-return form without cleaning up. While not a runtime bug in these two cases, it is misleading to future maintainers and may mask accidental omission of `return` in other nearby cases.

**Fix:** Remove the unreachable `break;` statements at lines 1877 and 1888.

---

**A03-4** · MEDIUM · Qt deprecated API: `QNetworkConfigurationManager` and `QRegExp`

**Description:** Two Qt 5 APIs that are deprecated in Qt 5.15 and removed in Qt 6 are used:
1. `QNetworkConfigurationManager` is `#include`d in backgroundworker.h (line 7) and `QNetworkConfiguration` is included in backgroundworker.cpp (line 31). Neither class is referenced anywhere in the visible code of these two files; the includes appear to be dead. Both classes are fully removed in Qt 6.
2. `QRegExp` is used in `getKernelBuildDate()` at backgroundworker.cpp line 3090. `QRegExp` is deprecated since Qt 5.0 in favour of `QRegularExpression` and removed in Qt 6.

**Fix:**
1. Remove the `#include <QNetworkConfigurationManager>` from backgroundworker.h and `#include <QNetworkConfiguration>` from backgroundworker.cpp if they are genuinely unused; otherwise replace with `QNetworkInformation` (Qt 6) or a platform-specific alternative.
2. Replace `QRegExp rx(...)` with `QRegularExpression rx(...)` and update the match call accordingly.

---

**A03-5** · MEDIUM · Large commented-out code blocks throughout both files

**Description:** Significant sections of live-logic code have been commented out rather than removed, creating noise and risk of accidental reactivation:

- backgroundworker.h lines 141 (`//EM070::BleCentral *m_bleCentral;`) and 151 (`//BleExpansion *m_bleExpansion;`) — member declarations commented out; corresponding allocation code in the `.cpp` is also commented.
- backgroundworker.cpp lines 264–265, 274 — BLE member initialiser lines commented out in the constructor.
- backgroundworker.cpp lines 2680–2697 — entire `BleCentral`/`BleExpansion` initialisation block (17 lines) commented out inside `changePowerState()`.
- backgroundworker.cpp lines 2854–2856 — BleExpansion disable block commented out.
- backgroundworker.cpp lines 2971–2972 — `m_bleExpansion->setCurrentTime` call commented out in `timeChanged()`.
- backgroundworker.cpp lines 3003–3005 — `m_bleExpansion->setEnabled(false)` commented out in `quit()`.
- backgroundworker.cpp line 2796 — `QTimer::singleShot(1000, [this](){dataTest();});` commented-out debug launch.
- backgroundworker.cpp line 2881 — `QProcess::startDetached("/etc/pvd/mobile -p")` commented out.
- backgroundworker.cpp lines 723–724, 738–740 — double-commented relay-query branches (`//if (!m_bleExpansion)` then `if (!m_canExpansion)`) in `CMD_RLY1` and `CMD_RLY2`.
- backgroundworker.cpp lines 1165–1167, 1191–1193 — BLE shock threshold and period setters commented out.
- backgroundworker.cpp lines 2139, 2147–2148, 2150–2153 — commented `m_bleExpansion` calls inside `GMTP_AUTH_SHOCK` handling.
- backgroundworker.cpp lines 2660, 2665 — commented brightness and log calls.
- backgroundworker.cpp line 2727 — commented gmtpHotStartReconnect connect.
- checklist.h line 28 — declaration `//void saveChecklist50();` commented out.
- checklist.cpp lines 109–137 — entire `saveChecklist50()` implementation (29 lines) commented out.

**Fix:** Remove all commented-out code blocks. If the BLE expansion path is intentionally disabled pending hardware availability, use a `#ifdef HAVE_BLE_EXPANSION` guard or delete the code with a note in git commit history. Commented-out production code should not reside in the main branch.

---

**A03-6** · MEDIUM · `m_isShuffled` member is declared but never written or read

**Description:** `Checklist::m_isShuffled` is declared as a private `bool` in checklist.h (line 46) and is initialised to nothing (not listed in the constructor initialiser list — meaning it defaults to an indeterminate value since no `= false` initialiser is present in the in-class declaration). The variable is never read or written anywhere in checklist.cpp. It appears to be a leftover from an earlier design that checked whether `shuffleChecklist()` had been called.

**Fix:** Either remove `m_isShuffled` entirely or initialise it in the constructor (`m_isShuffled(false)`) and use it as a guard inside `checkItem()` to avoid returning shuffled data before `shuffleChecklist()` has been called. As currently written, `checkItem()` defers the shuffle decision to `gCfg->preopRandom()` which is a valid alternative, making the member entirely redundant.

---

**A03-7** · MEDIUM · `Checklist` constructor does not initialise `m_isShuffled` or the array members

**Description:** The `Checklist` constructor (checklist.cpp line 9) initialises only `m_dirty(false)`. The member `m_isShuffled` (bool) receives no initialisation and contains indeterminate data until written. The two `CheckItem` arrays `m_checkItems` and `m_checkItems_shuffled` are not initialised in the constructor either; they are zeroed lazily inside `readChecklist50()` and `readChecklist100()`. If `checkItem()` or `checksum()` is called before `readChecklist()`, they operate on uninitialised memory.

**Fix:** Add a `memset` of both arrays and initialise `m_isShuffled` in the constructor body, e.g.:
```cpp
Checklist::Checklist() : m_dirty(false), m_isShuffled(false)
{
    memset(m_checkItems, 0, sizeof(m_checkItems));
    memset(m_checkItems_shuffled, 0, sizeof(m_checkItems_shuffled));
}
```

---

**A03-8** · MEDIUM · `shuffleChecklist()` rotate boundary is off by one

**Description:** `Checklist::shuffleChecklist()` at checklist.cpp line 219 calls:
```cpp
std::rotate(&randomPreop[0], &randomPreop[rotateNum], &randomPreop[numberOfRandomPreop-1]);
```
The `end` iterator passed to `std::rotate` is `&randomPreop[numberOfRandomPreop-1]`, which points to the last element rather than one-past-the-end. This means the final element in the `randomPreop` array is never rotated — it stays fixed regardless of `rotateNum`. The correct end iterator is `&randomPreop[numberOfRandomPreop]`. This is a subtle off-by-one that produces a non-uniform rotation of the checklist questions.

**Fix:** Change the call to:
```cpp
std::rotate(&randomPreop[0], &randomPreop[rotateNum], &randomPreop[numberOfRandomPreop]);
```

---

**A03-9** · MEDIUM · `convert2UTC` has dead code and is effectively a stub

**Description:** `BackgroundWorker::convert2UTC` (backgroundworker.cpp lines 3060–3068) handles only the `"PDT"` timezone and falls through to `return time` for all others. A `//TODO: add other kernel build timezone here.` comment sits below an unreachable `else` branch. The only consumer is `getKernelBuildDate()`. In practice the function adds 7 hours only if the kernel was built in Pacific Daylight Time, producing a wrong UTC conversion for any other kernel build timezone (e.g., PST, EST, UTC). The `else` clause at line 3065 is always reached when the timezone is not PDT, making the `if/else` structure misleading.

**Fix:** Either expand the timezone table to cover all expected cases, or — preferably — parse the kernel build date with `QDateTime::fromString` using an explicit Qt timezone offset rather than a string abbreviation lookup. Remove the dead comment.

---

**A03-10** · MEDIUM · `CMD_RLY1` and `CMD_RLY2` contain unreachable `QueryCmd` response branches

**Description:** In `dispatchLeaderCmd`, both `CMD_RLY1` (lines 719–734) and `CMD_RLY2` (lines 736–750) first check `if (type == QueryCmd) return false;` at the top of each case, then unconditionally fall through to a second `if (type == QueryCmd)` block that formats and returns a response. The second `QueryCmd` check can never be reached because execution already returned false at the first check. This appears to be leftover code from a previous design that allowed querying the relay state.

**Fix:** Remove the dead `if (type == QueryCmd)` response blocks (lines 727–729 and 743–745) from both relay cases, or remove the early `return false` if querying is intentionally desired.

---

**A03-11** · LOW · Mixed type conventions: `uint8_t` used alongside `quint8` in `checklist.cpp`

**Description:** `Checklist::copyAllRandomPreop` (checklist.cpp line 229) uses the C stdint type `uint8_t` for `tempCtr` while all other integer variables throughout both checklist files use Qt's `quint8`, `quint16`, `quint32` types. This minor inconsistency suggests the function was added by a different author or copied from non-Qt code without normalisation.

**Fix:** Replace `uint8_t tempCtr = 0;` with `quint8 tempCtr = 0;` to maintain consistent Qt-style typing throughout the file.

---

**A03-12** · LOW · `query == true` comparison style inconsistency in `checkItem()`

**Description:** `Checklist::checkItem()` (checklist.cpp line 239) compares `if (query == true)` rather than the idiomatic `if (query)`. Every other boolean check throughout both files uses the idiomatic form. The `== true` comparison triggers a compiler warning with `-Wbool-compare` on some toolchains.

**Fix:** Change `if (query == true)` to `if (query)`.

---

**A03-13** · LOW · `convert2UTC` takes `QString` by value instead of const reference

**Description:** `BackgroundWorker::convert2UTC(QString tzone, quint64 time)` (backgroundworker.h line 118, backgroundworker.cpp line 3060) passes the timezone string by value. Since the string is not modified inside the function, passing by `const QString &` avoids an unnecessary heap allocation for the implicit copy.

**Fix:** Change the signature to `quint64 convert2UTC(const QString &tzone, quint64 time)`.

---

**A03-14** · LOW · Indentation inconsistency in `backgroundworker.cpp`

**Description:** Several locations mix tab and space indentation:
- Lines 1837–1838 (`case CMD_LANG:` block closing) use a tab character where the rest of the file uses 4-space indentation.
- Lines 2835 (`//PwmBacklight::setBrightness(10);`) uses a tab.
- `testGeofence()` body (lines 2472–2530) uses 12-space leading indentation rather than the 4-space baseline used everywhere else, with inconsistent intermediate levels.

These inconsistencies suggest the code was pasted from different sources without reformatting.

**Fix:** Run the file through the project's code formatter (clang-format or Qt Creator's auto-format) to normalise all indentation to 4 spaces.

---

**A03-15** · LOW · `OtaWorker::m_isRunning` is a `public` data member

**Description:** `OtaWorker::m_isRunning` (backgroundworker.h line 45) is declared `public` with the `m_` prefix that signals it should be a private member. It is accessed directly from `BackgroundWorker::updateSelf()` (backgroundworker.cpp line 2954) with `m_otaWorker->m_isRunning`, bypassing encapsulation. While the `m_` prefix convention for private members is used consistently everywhere else in the header, this member is intentionally (or accidentally) made public.

**Fix:** Either make `m_isRunning` private and add a public accessor method `bool isRunning() const { return m_isRunning; }`, or — if direct atomic access from the owning class is the intent — document the design decision explicitly.

---

**A03-16** · LOW · `handleNtpSynchronization` always aborts NTP regardless of interface direction

**Description:** `BackgroundWorker::handleNtpSynchronization()` (backgroundworker.cpp lines 3173–3191) contains:
```cpp
if (!newState || interface == EthWifi || interface == EthModem) {
    m_ntpSync->abortConnection();
}
```
Since `interface` can only ever be `EthModem` or `EthWifi`, the condition `interface == EthWifi || interface == EthModem` is always true; this means `m_ntpSync->abortConnection()` is called unconditionally on every invocation regardless of `newState`. The `!newState` sub-condition is therefore dead. This appears to be a logic error introduced when the function was refactored out of `ethernetStateChanged`.

**Fix:** Clarify the intent. If NTP should be aborted only when network goes down, change the condition to `if (!newState)`. If NTP should be restarted on every interface change (the behaviour below), the abort is correct but the comment and condition should be simplified to remove the confusing dead sub-clause.

---

## 3. Summary Table

| ID | Severity | Title |
|----|----------|-------|
| A03-1 | HIGH | `streamUncompress` uses shared `static` variable for cross-call state |
| A03-2 | HIGH | Dead debug function `dataTest()` compiled into production binary |
| A03-3 | HIGH | Unreachable `break` after `return true` in `dispatchLeaderCmd` |
| A03-4 | MEDIUM | Qt deprecated API: `QNetworkConfigurationManager` and `QRegExp` |
| A03-5 | MEDIUM | Large commented-out code blocks throughout both files |
| A03-6 | MEDIUM | `m_isShuffled` declared but never written or read |
| A03-7 | MEDIUM | `Checklist` constructor leaves `m_isShuffled` and array members uninitialised |
| A03-8 | MEDIUM | `shuffleChecklist()` rotate end-iterator is off by one |
| A03-9 | MEDIUM | `convert2UTC` is a stub with dead code and a misleading `else` branch |
| A03-10 | MEDIUM | Unreachable `QueryCmd` response branches in `CMD_RLY1` and `CMD_RLY2` |
| A03-11 | LOW | Mixed type conventions: `uint8_t` used alongside `quint8` in checklist.cpp |
| A03-12 | LOW | `query == true` comparison style inconsistency in `checkItem()` |
| A03-13 | LOW | `convert2UTC` takes `QString` by value instead of const reference |
| A03-14 | LOW | Indentation inconsistency (mixed tabs/spaces) in backgroundworker.cpp |
| A03-15 | LOW | `OtaWorker::m_isRunning` is a `public` data member with `m_` prefix |
| A03-16 | LOW | `handleNtpSynchronization` condition always aborts NTP; `!newState` sub-clause is dead |
# Pass 4 Agent A04 — Code Quality

**Audit run:** 2026-02-28-01
**Branch:** master
**Files reviewed:**
- `app/cigconfigs.h`
- `app/crctable.cpp`
- `app/driverlist.h`
- `app/driverlist.cpp`

---

## Reading Evidence

### `app/cigconfigs.h`

**Module:** Global configuration header — no class, namespace `CIGCONF` wraps enums and structs.

**Functions/methods defined:** None (header-only, no functions).

**Macros defined (global scope, lines 8–77):**

| Macro | Line |
|---|---|
| `LFF_VERSION` | 8 |
| `SFF_VERSION` | 9 |
| `UFF_VERSION` | 10 |
| `ENG_VERSION` | 11 |
| `F_BUILD` | 12 |
| `C_BUILD` | 13 |
| `BROADCASTMSG_TEXT_LEN` | 15 |
| `GMTP_ID_LEN` | 17 |
| `GMTP_SERVER_CNT` | 18 |
| `SERVER_ADDR_LEN` | 19 |
| `MODEM_DIAL_NUMBER_LEN` | 20 |
| `MODEM_APN_LEN` | 21 |
| `MODEM_APN_USER_LEN` | 22 |
| `MODEM_ICCID_LEN` | 23 |
| `MODEM_APN_PASSWORD_LEN` | 24 |
| `MAX_POLY_POINTS` | 26 |
| `MAX_POLY` | 27 |
| `CHECKLIST_TIME_SLOTS` | 29 |
| `CHECKLIST_MAX_IDX` | 30 |
| `CHECKLIST_QUESTION_LEN` | 31 |
| `CHECKLIST_ITEM_SIZE` | 32 |
| `CHECKLIST_QUESTION_LEN_100` | 33 |
| `CHECKLIST_ITEM_SIZE_100` | 34 |
| `DRIVER_MAX_ID_IDX` | 36 |
| `MASTER_MAX_ID_IDX` | 37 |
| `SUPER_MAX_ID_IDX` | 38 |
| `TECH_MAX_ID_IDX` | 39 |
| `CAN_MAX_HW_PGN` | 42 |
| `CAN_MAX_PGN_IDX` | 43 |
| `CAN_MAX_SPN_IDX` | 44 |
| `CAN_MAX_LINK_IDX` | 45 |
| `CAN_MAX_ATT_IDX` | 46 |
| `CAN_ATT_NAME_LEN` | 47 |
| `CAN_MSG_TYPE` | 48 |
| `CAN_MSG_DLC` | 49 |
| `CAN_SIG_STATUS` | 50 |
| `ON_DEMAND_DURATION` | 53 |
| `WIFI_MAX_NETWORKS` | 56 |
| `WIFI_CONF_FILE` | 57 |
| `FILE_DRIVER_IDS` | 64 |
| `FILE_MASTER_IDS` | 65 |
| `FILE_SUPER_IDS` | 66 |
| `FILE_TECH_IDS` | 67 |
| `FILE_CHECKLIST` | 68 |
| `FILE_CHECKLIST_100` | 69 |
| `FILE_FLEETMS_FW` | 70 |
| `FILE_FLEETMS_FW_RD` | 71 |
| `FILE_LOGIN_SCREEN` | 72 |
| `FILE_LOGIN_SCREEN_RD` | 73 |
| `FILE_ONCEPERDAY_PREOP_IDS` | 74 |
| `DIR_GMTP_MSG` | 76 |
| `SHOW_ALL_MASTER_MENU` (inside namespace block) | 81 |

**Enums (all inside `namespace CIGCONF`):**

| Enum | Line |
|---|---|
| `MasterMenuOptions` | 83 |
| `PowerState` | 86 |
| `ConfigErrorCode` | 88 |
| `FtpErrorCode` | 90 |
| `LeaderCmdType` | 93 |
| `UnlockReasonScreen` | 95 |
| `RealImpact` | 97 |
| `DigitalInputMode` | 99 |
| `LeaderCmd` | 101 |
| `GmtpMessage` | 128 |
| `CheckReason` | 135 |
| `CheckResponses` | 136 |
| `ChecklistType` | 137 |
| `OnDemandCmdType` | 139 |
| `OnDemandCmdSrc` | 140 |
| `MaintLockedCode` | 142 |
| `ShowTimeFormat` | 150 |
| `BleExpansionDI` | 156 |
| `BleExpansionRelay` | 157 |
| `BleExpansionConnectionStatus` | 158 |
| `CanProtocol` | 160 |
| `CanAttributeType` | 162 |
| `WifiPosSource` | 171 |
| `CameraMode` | 173 |

**Structs (all inside `namespace CIGCONF`):**

| Struct | Line |
|---|---|
| `CanMsgLink` | 175 |
| `CanMsgPara` | 180 |
| `CanSigPara` | 188 |
| `CigCanConfig` | 195 |
| `BroadcastMessage` | 245 |
| `WifiNetwork` | 254 |
| `PreopDriverId` | 260 |
| `DriverId` | 265 |
| `MasterId` | 270 |
| `gpsPosStruct` | 276 |
| `polygonStruct` | 281 |
| `position` | 287 |
| `AccessPoint` | 295 |
| `CheckResponse` | 304 |

---

### `app/crctable.cpp`

**Module:** CRC lookup tables — no class, no header.

**Functions defined:** None.

**Constants defined:**

| Symbol | Type | Line |
|---|---|---|
| `crc32Table` | `const quint32[256]` | 6 |
| `crc16Table` | `const quint16[16]` | 41 |

**Forward declarations (lines 3–4):** Both arrays are forward-declared as `extern` before their definitions in the same translation unit.

---

### `app/driverlist.h`

**Class:** `DriverList` (line 9)

**Public methods declared:**

| Method | Line |
|---|---|
| `DriverList()` (constructor) | 12 |
| `readDriverIds()` | 14 |
| `readMasterIds()` | 15 |
| `readSuperIds()` | 16 |
| `readTechIds()` | 17 |
| `saveDriverIds()` | 18 |
| `saveMasterIds()` | 19 |
| `saveSuperIds()` | 20 |
| `saveTechIds()` | 21 |
| `readPreopDriverIds()` | 22 |
| `savePreopDriverIds()` | 23 |
| `driverIds() const` | 25 |
| `masterIds() const` | 26 |
| `superIds() const` | 27 |
| `techIds() const` | 28 |
| `preopDriverIds() const` | 29 |
| `driverId(int) const` | 31 |
| `masterId(int) const` | 32 |
| `masterIdById(quint64) const` | 33 |
| `superId(int) const` | 34 |
| `techId(int) const` | 35 |
| `setDriverId(int, quint64, QString)` | 37 |
| `setMasterId(int, quint64, quint8, QString)` | 38 |
| `setSuperId(int, quint64)` | 39 |
| `setTechId(int, quint64, QString)` | 40 |
| `containsDriverId(quint64) const` | 42 |
| `containsMasterId(quint64, quint8) const` | 50 |
| `containsSuperId(quint64) const` | 63 |
| `containsTechId(quint64) const` | 69 |
| `addDriverId(quint64, QString)` | 77 |
| `addSuperId(quint64)` | 78 |
| `addTechId(quint64, QString)` | 79 |
| `addPreopDriverId(quint64, quint32)` | 80 |
| `removeDriverId(quint64)` | 82 |
| `removeMasterId(quint64)` | 83 |
| `removeSuperId(quint64)` | 84 |
| `removeTechId(quint64)` | 85 |
| `clearDriverIds()` | 87 |
| `clearMasterIds()` | 88 |
| `clearSuperIds()` | 89 |
| `clearTechIds()` | 90 |
| `clearPreopDriverIds()` | 91 |
| `driverChecksum() const` | 93 |
| `masterChecksum() const` | 94 |
| `superChecksum() const` | 95 |
| `techChecksum() const` | 96 |
| `superIsEmpty()` | 98 |
| `getMasterIdIndex(quint64)` | 100 |
| `getDriverIdIndex(quint64)` | 101 |
| `getTechIdIndex(quint64)` | 102 |
| `getPreopDriverIdIndex(quint64)` | 103 |
| `getPreopDriverId(quint64)` | 104 |

**Private member variables:**

| Member | Line |
|---|---|
| `m_driverIds` (`QList<DriverId>`) | 108 |
| `m_masterIds` (`QList<MasterId>`) | 109 |
| `m_superIds` (`QList<quint64>`) | 110 |
| `m_techIds` (`QList<DriverId>`) | 111 |
| `m_preopDriverIds` (`QList<PreopDriverId>`) | 112 |
| `m_driverIdsDirty` (`bool`) | 113 |
| `m_masterIdsDirty` (`bool`) | 114 |
| `m_superIdsDirty` (`bool`) | 115 |
| `m_techIdsDirty` (`bool`) | 116 |
| `m_preopDriverDirty` (`bool`) | 117 |

---

### `app/driverlist.cpp`

**Functions/methods defined:**

| Method | Line |
|---|---|
| `DriverList::DriverList()` | 8 |
| `DriverList::readDriverIds()` | 16 |
| `DriverList::saveDriverIds()` | 45 |
| `DriverList::readMasterIds()` | 66 |
| `DriverList::saveMasterIds()` | 97 |
| `DriverList::readSuperIds()` | 120 |
| `DriverList::saveSuperIds()` | 136 |
| `DriverList::readTechIds()` | 155 |
| `DriverList::saveTechIds()` | 184 |
| `DriverList::readPreopDriverIds()` | 205 |
| `DriverList::savePreopDriverIds()` | 233 |
| `DriverList::setDriverId(int, quint64, QString)` | 267 |
| `DriverList::setMasterId(int, quint64, quint8, QString)` | 285 |
| `DriverList::setSuperId(int, quint64)` | 304 |
| `DriverList::setTechId(int, quint64, QString)` | 317 |
| `DriverList::getDriverIdIndex(quint64)` | 335 |
| `DriverList::addDriverId(quint64, QString)` | 344 |
| `DriverList::getMasterIdIndex(quint64)` | 370 |
| `DriverList::addSuperId(quint64)` | 379 |
| `DriverList::getTechIdIndex(quint64)` | 395 |
| `DriverList::addTechId(quint64, QString)` | 404 |
| `DriverList::getPreopDriverIdIndex(quint64)` | 430 |
| `DriverList::getPreopDriverId(quint64)` | 445 |
| `DriverList::addPreopDriverId(quint64, quint32)` | 455 |
| `DriverList::removeDriverId(quint64)` | 489 |
| `DriverList::removeMasterId(quint64)` | 511 |
| `DriverList::removeSuperId(quint64)` | 529 |
| `DriverList::removeTechId(quint64)` | 543 |
| `DriverList::clearDriverIds()` | 560 |
| `DriverList::clearMasterIds()` | 566 |
| `DriverList::clearSuperIds()` | 572 |
| `DriverList::clearTechIds()` | 578 |
| `DriverList::clearPreopDriverIds()` | 584 |
| `DriverList::driverChecksum() const` | 590 |
| `DriverList::masterChecksum() const` | 601 |
| `DriverList::superChecksum() const` | 613 |
| `DriverList::techChecksum() const` | 624 |
| `DriverList::superIsEmpty()` | 635 |
| `DriverList::masterIdById(quint64) const` | 645 |

---

## Findings

---

**A04-1** · HIGH · `crctable.cpp` has no corresponding header file

**Description:** `crctable.cpp` declares and defines `crc32Table` and `crc16Table` but there is no `crctable.h`. Both consumers (`globalconfigs.cpp` and `backgroundworker.cpp`) repeat `extern const quint32 crc32Table[]` and `extern const quint16 crc16Table[]` declarations inline inside their function bodies. This is a leaky abstraction: the declaration contract is implicit and scattered, making it trivially easy for a future caller to declare the wrong type, wrong element count, or wrong linkage. If the table type ever changes, no compiler error will be produced at the declaration sites.

**Fix:** Create `app/crctable.h` that declares both arrays with `extern const`, include it in `crctable.cpp`, `globalconfigs.cpp`, and `backgroundworker.cpp`, and remove the in-function `extern` declarations.

---

**A04-2** · HIGH · `#define SHOW_ALL_MASTER_MENU 255` placed inside a namespace block

**Description:** At line 81 of `cigconfigs.h`, a `#define` is written between the `namespace CIGCONF {` opening brace and the first `enum`. C preprocessor macros are not scoped by namespaces; the macro is effectively global and the namespace placement gives a false impression that it is namespaced. The value 255 duplicates `UnassignedMasterMenu = 255` from the `MasterMenuOptions` enum defined two lines later, creating two symbols with the same semantic meaning. Searches in the codebase find `SHOW_ALL_MASTER_MENU` used only inside `cigconfigs.h` itself (it is not referenced in any other `.cpp` or `.h` outside this file), confirming it is dead.

**Fix:** Remove the macro. If the value is genuinely needed, add a `ShowAllMasterMenu = 255` enumerator to `MasterMenuOptions` and use that enumerator.

---

**A04-3** · HIGH · `LeaderCmd` enum ordering broken — `CMD_UNKNOWN = 0xff` is not the last enumerator

**Description:** In `cigconfigs.h` lines 101–126, `CMD_UNKNOWN = 0xff` is assigned at line 120, but at least 25 additional enumerators (`CMD_TGFNCE`, `CMD_SCRSAV`, ..., `CMD_CAMERAFLIP`) are appended after it on lines 121–125. Because `CMD_UNKNOWN` uses an explicit value `0xff` (255) and the subsequent enumerators continue numerically from 256 onward, the enumerators after `CMD_UNKNOWN` silently overflow an `int` in the range 256–280. More critically, any `switch` or comparison that uses `CMD_UNKNOWN` as a sentinel "unknown command" value is broken: legitimate commands added after `CMD_UNKNOWN` will never match the sentinel and will be misrouted as unknown. This is a protocol/logic defect introduced by appending new commands without repositioning `CMD_UNKNOWN`.

**Fix:** Move `CMD_UNKNOWN = 0xff` to the end of the enum (or use it only as a runtime initializer, not as an enum member). Assign the newly added commands before `CMD_UNKNOWN` in the sequential value range, or use a separate constant for the sentinel so that the numeric gap cannot arise.

---

**A04-4** · MEDIUM · `CanAttributeType` contains two `Last`-style sentinel enumerators

**Description:** `cigconfigs.h` lines 162–169 define `CanAttributeType` with both `CanAttributeLast` (value 1) and `CanAttributeLast2` (value 5). Having two sentinels with names implying "the last value" is contradictory and confusing. A search confirms `CanAttributeLast2` appears only in `cigconfigs.h` and in CAN handler files, but the naming conveys no clear semantic difference. This is a dead-code / naming smell that indicates a past extension was done without cleaning up the original sentinel.

**Fix:** Rename or remove the older sentinel. If both are genuinely needed as range boundaries for separate sub-ranges, rename them with explicit meaning (e.g., `CanAttributeBasicLast`, `CanAttributeExtendedLast`).

---

**A04-5** · MEDIUM · `CigCanConfig` contains a large anonymous union with many `unused` members that hold real layout

**Description:** `cigconfigs.h` lines 207–243 define an anonymous union inside `CigCanConfig`. The first union member is an array of structs with fields all named `unused3` through `unused10`. This structure is clearly load-bearing for the binary layout of the config block — its presence controls the size and alignment of the union — but the naming actively conceals this. Any engineer reading the code may assume the fields can be freely removed or reordered, leading to silent config corruption. The `void *unused2` pointer at line 192 inside `CanSigPara` carries a comment "set to nullptr", making it a permanent padding placeholder with no type safety.

**Fix:** Replace `unusedN` field names with descriptive names prefixed `_reserved` (e.g., `_reserved_attLegacy`) and add a `static_assert` on the size of `CigCanConfig` to catch accidental layout changes. Replace `void *unused2` with an explicit `quint64 _reserved` or a suitably-typed field.

---

**A04-6** · MEDIUM · Hardcoded Linux filesystem paths in a Qt-targeting header

**Description:** `cigconfigs.h` lines 57 and 64–76 contain hardcoded absolute POSIX paths such as `/etc/wpa_supplicant.conf`, `/home/dlist.txt`, `/mnt/sd/FleetIQ360App`, and `/mnt/ramdisk/login.png`. These paths encode the exact production filesystem layout of the embedded Linux target directly into a shared header. Any build for a development host, unit-test harness, or future hardware revision will silently use wrong paths unless all callers add their own overrides. The paths are also split across two logical groups (modem/network paths and file paths) with no clear separation.

**Fix:** Move filesystem path configuration to a runtime-configurable source (e.g., a config singleton, a compile-time platform layer, or at minimum a separate `platform_paths.h` that is not included in unit-test builds). If the paths must remain as macros, isolate them in a dedicated platform header that is excluded from host-side test compilations via a feature flag.

---

**A04-7** · MEDIUM · `getPreopDriverIdIndex` contains a spurious function-declaration statement

**Description:** `driverlist.cpp` line 433 reads:
```cpp
CIGCONF::PreopDriverId getPreopDriverId(quint64 id);
```
This is a local function declaration placed inside the body of `DriverList::getPreopDriverIdIndex`. It does not call the function and has no effect; the compiler treats it as a forward declaration of a free function and immediately discards it. The statement appears to be copy-paste debris from an earlier draft. It compiles without error only because function declarations are syntactically valid as statements in C++, but it is entirely dead code and obscures the intent of the surrounding loop.

**Fix:** Remove line 433 from `getPreopDriverIdIndex`.

---

**A04-8** · MEDIUM · Commented-out debug block in `addPreopDriverId`

**Description:** `driverlist.cpp` lines 473–483 contain a `#if 0` block that includes a `qDebug()` debug dump using `ByteArray::asprintf`. This dead block was clearly debug scaffolding. The reference to `ByteArray::asprintf` (a non-standard helper) also means the block cannot compile as-is if the `#if 0` were ever removed, making it unmaintainable dead code.

**Fix:** Remove the `#if 0` block entirely. If the debug output is needed, use a proper `qCDebug` category guarded by a logging level rather than a preprocessor block.

---

**A04-9** · MEDIUM · `savePreopDriverIds` uses `QFile` instead of `QSaveFile`, unlike all other save methods

**Description:** All other `save*Ids` methods in `driverlist.cpp` (lines 45–203) use `QSaveFile`, which provides atomic write-then-rename semantics, protecting against file corruption on power loss. `savePreopDriverIds` (line 233) uses a plain `QFile`, meaning a power interruption during the write leaves a truncated or partial file. This is inconsistent with the established pattern in the same class and represents a reliability regression specifically for the once-per-day preop ID list, which is the newest feature.

**Fix:** Replace `QFile` with `QSaveFile` in `savePreopDriverIds` and call `file.commit()` as done in the other save methods.

---

**A04-10** · MEDIUM · `savePreopDriverIds` uses deprecated `endl` manipulator

**Description:** `driverlist.cpp` line 260 uses `endl` with `QTextStream`. In Qt 5.14+, `Qt::endl` is the preferred form and the bare `endl` form (which resolves to `std::endl`) causes an implicit flush on every line, degrading write performance and mixing std and Qt stream semantics. All other save methods write raw `QByteArray` without `QTextStream`, making this the only method using the Qt text stream API and `endl`.

**Fix:** Replace `endl` with `Qt::endl`, or better, rewrite `savePreopDriverIds` to use `QByteArray` accumulation consistent with the other save methods, eliminating the `QTextStream` dependency entirely.

---

**A04-11** · MEDIUM · `m_preopDriverDirty` not initialised in constructor

**Description:** `DriverList::DriverList()` (`driverlist.cpp` line 8) initialises `m_driverIdsDirty`, `m_masterIdsDirty`, `m_superIdsDirty`, and `m_techIdsDirty` to `false` in the member-initialiser list. `m_preopDriverDirty` (declared at `driverlist.h` line 117) is omitted from the initialiser list. Its value at construction time is indeterminate (undefined behaviour in C++). If `savePreopDriverIds` is called before any mutation, the dirty-flag check at line 236 may evaluate to `true` on an uninitialised bool, causing a spurious write.

**Fix:** Add `m_preopDriverDirty(false)` to the constructor initialiser list.

---

**A04-12** · LOW · `driverlist.h` unnecessarily includes `<QDebug>`

**Description:** `driverlist.h` line 7 includes `<QDebug>`. No method in the header uses `qDebug()` or any debug type. The include is unused in the header and is pulled in transitively by every translation unit that includes `driverlist.h`. `<QDebug>` is a heavyweight Qt header.

**Fix:** Remove `#include <QDebug>` from `driverlist.h`. If debug output is needed in `driverlist.cpp`, include `<QDebug>` there instead.

---

**A04-13** · LOW · `containsDriverId` / `containsMasterId` / `containsSuperId` / `containsTechId` use a ternary that is always true when the loop body is reached

**Description:** Each `contains*` method (e.g., `driverlist.h` line 45) ends with `return id != 1 ? true : false;` after finding a matching entry. The expression `id != 1 ? true : false` is exactly `id != 1`. More importantly, the logic appears designed to exclude the sentinel ID value `1`, yet returning `false` when a matching entry exists with `id == 1` is surprising and undocumented. There is no comment explaining why `id == 1` is special. The ternary form also triggers `-Wlogical-op` or style warnings on some compilers.

**Fix:** Replace the ternary with `return (id != 1);` and add a comment explaining the special-case meaning of ID value 1 (e.g., "id 1 is reserved as a null/unset sentinel"). If id 1 is never expected in the lists, add an assertion.

---

**A04-14** · LOW · `driverChecksum` / `masterChecksum` / `superChecksum` / `techChecksum` use C-style casts

**Description:** `driverlist.cpp` lines 594–595, 604–607, 617–618, 627–628 use `(quint32)d.id` and `(quint32)(d.id >> 32)` C-style casts to truncate `quint64` values. These are semantically `static_cast<quint32>(...)` but the C-style cast form suppresses compiler warnings and bypasses the type-system checks that `static_cast` preserves.

**Fix:** Replace all `(quint32)` C-style casts in the checksum methods with `static_cast<quint32>(...)`.

---

**A04-15** · LOW · `crctable.cpp` forward-declares its own definitions

**Description:** `crctable.cpp` lines 3–4 contain:
```cpp
extern const quint32 crc32Table[];
extern const quint16 crc16Table[];
```
immediately before defining those same arrays. This self-referential forward declaration adds no value (the definitions are visible at link time regardless) and appears to be a workaround for the absence of a proper header. If the array sizes or types ever diverge between declaration and definition, the compiler may not catch the mismatch.

**Fix:** Remove the forward declarations from `crctable.cpp` once a proper `crctable.h` header is created (see A04-1). The definitions alone are sufficient within the translation unit.

---

**A04-16** · LOW · `OnDemandCmdType` enum has redundant explicit zero value

**Description:** `cigconfigs.h` line 139:
```cpp
enum OnDemandCmdType {OnDemandStart, OnDemandExtend = 1, OnDemandEnd = 2};
```
`OnDemandStart` is implicitly 0, so no explicit value is needed. `OnDemandExtend = 1` is also redundant since it is the sequential value. Only `OnDemandEnd = 2` would be needed if the intent was to emphasise the values. The inconsistency across the three enumerators (implicit, explicit-same, explicit-same) is a style defect.

**Fix:** Either remove all explicit values (`{OnDemandStart, OnDemandExtend, OnDemandEnd}`) if the values are not protocol-significant, or add explicit values to all three enumerators for clarity.

---

**A04-17** · INFO · `DriverId` struct is reused for tech IDs instead of having a dedicated type

**Description:** `cigconfigs.h` line 265 defines `DriverId` and it is used for both driver and tech ID lists (`m_driverIds`, `m_techIds`). This means the type name in stack traces, debug output, and future refactoring provides no distinction between driver entries and tech entries. It is a minor semantic clarity issue.

**Fix:** Consider a `using TechId = DriverId;` alias or a dedicated `TechId` struct to improve readability and enable future divergence of the two types.

---

## Summary Table

| ID | Severity | Title | File(s) |
|---|---|---|---|
| A04-1 | HIGH | `crctable.cpp` has no header file | `crctable.cpp` |
| A04-2 | HIGH | `#define SHOW_ALL_MASTER_MENU` inside namespace / dead code | `cigconfigs.h:81` |
| A04-3 | HIGH | `CMD_UNKNOWN = 0xff` breaks `LeaderCmd` enum ordering | `cigconfigs.h:120` |
| A04-4 | MEDIUM | `CanAttributeType` has two confusingly-named sentinel enumerators | `cigconfigs.h:164,169` |
| A04-5 | MEDIUM | `CigCanConfig` has layout-critical fields named `unusedN` | `cigconfigs.h:205-242` |
| A04-6 | MEDIUM | Hardcoded Linux filesystem paths in shared header | `cigconfigs.h:57,64-76` |
| A04-7 | MEDIUM | Spurious function-declaration statement inside `getPreopDriverIdIndex` | `driverlist.cpp:433` |
| A04-8 | MEDIUM | Commented-out `#if 0` debug block in `addPreopDriverId` | `driverlist.cpp:473-483` |
| A04-9 | MEDIUM | `savePreopDriverIds` uses `QFile` instead of `QSaveFile` | `driverlist.cpp:244` |
| A04-10 | MEDIUM | `savePreopDriverIds` uses deprecated `endl` | `driverlist.cpp:260` |
| A04-11 | MEDIUM | `m_preopDriverDirty` not initialised in constructor | `driverlist.cpp:8` |
| A04-12 | LOW | `<QDebug>` unnecessarily included in `driverlist.h` | `driverlist.h:7` |
| A04-13 | LOW | `contains*` methods use verbose ternary with undocumented special case for `id == 1` | `driverlist.h:42-75` |
| A04-14 | LOW | C-style casts in checksum methods | `driverlist.cpp:594-628` |
| A04-15 | LOW | `crctable.cpp` self-forward-declares its own definitions | `crctable.cpp:3-4` |
| A04-16 | LOW | `OnDemandCmdType` has inconsistent explicit values | `cigconfigs.h:139` |
| A04-17 | INFO | `DriverId` struct reused for tech IDs without type alias | `cigconfigs.h:265` |
# Pass 4 Agent A05 — Code Quality

**Audit run:** 2026-02-28-01
**Branch:** master
**Assigned files:**
- `app/globalconfigs.h`
- `app/globalconfigs.cpp`
- `app/globalconfigsfilemanager.h` / `.cpp` — **FILE NOT FOUND** (confirmed absent, see Finding A05-1)

---

## 1. Reading Evidence

### 1.1 `app/globalconfigs.h`

**Class:** `GlobalConfigs` (inherits `QObject`, decorated with `Q_OBJECT`)

**Macro defined in this file:**
| Macro | Line | Value |
|---|---|---|
| `gCfg` | 13 | `GlobalConfigs::instance()` |

**Public methods / inline accessors (all defined in the header):**

| Method | Line |
|---|---|
| `explicit GlobalConfigs(QObject *parent = nullptr)` | 20 |
| `static GlobalConfigs *instance()` | 21 |
| `static quint32 crc32(const void *buf, int len)` | 22 |
| `void readConfigs()` | 24 |
| `void saveConfigs()` | 25 |
| `void saveOpdDriverList()` | 26 |
| `void resetConfigs(bool resetAll = false)` | 27 |
| `quint32 keepAliveTime() const` | 30 |
| `bool setKeepAliveTime(quint32 time)` | 31 |
| `quint32 shutdownTime() const` | 40 |
| `bool setShutdownTime(quint32 time)` | 41 |
| `QByteArray gmtpId() const` | 50 |
| `bool setGmtpId(const QByteArray &id)` | 51 |
| `CIGCONF::MaintLockedCode maintCode() const` | 60 |
| `quint64 maintDriverId() const` | 61 |
| `quint32 maintTimestamp() const` | 62 |
| `bool setMaintCode(CIGCONF::MaintLockedCode code)` | 64 |
| `quint64 unlockId() const` | 81 |
| `bool setUnlockId(quint64 id)` | 82 |
| `QByteArray dialNumber() const` | 87 |
| `bool setDialNumber(const QByteArray &number)` | 88 |
| `QByteArray apn() const` | 97 |
| `bool setApn(const QByteArray &apn)` | 98 |
| `QByteArray apnUser() const` | 107 |
| `bool setApnUser(const QByteArray &user)` | 108 |
| `QByteArray apnPassword() const` | 117 |
| `bool setApnPassword(const QByteArray &password)` | 118 |
| `QByteArray gmtpServerAddress(int index) const` | 127 |
| `bool setGmtpServerAddress(int index, const QByteArray &addr)` | 128 |
| `quint16 gmtpServerPort(int index) const` | 137 |
| `bool setGmtpServerPort(int index, quint16 port)` | 138 |
| `quint64 expansionModMac() const` | 147 |
| `bool setExpansionModMac(quint64 mac)` | 148 |
| `void resetSimCardID()` | 157 |
| `QByteArray getSimCardID() const` | 158 |
| `bool setSimCardID(const QByteArray &iccid)` | 159 |
| `QList<CIGCONF::DriverId> driverIds() const` | 168 |
| `QList<CIGCONF::MasterId> masterIds() const` | 169 |
| `QList<quint64> superIds() const` | 170 |
| `QList<CIGCONF::DriverId> techIds() const` | 171 |
| `QList<CIGCONF::PreopDriverId> preopDriverIds() const` | 172 |
| `CIGCONF::DriverId driverId(int index) const` | 174 |
| `CIGCONF::MasterId masterId(int index) const` | 175 |
| `CIGCONF::MasterId masterIdById(quint64 id) const` | 176 |
| `quint64 superId(int index) const` | 177 |
| `CIGCONF::DriverId techId(int index) const` | 178 |
| `bool setDriverId(int index, quint64 id, QString name)` | 180 |
| `bool setMasterId(int index, quint64 id, quint8 option, QString name)` | 181 |
| `bool setSuperId(int index, quint64 id)` | 182 |
| `bool setTechId(int index, quint64 id, QString name)` | 183 |
| `bool containsDriverId(quint64 id) const` | 185 |
| `bool containsMasterId(quint64 id, quint8 permissions=0) const` | 186 |
| `bool containsSuperId(quint64 id) const` | 187 |
| `bool containsTechId(quint64 id) const` | 188 |
| `bool addDriverId(quint64 id, QString name)` | 190 |
| `bool addSuperId(quint64 id)` | 191 |
| `bool addTechId(quint64 id, QString name)` | 192 |
| `bool addPreopDriverId(quint64 id, quint32 timestamp)` | 193 |
| `bool removeDriverId(quint64 id)` | 195 |
| `bool removeMasterId(quint64 id)` | 196 |
| `bool removeSuperId(quint64 id)` | 197 |
| `bool removeTechId(quint64 id)` | 198 |
| `void clearDriverIds()` | 200 |
| `void clearMasterIds()` | 201 |
| `void clearSuperIds()` | 202 |
| `void clearTechIds()` | 203 |
| `void clearPreopDriverIds()` | 204 |
| `int getMasterIdIndex(quint64 id)` | 206 |
| `int getDriverIdIndex(quint64 id)` | 207 |
| `int getTechIdIndex(quint64 id)` | 208 |
| `int getPreopDriverIdIndex(quint64 id)` | 209 |
| `CIGCONF::PreopDriverId getPreopDriverId(quint64 id)` | 210 |
| `bool preopOncePerDayEn() const` | 212 |
| `bool setPreopOncePerDayEn(bool en)` | 213 |
| `QString getDriverName(quint64 id)` | 220 |
| `bool superIsEmpty()` | 233 |
| `quint8 digitalInputMode1() const` | 235 |
| `quint8 digitalInputMode2() const` | 236 |
| `quint8 digitalInputMode3() const` | 237 |
| `quint8 digitalInputMode4() const` | 238 |
| `void setDigInputMode(quint8, quint8, quint8, quint8)` | 240 |
| `quint32 seenDebounceTime() const` | 248 |
| `quint32 seenHoldTime() const` | 249 |
| `bool setSeenParam(quint32 debounce, quint32 hTime)` | 250 |
| `quint8 convorStatus() const` | 257 |
| `quint64 convorId() const` | 258 |
| `bool setConvor(quint8 convor, quint64 id)` | 259 |
| `quint8 fullLockoutEnable() const` | 270 |
| `bool setFullLockoutEnable(quint8 lockOutEnable)` | 271 |
| `quint32 fullLockoutTimeout() const` | 277 |
| `bool setFullLockoutTimeout(quint32 lockOutTimeout)` | 278 |
| `quint8 unlkScr() const` | 284 |
| `bool setUnlkScr(quint8 scr)` | 285 |
| `quint8 scrSavMode() const` | 294 |
| `bool setScrSavMode(quint8 mode)` | 295 |
| `quint16 checkTimeSlot(int index) const` | 304 |
| `bool setCheckTimeSlot(int index, quint16 hm)` | 305 |
| `quint16 checklistTimeout() const` | 314 |
| `bool setChecklistTimeout(quint16 time)` | 315 |
| `quint64 lastTimeServerUpdate() const` | 324 |
| `bool setLastTimeServerUpdate(quint64 ts)` | 325 |
| `qint64 timeError() const` | 330 |
| `bool setTimeError(qint64 ts)` | 331 |
| `quint32 lastPreopOncePerDayTimestamp() const` | 336 |
| `bool setlastPreopOncePerDayTimestamp(quint32 ts)` | 337 |
| `quint32 lastCheckTimestamp() const` | 344 |
| `bool setLastCheckTimestamp(quint32 ts)` | 345 |
| `quint64 lastCheckDriverId() const` | 352 |
| `bool setLastCheck(quint64 id, quint32 ts)` | 353 |
| `void clearChecklist()` | 361 |
| `Checklist::CheckItem checkItem(int index, bool query = false)` | 362 |
| `bool setCheckItem(int index, const Checklist::CheckItem item)` | 363 |
| `int nextValidCheckItemIndex(int start = 0, bool queryOrigList = false)` | 367 |
| `void shuffleChecklist()` | 374 |
| `quint8 preopRandom() const` | 375 |
| `bool setPreopRandom(quint8 isRandom)` | 376 |
| `quint32 shockThreshold() const` | 382 |
| `bool setShockThreshold(quint32 data)` | 383 |
| `quint32 shockRedImpact() const` | 389 |
| `bool setShockRedImpact(quint32 data)` | 390 |
| `quint32 shockPeriod() const` | 396 |
| `bool setShockPeriod(quint32 data)` | 397 |
| `quint32 shockTimer() const` | 403 |
| `bool setShockTimer(quint32 data)` | 404 |
| `qint16 timeZoneInMinutes() const` | 410 |
| `bool setTimeZoneInMinutes(qint16 zone)` | 411 |
| `QByteArray timeServerAddress() const` | 419 |
| `bool setTimeServerAddress(const QByteArray &addr)` | 420 |
| `quint32 gpsUpdateTime() const` | 429 |
| `bool setGpsUpdateTime(quint32 time)` | 430 |
| `qint16 gpsDistanceMark() const` | 439 |
| `bool setGpsDistanceMark(qint16 mark)` | 440 |
| `quint16 satNum() const` | 449 |
| `bool setSatNum(quint16 n)` | 450 |
| `quint16 idleTimeout() const` | 459 |
| `bool setIdleTimeout(quint16 time)` | 460 |
| `quint16 getGmtpWaitTimeout() const` | 466 |
| `bool setGmtpWaitTimeout(quint16 time)` | 467 |
| `bool idleInputPolarity() const` | 473 |
| `bool setIdleInputPolarity(bool high)` | 474 |
| `quint8 idleInputSource() const` | 480 |
| `bool setIdleInputSource(quint8 src)` | 481 |
| `CIGCONF::polygonStruct polygon(int n) const` | 490 |
| `quint8 polygonNPoints(int n) const` | 492 |
| `bool setPolygonNPoints(int n, quint8 vect)` | 493 |
| `quint32 polygonLatitude(int n, int vect) const` | 502 |
| `bool setPolygonLatitude(int n, int vect, quint32 lat)` | 503 |
| `quint32 polygonLongitude(int n, int vect) const` | 512 |
| `bool setPolygonLongitude(int n, int vect, quint32 lon)` | 513 |
| `quint32 configVersion() const` | 524 |
| `quint8 backlight() const` | 526 |
| `quint32 checksum() const` | 527 |
| `CIGCONF::ConfigErrorCode configErrorCode() const` | 529 |
| `void readPreopDriverIds()` | 531 |
| `void readDriverIds()` | 532 |
| `void readMasterIds()` | 533 |
| `void readSuperIds()` | 534 |
| `void readTechIds()` | 535 |
| `void readChecklist()` | 536 |
| `quint32 driverChecksum() const` | 537 |
| `quint32 masterChecksum() const` | 538 |
| `quint32 superChecksum() const` | 539 |
| `quint32 questionChecksum() const` | 540 |
| `quint32 timestamp() const` | 542 |
| `quint32 localTimestamp() const` | 543 |
| `QDateTime localTime() const` | 545 |
| `quint64 clockTime() const` | 547 |
| `QString preopCommentString() const` | 557 |
| `void setPreopCommentString(QString msg)` | 558 |
| `QString UnlkReasonString() const` | 560 |
| `void setUnlkReasonString(QString msg)` | 561 |
| `CIGCONF::RealImpact UnlkOption() const` | 563 |
| `void setUnlkOption(CIGCONF::RealImpact option)` | 564 |
| `quint64 currentDriverId() const` | 566 |
| `void setCurrentDriverId(quint64 id)` | 567 |
| `quint64 fwVersion()` | 569 |
| `QString fwVersionString()` | 570 |
| `quint32 onDemandStartTime() const` | 573 |
| `quint32 onDemandEndTime() const` | 574 |
| `quint64 onDemandSmId() const` | 575 |
| `void setOnDemand(quint32 start, quint32 end, quint64 id)` | 577 |
| `void clearOnDemand()` | 583 |
| `bool onDemandActive()` | 585 |
| `bool onDemandVehicleEnabled()` | 586 |
| `bool setWifiNetwork(quint32 index, const QByteArray &ssid, const QByteArray &pw)` | 588 |
| `CIGCONF::WifiNetwork wifiNetwork(quint32 index) const` | 589 |
| `bool setWifiCountry(const QByteArray &country)` | 591 |
| `QByteArray wifiCountry() const` | 592 |
| `void clearWifiConfig()` | 594 |
| `quint8 wifiPos()` | 596 |
| `quint16 wifiPosInterval()` | 597 |
| `CIGCONF::WifiPosSource wifiPosSource()` | 598 |
| `bool setWifiPos(const quint8 n, const quint16 interval, const CIGCONF::WifiPosSource src)` | 599 |
| `bool isRs232AccessoryActive()` | 606 |
| `qint16 debugMsg() const` | 608 |
| `void setDebugMsg(qint16 n)` | 609 |
| `qint16 debugSpn() const` | 611 |
| `void setDebugSpn(qint16 n)` | 612 |
| `quint32 geofenceState() const` | 614 |
| `void setGeofenceState(quint32 state)` | 615 |
| `quint8 showDriverName() const` | 617 |
| `bool setShowDriverName(quint8 show)` | 618 |
| `bool GPSMsgLogEn() const` | 624 |
| `void setGPSMsgLogEn(bool en)` | 625 |
| `quint8 showPreopComment() const` | 630 |
| `void setShowPreopComment(quint8 show)` | 631 |
| `quint8 amberImpactAlertActive() const` | 636 |
| `void setAmberImpactAlertActive(quint8 state)` | 637 |
| `quint8 idleLockout() const` | 642 |
| `bool setIdleLockout(quint8 en)` | 643 |
| `quint8 showPreopSummary() const` | 649 |
| `void setShowPreopSummary(quint8 show)` | 650 |
| `quint8 unlockMode() const` | 655 |
| `void setUnlockMode(quint8 mode)` | 656 |
| `quint8 forceChecklist() const` | 661 |
| `bool setForceChecklist(quint8 force)` | 662 |
| `quint8 showTime() const` | 669 |
| `void setShowTime(quint8 format)` | 670 |
| `quint8 vdiMode() const` | 675 |
| `void setVdiMode(quint8 mode)` | 676 |
| `CIGCONF::CameraMode cameraMode() const` | 681 |
| `void setCameraMode(CIGCONF::CameraMode mode)` | 682 |
| `quint8 cameraFlip() const` | 687 |
| `void setCameraFlip(quint8 flip)` | 688 |
| `QByteArray lastSessionDriver() const` | 693 |
| `QByteArray lastSessionStart() const` | 694 |
| `QByteArray lastSessionEnd() const` | 695 |
| `void setLastSessionDriver(const QByteArray& driver)` | 696 |
| `void setLastSessionStart(const QByteArray& start)` | 700 |
| `void setLastSessionEnd(const QByteArray& end)` | 704 |

**Signals:**
| Signal | Line |
|---|---|
| `superListChanged(bool empty)` | 710 |
| `convorStatusChanged()` | 711 |
| `preopOncePerDayStatusChanged()` | 712 |

**Private methods:**
| Method | Line |
|---|---|
| `bool readStaticConfig()` | 771 |
| `void saveStaticConfig()` | 772 |
| `void readDynamicConfig()` | 774 |
| `void saveDynamicConfig()` | 775 |
| `void readOdConfig()` | 777 |
| `void saveOdConfig()` | 778 |
| `void readVORConfig()` | 785 |
| `void saveVORConfig()` | 786 |
| `void readGeofenceConfig()` | 816 |
| `void saveGeofenceConfig()` | 817 |

**Private structs (nested / file-local):**
| Name | Lines |
|---|---|
| `ConfigsData` | 715–758 |
| `ConfigsDataExt` | 760–762 |
| `OnDemandData` | 764–769 |
| `ConvorData` | 780–783 |
| `DigitalInputCfg` | 788–793 |
| `FullLockoutData` | 835–838 |

**Private member variables:**
`m_configs`, `m_configsExt`, `m_odConfig`, `m_driverList`, `m_checklist`, `m_configErrorCode`, `m_VORConfig`, `m_dINConfig`, `m_currentDriverId`, `m_unlockId`, `m_lastTimeServerUpdate`, `m_timeError`, `m_unlkMessage`, `m_unlkOption`, `m_gpsDistanceMark`, `m_satNum`, `m_polygon[]`, `m_screenSaverMode`, `gmtpWaitTimeout`, `m_networks`, `m_country`, `m_wifiPos`, `m_wifiPosInterval`, `m_wifiPosSource`, `m_fmsDirty`, `m_dynDirty`, `m_gfnceDirty`, `m_debugMsg`, `m_debugSpn`, `m_geofenceState`, `m_convorId`, `m_seenDebounceTime`, `m_seenHoldTime`, `m_fullLockout`, `m_preopComment`, `m_preopRandom`, `m_showDriverName`, `m_isGPSMsgLogEn`, `m_showPreopComment`, `m_amberImpactAlertState`, `simICCID[]`, `m_preopOncePerDayEn`, `m_idleLockoutEnabled`, `m_showPreopSummary`, `m_unlockMode`, `m_forceChecklist`, `m_showTime`, `m_vdiMode`, `m_cameraMode`, `m_cameraFlip`, `m_lastSessionDriver`, `m_lastSessionStart`, `m_lastSessionEnd`

---

### 1.2 `app/globalconfigs.cpp`

**Functions defined (with line numbers):**

| Function | Line |
|---|---|
| `GlobalConfigs::GlobalConfigs(QObject *parent)` | 26 |
| `GlobalConfigs *GlobalConfigs::instance()` | 33 |
| `quint32 GlobalConfigs::crc32(const void *data, int len)` | 38 |
| `void GlobalConfigs::readConfigs()` | 51 |
| `void GlobalConfigs::saveConfigs()` | 110 |
| `void GlobalConfigs::saveOpdDriverList()` | 126 |
| `void GlobalConfigs::resetConfigs(bool resetAll)` | 131 |
| `bool GlobalConfigs::readStaticConfig()` | 265 |
| `void GlobalConfigs::saveStaticConfig()` | 420 |
| `void GlobalConfigs::readDynamicConfig()` | 510 |
| `void GlobalConfigs::saveDynamicConfig()` | 556 |
| `void GlobalConfigs::readOdConfig()` | 587 |
| `void GlobalConfigs::saveOdConfig()` | 618 |
| `bool GlobalConfigs::setSuperId(int index, quint64 id)` | 639 |
| `bool GlobalConfigs::addSuperId(quint64 id)` | 649 |
| `bool GlobalConfigs::removeSuperId(quint64 id)` | 659 |
| `void GlobalConfigs::readVORConfig()` | 669 |
| `void GlobalConfigs::saveVORConfig()` | 690 |
| `bool GlobalConfigs::setWifiNetwork(quint32 index, const QByteArray &ssid, const QByteArray &pw)` | 709 |
| `bool GlobalConfigs::setWifiCountry(const QByteArray &country)` | 723 |
| `void GlobalConfigs::clearWifiConfig()` | 733 |
| `void GlobalConfigs::saveGeofenceConfig()` | 749 |
| `void GlobalConfigs::readGeofenceConfig()` | 778 |

**File-level macros defined in `.cpp`:**

| Macro | Line | Value |
|---|---|---|
| `TEST_LOC_SZ` | 11 | (empty body — no value) |
| `FMS_INI_FILE` | 13 | `"fms.ini"` |
| `DYN_INI_FILE` | 14 | `"dyn.ini"` |
| `FMS_CONFIG_FILE` | 15 | `"fmscfg.dat"` |
| `OD_CONFIG_FILE` | 16 | `"odcfg.dat"` |
| `VOR_CONFIG_FILE` | 17 | `"vor.cfg"` |
| `GFNCE_CONFIG_FILE` | 18 | `"gfnce.cfg"` |
| `MAGIC_CODE` | 19 | `0xA53F3456` |
| `OD_VERSION` | 20 | `1` |

**`using` directive:** `using namespace CIGCONF;` at line 24.

---

### 1.3 `app/globalconfigsfilemanager.h` / `.cpp`

These files **do not exist** in the repository. A `Glob` search for `**/globalconfigsfilemanager*` returned no results. This is noted as Finding A05-1.

---

## 2. Findings

---

**A05-1** · INFO · `globalconfigsfilemanager.h` / `.cpp` do not exist

**Description:** The audit assignment references `app/globalconfigsfilemanager.h` and `app/globalconfigsfilemanager.cpp` as files to review. Neither file exists anywhere in the repository. This was also confirmed by the Pass 3 agent. File I/O is implemented directly inside `GlobalConfigs`, with no separate file-manager abstraction layer. The absence of the files may indicate: (a) the files were planned but never created; (b) they were deleted and the work was inlined; or (c) they are referenced by a stale task description.

**Fix:** Confirm with the team whether a file-manager abstraction was intentionally removed or was never implemented. If the split is still planned, create the files. If not, remove the reference from documentation and the build system.

---

**A05-2** · LOW · Dead macro `TEST_LOC_SZ` (cpp line 11)

**Description:** `#define TEST_LOC_SZ` is defined at `globalconfigs.cpp` line 11 with an empty body. It is never referenced anywhere else in the repository. It appears to be a leftover from a development or test build that was never cleaned up.

**Fix:** Remove the unused `#define TEST_LOC_SZ` line entirely.

---

**A05-3** · LOW · Commented-out code block — reverted MK3-296 logic (cpp lines 164–181)

**Description:** A large commented-out block (18 lines) at `globalconfigs.cpp` lines 164–181 contains the full implementation of an intentionally reverted feature (MK3-296: leading-zero GMTP ID generation). The comment header says `/** Reverted 06Mar24`. While the reverted date is noted, the dead code adds noise, obscures intent, and is now tracked in version control history.

**Fix:** Remove the commented-out block entirely. The VCS history preserves the reverted code if it is ever needed again.

---

**A05-4** · LOW · Commented-out code — minor residual comments (cpp lines 186–187, 194–196, 203–205, 212, 227–228, 243)

**Description:** Multiple single-line and small multi-line commented-out statements are scattered throughout `resetConfigs()` (cpp lines 186, 187, 194–196, 203–205, 212, 227–228) and `saveConfigs()` (line 120) and `resetConfigs()` (line 243). Examples:
- Line 120: `//saveOdConfig();`
- Lines 186–187: `// m_configs.maint.driverId = 0;` / `// m_configs.maint.timestamp = 0;`
- Lines 194–196: `// m_configs.checklistTimeout = 0;` etc.
- Line 243: `//setMasterId(0, 0x2002f5b, CIGCONF::UnassignedMasterMenu, "");`

These commented-out statements are redundant (the `memset` above already zeros the struct) or represent disabled functionality with no explanation. They create maintenance confusion.

**Fix:** Remove all residual commented-out statements. Add an explanatory comment if a deliberate default is being preserved.

---

**A05-5** · LOW · Commented-out `qDebug` in `saveDynamicConfig()` (cpp line 583)

**Description:** `// qDebug() << Q_FUNC_INFO << "Saved dynamic config.";` at line 583 is commented out, unlike the equivalent log statements in every other save function. This is inconsistent with the surrounding code style, where every other `save*Config()` function emits a `qDebug` success message.

**Fix:** Either restore the `qDebug` call (consistent with `saveStaticConfig()`, `saveOdConfig()`, etc.) or document why it is intentionally suppressed.

---

**A05-6** · MEDIUM · Member prefix inconsistency — `gmtpWaitTimeout` and `simICCID` lack `m_` prefix

**Description:** Every private member variable in `GlobalConfigs` uses the `m_` prefix (e.g., `m_fmsDirty`, `m_configs`, `m_screenSaverMode`). Two members violate this convention:
- `gmtpWaitTimeout` (header line 814 / used in cpp lines 236, 365, 470)
- `simICCID[MODEM_ICCID_LEN]` (header line 849 / used in cpp lines 157–165 via the public `getSimCardID()` / `setSimCardID()` / `resetSimCardID()`)

Both are accessed directly in public inline methods, making the inconsistency visible through the public interface.

**Fix:** Rename to `m_gmtpWaitTimeout` and `m_simICCID` (or `m_simIccid` following Qt camelCase conventions) throughout the header and implementation.

---

**A05-7** · MEDIUM · `getDriverName()` uses `gCfg` macro to call back on itself (header lines 220–231)

**Description:** The inline public method `getDriverName(quint64 id)` (header lines 220–231) calls `gCfg->containsTechId(id)`, `gCfg->techIds()`, etc., where `gCfg` expands to `GlobalConfigs::instance()`. The method is called on the singleton, and then internally re-acquires the singleton to call its own public methods. This is a circular self-reference through the global accessor: `this->getDriverName()` → `GlobalConfigs::instance()->containsTechId()`. The correct form would simply use `this->` or call the member objects directly.

**Fix:** Replace all `gCfg->` calls inside `getDriverName()` with direct calls on `this` (e.g., `containsTechId(id)`, `techIds().at(getTechIdIndex(id)).name`).

---

**A05-8** · MEDIUM · `setConvor()` uses `gCfg` self-reference inside member function (header line 265)

**Description:** `setConvor(quint8 convor, quint64 id)` (header lines 259–267) calls `gCfg->setLastCheckTimestamp(0)` inside its body. As with A05-7, `gCfg` is `GlobalConfigs::instance()`, so the method is calling back on itself through the global accessor rather than via `this`.

**Fix:** Replace `gCfg->setLastCheckTimestamp(0)` with `setLastCheckTimestamp(0)` or `this->setLastCheckTimestamp(0)`.

---

**A05-9** · MEDIUM · `onDemandActive()` and `onDemandVehicleEnabled()` use `gCfg` self-reference (header lines 585–586)

**Description:** Both methods expand `gCfg` to `GlobalConfigs::instance()` and then call other methods on the singleton, while they are themselves member functions of that same singleton. Same pattern as A05-7 and A05-8.

**Fix:** Replace `gCfg->` with direct method calls, e.g., `superIsEmpty()` and `onDemandStartTime()` etc.

---

**A05-10** · LOW · `resetConfigs()` calls `memset` on wrong type for `m_configsExt` (cpp line 140)

**Description:** `resetConfigs()` at cpp line 140 performs:
```cpp
memset(&m_configs, 0, sizeof(ConfigsDataExt));
```
This is a copy-paste error. The first argument is `&m_configs` (of type `ConfigsData`) but the size used is `sizeof(ConfigsDataExt)`. Since `ConfigsDataExt` is a 1-byte struct (`quint8 unlkScr`) this is harmless in practice (it only zeroes the first byte of `m_configs`, which was already zeroed by the preceding `memset`), but it never resets `m_configsExt` at all. The intended call should be `memset(&m_configsExt, 0, sizeof(ConfigsDataExt))`.

**Fix:** Change line 140 to:
```cpp
memset(&m_configsExt, 0, sizeof(ConfigsDataExt));
```

---

**A05-11** · HIGH · `readConfigs()` partial-read fallback branch uses an already-attempted `QFile` (cpp lines 63–90)

**Description:** In `readConfigs()`, if `readStaticConfig()` returns `false`, a second attempt is made to read `FMS_CONFIG_FILE` (`fmscfg.dat`) using binary layout. The two files are distinct (`fms.ini` vs `fmscfg.dat`), so this is intentional fallback logic. However, there is an architectural defect: the fallback branch sets `m_configErrorCode = ConfigSizeError` (line 65) before opening the file, then overwrites it with `ConfigCrcError` (line 79) before validating the magic/CRC. If the magic code or CRC check fails, `resetConfigs()` is called (which resets `m_configErrorCode` indirectly via `memset`) but the error code set at line 79 (`ConfigCrcError`) was already overwritten by `resetConfigs()` resetting `m_configs`. After `resetConfigs()`, the code falls through to line 92 (`m_configErrorCode = NoConfigError`), incorrectly reporting a clean state after a CRC failure.

**Fix:** Preserve the error code after calling `resetConfigs()` by setting it again after the `return` statements, or restructure the error-code assignments so `m_configErrorCode` is set after `resetConfigs()` returns in all error paths. Additionally, make `resetConfigs()` not clear `m_configErrorCode`.

---

**A05-12** · MEDIUM · `readGeofenceConfig()` — unused variable `it` declared outside the loop (cpp line 780)

**Description:** `readGeofenceConfig()` at cpp line 780 declares `int it;` and then uses it as the loop counter in a C-style `for (it = 0; it < bas.size(); it++)` loop (line 794). The `it` variable has function scope but is only used inside the loop. Modern C++ style (and Qt convention) declares the loop variable in the `for` initialiser.

**Fix:** Change the loop to `for (int it = 0; it < bas.size(); it++)` and remove the outer declaration.

---

**A05-13** · LOW · Naming convention inconsistency — `UnlkReasonString()` and `UnlkOption()` use PascalCase for non-constructor public methods (header lines 560, 563)

**Description:** Qt coding convention and the prevailing style throughout this class uses lowerCamelCase for public method names (e.g., `maintCode()`, `dialNumber()`, `checklistTimeout()`). The two methods `UnlkReasonString()` and `UnlkOption()` (header lines 560 and 563) use PascalCase, as does `GPSMsgLogEn()` (line 624). This is inconsistent with every other accessor in the class.

**Fix:** Rename to `unlkReasonString()`, `unlkOption()`, and `gpsMsgLogEn()` (or `isGpsMsgLogEn()` following Qt bool-property convention). Update all call sites.

---

**A05-14** · LOW · `bool` members stored as `quint8` — type mismatch and potential signed/unsigned warnings (header lines 851, 853–855, 858)

**Description:** Several fields that semantically hold boolean on/off state are stored as `quint8` rather than `bool`:
- `m_preopOncePerDayEn` (line 850) declared `bool`, but written in `resetConfigs()` as `m_preopOncePerDayEn = 0` and read from file as `(quint8)args[1].toUInt()`.
- `m_idleLockoutEnabled` (line 851): declared `quint8`, but the reset code assigns `false` (cpp line 252): `m_idleLockoutEnabled = false;`
- `m_showPreopSummary`, `m_unlockMode`, `m_forceChecklist`, `m_showTime`, `m_vdiMode` (lines 852–856) are all `quint8` but semantically flags or small enumerations.

The assignment `m_idleLockoutEnabled = false` (cpp line 252) is an implicit conversion from `bool` to `quint8`, which is defined behaviour but triggers `-Wconversion` on stricter build configurations. The inconsistency between `bool` declaration (`m_preopOncePerDayEn`) and `quint8` usage (file I/O casting) is a latent type-mismatch smell.

**Fix:** Decide on a consistent representation. Pure boolean flags should be `bool`. Multi-value flags that map to file-stored integers should be the appropriate integer type. Remove the `= false` initialisation of a `quint8` member.

---

**A05-15** · LOW · `QString` pass-by-value in several public setter methods (header lines 180–183, 220, 558, 561)

**Description:** Several public setters accept `QString` by value instead of by `const QString &`:
- `setDriverId(int index, quint64 id, QString name)` (line 180)
- `setMasterId(int index, quint64 id, quint8 option, QString name)` (line 181)
- `setTechId(int index, quint64 id, QString name)` (line 183)
- `addDriverId(quint64 id, QString name)` (line 190)
- `addTechId(quint64 id, QString name)` (line 192)
- `setPreopCommentString(QString msg)` (line 558)
- `setUnlkReasonString(QString msg)` (line 561)

Each call site causes an unnecessary copy of the `QString` object on the call stack.

**Fix:** Change the parameter type to `const QString &` in all of the above signatures.

---

**A05-16** · MEDIUM · `readStaticConfig()` uses `while(1)` with a single-empty-line break condition (cpp line 274)

**Description:** The loop `while (1) { ... if (ba.isEmpty()) break; ... }` in `readStaticConfig()` (and identically in `readDynamicConfig()`, cpp line 519) uses an infinite loop with an implicit EOF/empty-line break. `QFile::readLine()` returns an empty `QByteArray` both on EOF and on an actual blank line within the file. This means a blank line in `fms.ini` silently terminates parsing of the rest of the file, discarding any settings below the blank line without warning. The correct approach is to check `QFile::atEnd()`.

**Fix:** Replace `while (1)` with `while (!file.atEnd())` and remove the `if (ba.isEmpty()) break;` guard (keeping the `if (args.size() != 2) continue;` guard to skip truly blank lines).

---

**A05-17** · LOW · `dec` and `endl` stream manipulators are deprecated in Qt 5.15+ (cpp lines 434 onwards)

**Description:** `saveStaticConfig()` and `saveDynamicConfig()` make extensive use of `dec` and `endl` as `QTextStream` manipulators (e.g., cpp lines 434–502, 570–579). In Qt 5.15, `dec`, `endl`, and related manipulators were deprecated in favour of `Qt::dec`, `Qt::endl`, etc. Building with `-Wdeprecated-declarations` (default for Qt 5.15+) will produce warnings for every occurrence.

**Fix:** Replace `dec` with `Qt::dec` and `endl` with `Qt::endl` (or `'\n'`) throughout `saveStaticConfig()` and `saveDynamicConfig()`.

---

**A05-18** · LOW · C-style casts in `readStaticConfig()` (cpp lines 284, 300, 335–337, 339, 343–347, 359–410)

**Description:** `readStaticConfig()` uses C-style casts (`(quint8)`, `(quint16)`, `(quint32)`, `(qint16)`, `(CIGCONF::WifiPosSource)`, `(CIGCONF::CameraMode)`, `(CIGCONF::MaintLockedCode)`) extensively when assigning values parsed from the INI file (e.g., `(quint8)args[1].toUInt()` on lines 284, 335, 336, 339, etc.). C-style casts suppress compiler narrowing warnings and bypass type-safety checks.

**Fix:** Replace C-style casts with `static_cast<quint8>(...)` and the equivalent Qt integer types. For enum casts (`CIGCONF::WifiPosSource`, etc.), validate the integer value is within the enum range before casting.

---

**A05-19** · LOW · `readGeofenceConfig()` mixes `qint32` parse result into `quint32` polygon field without validation (cpp lines 803–807)

**Description:** In `readGeofenceConfig()` (cpp lines 801–807):
```cpp
qint32 lon = pol[2].trimmed().toLong();
qint32 lat = pol[3].trimmed().toLong();
m_polygon[n].polyVertices[vect].latitude = lat;
m_polygon[n].polyVertices[vect].longitude = lon;
```
`latitude` and `longitude` in `gpsPosStruct` are `qint32`, but in the header, `polygonLatitude()` / `polygonLongitude()` return `quint32` and the setters accept `quint32`. There is an implicit signed/unsigned mismatch at every point where the polygon data moves through the public API. This is likely to produce `-Wsign-compare` or `-Wconversion` warnings on stricter builds.

**Fix:** Decide on a single type for coordinates throughout (`qint32` is the correct type for signed latitude/longitude values). Update `gpsPosStruct` fields, the getter return types, setter parameter types, and the save/read functions to use `qint32` consistently.

---

**A05-20** · MEDIUM · No bounds checking on `gmtpServerAddress(int index)` and `gmtpServerPort(int index)` getters (header lines 127, 137)

**Description:** The getter methods `gmtpServerAddress(int index)` and `gmtpServerPort(int index)` (header lines 127 and 137) perform no bounds check on `index`. An out-of-range `index` causes an array out-of-bounds access on `m_configs.gmtpServer[index]`. The corresponding setters validate `index >= 0 && index < GMTP_SERVER_CNT`, but the getters do not. Callers who pass an unchecked `index` (e.g., in `saveStaticConfig()` loop) are relying on the caller to be correct. The same pattern exists for `checkTimeSlot(int index)` (line 304) and `polygon(int n)` / `polygonNPoints(int n)` / `polygonLatitude()` / `polygonLongitude()` (lines 490–519).

**Fix:** Add bounds assertions (`Q_ASSERT(index >= 0 && index < GMTP_SERVER_CNT)`) or range-checked access to all array-indexed getters.

---

## 3. Summary Table

| ID | Severity | Title |
|---|---|---|
| A05-1 | INFO | `globalconfigsfilemanager.h/.cpp` do not exist |
| A05-2 | LOW | Dead macro `TEST_LOC_SZ` |
| A05-3 | LOW | Large commented-out reverted-feature block (MK3-296, cpp lines 164–181) |
| A05-4 | LOW | Residual commented-out code in `resetConfigs()` / `saveConfigs()` |
| A05-5 | LOW | `qDebug` success log commented out in `saveDynamicConfig()` |
| A05-6 | MEDIUM | Missing `m_` prefix on `gmtpWaitTimeout` and `simICCID` |
| A05-7 | MEDIUM | `getDriverName()` uses `gCfg` self-reference instead of `this` |
| A05-8 | MEDIUM | `setConvor()` uses `gCfg` self-reference instead of `this` |
| A05-9 | MEDIUM | `onDemandActive()` / `onDemandVehicleEnabled()` use `gCfg` self-reference |
| A05-10 | LOW | `resetConfigs()` memset targets wrong object for `ConfigsDataExt` |
| A05-11 | HIGH | Error code incorrectly reset to `NoConfigError` after CRC failure in `readConfigs()` |
| A05-12 | MEDIUM | `readGeofenceConfig()` — loop variable `it` declared outside the loop |
| A05-13 | LOW | Inconsistent PascalCase on `UnlkReasonString()`, `UnlkOption()`, `GPSMsgLogEn()` |
| A05-14 | LOW | Boolean fields stored as `quint8`; `bool` field initialised with `false` assigned to `quint8` |
| A05-15 | LOW | `QString` parameters passed by value instead of `const QString &` |
| A05-16 | MEDIUM | `while(1)` parse loop breaks on first blank line, silently dropping rest of config file |
| A05-17 | LOW | Deprecated Qt `dec` / `endl` manipulators in `QTextStream` output |
| A05-18 | LOW | Pervasive C-style casts in `readStaticConfig()` |
| A05-19 | LOW | Signed/unsigned mismatch for polygon coordinate types across public API |
| A05-20 | MEDIUM | No bounds checking on array-indexed getter methods |
# Pass 4 Agent A06 — Code Quality

**Audit run:** 2026-02-28-01
**Branch:** master
**Files reviewed:**
- `comm/bleexpansion.h`
- `comm/bleexpansion.cpp`
- `comm/bleexpansionuuid.h`
- `comm/bleexpansionuuid.cpp` (companion definition file, read for full context)

---

## Reading Evidence

### `comm/bleexpansion.h`

**Class:** `BleExpansion` (inherits `QObject`)

| Function / Method | Line | Visibility |
|---|---|---|
| `explicit BleExpansion(EM070::BleCentral *bleCentral)` | 32 | public |
| `void setEnabled(bool enable)` | 34 | public |
| `const QByteArray &deviceName() const` | 36 | public inline |
| `const QByteArray &bleVersion() const` | 37 | public inline |
| `const QByteArray &mainVersion() const` | 38 | public inline |
| `const QByteArray &manufacture() const` | 39 | public inline |
| `const QByteArray &modelNumber() const` | 40 | public inline |
| `bool digitalInput(CIGCONF::BleExpansionDI di) const` | 42 | public inline |
| `bool relayOutput(CIGCONF::BleExpansionRelay relay) const` | 44–46 | public inline |
| `void setRelayOutput(CIGCONF::BleExpansionRelay relay, bool state)` | 47 | public |
| `void setShockThreshold(quint32 threshold)` | 49 | public |
| `void setShockPeriod(quint32 period)` | 50 | public |
| `bool isShockQueueEmpty()` | 52 | public inline |
| `ShockEvent shockEvent()` | 53 | public inline |
| `void setCurrentTime(const QDateTime &time)` | 55 | public |
| `bool generateShockMessage(bool force)` | 57 | public |
| `void accessible(bool yes)` *(signal)* | 60 | signal |
| `void inputStateChanged(CIGCONF::BleExpansionDI input, bool state)` *(signal)* | 61 | signal |
| `void shockOccurred()` *(signal)* | 62 | signal |
| `void amberImpactOccurred()` *(signal)* | 63 | signal |
| `void redImpactOccurred()` *(signal)* | 64 | signal |
| `void timerEvent(QTimerEvent *)` | 67 | protected override |
| `void setAccessible(bool yes)` | 103 | private |
| `void readDeviceInfo()` | 104 | private |
| `void resetInputTimer()` | 105 | private |
| `void resetOutput()` | 106 | private |
| `void initRelays()` | 107 | private |
| `void clearShockEvent()` | 108 | private |
| `void popShockEvent(const QByteArray &ba)` | 109 | private |
| `void allowShockCountNotify(bool yes)` | 110 | private |
| `void characteristicRead(const quint128 &uuid, const QByteArray &ba)` | 111 | private |
| `void characteristicWritten(const quint128 &uuid, const QByteArray &ba)` | 112 | private |
| `void descriptorRead(const quint128 &uuid, const QByteArray &ba)` | 113 | private |
| `void descriptorWritten(const quint128 &uuid, const QByteArray &ba)` | 114 | private |

**Types / Unions / Nested structs defined in `bleexpansion.h`:**

| Name | Kind | Lines |
|---|---|---|
| `BleExpansion::ShockEvent` | nested struct | 27–30 |
| `BleExpansion::RtcTime` | private union (char[10] + packed struct) | 71–83 |
| `BleExpansion::WritePending` | private union (quint32 + bitfield struct) | 85–101 |

**Member variables:** `m_bleCentral`, `m_timerId`, `m_accessible`, `m_shockCountNotifyEnabled`, `m_pending`, `m_previousPending`, `m_deviceName`, `m_bleVersion`, `m_mainVersion`, `m_manufacture`, `m_modelNumber`, `m_shockMaxMagnitude`, `m_digitalInput[4]`, `m_outputRelay[2]`, `m_shockThreshold`, `m_shockPeriod`, `m_shockTimestamp`, `m_shockEvent1`, `m_readingShocks`, `m_shockEvents`, `m_popTimer`.

---

### `comm/bleexpansionuuid.h`

**Class:** `BleExpansionUuid` (utility/namespace-like class, no base)

| Function / Method | Line | Visibility |
|---|---|---|
| `static inline bool equals128(const quint128 *v1, const quint128 *v2)` | 9–17 | public static inline |

**Static data members (all `private static quint128`):**

`authUuid` (20), `deviceName` (21), `appearance` (22), `bleVersion` (23), `mainVersion` (24), `manufactureName` (25), `modelNumber` (26), `currentRtc` (27), `inputTimerReset` (28), `inputD0`–`inputD3` (29–32), `inputPullUp0`–`inputPullUp3` (33–36), `outputReset` (37), `outputRelay0`–`outputRelay1` (38–39), `relay0Timeout`–`relay1Timeout` (40–41), `outputD0`–`outputD3` (42–45), `openCollector0`–`openCollector3` (46–49), `shockCount` (50), `shockPeek` (51), `shockPop` (52), `shockThreshold` (53), `shockPeriod` (54), `shockMaxMagnitude` (55), `shockCountNotifyDesc` (56).

**Friend declaration:** `friend class BleExpansion;` (line 58).

---

### `comm/bleexpansion.cpp`

**Preprocessor macros defined:**

| Macro | Value | Line |
|---|---|---|
| `AUTH_CODE` | `"uS8MgpklMx"` | 9 |
| `MAX_SHOCK_COUNT` | `10000` | 11 |
| `RELAY1_TIMEOUT` | `60` | 12 |
| `RELAY2_TIMEOUT` | `60` | 13 |

**Function definitions (line numbers are the definition start):**

| Function | Line |
|---|---|
| `BleExpansion::BleExpansion` (constructor) | 17 |
| `BleExpansion::timerEvent` | 43 |
| `BleExpansion::setEnabled` | 76 |
| `BleExpansion::setAccessible` | 81 |
| `BleExpansion::setRelayOutput` | 114 |
| `BleExpansion::readDeviceInfo` | 140 |
| `BleExpansion::setCurrentTime` | 154 |
| `BleExpansion::resetInputTimer` | 175 |
| `BleExpansion::resetOutput` | 184 |
| `BleExpansion::clearShockEvent` | 193 |
| `BleExpansion::popShockEvent` | 200 |
| `BleExpansion::generateShockMessage` | 237 |
| `BleExpansion::setShockThreshold` | 254 |
| `BleExpansion::initRelays` | 265 |
| `BleExpansion::setShockPeriod` | 289 |
| `BleExpansion::allowShockCountNotify` | 300 |
| `BleExpansion::characteristicRead` | 308 |
| `BleExpansion::characteristicWritten` | 427 |
| `BleExpansion::descriptorRead` | 508 |
| `BleExpansion::descriptorWritten` | 518 |

---

## Findings

---

**A06-1** · HIGH · `descriptorRead` is implemented but never connected

**Description:** `BleExpansion::descriptorRead` is declared at header line 113 and implemented at `bleexpansion.cpp` line 508. However, the constructor (lines 29–34) only connects four `BleCentral` signals: `characteristicChanged`, `characteristicRead`, `characteristicWritten`, `descriptorWritten`, and `accessible`. There is no `connect` call for `BleCentral::descriptorRead`. The `descriptorRead` slot is therefore dead — it can never be invoked at runtime. The `m_shockCountNotifyEnabled` flag that depends on it (lines 511–514) can therefore only ever be set through `descriptorWritten`, and the `descriptorRead` path is silently unreachable. This is both dead code and a latent bug if the read path is ever relied upon.

**Fix:** Either add `connect(m_bleCentral, &BleCentral::descriptorRead, this, &BleExpansion::descriptorRead);` in the constructor, or remove the `descriptorRead` method entirely if only the write confirmation path is needed.

---

**A06-2** · HIGH · `allowShockCountNotify` is defined but never called

**Description:** `BleExpansion::allowShockCountNotify(bool yes)` is declared private (header line 110) and implemented at `bleexpansion.cpp` line 300. A full search of the repository finds no call site for this function. The `m_shockCountNotifyEnabled` flag it manages is also never read from outside the notification-descriptor callbacks. The BLE CCCD notification path for `shockCount` is therefore permanently disabled, meaning the firmware relies entirely on polling (the 1-second timer) to detect shock events rather than the notification mechanism that was apparently planned.

**Fix:** Either wire `allowShockCountNotify` into the `setAccessible(true)` path and handle the resulting `characteristicChanged` notifications, or remove the method and the `m_shockCountNotifyEnabled` member to reflect the chosen polling design.

---

**A06-3** · HIGH · `resetInputTimer` and `resetOutput` are defined but never called

**Description:** Both `BleExpansion::resetInputTimer()` (header line 105, impl line 175) and `BleExpansion::resetOutput()` (header line 106, impl line 184) are private methods with no call sites anywhere in the repository. The `WritePending` bitfield contains corresponding bits `inputTimerReset` (bit 1) and `outputReset` (bit 6) that are set inside these methods, but because the methods are never invoked, those bits are permanently zero and their acknowledgement branches in `characteristicWritten` (lines 494–504) are also unreachable dead code.

**Fix:** Remove both methods and their corresponding `WritePending` bitfield entries, or document and implement the conditions under which they should be triggered.

---

**A06-4** · MEDIUM · Commented-out code block in `initRelays` (lines 284–286)

**Description:** Three lines of commented-out code appear at the end of `initRelays`:

```cpp
//m_pending.bitMap.outputRelay = 1;
//        m_bleCentral->writeCharacteristic(BleExpansionUuid::outputRelay0, ba);
//        SerialLogger::log(QString("[EXPMOD:RLY] Relay 1 %1\r\n").arg(state?"closed":"opened").toLatin1());
```

These lines were replaced by the `setRelayOutput` calls on lines 281–282 but left in place. The fragment is also syntactically incomplete (references `ba` and `state` that are out of scope at that point), meaning it could not even be uncommented without further edits.

**Fix:** Delete the three commented-out lines.

---

**A06-5** · MEDIUM · `MAX_SHOCK_COUNT` macro defined but never used

**Description:** `#define MAX_SHOCK_COUNT 10000` appears at `bleexpansion.cpp` line 11. No usage of this constant exists anywhere in the file or the wider codebase. The `m_shockEvents` queue is unbounded; the hardware shock counter is a 16-bit value read from a BLE characteristic. It is unclear whether this constant was intended as a queue size cap or as a guard in `popShockEvent`. Its presence without use is misleading and may indicate an unimplemented safety limit.

**Fix:** Either apply the constant as an upper bound on `m_shockEvents.size()` (or on the shock counter read-back) or remove the macro.

---

**A06-6** · MEDIUM · `m_shockMaxMagnitude` is written but never read

**Description:** `m_shockMaxMagnitude` is declared at header line 131 and assigned at `bleexpansion.cpp` line 422 when the BLE characteristic is read. However, it is never subsequently used — not in `popShockEvent`, `generateShockMessage`, nor exposed via any getter. The corresponding UUID (`BleExpansionUuid::shockMaxMagnitude`) is read from the peripheral at startup (line 151) purely to populate this variable. The field appears to have been retained for a planned feature (e.g., normalising shock magnitude or setting an upper alert threshold) that was never implemented.

**Fix:** Either expose `m_shockMaxMagnitude` through a getter and use it in threshold comparisons, or remove the member, the `readCharacteristic` call for `shockMaxMagnitude`, and the handling branch in `characteristicRead`.

---

**A06-7** · MEDIUM · `AUTH_CODE` is a plain-text hardcoded secret in source

**Description:** Line 9 of `bleexpansion.cpp` defines:

```cpp
#define AUTH_CODE   "uS8MgpklMx"
```

This value is passed directly as the BLE authorisation code to `m_bleCentral->setAuthorizationCode(...)` in the constructor (line 40). It is stored verbatim in the compiled binary and committed in version control. Any party with access to the repository or the binary can recover the peripheral authentication credential.

**Fix:** Do not store credentials as string literals in source. Load the auth code from a protected key store, a provisioned device identity, or a configuration protected by OS-level access controls. At minimum, move it out of a public macro into a more restricted scope.

---

**A06-8** · MEDIUM · Double-semicolons on relay-correction lines create silent no-ops

**Description:** Lines 377 and 385 of `bleexpansion.cpp` each have a trailing double semicolon:

```cpp
setRelayOutput(CIGCONF::BleExpRelay1, m_outputRelay[0]);;   // line 377
setRelayOutput(CIGCONF::BleExpRelay2, m_outputRelay[1]);;   // line 385
```

While a stray `;` is syntactically harmless as an empty statement in C++, it is a style defect that signals a copy-paste error or incomplete edit, and some compiler warning configurations (`-Wextra` with pedantic settings) will flag it. More importantly, both lines are inside the relay-discrepancy correction block but the double semicolon suggests the code was hastily edited and may have originally contained a missing `else` branch or an additional side-effect call.

**Fix:** Remove the extra semicolons.

---

**A06-9** · MEDIUM · `RtcTime` uses GCC-specific `__attribute__((packed))` on an anonymous struct inside a union

**Description:** The `RtcTime` union (header lines 71–83) uses:

```cpp
} DateTime __attribute__ ((packed));
```

`__attribute__((packed))` is a GCC/Clang extension not available in MSVC. The union overlays a `char[10]` array against a struct of `quint8`/`quint16` fields. Even without the attribute, accessing the struct members through `rtc.DateTime.year` on a platform where `quint16` requires 2-byte alignment would be undefined behaviour if the union's base address is odd. Mixing union-based type-punning with packed structs is not portable C++ and may produce misaligned-read UB on ARM platforms depending on the allocator.

**Fix:** Replace the union/packed-struct with explicit `qToLittleEndian`/byte-array writes to remove both the portability and the UB risk.

---

**A06-10** · MEDIUM · `reinterpret_cast` on potentially unaligned BLE byte buffers

**Description:** Multiple locations dereference `reinterpret_cast<const quint32 *>(ba.constData())` directly:

- `popShockEvent` line 204: `event.timestamp = *(reinterpret_cast<const quint32 *>(ba.constData()))`
- `popShockEvent` line 205: `event.magnitude = *(reinterpret_cast<const quint32 *>(ba.constData() + 4))`
- `characteristicRead` line 422: `m_shockMaxMagnitude = *(reinterpret_cast<const quint32 *>(ba.constData()))`
- `characteristicWritten` lines 474 and 481: same pattern for threshold/period confirmation

`QByteArray::constData()` returns a `const char *` whose alignment is only guaranteed to be 1-byte. On ARM Cortex-A/M targets where the BLE stack may supply non-4-byte-aligned buffers, dereferencing a `quint32 *` from such a pointer is undefined behaviour (unaligned access trap or silent tearing depending on MCU configuration).

**Fix:** Use `qFromLittleEndian<quint32>(ba.constData())` or `memcpy` into a local `quint32` to perform safe unaligned reads.

---

**A06-11** · MEDIUM · `WritePending` bitfield uses signed `int` for bit members

**Description:** The `WritePending::bitMap` struct (header lines 87–100) declares all bit-field members as `int` (signed), e.g.:

```cpp
int currentTime     : 1;
int shockEventClear : 1;
```

A 1-bit signed integer has only two representable values: `0` and `-1`. Assigning `1` to a 1-bit signed bitfield yields implementation-defined behaviour in C++03 and is still potentially surprising in C++11+. The code uses assignments like `m_pending.bitMap.currentTime = 1` throughout, which will always store `-1` in a 1-bit signed field on two's-complement platforms, but comparing or printing the value produces unexpected results.

**Fix:** Change all bitfield member types to `unsigned int` (or `quint32`) to make single-bit values behave as booleans with values 0 and 1.

---

**A06-12** · LOW · `isShockQueueEmpty` and `shockEvent` are non-`const` public inline methods lacking `const` correctness

**Description:** `isShockQueueEmpty()` (header line 52) could logically be `const` — it only calls `m_shockEvents.isEmpty()`. It is not declared `const`. `shockEvent()` (line 53) does mutate the queue (dequeue), so `const` is not applicable there, but the absence of `const` on `isShockQueueEmpty` is a minor style defect.

**Fix:** Add `const` qualifier to `isShockQueueEmpty`.

---

**A06-13** · LOW · `BleExpansionUuid` UUID constants declared without `const`

**Description:** All 37 UUID constants in `BleExpansionUuid` are declared `static quint128` — mutable by any code in scope — rather than `static const quint128`. The `friend class BleExpansion` declaration makes all private members accessible to `BleExpansion`, which means any method of `BleExpansion` can inadvertently modify a UUID constant. Given the definitions in `bleexpansionuuid.cpp` are used only as read-only lookup keys, they should be const.

**Fix:** Change all `static quint128` members in `BleExpansionUuid` to `static const quint128` and update the `bleexpansionuuid.cpp` definitions accordingly.

---

**A06-14** · LOW · `equals128` performs pointer arithmetic past the end of `quint128` without size guarantee

**Description:** `BleExpansionUuid::equals128` (header lines 9–17) casts two `const quint128 *` pointers to `const quint32 *` and iterates four times with `++p1`/`++p2`. This assumes `sizeof(quint128) == 16` and that the layout is exactly four contiguous `quint32` values. Qt's `quint128` is a typedef for a compiler-specific 128-bit integer type (or a struct on platforms without native 128-bit support). If the struct representation has padding, the comparison silently fails. Qt provides `QBluetoothUuid::toUInt128()` which returns a well-defined struct; however, there is no static assertion verifying this assumption.

**Fix:** Add `static_assert(sizeof(quint128) == 16, "quint128 size mismatch");` inside `equals128`, or use `memcmp(v1, v2, sizeof(quint128))` which is both safer and more readable.

---

**A06-15** · LOW · `setRelayOutput` logs a debug warning on inaccessible state but continues execution

**Description:** At `bleexpansion.cpp` line 117:

```cpp
if (!m_accessible)
    qDebug() << "setRelayOutput(" << relay << ", " << state << ") not accessible";
```

The function does **not** return after logging. It falls through to update `m_outputRelay[0]` or `m_outputRelay[1]` (lines 123, 131) even when not accessible, but does not write to the BLE characteristic. This silent state divergence means the local shadow state (`m_outputRelay`) is updated as if the write succeeded, but the peripheral is not written. When accessibility is later restored, `initRelays` will push the cached state to the peripheral, which partly mitigates this, but the debug-only log with no early return is a style inconsistency with every other method in the class (all of which do `if (!m_accessible) return;`).

**Fix:** Consistently apply the early-return guard, or replace with `qWarning()` to surface the issue at a non-debug build level.

---

**A06-16** · LOW · `appearance` UUID is declared and defined but never used

**Description:** `BleExpansionUuid::appearance` is declared in `bleexpansionuuid.h` line 22 and defined in `bleexpansionuuid.cpp` line 9. No code in `bleexpansion.cpp` (or anywhere else in the repository) reads or writes the `appearance` characteristic. It is dead data.

**Fix:** Remove the `appearance` declaration and definition.

---

**A06-17** · LOW · Output UUIDs `outputD0`–`outputD3` and `openCollector0`–`openCollector3` are never referenced in `bleexpansion.cpp`

**Description:** Eight UUID constants — `outputD0`, `outputD1`, `outputD2`, `outputD3`, `openCollector0`, `openCollector1`, `openCollector2`, `openCollector3` — are declared in `bleexpansionuuid.h` and defined in `bleexpansionuuid.cpp`, but are never referenced in `bleexpansion.cpp`. The corresponding `WritePending` bitfield allocates bits for `output` (4 bits) and `openCollector` (4 bits) but no code ever sets or clears these bits. This suggests a partially implemented feature for driving digital outputs and open-collector outputs.

**Fix:** Either implement the digital output and open-collector write/read paths, or remove the UUID constants and `WritePending` bit allocations to keep the code consistent with what is actually used.

---

**A06-18** · INFO · `inputPullUp0`–`inputPullUp3` UUIDs are defined but never used in `bleexpansion.cpp`

**Description:** The four pull-up configuration UUIDs (`inputPullUp0`–`inputPullUp3`, `bleexpansionuuid.h` lines 33–36) are defined but never referenced in `bleexpansion.cpp`. The `WritePending` bitfield reserves 4 bits for `inputPullup` (header line 90), but no code sets or clears these bits.

**Fix:** Implement pull-up configuration writes if required by the hardware protocol, or remove the unused UUID constants and bitfield entries.

---

**A06-19** · INFO · `relay0Timeout` and `relay1Timeout` use magic constants `RELAY1_TIMEOUT`/`RELAY2_TIMEOUT` both set to `60` with no units documented

**Description:** Macros `RELAY1_TIMEOUT` (value `60`) and `RELAY2_TIMEOUT` (value `60`) are defined at lines 12–13 without any comment indicating the unit (seconds? milliseconds? BLE ticks?). The values are written as a 16-bit little-endian integer to the relay timeout characteristics. A reader cannot determine from source alone what timeout duration is configured.

**Fix:** Add a comment stating the unit (e.g., `// seconds`) next to the macro definitions.

---

**A06-20** · INFO · `m_previousPending` is not initialised in the constructor member-initialiser list

**Description:** `m_previousPending` is declared at header line 123 but does not appear in the constructor initialiser list (`bleexpansion.cpp` lines 17–26). `m_pending.val` is explicitly zeroed at line 27, but `m_previousPending` receives no initialisation — its value at construction is indeterminate until the first write acknowledgement. If `timerEvent` fires before any write is acknowledged, the stale comparison on line 50 (`m_previousPending == m_pending.val`) may suppress the "Failed to write" warning spuriously.

**Fix:** Add `m_previousPending(0)` to the constructor's member-initialiser list.

---

**A06-21** · INFO · `m_shockCountNotifyEnabled` is not initialised in the constructor member-initialiser list

**Description:** `m_shockCountNotifyEnabled` is declared at header line 120 but is absent from the constructor initialiser list. It is set to `false` inside `setAccessible(true)` at line 98, but if any BLE event arrives before `setAccessible` is called (unlikely but technically possible during connection setup), the field value is indeterminate.

**Fix:** Add `m_shockCountNotifyEnabled(false)` to the constructor's member-initialiser list.

---

**A06-22** · INFO · `m_digitalInput[4]` is not zero-initialised in the constructor

**Description:** `m_digitalInput[4]` (header line 132) is not initialised in the constructor initialiser list or in the constructor body. The array holds the last-known state of the four digital inputs. Before any BLE read completes, `digitalInput()` will return garbage. On most Qt-embedded targets the heap is zeroed, but this is not a language guarantee.

**Fix:** Initialise the array either as `m_digitalInput{}` in the member-initialiser list or add a `memset` in the constructor body.

---

## Summary Table

| ID | Severity | Title |
|---|---|---|
| A06-1 | HIGH | `descriptorRead` slot implemented but never connected |
| A06-2 | HIGH | `allowShockCountNotify` defined but never called |
| A06-3 | HIGH | `resetInputTimer` and `resetOutput` defined but never called |
| A06-4 | MEDIUM | Commented-out code block in `initRelays` (lines 284–286) |
| A06-5 | MEDIUM | `MAX_SHOCK_COUNT` macro defined but never used |
| A06-6 | MEDIUM | `m_shockMaxMagnitude` written but never read |
| A06-7 | MEDIUM | `AUTH_CODE` is a hardcoded plain-text secret in source |
| A06-8 | MEDIUM | Double-semicolons on relay-correction lines (lines 377, 385) |
| A06-9 | MEDIUM | `RtcTime` uses non-portable GCC `__attribute__((packed))` |
| A06-10 | MEDIUM | `reinterpret_cast` on potentially unaligned BLE byte buffers |
| A06-11 | MEDIUM | `WritePending` bitfield uses signed `int` for 1-bit members |
| A06-12 | LOW | `isShockQueueEmpty` missing `const` qualifier |
| A06-13 | LOW | `BleExpansionUuid` UUID constants not declared `const` |
| A06-14 | LOW | `equals128` lacks size assertion for `quint128` layout |
| A06-15 | LOW | `setRelayOutput` logs debug but does not early-return when inaccessible |
| A06-16 | LOW | `appearance` UUID declared, defined, and never used |
| A06-17 | LOW | `outputD0`–`outputD3` and `openCollector0`–`openCollector3` UUIDs unused |
| A06-18 | INFO | `inputPullUp0`–`inputPullUp3` UUIDs defined but never used |
| A06-19 | INFO | Relay timeout macros lack unit documentation |
| A06-20 | INFO | `m_previousPending` not initialised in constructor initialiser list |
| A06-21 | INFO | `m_shockCountNotifyEnabled` not initialised in constructor initialiser list |
| A06-22 | INFO | `m_digitalInput[4]` not zero-initialised in constructor |
# Pass 4 Agent A07 — Code Quality

**Audit run:** 2026-02-28-01
**Branch:** master
**Files reviewed:**
- `comm/bleinputhandler.h`
- `comm/bleinputhandler.cpp`
- `comm/canexpansion.h`
- `comm/canexpansion.cpp`

---

## Reading Evidence

### comm/bleinputhandler.h

**Class:** `BleInputHandler` (extends `QObject`)

**Enums / Types defined:**
| Name | Values |
|------|--------|
| `DigitalFormat` (public enum) | `SessionFormat`, `UsageFormat`, `OnDemandFormat` |
| `InputState` (private struct) | fields: `bool state`, `quint32 sessionOnTime`, `quint32 sessionOffTime`, `quint32 usageOnTime`, `quint32 usageOffTime`, `quint32 sessionRisings`, `quint32 usageRisings`, `quint64 clock` |

**Methods (all in `BleInputHandler`):**

| Method | Line | Visibility |
|--------|------|------------|
| `BleInputHandler(CanExpansion *canExpansion)` (constructor) | 20 | public |
| `updateIgnition(CIGCONF::PowerState state)` | 22 | public |
| `updateBleInput(CIGCONF::BleExpansionDI input, bool state)` | 23 | public |
| `changeBleState(bool connected)` | 24 | public |
| `updateIdleTimer()` | 26 | public |
| `digitalInputs(DigitalFormat format, bool autoReset)` | 28 | public |
| `idleTimeout()` | 31 | signal |
| `sendGmtpMessage(CIGCONF::GmtpMessage msg, const QByteArray &extra)` | 32 | signal |
| `resetStates()` | 35 | private |
| `onTimerEvent()` | 36 | private |
| `sendSeenSafeReport(bool state)` | 37 | private |

**Member variables:**
- `m_canExpansion` (`CanExpansion *`)
- `m_timer` (`QTimer *`)
- `m_digInputModeTimer` (`QTimer *`)
- `m_ignition` (`InputState`)
- `m_bleInputs[4]` (`InputState`)
- `m_bypassReset` (`bool`)
- `m_bleConnected` (`bool`)
- `m_seenState` (`bool`)
- `m_lastSeenReport` (`quint64`)
- `m_seenSecond` (`bool`)
- `m_seenTimestamp` (`quint32`)

---

### comm/bleinputhandler.cpp

**Functions (all in `BleInputHandler`):**

| Function | Line |
|----------|------|
| `BleInputHandler(CanExpansion *canExpansion)` — constructor | 7 |
| `resetStates()` | 25 |
| `updateIgnition(CIGCONF::PowerState state)` | 40 |
| `onTimerEvent()` | 81 |
| `sendSeenSafeReport(bool state)` | 92 |
| `updateBleInput(CIGCONF::BleExpansionDI input, bool state)` | 115 |
| `changeBleState(bool connected)` | 178 |
| `updateIdleTimer()` | 201 |
| `digitalInputs(DigitalFormat format, bool autoReset)` | 257 |

---

### comm/canexpansion.h

**Class:** `CanExpansion` (extends `QObject`)

**Enums / Types defined:**
| Name | Description |
|------|-------------|
| `ShockEvent` (public struct) | fields: `quint32 timestamp`, `quint32 magnitude`, `quint64 driverId`, `quint8 satelliteCount`, `quint32 lastLongitude`, `quint32 lastLatitude`, `quint16 speed`, `quint32 sumOfDistance`, `quint16 course`, `quint32 longitude`, `quint32 latitude`, `quint32 distance`, `bool isIgnitionOn` |

**Methods:**

| Method | Line | Visibility |
|--------|------|------------|
| `CanExpansion(EM070::CanBus *canBus, EM070::PowerSupply *ps)` (constructor) | 42 | public |
| `setEnabled(bool enable)` | 44 | public |
| `deviceName() const` | 46 | public inline |
| `bleVersion() const` | 47 | public inline |
| `mainVersion() const` | 48 | public inline |
| `manufacture() const` | 49 | public inline |
| `modelNumber() const` | 50 | public inline |
| `relayOutput(CIGCONF::BleExpansionRelay relay) const` | 52 | public inline |
| `setRelayOutput(CIGCONF::BleExpansionRelay relay, bool state)` | 55 | public |
| `relayTimeout(CIGCONF::BleExpansionRelay relay) const` | 57 | public inline |
| `setRelayTimeout(CIGCONF::BleExpansionRelay relay, quint16 timeout_in_sec)` | 60 | public |
| `setCurrentTime(quint32 time)` | 62 | public |
| `digitalInput(CIGCONF::BleExpansionDI di) const` | 64 | public inline |
| `setShockThreshold(quint32 threshold)` | 66 | public |
| `setShockPeriod(quint32 period)` | 67 | public |
| `isShockQueueEmpty()` | 69 | public inline |
| `shockEvent()` | 70 | public inline |
| `generateShockMessage(bool force)` | 72 | public |
| `setGnssReceiver(EM070::GnssReceiver* gnss)` | 74 | public |
| `inputStateChanged(CIGCONF::BleExpansionDI input, bool state)` | 77 | signal |
| `shockOccurred()` | 78 | signal |
| `amberImpactOccurred()` | 79 | signal |
| `redImpactOccurred()` | 80 | signal |
| `accessible(bool yes)` | 81 | signal |
| `expModInfo(QByteArray mainVersion)` | 82 | signal |
| `inactiveNotification(bool inactive, quint32 secs)` | 83 | signal |
| `relayStateChanged(bool relay1, bool relay2)` | 84 | signal |
| `initialise()` | 87 | private |
| `updateBusConfig()` | 88 | private |
| `readCanFrame(quint32 id, const QByteArray &ba)` | 89 | private |
| `packetHandler()` | 90 | private |
| `writeFrame()` | 91 | private |
| `timeout()` | 92 | private |
| `sendPacket(uint16_t cmd, const QByteArray &ba)` | 94 | private |
| `initRelays()` | 96 | private |
| `clearShockEvent()` | 97 | private |
| `popShockEvent(const QByteArray &ba)` | 98 | private |

**Member variables:**
- `m_canBus` (`EM070::CanBus *`)
- `m_powerSupply` (`EM070::PowerSupply *`)
- `m_gnssReceiver` (`EM070::GnssReceiver *`)
- `m_timer` (`QTimer *`)
- `m_initTimer` (`QTimer *`)
- `m_rx` (`QByteArray`)
- `m_tx` (`QByteArray`)
- `m_active` (`bool`)
- `m_lastActive` (`bool`)
- `m_inactiveCount` (`quint32`)
- `m_deviceName` (`QByteArray`)
- `m_bleVersion` (`QByteArray`)
- `m_mainVersion` (`QByteArray`)
- `m_manufacture` (`QByteArray`)
- `m_modelNumber` (`QByteArray`)
- `m_digitalInput[4]` (`bool`) — **declared but never written in canexpansion.cpp**
- `m_outputRelay[2]` (`bool`)
- `m_outputRelayTimeout[2]` (`quint16`)
- `m_shockThreshold` (`quint32`)
- `m_shockPeriod` (`quint32`)
- `m_redImpactCounter` (`qint32`)
- `m_shockTimestamp` (`quint32`)
- `m_shockEvent1` (`ShockEvent`)
- `m_shockEvents` (`QQueue<ShockEvent>`)

**Constants defined (canexpansion.cpp, file-scope `#define`):**

| Macro | Value | Comment |
|-------|-------|---------|
| `CMD_DEVICE_NAME` | 1001 | |
| `CMD_BLE_FWVER` | 8 | |
| `CMD_MAIN_FWVER` | 10 | |
| `CMD_MFR_NAME` | 1002 | |
| `CMD_MODEL_NUMBER` | 1003 | |
| `CMD_RTC_TIME` | 26 | |
| `CMD_DIGIN_STATE0..3` | 31,35,39,43 | |
| `CMD_RELAY_RESET` | 48 | |
| `CMD_RELAY_STATE0/1` | 50,54 | |
| `CMD_RELAY_TIMEOUT0/1` | 52,56 | |
| `CMD_SHOCK_COUNT` | 75 | |
| `CMD_SHOCK_PEEK` | 78 | |
| `CMD_SHOCK_POP` | 80 | |
| `CMD_SHOCK_THRESHOLD` | 82 | |
| `CMD_SHOCK_PERIOD` | 84 | |
| `CMD_SHOCK_MAGMAX` | 86 | |
| `CMD_SHOCK_NOTIFY` | 1004 | |
| `UPDATE_DEFER` | 500 | |
| `MAX_BUFFER_SIZE` | 256 | |
| `MK3_ID` | 0x3C1 | |
| `SLIP_END/ESC/ESC_END/ESC_ESC` | 0xC0,0xDB,0xDC,0xDD | |
| `FROM_MK3_HEADER` | 0x01 | |
| `TO_MK3_HEADER` | 0x81 | |
| `CMD_WRITE_FLAG` | 0x8000 | |
| `REDIMPACT_SHOCKMSG_TIME` | 3 | |
| `REDIMPACT_COUNTER_OFF` | -1 | |
| `TIMER` | 2000 | |
| `INACTIVE_TIME` | 2 | |

---

## Findings

---

**A07-1** · HIGH · Dead member: `m_digitalInput[4]` declared in `CanExpansion` but never written

**Description:** `canexpansion.h` line 119 declares `bool m_digitalInput[4]` and line 64 exposes a `digitalInput()` accessor. However, `canexpansion.cpp` never writes to `m_digitalInput` — the digital-input state is emitted only via the `inputStateChanged` signal and is tracked inside `BleInputHandler`. The accessor therefore always returns the zero-initialised value (`false`). Any caller that uses `CanExpansion::digitalInput()` receives stale, permanently-false data. (Contrast with `bleexpansion.h/.cpp`, which maintains its own identical member and does write to it correctly.)

**Fix:** Either populate `m_digitalInput[index]` when `inputStateChanged` is emitted inside `packetHandler()`, or remove the member and the `digitalInput()` accessor from the public API and update any callers to use the signal instead.

---

**A07-2** · HIGH · Static local state in `readCanFrame` and `packetHandler` breaks re-entrancy and testability

**Description:**
- `readCanFrame()` (canexpansion.cpp line 130): `static bool esc = false;` persists across calls. If the CAN bus is reset or `CanExpansion` is destroyed and recreated, the escape-flag is never cleared, so the next SLIP stream may be decoded incorrectly.
- `packetHandler()` (canexpansion.cpp line 251–252): `static quint16 sm = 0; static quint16 shocks_read = 0;` are the sole state-machine registers for the init handshake and shock-drain loop. Because they are function-local statics they are shared across all instances and survive object destruction. In a single-instance embedded target this is unlikely to cause a runtime fault, but it is architecturally broken: unit tests cannot reset the state machine, and a second `CanExpansion` instance would corrupt the first's handshake.

**Fix:** Promote `esc`, `sm`, and `shocks_read` to private member variables of `CanExpansion` (initialised in the constructor). Add their reset to any `setEnabled(false)` / re-initialisation path.

---

**A07-3** · MEDIUM · Commented-out code left in production sources

**Description:**
- `canexpansion.h` line 118: `//quint32     m_shockMaxMagnitude;` — commented-out member declaration.
- `canexpansion.cpp` line 234: `//SerialLogger::log(QString("[%1 " + m_canBus->canBusDevice()->errorString() + "]\r\n").arg(m_canBus->canBusDevice()->framesToWrite()).toLatin1());` — entire debug-logging line inside `writeFrame()`.
- `canexpansion.cpp` line 123: `//if (m_busConfig.enabled)` — a guard expression replaced by `if (enabled)` on the very next line; the old version is still present.

**Fix:** Delete all three commented-out lines. If `m_shockMaxMagnitude` is genuinely unused it should be removed entirely; if it will be needed it should be tracked in a TODO/issue rather than left as dead markup in the header.

---

**A07-4** · MEDIUM · `qDebug()` statement left in production code

**Description:** `canexpansion.cpp` line 659:
```cpp
qDebug() << "EXPMOD Shock" << event.timestamp << event.magnitude;
```
This is inside `popShockEvent()`, which executes on every shock detection. `qDebug()` output is compiled in by default in release builds unless `QT_NO_DEBUG_OUTPUT` is explicitly defined, leaking internal telemetry data to any connected debug console and adding unnecessary overhead on the target hardware.

**Fix:** Remove the `qDebug()` line. The `SerialLogger::log()` call on the line immediately below provides sufficient structured diagnostic output through the controlled logging subsystem.

---

**A07-5** · MEDIUM · Mixed integer type for `sendPacket` command parameter (`uint16_t` vs `quint16`)

**Description:** The private declaration of `sendPacket` in `canexpansion.h` line 94 uses the raw C type `uint16_t`:
```cpp
void sendPacket(uint16_t cmd, const QByteArray &ba);
```
Every other integer in both files uses Qt's portable types (`quint16`, `quint32`, etc.). The rest of the codebase is consistent in using Qt types. This inconsistency is exacerbated by the fact that `sendPacket` is called with expressions such as `CMD_RELAY_STATE0 | CMD_WRITE_FLAG`, where `CMD_WRITE_FLAG` is defined as `0x8000` (an `int` macro), causing the result to be implicitly narrowed through a mixed-type OR before being passed.

**Fix:** Change the parameter type to `quint16` to match the rest of the file. If the OR-with-`CMD_WRITE_FLAG` pattern is intentional (setting the high bit to indicate a write), replace the raw `int` macro with a typed constant (`static const quint16 CMD_WRITE_FLAG = 0x8000;`) to make the narrowing explicit.

---

**A07-6** · MEDIUM · `updateBleInput` does not bounds-check the `input` index

**Description:** `bleinputhandler.cpp` line 117:
```cpp
int index = input - CIGCONF::BleExpDI1;
InputState &is = m_bleInputs[index];
```
`CIGCONF::BleExpansionDI` is an unscoped enum starting at `BleExpDI1 = 0`. If `input` is ever passed a value outside `[BleExpDI1, BleExpDI4]` (e.g., from a future enum extension or a programming error in a caller), `index` will be negative or >= 4 and the array access will be out-of-bounds with undefined behaviour. The same unchecked arithmetic appears in `canexpansion.h` line 64 (`digitalInput()`).

**Fix:** Add a bounds assertion or early-return guard:
```cpp
int index = input - CIGCONF::BleExpDI1;
if (index < 0 || index >= 4) return;
```
Alternatively use `Q_ASSERT` for debug builds.

---

**A07-7** · MEDIUM · Empty `switch` cases in `packetHandler` with no documentation

**Description:** `canexpansion.cpp` lines 330–465 contain nine `case` labels (`CMD_RELAY_RESET`, `CMD_RELAY_STATE0`, `CMD_RELAY_STATE1`, `CMD_RELAY_TIMEOUT0`, `CMD_RELAY_TIMEOUT1`, `CMD_RTC_TIME`, `CMD_SHOCK_THRESHOLD`, `CMD_SHOCK_PERIOD`, `CMD_SHOCK_MAGMAX`, `CMD_SHOCK_NOTIFY`) that have empty bodies with no comment. It is impossible to determine whether these are intentional no-ops (acknowledgement frames where no action is required), planned future work, or overlooked implementations. This ambiguity is a maintenance hazard.

**Fix:** Add a brief comment to each empty case explaining the intent, for example:
```cpp
case CMD_RTC_TIME:
    // Write-only; no response payload expected.
    break;
```

---

**A07-8** · LOW · Inconsistent `relayOutput` / `relayTimeout` accessor guard logic

**Description:** `canexpansion.h` lines 52–59:
```cpp
bool relayOutput(CIGCONF::BleExpansionRelay relay) const {
    return (relay == CIGCONF::BleExpRelay2 ? m_outputRelay[1] : m_outputRelay[0]);
}
quint16 relayTimeout(CIGCONF::BleExpansionRelay relay) const {
    return (relay == CIGCONF::BleExpRelay2 ? m_outputRelayTimeout[1] : m_outputRelayTimeout[0]);
}
```
Both accessors use a ternary where any value that is not `BleExpRelay2` silently maps to relay 1. An invalid relay enum value would return relay-1 data rather than triggering a diagnostic. This is the same structural problem as A07-6. The `BleExpansionRelay` enum has exactly two values so it is low severity today, but the silent-fallback pattern is fragile.

**Fix:** Replace the ternary with an explicit index calculation (`relay - CIGCONF::BleExpRelay1`) and add an assertion, or use a switch with a default that asserts/returns a sentinel.

---

**A07-9** · LOW · `updateIdleTimer()` is `public` but is an implementation detail

**Description:** `bleinputhandler.h` line 26: `updateIdleTimer()` is declared `public`. Inspecting the call sites, `updateIdleTimer()` is only called from `resetStates()` (an internal method) and indirectly from the constructor. It is exposed publicly with no documented reason. Callers outside the class that invoke it at the wrong time could corrupt the idle-timer state.

**Fix:** Move `updateIdleTimer()` to the `private` section unless there is a documented external caller that requires it.

---

**A07-10** · LOW · `bool on = (state == CIGCONF::NormalPowerState) ? true : false;` — redundant ternary

**Description:** `bleinputhandler.cpp` line 42:
```cpp
bool on = (state == CIGCONF::NormalPowerState) ? true : false;
```
The comparison expression already yields a `bool`. The `? true : false` suffix is redundant and a common style warning in static analysis tools.

**Fix:** Simplify to:
```cpp
bool on = (state == CIGCONF::NormalPowerState);
```

---

**A07-11** · LOW · Trailing whitespace and brace/formatting inconsistencies

**Description:**
- `canexpansion.cpp` line 232: `void CanExpansion::writeFrame()` — the opening brace is on the same line as the first variable declaration (`{   int len;`), which is unique in the file and inconsistent with every other function definition.
- `canexpansion.cpp` line 147: trailing whitespace after `packetHandler();` inside `readCanFrame`.
- `canexpansion.cpp` line 525: trailing whitespace after the closing brace of `initRelays()`.
- `bleinputhandler.cpp` line 142: trailing whitespace after `m_digInputModeTimer->start(...)`.
- `bleinputhandler.cpp` line 289: trailing whitespace before the blank line inside `digitalInputs()`.

These are minor but indicate the files have not been passed through a consistent formatter.

**Fix:** Run `clang-format` (or the project's chosen formatter) over both files and configure the CI pipeline to enforce formatting on commit.

---

**A07-12** · LOW · `QTimer` forward-declared in `canexpansion.h` but also `#include <QTimer>` present

**Description:** `canexpansion.h` line 19 contains a forward declaration `class QTimer;`, but line 11 already `#include <QTimer>`. The forward declaration is therefore redundant. (`bleinputhandler.h` has the same pattern: forward-declares `QTimer` at line 12 despite not including the header — that usage is correct as a forward declaration only, but should be verified against Qt's inclusion requirements for inline use.)

**Fix:** Remove the redundant `class QTimer;` forward declaration from `canexpansion.h` since the full header is already included. In `bleinputhandler.h` the forward declaration is appropriate (the type is only used as a pointer), so it should be retained.

---

**A07-13** · INFO · Magic number `500` used directly in `initialise()`

**Description:** `canexpansion.cpp` line 94: `m_timer->start(500);`. The constant `TIMER` is defined as `2000` on line 58, and `UPDATE_DEFER` as `500` on line 40. The poll interval for the main 2-second cycle is started with the literal `500` rather than a named constant. While `UPDATE_DEFER` happens to have the same value, using the literal hides the intent (is this 500 ms by coincidence or by design to match `UPDATE_DEFER`?).

**Fix:** If the 500 ms poll interval is intentional and independent of `UPDATE_DEFER`, define a separate named constant (e.g., `POLL_INTERVAL 500`). If it is the same concept, replace the literal with `UPDATE_DEFER`.

---

## Summary Table

| ID | Severity | Title |
|----|----------|-------|
| A07-1 | HIGH | Dead member `m_digitalInput[4]` declared but never written in `CanExpansion` |
| A07-2 | HIGH | Static local variables in `readCanFrame` / `packetHandler` break re-entrancy |
| A07-3 | MEDIUM | Commented-out code left in production sources (3 sites) |
| A07-4 | MEDIUM | `qDebug()` statement left in production `popShockEvent()` |
| A07-5 | MEDIUM | Mixed `uint16_t` / `quint16` type for `sendPacket` command parameter |
| A07-6 | MEDIUM | `updateBleInput` array index not bounds-checked |
| A07-7 | MEDIUM | Nine empty `switch` cases in `packetHandler` with no explanatory comment |
| A07-8 | LOW | Accessor ternary silently maps invalid relay enum to relay 1 |
| A07-9 | LOW | `updateIdleTimer()` is public but is an internal implementation detail |
| A07-10 | LOW | Redundant `? true : false` ternary in `updateIgnition` |
| A07-11 | LOW | Trailing whitespace and brace-placement inconsistencies |
| A07-12 | LOW | Redundant `class QTimer` forward declaration in `canexpansion.h` |
| A07-13 | INFO | Magic literal `500` in `initialise()` should be a named constant |
# Pass 4 Agent A08 — Code Quality

**Audit run:** 2026-02-28-01
**Branch:** master
**Files reviewed:**
- `comm/canmonitor.h`
- `comm/canmonitor.cpp`
- `comm/canstatehandler.h`
- `comm/canstatehandler.cpp`

---

## 1. Reading Evidence

### 1.1 `comm/canmonitor.h`

**Class:** `CanMonitor` (inherits `QObject`)

| Function / Method | Line |
|---|---|
| `CanMonitor(EM070::CanBus *canBus)` (constructor) | 20 |
| `readCanConfig()` | 22 |
| `readOldCanConfig()` | 23 |
| `saveCanConfig()` | 24 |
| `calculateCanCrc()` | 25 |
| `canCrc32() const` (inline) | 28 |
| `setEnabled(bool enable)` | 30 |
| `clearCanConfig()` | 32 |
| `canBusConfig() const` | 33 |
| `setCanBusConfig(const QByteArray &config)` | 34 |
| `canPgnConfig() const` | 35 |
| `setCanPgnConfig(const QByteArray &config)` | 36 |
| `canSpnConfig() const` | 37 |
| `setCanSpnConfig(const QByteArray &config)` | 38 |
| `canAttConfig() const` | 39 |
| `setCanAttConfig(const QByteArray &config)` | 40 |
| `canLinConfig() const` | 41 |
| `setCanLinConfig(const QByteArray &config)` | 42 |
| `canBydConfig() const` | 43 |
| `setCanBydConfig(const QByteArray &config)` | 44 |
| `canLin2Config() const` | 45 |
| `setCanLin2Config(const QByteArray &config)` | 46 |
| `isXferEnabled() const` (inline) | 48 |
| `attributeName(quint8 index) const` (inline) | 49 |
| `attributeType(quint8 index) const` (inline) | 50 |
| `setVdiAccess(bool access, bool inhibit)` | 52 |
| `enableVdi(bool enable)` | 53 |
| **signals:** `resetCanStates(bool resetLast)` | 60 |
| **signals:** `stateUpdated(quint8 index, quint32 state)` | 61 |
| `isValidPgnConfig(const PgnConfig &config) const` (inline private) | 108 |
| `isValidSpnConfig(const SpnConfig &config) const` (inline private) | 109 |
| `isValidAttribute(const AttConfig &config) const` (inline private) | 110 |
| `childSpnIndexes(quint8 pgnIndex) const` | 111 |
| `findPgnIndex(quint32 rspId, quint32 reqId = 0) const` | 112 |
| `newPgnIndex() const` | 113 |
| `attributePollingRate(quint32 namePattern) const` | 114 |
| `createRequest(quint8 spnIndex, quint32 pollingRate)` | 115 |
| `updateBusConfig()` | 117 |
| `updateRequests()` | 118 |
| `readCanFrame(quint32 id, const QByteArray &ba)` | 120 |
| `updateState(quint8 spnIndex, quint64 data)` | 121 |
| `updateSpnState(quint8 spnIndex, quint64 data)` | 122 |
| `initVdi()` | 124 |
| `configureVdiAccessRequest()` | 125 |
| `perfTimer()` | 147 |

**Private structs defined in header:**

| Struct | Lines |
|---|---|
| `BusConfig` | 64–69 |
| `PgnConfig` | 71–79 |
| `SpnConfig` | 81–92 |
| `AttConfig` | 94–106 |

**Private data members:**

| Member | Type |
|---|---|
| `m_canBus` | `EM070::CanBus *` |
| `m_timer` | `QTimer *` |
| `m_file` | `QFile` |
| `m_canCrc32` | `quint32` |
| `m_enabled` | `bool` |
| `m_busConfig` | `BusConfig` |
| `m_pgnConfigs[CAN_MAX_PGN_IDX]` | `PgnConfig[]` |
| `m_spnConfigs[CAN_MAX_SPN_IDX]` | `SpnConfig[]` |
| `m_attConfigs[CAN_MAX_ATT_IDX]` | `AttConfig[]` |
| `m_attrToSpn` | `QMap<quint8, quint8>` |
| `m_spnState[CAN_MAX_SPN_IDX]` | `quint32[]` |
| `m_perfCounter` | `quint32` |
| `m_perfTimer` | `QTimer *` |
| `m_vdiAccess` | `bool` |
| `m_vdiInhibit` | `bool` |

---

### 1.2 `comm/canmonitor.cpp`

**File-scope structs (migration helpers):**

| Struct | Lines | Purpose |
|---|---|---|
| `SpnConfig0` | 53–61 | Original `cancfg.dat` SPN layout (quint16 spn) |
| `SpnConfig1` | 64–72 | Version 1 `cancfgnew.dat` SPN layout (quint32 spn) |

**File-scope `#define` macros:**

| Macro | Line | Value |
|---|---|---|
| `PERF_MON` | 13 | `0` |
| `CAN_CONF_FILE_OLD` | 15 | `"cancfg.dat"` |
| `CAN_CONF_FILE` | 16 | `"cancfgnew.dat"` |
| `RULE_SEAT_U/L` | 18–19 | `LE_INT` patterns |
| `RULE_TRAC_U/L` | 20–21 | `LE_INT` patterns |
| `RULE_HYDR_U/L` | 22–23 | `LE_INT` patterns |
| `RULE_HYDL_U/L` | 24–25 | `LE_INT` patterns |
| `RULE_HRS_U/L` | 26–27 | `LE_INT` patterns |
| `RULE_BACD_U/L` | 28–29 | `LE_INT` patterns |
| `RULE_BLAN_U/L` | 30–31 | `LE_INT` patterns |
| `RULE_SEAT_RATE` | 33 | `(2 * 1000)` |
| `RULE_TRAC_RATE` | 34 | `(2 * 1000)` |
| `RULE_HYDR_RATE` | 35 | `(2 * 1000)` |
| `RULE_HYDL_RATE` | 36 | `(2 * 1000)` |
| `RULE_BLAN_RATE` | 37 | `(2 * 1000)` |
| `RULE_HRS_RATE` | 38 | `(1*60*1000)` |
| `RULE_BACD_RATE` | 39 | `(1*60*1000)` |
| `LIN_CANID_OFFSET` | 41 | `0x10` |
| `LIN_ADDR_OFFSET` | 42 | `0x4000` |
| `BYD_CANID_XOR` | 44 | `0x380` |
| `BYD_ADDR_OFFSET` | 45 | `0x0B000000` |
| `UPDATE_DEFER` | 47 | `3000` |

**Functions defined in canmonitor.cpp:**

| Function | Line |
|---|---|
| `CanMonitor::CanMonitor(CanBus *canbus)` | 74 |
| `CanMonitor::perfTimer()` | 101 |
| `CanMonitor::readCanConfig()` | 107 |
| `CanMonitor::readOldCanConfig()` | 209 |
| `CanMonitor::saveCanConfig()` | 265 |
| `CanMonitor::setEnabled(bool enable)` | 295 |
| `CanMonitor::calculateCanCrc()` | 310 |
| `CanMonitor::findPgnIndex(quint32 rspId, quint32 reqId) const` | 418 |
| `CanMonitor::newPgnIndex() const` | 437 |
| `CanMonitor::childSpnIndexes(quint8 pgnIndex) const` | 447 |
| `CanMonitor::clearCanConfig()` | 469 |
| `CanMonitor::canBusConfig() const` | 488 |
| `CanMonitor::setCanBusConfig(const QByteArray &config)` | 498 |
| `CanMonitor::canPgnConfig() const` | 531 |
| `CanMonitor::setCanPgnConfig(const QByteArray &config)` | 566 |
| `CanMonitor::canSpnConfig() const` | 615 |
| `CanMonitor::setCanSpnConfig(const QByteArray &config)` | 642 |
| `CanMonitor::canAttConfig() const` | 705 |
| `CanMonitor::setCanAttConfig(const QByteArray &config)` | 752 |
| `CanMonitor::canLinConfig() const` | 828 |
| `CanMonitor::setCanLinConfig(const QByteArray &config)` | 857 |
| `CanMonitor::canBydConfig() const` | 947 |
| `CanMonitor::setCanBydConfig(const QByteArray &config)` | 976 |
| `CanMonitor::canLin2Config() const` | 1064 |
| `CanMonitor::setCanLin2Config(const QByteArray &config)` | 1097 |
| `CanMonitor::attributePollingRate(quint32 namePattern) const` | 1193 |
| `CanMonitor::createRequest(quint8 spnIndex, quint32 pollingRate)` | 1231 |
| `CanMonitor::updateBusConfig()` | 1301 |
| `CanMonitor::updateRequests()` | 1313 |
| `CanMonitor::readCanFrame(quint32 id, const QByteArray &ba)` | 1369 |
| `CanMonitor::updateState(quint8 spnIndex, quint64 data)` | 1474 |
| `CanMonitor::updateSpnState(quint8 spnIndex, quint64 data)` | 1526 |
| `CanMonitor::initVdi()` | 1600 |
| `CanMonitor::setVdiAccess(bool access, bool inhibit)` | 1616 |
| `CanMonitor::configureVdiAccessRequest()` | 1627 |
| `CanMonitor::enableVdi(bool enable)` | 1648 |

---

### 1.3 `comm/canstatehandler.h`

**Class:** `CanStateHandler` (inherits `QObject`)

**Enum defined:**

| Enum | Values | Line |
|---|---|---|
| `DigitalFormat` | `SessionFormat`, `UsageFormat`, `OnDemandFormat` | 14 |

**Methods:**

| Function / Method | Line |
|---|---|
| `CanStateHandler(CanMonitor *canMonitor)` (constructor) | 16 |
| `updateIdleTimer()` | 17 |
| `canStates(DigitalFormat format, bool autoReset)` | 18 |
| `resetStates(bool resetLast)` | 19 |
| **signals:** `idleTimeout()` | 22 |
| `updateState(quint8 index, quint32 state)` (private) | 45 |

**Private struct defined in header:**

| Struct | Lines |
|---|---|
| `CanState` | 25–43 |

**Private data members:**

| Member | Type |
|---|---|
| `m_canStates[CAN_MAX_ATT_IDX]` | `CanState[]` |
| `m_canMonitor` | `CanMonitor *` |
| `m_timer` | `QTimer *` |

---

### 1.4 `comm/canstatehandler.cpp`

**Functions defined:**

| Function | Line |
|---|---|
| `CanStateHandler::CanStateHandler(CanMonitor *monitor)` | 14 |
| `CanStateHandler::updateState(quint8 index, quint32 state)` | 24 |
| `CanStateHandler::resetStates(bool resetLast)` | 73 |
| `CanStateHandler::updateIdleTimer()` | 91 |
| `CanStateHandler::canStates(DigitalFormat format, bool autoReset)` | 117 |

---

## 2. Findings

---

**A08-1** · MEDIUM · Large block of commented-out debug code inside `calculateCanCrc()`

**Description:** Lines 312–336 of `canmonitor.cpp` contain a commented-out struct definition and seven commented-out `memcpy`/`SerialLogger` lines inside the `calculateCanCrc()` function body. These were apparently left over from a debugging session that explored an alternative CRC computation strategy. The volume of dead comment noise obscures the active code path and makes the function difficult to read at a glance.

```cpp
// canmonitor.cpp lines 312–336
        /*struct {
            BusConfig busConfig;
            ...
        } config;*/

        //memset(&config, 0, sizeof(config));
        //memcpy(&config.busConfig, ...);
        ...
        //m_canCrc32 = GlobalConfigs::crc32(&config, sizeof(config));
```

**Fix:** Delete all commented-out code between lines 312 and 336. If the alternative code path is ever needed, version control history preserves it.

---

**A08-2** · LOW · Commented-out code in `setEnabled()` and `updateState()`

**Description:**
- `canmonitor.cpp` line 304: `//emit resetCanStates();` — a signal emission is silenced inside `setEnabled()`.
- `canmonitor.cpp` line 1476: `//qDebug() << "updateState(..."` — diagnostic log left commented out.
- `canmonitor.cpp` line 1528: `//qDebug() << "updateSpnState(..."` — same pattern.

These are individually minor but create confusion about whether the emit on line 304 was intentionally removed or accidentally silenced.

**Fix:** Remove the commented-out `qDebug` lines. For the silenced signal emission, add a code comment explaining the deliberate omission or restore it if it was accidentally removed.

---

**A08-3** · LOW · Commented-out code in `canstatehandler.cpp` (`memset` call, line 80)

**Description:** `canstatehandler.cpp` line 80 contains `//memset(m_canStates, 0, sizeof(m_canStates));` immediately after the selective-reset loop. The active code was refactored to be selective but the original bulk `memset` was never deleted.

```cpp
// canstatehandler.cpp line 80
    //memset(m_canStates, 0, sizeof(m_canStates));
```

**Fix:** Delete the commented-out line.

---

**A08-4** · MEDIUM · Disabled feature macro `DEPENDS_ON_TRIGGER` left as a comment block

**Description:** `canstatehandler.cpp` lines 8–12 contain a `TODO` comment followed by `//#define DEPENDS_ON_TRIGGER`. The macro is referenced at three more points in the file (lines 30–33, 80–86, 129–135) via `#ifdef`/`#ifndef` guards. The feature is unconditionally disabled at compile time — the disabled path is never compiled — yet the entire conditional framework is retained. This inflates cognitive complexity with code that is always dead in production builds.

**Fix:** Either commit to removing `DEPENDS_ON_TRIGGER` and its guarded blocks, or restore the macro and the TODO to an issue tracker and remove the comment block. Do not leave permanently-disabled conditional compilation blocks in production source.

---

**A08-5** · MEDIUM · Dead `#if 0` block in `updateSpnState()` — unreachable alternative algorithm

**Description:** `canmonitor.cpp` lines 1540–1545 wrap an alternative bit-extraction algorithm in `#if 0`:

```cpp
#if 0
    // LSB first for offset
    spnData = data >> spnConfig.offset;
    spnData &= spnMask;
#else
    // MSB first for offset
    ...
#endif
```

The `#if 0` block will never be compiled. Its presence suggests an experimental change was never cleaned up.

**Fix:** Delete the `#if 0` block and the surrounding `#if 0 / #else / #endif` scaffolding, leaving only the active `#else` branch. The comment "MSB first for offset" should be retained inline.

---

**A08-6** · LOW · Dead `#if 1` block in `clearCanConfig()` — always-active conditional

**Description:** `canmonitor.cpp` lines 478–482 contain:

```cpp
#if 1   // default setting to do
    m_busConfig.protocol = LindeExtended;
    m_busConfig.baudRate = 250000;
    m_busConfig.enabled  = true;
#endif
```

An `#if 1` block is always compiled. The comment "default setting to do" implies this was meant to be temporary. The conditional wrapper is misleading because it implies the block could be disabled.

**Fix:** Remove the `#if 1` / `#endif` wrapper and leave the three assignment statements as unconditional code, or promote the literals to named constants.

---

**A08-7** · MEDIUM · Magic number `64` for idle input source embedded in `updateIdleTimer()`

**Description:** `canstatehandler.cpp` line 99 compares `gCfg->idleInputSource()` against the literal `64`. The comment on lines 93–96 explains the meaning: "64 means input is CAN SEAT state." This is a protocol/specification constant that should be named.

```cpp
if (!gCfg->idleTimeout() || !gCfg->currentDriverId() ||
        gCfg->idleInputSource() != 64) {
```

**Fix:** Define `constexpr int CAN_IDLE_INPUT_SOURCE_SEAT = 64;` (or equivalent) in `cigconfigs.h` and replace the literal.

---

**A08-8** · MEDIUM · Magic numbers for VDI CAN IDs and byte payloads in `updateRequests()` and `configureVdiAccessRequest()`

**Description:** Several raw CAN identifiers and payload bytes appear as bare integer literals with no named constant:

- `canmonitor.cpp` line 1361: `m_canBus->addRequest(0x000, ba, 1000)` — VDI enable node message to ID `0x000`.
- `canmonitor.cpp` lines 1638–1643: payload bytes `0x05`, `0x01`, `0x00` representing access-mode states sent to ID `0x215` (line 1635, also a magic number).
- `canmonitor.cpp` line 1242: `6 << 26 | 234 << 16 | 255 << 8` — J1939 request PGN components with raw field values.

These are protocol-specific constants that are impossible to understand without the specification. Their repetition across encode and decode paths also risks inconsistency if the values ever change.

**Fix:** Define named constants (e.g., `VDI_ENABLE_NODE_ID`, `VDI_ACCESS_REQUEST_ID`, `VDI_ACCESS_INHIBIT_BYTE`, `J1939_REQUEST_PRIORITY`, `J1939_REQUEST_PF`, `J1939_REQUEST_PS`) and replace all occurrences.

---

**A08-9** · MEDIUM · Unreachable `return 0` statement at end of `attributePollingRate()`

**Description:** `canmonitor.cpp` lines 1224–1228:

```cpp
    default:
        return 0;
    }

    return 0;   // <-- unreachable
```

The `switch` covers every path including `default: return 0`. The statement after the closing brace of the switch is never reached. Compilers with `-Wunreachable-code` will warn on this.

**Fix:** Delete the trailing `return 0;` on line 1228.

---

**A08-10** · LOW · Commented-out `RULE_HRS_RATE` and `RULE_BACD_RATE` commented-out alternative values

**Description:** `canmonitor.cpp` lines 38–39:

```cpp
#define RULE_HRS_RATE       (1*60*1000)//(10 * 60 * 1000)
#define RULE_BACD_RATE      (1*60*1000)//(10 * 60 * 1000)
```

The original 10-minute values are retained as inline comments after the active 1-minute values. This implies a recent tuning change where the old value was never cleaned up. The inline comment is adjacent to the macro value in a way that risks misreading the effective value.

**Fix:** Delete the `// (10 * 60 * 1000)` suffixes. If the reasoning for the change is important, record it in a commit message or a separate code comment on the next line.

---

**A08-11** · HIGH · Private wire-protocol structs exposed in public header, creating tight coupling

**Description:** `canmonitor.h` defines four private structs — `BusConfig`, `PgnConfig`, `SpnConfig`, and `AttConfig` — in the `private:` section of the class header. These structs encode the exact on-disk binary layout of the CAN configuration file (field widths, alignment attributes, protocol-specific overlap via unions). Because these struct definitions live in the header, any translation unit that `#include`s `canmonitor.h` is compiled with knowledge of the full binary format.

`canstatehandler.h` similarly declares its private `CanState` struct (with its `time`/`count` union) in the header rather than in an implementation-local file.

This is a leaky abstraction: the internal serialisation layout becomes an implicit part of the public interface. Any change to a struct field (e.g., widening `SpnConfig::spn` from `quint32` to `quint64` in version 2) forces recompilation of every dependent TU even if the public API is unchanged, and risks ABI surprises if the struct is ever passed across a library boundary.

**Fix:** Move `BusConfig`, `PgnConfig`, `SpnConfig`, `AttConfig` (and `CanState`) to an anonymous namespace or a forward-declared private implementation struct (`Pimpl`) inside the `.cpp` files. The public header should expose only opaque handles or typed enumerations. At minimum, document with a prominent comment that these structs are serialised to disk and must not be changed without a format-version bump.

---

**A08-12** · LOW · Naming inconsistency: constructor parameter `canbus` vs. member `m_canBus`

**Description:** In `canmonitor.cpp` line 74, the constructor parameter is spelled `canbus` (lower camel, no separator), while the stored member is `m_canBus` (camel with capital B). The Qt-style convention used throughout the rest of the codebase spells multi-word identifiers with an upper-case word boundary. The constructor parameter should follow the same convention for readability.

**Fix:** Rename the constructor parameter from `canbus` to `canBus` to match the member naming convention.

---

**A08-13** · LOW · Inconsistent brace style for single-statement `if` bodies in `enableVdi()`

**Description:** `canmonitor.cpp` lines 1650–1656:

```cpp
void CanMonitor::enableVdi(bool enable)
{
    if (enable)
    {
        initVdi();
    } else {
        clearCanConfig();
    }
}
```

The `if` body uses Allman style (opening brace on its own line) while the `else` body uses K&R style (opening brace on same line). The rest of the file consistently uses K&R for class methods. This is purely a style inconsistency.

**Fix:** Normalise to K&R style: `if (enable) {` on the same line as the condition.

---

**A08-14** · LOW · Typo in comment: "idenitifer" (twice) and "consistant"

**Description:**
- `canmonitor.h` line 84: `// SPN idenitifer` (should be "identifier").
- `canmonitor.cpp` line 56: `// SPN idenitifer` (same typo in `SpnConfig0`).
- `canmonitor.cpp` line 1020: `// but address 0 is an exception which is consistant` (should be "consistent").

**Fix:** Correct the three spelling errors.

---

**A08-15** · MEDIUM · Signed/unsigned comparison and implicit narrowing in `readCanFrame()` loop index

**Description:** `canmonitor.cpp` lines 1375–1385:

```cpp
int pgnIndex;
for (pgnIndex = 0; pgnIndex < CAN_MAX_PGN_IDX; ++pgnIndex) {
```

`pgnIndex` is declared as `int` (signed), but `CAN_MAX_PGN_IDX` is a preprocessor integer constant (effectively `int`-typed in this context). Immediately after the loop, the same `pgnIndex` (now possibly equal to `CAN_MAX_PGN_IDX`) is compared with `CAN_MAX_PGN_IDX` and then used to index `m_pgnConfigs[]` (line 1377), which accepts `int`. However, in `childSpnIndexes()` and related helpers the index type is `quint8`, and `findPgnIndex()` returns `quint8`. The inconsistency — some helpers return/accept `quint8` and some use `int` — means index values are silently narrowed at call sites. With `CAN_MAX_PGN_IDX = 10` and `CAN_MAX_SPN_IDX = 20` the narrowing is safe today, but this is fragile.

**Fix:** Standardise on a single index type for all PGN/SPN index variables. Using `int` for loop variables and explicit `static_cast<quint8>` at boundaries is acceptable; the important fix is consistency. Consider a `using PgnIndex = quint8;` type alias to make intent explicit.

---

**A08-16** · LOW · `qDebug()` left active in hot receive path (`updateState()`, line 1522)

**Description:** `canmonitor.cpp` line 1522:

```cpp
qDebug() << "CAN Name/State:" << attr.name << attState;
```

This `qDebug()` call is in the `updateState()` method that is invoked on every received CAN frame that triggers an attribute change. In a production build without `QT_NO_DEBUG_OUTPUT`, this will emit to stderr (or a debug sink) on every state change, potentially flooding logs and degrading performance. The companion lines at 1476 and 1528 were at least commented out; this one was not.

**Fix:** Either wrap the call in `#ifdef QT_DEBUG` or remove it. If it is intentionally left for field diagnosis, route it through `SerialLogger` (already used elsewhere in this file) so it can be gated by a runtime flag.

---

## 3. Summary Table

| ID | Severity | Title |
|---|---|---|
| A08-1 | MEDIUM | Large commented-out struct and memcpy block in `calculateCanCrc()` |
| A08-2 | LOW | Commented-out signal emit and qDebug lines in `setEnabled()`/`updateState()` |
| A08-3 | LOW | Commented-out bulk `memset` in `resetStates()` |
| A08-4 | MEDIUM | Permanently-disabled `DEPENDS_ON_TRIGGER` conditional compilation |
| A08-5 | MEDIUM | Dead `#if 0` alternative algorithm in `updateSpnState()` |
| A08-6 | LOW | Misleading `#if 1` wrapper in `clearCanConfig()` |
| A08-7 | MEDIUM | Magic number `64` for CAN SEAT idle-input source |
| A08-8 | MEDIUM | Magic numbers for VDI CAN IDs and J1939 request frame components |
| A08-9 | MEDIUM | Unreachable `return 0` after switch in `attributePollingRate()` |
| A08-10 | LOW | Commented-out alternative rate values inline on `#define` lines |
| A08-11 | HIGH | Private wire-protocol structs exposed in public headers (leaky abstraction) |
| A08-12 | LOW | Naming inconsistency: constructor parameter `canbus` vs member `m_canBus` |
| A08-13 | LOW | Inconsistent brace style in `enableVdi()` |
| A08-14 | LOW | Typos in comments: "idenitifer" and "consistant" |
| A08-15 | MEDIUM | Signed/unsigned index-type inconsistency across PGN/SPN helpers |
| A08-16 | LOW | Active `qDebug()` in hot CAN-frame receive path (`updateState()`) |

**Totals:** 1 HIGH, 6 MEDIUM, 9 LOW
# Pass 4 Agent A09 — Code Quality

**Audit run:** 2026-02-28-01
**Branch:** master
**Reviewer:** Pass 4 Agent A09
**Files reviewed:**
- `comm/ftpclient.h`
- `comm/ftpclient.cpp`
- `comm/gmtpchat.h`
- `comm/gmtpchat.cpp`

---

## Reading Evidence

### `comm/ftpclient.h`

**Class:** `FtpClient` (extends `QObject`)

**Public methods:**

| Line | Signature |
|------|-----------|
| 17 | `explicit FtpClient(BackgroundWorker *parent)` |
| 18 | `void download(const QUrl &url)` |
| 19 | `void startTransfer()` |
| 21 | `void writeQueue()` |
| 22 | `void readQueue()` |
| 24 | `void setPowerState(CIGCONF::PowerState state)` |

**Signals:**

| Line | Signature |
|------|-----------|
| 27 | `void fileUpdated(const QString &fileName)` |
| 28 | `void sendGmtpMessage(CIGCONF::GmtpMessage msg, const QByteArray &extra)` |
| 29 | `void nextTransfer()` |

**Private methods:**

| Line | Signature |
|------|-----------|
| 32 | `void readData()` |
| 33 | `void downloadFinished()` |
| 34 | `void setReport(CIGCONF::FtpErrorCode errorCode)` |
| 35 | `void popQueue()` |

**Private members:**

| Line | Name | Type |
|------|------|------|
| 37 | `m_worker` | `BackgroundWorker *` |
| 38 | `m_manager` | `QNetworkAccessManager *` |
| 39 | `m_url` | `QUrl` |
| 40 | `m_file` | `QSaveFile` |
| 41 | `m_fileSize` | `quint32` |
| 43 | `m_transferInProgress` | `bool` |
| 45 | `m_queue` | `QQueue<QUrl>` |
| 46 | `m_retries` | `quint32` |
| 47 | `m_queueFile` | `bool` |
| 48 | `m_powerState` | `CIGCONF::PowerState` |

**Types / constants defined in `ftpclient.cpp`:**

| Line | Name | Value |
|------|------|-------|
| 14 | `MAX_FILE_SIZE` | `16 * 1024 * 1024` (16 MiB) |
| 15 | `FTP_QUEUE_FILE` | `"/home/ftpqueue.txt"` |
| 16 | `FTP_RETRIES` | `5` |

---

### `comm/gmtpchat.h`

**Class:** `GmtpChat` (extends `QObject`)

**Enums:**

| Name | Values |
|------|--------|
| `Priority` | `NormalPriority = 0`, `HighPriority = 1` (line 18) |
| `PduType` | `PduId = 1`, `PduData = 2`, `PduIdExt = 3`, `PduDataExt = 4`, `PduAck = 5` (line 19) |

**Public methods:**

| Line | Signature |
|------|-----------|
| 21 | `explicit GmtpChat(ModemChat *parent)` |
| 22 | `void setPowerState(CIGCONF::PowerState state)` |
| 23 | `void connectServer()` |
| 24 | `void sendMessage(const QByteArray &msgData, Priority priority = NormalPriority)` |
| 25 | `void sendAck(quint16 msgId)` |
| 26 | `void clearGMTPMsgQueue()` |
| 27 | `bool sleeping()` (inline) |
| 28 | `void setEthernetState(bool up)` (inline) |
| 29 | `bool acksRemaining()` (inline) |

**Signals:**

| Line | Signature |
|------|-----------|
| 32 | `void cmdReceived(const QByteArray &ba)` |
| 33 | `void socketStateChanged(bool state)` |
| 34 | `void allMessagesSent()` |
| 35 | `void allAcksSent()` |
| 36 | `void gmtpHotStartReconnect()` |
| 37 | `void disconnectSocket()` |

**Private methods:**

| Line | Signature |
|------|-----------|
| 40 | `void readToQueue()` |
| 41 | `void writeQueue(bool recent)` |
| 42 | `void onConnected()` |
| 43 | `void onDisconnected()` |
| 44 | `void reconnectServer()` |
| 45 | `void readSocket()` |
| 46 | `void writeSocket()` |
| 47 | `void bytesWritten(qint64 bytes)` |
| 49 | `QByteArray packedMessage(const QByteArray &msgData, PduType type = PduDataExt, quint16 ackId = 0)` |
| 50 | `void setOnIgnitionOffDisconnect(bool state)` |
| 51 | `void disconnectFromHost()` |

**Private members:**

| Line | Name | Type |
|------|------|------|
| 53 | `m_modemChat` | `ModemChat *` |
| 54 | `m_tcpSocket` | `QTcpSocket *` |
| 55 | `m_socketTimer` | `QTimer *` |
| 56 | `m_uploadTimer` | `QTimer *` |
| 57 | `m_ackTimer` | `QTimer *` |
| 58 | `m_powerState` | `CIGCONF::PowerState` |
| 60 | `m_serverIndex` | `int` |
| 61 | `m_gmtpFileIndexes` | `QList<quint32>` |
| 63 | `m_uploadMessages` | `QQueue<QByteArray>` |
| 64 | `m_recentMessages` | `QQueue<QByteArray>` |
| 65 | `m_ackMessages` | `QQueue<QByteArray>` |
| 67 | `m_sendingMessage` | `QByteArray` |
| 68 | `m_downloadMessage` | `QByteArray` |
| 70 | `m_msgId` | `quint16` |
| 71 | `m_ackId` | `quint16` |
| 72 | `m_retryCount` | `quint8` |
| 73 | `m_reconnectCount` | `quint8` |
| 74 | `m_idSent` | `bool` |
| 75 | `m_connect` | `bool` |
| 76 | `m_ethState` | `bool` |
| 77 | `m_onIgnitionOffDisconnect` | `bool` |
| 78 | `m_mutexConnectToHost` | `QMutex` |
| 79 | `m_mutexWriteSocket` | `QMutex` |
| 80 | `m_mutexDisconnectFromHost` | `QMutex` |

**Constants defined in `gmtpchat.cpp`:**

| Line | Name | Value |
|------|------|-------|
| 16 | `MAX_MESSAGE_CNT` | `1000` |
| 17 | `MAX_RETRIES` | `3` |
| 18 | `DEF_MSOCKET_TIMEOUT` | `10000` (ms) |
| 19 | `MAX_GMTP_RECONNECT_CNT` | `20` |

---

## Findings

---

**A09-1** · HIGH · `ByteArray::asprintf` re-uses invalidated `va_list`

**Description:** In `utils/bytearray.h` (used extensively in both files), `ByteArray::asprintf` calls `va_start`/`va_end`, then calls `vsprintf` with the same `ap` after `va_end` has already been called on it (the two-pass pattern is broken: `va_end` is called after `vsnprintf` but before `vsprintf`, making the second use of `ap` undefined behaviour per C11 7.16). Every `ByteArray::asprintf(...)` call in `ftpclient.cpp` (lines 71, 89, 96, 206, 208, 259, 275) and `gmtpchat.cpp` (lines 67, 201, 231, 352, 415, 457, 482, 498) is therefore producing undefined behaviour at runtime. This is a latent data-corruption bug that may silently truncate or garble log/GMTP messages.

**Fix:** In `ByteArray::asprintf`, call `va_start` a second time before the `vsprintf` call (add `va_start(ap, cformat)` before `vsprintf` and a matching `va_end(ap)` after it), or rewrite using `QByteArray::asprintf` (Qt 5.5+) which handles this correctly.

---

**A09-2** · HIGH · Large commented-out code blocks leave dead logic in `gmtpchat.cpp`

**Description:** Several substantial blocks of logic have been commented out but left in the source, creating noise and indicating unresolved design decisions:
- Lines 89–106: An entire `if/else` branch for `m_onIgnitionOffDisconnect` hot-start reconnect logic is commented out inside `connectServer()`. The surrounding braces and the `// }` closing markers remain, indicating this was originally a structural else-branch.
- Lines 187–191: The companion power-state guard in `onDisconnected()` is also commented out.
- Lines 136 in `reconnectServer()`: `//m_modemChat->detach();` — a replaced call left as a comment rather than removed.
- Line 97 in `connectServer()`: `//SerialLogger::log(...)` — a debug log line.
- Lines 267, 315, 328, 337 in `gmtpchat.cpp`: Multiple `SerialLogger::log` hex-dump calls commented out.

The `setOnIgnitionOffDisconnect` private method (lines 516–519) and the `m_onIgnitionOffDisconnect` member variable exist solely to support the commented-out logic. They are otherwise dead code.

**Fix:** Either restore the intended logic behind the comment-out and remove the guards, or delete the commented-out blocks, the `setOnIgnitionOffDisconnect` method, and the `m_onIgnitionOffDisconnect` member entirely. Prefer deletion — version control preserves history.

---

**A09-3** · MEDIUM · `writeQueue()` / `readQueue()` are public on `FtpClient` with no documented contract

**Description:** `FtpClient::writeQueue()` and `FtpClient::readQueue()` are declared `public` in the header (lines 21–22). Internally they manipulate the transfer queue and persistence file; calling them externally in the wrong order (e.g., `readQueue()` while a transfer is in progress) would corrupt `m_retries` and the queue state. There is no documented reason for these to be public — inspection of the codebase shows they are only called from within `FtpClient` itself (`startTransfer()` calls `readQueue()`; `setPowerState()` calls `writeQueue()`).

**Fix:** Demote both methods to `private`.

---

**A09-4** · MEDIUM · `FtpClient::startTransfer()` is public but is only ever called via the `nextTransfer` signal

**Description:** `startTransfer()` is declared `public` (line 19) and is connected to `nextTransfer` internally (constructor line 26). No external caller exists in the codebase. Calling it externally while `m_transferInProgress` is true is silently a no-op; calling it from a different thread would be a data race. The method should be private (or a private slot).

**Fix:** Declare `startTransfer()` as a `private` slot (add it under a `private slots:` section or use the `connect` with a lambda).

---

**A09-5** · MEDIUM · `PduType` enum exposed in `GmtpChat` public interface but belongs to internal wire protocol

**Description:** `GmtpChat::PduType` (`PduId`, `PduData`, `PduIdExt`, `PduDataExt`, `PduAck`) is a public enum (header line 19) that describes the GMTP wire-protocol PDU type field. It is used only internally by `packedMessage()` and `readSocket()`. Exposing it in the public interface leaks the wire-format details to callers and creates an unnecessary coupling point.

**Fix:** Move `PduType` to the private section of the class declaration, or forward-declare it in the `.cpp` file as a file-local enum.

---

**A09-6** · MEDIUM · Magic number `6` repeated throughout `gmtpchat.cpp` without a named constant

**Description:** The GMTP PDU header size (2 bytes type + 2 bytes msg ID + 2 bytes length = 6 bytes) appears as the bare integer `6` in at least seven locations: lines 333, 342, 349, 353, 372, 468, 469, 474, 475. There is no named constant such as `GMTP_HEADER_SIZE`. If the header layout ever changes, all sites must be found and updated manually.

**Fix:** Define `static constexpr int GMTP_HEADER_SIZE = 6;` (or a `#define`) and replace every literal `6` that refers to the PDU header with that constant.

---

**A09-7** · MEDIUM · `GmtpChat::sendAck()` is public but invokes internal protocol machinery

**Description:** `sendAck(quint16 msgId)` is a public method (header line 25). It constructs a `PduAck` PDU and queues it for transmission. Callers need to know server-assigned message IDs — a protocol-level detail — to use it correctly. Inspecting the codebase, `sendAck` is called only from `readSocket()` (line 347), which is itself private. The public exposure creates an unnecessary surface for misuse.

**Fix:** Demote `sendAck` to `private`. The ACK response is an implementation detail of the receive loop.

---

**A09-8** · MEDIUM · Double semicolon on `writeQueue` local variable declaration (`ftpclient.cpp` line 124)

**Description:** Line 124 reads `QFile file(FTP_QUEUE_FILE);;` — two consecutive semicolons. This is syntactically harmless (the second `;` is an empty statement) but is a style error that indicates copy-paste or editing slippage and may confuse static analysis tools.

**Fix:** Remove the duplicate semicolon.

---

**A09-9** · MEDIUM · `readSocket()` silently discards unknown PDU types one byte at a time

**Description:** In `gmtpchat.cpp` lines 371–373, when a received PDU type is neither `PduDataExt` nor `PduAck`, the code removes exactly one byte (`ba.remove(0,1)`) and retries. This is a framing-resync heuristic. No log message is emitted; no error counter is incremented. A corrupt or unexpected PDU type will cause the loop to spin silently, consuming the buffer byte-by-byte. This masks protocol errors and makes field diagnosis very difficult.

**Fix:** Log a warning (at least at `SerialLogger` level) when an unexpected type is encountered, and consider recording a metric or emitting a diagnostic signal. If the protocol guarantees well-formed frames, consider aborting and reconnecting instead.

---

**A09-10** · LOW · `m_serverIndex` typed as `int` while compared against `GMTP_SERVER_CNT` (unsigned)

**Description:** `m_serverIndex` is declared as `int` (header line 60), but it is used in an unsigned comparison against `GMTP_SERVER_CNT` (value 3) at `gmtpchat.cpp` line 129 (`if (++m_serverIndex >= GMTP_SERVER_CNT)`). A signed/unsigned comparison warning will be generated by compilers with `-Wsign-compare`. While it cannot go negative in practice, the type mismatch is inconsistent with the surrounding `quint8`/`quint16` usage.

**Fix:** Change `m_serverIndex` to `int` with an explicit `static_cast<int>(GMTP_SERVER_CNT)` comparison, or change it to `quint8` / `quint32` to match the unsigned context.

---

**A09-11** · LOW · Inline method bodies in `gmtpchat.h` mix logic with class declaration

**Description:** Three public methods are defined inline in the header (lines 27–29): `sleeping()`, `setEthernetState(bool)`, and `acksRemaining()`. While `sleeping()` and `acksRemaining()` are trivial getters, `setEthernetState` contains a side-effect (emitting `disconnectSocket()`) with a guarded branch. Inline logic in headers makes the interface harder to read and can surprise callers who do not expect a signal emission from a setter.

**Fix:** Move `setEthernetState` to the `.cpp` file. Keep the two pure getters inline only if consistency with the rest of the codebase demands it.

---

**A09-12** · LOW · `using namespace CIGCONF` at file scope in `gmtpchat.cpp`

**Description:** Line 20 of `gmtpchat.cpp` declares `using namespace CIGCONF;` at file scope. This pulls every name from that namespace into the translation unit, increasing the risk of accidental name shadowing or collisions as the namespace grows. The remainder of the codebase (including `ftpclient.cpp`) uses the fully qualified `CIGCONF::` prefix consistently.

**Fix:** Remove the `using namespace CIGCONF;` directive and qualify all references with `CIGCONF::`, consistent with the rest of the codebase.

---

**A09-13** · LOW · Commented-out code in `ftpclient.cpp` lines 38–39

**Description:** Inside `FtpClient::download()`, lines 38–39 contain:
```cpp
//setReport(CIGCONF::FtpGenericError);
```
This commented-out call was presumably the original behaviour when the network is not available: report an error immediately. The code was silently removed, leaving only a `return` with no notification. The comment has no associated ticket reference or explanation.

**Fix:** Either restore the `setReport` call with appropriate justification, or delete the comment. Add a code comment explaining why no error is reported when the network is down (i.e., the URL is queued and will retry later).

---

**A09-14** · LOW · `reconnectCount` overflow silently wraps

**Description:** `m_reconnectCount` is `quint8` (max 255, header line 73). In `reconnectServer()` (line 134), the check is `if (m_reconnectCount > MAX_GMTP_RECONNECT_CNT)` (20). After triggering, it resets to 0 (line 135) then immediately increments to 1 (line 140), so the logic works today. However, if the reset were removed or the check changed, `quint8` wraps at 256. Using `quint8` for a counter compared against an `int` constant also generates a compiler sign/size warning. Additionally `m_reconnectCount` is initialised to `1` in the constructor (not `0`), which means the very first connection attempt already counts as reconnect attempt #1, which is misleading.

**Fix:** Initialise `m_reconnectCount` to `0`. Consider using `quint32` or `int` to avoid overflow-related surprises.

---

**A09-15** · LOW · `FtpClient::downloadFinished()` line 259 — GMTP message key mismatch

**Description:** At line 259, the "no more retries" GMTP monitoring message is keyed as `"FTPF_DL_NO_MORE_RETRIES"` but the accompanying log message at line 258 says `"File transfer failed ... no more retries"`. However, this branch is reached only when `m_retries < FTP_RETRIES` (i.e., there *are* retries remaining — it is the retry-in-progress path). The GMTP key name `FTPF_DL_NO_MORE_RETRIES` is semantically incorrect for this branch; that key is used when retries are exhausted (which is the branch at line 253–256 that uses no such key). The misleading constant name will confuse server-side log analysis.

**Fix:** Rename the monitoring message key to `FTPF_DL_RETRY` or similar to accurately describe the retry-in-progress case.

---

**A09-16** · INFO · Timer interval constants are bare integer literals in constructor

**Description:** In `GmtpChat`'s constructor (`gmtpchat.cpp` lines 41–43), three timers are assigned intervals: `5000` ms (socket timer), `1000` ms (upload timer), `10000` ms (ACK timer). Only the ACK timer value is captured in the named constant `DEF_MSOCKET_TIMEOUT` (which equals `10000` — but this constant is used in `reconnectServer()` / `connectServer()` for the socket reconnect timer, not the ACK timer). The `5000` and `1000` values are truly bare literals with no named constant.

**Fix:** Introduce named constants (e.g., `GMTP_SOCKET_TIMEOUT_MS = 5000`, `GMTP_UPLOAD_INTERVAL_MS = 1000`) and use them in place of the literals.

---

**A09-17** · INFO · `GmtpChat::signal gmtpHotStartReconnect()` is declared but never emitted

**Description:** The signal `gmtpHotStartReconnect()` (header line 36) is never emitted anywhere in the codebase — the only location that would emit it is inside the commented-out block at `gmtpchat.cpp` lines 91–93. The signal declaration is dead code that cannot be used until the hot-start logic is restored.

**Fix:** Either restore the hot-start reconnect logic or remove the signal declaration.

---

## Summary Table

| ID | Severity | Title |
|----|----------|-------|
| A09-1 | HIGH | `ByteArray::asprintf` re-uses invalidated `va_list` (UB) |
| A09-2 | HIGH | Large commented-out code blocks with dead `setOnIgnitionOffDisconnect` |
| A09-3 | MEDIUM | `writeQueue()`/`readQueue()` unnecessarily public on `FtpClient` |
| A09-4 | MEDIUM | `FtpClient::startTransfer()` unnecessarily public |
| A09-5 | MEDIUM | `PduType` wire-protocol enum exposed in public interface |
| A09-6 | MEDIUM | Magic number `6` (PDU header size) repeated without named constant |
| A09-7 | MEDIUM | `sendAck()` unnecessarily public; leaks protocol details |
| A09-8 | MEDIUM | Double semicolon at `ftpclient.cpp` line 124 |
| A09-9 | MEDIUM | Silent byte-by-byte resync on unknown PDU type in `readSocket()` |
| A09-10 | LOW | `m_serverIndex` signed/unsigned mismatch with `GMTP_SERVER_CNT` |
| A09-11 | LOW | Inline side-effect method `setEthernetState` in header |
| A09-12 | LOW | `using namespace CIGCONF` at file scope in `gmtpchat.cpp` |
| A09-13 | LOW | Commented-out `setReport` call in `FtpClient::download()` |
| A09-14 | LOW | `m_reconnectCount` initialised to 1, `quint8` overflow risk |
| A09-15 | LOW | GMTP monitoring key `FTPF_DL_NO_MORE_RETRIES` used on retry-in-progress path |
| A09-16 | INFO | Bare timer interval literals in `GmtpChat` constructor |
| A09-17 | INFO | Signal `gmtpHotStartReconnect()` declared but never emitted |
# Pass 4 Agent A10 — Code Quality

**Audit run:** 2026-02-28-01
**Branch:** master
**Files reviewed:**
- `comm/modemchat.h`
- `comm/modemchat.cpp`
- `comm/ntpsync.h`
- `comm/ntpsync.cpp`

---

## Reading Evidence

### `comm/modemchat.h`

**Class:** `ModemChat` (inherits `QObject`)

**Enum defined:**
| Enum | Values |
|------|--------|
| `NetworkState` | `NetworkStopped(0)`, `NetworkHome(1)`, `NetworkSearching(2)`, `NetworkDenied(3)`, `NetworkUnknown(4)`, `NetworkRoaming(5)` |

**Struct defined (private):**
| Struct | Fields |
|--------|--------|
| `apnData` | `QString apn`, `QString apnUser`, `QString apnPassword` |

**Public methods / accessors:**
| Line | Name |
|------|------|
| 24 | `ModemChat(EM070::ModemPort *modemPort)` (constructor) |
| 25 | `void portStateChanged(bool open)` |
| 26 | `void setGnssEnabled(bool enable)` |
| 27 | `void rssiRefresh()` |
| 28 | `void qmiCheck()` |
| 29 | `void networkCheck()` |
| 30 | `void updateApn()` |
| 31 | `void detach(bool send = true)` |
| 32 | `void requestDetach()` |
| 34 | `const QByteArray &cgmi() const` |
| 35 | `const QByteArray &cgmm() const` |
| 36 | `const QByteArray &cgmr() const` |
| 37 | `const QByteArray &cgsn() const` |
| 38 | `const QByteArray &iccid() const` |
| 39 | `const QByteArray &rssi() const` |
| 40 | `const QByteArray &mobileOperator() const` |
| 41 | `const QByteArray &moni() const` |
| 42 | `NetworkState networkState() const` |
| 43 | `bool isEthernetReady() const` |

**Private methods:**
| Line | Name |
|------|------|
| 56 | `void sendChat(bool timeout = false)` |
| 57 | `void popChat()` |
| 58 | `void pushChat(const QByteArray &chat)` |
| 59 | `void noResponse()` |
| 60 | `void parseResponse(bool result, const QByteArrayList &content)` |
| 61 | `void selectAPN()` |
| 62 | `void updateEthernetState(bool connected)` |
| 63 | `void reconnectNetwork()` |
| 64 | `void onUqmiProcessComplete(int exitCode, QProcess::ExitStatus exitStatus)` |
| 65 | `void onProcessTimeout()` |
| 66 | `void resetReconnectFlag()` |
| 69 | `int args(const QByteArrayList &content, QGenericArgument val1, QGenericArgument val2, QGenericArgument val3, QGenericArgument val4)` |

**Constants (macros in modemchat.cpp):**
| Macro | Value | Meaning |
|-------|-------|---------|
| `RETRY_WAIT` | 500 | ms between retries |
| `RETRIES_PER_SEC` | 1000/500 = 2 | retries per second |
| `ACK_TIMEOUT` | 3000 | ms to wait for AT response |
| `RSSI_INTERVAL` | 10000 | ms between RSSI polls |
| `QMI_INTERVAL` | 2000 | ms between QMI polls |
| `NETWORK_INTERVAL` | 2000 | ms between network checks |
| `NETWORK_TIMEOUT` | 90 | ticks (= 180 s) before detach |
| `MONOGOTO_PREFIX_SIZE` | 5 | ICCID prefix length for Monogoto |
| `MAX_QMI_FAILURE_COUNT` | 7 | max successive QMI failures |
| `PROCESS_MAX_WAIT_TIMEOUT` | 10000 | ms to wait for uqmi process start |
| `MAX_CGDCONT` | 5 | max APN-set retries |

---

### `comm/ntpsync.h`

**Class:** `NtpSync` (inherits `QObject`)

**Public methods:**
| Line | Name |
|------|------|
| 14 | `NtpSync(ModemChat *parent)` (constructor) |
| 15 | `void connectServer()` |
| 16 | `void abortConnection()` |

**Signals:**
| Line | Name |
|------|------|
| 19 | `void synchronized(bool yes)` |

**Private methods:**
| Line | Name |
|------|------|
| 22 | `void writeSocket()` |
| 23 | `void readSocket()` |

**Constants (macros in ntpsync.cpp):**
| Macro | Value | Meaning |
|-------|-------|---------|
| `EPOCH_DIFF` | `0x83aa7e80UL` | Seconds between NTP epoch (1900) and Unix epoch (1970) |

---

## Findings

---

**A10-1** · HIGH · Large commented-out block in `portStateChanged` obscures active code path selection

**Description:** Lines 85-101 in `modemchat.cpp` contain a multi-line commented-out `if/else` block that was apparently the predecessor to the current runtime branch selected in `parseResponse` after `AT+CGMM` is received. The commented block mixes initialization commands that now appear elsewhere with subtly different ordering. Its continued presence creates confusion about intent: it is unclear whether the dead block is aspirational, superseded, or a rollback option. It also misrepresents the actual startup sequence to any reader.

```cpp
// comm/modemchat.cpp lines 85-101
// if (m_modemPort->isWwx()) {
//     m_chatCmds << "AT+CGDCONT?"
//                << "AT#MONI"
//                << "AT+CSQ";
// } else {
//     m_chatCmds << "AT+CSQ"
//             << "AT+CGCONTRDP="
//            << "AT+CGDCONT?"
//            << "AT#PDPAUTH?"
//            << "AT+COPS?"
//            << "AT+CGATT?"
//            << "AT+CGREG?"
//            << "AT#MONI"
//            << "AT+CSQ"
//            << "AT#ECM?"
//            << "AT#ECMC?";
//}
```

**Fix:** Remove the commented-out block entirely. If needed for reference, it is preserved in version control history.

---

**A10-2** · MEDIUM · Additional scattered commented-out code throughout `modemchat.cpp`

**Description:** Multiple other commented-out lines are spread throughout the file and create noise:

- Line 110-111: `// m_ethernetState = false;` / `// emit ethernetStateChanged(false);` — superseded by `updateEthernetState(false)` on line 112 but left in place.
- Lines 320, 342-344: `//QProcess::execute(...)` and `//m_qmiTimer->start(...)` / `//m_rssiTimer->start(...)` inside `updateApn()` and `detach()`.
- Lines 503-504: `// selectAPN();` / `// QProcess::execute(...)` inside `parseResponse` for `AT+CGDCONT?`.
- Lines 609-610: `// m_ethernetState = true;` / `// emit ethernetStateChanged(true);` in `AT#ECMC?` handler.
- Lines 615: `// m_ethernetState = false;` in same handler.
- Lines 674-685: Commented-out `pushChat` calls inside the `+CGEV:` handler.
- Line 224-225: Commented-out `m_chatCmds << "AT#MONI"` / `sendChat()` in `updateEthernetState`.

**Fix:** Purge all commented-out statements. Where genuinely uncertain code is being held in reserve, move it to a named helper or document the reason it is retained with a TODO/FIXME tag with a ticket reference.

---

**A10-3** · MEDIUM · AT-command strings and modem vendor mnemonics leak into the public interface

**Description:** The public methods `detach()`, `requestDetach()`, `updateApn()`, `rssiRefresh()`, and `qmiCheck()` are named after modem operations or internal AT-command concepts. The public accessors `cgmi()`, `cgmm()`, `cgmr()`, `cgsn()`, `iccid()`, and `moni()` directly expose AT-command names (CGMI, CGMM, CGMR, CGSN, ICCID, MONI) as the public API of the class. Callers are required to know what `cgmr` or `moni` mean, which are raw modem AT-command names. This is a leaky abstraction: the hardware-protocol layer bleeds through to any consumer of `ModemChat`.

**Fix:** Rename public accessors and methods to domain-meaningful names. Examples: `cgmi()` -> `manufacturerId()`, `cgmm()` -> `modelId()`, `cgmr()` -> `revisionId()`, `cgsn()` -> `imei()`, `moni()` -> `cellInfo()`. Rename `detach()` / `requestDetach()` to `disconnectNetwork()` / `requestNetworkDisconnect()`.

---

**A10-4** · MEDIUM · `args()` uses `QGenericArgument` / `Q_ARG` for a purely internal parsing helper — inappropriate API

**Description:** `ModemChat::args()` (header line 69, impl line 696) uses the Qt meta-object `QGenericArgument` mechanism (`Q_ARG`, `val.name()`, `val.data()`) to pass typed output parameters. This mechanism is designed for `QMetaObject::invokeMethod` dynamic dispatch and is explicitly noted in the Qt docs as not type-safe. The class's own header comment (`// to save the parsing time, only QByteArray/QString/int/bool are supported`) acknowledges the limitation. A plain overload set or a small `struct` would be safer and clearer.

**Fix:** Replace the `args()` helper with either (a) a set of typed overloads, (b) a `struct ParseResult` return type, or (c) a small template helper that avoids `QGenericArgument` entirely. At minimum, document the constraint more prominently and add a `static_assert` or runtime check that rejects unsupported types rather than silently misinterpreting them.

---

**A10-5** · MEDIUM · Shadow variable `isWwx` declared inside `AT#USBCFG?` branch obscures outer declaration

**Description:** In `parseResponse()`, `isWwx` is declared at line 371 for use throughout the function. Inside the `AT#USBCFG?` handler at line 440, a second `bool isWwx = m_modemPort->isWwx();` is declared, shadowing the outer variable. The inner re-declaration is redundant (same value) and on a compiler with `-Wshadow` this produces a warning.

```cpp
// Line 371 (outer):
bool isWwx = m_modemPort->isWwx();
// ...
// Line 440 (inner shadow, inside if-block for AT#USBCFG?):
bool isWwx = m_modemPort->isWwx();
```

**Fix:** Remove the inner `bool isWwx` declaration at line 440; the outer `isWwx` is already in scope and holds the same value.

---

**A10-6** · MEDIUM · Logic bug: `bool` validation in `args()` uses `||` instead of `&&` — always true

**Description:** In `modemchat.cpp` at line 749:

```cpp
if (val >= 0 || val <= 1)
    * (bool *) valDatas[i] = val;
else
    return i;
```

The condition `val >= 0 || val <= 1` is a tautology — it is always true for any integer (every integer is either >= 0 or <= 1). The intent is clearly to accept only values 0 or 1, which requires `val >= 0 && val <= 1`. The `else` branch that rejects out-of-range values is therefore dead/unreachable code.

**Fix:** Change `||` to `&&`:
```cpp
if (val >= 0 && val <= 1)
    * (bool *) valDatas[i] = val;  <!-- dup, orig line 24742 -->
else
    return i;
```

---

**A10-7** · MEDIUM · `updateApn()` has inconsistent indentation — `else` branch body not indented

**Description:** The `else` branch of `updateApn()` at lines 321-333 is not indented relative to the enclosing `if/else`, making the code's structure misleading:

```cpp
void ModemChat::updateApn()
{
    if (m_modemPort->isWwx()) {
        pushChat("AT+CGDCONT?");
        //QProcess::execute(...);
    } else {
    pushChat("AT#ECMC?");   // <- should be indented
    pushChat("AT#ECM?");
    ...
    sendChat();
}
}
```

The closing brace alignment is also wrong: the function's closing `}` appears on a line by itself at column 0 after the `else` block's `}`, which compiles correctly but is highly misleading.

**Fix:** Re-indent the `else` block body consistently. Both branches should use 4-space (or one tab) indentation. Run the file through `clang-format` with the project's style settings.

---

**A10-8** · LOW · Magic number `0x0b` in `writeSocket()` with no named constant or comment

**Description:** In `ntpsync.cpp` line 65:

```cpp
ba[0] = 0x0b;
```

This byte encodes the NTP packet LI/VN/Mode field: LI=0 (no warning), VN=1 (version 1), Mode=3 (client). The value `0x0b` is opaque and non-obvious. Any reader maintaining the code must know NTP packet structure to understand it.

**Fix:** Replace with a named constant and comment:
```cpp
// NTP packet: LI=0 (no leap warning), VN=1, Mode=3 (client)
static const quint8 NTP_LI_VN_MODE = 0x0b;
ba[0] = NTP_LI_VN_MODE;
```
Also note that NTP version 1 is ancient; NTP version 4 (`0x1b`) is standard. Consider whether the server supports v1.

---

**A10-9** · LOW · Magic number `123` (NTP port) used inline without a named constant

**Description:** In `ntpsync.cpp` line 50 and referenced in the log message at line 62:

```cpp
m_udpSocket->connectToHost(gCfg->timeServerAddress(), 123);
```

Port 123 is the well-known NTP port, but it should be a named constant for readability and maintainability.

**Fix:** Define `static const quint16 NTP_PORT = 123;` and use it in both the `connectToHost` call and the log message.

---

**A10-10** · LOW · Magic number `48` (NTP packet size) used without a named constant

**Description:** In `ntpsync.cpp` lines 64 and 75:

```cpp
QByteArray ba(48, 0);  // line 64
if (ba.size() < 48)    // line 75
```

48 bytes is the fixed NTP packet size. Having it as a bare literal in two places risks a discrepancy if one is ever changed.

**Fix:** Define `static const int NTP_PACKET_SIZE = 48;` and use it consistently.

---

**A10-11** · LOW · Comment in `connectServer()` has incorrect polarity — `// -1 means time has in sync yet`

**Description:** In `ntpsync.cpp` line 31:

```cpp
// -1 means time has in sync yet
if (m_syncTimes < 0) {
```

The comment appears to be a garbled version of "time has already synced" or "time is in sync". The word "yet" makes the sentence ambiguous/incorrect. The sentinel value -1 meaning "already synced" is a non-obvious convention.

**Fix:** Correct the comment: `// m_syncTimes == -1 means synchronisation already completed`. Consider replacing the sentinel `-1` with a named constant `static const int SYNC_COMPLETE = -1;` or a separate `bool m_synced` flag for clarity.

---

**A10-12** · LOW · `abortConnection()` silently resets `m_syncTimes` to 0 only when positive — inconsistent reset

**Description:** In `ntpsync.cpp` lines 54-58:

```cpp
void NtpSync::abortConnection()
{
    if (m_syncTimes > 0)
        m_syncTimes = 0;
    m_timer->stop();
}
```

If `m_syncTimes` is already 0 (never started) or -1 (already synced), the reset is skipped or suppressed. An abort when `m_syncTimes == -1` leaves the "already synced" sentinel in place; the next call to `connectServer()` would immediately re-emit `synchronized(true)` without actually connecting. Whether this is the desired behaviour is not documented.

**Fix:** Document the intended post-conditions of `abortConnection()` explicitly. If a full reset is desired (i.e., allow re-synchronisation after abort), set `m_syncTimes = 0` unconditionally. If re-sync after abort should be inhibited once already synced, add an explanatory comment.

---

**A10-13** · LOW · `MAX_QMI_FAILURE_COUNT` defined but never used

**Description:** In `modemchat.cpp` line 18:

```cpp
#define MAX_QMI_FAILURE_COUNT (7) //Approximately n x 2s timeout = n*2s successive failure
```

A search of the file shows this constant is never referenced anywhere in `modemchat.cpp` or `modemchat.h`. It appears to be dead configuration left from a previous implementation of QMI failure counting that was removed.

**Fix:** Remove the unused macro, or implement the failure counter logic it was intended to support.

---

**A10-14** · LOW · `m_networkState` member is never initialised in the constructor

**Description:** In `modemchat.h` the member `NetworkState m_networkState` is declared at line 94. The constructor initialiser list in `modemchat.cpp` (lines 24-40) does not initialise `m_networkState`. Because `NetworkState` is a plain `enum` (not `enum class`), it defaults to an indeterminate integer value if the object is allocated on the heap or in uninitialized storage. Any call to `networkState()` before `parseResponse` processes a `+CGREG?` response returns an undefined value.

**Fix:** Add `m_networkState(NetworkUnknown)` to the constructor initialiser list.

---

**A10-15** · LOW · `BE_INT` macro in `ntpsync.cpp` — first argument is a signed `char` used in a left-shift

**Description:** `ntpsync.cpp` line 78-79 uses `BE_INT(ba[32], ...)`. `ba` is a `QByteArray`; its `operator[]` returns `char`, which is signed on most platforms. The macro definition (`utils/bytearray.h` line 7) performs `(c1) << 24` — left-shifting a potentially negative signed `char` by 24 is undefined behaviour in C++ if `c1` is negative (i.e., byte value > 127). Only `c2`, `c3`, `c4` are cast to `uchar` inside the macro; `c1` is not.

```cpp
#define BE_INT(c1, c2, c3, c4)  ((c1) << 24 | (uchar)(c2) << 16 | (uchar)(c3) << 8 | (uchar)(c4))
```

**Fix:** Cast `c1` to `uchar` (or `quint8`) inside the macro before the shift:
```cpp
#define BE_INT(c1, c2, c3, c4)  ((uchar)(c1) << 24 | (uchar)(c2) << 16 | (uchar)(c3) << 8 | (uchar)(c4))
```

---

**A10-16** · LOW · `rssiRefresh()` enqueues commands but only calls `sendChat()` when queue size is exactly 2

**Description:** In `modemchat.cpp` lines 132-137:

```cpp
void ModemChat::rssiRefresh()
{
    m_chatCmds << "AT+CSQ";
    m_chatCmds << "AT#MONI";

    if (m_chatCmds.size() == 2)
        sendChat();
}
```

`sendChat()` is only called if the queue contained exactly zero commands before this function ran (i.e., size becomes exactly 2). If the queue already had any pending commands, the new commands are appended silently and `sendChat()` is not called from here. While `sendChat()` is called from `parseResponse()` after each command completes, the check `== 2` is fragile: if `rssiRefresh()` were ever modified to enqueue a third command, the `sendChat()` trigger would silently stop working.

**Fix:** Replace `m_chatCmds.size() == 2` with `m_chatCmds.size() == 2` being replaced by a named pre-count check:
```cpp
bool wasEmpty = m_chatCmds.isEmpty();
m_chatCmds << "AT+CSQ" << "AT#MONI";
if (wasEmpty)
    sendChat();
```

---

**A10-17** · INFO · Struct `apnData` uses lowercase name, inconsistent with Qt/project PascalCase convention

**Description:** In `modemchat.h` line 50, the private struct is named `apnData` (camelCase starting with lowercase), while all other types in the codebase use PascalCase (e.g., `ModemChat`, `NetworkState`, `NtpSync`). Qt coding style recommends PascalCase for all type names.

**Fix:** Rename to `ApnData` to match the surrounding naming convention.

---

**A10-18** · INFO · `vsprintf` call in `ByteArray::asprintf` (used by `modemchat.cpp`) uses a recycled `va_list` after `va_end`

**Description:** `utils/bytearray.h` lines 19-25 (used by `modemchat.cpp` via `ByteArray::asprintf`):

```cpp
va_start(ap, cformat);
size = vsnprintf(nullptr, 0, cformat, ap);
va_end(ap);

QByteArray ba;
ba.resize(size);
vsprintf(ba.data(), cformat, ap);  // ap was already va_end'd
```

After `va_end(ap)`, the `va_list` `ap` is indeterminate; passing it to `vsprintf` is undefined behaviour. A second `va_start` / `va_end` pair is required. This is a pre-existing issue in a utility used by this module.

**Fix:** Add a second `va_start(ap, cformat)` before the `vsprintf` call and a matching `va_end(ap)` after it.

---

## Summary Table

| ID | Severity | Title |
|----|----------|-------|
| A10-1 | HIGH | Large commented-out block in `portStateChanged` obscures code path |
| A10-2 | MEDIUM | Additional scattered commented-out code throughout modemchat.cpp |
| A10-3 | MEDIUM | AT-command names leak into public interface (leaky abstraction) |
| A10-4 | MEDIUM | `args()` uses `QGenericArgument` inappropriately for internal parsing |
| A10-5 | MEDIUM | Shadow variable `isWwx` redeclared inside AT#USBCFG? handler |
| A10-6 | MEDIUM | Logic bug in `args()`: tautological OR makes bool validation dead code |
| A10-7 | MEDIUM | `updateApn()` has incorrect indentation in `else` branch |
| A10-8 | LOW | Magic number `0x0b` NTP LI/VN/Mode byte with no named constant |
| A10-9 | LOW | Magic number `123` (NTP port) used inline |
| A10-10 | LOW | Magic number `48` (NTP packet size) repeated without named constant |
| A10-11 | LOW | Incorrect/garbled comment for sentinel value in `connectServer()` |
| A10-12 | LOW | `abortConnection()` inconsistently resets `m_syncTimes` |
| A10-13 | LOW | `MAX_QMI_FAILURE_COUNT` defined but never used (dead macro) |
| A10-14 | LOW | `m_networkState` not initialised in constructor |
| A10-15 | LOW | `BE_INT` macro shifts signed `char` — undefined behaviour for bytes > 127 |
| A10-16 | LOW | `rssiRefresh()` uses fragile queue-size check instead of was-empty check |
| A10-17 | INFO | Struct `apnData` uses non-PascalCase name |
| A10-18 | INFO | `ByteArray::asprintf` uses `va_list` after `va_end` (UB in shared utility) |
# Pass 4 Agent A11 — Code Quality

**Audit run:** 2026-02-28-01
**Branch:** master
**Files reviewed:**
- `main.cpp` (repo root: `C:/Projects/cig-audit/repos/mark3-pvd/main.cpp`)
- `mytranslator.h` (repo root: `C:/Projects/cig-audit/repos/mark3-pvd/mytranslator.h`)
- `mytranslator.cpp` (repo root: `C:/Projects/cig-audit/repos/mark3-pvd/mytranslator.cpp`)

---

## Reading Evidence

### `main.cpp`

**File purpose:** Application entry point. Initialises the Qt application, installs a key event filter, loads the locale, registers Qt meta-types, starts GPIO configuration via shell commands, creates the main `Dialog` UI, and spins up the `BackgroundWorker` on a dedicated `QThread`.

**Functions / methods:**

| Line | Name | Signature |
|------|------|-----------|
| 24 | `hideBootProgress` | `void hideBootProgress()` |
| 38 | `configureCrashLogging` | `void configureCrashLogging()` |
| 71 | `main` | `int main(int argc, char *argv[])` |

**Types / enums / constants defined:**

| Line | Kind | Name | Value |
|------|------|------|-------|
| 17 | Preprocessor macro (commented out) | `CONSTRAINED_MEMORY_TEST` | — |
| 20 | Preprocessor macro (conditional) | `MEMSZ` | `10*1024*1024` |
| 21 | Static global array (conditional) | `mem` | `static quint8 mem[MEMSZ]` |

**Namespace in scope:** `using namespace EM070;` (line 15)

---

### `mytranslator.h`

**File purpose:** Public interface for the application's translation subsystem. Declares the global `QTranslator` object and all free functions that load, update, query, and remove locale files.

**Functions declared:**

| Line | Name | Signature |
|------|------|-----------|
| 15 | `loadLocalLanguage` | `void loadLocalLanguage(void)` |
| 16 | `updateLocalLanguage` | `void updateLocalLanguage(const QString &arg1)` |
| 17 | `getCurrentLanguage` | `QString getCurrentLanguage(void)` |
| 18 | `queryLanguage` | `int queryLanguage(void)` |
| 19 | `setLanguage` | `int setLanguage(int local)` |
| 20 | `removeTranslator` | `void removeTranslator()` |

**Types / constants defined:**

| Line | Kind | Name | Value |
|------|------|------|-------|
| 11 | `const QString` (non-`inline`, header-level) | `langEnglish` | `"EN"` |
| 12 | `const QString` (non-`inline`, header-level) | `langSpanish` | `"ES"` |
| 14 | `extern` global object | `mTranslator` | `QTranslator` |

---

### `mytranslator.cpp`

**File purpose:** Implementation of the translation subsystem. Manages reading/writing a plain-text `local.dat` file to persist the selected language, and loading the corresponding Qt `.qm` translation file listed in the embedded `lang.dat` resource.

**Functions defined:**

| Line | Name | Notes |
|------|------|-------|
| 15 | `loadLocalLanguage` | Reads `local.dat`, looks up entry in `lang.dat`, installs `mTranslator`. Deletes `local.dat` if language not found. |
| 74 | `updateLocalLanguage` | Looks up language in `lang.dat`, installs `mTranslator`, writes `local.dat`. Removes file on miss. |
| 132 | `getCurrentLanguage` | Returns the two-letter language code for the active locale, defaulting to `langEnglish`. |
| 167 | `queryLanguage` | Maps language string to `QLocale::Language` integer; returns `-1` on unknown. |
| 177 | `setLanguage` | Calls `updateLocalLanguage` if locale differs from current; returns `-1` on unknown locale. |
| 190 | `removeTranslator` | Removes `mTranslator` from the application via `QCoreApplication::removeTranslator`. |

**Types / constants defined:**

| Line | Kind | Name | Value |
|------|------|------|-------|
| 7 | `const QString` (file-scope) | `localFile` | `"local.dat"` |
| 8 | `const QString` (file-scope) | `langFile` | `":/lang.dat"` |
| 10 | Global object definition | `mTranslator` | `QTranslator mTranslator;` |

---

## Findings

---

**A11-1** · MEDIUM · Global `QTranslator` object exposed through a header

**Description:** `mTranslator` is declared `extern` in `mytranslator.h` (line 14) and defined at translation-unit scope in `mytranslator.cpp` (line 10). Every translation unit that includes `mytranslator.h` can read or write the translator directly, bypassing the API. More critically, `QTranslator` inherits `QObject`, and `QObject` instances must not be constructed before `QApplication` exists. Because `mTranslator` is a namespace-scope (pre-`main`) object its constructor runs at static-initialisation time, before `QApplication a(argc, argv)` on line 78 of `main.cpp`. On platforms where Qt's internal state is not yet ready this is undefined behaviour.

**Fix:** Remove the `extern` declaration from the header. Make `mTranslator` a function-local static or a private member of a small `TranslatorManager` singleton initialised after `QApplication`. Expose only the six existing free-function signatures (which are already sufficient for all callers).

---

**A11-2** · LOW · Header-level `const QString` constants cause ODR issues across translation units

**Description:** `langEnglish` and `langSpanish` are defined as `const QString` at namespace scope directly in `mytranslator.h` (lines 11–12). Unlike `const int` or `constexpr`, `QString` is not an integral constant and is not `inline`. Every translation unit that includes this header gets its own definition (though the linker typically merges them under the One-Definition Rule). More important, each TU pays the cost of constructing and destructing a `QString` at static-init and static-deinit time. This is an anti-pattern for Qt applications.

**Fix:** Replace with `constexpr char` arrays or `inline const QString` (Qt 5.10+ / C++17), or move them to a `.cpp`-level `static const`. For example:

```cpp
// mytranslator.h
constexpr char langEnglish[] = "EN";
constexpr char langSpanish[] = "ES";
```

---

**A11-3** · LOW · `configureCrashLogging()` is a fully implemented function that is permanently commented out

**Description:** `configureCrashLogging()` (lines 38–69 of `main.cpp`) is a complete function that writes a shell script to `/mnt/sd/app_monitor` and starts it with `QProcess::startDetached`. Its call site on line 101 is commented out with no associated TODO or bug-reference comment. The function is compiled into the binary but never called, constituting dead code. The embedded shell script also leaks the internal product name `FleetFocus` into the binary image.

**Fix:** If crash-logging monitoring is not required for this release, remove both the function definition and its commented-out call site. If it is intended for a future release, add a JIRA/issue reference in the comment and guard it under an appropriate `#ifdef` (e.g., `#ifdef ENABLE_CRASH_MONITOR`).

---

**A11-4** · LOW · `CONSTRAINED_MEMORY_TEST` dead-code block is compiled in unconditionally (false branch always taken)

**Description:** Lines 17–22 and 102–105 of `main.cpp` define a preprocessor-guarded memory-stress test that allocates a 10 MB static array and locks it with `mlock`. The controlling macro `CONSTRAINED_MEMORY_TEST` is permanently commented out (line 17: `//#define CONSTRAINED_MEMORY_TEST`). The guarded block can never be entered. This is a development artifact that should not remain in the repository on the `master` / release branch.

**Fix:** Remove the `#define`, the `#ifdef` blocks, the static `mem` array, and the `#include <sys/mman.h>` if it is only needed by that block. If the test is still needed, move it to the test project (`mk3-test.pro`) rather than the production build.

---

**A11-5** · LOW · Commented-out GPIO shell command on line 108

**Description:** Line 108 of `main.cpp` contains a commented-out alternative approach for exporting GPIO 37:

```cpp
//int ret = QProcess::execute("echo 37 > /sys/class/gpio/export");
```

The equivalent shell-safe version immediately follows on line 109. The commented-out line is dead code and its stale variable `ret` (which was never checked) also indicates the original implementation was incomplete.

**Fix:** Remove the commented-out line. The active version on line 109 is the correct implementation.

---

**A11-6** · MEDIUM · `QTextStream::setCodec` is deprecated in Qt 5 and removed in Qt 6

**Description:** `setCodec("UTF-8")` is called on every `QTextStream` instance in `mytranslator.cpp` (lines 22, 29, 84, 115, 140, 147). `QTextStream::setCodec(const char *)` was deprecated in Qt 5.15 and removed in Qt 6. The project's `.pro` file (`mk3.pro`, line 30) enables `QT_DEPRECATED_WARNINGS`, meaning every build targeting Qt 5.15+ will emit compiler warnings for these six call sites. There is also a commented-out entry in `mk3.pro` (line 35) suggesting a future migration to Qt 6 has been considered.

**Fix:** Replace with `QTextStream::setEncoding(QStringConverter::Utf8)` (Qt 6 API). If Qt 5 compatibility must be retained, use a version-guarded wrapper:

```cpp
#if QT_VERSION < QT_VERSION_CHECK(6, 0, 0)
    stream.setCodec("UTF-8");
#else
    stream.setEncoding(QStringConverter::Utf8);
#endif
```

---

**A11-7** · LOW · `qsrand` / `qrand` are deprecated Qt APIs

**Description:** `qsrand(QDateTime::currentSecsSinceEpoch())` is called in `main.cpp` line 99. `qsrand` and its companion `qrand` (used in `ui/checkquestiondialog.cpp` line 24) were deprecated in Qt 5.15. They wrap the C `srand`/`rand` functions, which are not thread-safe. With `QT_DEPRECATED_WARNINGS` enabled in `mk3.pro`, these produce build warnings.

**Fix:** Replace with `QRandomGenerator::global()->seed(...)` and `QRandomGenerator::global()->bounded(...)` respectively. Seeding the global generator is optional (it is auto-seeded from the OS); callers should simply call `QRandomGenerator::global()->bounded(n)` in place of `qrand() % n`.

---

**A11-8** · LOW · `endl` manipulator deprecated in Qt 5.15 / Qt 6 context

**Description:** `out << lang << endl;` on line 116 of `mytranslator.cpp` uses Qt's `endl` manipulator (imported via `<QTextStream>`). Qt's `endl` (distinct from `std::endl`) was deprecated in Qt 5.14. With `QT_DEPRECATED_WARNINGS` active, this is a build warning.

**Fix:** Replace with `Qt::endl` (available from Qt 5.14):

```cpp
out << lang << Qt::endl;
```

---

**A11-9** · INFO · Inconsistent naming convention: parameter `arg1` in public API

**Description:** The public function `updateLocalLanguage(const QString &arg1)` (header line 16, implementation line 74) uses the auto-generated Qt slot parameter name `arg1` rather than a descriptive name. All other parameters in the file use meaningful names (`lang`, `local`, `filename`). This reduces readability and is inconsistent with the rest of the codebase.

**Fix:** Rename the parameter to something descriptive, for example `languageCode` or `langCode`, in both the header declaration and the implementation.

---

**A11-10** · INFO · `loadLocalLanguage` closes `local` in only one branch; open file may be leaked on error path

**Description:** In `loadLocalLanguage` (lines 55–63 of `mytranslator.cpp`), the `QFile local` is closed only in the `isFound == true` branch. In the `isFound == false` branch the file is deleted via `local.remove()`. `QFile::remove()` does implicitly close on some Qt versions, but this behaviour is undocumented as guaranteed and differs from the explicit `close()` in the success path, creating an inconsistency that makes correctness reasoning harder.

**Fix:** Call `local.close()` unconditionally before the `if(isFound)` block, then call `local.remove()` in the false branch. This matches the pattern used in `updateLocalLanguage` (line 124) and makes the control flow symmetrical.

---

**A11-11** · INFO · `gCfg` macro defined in included header creates a leaky abstraction in `globalconfigs.h`

**Description:** `globalconfigs.h` (line 13) defines:

```cpp
#define gCfg GlobalConfigs::instance()
```

This macro is included transitively by a large portion of the codebase. Every call site that writes `gCfg->someMethod()` expands to `GlobalConfigs::instance()->someMethod()`, silently calling the singleton accessor on every use. Although this is not directly in the audited files, `main.cpp` pulls it in through `app/backgroundworker.h`. The macro hides the singleton pattern, prevents IDE navigation and refactoring, and makes it impossible to inject a mock for unit testing.

**Fix:** Remove the macro. Provide a named free function `GlobalConfigs *globalConfigs()` (or simply use `GlobalConfigs::instance()` at call sites). Where unit-testability is required, pass the instance as a constructor parameter.

---

## Summary Table

| ID | Severity | Title |
|----|----------|-------|
| A11-1 | MEDIUM | Global `QTranslator` object exposed through a header (pre-`QApplication` construction risk) |
| A11-2 | LOW | Header-level `const QString` constants — ODR concern and static-init overhead |
| A11-3 | LOW | `configureCrashLogging()` fully implemented but permanently commented out (dead code) |
| A11-4 | LOW | `CONSTRAINED_MEMORY_TEST` dead-code block left in production branch |
| A11-5 | LOW | Commented-out GPIO shell command on line 108 of `main.cpp` |
| A11-6 | MEDIUM | `QTextStream::setCodec` deprecated (Qt 5.15) / removed (Qt 6) — 6 call sites |
| A11-7 | LOW | `qsrand` / `qrand` deprecated in Qt 5.15; not thread-safe |
| A11-8 | LOW | `endl` manipulator deprecated in Qt 5.14 |
| A11-9 | INFO | Opaque parameter name `arg1` in public API `updateLocalLanguage` |
| A11-10 | INFO | `loadLocalLanguage` closes `QFile local` only in the success branch |
| A11-11 | INFO | `gCfg` macro in `globalconfigs.h` leaks singleton pattern across codebase |
# Pass 4 Agent A12 — Code Quality

**Audit run:** 2026-02-28-01
**Branch:** master
**Assigned files:**
- `platform/aescrypto.h`
- `platform/aescrypto.cpp`
- `platform/blecentral.h`
- `platform/blecentral.cpp`

---

## Reading Evidence

### `platform/aescrypto.h`

**Class:** `EM070::AesCrypto`

| Method / Member | Line | Notes |
|---|---|---|
| `static QByteArray encrypt(const QByteArray &in)` | 16 | Public static |
| `static QByteArray descrypt(const QByteArray &in)` | 17 | Public static (note: typo — should be `decrypt`) |
| `bool enableMtp()` | 20 | Private instance method |
| `QByteArray aes(const QByteArray &in, bool encrypt)` | 21 | Private instance method |
| `static bool m_mtpEnabled` | 22 | Private static member |

**Types / Enums / Constants:** none defined in the header.

**Namespace:** `EM070`

---

### `platform/aescrypto.cpp`

| Method | Line |
|---|---|
| `AesCrypto::enableMtp()` | 20 |
| `AesCrypto::aes(const QByteArray &in, bool encrypt)` | 63 |
| `AesCrypto::encrypt(const QByteArray &in)` | 150 |
| `AesCrypto::descrypt(const QByteArray &in)` | 156 |

**Constants / macros defined:**

| Symbol | Line | Value |
|---|---|---|
| `AF_ALG` | 10 | `38` (fallback `#ifndef` guard) |
| `SOL_ALG` | 13 | `279` (fallback `#ifndef` guard) |

**Platform guards:** all ARM-specific socket/crypto code wrapped in `#ifdef __arm__` (lines 2–6, 24–58, 67–145).

**Notable literals:**
- Hardcoded AES CBC IV at line 124: `"\x3d\xaf\xba\x42\x9d\x9e\xb4\x30\xb4\x22\xda\x80\x2c\x9f\xac\x41"` (16 bytes, fixed for all calls)
- Magic status bitmask at line 49: `0x1000014`, `0x3`

---

### `platform/blecentral.h`

**Classes (all in namespace `EM070`):**

1. **`CharacteristicInfo`** (inherits `QObject`) — lines 13–28
2. **`DescriptorInfo`** (inherits `QObject`) — lines 30–43
3. **`BleCentral`** (inherits `QObject`) — lines 45–126

**`CharacteristicInfo` methods:**

| Method | Line |
|---|---|
| Constructor `CharacteristicInfo(const QLowEnergyCharacteristic &, QLowEnergyService *)` | 17 |
| `QBluetoothUuid uuid() const` | 20 |
| `bool isReadable() const` | 21 |
| `bool isWritable() const` | 22 |
| `const QLowEnergyCharacteristic &characteristic() const` | 23 |
| `QLowEnergyService *parentService() const` | 24 |

**`DescriptorInfo` methods:**

| Method | Line |
|---|---|
| Constructor `DescriptorInfo(const QLowEnergyDescriptor &, CharacteristicInfo *)` | 34 |
| `QBluetoothUuid uuid() const` | 37 |
| `const QLowEnergyDescriptor &descriptor() const` | 38 |
| `const CharacteristicInfo *parentInfo() const` | 39 |

**`BleCentral` methods:**

| Method | Line | Type |
|---|---|---|
| Constructor `BleCentral(QObject *parent = nullptr)` | 51 | Public |
| `~BleCentral()` | 52 | Public |
| `void setEnabled(bool enable)` | 54 | Public |
| `void setPeripheralAddress(const quint64 &address)` | 56 | Public |
| `void setAuthorizationCode(const quint128 &uuid, const QByteArray &code)` | 57 | Public |
| `State state() const` | 59 | Public |
| `QByteArrayList servicesUuid() const` | 61 | Public |
| `QByteArrayList characteristicsUuid() const` | 62 | Public |
| `QByteArrayList descriptionsUuid() const` | 63 | Public |
| `bool readCharacteristic(const quint128 &uuid)` | 65 | Public |
| `bool writeCharacteristic(const quint128 &uuid, const QByteArray &ba)` | 66 | Public |
| `bool readDescriptor(const quint128 &uuid)` | 67 | Public |
| `bool writeDescriptor(const quint128 &uuid, const QByteArray &ba)` | 68 | Public |
| `const DescriptorInfo *descriptionInfo(const quint128 &uuid)` | 88 | Private |
| `const CharacteristicInfo *characteristicInfo(const quint128 &uuid)` | 89 | Private |
| `void startDeviceDiscovery()` | 91 | Private |
| `void connectToDevice()` | 92 | Private |
| `void addDevice(const QBluetoothDeviceInfo &)` | 95 | Private |
| `void deviceDiscoveryFinished()` | 96 | Private |
| `void deviceDiscoveryError(QBluetoothDeviceDiscoveryAgent::Error)` | 97 | Private |
| `void deviceConnected()` | 100 | Private |
| `void deviceDisconnected()` | 101 | Private |
| `void addService(const QBluetoothUuid &newService)` | 102 | Private |
| `void serviceDiscoveryFinished()` | 103 | Private |
| `void serviceStateChanged(QLowEnergyService::ServiceState newState)` | 106 | Private |

**Signals:**

| Signal | Line |
|---|---|
| `void accessible(bool yes)` | 71 |
| `void error(QBluetoothDeviceDiscoveryAgent::Error newError)` | 74 |
| `void error(QLowEnergyController::Error newError)` | 77 |
| `void error(QLowEnergyService::ServiceError newError)` | 80 |
| `void characteristicChanged(const quint128 &uuid, const QByteArray &newValue)` | 81 |
| `void characteristicRead(const quint128 &uuid, const QByteArray &value)` | 82 |
| `void characteristicWritten(const quint128 &uuid, const QByteArray &newValue)` | 83 |
| `void descriptorRead(const quint128 &uuid, const QByteArray &value)` | 84 |
| `void descriptorWritten(const quint128 &uuid, const QByteArray &newValue)` | 85 |

**Enum:**

| Enum | Values | Line |
|---|---|---|
| `BleCentral::State` | `Disabled, Discovering, Ready` | 49 |

**`#define` constants (`blecentral.cpp`):**

| Symbol | Line | Value |
|---|---|---|
| `DISCOVERY_RETRY_WAIT` | 7 | `3000` |
| `RECONNECT_RETRY_WAIT` | 8 | `2000` |
| `WAIT_FOR_CONNECTED` | 9 | `10000` |
| `WAIT_FOR_READY` | 10 | `30000` |

---

## Findings

---

**A12-1** · HIGH · Hardcoded AES IV — fixed IV destroys CBC security

**Description:** `aescrypto.cpp` line 124 embeds a literal 16-byte IV directly in the source:
```cpp
memcpy(iv->iv, "\x3d\xaf\xba\x42\x9d\x9e\xb4\x30\xb4\x22\xda\x80\x2c\x9f\xac\x41", 16);
```
CBC mode requires a unique, unpredictable IV for every encryption operation. Using the same IV for every call means that two identical plaintexts will always produce identical ciphertexts, and an adversary who observes multiple messages can detect repeated content. It also facilitates chosen-plaintext attacks. Even though the key is hardware-derived (MTP), the fixed IV leaks structural information. This is a well-known cryptographic misuse classified under CWE-329 (Not Using a Random IV with CBC Mode).

**Fix:** Generate a cryptographically random 16-byte IV per encryption call (e.g., via `/dev/urandom` or `RAND_bytes`), prepend it to the ciphertext, and read it back before decryption. Do not store or reuse the IV across calls.

---

**A12-2** · HIGH · Typo in public API: `descrypt` instead of `decrypt`

**Description:** `aescrypto.h` line 17 declares `static QByteArray descrypt(const QByteArray &in)`. This is a misspelling of `decrypt`. Although functionally minor, this identifier is part of the public API surface. Any caller already written against this name will silently continue with the misspelled symbol, and no compiler warning is raised. This also makes the API confusing to every future reader who must determine whether `descrypt` is intentional or erroneous.

**Fix:** Rename to `decrypt` throughout (`aescrypto.h` line 17 and `aescrypto.cpp` line 156). Update all call sites. If backward compatibility matters, add a deprecated alias.

---

**A12-3** · HIGH · `AesCrypto::aes()` silently returns empty `QByteArray` on non-ARM builds

**Description:** The entire implementation body of `AesCrypto::aes()` (lines 67–145) and `AesCrypto::enableMtp()` (lines 24–58) is guarded by `#ifdef __arm__`. On any non-ARM host (desktop build, CI, unit-test environment) both `encrypt()` and `descrypt()` silently return an empty `QByteArray`. There is no compile-time or run-time indication to the caller that the operation produced no output. This means data silently passes through as empty bytes on non-target builds, which could mask correctness defects in higher-level code.

**Fix:** Add a `static_assert` or `#error` for unsupported architectures, or emit a `qWarning()` / `Q_UNREACHABLE()` at the non-ARM fallback return so callers can detect the no-op at runtime. If a desktop stub is intentional, document it explicitly and have it return an error indicator rather than empty data.

---

**A12-4** · MEDIUM · C-style casts in `aescrypto.cpp`

**Description:** Lines 32–33 and 78–79 use C-style casts to strip `const` from string literals for `::strcpy`:
```cpp
::strcpy((char *) sa.salg_type, "skcipher");
::strcpy((char *) sa.salg_name, "mtp");
```
Line 116 uses a C-style cast to dereference control message data:
```cpp
* (__u32 *) CMSG_DATA(cmsg) = encrypt ? ALG_OP_ENCRYPT : ALG_OP_DECRYPT;
```
Line 122 similarly casts `CMSG_DATA(cmsg)` to `struct af_alg_iv *`. C-style casts bypass type-safety checks and hide the intent of the conversion (const-cast vs. reinterpret-cast vs. static-cast). They are a known source of subtle bugs and are flagged by `-Wold-style-cast`.

**Fix:** Replace C-style casts with explicit C++ casts (`reinterpret_cast`, `const_cast`, `static_cast`) appropriate to each context. For the `strcpy` calls, use `strncpy` (or safer Qt equivalents) with the correctly-typed buffer.

---

**A12-5** · MEDIUM · `strcpy` into fixed-size `sockaddr_alg` fields without bounds check

**Description:** Lines 32–33 and 78–79 use `::strcpy` to write into `sa.salg_type` and `sa.salg_name`, which are fixed-size character arrays (14 and 64 bytes respectively per `linux/if_alg.h`). While the literal strings used here (`"skcipher"`, `"mtp"`, `"cbc(aes)"`) are safely short, the pattern is dangerous and fragile: there is no bounds enforcement. A future developer who changes the algorithm name string to something longer will introduce a stack buffer overflow with no warning.

**Fix:** Replace `::strcpy` with `::strncpy` (or `std::memcpy`) paired with an explicit size limit equal to the field capacity, or use a safe wrapper that asserts the length at compile time.

---

**A12-6** · MEDIUM · Return value of `sendmsg()` and `read()` ignored in `aescrypto.cpp`

**Description:** Lines 134–135 and lines 140–141 call `sendmsg()` and `read()` without checking the return value:
```cpp
sendmsg(tfd, &msg, MSG_MORE);
read(tfd, ba.data() + i, 1024);
```
A failure of either call would silently produce a `QByteArray` containing uninitialised or stale data, which would then be passed back to the caller as if encryption had succeeded. This is a correctness and potential security issue: the caller cannot distinguish a successful encryption from a partial or failed one.

**Fix:** Check the return values of `sendmsg()` and `read()`. On error or short read/write, close the file descriptors, log an appropriate message, and return an empty or error-signalling `QByteArray`.

---

**A12-7** · MEDIUM · `AesCrypto` mixes static public API with instance state (`m_mtpEnabled`)

**Description:** `AesCrypto::encrypt()` and `AesCrypto::descrypt()` are public `static` methods, yet they internally construct a temporary `AesCrypto` instance (`AesCrypto aesCrypto`) to call the non-static `aes()` method. Meanwhile, `m_mtpEnabled` is a `static` member shared across all instances. This design is incoherent: the class simultaneously acts as a stateless utility (`static` public interface) and a stateful singleton (`static bool m_mtpEnabled`). The inconsistency makes the ownership and initialization semantics unclear and makes the class non-testable.

**Fix:** Decide on one design. If the class is meant to be a stateless utility, make `aes()`, `enableMtp()`, and `m_mtpEnabled` all static and remove the unnecessary instance creation. If it is meant to be a stateful object, remove `static` from the public interface and require callers to manage the object lifetime.

---

**A12-8** · MEDIUM · Commented-out code blocks in `blecentral.cpp`

**Description:** Multiple commented-out code blocks remain in production source:

- Line 30: `//connect(m_reconnectTimer, &QTimer::timeout, this, &BleCentral::connectToDevice);` — original reconnect logic replaced by a lambda, old connection left as a comment.
- Line 37: `);//&BleCentral::startDeviceDiscovery);` — inline comment fragment at the end of the lambda lambda block, residue of a previous refactor.
- Line 85: `//SerialLogger::log("[BLE:STATE] Starting device discovery\r\n");` — disabled logging statement.
- Lines 158, 161: `//if (m_previousAddress != m_device.address()) {` and `//}` — address-change guard removed but left commented.
- Lines 266, 272: Two `SerialLogger::log` calls disabled.

Commented-out code is a maintenance liability: it obscures intent, confuses reviewers, and can mislead static analysis tools.

**Fix:** Remove all commented-out code. If the address-change optimisation (lines 158/161) is intentionally deferred, document it with a `// TODO:` comment referencing a ticket. Use version control history rather than source comments to preserve old logic.

---

**A12-9** · MEDIUM · `SerialLogger::log()` called unconditionally at constructor time

**Description:** `blecentral.cpp` line 31 calls `SerialLogger::log("Reconnect timeout\r\n")` in the constructor body, immediately after a commented-out `connect()` call. This log statement appears to be debugging residue from the refactor that replaced `connectToDevice` with the inline lambda. It fires every time a `BleCentral` object is constructed, polluting the serial log with a message that has no associated event.

**Fix:** Remove the orphaned `SerialLogger::log("Reconnect timeout\r\n")` statement on line 31. If the intent is to log when the reconnect timer fires, move the log call inside the lambda body.

---

**A12-10** · MEDIUM · Duplicate `SerialLogger::log` call in `addDevice()`

**Description:** `blecentral.cpp` lines 115 and 121 both call `SerialLogger::log("[BLE:STATE] Device found MAC=...")` with identical content. Line 115 runs for every BLE device found (before the address filter), and line 121 runs again immediately after confirming the device address matches. This means the matching device address is logged twice with the same message, potentially causing confusion during log analysis.

**Fix:** Remove the duplicate on line 121 or differentiate the two messages (e.g., line 115: `"Device seen"`, line 121: `"Target device matched"`).

---

**A12-11** · MEDIUM · `requestConnectionUpdate()` called twice with identical parameters

**Description:** Identical `QLowEnergyConnectionParameters` blocks are set up and applied at both `deviceConnected()` (lines 185–189) and `serviceStateChanged()` when all services are discovered (lines 295–299):
```cpp
QLowEnergyConnectionParameters p;
p.setIntervalRange(15, 15);
p.setLatency(5);
p.setSupervisionTimeout(5000);
m_controller->requestConnectionUpdate(p);
```
This is a verbatim code duplication. The rationale for requesting the same parameters at two different lifecycle points is not documented. If the parameters ever need to change, they must be updated in two places.

**Fix:** Extract the connection parameters into a private helper method (e.g., `applyConnectionParameters()`) and call it from both locations. Optionally document why the update is repeated after service discovery.

---

**A12-12** · LOW · Magic number bitmasks in `enableMtp()` undocumented

**Description:** `aescrypto.cpp` lines 49 and 54 use magic integer constants with no explanatory comment:
```cpp
if (status == 0xffff || (status & 0x1000014)) { ... }
if ((status & 0x3) == 0x3) { ... }
```
The meaning of these bitmask values cannot be determined without reading the referenced kernel driver source (`nuc970-crypto.c`). Only a partial comment (lines 43–47) points to the driver, but the actual bit-field semantics are not explained.

**Fix:** Define named constants or enumerators for each bitmask (e.g., `MTP_STATUS_ERROR_MASK`, `MTP_STATUS_ENABLED_MASK`) and add a brief comment explaining what each bit represents per the kernel driver documentation.

---

**A12-13** · LOW · `AesCrypto` public header exposes no platform guard or capability check

**Description:** `aescrypto.h` presents a clean platform-neutral interface, but the implementation silently no-ops on non-ARM builds (see A12-3). There is no `#ifdef`, `Q_OS_LINUX`, or capability-query method in the header to signal to callers whether AES operations will actually work. A caller on a non-ARM host has no compile-time indication of this limitation.

**Fix:** Add a `static bool isSupported()` method (or equivalent `#if` guard) to the header so callers can detect at compile time or runtime whether the crypto subsystem is operational on the current platform.

---

**A12-14** · LOW · `BleCentral` `#define` timing constants should be `static constexpr`

**Description:** `blecentral.cpp` lines 7–10 define four timing constants using the C preprocessor:
```cpp
#define DISCOVERY_RETRY_WAIT    3000
#define RECONNECT_RETRY_WAIT    2000
#define WAIT_FOR_CONNECTED      10000
#define WAIT_FOR_READY          30000
```
Preprocessor macros have no type, no scope, and bypass the C++ type system. They cannot be inspected in a debugger and are replaced everywhere without regard to context.

**Fix:** Replace with `static constexpr int` (or `static constexpr std::chrono::milliseconds`) defined at the top of the `.cpp` file or in the class definition if they need to be accessed from tests.

---

**A12-15** · LOW · `m_serviceIndex` is uninitialized in the constructor member-initialization list

**Description:** `blecentral.h` declares `int m_serviceIndex` at line 125. The constructor in `blecentral.cpp` (lines 14–40) initializes `m_discoveryTimer`, `m_reconnectTimer`, `m_discoveryAgent`, `m_controller`, and `m_state` in its member-initialization list, but `m_serviceIndex` is not listed. It is first assigned at line 253 inside `serviceDiscoveryFinished()`. On compilers that do not zero-initialize plain members, `m_serviceIndex` holds an indeterminate value between object construction and the first call to `serviceDiscoveryFinished()`, which is a latent defect.

**Fix:** Add `m_serviceIndex(0)` to the constructor's member-initialization list.

---

**A12-16** · INFO · `cbuf` size calculation assumes `af_alg_iv.iv` overhead is exactly 4 bytes

**Description:** `aescrypto.cpp` line 99 allocates the control message buffer as:
```cpp
char cbuf[CMSG_SPACE(4) + CMSG_SPACE(20)];
```
The value `20` is `sizeof(struct af_alg_iv) + 16` = `4 + 16`. This relies on the implicit assumption that `struct af_alg_iv` (which contains `__u32 ivlen` and a flexible array `__u8 iv[]`) has exactly 4 bytes of overhead. This is true on current Linux ARM targets, but the calculation is fragile: it could silently break if the kernel struct layout changes or if compiled for a target with different alignment rules.

**Fix:** Replace `20` with `sizeof(struct af_alg_iv) + 16` to express the intent explicitly.

---

## Summary Table

| ID | Severity | Title |
|---|---|---|
| A12-1 | HIGH | Hardcoded AES IV — fixed IV destroys CBC security |
| A12-2 | HIGH | Typo in public API: `descrypt` instead of `decrypt` |
| A12-3 | HIGH | `AesCrypto::aes()` silently returns empty `QByteArray` on non-ARM builds |
| A12-4 | MEDIUM | C-style casts in `aescrypto.cpp` |
| A12-5 | MEDIUM | `strcpy` into fixed-size `sockaddr_alg` fields without bounds check |
| A12-6 | MEDIUM | Return values of `sendmsg()` and `read()` ignored |
| A12-7 | MEDIUM | `AesCrypto` mixes static public API with instance state (`m_mtpEnabled`) |
| A12-8 | MEDIUM | Commented-out code blocks in `blecentral.cpp` |
| A12-9 | MEDIUM | Orphaned `SerialLogger::log()` call in `BleCentral` constructor |
| A12-10 | MEDIUM | Duplicate `SerialLogger::log` call in `addDevice()` |
| A12-11 | MEDIUM | `requestConnectionUpdate()` duplicated verbatim at two lifecycle points |
| A12-12 | LOW | Magic number bitmasks in `enableMtp()` undocumented |
| A12-13 | LOW | `AesCrypto` public header exposes no platform guard or capability check |
| A12-14 | LOW | `BleCentral` timing `#define` constants should be `static constexpr` |
| A12-15 | LOW | `m_serviceIndex` uninitialized in constructor member-initialization list |
| A12-16 | INFO | `cbuf` size calculation uses implicit `af_alg_iv` overhead assumption |

**Totals:** 3 HIGH, 8 MEDIUM, 4 LOW, 1 INFO
# Pass 4 Agent A13 — Code Quality

**Audit run:** 2026-02-28-01
**Branch:** master
**Files reviewed:**
- `platform/canbus.h`
- `platform/canbus.cpp`
- `platform/gnssreceiver.h`
- `platform/gnssreceiver.cpp`

---

## Reading Evidence

### `platform/canbus.h`

**Class:** `EM070::CanBus` (extends `QObject`)

**Enums / Types / Constants:**

| Kind | Name | Location |
|------|------|----------|
| Enum | `CanDeviceId { CAN2, CAN1 }` | Line 16 |
| Struct | `Request { QCanBusFrame frame; quint32 interval; qint32 timer; }` | Lines 18–23 |

**Methods (public unless noted):**

| Line | Signature | Notes |
|------|-----------|-------|
| 25 | `explicit CanBus(CanDeviceId id = CAN1, QObject *parent = nullptr)` | Constructor |
| 26 | `~CanBus()` | Destructor |
| 28 | `void initialize()` | |
| 30 | `void setXferEnabled(bool enable)` | |
| 31 | `bool isXferEnabled() const` | Inline |
| 33 | `void setPower(bool on)` | |
| 34 | `bool isEnabled() const` | Inline |
| 36 | `bool setBaudRate(int baudRate)` | |
| 37 | `int baudRate() const` | Inline |
| 39 | `void addRequest(quint32 id, const QByteArray &ba, quint32 interval)` | |
| 40 | `QList<Request> getRequests()` | Non-const, returns by value |
| 41 | `void clearRequests()` | |
| 43 | `void addFilter(quint32 identifier)` | |
| 44 | `void clearFilters()` | |
| 45 | `void applyFilters()` | |
| 47 | `void writeFrameDirect(quint32 id, const QByteArray &ba)` | |
| 49 | `void removeRequests(quint32 id)` | |
| 54 | `void error(QCanBusDevice::CanBusError canBusError)` | Signal |
| 55 | `void read(quint32 identifier, const QByteArray &ba)` | Signal |
| 58 | `void sendRequest()` | Protected |
| 61 | `void readFrame()` | Private |
| 62 | `void handleError(QCanBusDevice::CanBusError error)` | Private |

**Commented-out code in header:**
- Line 22: `//int timerId;` — commented-out struct field inside `Request`
- Line 51: `//QCanBusDevice* canBusDevice() const {return m_canBusDevice;}` — commented-out accessor

---

### `platform/canbus.cpp`

**Macros / Constants defined:**

| Name | Value | Line |
|------|-------|------|
| `REQUEST_TIMER` | `100` | 14 |
| `CANBUS_DEBUG` | `0` | 15 |

**Methods (all are implementations of `EM070::CanBus`):**

| Line | Signature |
|------|-----------|
| 17 | `CanBus::CanBus(CanDeviceId id, QObject *parent)` |
| 28 | `CanBus::~CanBus()` |
| 34 | `void CanBus::initialize()` |
| 51 | `void CanBus::sendRequest()` |
| 89 | `void CanBus::setXferEnabled(bool enable)` |
| 105 | `void CanBus::setPower(bool on)` |
| 178 | `bool CanBus::setBaudRate(int baudRate)` |
| 193 | `void CanBus::addRequest(quint32 id, const QByteArray &ba, quint32 interval)` |
| 208 | `void CanBus::clearRequests()` |
| 214 | `void CanBus::addFilter(quint32 identifier)` |
| 219 | `void CanBus::clearFilters()` |
| 224 | `void CanBus::applyFilters()` |
| 258 | `void CanBus::writeFrameDirect(quint32 id, const QByteArray &ba)` |
| 264 | `void CanBus::readFrame()` |
| 274 | `void CanBus::handleError(QCanBusDevice::CanBusError canBusError)` |
| 285 | `void CanBus::removeRequests(quint32 id)` |

**Commented-out code in .cpp:**
- Line 116: `//return;` inside `setPower()` after gpio36 open failure
- Line 120: `//return;` inside `setPower()` after gpio38 open failure
- Line 148: `// return;` inside `setPower()` after `ip link set` failure

---

### `platform/gnssreceiver.h`

**Class:** `EM070::GnssReceiver` (extends `QObject`)

**Macros / Constants:**

| Name | Value | Line |
|------|-------|------|
| `MAX_POINTS` | `8` | 7 |

**Methods (public unless noted):**

| Line | Signature | Notes |
|------|-----------|-------|
| 17 | `explicit GnssReceiver(QObject *parent = nullptr)` | Constructor |
| 18 | `void portStateChanged(bool open)` | |
| 19 | `void reset()` | |
| 20 | `void changeUpdateTime()` | |
| 22 | `quint8 satelliteCount() const` | Inline |
| 23 | `qint32 latitude() const` | Inline |
| 24 | `qint32 longitude() const` | Inline |
| 25 | `qint32 lastLatitude() const` | Inline |
| 26 | `qint32 lastLongitude() const` | Inline |
| 27 | `qint16 speed() const` | Inline |
| 28 | `qint16 course() const` | Inline |
| 29 | `quint32 distance() const` | Inline |
| 30 | `quint32 sumOfDistance() const` | Inline |
| 31 | `quint32 altitude() const` | Inline |
| 32 | `bool locked() const` | Inline |
| 33 | `quint32 hpe() const` | Inline — performs HDOP-to-accuracy conversion inline |
| 34 | `quint32 hdop() const` | Inline |
| 35 | `qint64 age()` | Non-const |
| 36 | `quint8 warn() const` | Inline |
| 37 | `void setWarn(quint8 n)` | Inline |
| 38 | `quint8 quality() const` | Inline |
| 39 | `void setQuality(quint8 n)` | Inline |
| 40 | `quint16 markerCnt() const` | Inline |
| 41 | `void setMarkerCnt(quint16 n)` | Inline |
| 42 | `quint32 pathLatitude(int n)` | |
| 43 | `void setPathLatitude(int n, quint32 lat)` | |
| 44 | `quint32 pathLongitude(int n)` | |
| 45 | `void setPathLongitude(int n, quint32 lon)` | |
| 46 | `void gpsDebugPrint()` | |
| 47 | `bool inPoly2(const CIGCONF::gpsPosStruct *gpsPos, const CIGCONF::polygonStruct *polygon)` | **Declared, never defined — dead/broken** |
| 48 | `bool pointInPolygon(int polyCorners, CIGCONF::position me, CIGCONF::position *points)` | |
| 49 | `double degrees2radians(double degrees)` | |
| 51 | `void timerEvent(QTimerEvent *)` | Protected |
| 54 | `void sendGmtpMessage(CIGCONF::GmtpMessage msg, const QByteArray &extra = QByteArray())` | Signal |
| 57 | `void readData()` | Private |
| 58 | `void parseData(const QByteArray &ba)` | Private |
| 59 | `void cumulateDistance()` | Private |
| 60 | `static quint32 calculateDistance(qint32 lat1, qint32 lng1, qint32 lat2, qint32 lng2)` | Private static |

---

### `platform/gnssreceiver.cpp`

**Macros / Constants:**

| Name | Value | Line |
|------|-------|------|
| `FILE_GNSS_PORT` | `"/dev/ttyUSB1"` | 11 |
| `EARTH_R` | `6371000UL` | 13 |

**Methods:**

| Line | Signature |
|------|-----------|
| 17 | `GnssReceiver::GnssReceiver(QObject *parent)` |
| 44 | `void GnssReceiver::timerEvent(QTimerEvent *event)` |
| 51 | `void GnssReceiver::portStateChanged(bool open)` |
| 72 | `void GnssReceiver::readData()` |
| 101 | `void GnssReceiver::parseData(const QByteArray &ba)` |
| 192 | `void GnssReceiver::reset()` |
| 212 | `void GnssReceiver::changeUpdateTime()` |
| 222 | `void GnssReceiver::cumulateDistance()` |
| 339 | `quint32 GnssReceiver::calculateDistance(qint32 lat1, qint32 lng1, qint32 lat2, qint32 lng2)` |
| 369 | `quint32 GnssReceiver::pathLatitude(int n)` |
| 380 | `void GnssReceiver::setPathLatitude(int n, quint32 lat)` |
| 390 | `quint32 GnssReceiver::pathLongitude(int n)` |
| 401 | `void GnssReceiver::setPathLongitude(int n, quint32 lon)` |
| 409 | `void GnssReceiver::gpsDebugPrint()` |
| 424 | `double GnssReceiver::degrees2radians(double degrees)` |
| 428 | `bool GnssReceiver::pointInPolygon(int polyCorners, CIGCONF::position me, CIGCONF::position *points)` |
| 448 | `qint64 GnssReceiver::age()` |

**Commented-out code in .cpp:**
- Line 216: `//m_timerId = startTimer(gCfg->gpsUpdateTime() * 1000);` in `changeUpdateTime()`
- Line 224: `//qDebug() << ...` in `cumulateDistance()`
- Lines 123–126: Commented-out MK2 relay/geofence block inside `parseData()`
- Lines 314–317: Commented-out `MK2 RELAY CONTROL OP` block (first instance) in `cumulateDistance()`
- Lines 324–326: Commented-out `MK2 RELAY CONTROL OP` block (second instance) in `cumulateDistance()`
- Line 331: `//sendGmtpMessage(CIGCONF::GMTP_GPSE);` at bottom of `cumulateDistance()`

---

## Findings

---

**A13-1** · HIGH · `inPoly2()` declared in public interface but never implemented

**Description:** `gnssreceiver.h` line 47 declares `bool inPoly2(const CIGCONF::gpsPosStruct *gpsPos, const CIGCONF::polygonStruct *polygon)` as a public method. No definition exists anywhere in the codebase. Any translation unit that calls this method will fail to link. The declaration pollutes the public API with a broken contract and signals an incomplete or abandoned feature. This is classic dead/broken code — the linker will catch it at build time if called, but callers may rely on its presence in headers.

**Fix:** Either implement the function body in `gnssreceiver.cpp` or remove the declaration from `gnssreceiver.h` entirely. If it is intended future work, move it to a clearly-marked private stub or a separate feature branch.

---

**A13-2** · HIGH · `changeUpdateTime()` is functionally broken — timer restart is commented out

**Description:** `gnssreceiver.cpp` line 216 shows `//m_timerId = startTimer(gCfg->gpsUpdateTime() * 1000);` is commented out. The method kills the existing timer but never restarts it. Consequently, any caller invoking `changeUpdateTime()` (e.g., `backgroundworker.cpp` line 1275) permanently stops GPS update reporting without any indication of error. The public method name implies a configuration change, not a shutdown, making this a silent, misleading behaviour defect.

**Fix:** Uncomment line 216 in `gnssreceiver.cpp` so that `changeUpdateTime()` kills and restarts the timer with the updated period. If the intent is truly to stop reporting, rename the method to `stopUpdates()` and document accordingly.

---

**A13-3** · MEDIUM · Suppressed `return` statements after fatal GPIO failures in `setPower()`

**Description:** `canbus.cpp` lines 116, 120, and 148 each contain a commented-out `//return;` after critical failures: GPIO file open failures (lines 116, 120) and `ip link set` subprocess failure (line 148). When these failures occur, execution continues silently as if the setup succeeded. If gpio36 or gpio38 cannot be opened, write calls at lines 127–130 and 169–172 operate on a closed file handle. If the `ip link set` command fails, `connectDevice()` is still called, potentially on an interface that was never configured.

**Fix:** Uncomment and restore the `return` statements at lines 116, 120, and 148 so that `setPower()` aborts on unrecoverable hardware errors. At minimum, a function-level return should follow each critical failure, consistent with the already-present `qCritical()` log calls.

---

**A13-4** · MEDIUM · Signed/unsigned comparison: `quint32 last = -1` in `applyFilters()`

**Description:** `canbus.cpp` line 232 initialises `quint32 last = -1`. Assigning `-1` to an unsigned type is implementation-defined-safe in C++ (it wraps to `UINT_MAX`), but it is a style violation and triggers compiler warnings with `-Wsign-conversion` or `-Wall`. The intent is to represent "no previous value", which is a sentinel that happens to work only because no valid CAN ID equals `UINT_MAX`. This is fragile and non-obvious.

**Fix:** Replace with `quint32 last = UINT_MAX;` using the named constant, and add a comment explaining the sentinel value. Alternatively, use `std::optional<quint32>` to express "no prior value" without relying on a magic sentinel.

---

**A13-5** · MEDIUM · Magic number `47757857` in `calculateDistance()` with no explanation

**Description:** `gnssreceiver.cpp` lines 349 and 357 use the literal `47757857` as a scaling factor. The surrounding comment (`// dlng / 10000000 * PI / 180 * R << 32`) explains the intent, but the magic constant itself is the pre-computed product of `(1/10000000) * (PI/180) * 6371000 * 2^32` (approximately). Without this derivation in the code, maintainers cannot verify correctness, and the constant `EARTH_R` defined on line 13 is never used in the calculation despite its presence.

**Fix:** Replace `47757857` with a named compile-time constant or a `constexpr` expression that makes the derivation explicit, e.g.:
```cpp
// (PI / 180 / 10000000) * EARTH_R * (1 << 32)
constexpr qint64 kLatLngScaleFactor = 47757857;
```
Also either use `EARTH_R` in the derivation or remove the unused macro.

---

**A13-6** · MEDIUM · `EARTH_R` macro defined but never used

**Description:** `gnssreceiver.cpp` line 13 defines `#define EARTH_R 6371000UL` but this constant is never referenced anywhere in the file. `calculateDistance()` uses the hardcoded magic number `47757857` which implicitly incorporates the Earth radius. The unused macro misleads readers into thinking the radius is applied symbolically when it is not.

**Fix:** Remove the `EARTH_R` macro, or integrate it into a named `constexpr` expression for `kLatLngScaleFactor` (see A13-5) so the radius is both visible and used.

---

**A13-7** · MEDIUM · Leaky abstraction: CAN protocol bit constants exposed in `applyFilters()`

**Description:** `canbus.cpp` lines 241–249 directly manipulate raw CAN framing bits: `(1 << 29)` to detect extended frame format, mask values `0x3ffff00` and `0x3ff`, and the `MatchExtendedFormat` / `MatchBaseFormat` constants. These hardware-protocol details are embedded in the implementation without named constants or explanatory abstractions. The value `0x3ffff00` is particularly opaque — it is not a standard CAN mask and its derivation is not documented.

**Fix:** Replace magic bit masks with named constants (e.g., `kCanExtendedFrameBit`, `kExtendedFrameIdMask`, `kBaseFrameIdMask`) defined at file or class scope with comments explaining their purpose and derivation.

---

**A13-8** · MEDIUM · `getRequests()` is non-const and returns a mutable copy of internal state

**Description:** `canbus.h` line 40 declares `QList<Request> getRequests()` as non-const with no `const` qualifier. The method returns a full copy of `m_requests` by value. Callers cannot call this on a `const CanBus` reference, making it impossible to use in read-only contexts. The naming convention `getX()` is inconsistent with the rest of the class, which uses Qt-style accessors without the `get` prefix (e.g., `baudRate()`, `isXferEnabled()`).

**Fix:** Declare the method `const` and rename it to `requests()` to match the existing naming convention: `QList<Request> requests() const { return m_requests; }`.

---

**A13-9** · MEDIUM · Commented-out legacy MK2 relay control blocks in `cumulateDistance()`

**Description:** `gnssreceiver.cpp` contains two commented-out blocks of legacy MK2 relay control code at lines 314–317 and 324–326, both marked `/** MK2 RELAY CONTROL OP ... **/`. An additional commented-out block at lines 123–126 of `parseData()` also references legacy relay/geofence logic. These blocks reference undefined symbols (`RELAY3_MODE`, `RELAY3_MODE_GFNCE_NO`, `BSP_RLY3_STATE`, `BSP_RLY3_SET`, `BSP_RLY3_CLR`) and represent dead legacy code that should have been removed, not commented out. They increase maintenance burden and cause reader confusion about the current state of relay control.

**Fix:** Remove all commented-out legacy relay control blocks from `parseData()` and `cumulateDistance()`. If relay integration is needed in the future, it should be re-implemented cleanly against the current hardware abstraction layer, not resurrected from commented-out MK2 code.

---

**A13-10** · MEDIUM · `timerEvent()` handler is an empty stub — misleading dead code

**Description:** `gnssreceiver.cpp` lines 44–49 define `GnssReceiver::timerEvent(QTimerEvent *event)` with a guard `if (m_timerId != event->timerId()) return;` followed by an empty body. The handler starts the timer in `portStateChanged()` (line 60) but does nothing when the timer fires. This is dead code — the timer slot does not exist, and `timerEvent` is the Qt fallback mechanism. A reader may incorrectly assume periodic work occurs here.

**Fix:** Either remove `timerEvent()` entirely and implement a `QTimer`-based slot (consistent with the `CanBus` pattern), or add the intended periodic behaviour inside the handler body. At minimum, if the handler is intentionally empty, add a comment explaining why.

---

**A13-11** · LOW · `age()` is not declared `const` despite having no side effects

**Description:** `gnssreceiver.h` line 35 declares `qint64 age()` without the `const` qualifier, even though the method only reads `m_timestamp` and calls `QDateTime::currentMSecsSinceEpoch()`. All other read-only accessors in the same class are correctly declared `const`. This inconsistency prevents `age()` from being called on a `const GnssReceiver` reference and breaks const-correctness throughout the API.

**Fix:** Add `const` to the declaration: `qint64 age() const;` and to the definition in `gnssreceiver.cpp`.

---

**A13-12** · LOW · `Request::timer` field type mismatch: `qint32` vs `quint32 interval`

**Description:** In `canbus.h` lines 20–22, `Request::interval` is `quint32` but `Request::timer` is `qint32`. In `canbus.cpp` line 69, timer is decremented (`request.timer -= REQUEST_TIMER`) and compared against zero (`if (request.timer <= 0)`). The mixed signed/unsigned types are inconsistent; if `interval` is assigned to `timer` (line 204: `request.timer = interval`), a large `quint32` interval value could produce undefined behaviour or sign wrap when stored in `qint32`.

**Fix:** Make both fields the same type. Since the countdown logic requires signed comparison against zero, either change `interval` to `qint32` or keep both as `quint32` and use an explicit `== 0` comparison (ensuring the unsigned value wraps predictably by enforcing `REQUEST_TIMER` divides evenly into all valid intervals).

---

**A13-13** · LOW · Inconsistent indentation and brace style in `pointInPolygon()`

**Description:** `gnssreceiver.cpp` lines 428–446 (`pointInPolygon`) uses 2-space indentation and inconsistent spacing (notably the trailing spaces on lines 430, 444), while the rest of the file uses 4-space indentation with K&R-style braces. This suggests the function was copied from an external source without reformatting. The opening comment `//oddNodes = 1 means within the polygon` is also inconsistently positioned (inline with the opening brace on the same line).

**Fix:** Reformat `pointInPolygon()` to match the 4-space indentation convention used throughout the rest of `gnssreceiver.cpp`. Run `clang-format` with the project's `.clang-format` config if available.

---

**A13-14** · LOW · `#include <math.h>` and `#include <QtMath>` both present in `gnssreceiver.cpp`

**Description:** `gnssreceiver.cpp` lines 8–9 include both `<QtMath>` and `<math.h>`. `<QtMath>` already provides Qt wrappers around standard math functions, and `<math.h>` (C-style header) is redundant. Mixing C-style `<math.h>` with C++ headers is a style violation and can cause macro/function name conflicts in some toolchains.

**Fix:** Remove `#include <math.h>` from `gnssreceiver.cpp`. All required math functions (`M_PI`, `qCos`, `qSqrt`, etc.) are available via `<QtMath>`.

---

**A13-15** · LOW · `sendRequest()` declared `protected` but serves as a private timer slot

**Description:** `canbus.h` line 58 declares `sendRequest()` as `protected`. The method is connected exclusively as a `QTimer::timeout` slot (line 48 of `canbus.cpp`) and is not intended to be called or overridden by subclasses. `CanBus` is not designed as a base class (no virtual destructor, no other virtual methods). Exposing the timer slot as `protected` needlessly widens the access surface.

**Fix:** Move `sendRequest()` to the `private` section of `CanBus`. If subclassing is ever required, promote it back to `protected` deliberately.

---

**A13-16** · INFO · Commented-out struct field `//int timerId` in `Request`

**Description:** `canbus.h` line 22 contains `//int timerId;` commented out inside the `Request` struct. This suggests an earlier design where each request managed its own timer ID. The field is entirely unused and the comment has no explanatory text.

**Fix:** Remove the commented-out field. If the alternative design is of historical interest, document it in a git commit message rather than in source code.

---

**A13-17** · INFO · Commented-out `canBusDevice()` accessor in `canbus.h`

**Description:** `canbus.h` line 51 contains `//QCanBusDevice* canBusDevice() const {return m_canBusDevice;}` commented out. Exposing the raw `QCanBusDevice` pointer in the public interface would break encapsulation, so the accessor was presumably removed, but the commented line was left behind.

**Fix:** Remove the commented-out line entirely.

---

## Summary Table

| ID | Severity | Category | Location | Short Title |
|----|----------|----------|----------|-------------|
| A13-1 | HIGH | Dead / Broken Code | `gnssreceiver.h:47` | `inPoly2()` declared but never implemented |
| A13-2 | HIGH | Dead / Broken Code | `gnssreceiver.cpp:216` | `changeUpdateTime()` permanently stops GPS — timer restart commented out |
| A13-3 | MEDIUM | Error Handling | `canbus.cpp:116, 120, 148` | Suppressed `return` statements after fatal GPIO/subprocess failures |
| A13-4 | MEDIUM | Build Warning | `canbus.cpp:232` | Signed/unsigned: `quint32 last = -1` |
| A13-5 | MEDIUM | Magic Numbers | `gnssreceiver.cpp:349, 357` | Magic number `47757857` — derivation undocumented |
| A13-6 | MEDIUM | Dead Code | `gnssreceiver.cpp:13` | `EARTH_R` macro defined but never used |
| A13-7 | MEDIUM | Leaky Abstraction | `canbus.cpp:241–249` | Raw CAN protocol bit masks without named constants |
| A13-8 | MEDIUM | Style / API | `canbus.h:40` | `getRequests()` non-const and inconsistently named |
| A13-9 | MEDIUM | Commented-out Code | `gnssreceiver.cpp:123–126, 314–317, 324–326` | Legacy MK2 relay control blocks never removed |
| A13-10 | MEDIUM | Dead Code | `gnssreceiver.cpp:44–49` | `timerEvent()` is an empty stub — misleading dead code |
| A13-11 | LOW | Const-correctness | `gnssreceiver.h:35` | `age()` not declared `const` |
| A13-12 | LOW | Type Safety | `canbus.h:20–22` | `Request::timer` (qint32) vs `Request::interval` (quint32) mismatch |
| A13-13 | LOW | Style | `gnssreceiver.cpp:428–446` | Inconsistent indentation in `pointInPolygon()` |
| A13-14 | LOW | Style | `gnssreceiver.cpp:9` | Redundant C-style `<math.h>` alongside `<QtMath>` |
| A13-15 | LOW | Access Control | `canbus.h:58` | `sendRequest()` declared `protected` but should be `private` |
| A13-16 | INFO | Commented-out Code | `canbus.h:22` | Commented-out `timerId` field in `Request` struct |
| A13-17 | INFO | Commented-out Code | `canbus.h:51` | Commented-out `canBusDevice()` accessor |
# Pass 4 Agent A14 — Code Quality

**Audit run:** 2026-02-28-01
**Branch:** master
**Assigned files:**
- `platform/internalrfid.h`
- `platform/internalrfid.cpp`
- `platform/internalrtc.h`
- `platform/internalrtc.cpp`

---

## Reading Evidence

### `platform/internalrfid.h`

**Class:** `EM070::InternalRfid` (inherits `QObject`)

| Function / Method | Line |
|---|---|
| `InternalRfid(QObject *parent = 0)` | 14 |
| `void setEnabled(bool enabled)` | 15 |
| `void response()` (signal) | 18 |
| `void cardData(quint64, quint16, quint32, QByteArray &)` (signal) | 19 |
| `void error(const QString &text)` (signal) | 20 |
| `void readData()` (private) | 23 |
| `void parseData()` (private) | 24 |

**Members:** `QSerialPort *m_serialPort`, `QByteArray m_receiver`

**Types / Constants / Enums defined:** none (all macros are in the `.cpp`)

---

### `platform/internalrfid.cpp`

**Macros defined:**

| Name | Value | Line |
|---|---|---|
| `FILE_SERIAL_PORT` | `"/dev/ttyS2"` | 7 |
| `RECEIVER_MAX_SIZE` | `128` | 8 |

**Functions implemented:**

| Function | Line |
|---|---|
| `InternalRfid::InternalRfid(QObject *parent)` | 12 |
| `InternalRfid::setEnabled(bool enabled)` | 38 |
| `InternalRfid::readData()` | 51 |
| `InternalRfid::parseData()` | 67 |

---

### `platform/internalrtc.h`

**Class:** `EM070::InternalRtc` (no base class; purely static interface)

| Function / Method | Line |
|---|---|
| `static void setRtcTime(QDateTime dateTime = QDateTime())` | 11 |
| `static void setSystemTime()` | 12 |
| `static quint64 euiAddress()` | 13 |

**Types / Constants / Enums defined:** none

---

### `platform/internalrtc.cpp`

**Macros defined:**

| Name | Value | Line |
|---|---|---|
| `FILE_RTC_DEVICE` | `"/dev/rtc1"` | 5 |
| `FILE_RTC_EUI` | `"/sys/devices/platform/nuc970-i2c0/i2c-0/0-006f/eui"` | 6 |

**Functions implemented:**

| Function | Line |
|---|---|
| `InternalRtc::setRtcTime(QDateTime dateTime)` | 10 |
| `InternalRtc::setSystemTime()` | 24 |
| `InternalRtc::euiAddress()` | 31 |

---

## Findings

---

**A14-1** · HIGH · `::stime()` is a deprecated/removed POSIX syscall

**Description:** `internalrtc.cpp` line 15 calls `::stime(&sec)`, guarded by `#ifdef __arm__`. `stime()` was removed from POSIX.1-2008 and is absent from glibc 2.31+ (Linux kernel 5.1+). On a modern toolchain this call will fail to compile or silently link against an unavailable symbol. It also requires the process to run as root (CAP_SYS_TIME), raising privilege concerns. The correct replacement is `clock_settime(CLOCK_REALTIME, ...)`.

**Fix:** Replace `::stime(&sec)` with a `clock_settime` call:
```cpp
struct timespec ts { static_cast<time_t>(sec), 0 };
::clock_settime(CLOCK_REALTIME, &ts);
```
Include `<time.h>` / `<ctime>` and remove the `stime` dependency. Verify the process holds `CAP_SYS_TIME` rather than running as root.

---

**A14-2** · HIGH · Device paths hard-coded as `#define` macros leak into binary and are not configurable at runtime for `internalrtc.cpp`

**Description:** `internalrtc.cpp` defines `FILE_RTC_DEVICE` (`/dev/rtc1`) and `FILE_RTC_EUI` (`/sys/devices/platform/nuc970-i2c0/i2c-0/0-006f/eui`) as plain `#define` macros (lines 5-6). Unlike `internalrfid.cpp` which at least provides a `QT_RFID_SERIAL_PORT` environment-variable override, the RTC paths have no override mechanism. The `sysfs` path embeds the exact hardware bus topology (`nuc970-i2c0`, bus address `0-006f`), making the binary non-portable and impossible to test on a development host without modifying source. This is a leaky abstraction: implementation detail of hardware topology is baked into the compiled artifact.

**Fix:** Promote both paths to `static constexpr QLatin1String` constants (or `QStringLiteral`) and add environment-variable overrides mirroring the pattern already used in `InternalRfid`. For the `sysfs` EUI path, consider reading the path from a platform configuration file rather than hard-coding bus topology.

---

**A14-3** · MEDIUM · Device path `FILE_SERIAL_PORT` hard-coded as `#define` macro in `internalrfid.cpp`

**Description:** `internalrfid.cpp` line 7 defines `FILE_SERIAL_PORT` as `"/dev/ttyS2"` via a C preprocessor macro. Although an environment variable override exists (`QT_RFID_SERIAL_PORT`), the macro itself is a raw `#define` rather than a typed constant, providing no type safety. The macro name is misleading because `FILE_` prefix suggests a file-system path constant, whereas Qt serial port APIs take a port name string.

**Fix:** Replace the `#define` with a `static constexpr QLatin1String` or `static const QString` in the translation unit, keeping the env-var override logic. Rename to reflect its purpose, e.g., `DefaultRfidPortName`.

---

**A14-4** · MEDIUM · `RECEIVER_MAX_SIZE` defined as untyped `#define` macro

**Description:** `internalrfid.cpp` line 8 defines `RECEIVER_MAX_SIZE 128` as a plain `#define`. This provides no type information (it could be used as `int`, `size_t`, or any numeric type without warning) and pollutes the preprocessor namespace.

**Fix:** Replace with `static constexpr int ReceiverMaxSize = 128;` (or `qsizetype`) so the constant has an explicit type and respects C++ scoping rules.

---

**A14-5** · MEDIUM · `QProcess::execute()` used with a concatenated string command — injection risk and deprecated API pattern

**Description:** `internalrtc.cpp` lines 21 and 27 construct a shell command by string concatenation (`QString cmd("hwclock -w -f "); cmd += QStringLiteral(FILE_RTC_DEVICE);`) and pass it to `QProcess::execute(QString)`. The single-argument overload of `QProcess::execute` is deprecated since Qt 5.15 in favour of `QProcess::execute(const QString &program, const QStringList &arguments)`. Additionally, passing a single concatenated string relies on the Qt implementation splitting arguments, which can mishandle paths containing spaces. While `FILE_RTC_DEVICE` is a compile-time constant here, the pattern is fragile and generates deprecation warnings on Qt 5.15+.

**Fix:** Refactor to:
```cpp
QProcess::execute(QStringLiteral("hwclock"), { QStringLiteral("-w"), QStringLiteral("-f"), QStringLiteral(FILE_RTC_DEVICE) });
```
This eliminates the deprecation warning and makes argument boundaries explicit.

---

**A14-6** · MEDIUM · `qDebug()` production log in `parseData()` emits raw card data on every read

**Description:** `internalrfid.cpp` line 79 unconditionally calls `qDebug() << "Read internal card data: " << ba;` inside `parseData()`, which fires on every RFID card presentation. In a production build where `QT_NO_DEBUG_OUTPUT` is not defined, this writes potentially sensitive card data (facility code, card number in hex) to the application log, creating an uncontrolled information disclosure path.

**Fix:** Wrap the statement in a `#ifdef QT_DEBUG` guard, or replace it with a conditional `qCDebug` category that can be toggled at runtime without a rebuild:
```cpp
qCDebug(lcRfid) << "Read internal card data:" << ba;
```
Ensure that card data logging is explicitly disabled in the production build configuration.

---

**A14-7** · MEDIUM · Signal `cardData` passes `QByteArray &` (non-const reference) — unsafe across queued connections

**Description:** Both `InternalRfid` (header line 19) and `WiegandRfid` (`wiegandrfid.h` line 20) declare the `cardData` signal with a `QByteArray &readerOutput` parameter (non-const lvalue reference). Qt signals delivered over a queued connection (across threads) cannot marshal non-const references — the value is silently treated as a copy but the API promises a reference. This is a latent bug: if the connection type is ever changed to `Qt::QueuedConnection` or the objects are moved to separate threads, the reference semantics silently break. It also violates Qt signal best-practice (signals should use `const T &` or pass by value).

**Fix:** Change the signal signature to `const QByteArray &readerOutput` (const reference) or `QByteArray readerOutput` (by value) in both `InternalRfid` and `WiegandRfid`, and update all `emit` call sites accordingly.

---

**A14-8** · LOW · Constructor default argument uses `= 0` instead of `= nullptr`

**Description:** `internalrfid.h` line 14 declares `explicit InternalRfid(QObject *parent = 0)`. Using the integer literal `0` as a null pointer constant is valid C++ but considered poor style since C++11; `nullptr` is the correct typed null-pointer constant and is already used pervasively in the rest of the codebase.

**Fix:** Change `= 0` to `= nullptr` in `InternalRfid`'s constructor declaration and definition.

---

**A14-9** · LOW · Stale `#include <QDebug>` with unconditional use — should be conditional

**Description:** `internalrfid.cpp` line 4 includes `<QDebug>` unconditionally. Given that the only use is the `qDebug()` call at line 79 (see A14-6), if that call is wrapped in a `#ifdef QT_DEBUG` guard, the include must also be guarded or moved to a debug-only block to avoid the header being pulled into release builds unnecessarily.

**Fix:** Resolve A14-6 first; then guard or remove the `<QDebug>` include to match the guarded call site.

---

**A14-10** · LOW · `setSystemTime()` has misleading comment implying it should never be called

**Description:** `internalrtc.h` line 12 contains the comment `// no need to call this as which will be done on OS booting`. The grammar is broken ("as which will be done") and the statement contradicts the function's public visibility — if callers truly should never call it, the function should be `private` or removed. Exposing it publicly while commenting that it should not be called is a documentation inconsistency and an invitation for misuse.

**Fix:** If the function is genuinely only called by OS boot scripts (not by application code), remove it from the public header or mark it `private`. If it is legitimately callable at runtime, rewrite the comment to explain when it is appropriate to call it.

---

**A14-11** · LOW · Inconsistent alignment of `#R` branch local variable declarations in `parseData()`

**Description:** `internalrfid.cpp` lines 98-107: the `#R` branch declares `QList<QByteArray> bas` inside the `else if` block, while other branches use only inline expressions. The variable name `bas` (plural of `ba`) is cryptic. This is a minor style inconsistency but reduces readability in an already dense parsing function.

**Fix:** Rename `bas` to `parts` or `fields` for clarity. Consider extracting the entire parsing of each card-format variant into named private helper methods.

---

**A14-12** · LOW · Missing `long` cast for `::stime` argument type mismatch on 64-bit ARM

**Description:** `internalrtc.cpp` line 14 stores `dateTime.toSecsSinceEpoch()` (returns `qint64`) into `long sec`. On LP64 platforms (64-bit Linux), `long` and `qint64` are both 64-bit, so this is fine. However, on ILP32 (32-bit ARM — the guarded `#ifdef __arm__` target), `long` is 32-bit and will overflow after 2038-01-19 (the Year-2038 problem). `::stime` takes `const time_t *`; on 32-bit ARM with a modern kernel and `time_t` defined as 64-bit (`CONFIG_COMPAT_32BIT_TIME`), using `long` rather than `time_t` is the wrong type.

**Fix:** Declare `time_t sec = static_cast<time_t>(dateTime.toSecsSinceEpoch());` to use the correct type regardless of platform word size. This also becomes moot if `stime` is replaced per A14-1.

---

## Summary Table

| ID | Severity | Title |
|---|---|---|
| A14-1 | HIGH | `::stime()` is a deprecated/removed POSIX syscall |
| A14-2 | HIGH | RTC device paths hard-coded with no runtime override |
| A14-3 | MEDIUM | Serial port path defined as untyped `#define` macro |
| A14-4 | MEDIUM | `RECEIVER_MAX_SIZE` defined as untyped `#define` macro |
| A14-5 | MEDIUM | `QProcess::execute(QString)` deprecated single-argument form used |
| A14-6 | MEDIUM | Unconditional `qDebug()` emits raw card data in production |
| A14-7 | MEDIUM | Signal `cardData` passes non-const `QByteArray &` — unsafe for queued connections |
| A14-8 | LOW | Constructor default argument uses `= 0` instead of `= nullptr` |
| A14-9 | LOW | `<QDebug>` included unconditionally; should match guarded call site |
| A14-10 | LOW | `setSystemTime()` has misleading and grammatically broken comment |
| A14-11 | LOW | Cryptic variable name `bas` and style inconsistency in `parseData()` |
| A14-12 | LOW | `long sec` type is wrong on 32-bit ARM — Year-2038 exposure |

**Total findings: 12** (2 HIGH, 5 MEDIUM, 5 LOW)
# Pass 4 Agent A15 — Code Quality

**Audit run:** 2026-02-28-01
**Branch:** master
**Files reviewed:**
- `platform/modemport.h`
- `platform/modemport.cpp`
- `platform/powersupply.h`
- `platform/powersupply.cpp`

---

## Reading Evidence

### `platform/modemport.h`

**Class:** `EM070::ModemPort` (inherits `QObject`)

| Line | Name | Kind |
|------|------|------|
| 14 | `explicit ModemPort(QObject *parent = nullptr)` | constructor |
| 15 | `bool sendCmd(const QByteArray &cmd)` | public method |
| 16 | `void resetModem()` | public method |
| 17 | `void setEnabled(bool enable)` | public method |
| 18 | `void setEcho(bool enable)` | public inline method |
| 19 | `bool isWwx()` | public inline method |
| 20 | `void setWwx(bool isWwx)` | public inline method |
| 23 | `void portStateChanged(bool open)` | signal |
| 24 | `void response(bool ok, const QByteArrayList &content)` | signal |
| 27 | `void openPort()` | private method |
| 28 | `void portError()` | private method |
| 29 | `void readData()` | private method |
| 30 | `void parseData(const QByteArray &line)` | private method |

**Members:**

| Line | Name | Type |
|------|------|------|
| 32 | `m_serialPort` | `QSerialPort *` |
| 33 | `m_timer` | `QTimer *` |
| 34 | `m_tryTimes` | `int` |
| 35 | `m_receiver` | `QByteArray` |
| 36 | `m_response` | `QByteArrayList` |
| 37 | `m_cmdLine` | `QByteArray` |
| 38 | `m_echo` | `bool` |
| 39 | `m_wwx` | `bool` |

**Types/enums/constants defined:** none in this header.

---

### `platform/modemport.cpp`

**Macros defined:**

| Line | Name | Value |
|------|------|-------|
| 7 | `FILE_MODEM_PORT_WWX` | `"/dev/ttyUSB2"` |
| 8 | `FILE_MODEM_PORT` | `"/dev/ttyUSB3"` |

**Functions:**

| Line | Name |
|------|------|
| 12 | `ModemPort::ModemPort(QObject *parent)` |
| 50 | `void ModemPort::resetModem()` |
| 68 | `void ModemPort::setEnabled(bool enable)` |
| 90 | `void ModemPort::openPort()` |
| 108 | `void ModemPort::portError()` |
| 125 | `bool ModemPort::sendCmd(const QByteArray &cmd)` |
| 139 | `void ModemPort::readData()` |
| 168 | `void ModemPort::parseData(const QByteArray &line)` |

---

### `platform/powersupply.h`

**Class:** `EM070::PowerSupply` (inherits `QObject`)

**Enums:**

| Line | Name | Enumerators |
|------|------|-------------|
| 16 | `BlankMode` | `UnBlank = 0`, `BlankPowerDown = 4` |
| 17 | `ChargeState` | `NotCharging = 0`, `PreCharging = 1`, `FastCharging = 2`, `ChargeDone = 3` |
| 18 | `ChargeFault` | `NoFault = 0`, `InputFault = 1`, `ThermalShutdown = 2`, `ChargeTimerExpired = 3` |

**Public methods:**

| Line | Name | Kind |
|------|------|------|
| 19 | `explicit PowerSupply(QObject *parent = nullptr)` | constructor |
| 21 | `bool isIgnitionOn() const` | inline getter |
| 23 | `bool isPowerGood() const` | inline getter |
| 24 | `bool isBatteryAvailable() const` | inline getter |
| 25 | `ChargeState chargeState() const` | inline getter |
| 26 | `ChargeFault chargeFault() const` | inline getter |
| 27 | `quint16 voltage() const` | inline getter |
| 28 | `qint16 current() const` | inline getter |
| 29 | `quint16 temperature() const` | inline getter |
| 30 | `quint16 remainingCapacity() const` | inline getter |
| 31 | `quint16 designCapacity() const` | inline getter |
| 32 | `quint16 timeToEmpty() const` | inline getter |
| 33 | `quint16 timeToFull() const` | inline getter |
| 35 | `static void reboot()` | static method |
| 36 | `static void poweroff()` | static method |
| 37 | `static void setBlankMode(BlankMode mode)` | static method |
| 38 | `static void setTouchPower(bool on)` | static method |
| 39 | `static void charge(bool enable)` | static method |
| 40 | `static void setBatteryEnabled(bool enable)` | static method |

**Signals:**

| Line | Name |
|------|------|
| 43 | `void ignitionStateChanged(bool on)` |
| 44 | `void batteryStatusRead(bool avail, int state, int fault, quint16 voltage, qint16 current, quint16 temp, quint16 remainingCapacity)` |

**Private methods:**

| Line | Name |
|------|------|
| 47 | `void readIgnitionState()` |
| 48 | `void readChargerStatus()` |
| 49 | `void readGaugeStatus()` |

**Private members:**

| Line | Name | Type | Comment |
|------|------|------|---------|
| 51 | `m_ignitionFile` | `QFile` | |
| 52 | `m_notifier` | `QSocketNotifier *` | |
| 53 | `m_timer` | `QTimer *` | |
| 55 | `m_ignitionOn` | `bool` | |
| 56 | `m_powerGood` | `bool` | |
| 57 | `m_batteryAvailable` | `bool` | false means VBat < Vsysmin |
| 58 | `m_chargeState` | `ChargeState` | |
| 59 | `m_chargeFault` | `ChargeFault` | |
| 60 | `m_voltage` | `quint16` | in mV |
| 61 | `m_current` | `qint16` | in mA |
| 62 | `m_temperature` | `quint16` | in Celsius degree |
| 63 | `m_remainingCapacity` | `quint16` | in % |
| 64 | `m_designCapacity` | `quint16` | in mAH |
| 65 | `m_timeToEmpty` | `quint16` | in minitues [sic] |
| 66 | `m_timeToFull` | `quint16` | in minitues [sic] |

---

### `platform/powersupply.cpp`

**Macros defined:**

| Line | Name | Value |
|------|------|-------|
| 8 | `QUERY_INTERVAL` | `6000` |
| 10 | `FILE_IGNITION` | `"/sys/devices/platform/nuc970-gpio.0/gpio/gpio225/value"` |
| 11 | `FILE_FB_BLANK` | `"/sys/devices/platform/nuc970-lcd/graphics/fb0/blank"` |
| 12 | `FILE_TOUCH_POWER` | `"/sys/touchscreen/power_state"` |
| 13 | `FILE_CHARGE_EN` | `"/sys/class/gpio/gpio160/value"` |
| 14 | `FILE_BATFET_DISABLE` | `"/sys/devices/platform/nuc970-i2c0/i2c-0/0-006b/power_supply/bq24190-charger/f_batfet_disable"` |
| 15 | `FILE_PG_STAT` | `"/sys/devices/platform/nuc970-i2c0/i2c-0/0-006b/power_supply/bq24190-charger/f_pg_stat"` |
| 16 | `FILE_VSYS_STAT` | `"/sys/devices/platform/nuc970-i2c0/i2c-0/0-006b/power_supply/bq24190-charger/f_vsys_stat"` |
| 17 | `FILE_CHRG_STAT` | `"/sys/devices/platform/nuc970-i2c0/i2c-0/0-006b/power_supply/bq24190-charger/f_chrg_stat"` |
| 18 | `FILE_CHRG_FAULT` | `"/sys/devices/platform/nuc970-i2c0/i2c-0/0-006b/power_supply/bq24190-charger/f_chrg_fault"` |
| 19 | `FILE_NTC_FAULT` | `"/sys/devices/platform/nuc970-i2c0/i2c-0/0-006b/power_supply/bq24190-charger/f_ntc_fault"` |
| 20 | `FILE_GAUGE_REGS` | `"/sys/devices/platform/nuc970-i2c0/i2c-0/0-0055/show_regs"` |

**Functions:**

| Line | Name |
|------|------|
| 24 | `PowerSupply::PowerSupply(QObject *parent)` |
| 53 | `void PowerSupply::readIgnitionState()` |
| 65 | `void PowerSupply::readChargerStatus()` |
| 123 | `void PowerSupply::readGaugeStatus()` |
| 181 | `void PowerSupply::reboot()` |
| 208 | `void PowerSupply::poweroff()` |
| 214 | `void PowerSupply::setBlankMode(BlankMode mode)` |
| 229 | `void PowerSupply::setTouchPower(bool on)` |
| 240 | `void PowerSupply::charge(bool enable)` |
| 251 | `void PowerSupply::setBatteryEnabled(bool enable)` |

---

## Findings

---

**A15-1** · MEDIUM · Commented-out code in `ModemPort::sendCmd` (modemport.cpp:132)

**Description:** Line 132 contains a commented-out `SerialLogger::log` call for outgoing modem commands:
```cpp
//SerialLogger::log("[MODEM:SEND] " + cmd + "\r\n");
```
Similarly, line 171 in `parseData` has a commented-out log for received modem data:
```cpp
//SerialLogger::log("[MODEM:RECV] " + line + "\r\n");
```
These blocks were apparently disabled deliberately (since `m_echo` was added as an alternative mechanism), but the dead code remains in the source. A companion commented-out block also exists at modemport.cpp:29:
```cpp
//m_wwx = true;
```
This appears to be a leftover from a port-detection experiment where `m_wwx` was supposed to be set automatically when `FILE_MODEM_PORT` did not exist, but that behavior was suppressed without explanation.

**Fix:** Remove all three commented-out code lines (modemport.cpp:29, 132, 171). If any of these represent intentional design decisions (e.g., disabling the wwx auto-detection), document the rationale in a comment rather than leaving dead code.

---

**A15-2** · MEDIUM · Commented-out code in `PowerSupply::readGaugeStatus` (powersupply.cpp:130–131)

**Description:** Lines 130–131 contain a commented-out early-return guard:
```cpp
// if (!m_batteryAvailable)
//    return;
```
The surrounding block comment (lines 125–129) explains *why* the guard was disabled — to allow charging even when the battery is fully discharged — but the dead code lines still remain in source, creating noise and ambiguity.

**Fix:** Remove the commented-out `if` block. If the comment block explaining the rationale is still valid, keep it as a plain prose comment without the dead code lines.

---

**A15-3** · LOW · Commented-out code in `PowerSupply::parseData` — modem response terms (modemport.cpp:195–199)

**Description:** Lines 195–199 contain a block of commented-out `startsWith` conditions that were apparently considered but not implemented:
```cpp
//            line.startsWith("BUSY") ||
//            line.startsWith("RING") ||
//            line.startsWith("NO CARRIER") ||
//            line.startsWith("NO ANSWER") ||
//            line.startsWith("NO DIALTONE") ||
```
These suggest dial-up/voice-call handling was considered and then abandoned. They carry no explanatory note.

**Fix:** Remove the commented-out lines. If these responses are genuinely not expected on the data-only modem interface in use, a brief comment stating "voice call responses not applicable" is clearer than dead code.

---

**A15-4** · LOW · Commented-out code in `PowerSupply::reboot` — shell script embedded in comment (powersupply.cpp:183–203)

**Description:** The body of `reboot()` is preceded by a multi-line comment (lines 183–203) that reproduces the entire content of the `/etc/pvd/reboot` shell script inline. While this is informational, it duplicates maintenance-sensitive logic that lives in an external script. If the script changes, the comment will silently drift out of sync.

**Fix:** Replace the verbatim script reproduction with a brief prose description (e.g., "Calls /etc/pvd/reboot which shuts down the modem and network interfaces before rebooting the system"). Reference a documentation location or the script path for readers who want full details.

---

**A15-5** · MEDIUM · Hardware sysfs paths hard-coded as `#define` macros in implementation file (powersupply.cpp:10–20)

**Description:** Ten hardware-specific sysfs paths are defined as `#define` macros at the top of `powersupply.cpp`. These paths encode the SoC part number (`nuc970`), I2C bus topology (`i2c-0/0-006b`), GPIO numbers (`gpio160`, `gpio225`), and charger chip model (`bq24190`). Any board revision or kernel driver update that changes a sysfs path requires edits to this file. There is no mechanism to override paths at compile time or runtime for different board variants.

Examples:
```cpp
#define FILE_IGNITION       "/sys/devices/platform/nuc970-gpio.0/gpio/gpio225/value"
#define FILE_CHARGE_EN      "/sys/class/gpio/gpio160/value"
#define FILE_BATFET_DISABLE "/sys/devices/platform/nuc970-i2c0/i2c-0/0-006b/power_supply/bq24190-charger/f_batfet_disable"
```

**Fix:** Collect the sysfs path strings into a named constant struct or a dedicated `platform_paths.h` header, or make them compile-time configurable via a build variable. As a minimum, group them with a comment indicating the target hardware revision so the scope of change is explicit.

---

**A15-6** · LOW · Device node paths hard-coded as `#define` macros in implementation file (modemport.cpp:7–8)

**Description:** The modem serial port device paths are defined as `#define` macros at the top of the `.cpp` file:
```cpp
#define FILE_MODEM_PORT_WWX "/dev/ttyUSB2"
#define FILE_MODEM_PORT     "/dev/ttyUSB3"
```
There is also a non-ARM fallback hard-coded as the string literal `"COM4"` on line 33, with no macro. These paths are tied to a specific USB enumeration order that can vary between kernel versions or USB attachment sequences.

**Fix:** Promote these to named constants in the header or a shared platform configuration header. The `"COM4"` literal on line 33 should also be named and placed alongside the other port definitions. Consider supporting runtime override via the existing `QT_MOBILE_SERIAL_PORT` environment variable mechanism for both port variants.

---

**A15-7** · MEDIUM · `QProcess::startDetached` called with a combined command-and-argument string (modemport.cpp:61)

**Description:** `resetModem()` invokes:
```cpp
QProcess::startDetached("/etc/pvd/mobile -r");
```
The single-string overload of `QProcess::startDetached` was deprecated in Qt 5.15 in favour of the overload that takes the program path and a separate `QStringList` of arguments. Using the deprecated single-string form is a build warning source on Qt 5.15+ and will be removed in Qt 6.

**Fix:** Replace with the two-argument form:
```cpp
QProcess::startDetached("/etc/pvd/mobile", {"-r"});
```

---

**A15-8** · LOW · Magic numbers used in `readGaugeStatus` without symbolic names (powersupply.cpp:145–175)

**Description:** `readGaugeStatus` uses a series of `mid(N)` calls with bare integer offsets (5, 10, 14, 7, 6, 6, 6) to parse fixed-position fields from a comma-separated register dump string. These offsets correspond to the byte lengths of field-name prefixes in the sysfs output (e.g., `"volt="` is 5 chars, `"current_now="` is 12 chars). No comment names the corresponding field labels, making the parsing logic opaque and fragile.

Additionally, the voltage thresholds on lines 148 and 150 (`4100` and `4300` mV) are bare integer literals with no named constants or comments explaining what charge levels they represent.

**Fix:** Define named constants or an inline comment for each `mid` offset that identifies the prefix being skipped. For example:
```cpp
constexpr int VOLT_PREFIX_LEN = 5; // "volt="
```
Similarly, define named constants for the charge threshold voltages:
```cpp
constexpr int CHARGE_ENABLE_THRESHOLD_MV  = 4100;
constexpr int CHARGE_DISABLE_THRESHOLD_MV = 4300;
```

---

**A15-9** · LOW · `BlankMode` enum gap between `UnBlank` (0) and `BlankPowerDown` (4) (powersupply.h:16)

**Description:** The enum is declared as:
```cpp
enum BlankMode {UnBlank, BlankPowerDown = 4};
```
Values 1, 2, and 3 are implicit holes in the enum range. The `setBlankMode` implementation ignores the enum value entirely for the non-`UnBlank` case and always writes `"4"` to the framebuffer blank sysfs node:
```cpp
default:
    file.write("4");
    break;
```
This means any caller who constructs a `BlankMode` with a value of 1, 2, or 3 (possible via a cast) will silently write `"4"` rather than the intended value. The Linux framebuffer blank interface supports values 0–4 (FB_BLANK_UNBLANK through FB_BLANK_POWERDOWN), so values 1–3 are valid and meaningful intermediates that the enum design implies should be reachable but are not.

**Fix:** Either enumerate all meaningful FB_BLANK values (0 = unblank, 1 = normal blank, 2 = vsync suspend, 3 = hsync suspend, 4 = powerdown) or document explicitly that only `UnBlank` and `BlankPowerDown` are supported by this hardware. The `switch` in `setBlankMode` should use the actual enum value when writing the sysfs file rather than the hard-coded `"4"`.

---

**A15-10** · LOW · `m_timer->start(QUERY_INTERVAL)` called twice in `readGaugeStatus` (powersupply.cpp:120, 178)

**Description:** `readChargerStatus` calls `readGaugeStatus` on line 117, then immediately calls `m_timer->start(QUERY_INTERVAL)` on line 120 to schedule the next poll. However, `readGaugeStatus` itself also calls `m_timer->start(QUERY_INTERVAL)` at line 178. Because `readGaugeStatus` is only ever called from `readChargerStatus`, the timer is restarted twice per poll cycle. The second start (line 120 in `readChargerStatus`) is a no-op because `QTimer::start` on an already-active single-shot timer that has not fired simply resets the interval — but the intent is obscured and the placement is misleading.

**Fix:** Remove the `m_timer->start(QUERY_INTERVAL)` call from inside `readGaugeStatus` (line 178). The timer restart belongs in `readChargerStatus` only, after all status reads are complete.

---

**A15-11** · LOW · Inconsistent `inline` method style in `modemport.h` (modemport.h:18–20)

**Description:** Three inline methods in the `ModemPort` header have inconsistent formatting. `setEcho` at line 18 omits the space before the opening brace and uses no space after the function signature:
```cpp
void setEcho(bool enable) {m_echo = enable;}
```
`isWwx` at line 19 has a trailing semicolon after the closing brace, which is valid C++ but inconsistent:
```cpp
bool isWwx() {return m_wwx;};
```
The `PowerSupply` inline getters in `powersupply.h` are consistently formatted with spaces inside braces (e.g., `{return m_ignitionOn;}`). The style difference between the two headers in the same namespace is a minor consistency issue.

**Fix:** Apply consistent inline formatting. For `modemport.h`, add spaces around the body content and remove the spurious trailing semicolon on `isWwx`:
```cpp
void setEcho(bool enable) { m_echo = enable; }
bool isWwx() { return m_wwx; }
void setWwx(bool isWwx) { m_wwx = isWwx; }
```

---

**A15-12** · LOW · Typo in `powersupply.h` member comments: "minitues" (powersupply.h:65–66)

**Description:** The inline comments on lines 65 and 66 read:
```cpp
quint16 m_timeToEmpty;      // in minitues
quint16 m_timeToFull;       // in minitues
```
"minitues" is a misspelling of "minutes".

**Fix:** Correct to "minutes" on both lines.

---

**A15-13** · INFO · `qDebug()` trace left in production code paths (modemport.cpp:102, 118, 131, 170)

**Description:** Four `qDebug()` calls remain in `ModemPort`:
- Line 102: `qDebug() << "ModemPort open";`
- Line 118: `qDebug() << "ModemPort closed";`
- Line 131: `qDebug() << "ModemPort >" << m_cmdLine;` (logs every outgoing AT command)
- Line 170: `qDebug() << "ModemPort <" << line;` (logs every received line)

Lines 131 and 170 will produce high-frequency output on every AT command transaction. In release builds without `QT_NO_DEBUG_OUTPUT` defined, this constitutes unnecessary I/O and potential log volume concern.

**Fix:** Guard high-frequency debug traces (lines 131 and 170) with `#ifdef QT_DEBUG` or replace with the existing `SerialLogger` mechanism controlled by `m_echo`, so they are not emitted in production firmware builds.

---

## Summary Table

| ID | Severity | Location | Short Title |
|----|----------|----------|-------------|
| A15-1 | MEDIUM | modemport.cpp:29, 132, 171 | Commented-out code: log calls and wwx auto-detect |
| A15-2 | MEDIUM | powersupply.cpp:130–131 | Commented-out early-return guard in readGaugeStatus |
| A15-3 | LOW | modemport.cpp:195–199 | Commented-out modem response terms (BUSY, RING, etc.) |
| A15-4 | LOW | powersupply.cpp:183–203 | Verbatim shell script reproduced in comment |
| A15-5 | MEDIUM | powersupply.cpp:10–20 | Hardware sysfs paths hard-coded as #define macros |
| A15-6 | LOW | modemport.cpp:7–8, 33 | Device node paths hard-coded as #define macros |
| A15-7 | MEDIUM | modemport.cpp:61 | Deprecated QProcess::startDetached single-string overload |
| A15-8 | LOW | powersupply.cpp:145–175 | Magic numbers in sysfs field offset parsing and voltage thresholds |
| A15-9 | LOW | powersupply.h:16, powersupply.cpp:218–226 | BlankMode enum gap; implementation ignores enum value |
| A15-10 | LOW | powersupply.cpp:120, 178 | Timer restarted twice per poll cycle |
| A15-11 | LOW | modemport.h:18–20 | Inconsistent inline method style (trailing semicolon, missing spaces) |
| A15-12 | LOW | powersupply.h:65–66 | Typo "minitues" in member comments |
| A15-13 | INFO | modemport.cpp:102, 118, 131, 170 | High-frequency qDebug() calls left in production code paths |
# Pass 4 Agent A16 — Code Quality

**Audit run:** 2026-02-28-01
**Branch:** master
**Repo root:** `C:/Projects/cig-audit/repos/mark3-pvd`
**Files reviewed:**
- `platform/pwmbacklight.h`
- `platform/pwmbacklight.cpp`
- `platform/pwmbeeper.h`
- `platform/pwmbeeper.cpp`
- `platform/seriallogger.h`
- `platform/seriallogger.cpp`

---

## Reading Evidence

### `platform/pwmbacklight.h`

**Class:** `EM070::PwmBacklight` (extends `QObject`)

| Name | Kind | Line |
|------|------|------|
| `State` | enum | 15 |
| `State::NoChange` | enum value | 15 |
| `State::Brighter` | enum value | 15 |
| `State::Darker` | enum value | 15 |
| `PwmBacklight(QObject *parent)` | constructor | 16 |
| `~PwmBacklight()` | destructor | 17 |
| `setAutoBrightness(bool enable)` | public method | 18 |
| `isAutoBrightness() const` | public inline method | 19 |
| `brightness()` | public static method | 21 |
| `setBrightness(quint8 val)` | public static method | 22 |
| `luxRead(int lux)` | signal | 25 |
| `timerEvent(QTimerEvent *)` | protected override | 28 |
| `parse(int lux)` | private method | 31 |
| `adjust(int lux)` | private method | 32 |
| `readLux()` | private method | 33 |
| `m_alsPowerFile` | `QFile` member | 35 |
| `m_alsLuxFile` | `QFile` member | 36 |
| `m_brightnessMap` | `QMap<int,int>` member | 37 |
| `m_luxQueue` | `QQueue<int>` member | 38 |
| `m_autoBrightness` | `bool` member | 39 |
| `m_timerId` | `int` member | 40 |
| `m_state` | `State` member | 41 |
| `m_stateCount` | `quint8` member | 42 |
| `m_currentLux` | `int` member | 43 |

**Constants / macros defined in `pwmbacklight.cpp`:**

| Name | Value | Line |
|------|-------|------|
| `FILE_BRIGHTNESS` | sysfs path string | 6 |
| `FILE_ALS_POWER` | sysfs path string | 7 |
| `FILE_ALS_RANGE` | sysfs path string | 8 |
| `FILE_ALS_LUX` | sysfs path string | 9 |
| `TIMER_INTERVAL` | `250` (ms) | 11 |
| `TWO_SECONDS` | `7` (tick count) | 12 |
| `THREE_SECONDS` | `11` (tick count) | 13 |
| `MAX_QUEUE_SIZE` | `20` | 15 |
| `X1P1(v)` | threshold macro | 17 |
| `X1P2(v)` | threshold macro | 18 |

---

### `platform/pwmbeeper.h`

**Class:** `EM070::PwmBeeper` (extends `QObject`)

| Name | Kind | Line |
|------|------|------|
| `BeepType` | enum | 15 |
| `BeepType::BeepOn` | enum value | 15 |
| `BeepType::BeepSilent` | enum value | 15 |
| `BeepType::BeepOff` | enum value | 15 |
| `PwmBeeper(bool autoDelete, QObject *parent)` | constructor | 18 |
| `~PwmBeeper()` | destructor | 19 |
| `setFrequency(quint16 frequency)` | public inline method | 20 |
| `beep(quint16 milliseconds)` | public method | 21 |
| `beep(quint16 frequency, quint16 milliseconds)` | public method | 22 |
| `beep(qint16 count, quint16 msecOn, quint16 msecOff)` | public method | 23 |
| `stop()` | public method | 24 |
| `timeout()` | private slot | 27 |
| `setBeep(bool on)` | private method | 28 |
| `m_timerOn` | `QTimer *` member | 30 |
| `m_timerOff` | `QTimer *` member | 31 |
| `m_file` | `QFile` member | 32 |
| `m_autoDelete` | `bool` member | 33 |
| `m_frequency` | `quint16` member | 34 |
| `m_beeping` | `bool` member | 35 |
| `m_count` | `qint16` member | 36 |
| `m_msecOn` | `quint16` member | 37 |
| `m_msecOff` | `quint16` member | 38 |

**Constants / macros defined in `pwmbeeper.cpp`:**

| Name | Value | Line |
|------|-------|------|
| `FILE_BEEPER` | `"/dev/input/event3"` | 8 |

---

### `platform/seriallogger.h`

**Class:** `SerialLogger` (no base class, pure-static utility)

| Name | Kind | Line |
|------|------|------|
| `log(const QByteArray &message)` | public static method | 9 |
| `setSerialPort(EM070::UserPort *serial)` | public static method | 10 |
| `m_serial` | `static EM070::UserPort *` member | 13 |

**Constants / macros defined in `seriallogger.cpp`:**

| Name | Value | Line |
|------|-------|------|
| `ENABLE_SL_FILE` | `0` | 5 |
| `SERIAL_LOG_FILE` | `"/mnt/sd/sl.log"` | 6 |

---

## Findings

---

**A16-1** · HIGH · Broken include guard in `pwmbacklight.h`

**Description:** Line 1 of `pwmbacklight.h` opens with `#ifndef PWMBACKLIGHT_H`, but line 2 defines `BRIGHTNESS_H` instead of `PWMBACKLIGHT_H`. These two macros are completely independent, so the guard never fires: on any second inclusion within the same translation unit the preprocessor evaluates `#ifndef PWMBACKLIGHT_H` as true (the macro was never defined), re-processes the entire header, and redeclares `class PwmBacklight` — a hard compiler error. The name `BRIGHTNESS_H` also appears to be a leftover from a previous file name or copy-paste from an earlier draft.

**Fix:** Change line 2 from `#define BRIGHTNESS_H` to `#define PWMBACKLIGHT_H` so it matches the guard on line 1. Alternatively, replace the entire traditional guard with `#pragma once`.

---

**A16-2** · MEDIUM · Dead `BeepType` enum in public API (`pwmbeeper.h:15`)

**Description:** `enum BeepType {BeepOn, BeepSilent, BeepOff}` is declared public at line 15 of `pwmbeeper.h`. No `beep()` overload, no internal method, and no call site in the codebase (confirmed by repository-wide search) references `BeepType` or any of its values. The three `beep()` overloads use `quint16` and `qint16` raw integers. The presence of a public, unused enum in a hardware driver creates ambiguity: integrators may attempt to pass `BeepType` values to `beep()` and find no matching overload. `BeepSilent` implies a distinct beep mode that is entirely unimplemented.

**Fix:** If `BeepType` is not planned for near-term use, remove the enum entirely. If it is intended to replace the raw-integer API, implement the corresponding overload (`void beep(BeepType type, quint16 milliseconds)`) and deprecate the `bool`-based internal `setBeep()`.

---

**A16-3** · MEDIUM · Large commented-out brightness map block (`pwmbacklight.cpp:48–59`)

**Description:** Lines 48–59 contain a 12-entry `m_brightnessMap` initialisation block wrapped in a `/* ... */` comment. The comment was replaced by the two-entry linear map on lines 60–61. The old table is completely dead and will never execute. The values inside it (e.g. `2047 >> 3` = 255, brightness levels up to 2047) suggest a different hardware configuration from the one currently deployed. Dead blocks of this size obscure the maintenance history and may mislead future developers into believing the old table is still relevant.

**Fix:** Remove the commented-out block entirely. If the old brightness curve has historical value, preserve it in version control history or in a named git commit message rather than inline in the source.

---

**A16-4** · MEDIUM · Commented-out call on `setAutoBrightness` (`pwmbacklight.cpp:115`)

**Description:** Line 115 reads:
```cpp
m_currentLux = readLux();//m_brightnessMap.key(brightness(), 4000);
```
The inline comment `//m_brightnessMap.key(brightness(), 4000)` is a commented-out expression that was the original initialiser for `m_currentLux`. It is appended directly to the active statement, making the line hard to parse at a glance. The old expression also read the brightness sysfs file and reverse-looked it up in the map — a round-trip that could fail silently — so the replacement is correct, but the dead code should be removed.

**Fix:** Delete the commented fragment, leaving only `m_currentLux = readLux();`.

---

**A16-5** · MEDIUM · `X1P1` and `X1P2` macros carry stale commented-out magic numbers (`pwmbacklight.cpp:17–18`)

**Description:** Both threshold macros embed two alternative magic-number constants side-by-side, with one commented out:
```cpp
#define X1P1(v)  ((v) * 333/*281*/ >> 8)
#define X1P2(v)  ((v) * 333/*307*/ >> 8)
```
The values `281` and `307` (the original 1.1× and 1.2× approximations in Q8 fixed-point) were replaced by the shared value `333`, which approximates neither 1.1 nor 1.2 correctly (333/256 ≈ 1.301). The stale alternatives are embedded inline as comments making the macros obscure. The macro names (`X1P1` = ×1.1, `X1P2` = ×1.2) now misrepresent the actual multiplier used at runtime.

**Fix:** Decide on the correct multiplier for each threshold, update the constants, name them clearly (e.g. `BRIGHTER_RATIO_Q8`, `DARKER_RATIO_Q8`), remove the dead alternatives, and add a comment explaining the fixed-point arithmetic.

---

**A16-6** · MEDIUM · `ENABLE_SL_FILE` permanently disabled compile-time flag (`seriallogger.cpp:5`)

**Description:** `#define ENABLE_SL_FILE 0` permanently disables the file-logging branch on lines 18–30 at compile time. The dead branch includes a `static QFile` that is never constructed, and the path `/mnt/sd/sl.log` is never opened. Permanently-disabled `#if 0`-style blocks that remain in production code are a maintenance hazard: they age without testing, their APIs drift from the live code, and they consume reader attention. The `SERIAL_LOG_FILE` macro on line 6 is also effectively dead.

**Fix:** If file logging is not planned for any near-term build configuration, remove lines 5–6 and lines 18–30 entirely. If it is a debug feature that may be re-enabled, convert it to a proper build-system option (a CMake/qmake `DEFINES` flag) so it can be toggled without editing source, and add a build-configuration note in the file header.

---

**A16-7** · LOW · C-style cast in `pwmbeeper.cpp:77`

**Description:** Line 77 uses a C-style pointer cast:
```cpp
m_file.write((const char *) &event, sizeof(struct input_event));
```
C-style casts in C++ bypass type-system checks and are invisible to static analysers. In this context the cast from `struct input_event *` to `const char *` is the conventional way to serialise a kernel struct to a byte stream, but the explicit `sizeof(struct input_event)` separately increases the risk of a size mismatch if the struct type were ever changed.

**Fix:** Replace with `reinterpret_cast<const char *>(&event)` to make intent explicit. Consider also using `sizeof(event)` instead of `sizeof(struct input_event)` to keep size and object in sync.

---

**A16-8** · LOW · `input_event` struct partially uninitialized in `pwmbeeper.cpp:66–75`

**Description:** The `struct input_event event` declared at line 66 is never zero-initialized. The kernel `input_event` struct contains a `timeval time` field (two `long` members) that is not set before the struct is written to the device file. On most platforms the kernel ignores this field when reading from userspace, but writing stack garbage to a device file is an inadvertent information-disclosure of stack memory contents to any kernel-side observer or sniffer on the input subsystem. The code also does not initialise the `type` field to zero before branching on `on`, so the `type` field is set correctly but only after the `event` variable is allocated with indeterminate contents.

**Fix:** Zero-initialize the struct at declaration: `struct input_event event = {};`. This guarantees all fields are zero before the relevant ones are set.

---

**A16-9** · LOW · `TWO_SECONDS` and `THREE_SECONDS` names are misleading (`pwmbacklight.cpp:12–13`)

**Description:**
```cpp
#define TWO_SECONDS   7    // (7 + 1) * 250
#define THREE_SECONDS 11   // (11 + 1) * 250
```
The comment explains the derivation: `(count + 1) * TIMER_INTERVAL`. `(7+1)*250 = 2000 ms` and `(11+1)*250 = 3000 ms`. The names correctly describe the intent, but the encoding as a raw count (not a duration) means the constants are implicitly coupled to `TIMER_INTERVAL`. If `TIMER_INTERVAL` is ever changed the time duration changes without any compile-time error, and the macro names will silently lie.

**Fix:** Define the thresholds in terms of `TIMER_INTERVAL`:
```cpp
#define TWO_SECONDS_TICKS   (2000 / TIMER_INTERVAL - 1)
#define THREE_SECONDS_TICKS (3000 / TIMER_INTERVAL - 1)
```
This makes the coupling explicit and keeps the values automatically consistent.

---

**A16-10** · LOW · `SerialLogger` is a non-constructible static class without a deleted constructor

**Description:** `SerialLogger` has only static public methods and a single static private data member, making it a pure static-utility class. However, it has no deleted default constructor. Any code could accidentally write `SerialLogger logger;` and instantiate a useless object. The class also does not inherit from `QObject` but uses `EM070::UserPort` in its interface — the `EM070` namespace is used in the header without a forward declaration of the namespace itself, which requires `userport.h` to transitively pull in everything needed.

**Fix:** Add `SerialLogger() = delete;` to the private section to prevent instantiation. Consider making the class `final` if subclassing is also unintended.

---

**A16-11** · LOW · `setBrightness` and `brightness` open and close a file on every call (`pwmbacklight.cpp:179–201`)

**Description:** Both `brightness()` (line 179) and `setBrightness()` (line 191) construct a local `QFile`, open it, perform one read or write, and implicitly close it on destruction — every time they are called. For brightness reads this matters less (they are called infrequently), but `setBrightness` is called from `adjust()`, which is called from the 250 ms timer tick whenever the lux level changes. Opening and closing a sysfs node on every write adds unnecessary system-call overhead compared to holding an open file descriptor (as is already done for `m_alsPowerFile` and `m_alsLuxFile`).

**Fix:** Either promote the brightness sysfs file to a persistent `QFile` member on `PwmBacklight` (analogous to `m_alsPowerFile`) or, since `brightness()` and `setBrightness()` are static, maintain a `static QFile` within the translation unit opened once on first use.

---

**A16-12** · LOW · Trailing whitespace in `parse()` — extra space before `)` (`pwmbacklight.cpp:140`)

**Description:** Line 140 reads `if (m_state != Brighter )` with a stray space before the closing parenthesis. This is a minor style inconsistency; no other conditional in the file has this pattern.

**Fix:** Remove the extra space: `if (m_state != Brighter)`.

---

**A16-13** · INFO · Magic number `8` inside `parse()` with no named constant (`pwmbacklight.cpp:162–169`)

**Description:** Lines 162–169 use the literal `8` as the minimum queue depth and the divisor for averaging:
```cpp
if (size < 8)
    return;
int sum = 0;
for (int i = size - 8; i < size; ++i)
    sum += m_luxQueue.at(i);
adjust(sum >> 3);    // sum / 8
```
`8` corresponds to 8 × 250 ms = 2 seconds of samples, matching the `TWO_SECONDS` concept but expressed as a raw integer in three separate places. `sum >> 3` is the divide-by-8, but is not obviously connected to the `8` above.

**Fix:** Introduce a named constant (e.g. `#define AVG_WINDOW_SIZE 8`) and replace all three occurrences. Replace `sum >> 3` with `sum / AVG_WINDOW_SIZE` or add an explanatory comment.

---

**A16-14** · INFO · `SerialLogger::m_serial` initialised with `0` not `nullptr` (`seriallogger.cpp:8`)

**Description:** Line 8 initialises the static pointer with the integer literal `0`:
```cpp
EM070::UserPort *SerialLogger::m_serial = 0;
```
Modern C++ style uses `nullptr` for null pointer constants. Using `0` is not incorrect but is stylistically inconsistent with the rest of the codebase which uses Qt types and is compiled as C++11 or later.

**Fix:** Replace `= 0` with `= nullptr`.

---

## Summary Table

| ID | Severity | Category | Location | Short Title |
|----|----------|----------|----------|-------------|
| A16-1 | HIGH | Build / Guard | `pwmbacklight.h:1-2` | Broken include guard (`PWMBACKLIGHT_H` vs `BRIGHTNESS_H`) |
| A16-2 | MEDIUM | Dead Code | `pwmbeeper.h:15` | `BeepType` enum declared but never used |
| A16-3 | MEDIUM | Dead Code | `pwmbacklight.cpp:48-59` | Large commented-out brightness map block |
| A16-4 | MEDIUM | Dead Code | `pwmbacklight.cpp:115` | Commented-out expression inline on active statement |
| A16-5 | MEDIUM | Dead Code / Correctness | `pwmbacklight.cpp:17-18` | `X1P1`/`X1P2` macros carry stale alternatives; multiplier mismatches names |
| A16-6 | MEDIUM | Dead Code | `seriallogger.cpp:5-6,18-30` | `ENABLE_SL_FILE` permanently zero; file-log branch is dead code |
| A16-7 | LOW | Style | `pwmbeeper.cpp:77` | C-style cast instead of `reinterpret_cast` |
| A16-8 | LOW | Correctness | `pwmbeeper.cpp:66-75` | `input_event` struct not zero-initialized before write |
| A16-9 | LOW | Style / Maintenance | `pwmbacklight.cpp:12-13` | `TWO_SECONDS`/`THREE_SECONDS` are tick-counts implicitly tied to `TIMER_INTERVAL` |
| A16-10 | LOW | Style | `seriallogger.h` | Pure-static class missing deleted constructor |
| A16-11 | LOW | Performance | `pwmbacklight.cpp:179-201` | Brightness sysfs file opened/closed on every read and write |
| A16-12 | LOW | Style | `pwmbacklight.cpp:140` | Stray space before `)` in condition |
| A16-13 | INFO | Readability | `pwmbacklight.cpp:162-169` | Magic number `8` used three times with no named constant |
| A16-14 | INFO | Style | `seriallogger.cpp:8` | Static pointer initialised with `0` instead of `nullptr` |
# Pass 4 Agent A17 — Code Quality

**Audit run:** 2026-02-28-01
**Branch:** master
**Repo root:** `C:/Projects/cig-audit/repos/mark3-pvd`
**Files reviewed:**
- `platform/userport.h` + `platform/userport.cpp`
- `platform/wiegandrfid.h` + `platform/wiegandrfid.cpp`
- `platform/wifi.h` + `platform/wifi.cpp`

---

## Reading Evidence

### `platform/userport.h`

**Class:** `EM070::UserPort` (extends `QObject`)

| Method / Member | Line |
|---|---|
| `explicit UserPort(QObject *parent = nullptr)` | 15 |
| `void response(const QByteArray &ba)` | 16 |
| `void setBaudRate(QSerialPort::BaudRate baudRate)` | 18 |
| signal: `void cmdReceived(const QByteArray &ba)` | 21 |
| private: `void readData()` | 24 |
| private: `QSerialPort *m_serialPort` | 26 |
| private: `QByteArray m_receiver` | 27 |

**Types / constants defined:** none beyond class members.

**Includes:**
- `<QObject>` (line 4)
- `<QSerialPort>` (line 5)
- Forward declaration `class QSerialPort;` (line 7) — redundant after `#include <QSerialPort>`

---

### `platform/userport.cpp`

| Function | Line |
|---|---|
| `UserPort::UserPort(QObject *parent)` | 15 |
| `UserPort::readData()` | 54 |
| `UserPort::response(const QByteArray &ba)` | 78 |
| `UserPort::setBaudRate(QSerialPort::BaudRate baudRate)` | 88 |

**Macros / constants defined:**
- `FILE_USER_PORT "/dev/ttyS1"` (line 5)

**Conditional blocks:**
- `#if (TEST_MODE == 1)` at lines 7–11 and 44–51 and 83–85 — introduces `QSocketNotifier *notifier` as a file-scope (global) raw pointer.

---

### `platform/wiegandrfid.h`

**Class:** `EM070::WiegandRfid` (extends `QObject`)

| Method / Member | Line |
|---|---|
| `explicit WiegandRfid(QObject *parent = 0)` | 14 |
| `void setEnabled(bool enable)` | 15 |
| `static quint64 wiegandData(quint8 facility, quint32 number)` | 17 |
| signal: `void cardData(quint64 wiegand, quint16 facility, quint32 number, QByteArray &readerOutput)` | 20 |
| signal: `void error(const QString &text)` | 21 |
| private: `void activated()` | 24 |
| private: `QFile m_cardReadyFile` | 26 |
| private: `QSocketNotifier *m_notifier` | 27 |

**Types / constants defined:** none beyond class members.

---

### `platform/wiegandrfid.cpp`

| Function | Line |
|---|---|
| `WiegandRfid::WiegandRfid(QObject *parent)` | 11 |
| `WiegandRfid::activated()` | 24 |
| `WiegandRfid::setEnabled(bool enable)` | 106 |
| `WiegandRfid::wiegandData(quint8 facility, quint32 number)` | 111 |

**Macros / constants defined:**
- `FILE_CARD_READY "/sys/devices/platform/wiegand-gpio.0/card_ready"` (line 5)
- `FILE_CARD_DATA  "/sys/devices/platform/wiegand-gpio.0/card_data"` (line 6)
- `FILE_RAW_DATA   "/sys/devices/platform/wiegand-gpio.0/raw_data"` (line 7)

**Commented-out block:** 37-bit Wiegand decode, lines 83–96.

---

### `platform/wifi.h`

**Class:** `EM070::Wifi` (extends `QObject`)

| Method / Member | Line |
|---|---|
| `explicit Wifi(EM070::UserPort *userPort)` | 26 |
| `~Wifi() {}` | 27 |
| `void writeConf()` | 29 |
| `void restart()` | 30 |
| `bool status()` — inline, returns `m_status` | 32 |
| `bool startPositioning()` | 34 |
| `void parseResponse(const QByteArray &ba)` | 36 |
| `QList<CIGCONF::AccessPoint> accessPoints()` — inline | 38 |
| `void setCellularState(bool state)` | 40 |
| `void setPowerState(CIGCONF::PowerState state)` | 42 |
| signal: `void ethernetStateChanged(bool ready)` | 46 |
| signal: `void wifiReconnectionFailed()` | 47 |
| signal: `void wifiScanFinished(QList<CIGCONF::AccessPoint> list)` | 48 |
| private: `void attemptReconnectToWifi()` | 51 |
| private: `void checkStatus()` | 52 |
| private: `void scanAccessPoints()` | 53 |
| private: `void scanFinished(int exitCode, QProcess::ExitStatus exitStatus)` | 54 |
| private data members | 56–69 |

**Types / constants defined:** none beyond class members (uses imported `CIGCONF::AccessPoint`, `CIGCONF::PowerState`).

**Includes:**
- `"../app/cigconfigs.h"` (line 4)
- `<QObject>` (line 5)
- `<QByteArray>` (line 6)
- `<QList>` **(line 7 — first occurrence)**
- `<QProcess>` (line 8)
- `<QNetworkConfigurationManager>` (line 9)
- `<QTimer>` (line 10)
- `<QList>` **(line 11 — DUPLICATE)**
- Forward declaration `class QTimer;` (line 13) — redundant after `#include <QTimer>`

---

### `platform/wifi.cpp`

| Function | Line |
|---|---|
| `Wifi::Wifi(UserPort *userPort)` | 16 |
| `Wifi::writeConf()` | 46 |
| `Wifi::restart()` | 82 |
| `Wifi::checkStatus()` | 96 |
| `Wifi::setCellularState(bool state)` | 146 |
| `Wifi::attemptReconnectToWifi()` | 153 |
| `Wifi::startPositioning()` | 191 |
| `Wifi::parseResponse(const QByteArray &ba)` | 211 |
| `Wifi::scanAccessPoints()` | 250 |
| `Wifi::scanFinished(int exitCode, QProcess::ExitStatus exitStatus)` | 266 |
| `Wifi::setPowerState(CIGCONF::PowerState state)` | 297 |

**Macros / constants defined:**
- `SCAN_WATCHDOG (300*1000)` (line 13)
- `RECONNECT_TIMEOUT (210000)` (line 14)

**Commented-out blocks:**
- `cigconfigs.h` include, line 5
- Old SIGNAL/SLOT connect for `QProcess::finished`, line 35
- WiFi nmcli reconnection block, lines 174–188
- RSSI format guard in `parseResponse`, lines 229–231
- Debug output in `scanFinished`, lines 284–287
- Debug output in `parseResponse`, line 247

---

## Findings

---

**A17-1** · LOW · Duplicate `#include <QList>` in `wifi.h`
**Description:** `wifi.h` includes `<QList>` twice: once at line 7 and again at line 11. While include guards inside Qt headers make this harmless at compile time, it is a clear copy-paste error that adds noise for readers and can cause warnings with some static analysis tools.
**Fix:** Remove the duplicate `#include <QList>` at line 11 of `platform/wifi.h`.

---

**A17-2** · LOW · Redundant forward declarations after full includes
**Description:** `userport.h` line 7 forward-declares `class QSerialPort;` after already `#include <QSerialPort>`-ing the full header at line 5. Similarly, `wifi.h` line 13 forward-declares `class QTimer;` after already including `<QTimer>` at line 10. Forward declarations after full includes are dead text and can confuse readers about the intended dependency.
**Fix:** Remove `class QSerialPort;` from `platform/userport.h` line 7 and `class QTimer;` from `platform/wifi.h` line 13.

---

**A17-3** · LOW · Deprecated `parent = 0` default argument instead of `nullptr`
**Description:** `WiegandRfid`'s constructor in `wiegandrfid.h` line 14 uses `QObject *parent = 0` as a default argument. This is a pre-C++11 idiom; the rest of the codebase (e.g. `UserPort` at `userport.h` line 15) consistently uses `nullptr`. This inconsistency creates a minor style regression.
**Fix:** Change `explicit WiegandRfid(QObject *parent = 0)` to `explicit WiegandRfid(QObject *parent = nullptr)` in `platform/wiegandrfid.h` line 14.

---

**A17-4** · MEDIUM · `wifiReconnectionFailed` signal declared but never emitted — connected slot silently dead
**Description:** `wifi.h` line 47 declares the `wifiReconnectionFailed()` signal. `backgroundworker.cpp` line 2806 connects it to `m_modemPort->resetModem()`. However, the only `emit wifiReconnectionFailed()` call (inside `attemptReconnectToWifi()`) was commented out as part of the larger reconnection block at `wifi.cpp` line 179. As a result, modem reset on WiFi failure never occurs; the caller believes this recovery path is active when it is not.
**Fix:** Either implement the reconnection logic so that `emit wifiReconnectionFailed()` is reached, or remove the signal declaration, remove the `connect()` in `backgroundworker.cpp`, and document clearly that WiFi-failure-triggered modem reset is not yet implemented.

---

**A17-5** · MEDIUM · `wifiScanFinished` signal declared but never emitted — GPS positioning data never delivered
**Description:** `wifi.h` line 48 declares `wifiScanFinished(QList<CIGCONF::AccessPoint>)`. `backgroundworker.cpp` line 2807 connects it to `sendGmtpMessage(CIGCONF::GMTP_WIFIPOS)`. No `emit wifiScanFinished(...)` call exists anywhere in `wifi.cpp`. `scanFinished()` populates `m_accessPoints` but never fires this signal; the positioning system can never deliver a WiFi position fix.
**Fix:** Add `emit wifiScanFinished(m_accessPoints)` at the end of `Wifi::scanFinished()` (after the access-point list is fully populated) and after `parseResponse()` completes a scan cycle (the `ba.at(0) == '>'` branch in line 219).

---

**A17-6** · MEDIUM · `m_status` permanently `false` — `status()` accessor is useless
**Description:** `wifi.h` line 32 exposes `bool status() { return m_status; }`. `m_status` is initialised to `false` in the constructor (`wifi.cpp` line 19) and is never written again anywhere in the file. No code path sets it to `true`. Any caller relying on `status()` to know whether the WiFi subsystem is functional will always receive `false`. (Confirmed by grep: no `m_status = true` or `m_status = false` assignment exists beyond initialisation.)
**Fix:** Either remove `m_status` and `status()` if they serve no purpose, or wire `m_status` to be set `true` when `m_configurationManager` is successfully initialised and `false` on failure, mirroring the pattern used for `m_wifiStatus`.

---

**A17-7** · MEDIUM · Commented-out WiFi reconnection block leaves `attemptReconnectToWifi()` functionally empty
**Description:** `wifi.cpp` lines 174–188 contain a large commented-out block that was the core reconnection logic: starting `nmcli`, waiting for it to finish, and handling failure. What remains live in `attemptReconnectToWifi()` only kills the DHCP process and returns — there is no actual reconnection attempt. The function name strongly implies active remediation, but the body provides none. This is a leaky abstraction: callers (`checkStatus()`) believe reconnection was attempted.
**Fix:** Either restore the reconnection logic (replacing the deprecated `nmcli` path with a working alternative such as `wpa_cli reconnect` or direct `dhclient`), or rename the function to reflect its actual behaviour (e.g., `releaseDhcpLease()`) and update callers accordingly. Remove the dead comment block once the intent is resolved.

---

**A17-8** · MEDIUM · Commented-out 37-bit Wiegand decode leaves an unsupported card format with no error reporting
**Description:** `wiegandrfid.cpp` lines 83–96 contain a commented-out `if (bits == 37)` block for decoding HID 37-bit Wiegand cards. With the block disabled, 37-bit cards fall through to the `if (bits >= 26)` catch-all at line 98, which emits `cardData(wiegand, 0, 0, ba)` (facility=0, number=0) followed immediately by `emit error(ba)` at line 103. This means 37-bit HID cards are treated as decode failures rather than as an unsupported-but-known format, and the error message contains only raw binary data, not a useful diagnostic.
**Fix:** Either re-enable and fix the 37-bit decode path (the commented code contains a type mismatch: `facility` is `quint16` inside but the signal and `wiegandData()` accept `quint8`/`quint16` — verify the field widths and correct them), or add an explicit `bits == 37` branch that emits a descriptive `error()` string such as `"37-bit HID format not supported"` instead of raw card data. Remove the commented block.

---

**A17-9** · LOW · C-style casts in `wiegandrfid.cpp` Wiegand decode logic
**Description:** `wiegandrfid.cpp` lines 71–72 use C-style casts `(quint8)(w >> 16)` and `(quint16)w` to extract facility and card number from the 34-bit Wiegand word. C-style casts suppress all compiler warnings about truncation and are stylistically inconsistent with the rest of the Qt codebase which generally avoids them.
**Fix:** Replace with `static_cast<quint8>(w >> 16)` and `static_cast<quint16>(w)` to make the intended truncation explicit and compiler-visible.

---

**A17-10** · LOW · Test-mode global raw pointer `notifier` leaks into translation unit scope
**Description:** `userport.cpp` lines 9–10 declare `QSocketNotifier *notifier` as a file-scope global raw pointer guarded by `#if (TEST_MODE == 1)`. The pointer is assigned inside the constructor but is never deleted and is never wrapped in a smart pointer. Even in test mode, if the `UserPort` object is destroyed and recreated, the old notifier is orphaned. Additionally, a bare global pointer is unidiomatic in Qt code where `QObject` parented children are the norm.
**Fix:** Move `notifier` into the `UserPort` class as a `QSocketNotifier *m_testNotifier` member (still `#if TEST_MODE` guarded), constructed with `this` as parent so Qt's object tree handles its lifetime. Remove the global declaration.

---

**A17-11** · LOW · `wifi.h` includes `<QNetworkConfigurationManager>` — deprecated Qt Network Bearer API exposed in public header
**Description:** `QNetworkConfigurationManager` and `QNetworkConfiguration` are part of the Qt Network Bearer API that was deprecated in Qt 5.15 and removed in Qt 6. Including this header in the public `wifi.h` forces all consumers of `Wifi` to transitively depend on a deprecated API. The implementation detail (`m_configurationManager`) belongs in the `.cpp` file and should be forward-declared or hidden.
**Fix:** Forward-declare `QNetworkConfigurationManager` in `wifi.h` (or use a PIMPL), move `#include <QNetworkConfigurationManager>` and `#include <QNetworkConfiguration>` to `wifi.cpp` only. Longer term, migrate off `QNetworkConfigurationManager` to `QNetworkInformation` (Qt 6) or a direct kernel interface.

---

**A17-12** · LOW · `wifi.cpp` line 5 has a commented-out `#include "../app/cigconfigs.h"`
**Description:** `wifi.cpp` line 5 reads `//#include "../app/cigconfigs.h"`. This header is included transitively via `wifi.h` (which includes `"../app/cigconfigs.h"` at line 4), so the direct include was presumably removed when the header was added to `wifi.h`. The dead comment adds confusion about whether `cigconfigs.h` is required here.
**Fix:** Delete the commented-out include at `wifi.cpp` line 5.

---

**A17-13** · LOW · Commented-out old-style SIGNAL/SLOT connect left in `wifi.cpp`
**Description:** `wifi.cpp` line 35 contains a commented-out `connect(m_ps, SIGNAL(...), ...)` call. The modern `QOverload` form on the next line (line 36) is the intended and active connection. The dead comment creates confusion about which form is in use.
**Fix:** Delete `wifi.cpp` line 35.

---

**A17-14** · LOW · Inconsistent indentation in `wifi.cpp` `writeConf()` body
**Description:** Inside the `if`/`else` block of `writeConf()` (lines 65–74), the `if` branch uses consistent `\t`-indented `out <<` lines, but the `else` branch (lines 69–73) drops back to the enclosing indentation level for the `out <<` statements, making the block harder to read and diff.
**Fix:** Indent the `else` branch body to one level deeper than the `else` keyword, consistent with the `if` branch.

---

**A17-15** · LOW · `wifi.cpp` `checkStatus()` uses `BearerEthernet` to classify `wlan0` — semantic mismatch
**Description:** `wifi.cpp` line 118 checks `cfg.bearerType() == QNetworkConfiguration::BearerEthernet` to identify the wlan0 interface. WiFi connections have bearer type `BearerWLAN`, not `BearerEthernet`. This check may never match (or may match a wired interface by accident), meaning `wifiConnected` could remain `false` even when wlan0 is up. The `name().contains(wifiInterfaceName)` guard narrows the risk but does not compensate for the wrong bearer type.
**Fix:** Change the bearer type check to `QNetworkConfiguration::BearerWLAN`, or remove it and rely solely on `cfg.name().contains(wifiInterfaceName)` combined with `cfg.state() == QNetworkConfiguration::Active`.

---

**A17-16** · INFO · Multiple scattered `qDebug()` calls remain in production paths
**Description:** `wiegandrfid.cpp` lines 42, 60, 74, 99 and `wifi.cpp` lines 111, 158, 169, 256, 260, 268 emit `qDebug()` output unconditionally in production code paths (not behind `#ifdef QT_DEBUG` or `Q_LOGGING_CATEGORY`). On an embedded device this can flood the serial console or system journal. Some of the messages also include raw card data values (line 42: `ba`, line 60: `ba`) which could expose credential-adjacent information in logs.
**Fix:** Wrap debug prints in `Q_LOGGING_CATEGORY` / `qCDebug` with a named category so they can be disabled at runtime. At minimum, protect them with `#ifdef QT_DEBUG`. Remove or redact prints that include raw card data bytes.

---

## Summary Table

| Finding | Severity | Short Title | File(s) | Line(s) |
|---|---|---|---|---|
| A17-1 | LOW | Duplicate `#include <QList>` | `wifi.h` | 7, 11 |
| A17-2 | LOW | Redundant forward declarations after full includes | `userport.h`, `wifi.h` | 7; 13 |
| A17-3 | LOW | `parent = 0` instead of `nullptr` | `wiegandrfid.h` | 14 |
| A17-4 | MEDIUM | `wifiReconnectionFailed` signal never emitted — modem reset silently disabled | `wifi.h`, `wifi.cpp` | 47; 174–188 |
| A17-5 | MEDIUM | `wifiScanFinished` signal never emitted — positioning data never delivered | `wifi.h`, `wifi.cpp` | 48; 266–295 |
| A17-6 | MEDIUM | `m_status` permanently `false` — `status()` accessor always wrong | `wifi.h`, `wifi.cpp` | 32; 19 |
| A17-7 | MEDIUM | Commented-out reconnect block leaves `attemptReconnectToWifi()` functionally empty | `wifi.cpp` | 153–188 |
| A17-8 | MEDIUM | Commented-out 37-bit Wiegand decode causes 37-bit HID cards to fail silently | `wiegandrfid.cpp` | 83–96 |
| A17-9 | LOW | C-style casts in Wiegand 34-bit decode | `wiegandrfid.cpp` | 71–72 |
| A17-10 | LOW | Test-mode global raw pointer `notifier` leaks into TU scope | `userport.cpp` | 9–10, 45 |
| A17-11 | LOW | Deprecated `QNetworkConfigurationManager` in public header | `wifi.h` | 9, 58 |
| A17-12 | LOW | Commented-out `#include` in `wifi.cpp` | `wifi.cpp` | 5 |
| A17-13 | LOW | Dead old-style SIGNAL/SLOT connect comment | `wifi.cpp` | 35 |
| A17-14 | LOW | Inconsistent indentation in `writeConf()` else-branch | `wifi.cpp` | 69–73 |
| A17-15 | LOW | `BearerEthernet` used to classify `wlan0` — wrong bearer type | `wifi.cpp` | 118 |
| A17-16 | INFO | Unconditional `qDebug()` in production paths, some emit raw card data | `wiegandrfid.cpp`, `wifi.cpp` | multiple |
# Pass 4 Agent A18 — Code Quality

**Audit run:** 2026-02-28-01
**Branch:** master
**Files reviewed:**
- `ui/amberimpactalertdialog.h` + `ui/amberimpactalertdialog.cpp`
- `ui/authoriseddialog.h` + `ui/authoriseddialog.cpp`
- `ui/broadcastuidialog.h` + `ui/broadcastuidialog.cpp`

---

## 1. Reading Evidence

### 1.1 AmberImpactAlertDialog

**File:** `ui/amberimpactalertdialog.h` / `ui/amberimpactalertdialog.cpp`

**Class:** `AmberImpactAlertDialog` (extends `QDialog`)

**Methods / functions (with line numbers):**

| Location | Signature |
|---|---|
| h:15 / cpp:6 | `explicit AmberImpactAlertDialog(QWidget *parent = nullptr)` |
| h:16 / cpp:14 | `~AmberImpactAlertDialog()` |
| h:18 / cpp:49 | `bool isOpen() const` |
| h:19 / cpp:31 | `void closeWindow()` |
| h:20 / cpp:19 | `void languageChanged()` |
| h:23 (public slot) / cpp:54 | `void amberAlertDialogShowEvent(bool isLocked)` |
| h:26 (protected) / cpp:25 | `void mouseReleaseEvent(QMouseEvent *)` |
| h:27 (protected) / cpp:39 | `void showEvent(QShowEvent *event = 0)` |

**Types / enums / constants defined:** none beyond those inherited from `QDialog`.

**Private members:**
- `Ui::AmberImpactAlertDialog *ui` (h:30)
- `bool dialogOpenFlag` (h:31)

---

### 1.2 AuthorisedDialog

**File:** `ui/authoriseddialog.h` / `ui/authoriseddialog.cpp`

**Class:** `AuthorisedDialog` (extends `QDialog`)

**Methods / functions (with line numbers):**

| Location | Signature |
|---|---|
| h:17 / cpp:13 | `explicit AuthorisedDialog(QWidget *parent = 0)` |
| h:18 / cpp:44 | `~AuthorisedDialog()` |
| h:19 / cpp:56 | `void setHasChecklist(bool yes)` |
| h:20 / cpp:67 | `void setDriverId(quint64 id)` |
| h:21 / cpp:178 | `void setTime(const QString s)` |
| h:22 / cpp:211 | `void setPower(bool on)` |
| h:23 / cpp:217 | `void updateCamera()` |
| h:33 (protected) / cpp:71 | `void showEvent(QShowEvent *)` |
| h:34 (protected) / cpp:113 | `void hideEvent(QHideEvent *)` |
| h:43 (private) / cpp:148 | `bool debounce()` |
| h:44 (private) / cpp:120 | `void screensaverOff()` |
| h:45 (private) / cpp:138 | `void screensaverPressed()` |
| h:46 (private) / cpp:50 | `void onButtonConfirmStart()` |
| h:47 (private) / cpp:130 | `void screensaverOn()` |
| h:48 (private) / cpp:188 | `void setCamera(bool on, bool flip)` |
| h:54 (private slot) / cpp:172 | `void rstLogout()` |
| h:55 (private slot) / cpp:156 | `void onLogoutRequest()` |

**Signals:**
- `void userLogout()` (h:30)

**Types / enums / constants defined:**
- `#define RESET_TIMEOUT 2000` (cpp:11)

**Private members:**
- `bool m_waking` (h:37)
- `Ui::AuthorisedDialog *ui` (h:38)
- `OptionalCheckConfirmationDialog *m_optionalCheckConfirmationDialog` (h:39)
- `QTimer *m_resetTimer` (h:40)
- `quint32 m_lastPress` (h:41)
- `quint64 m_pendingDriverId` (h:42)
- `bool m_showCamera` (h:50)
- `bool m_power` (h:51)

---

### 1.3 BroadcastUIDialog

**File:** `ui/broadcastuidialog.h` / `ui/broadcastuidialog.cpp`

**Class:** `BroadcastUIDialog` (extends `QDialog`)

**Methods / functions (with line numbers):**

| Location | Signature |
|---|---|
| h:19 / cpp:4 | `explicit BroadcastUIDialog(QWidget *parent = nullptr)` |
| h:20 / cpp:19 | `~BroadcastUIDialog()` |
| h:22 / cpp:24 | `void setUIParam(CIGCONF::BroadcastMessage m)` |
| h:32 (private slot) / cpp:48 | `void onYes()` |
| h:33 (private slot) / cpp:54 | `void onNo()` |
| h:34 (private slot) / cpp:60 | `void onOK()` |

**Signals:**
- `void messageClosed(CIGCONF::BroadcastMessage m)` (h:25)

**Enums defined:**
- `enum MessageResult { MsgResultOK, MsgResultYes, MsgResultNo, MsgResultTimeout, MsgResultLogout, MsgResultNoDriver }` (h:17)

**Private members:**
- `Ui::BroadcastUIDialog *ui` (h:28)
- `QTimer *m_timer` (h:29)

---

## 2. Findings

---

**A18-1** · HIGH · `BroadcastUIDialog::m_timer` allocated without parent — potential memory leak

**Description:** In `broadcastuidialog.cpp` line 7, `m_timer` is constructed as `new QTimer` with no parent argument. Every other `QTimer` allocation in the `ui/` directory uses `new QTimer(this)`, which means the Qt object tree will automatically delete the timer when the dialog is destroyed. Without a parent, the timer is not owned by the object tree and must be deleted manually. The destructor (`cpp:19–22`) only calls `delete ui` and never deletes `m_timer`, so the timer is leaked on every `BroadcastUIDialog` destruction.

**Fix:** Change `m_timer(new QTimer)` to `m_timer(new QTimer(this))` at `broadcastuidialog.cpp:7`. This registers the timer in the Qt object tree and removes the need for a manual `delete`.

---

**A18-2** · HIGH · `messageClosed` signal declared but never emitted — silent API contract failure

**Description:** `BroadcastUIDialog` declares `void messageClosed(CIGCONF::BroadcastMessage m)` at `broadcastuidialog.h:25`. This signal is never emitted anywhere in the codebase (verified by full-repository search). The three button slots (`onYes`, `onNo`, `onOK`) and the timer lambda all call `emit done(MsgResultXxx)`, which invokes the inherited `QDialog::finished(int)` signal rather than `messageClosed`. Any caller that connects to `messageClosed` will never receive a notification, silently discarding message results. The actual consumer in `dialog.cpp:133` connects to `BroadcastUIDialog::finished`, confirming `messageClosed` is unreachable dead code that creates a misleading public API surface.

**Fix:** Remove the `messageClosed` signal declaration from `broadcastuidialog.h`. If a typed result notification carrying back the `BroadcastMessage` is needed in future, re-introduce it and emit it from each slot. Add a comment near the `done()` calls noting that callers should connect to `QDialog::finished(int)` and cast the result to `BroadcastUIDialog::MessageResult`.

---

**A18-3** · MEDIUM · `MessageResult` values `MsgResultLogout` and `MsgResultNoDriver` emitted externally, not by the owning class

**Description:** The `MessageResult` enum values `MsgResultLogout` and `MsgResultNoDriver` are never emitted inside `BroadcastUIDialog` itself. They are fired from `dialog.cpp:135` (`emit m_broadcastDialog->done(BroadcastUIDialog::MsgResultLogout)`) and `dialog.cpp:1165` (`onBroadcastDialogDone(BroadcastUIDialog::MsgResultNoDriver)`). Calling `emit` on another object's signal is a Qt anti-pattern: it bypasses the owning class's encapsulation, couples the external class to internal state transitions, and makes the control flow non-obvious. It can also produce unexpected re-entrancy if the signal is connected with `Qt::DirectConnection`.

**Fix:** Add dedicated public slots or methods to `BroadcastUIDialog` — e.g., `void forceLogoutClose()` and `void forceNoDriverClose()` — that call `emit done(MsgResultLogout)` and `emit done(MsgResultNoDriver)` respectively from within the class. The external caller in `dialog.cpp` should invoke these methods instead of reaching into the object to emit its signals.

---

**A18-4** · MEDIUM · `showEvent` default argument `= 0` is deprecated C++11 / Qt style inconsistency

**Description:** `amberimpactalertdialog.h:27` declares `void showEvent(QShowEvent *event = 0)`. Using integer literal `0` as a default value for a pointer parameter is deprecated C++ style; the correct form is `= nullptr`. This pattern also appears on the same line using a tab-indented style that differs from the spaces-indented body of the same header. `authoriseddialog.h:33` uses `void showEvent(QShowEvent *)` (no default at all), which is the correct override form. `broadcastuidialog.h` omits `showEvent` entirely. Providing a default argument on a virtual override is misleading: the base class `QDialog::showEvent` has no default, so callers always pass the event; the default is never used and serves only to confuse.

**Fix:** Remove the `= 0` default from `amberimpactalertdialog.h:27`. Change `0` to `nullptr` as a secondary improvement wherever legacy `= 0` defaults appear across the `ui/` directory. Align all `showEvent` overrides to the form `void showEvent(QShowEvent *event) override;`.

---

**A18-5** · MEDIUM · `AuthorisedDialog` constructor uses `= 0` for parent parameter; `AmberImpactAlertDialog` uses `= nullptr` — inconsistent within the same file set

**Description:** `authoriseddialog.h:17` declares `explicit AuthorisedDialog(QWidget *parent = 0)` whereas `amberimpactalertdialog.h:15` and `broadcastuidialog.h:19` both use `= nullptr`. Within the same logical group of dialog classes, two different null-pointer representations are used. This is a style inconsistency that will produce compiler warnings under `-Wzero-as-null-pointer-constant` on modern compilers.

**Fix:** Standardise all constructor default parent arguments to `= nullptr` across the `ui/` dialog class headers.

---

**A18-6** · MEDIUM · `AuthorisedDialog::setCamera` contains a leftover `qDebug` trace statement in production code

**Description:** `authoriseddialog.cpp:190` contains `qDebug() << "setCamera(" << on << "," << flip << ")";`. This diagnostic trace fires on every camera state transition, which can occur frequently (on every screensaver toggle, hide/show event, and power change). Debug output in production code adds unnecessary I/O overhead and can expose internal state information in production logs.

**Fix:** Remove the `qDebug` call, or wrap it in `#ifdef QT_DEBUG` / `#endif` so it compiles out in release builds.

---

**A18-7** · MEDIUM · `AmberImpactAlertDialog` includes `<QDebug>` but never calls `qDebug`

**Description:** `amberimpactalertdialog.cpp:4` includes `<QDebug>`, but no `qDebug()` call exists anywhere in the file. This is a dead include left over from development. Unused includes add noise and marginally increase compile time.

**Fix:** Remove `#include <QDebug>` from `amberimpactalertdialog.cpp`.

---

**A18-8** · MEDIUM · `AmberImpactAlertDialog::languageChanged` not called from `Dialog::onLanguageChanged` — localisation gap

**Description:** `dialog.cpp` calls `languageChanged()` on eight child dialogs during language switching (lines 1275–1282), but `m_amberImpactAlertDialog->languageChanged()` is absent from that list. `AmberImpactAlertDialog` has its own `languageChanged()` implementation (`amberimpactalertdialog.cpp:19–23`) that re-translates two labels. If the user changes language while the amber alert dialog is open or has been shown before, those labels will remain in the previous language.

**Fix:** Add `m_amberImpactAlertDialog->languageChanged();` to the `Dialog::onLanguageChanged` handler alongside the other dialog calls.

---

**A18-9** · LOW · `AmberImpactAlertDialog::showEvent` duplicates translation strings already in `languageChanged`

**Description:** `amberimpactalertdialog.cpp:43–44` (inside `showEvent`) and `amberimpactalertdialog.cpp:21–22` (inside `languageChanged`) contain identical `tr(...)` calls for the same two labels. This duplication means any future change to the displayed text must be made in two places, risking divergence.

**Fix:** Refactor `showEvent` to call `languageChanged()` rather than repeating the `tr(...)` assignments. This makes `languageChanged` the single source of truth for translated strings.

---

**A18-10** · LOW · `AuthorisedDialog::onLogoutRequest` compares button text to a translated string to determine dialog state

**Description:** `authoriseddialog.cpp:160` uses `ui->btnLogout->text() == tr("Confirm?")` to test whether the button is in its first-click or second-click (confirm) state. This couples state detection to the localised display text. If the translated string for "Confirm?" in any language contains leading/trailing whitespace or differs in punctuation, the comparison will silently fail and the logout confirmation flow will break. It also makes the component untestable without mocking the translation engine.

**Fix:** Introduce a private `bool m_logoutPending` member that is set to `true` on the first click and reset to `false` by `rstLogout()` and on successful logout. Use `m_logoutPending` as the state gate instead of comparing button text.

---

**A18-11** · LOW · `AuthorisedDialog::setTime` takes `const QString s` by value — unnecessary copy

**Description:** `authoriseddialog.h:21` declares `void setTime(const QString s)`. Passing `QString` by `const` value provides no benefit over passing by `const QString &`; it creates a copy of the string on every call with no additional safety guarantee.

**Fix:** Change the signature to `void setTime(const QString &s)` in both the header and the implementation.

---

**A18-12** · LOW · `AuthorisedDialog::showEvent` sets widget geometry with hard-coded pixel coordinates

**Description:** `authoriseddialog.cpp:82–96` uses hard-coded absolute pixel positions (e.g., `resize(800,321)`, `move(355,170)`) to reposition labels depending on whether the driver name is displayed. Hard-coded pixel layout is fragile: it breaks on any display resolution other than the targeted 800x480 and is unaffected by Qt's layout system. This is a maintainability concern rather than a security issue.

**Fix:** Replace hard-coded geometry calls with a QLayout-based approach (e.g., a `QVBoxLayout` / `QStackedWidget` that shows or hides the driver name label while the other widgets reflow automatically).

---

**A18-13** · LOW · `AuthorisedDialog::showEvent` sets a non-translated hard-coded English string `"Welcome, "`

**Description:** `authoriseddialog.cpp:79` constructs the driver name label text as `"Welcome, " + driverName`. The string literal `"Welcome, "` is not wrapped in `tr(...)`, so it is not subject to translation even when the UI language is changed.

**Fix:** Change the assignment to `ui->lblDriverName->setText(tr("Welcome, ") + driverName)` or, preferably, use `tr("Welcome, %1").arg(driverName)` which is safer for languages where word order differs.

---

**A18-14** · LOW · `BroadcastUIDialog::setUIParam` takes `CIGCONF::BroadcastMessage` by value — unnecessary copy of a potentially non-trivial struct

**Description:** `broadcastuidialog.h:22` declares `void setUIParam(CIGCONF::BroadcastMessage m)`. If `BroadcastMessage` contains a `QString` member (which it does — `m.text` is accessed on cpp:26), passing by value copies the entire struct including the string allocation on every call.

**Fix:** Change the parameter to `const CIGCONF::BroadcastMessage &m`.

---

## 3. Summary Table

| ID | Severity | File(s) | Short Title |
|---|---|---|---|
| A18-1 | HIGH | `broadcastuidialog.cpp:7` | `m_timer` allocated without parent — memory leak |
| A18-2 | HIGH | `broadcastuidialog.h:25` / `.cpp` | `messageClosed` signal declared but never emitted |
| A18-3 | MEDIUM | `broadcastuidialog.h:17` / `dialog.cpp:135,1165` | `MsgResultLogout`/`MsgResultNoDriver` emitted externally via `emit obj->signal()` |
| A18-4 | MEDIUM | `amberimpactalertdialog.h:27` | `showEvent` default argument `= 0` — deprecated null pointer style |
| A18-5 | MEDIUM | `authoriseddialog.h:17` | Constructor uses `= 0` vs `= nullptr` — inconsistent across file set |
| A18-6 | MEDIUM | `authoriseddialog.cpp:190` | Leftover `qDebug` trace in production `setCamera` path |
| A18-7 | MEDIUM | `amberimpactalertdialog.cpp:4` | Unused `#include <QDebug>` |
| A18-8 | MEDIUM | `dialog.cpp` / `amberimpactalertdialog.cpp` | `languageChanged()` never called on `AmberImpactAlertDialog` during language switch |
| A18-9 | LOW | `amberimpactalertdialog.cpp:43–44` | Translation strings duplicated in `showEvent` and `languageChanged` |
| A18-10 | LOW | `authoriseddialog.cpp:160` | Logout state detected by comparing translated button text |
| A18-11 | LOW | `authoriseddialog.h:21` / `.cpp:178` | `setTime` takes `QString` by value instead of `const QString &` |
| A18-12 | LOW | `authoriseddialog.cpp:82–96` | Hard-coded pixel geometry in `showEvent` |
| A18-13 | LOW | `authoriseddialog.cpp:79` | Hard-coded English string `"Welcome, "` not passed through `tr()` |
| A18-14 | LOW | `broadcastuidialog.h:22` / `.cpp:24` | `setUIParam` takes `BroadcastMessage` by value instead of const reference |
# Pass 4 Agent A19 — Code Quality

**Audit run:** 2026-02-28-01
**Branch:** master
**Files reviewed:**
- `ui/checkcompleteddialog.h` + `ui/checkcompleteddialog.cpp`
- `ui/checkconfirmationdialog.h` + `ui/checkconfirmationdialog.cpp`
- `ui/checkquestiondialog.h` + `ui/checkquestiondialog.cpp`

---

## Reading Evidence

### `ui/checkcompleteddialog.h`

**Class:** `CheckCompletedDialog` (extends `QDialog`)

| Symbol | Kind | Line |
|--------|------|------|
| `CheckCompletedDialog(QWidget *parent = 0)` | constructor (public) | 17 |
| `~CheckCompletedDialog()` | destructor (public) | 18 |
| `languageChanged(void)` | method (public) | 20 |
| `isTimerActive()` | method (public) | 21 |
| `stopTimer()` | method (public) | 22 |
| `setCheckResponses(QList<CIGCONF::CheckResponse> &)` | inline method (public) | 23 |
| `openPreopNotes()` | signal | 31 |
| `showEvent(QShowEvent *event = 0)` | method (protected) | 33 |
| `ui` | member (`Ui::CheckCompletedDialog *`) | 36 |
| `m_timer` | member (`QTimer *`) | 37 |
| `m_checkResponses` | member (`QList<CIGCONF::CheckResponse>`) | 38 |

**Types/constants used:** `CIGCONF::CheckResponse` (from `app/cigconfigs.h`)

---

### `ui/checkcompleteddialog.cpp`

**Class:** `CheckCompletedDialog`

| Symbol | Kind | Line |
|--------|------|------|
| `CheckCompletedDialog(QWidget *parent)` | constructor | 7 |
| `~CheckCompletedDialog()` | destructor | 62 |
| `languageChanged()` | method | 67 |
| `showEvent(QShowEvent *event)` | method | 75 |
| `isTimerActive()` | method | 135 |
| `stopTimer()` | method | 140 |

**Macros defined:**
- `NO_ACTIVITY_TIME` — `10000` (milliseconds), defined at line 5

---

### `ui/checkconfirmationdialog.h`

**Class:** `CheckConfirmationDialog` (extends `QDialog`)

| Symbol | Kind | Line |
|--------|------|------|
| `CheckConfirmationDialog(QWidget *parent = 0)` | constructor (public) | 16 |
| `~CheckConfirmationDialog()` | destructor (public) | 17 |
| `confirm(bool yes)` | method (public) | 19 |
| `setQuestion(const QString &question)` | method (public) | 20 |
| `languageChanged(void)` | method (public) | 21 |
| `ui` | member (`Ui::CheckConfirmationDialog *`) | 24 |

No types, enums, or constants defined in this file.

---

### `ui/checkconfirmationdialog.cpp`

**Class:** `CheckConfirmationDialog`

| Symbol | Kind | Line |
|--------|------|------|
| `CheckConfirmationDialog(QWidget *parent)` | constructor | 4 |
| `~CheckConfirmationDialog()` | destructor | 24 |
| `confirm(bool yes)` | method | 29 |
| `setQuestion(const QString &question)` | method | 40 |
| `languageChanged()` | method | 45 |

The file is fully implemented with 54 lines of active code; no commented-out blocks are present.

---

### `ui/checkquestiondialog.h`

**Class:** `CheckQuestionDialog` (extends `QDialog`)

| Symbol | Kind | Line |
|--------|------|------|
| `CheckQuestionDialog(QWidget *parent = 0)` | constructor (public) | 17 |
| `~CheckQuestionDialog()` | destructor (public) | 18 |
| `question() const` | inline accessor (public) | 20 |
| `setQuestion(const QString &question, bool critical = false)` | method (public) | 21 |
| `shown()` | signal | 28 |
| `showEvent(QShowEvent *event)` | method (protected) | 31 |
| `ui` | member (`Ui::CheckQuestionDialog *`) | 34 |
| `m_question` | member (`QString`) | 35 |

No types, enums, or constants defined in this file.

---

### `ui/checkquestiondialog.cpp`

**Class:** `CheckQuestionDialog`

| Symbol | Kind | Line |
|--------|------|------|
| `CheckQuestionDialog(QWidget *parent)` | constructor | 4 |
| `~CheckQuestionDialog()` | destructor | 14 |
| `setQuestion(const QString &question, bool critical)` | method | 19 |
| `showEvent(QShowEvent *event)` | method | 39 |

---

## Findings

---

**A19-1** · HIGH · Deprecated `qrand()` used in `CheckQuestionDialog::setQuestion`

**Description:** `checkquestiondialog.cpp` line 24 calls `qrand() % 2` to randomly swap the YES/NO button positions. `qrand()` was deprecated in Qt 5.10 and is not available in Qt 6 without a compatibility shim. The replacement is `QRandomGenerator::global()->bounded(2)`. Beyond the deprecation issue, the intent of randomly swapping button positions on every question display is itself a usability concern (it prevents muscle-memory confirmation), but the immediate code-quality defect is the use of a deprecated API.

**Fix:** Replace `qrand() % 2` with `QRandomGenerator::global()->bounded(2)` and add `#include <QRandomGenerator>` to the translation unit.

---

**A19-2** · MEDIUM · Leaky abstraction — internal timer details exposed in `CheckCompletedDialog` public interface

**Description:** `checkcompleteddialog.h` declares `isTimerActive()` and `stopTimer()` as public methods, directly surfacing the existence and state of the internal `m_timer` to callers. At `dialog.cpp` lines 877–878 the caller must first query `isTimerActive()` before calling `stopTimer()`, reproducing guard logic that belongs inside the class. The `stopTimer()` implementation in `checkcompleteddialog.cpp` (lines 140–143) already performs the `isActive()` check internally, making the external check at the call site redundant. Exposing timer mechanics in the public API makes it harder to change the auto-dismiss mechanism in future without cascading changes to callers.

**Fix:** Remove `isTimerActive()` from the public interface. `stopTimer()` is idempotent (it already guards internally), so callers should call it unconditionally. Alternatively, rename the pair to a higher-level concept such as `cancelAutoDismiss()`.

---

**A19-3** · MEDIUM · Inconsistent member naming: `setCheckResponses` takes a non-const reference

**Description:** In `checkcompleteddialog.h` line 23 the inline setter is declared as `void setCheckResponses(QList<CIGCONF::CheckResponse> &responses)` — a non-const lvalue reference. This implies the method may modify the caller's list, which it does not (it merely copies into `m_checkResponses`). The other two dialog classes use `const QString &` for analogous setter parameters (`setQuestion` in both `CheckConfirmationDialog` and `CheckQuestionDialog`). The non-const reference is misleading and prevents callers from passing temporary or const objects.

**Fix:** Change the parameter to `const QList<CIGCONF::CheckResponse> &responses`.

---

**A19-4** · MEDIUM · Duplicated UI text setup between `languageChanged()` and `showEvent()` in `CheckCompletedDialog`

**Description:** `checkcompleteddialog.cpp` sets the same four UI strings (`label_2`, `btnSend_2`, `btnRepeat_2`, `btnNotes_2`) in both `languageChanged()` (lines 68–72) and `showEvent()` (lines 81–84). The duplication means any future translation change must be applied in two places and creates a risk of divergence. `CheckConfirmationDialog` and `CheckQuestionDialog` do not share this problem — they separate concerns cleanly.

**Fix:** Have `showEvent()` call `languageChanged()` for the text-setting portion, eliminating the duplicate block.

---

**A19-5** · LOW · Inconsistent constructor default-argument style across the three classes

**Description:** All three header files declare constructors with `QWidget *parent = 0` (null pointer as integer literal). Qt conventions and the C++11 standard prefer `nullptr`. `CheckCompletedDialog` and `CheckConfirmationDialog` also use `= 0` for the `showEvent` default parameter. `CheckQuestionDialog` (line 31) omits the default for `showEvent`, which is inconsistent with `CheckCompletedDialog` (line 33) and `Dialog` (line 93). None of the files uses `= nullptr`.

**Fix:** Replace all `= 0` pointer defaults with `= nullptr` throughout the three header files.

---

**A19-6** · LOW · `NO_ACTIVITY_TIME` macro defined in `.cpp` rather than as a typed constant

**Description:** `checkcompleteddialog.cpp` line 5 defines `NO_ACTIVITY_TIME` as a bare `#define` with value `10000`. This bypasses the type system (no `int` or `constexpr int` context), cannot be referenced from tests or related code without re-defining it, and contributes to the leaky-timer-abstraction problem noted in A19-2. The other two dialog files use no such macros.

**Fix:** Replace with a `static constexpr int kNoActivityTimeMs = 10000;` at class or file scope within `checkcompleteddialog.cpp`, or promote it to a named constant in `cigconfigs.h` if the timeout is a product-level configuration value.

---

**A19-7** · LOW · `showEvent` default parameter `= 0` on a protected override

**Description:** `checkcompleteddialog.h` line 33 declares `void showEvent(QShowEvent *event = 0)`. Adding a default argument to a virtual override (from `QWidget::showEvent(QShowEvent *)`) is unusual, potentially misleading, and the `= 0` form is discouraged in C++11 and later (see A19-5). The base class virtual does not declare a default argument for this parameter. `CheckQuestionDialog` correctly omits the default (line 31).

**Fix:** Remove the `= 0` default from the `showEvent` override declaration in `checkcompleteddialog.h`.

---

**A19-8** · INFO · Missing `languageChanged()` declaration in `CheckQuestionDialog`

**Description:** Both `CheckCompletedDialog` and `CheckConfirmationDialog` expose a public `languageChanged()` method used by the parent `Dialog` to update UI text when the language setting changes. `CheckQuestionDialog` has no `languageChanged()` method at all. Its `setQuestion()` method does call `tr("YES")` and `tr("NO")`, but those translations are only applied when a new question is set, not when the language changes mid-session. This is likely an oversight rather than intentional design.

**Fix:** Add a `languageChanged()` method to `CheckQuestionDialog` that re-applies `tr("YES")`/`tr("NO")` to the buttons, matching the pattern of the sibling classes.

---

## Summary Table

| ID | Severity | Title |
|----|----------|-------|
| A19-1 | HIGH | Deprecated `qrand()` in `CheckQuestionDialog::setQuestion` |
| A19-2 | MEDIUM | Leaky abstraction — timer details in `CheckCompletedDialog` public interface |
| A19-3 | MEDIUM | `setCheckResponses` takes non-const reference, inconsistent with sibling setters |
| A19-4 | MEDIUM | Duplicate UI text setup in `languageChanged()` and `showEvent()` |
| A19-5 | LOW | `= 0` pointer defaults should be `= nullptr` throughout |
| A19-6 | LOW | `NO_ACTIVITY_TIME` defined as untyped `#define` macro |
| A19-7 | LOW | `showEvent` protected override carries redundant default argument `= 0` |
| A19-8 | INFO | `CheckQuestionDialog` missing `languageChanged()` inconsistent with siblings |

**Total findings: 8** (1 HIGH, 3 MEDIUM, 3 LOW, 1 INFO)
# Pass 4 Agent A20 — Code Quality

**Audit run:** 2026-02-28-01
**Branch:** master
**Files reviewed:**
- `ui/checkstartdialog.h` + `ui/checkstartdialog.cpp`
- `ui/commentdialog.h` + `ui/commentdialog.cpp`
- `ui/dialog.h` + `ui/dialog.cpp`

---

## Reading Evidence

### `ui/checkstartdialog.h`

**Class:** `CheckStartDialog` (extends `QDialog`)

| Symbol | Kind | Line |
|--------|------|------|
| `CheckStartDialog(QWidget *parent = 0)` | Constructor | 15 |
| `~CheckStartDialog()` | Destructor | 16 |
| `setMandatory(bool mandatory)` | Public method | 17 |
| `languageChanged(void)` | Public method | 18 |
| `ui` | Private member (`Ui::CheckStartDialog*`) | 25 |

No enums, types, or constants defined in this file.

---

### `ui/checkstartdialog.cpp`

| Symbol | Kind | Line |
|--------|------|------|
| `CheckStartDialog::CheckStartDialog(QWidget*)` | Constructor | 5 |
| `CheckStartDialog::~CheckStartDialog()` | Destructor | 18 |
| `CheckStartDialog::setMandatory(bool)` | Method | 23 |
| `CheckStartDialog::languageChanged()` | Method | 34 |

---

### `ui/commentdialog.h`

**Class:** `CommentDialog` (extends `QDialog`)

**Macros / Constants:**

| Name | Value | Line |
|------|-------|------|
| `NO_ACTIVITY_TIME` | `10000` | 12 |
| `MAX_CHARACTER` | `100` | 13 |

**Enum:**

| Name | Enumerators | Line |
|------|-------------|------|
| `CommentDialogType` | `Unlock`, `Preop` | 15 |

**Methods:**

| Symbol | Kind | Line |
|--------|------|------|
| `CommentDialog(CommentDialogType, QWidget*)` | Constructor | 26 |
| `~CommentDialog()` | Destructor | 27 |
| `UpdateTextInput(QString, onScreenKeyboard::CtrlButton)` | Public method | 29 |
| `onkeyboardClosed()` | Public method | 30 |
| `onUnlkReasonSelected()` | Public method | 31 |
| `languageChanged()` | Public method | 32 |
| `debounce()` | Private method | 37 |
| `reset()` | Private method | 38 |
| `showWidgets()` | Private method | 39 |
| `showEvent(QShowEvent*)` | Protected override | 47 |
| `hideEvent(QHideEvent*)` | Protected override | 48 |
| `run_keyboard_lineEdit()` | Private slot | 51 |
| `onDone()` | Private slot | 52 |
| `onSkip()` | Private slot | 53 |

**Members:** `ui`, `lineEditkeyboard`, `m_timer`, `m_lastPress`, `m_dlgType`, `m_unlkReasonDlg`

---

### `ui/commentdialog.cpp`

| Symbol | Kind | Line |
|--------|------|------|
| `CommentDialog::CommentDialog(...)` | Constructor | 9 |
| `CommentDialog::~CommentDialog()` | Destructor | 36 |
| `CommentDialog::hideEvent(QHideEvent*)` | Override | 41 |
| `CommentDialog::showWidgets()` | Private | 46 |
| `CommentDialog::showEvent(QShowEvent*)` | Override | 91 |
| `CommentDialog::onkeyboardClosed()` | Public | 98 |
| `CommentDialog::UpdateTextInput(...)` | Public | 104 |
| `CommentDialog::run_keyboard_lineEdit()` | Private slot | 121 |
| `CommentDialog::onDone()` | Private slot | 134 |
| `CommentDialog::onSkip()` | Private slot | 168 |
| `CommentDialog::debounce()` | Private | 188 |
| `CommentDialog::reset()` | Private | 199 |
| `CommentDialog::onUnlkReasonSelected()` | Public | 205 |
| `CommentDialog::languageChanged()` | Public | 214 |

---

### `ui/dialog.h`

**Class:** `Dialog` (extends `QDialog`)

**Signals:**

| Signal | Line |
|--------|------|
| `driverChanged(quint64)` | 79 |
| `lastCheckDriverChanged(quint64)` | 80 |
| `screenLocked(CIGCONF::MaintLockedCode)` | 81 |
| `setRelayOut(bool, bool)` | 82 |
| `setRelay2Out(bool)` | 83 |
| `sendGmtpMessage(CIGCONF::GmtpMessage, const QByteArray&)` | 84 |
| `resetCanStates(bool)` | 85 |
| `forceBroadcastUIClose()` | 86 |
| `log(QByteArray&)` | 87 |
| `updatePreopTimer(QString)` | 88 |
| `amberDialogAboutToShow(bool)` | 89 |

**Public methods (declared):**

| Symbol | Line |
|--------|------|
| `Dialog(QWidget *parent = 0)` | 44 |
| `~Dialog()` | 45 |
| `onPowerChanged(CIGCONF::PowerState)` | 47 |
| `onReboot()` | 48 |
| `onBleReady(bool)` | 49 |
| `onNetworkReady(bool)` | 50 |
| `onCardAuthorised(bool, quint64)` | 51 |
| `onCmdLogin(quint64)` | 52 |
| `onIdleTimeout()` | 53 |
| `lockScreen(CIGCONF::MaintLockedCode, bool)` | 54 |
| `ambertImpactScreen()` | 55 |
| `updateLux(int)` | 57 |
| `updateStatus(...)` | 58 |
| `updateBatteryStatus(...)` | 59 |
| `updateExpModInfo(QByteArray)` | 60 |
| `onBroadcastMsgReceived(CIGCONF::BroadcastMessage)` | 61 |
| `showInformationScreen()` | 62 |
| `updateLoginImage()` | 63 |
| `quickPowerUpdate(bool)` | 64 |
| `onDemandStarted(...)` | 66 |
| `onDemandExtended(...)` | 67 |
| `onDemandEnded(...)` | 68 |
| `onLanguageChanged(void)` | 70 |
| `updateCamera()` | 72 |

**Private methods (declared in header):**

| Symbol | Line |
|--------|------|
| `onPinCode()` | 99 |
| `onCardSwiped(...)` | 100 |
| `onPinDialogAccepted()` | 102 |
| `onAuthorisedDialogAccepted()` | 103 |
| `onAuthorisedUserLogout()` | 104 |
| `onOptionalCheckConfirmed()` | 105 |
| `onCheckStartDialogAccepted()` | 106 |
| `onCheckQuestionDialogFinished(int)` | 107 |
| `onCheckConfirmationDialogFinished(int)` | 108 |
| `onCheckCompletedDialogAccepted()` | 109 |
| `onCheckCompletedDialogRejected()` | 110 |
| `onUnlockedDialogAccepted()` | 111 |
| `onProcessUnlock()` | 112 |
| `onPreopCommentDone()` | 113 |
| `onBroadcastDialogDone(int)` | 114 |
| `isValidId(quint64)` | 116 |
| `isChecklistEmpty(bool)` | 117 |
| `bypassChecklist()` | 118 |
| `clearWidgets()` | 119 |
| `login(quint64)` | 121 |
| `postLogin()` | 122 |
| `postMaintenanceLogin()` | 123 |
| `logout()` | 124 |
| `openMenuDialog()` | 125 |
| `startCheck(bool)` | 127 |
| `sendStartCheck()` | 128 |
| `superListUpdated(bool)` | 130 |
| `updateOnDemand()` | 131 |
| `convorStatusUpdated()` | 133 |
| `isOnDemandExpired()` | 135 |
| `fullLockStart()` | 137 |
| `updateFullLock()` | 138 |
| `updateTime()` | 140 |
| `writeMsgToQueue(CIGCONF::BroadcastMessage)` | 201 |
| `displayNextBroadcastMessage()` | 202 |
| `clearMsgQueue()` | 203 |
| `initOnScreenPreopTimer(quint16)` | 207 |
| `showCustomTimeFormat(quint32)` | 208 |
| `adjustPreopDialogs(bool)` | 212 |
| `updateBLEConSpinner(quint8)` | 214 |

**Private slot:**

| Symbol | Line |
|--------|------|
| `on_pushButton_clicked()` | 96 |

**Inner struct:**

| Name | Fields | Line |
|------|--------|------|
| `BroadcastMessageResponse` | `id`, `driverId`, `dispTimestamp` | 191–195 |

---

### `ui/dialog.cpp` — implemented functions

| Symbol | Line |
|--------|------|
| `Dialog::Dialog(...)` | 39 |
| `Dialog::~Dialog()` | 207 |
| `Dialog::updateBLEConSpinner(quint8)` | 212 |
| `Dialog::showInformationScreen()` | 228 |
| `Dialog::mouseReleaseEvent(QMouseEvent*)` | 238 |
| `Dialog::showEvent(QShowEvent*)` | 245 |
| `Dialog::updateLoginImage()` | 261 |
| `Dialog::onPinCode()` | 269 |
| `Dialog::onCardSwiped(...)` | 277 |
| `Dialog::onPinDialogAccepted()` | 319 |
| `Dialog::onAuthorisedDialogAccepted()` | 325 |
| `Dialog::onAuthorisedUserLogout()` | 332 |
| `Dialog::onCheckStartDialogAccepted()` | 339 |
| `Dialog::onCheckQuestionDialogFinished(int)` | 345 |
| `Dialog::onCheckConfirmationDialogFinished(int)` | 359 |
| `Dialog::onCheckCompletedDialogAccepted()` | 395 |
| `Dialog::onCheckCompletedDialogRejected()` | 449 |
| `Dialog::onUnlockedDialogAccepted()` | 461 |
| `Dialog::onProcessUnlock()` | 481 |
| `Dialog::onPreopCommentDone()` | 513 |
| `Dialog::onBroadcastDialogDone(int)` | 517 |
| `Dialog::login(quint64)` | 543 |
| `Dialog::openMenuDialog()` | 577 |
| `Dialog::postLogin()` | 590 |
| `Dialog::postMaintenanceLogin()` | 659 |
| `Dialog::logout()` | 674 |
| `Dialog::lockScreen(CIGCONF::MaintLockedCode, bool)` | 691 |
| `Dialog::ambertImpactScreen()` | 728 |
| `Dialog::startCheck(bool)` | 733 |
| `Dialog::sendStartCheck()` | 767 |
| `Dialog::isValidId(quint64)` | 773 |
| `Dialog::isChecklistEmpty(bool)` | 781 |
| `Dialog::bypassChecklist()` | 792 |
| `Dialog::clearWidgets()` | 875 |
| `Dialog::onPowerChanged(CIGCONF::PowerState)` | 899 |
| `Dialog::onReboot()` | 927 |
| `Dialog::onBleReady(bool)` | 934 |
| `Dialog::onNetworkReady(bool)` | 950 |
| `Dialog::updateStatus(...)` | 955 |
| `Dialog::onCardAuthorised(bool, quint64)` | 960 |
| `Dialog::onCmdLogin(quint64)` | 980 |
| `Dialog::onIdleTimeout()` | 986 |
| `Dialog::updateLux(int)` | 1008 |
| `Dialog::updateBatteryStatus(...)` | 1013 |
| `Dialog::updateExpModInfo(QByteArray)` | 1018 |
| `Dialog::superListUpdated(bool)` | 1023 |
| `Dialog::updateOnDemand()` | 1037 |
| `Dialog::onDemandStarted(...)` | 1069 |
| `Dialog::onDemandExtended(...)` | 1086 |
| `Dialog::onDemandEnded(...)` | 1106 |
| `Dialog::isOnDemandExpired()` | 1125 |
| `Dialog::convorStatusUpdated()` | 1135 |
| `Dialog::onBroadcastMsgReceived(CIGCONF::BroadcastMessage)` | 1155 |
| `Dialog::writeMsgToQueue(CIGCONF::BroadcastMessage)` | 1169 |
| `Dialog::displayNextBroadcastMessage()` | 1177 |
| `Dialog::clearMsgQueue()` | 1203 |
| `Dialog::initOnScreenPreopTimer(quint16)` | 1209 |
| `Dialog::adjustPreopDialogs(bool)` | 1225 |
| `Dialog::showCustomTimeFormat(quint32)` | 1249 |
| `Dialog::onLanguageChanged()` | 1260 |
| `Dialog::on_pushButton_clicked()` | 1285 |
| `Dialog::updateTime()` | 1291 |
| `Dialog::quickPowerUpdate(bool)` | 1314 |
| `Dialog::updateCamera()` | 1321 |

---

## Findings

---

**A20-1** · HIGH · `fullLockStart` and `updateFullLock` declared but never implemented

**Description:** `dialog.h` lines 137–138 declare two private methods, `fullLockStart()` and `updateFullLock()`, that have no corresponding definition anywhere in `dialog.cpp` or any other translation unit. The feature they were intended to implement — presumably a "full lockout" timer-driven UI update flow — is instead handled inline with direct `gCfg->fullLockoutEnable()` / `gCfg->fullLockoutTimeout()` checks scattered through the codebase. Leaving unimplemented declarations in the header is a latent build and maintenance hazard: any future caller of these methods will fail to link, and readers cannot tell whether the omission is intentional.

**Fix:** Either implement both methods or remove both declarations from `dialog.h` and confirm the full-lockout logic that was meant to call them is fully covered by the existing inline guards.

---

**A20-2** · MEDIUM · `onPreopCommentDone()` is a declared handler with an empty body

**Description:** `dialog.h` line 113 declares `onPreopCommentDone()` as a private method. Its implementation at `dialog.cpp` lines 513–515 is a completely empty stub:

```cpp
void Dialog::onPreopCommentDone() {

}
```

The method is never connected to any signal. The pre-op comment accept/reject paths in the constructor (lines 122–127) use separate lambdas that call `onCheckCompletedDialogAccepted()` and `m_checkCompletedDialog->open()` directly, making `onPreopCommentDone()` unreachable dead code. Its presence implies an incomplete refactoring.

**Fix:** Remove the declaration from `dialog.h` and the empty definition from `dialog.cpp`. If the intended handler logic was never ported, document what behavior is missing and implement it.

---

**A20-3** · MEDIUM · `onOptionalCheckConfirmed()` declared but never implemented or called

**Description:** `dialog.h` line 105 declares private method `onOptionalCheckConfirmed()`. There is no definition of this method anywhere in `dialog.cpp`, and no `connect()` call or direct invocation of it exists in the codebase. This is a second unimplemented private method alongside `fullLockStart` and `updateFullLock`, indicating a pattern of stale declarations left from abandoned feature work.

**Fix:** Remove the declaration from `dialog.h`. If optional-check-confirmed logic is genuinely needed, implement and connect it.

---

**A20-4** · MEDIUM · Commented-out multi-line code block in `onCheckQuestionDialogFinished`

**Description:** `dialog.cpp` lines 349–357 contain a large commented-out block inside `onCheckQuestionDialogFinished`:

```cpp
/*m_checkConfirmationDialog->confirm(m_checkSelectedYes);
m_checkConfirmationDialog->setQuestion(m_checkQuestionDialog->question());
m_checkConfirmationDialog->open();
if (m_survTo)
{
    m_overlay->show();
    m_overlay->raise();
}*/
```

This represents the original two-step confirmation flow that was bypassed when the design was simplified to skip the intermediate confirmation dialog. The dead code causes confusion about whether `CheckConfirmationDialog` is still part of the active flow, and whether `CheckConfirmationDialog::confirm()` and `CheckConfirmationDialog::setQuestion()` still need to be maintained.

**Fix:** Delete the commented-out block. If `CheckConfirmationDialog` is now fully unused in the normal question flow, audit whether the class and its connections (lines 104–105, 1227–1228) can also be removed.

---

**A20-5** · MEDIUM · Commented-out `#include` and log call for `SerialLogger`

**Description:** `dialog.cpp` line 21 has `//#include "platform/seriallogger.h"` and line 312 has `//SerialLogger::log("[MONIT] Login attempt while exp mod comms not ready");`. The logger appears to have been deactivated without a replacement. The commented include is particularly problematic because it hides whether `SerialLogger` is still a valid, maintained module.

**Fix:** Remove both commented-out lines. If structured logging is still needed for this code path, replace with the active logging mechanism used elsewhere (e.g., `qDebug` or the `log()` signal).

---

**A20-6** · MEDIUM · Commented-out `QTimer::singleShot` lock call in constructor

**Description:** `dialog.cpp` line 204 contains:

```cpp
//QTimer::singleShot(0, [this](){if (gCfg->maintCode() != CIGCONF::MaintNormal) lockScreen(gCfg->maintCode());});
```

This duplicates the `showEvent` logic at line 257. The commented form also omits the `remote` parameter (`false`) that the live call passes. Leaving this in place suggests an incomplete decision about the preferred initialization path.

**Fix:** Remove the commented line; the live `showEvent` implementation already handles initial lock state.

---

**A20-7** · MEDIUM · Commented-out `onIdleTimeout` early return for VOR status

**Description:** `dialog.cpp` lines 992–993:

```cpp
//    if (gCfg->convorStatus())
//        return;
```

This guard was silently removed from `onIdleTimeout`. Without this guard, an idle timeout while the vehicle is in "Vehicle Out of Service" (VOR/convor) mode will log the driver out via `logout()`, which conflicts with the convor session behavior enforced elsewhere (e.g., `lockScreen` returns early on convor, `login` routes convor users to `m_vorwarningDialog`). The comment gives no explanation for why this guard was disabled.

**Fix:** Determine the correct intended behavior for idle timeout under convor status. Either restore the guard with an explanatory comment or remove the commented lines and document the decision.

---

**A20-8** · MEDIUM · Commented-out wiegand recalculation in `onCardSwiped`

**Description:** `dialog.cpp` line 308:

```cpp
//quint64 wiegand = EM070::WiegandRfid::wiegandData(facility, number);
```

This shadowed local was commented out at an unknown time. The variable name matches the parameter name, and the `facility`/`number` parameters are now suppressed with `Q_UNUSED` (lines 279–280). The function parameter list still carries `quint16 facility` and `quint32 number` which are never used. This is misleading; readers may assume the facility/number values are validated.

**Fix:** Remove the commented line and the two unused parameters from the `onCardSwiped` signature (both declaration in `dialog.h` line 100 and definition in `dialog.cpp` line 277). Update the two call sites accordingly.

---

**A20-9** · LOW · Typo in public method name `ambertImpactScreen`

**Description:** `dialog.h` line 55 declares `void ambertImpactScreen()`. The name contains a spurious `t` — it should be `amberImpactScreen`. All callers (and the implementation at `dialog.cpp` line 728) use the same typo, so there is no current compile error, but the name is confusing and inconsistent with related identifiers such as `amberDialogAboutToShow` and `AmberImpactAlertDialog`.

**Fix:** Rename `ambertImpactScreen` to `amberImpactScreen` across the declaration, definition, and all call sites.

---

**A20-10** · LOW · Naming inconsistency: `UpdateTextInput` violates `camelCase` convention

**Description:** In `CommentDialog`, the public method `UpdateTextInput` (`commentdialog.h` line 29) uses `PascalCase`, inconsistent with every other method in the same class (`onkeyboardClosed`, `onUnlkReasonSelected`, `languageChanged`, `run_keyboard_lineEdit`, `onDone`, `onSkip`, `debounce`, `reset`, `showWidgets`). There is also `onkeyboardClosed` (lowercase `k`) versus the typical Qt `onFooBar` pattern, but the `UpdateTextInput` inconsistency is the most prominent.

**Fix:** Rename `UpdateTextInput` to `updateTextInput` throughout (declaration, definition, and the `connect` call in the constructor at `commentdialog.cpp` line 23).

---

**A20-11** · LOW · `onkeyboardClosed` and `onUnlkReasonSelected` are public but should be private

**Description:** `commentdialog.h` lines 30–31 declare `onkeyboardClosed()` and `onUnlkReasonSelected()` as `public`. Both methods are internal response handlers connected to child/grandchild widget signals in the constructor. Nothing outside `CommentDialog` calls them directly. Exposing them as public widens the class interface unnecessarily and risks accidental external invocation.

**Fix:** Move both methods to the `private slots:` section alongside `run_keyboard_lineEdit`, `onDone`, and `onSkip`.

---

**A20-12** · LOW · `showEvent` default-argument override is a deprecated Qt pattern

**Description:** `commentdialog.h` line 47 declares `void showEvent(QShowEvent *event = 0)` with a default null argument. The same pattern appears in `checkstartdialog.h` (via the base) and `dialog.h` line 93. Qt virtual event handlers are never invoked with a null pointer by the framework; the default argument exists only because `commentdialog.cpp` line 202 calls `showEvent()` with no arguments from `reset()`. Providing a default argument to an overriding virtual is a code smell: it can silently fail to call the base class's override chain correctly and triggers `-Woverloaded-virtual` warnings on some compilers.

**Fix:** Remove the default argument from the override declaration. In `reset()`, replace the no-argument call to `showEvent()` with a direct call to `showWidgets()`, which is the actual work being re-triggered.

---

**A20-13** · LOW · `QWidget *parent = 0` should use `nullptr`

**Description:** All three headers use `QWidget *parent = 0` as the constructor default (`checkstartdialog.h` line 15, `commentdialog.h` line 26, `dialog.h` line 44). Qt 5 and Qt 6 both deprecate raw `0` in favor of `nullptr` for pointer defaults. The rest of the codebase mixes both forms (e.g., `commentdialog.h` already uses `nullptr` for `parent` in some internal declarations).

**Fix:** Replace `= 0` with `= nullptr` in all three constructor declarations for consistency with the C++11 style used elsewhere in the project.

---

**A20-14** · LOW · Magic number `2*60*1000` for broadcast message beeper interval

**Description:** `dialog.cpp` line 1198:

```cpp
m_messageTimer->start(2*60*1000);
```

This inline computation (two minutes in milliseconds) is not named or explained. Unlike `NO_ACTIVITY_TIME` (which is a named macro in `commentdialog.h`), this value is embedded directly in the logic with no symbolic label, making it harder to discover or adjust.

**Fix:** Define a named constant, e.g., `constexpr int BROADCAST_BEEPER_INTERVAL_MS = 2 * 60 * 1000;`, and use it at the call site.

---

**A20-15** · LOW · String comparison used as state machine discriminator in `onDone`/`onSkip`

**Description:** `commentdialog.cpp` lines 147 and 173 gate the confirm action by comparing the button label text to a translated string:

```cpp
if (ui->btnDone->text() == tr("Confirm?")) { ... }
if (ui->btnSkipButton->text() == tr("Confirm?")) { ... }
```

Using a localised UI string as the state variable is fragile: a translation change, a font renderer substitution, or a future l10n fix for the `"Confirm?"` string (e.g., making it language-specific) would silently break the two-tap confirmation flow without a compile error. The same issue affects the `onSkip` path.

**Fix:** Introduce a private boolean flag (e.g., `m_confirmPending`) that is set when the first tap is received and cleared on timer reset. Use that flag instead of text comparison to gate the confirm action.

---

**A20-16** · INFO · `Dialog` is a 1,325-line orchestrator tightly coupling 15+ child dialogs

**Description:** `Dialog` directly owns and wires 15 child dialog objects (`m_pinDialog`, `m_authorisedDialog`, `m_checkStartDialog`, `m_checkQuestionDialog`, `m_checkConfirmationDialog`, `m_checkCompletedDialog`, `m_lockedDialog`, `m_unlockedDialog`, `m_messageDialog`, `m_informationDialog`, `m_onDemandDialog`, `m_unlockReasonDlg`, `m_preopCommentDlg`, `m_broadcastDialog`, `m_supervisorDialog`, `m_languageDialog`, `m_amberImpactAlertDialog`, `m_vorwarningDialog`), three hardware driver objects, four `QTimer` objects, and carries all application state. Each new dialog class is a concrete type exposed directly as a private member; there is no abstraction layer between `Dialog` and the child widgets it orchestrates. While this is a known legacy architecture, it makes unit testing, feature flagging, and any future UI recomposition disproportionately expensive.

**Fix:** No immediate action required for correctness. For long-term maintainability, consider extracting state machines (e.g., the checklist flow, the lock/unlock flow) into separate controller objects and injecting child dialogs through interfaces rather than owning them directly.

---

**A20-17** · INFO · Acknowledged TODO: `gCfg` not guarded for multi-thread access

**Description:** `dialog.cpp` lines 35–37:

```cpp
/*
 * TODO: all functions of gCfg might be guarded as they are used in multithread
 */
```

This comment acknowledges a known concurrency risk that has not been addressed. It is tracked here for completeness; the thread-safety analysis of `gCfg` is out of scope for this pass.

**Fix:** Raise as a separate task; address in a dedicated concurrency audit pass.

---

## Summary Table

| ID | Severity | Title |
|----|----------|-------|
| A20-1 | HIGH | `fullLockStart` / `updateFullLock` declared but never implemented |
| A20-2 | MEDIUM | `onPreopCommentDone()` is an empty stub never connected to any signal |
| A20-3 | MEDIUM | `onOptionalCheckConfirmed()` declared but never implemented or called |
| A20-4 | MEDIUM | Commented-out multi-line confirmation dialog block in `onCheckQuestionDialogFinished` |
| A20-5 | MEDIUM | Commented-out `SerialLogger` include and log call |
| A20-6 | MEDIUM | Commented-out duplicate `QTimer::singleShot` lock call in constructor |
| A20-7 | MEDIUM | Commented-out VOR status guard in `onIdleTimeout` with unexplained intent |
| A20-8 | MEDIUM | Commented-out wiegand recalculation leaves two parameters permanently unused |
| A20-9 | LOW | Typo `ambertImpactScreen` (spurious `t`) in public API |
| A20-10 | LOW | `UpdateTextInput` uses PascalCase inconsistent with rest of class |
| A20-11 | LOW | `onkeyboardClosed` and `onUnlkReasonSelected` are public but should be private slots |
| A20-12 | LOW | `showEvent` default-argument override is a deprecated / warning-prone pattern |
| A20-13 | LOW | Constructor `parent` defaults use `= 0` instead of `= nullptr` |
| A20-14 | LOW | Magic number `2*60*1000` for broadcast beeper timer interval |
| A20-15 | LOW | Translated button label string used as state-machine discriminator in `onDone`/`onSkip` |
| A20-16 | INFO | `Dialog` tightly couples 15+ child dialogs in a 1,325-line God-class |
| A20-17 | INFO | Acknowledged unresolved TODO for `gCfg` multi-thread safety |

**Totals:** 1 HIGH, 6 MEDIUM, 7 LOW, 2 INFO
# Pass 4 Agent A21 — Code Quality

**Audit run:** 2026-02-28-01
**Branch:** master
**Files reviewed:**
- `ui/informationdialog.h` + `ui/informationdialog.cpp`
- `ui/keyfilter.h` + `ui/keyfilter.cpp`
- `ui/languagedialog.h` + `ui/languagedialog.cpp`

---

## Reading Evidence

### `ui/informationdialog.h`

**Class:** `InformationDialog : public QDialog`

| Line | Member / Function |
|------|-------------------|
| 21 | `explicit InformationDialog(QWidget *parent = 0)` — constructor |
| 22 | `~InformationDialog()` — destructor |
| 23 | `void updateInformationScreen()` |
| 24 | `void setLux(int lux)` |
| 25 | `void setStatus(QByteArray IO, bool Rly1, bool Rly2, QByteArray can, const QByteArray &rssi, const QByteArray &moni, bool netStat, bool mdemStat, bool wifiStat, qint8 sat, qint32 lat, qint32 lon)` |
| 26 | `void setConfigParam()` |
| 27 | `void setBatteryStatus(bool avail, int state, int fault, quint16 voltage, qint16 current, quint16 temp, quint16 remainingCapacity)` |
| 28 | `void setExpModInfo(QByteArray mainVersion)` |
| 29 | `void setSuperMasterStatus()` |
| 30 | `void setVOR()` |
| 31 | `void setLastWiegand(quint64 id)` |
| 32 | `void languageChanged()` |
| 35 | `void showEvent(QShowEvent *)` — protected override |
| 36 | `void hideEvent(QHideEvent *)` — protected override |

**Private members:**
- `Ui::InformationDialog *ui` (line 39)
- `QMap<int, QString> m_chargeStatusMap` (line 40)
- `QMap<int, QString> m_chargeFaultMap` (line 41)
- `QTimer *m_updateConfigTmr` (line 42)

**Types / constants defined in implementation:**
- `#define UPDATE_CONFIG_TIMER_MS 5000` (informationdialog.cpp, line 9)

---

### `ui/informationdialog.cpp`

| Line | Function |
|------|----------|
| 11  | `InformationDialog::InformationDialog(QWidget *parent)` — constructor |
| 89  | `void InformationDialog::hideEvent(QHideEvent *)` |
| 94  | `void InformationDialog::showEvent(QShowEvent *)` |
| 101 | `InformationDialog::~InformationDialog()` |
| 106 | `void InformationDialog::setLux(int lux)` |
| 111 | `void InformationDialog::setStatus(QByteArray IO, bool Rly1, bool Rly2, QByteArray can, const QByteArray &rssi, const QByteArray &moni, bool netStat, bool modemStat, bool wifiStat, qint8 sat, qint32 lat, qint32 lon)` |
| 126 | `void InformationDialog::setBatteryStatus(bool avail, int state, int fault, quint16 voltage, qint16 current, quint16 temp, quint16 remainingCapacity)` |
| 137 | `void InformationDialog::setConfigParam()` |
| 195 | `void InformationDialog::setExpModInfo(QByteArray mainVersion)` |
| 200 | `void InformationDialog::setSuperMasterStatus()` |
| 220 | `void InformationDialog::setVOR()` |
| 228 | `void InformationDialog::setLastWiegand(quint64 id)` |
| 233 | `void InformationDialog::updateInformationScreen()` |
| 240 | `void InformationDialog::languageChanged()` |

---

### `ui/keyfilter.h`

**Class:** `KeyFilter : public QObject`

| Line | Member / Function |
|------|-------------------|
| 13 | `explicit KeyFilter(QObject *parent = nullptr)` — constructor |
| 13 | `static bool isPowerKeyPressed()` — static inline accessor |
| 16 | `signal: void showInfoDialog()` |
| 18 | `bool eventFilter(QObject *obj, QEvent *event)` — protected override |
| 21 | `static bool m_powerKeyPressed` — static private member |
| 22 | `QSet<int> m_pressedKeys` — private member |
| 24 | `QTimer *m_timer` — private member |
| 25 | `int m_leftKeyCount` |
| 26 | `int m_rightKeyCount` |
| 27 | `int m_upKeyCount` |
| 28 | `int m_downKeyCount` |
| 29 | `bool m_leftKeyPressed` |
| 30 | `bool m_rightKeyPressed` |
| 31 | `bool m_upKeyPressed` |
| 32 | `bool m_downKeyPressed` |
| 34 | `void resetKeyCount()` — private |
| 35 | `void incrementKeyCount(int key)` — private |
| 36 | `int getKeyCount(int key)` — private |
| 37 | `void resetKeyCounter(int key)` — private |
| 38 | `bool getPressState(int key)` — private |
| 39 | `void setPressState(int key, bool state)` — private |

---

### `ui/keyfilter.cpp`

| Line | Function |
|------|----------|
| 6   | `bool KeyFilter::m_powerKeyPressed = false` — static member definition |
| 8   | `KeyFilter::KeyFilter(QObject *parent)` — constructor |
| 20  | `bool KeyFilter::eventFilter(QObject *obj, QEvent *event)` |
| 66  | `void KeyFilter::resetKeyCount()` |
| 76  | `void KeyFilter::incrementKeyCount(int key)` |
| 101 | `int KeyFilter::getKeyCount(int key)` |
| 114 | `void KeyFilter::resetKeyCounter(int key)` |
| 126 | `void KeyFilter::setPressState(int key, bool state)` |
| 145 | `bool KeyFilter::getPressState(int key)` |

---

### `ui/languagedialog.h`

**Class:** `LanguageDialog : public QDialog`

| Line | Member / Function |
|------|-------------------|
| 15 | `explicit LanguageDialog(QWidget *parent = nullptr)` — constructor |
| 16 | `~LanguageDialog()` |
| 17 | `void languageChanged()` |
| 18 | `void startScreenTimeout()` |
| 21 | `signal: void sigLanguageChanged()` |
| 24 | `slot: void on_btnEnglish_clicked()` — private slot |
| 25 | `slot: void on_btnSpanish_clicked()` — private slot |
| 26 | `slot: void on_btnQuit_clicked()` — private slot |
| 29 | `void showEvent(QShowEvent *event = 0)` — protected override |
| 32 | `Ui::LanguageDialog *ui` — private member |
| 33 | `QTimer *m_timer` — private member |
| 34 | `bool debounce()` — private |
| 35 | `quint32 m_lastPress` — private member |

**Constants defined in implementation:**
- `#define NO_ACTIVITY_TIME (10000)` (languagedialog.cpp, line 10)

---

### `ui/languagedialog.cpp`

| Line | Function |
|------|----------|
| 12 | `LanguageDialog::LanguageDialog(QWidget *parent)` — constructor |
| 25 | `LanguageDialog::~LanguageDialog()` |
| 30 | `void LanguageDialog::on_btnEnglish_clicked()` |
| 42 | `void LanguageDialog::on_btnSpanish_clicked()` |
| 54 | `void LanguageDialog::on_btnQuit_clicked()` |
| 59 | `void LanguageDialog::showEvent(QShowEvent *event)` |
| 65 | `bool LanguageDialog::debounce()` |
| 76 | `void LanguageDialog::languageChanged()` |
| 84 | `void LanguageDialog::startScreenTimeout()` |

---

## Findings

---

**A21-1** · HIGH · Deprecated `qChecksum` signature — potential length mismatch and Qt 6 breakage

**Description:** `informationdialog.cpp` line 74 calls:
```cpp
quint16 checksum = qChecksum(string.toLatin1().constData(), string.size());
```
Two distinct problems exist here. First, `string` is a `QString`; `string.size()` returns the number of UTF-16 code units, not the number of Latin-1 bytes produced by `.toLatin1()`. For any version string containing only ASCII characters these numbers coincide, but the distinction is latent and would cause an over-read the moment a non-ASCII character appears. Second, the two-argument `qChecksum(const char*, uint)` overload was deprecated in Qt 5.9 and removed in Qt 6. The project `.pro` file contains `QT_DEPRECATED_WARNINGS`, meaning this call already triggers a compiler warning on Qt 5.9+.

**Fix:** Store the `QByteArray` in a named local, pass its own `.size()`, and use the Qt 5.9+ three-argument overload that accepts a `QChecksumsType` so the call compiles cleanly on both Qt 5 and Qt 6:
```cpp
QByteArray la = string.toLatin1();
quint16 checksum = qChecksum(la.constData(), static_cast<uint>(la.size()));
```

---

**A21-2** · MEDIUM · `setStatus` parameter name inconsistency between declaration and definition

**Description:** The header declaration at `informationdialog.h:25` names the modem-status parameter `mdemStat`, while the implementation at `informationdialog.cpp:111` names it `modemStat`. Although this does not affect compilation (parameter names in declarations are advisory), it is a maintenance hazard: readers of the header see an abbreviated name that does not match the implementation, and grep/cross-reference tools may miss usages.

**Fix:** Align the parameter name to the more descriptive form used in the implementation. Change `informationdialog.h:25` to use `modemStat` consistently.

---

**A21-3** · MEDIUM · Leaky abstraction — `setStatus` takes 12 positional arguments

**Description:** `InformationDialog::setStatus` at `informationdialog.h:25` / `informationdialog.cpp:111` accepts 12 positional arguments covering relay states, CSQ, network/modem/WiFi status, MONI, digital IO, CAN data, and GPS coordinates. This is far beyond the commonly accepted limit of 4–5 parameters and forces every call site to supply all 12 values in the correct order with no compiler protection against transposition of same-typed arguments (e.g., `bool Rly1, bool Rly2` followed by three more booleans). The coupling between the caller (which assembles all hardware status at once) and the dialog's display concerns is maximal.

**Fix:** Introduce a value-type status struct (e.g., `struct DeviceStatus`) that groups related fields. The `setStatus` call becomes `setStatus(const DeviceStatus &)`, callers populate the struct by name, and the dialog remains decoupled from the order of hardware fields.

---

**A21-4** · MEDIUM · Hardcoded hardware revision string with TODO comment

**Description:** `informationdialog.cpp:42` contains:
```cpp
// TODO: currently doesn't support
ui->labelHwVer->setText("EM-070-02-B");
```
The hardware version is a hardcoded literal with an unresolved TODO. Because this string is also used in the `qChecksum` calculation (lines 69–74) that generates the barcode on the System tab, deploying on hardware with a different PCB revision silently produces a wrong barcode without any runtime error.

**Fix:** Read the hardware version from a device file, configuration source, or compile-time define that reflects the actual deployed revision. At minimum, promote the string to a named constant and remove the stale TODO or file a tracked issue.

---

**A21-5** · MEDIUM · `languagedialog.h` — `showEvent` declares a non-standard default argument

**Description:** `languagedialog.h:29` declares:
```cpp
void showEvent(QShowEvent *event = 0);
```
The base class `QWidget::showEvent(QShowEvent *)` has no default argument. Providing a default argument on an override is both a style violation and potentially confusing: it implies `showEvent()` can be called with no argument, which is never done. The C++ standard permits this but most static analysers flag it as a defect.

**Fix:** Remove the `= 0` default from the override declaration:
```cpp
void showEvent(QShowEvent *event) override;
```
Add `override` while editing to make the override relationship explicit.

---

**A21-6** · MEDIUM · `languagedialog.h` — missing `#include <QTimer>` for member type

**Description:** `languagedialog.h:33` declares `QTimer *m_timer` but the header does not include `<QTimer>`. The code compiles only because `ui_languagedialog.h` or another transitively-included header happens to pull in `QTimer`. This is a fragile dependency on include order.

**Fix:** Add `#include <QTimer>` to `languagedialog.h` directly.

---

**A21-7** · LOW · `KeyFilter` constructor only initialises `m_leftKeyPressed`; three bool members left uninitialised

**Description:** `keyfilter.cpp:8–18` — the constructor initialiser list is:
```cpp
m_timer(new QTimer(this)),
m_leftKeyCount(0),
m_rightKeyCount(0),
m_upKeyCount(0),
m_downKeyCount(0),
m_leftKeyPressed(false)
```
The three members `m_rightKeyPressed`, `m_upKeyPressed`, and `m_downKeyPressed` (declared at `keyfilter.h:30–32`) are not listed. Because `KeyFilter` inherits from `QObject` (which does not zero-initialise its subclass members), these booleans have indeterminate values until the first call to `setPressState`. The `getPressState` function reads them before any initialisation if a key release event arrives before the first press of that key, producing undefined behaviour.

**Fix:** Add all three to the initialiser list:
```cpp
m_leftKeyPressed(false),
m_rightKeyPressed(false),
m_upKeyPressed(false),
m_downKeyPressed(false)
```

---

**A21-8** · LOW · Commented-out `qDebug` blocks left in production code

**Description:** `keyfilter.cpp` contains five commented-out debug lines:
- Line 129: `// qDebug() << "KeyFilter::Key_Left: State=" << state;`
- Line 132: `// qDebug() << "KeyFilter::Key_Up: State=" << state;` (mislabelled as `Key_Up` for the `Key_Right` branch)
- Line 135: `// qDebug() << "KeyFilter::Key_Up: State=" << state;`
- Line 138: `// qDebug() << "KeyFilter::Key_Down: State=" << state;`
- Line 141: `// qDebug() << "KeyFilter::others:" << key << " State=" << state;`

These add visual noise, and the mislabelled `Key_Up` comment on line 132 (inside the `Key_Right` branch) is actively misleading to anyone who re-enables debug logging.

**Fix:** Remove all commented-out debug lines. If conditional debug output is needed, use `qCDebug` with a named category controlled by `QLoggingCategory` so it can be enabled at runtime without code changes.

---

**A21-9** · LOW · Inconsistent naming convention — `InformationDialog` constructor uses `QWidget *parent = 0` instead of `nullptr`

**Description:** `informationdialog.h:21` declares:
```cpp
explicit InformationDialog(QWidget *parent = 0);
```
The rest of the codebase (`KeyFilter`, `LanguageDialog`) uses `nullptr`. Using `0` as a null pointer constant is legal C++ but deprecated style since C++11 and is flagged by `-Wzero-as-null-pointer-constant` on modern GCC/Clang.

**Fix:** Change to `QWidget *parent = nullptr` to be consistent with the other classes in this directory.

---

**A21-10** · LOW · `languagedialog.h` — `showEvent` default argument uses `0` instead of `nullptr`

**Description:** `languagedialog.h:29`:
```cpp
void showEvent(QShowEvent *event = 0);
```
This is the same style issue as A21-9 but compounded by the unnecessary default argument (see A21-5). Both problems should be resolved together.

**Fix:** Remove the default argument and use `nullptr` style if any default is ever warranted.

---

**A21-11** · LOW · `InformationDialog` parameter naming violates project convention — capitalised parameter names

**Description:** `setStatus` uses `bool Rly1, bool Rly2` (capitalised, abbreviated) and `QByteArray IO` (all caps) while the remainder of the codebase uses `lowerCamelCase` for parameters. This inconsistency makes the function signature stand out as having originated from a different style guide and increases the risk of future misreads.

**Fix:** Rename to `bool relay1, bool relay2, QByteArray ioState` (or equivalent lower-camel forms) in both header and implementation.

---

**A21-12** · LOW · `languagedialog.cpp` — file opened in `languageChanged()` but never closed on the success path

**Description:** `languagedialog.cpp:306–309`:
```cpp
QFile file("/sys/class/net/wlan0/address");
if (!file.open(QIODevice::ReadOnly)) {
    ui->lblMacAddress_2->setText(tr("na"));
}
```
The file is opened only to test whether the WiFi interface exists; on success the file is left open and the `QFile` destructor eventually closes it. This is not a resource leak per se (RAII closes it), but the intent is clearly only to check existence. Additionally, `setConfigParam()` (lines 164–169) correctly opens, reads, and closes the same file. This code in `languageChanged()` duplicates the existence check unnecessarily. If `languageChanged()` is called repeatedly (it is — on every `showEvent`), this opens and silently leaks the file descriptor for the lifetime of each `QFile` stack object.

**Fix:** Remove the duplicate file-open test from `languageChanged()`. The "na" fallback for the WiFi MAC address label is already handled adequately in `setConfigParam()`, which is called from both `showEvent()` and the periodic timer.

---

**A21-13** · INFO · `InformationDialog` stylesheet embedded as a string literal in constructor

**Description:** `informationdialog.cpp:20–36` defines a multi-line `QString styleSheet` directly in the constructor. While functional, embedding display styling in C++ source couples appearance to compiled code and makes it impossible to adjust the UI skin without recompiling.

**Fix:** Move the stylesheet to a Qt resource file (`.qss`) loaded at runtime via `QFile`, or define it in the `.ui` designer file where it can be reviewed visually.

---

**A21-14** · INFO · `KeyFilter` models per-key state as four parallel scalar fields rather than a map or array

**Description:** `keyfilter.h` declares eight separate member variables (`m_leftKeyCount`, `m_rightKeyCount`, `m_upKeyCount`, `m_downKeyCount`, `m_leftKeyPressed`, `m_rightKeyPressed`, `m_upKeyPressed`, `m_downKeyPressed`) and `keyfilter.cpp` replicates the same `if/else if` chain six times across `incrementKeyCount`, `getKeyCount`, `resetKeyCounter`, `getPressState`, and `setPressState`. This design violates DRY, contributed to the uninitialised-member bug (A21-7), and would require changes in eight places if a fifth key were added.

**Fix:** Replace the eight fields with `QMap<int, int> m_keyCounts` and `QMap<int, bool> m_keyPressed` (keyed by `Qt::Key`). The five helper methods collapse to two or three lines each, and initialisation is automatic.

---

## Summary Table

| ID | Severity | Category | File | Line(s) | Title |
|----|----------|----------|------|---------|-------|
| A21-1 | HIGH | Deprecated API / correctness | `ui/informationdialog.cpp` | 74 | `qChecksum` uses deprecated 2-arg overload with mismatched length |
| A21-2 | MEDIUM | Inconsistency | `ui/informationdialog.h` / `.cpp` | 25 / 111 | `setStatus` parameter name `mdemStat` vs `modemStat` |
| A21-3 | MEDIUM | Leaky abstraction | `ui/informationdialog.h` | 25 | `setStatus` has 12 positional parameters |
| A21-4 | MEDIUM | Dead / hardcoded data | `ui/informationdialog.cpp` | 42 | Hardcoded hardware revision with unresolved TODO |
| A21-5 | MEDIUM | Style / correctness | `ui/languagedialog.h` | 29 | `showEvent` override declares non-standard default argument |
| A21-6 | MEDIUM | Missing include | `ui/languagedialog.h` | 33 | `QTimer` used but not included in header |
| A21-7 | LOW | Uninitialised member | `ui/keyfilter.cpp` | 8–18 | Three `bool` press-state members not initialised in constructor |
| A21-8 | LOW | Commented-out code | `ui/keyfilter.cpp` | 129,132,135,138,141 | Five commented-out `qDebug` lines (one mislabelled) |
| A21-9 | LOW | Style | `ui/informationdialog.h` | 21 | `parent = 0` should be `parent = nullptr` |
| A21-10 | LOW | Style | `ui/languagedialog.h` | 29 | `event = 0` should use `nullptr` (see also A21-5) |
| A21-11 | LOW | Naming convention | `ui/informationdialog.h` / `.cpp` | 25 / 111 | Capitalised parameter names `Rly1`, `Rly2`, `IO` violate camelCase convention |
| A21-12 | LOW | Resource management | `ui/languagedialog.cpp` | 306–309 | File opened in `languageChanged()` only for existence check; duplicate of `setConfigParam()` logic |
| A21-13 | INFO | Maintainability | `ui/informationdialog.cpp` | 20–36 | Stylesheet embedded as string literal in constructor |
| A21-14 | INFO | Design / DRY | `ui/keyfilter.h` / `.cpp` | multiple | Eight parallel scalar fields instead of a keyed collection |
# Pass 4 Agent A22 — Code Quality

**Audit run:** 2026-02-28-01
**Branch:** master
**Files reviewed:**
- `ui/lockeddialog.h` + `ui/lockeddialog.cpp`
- `ui/messagedialog.h` + `ui/messagedialog.cpp`
- `ui/onScreenKeyboard.h` + `ui/onScreenKeyboard.cpp`

---

## Reading Evidence

### `ui/lockeddialog.h` + `ui/lockeddialog.cpp`

**Class:** `LockedDialog` (extends `QDialog`)

**Public methods (header line numbers):**

| Location | Signature |
|---|---|
| h:18 | `explicit LockedDialog(QWidget *parent = 0)` — constructor |
| h:19 | `~LockedDialog()` — destructor |
| h:20 | `void setLockedReason(CIGCONF::MaintLockedCode lockedCode)` |
| h:21 | `void languageChanged(void)` |
| h:22 | `void setTimeRemaining(quint32 secs)` |
| h:23 | `void clearTimerText()` |
| h:24 | `void stopTimer()` |
| h:25 | `void startTimer()` |

**Signals:**

| Location | Signature |
|---|---|
| h:32 | `void fullLockoutTimerEnded(bool on1, bool on2)` |
| h:33 | `void beeperOn()` |

**Protected methods:**

| Location | Signature |
|---|---|
| h:36 | `void mouseReleaseEvent(QMouseEvent *)` — inline, calls `accept()` |

**Private methods:**

| Location | Signature |
|---|---|
| h:40 | `void updateFullLock()` |
| h:41 | `void fullLockStart()` |

**Private members:**

- `Ui::LockedDialog *ui` — h:39
- `QTimer *m_fullLockTimer` — h:43
- `quint32 m_timeCntr` — h:44

**Conditional compilation:**
- `#ifdef UNIT_TEST` — h:27–29: `friend class TestDialog`

**Types used from external header (`app/cigconfigs.h`):**

`CIGCONF::MaintLockedCode` enum (defined at cigconfigs.h:142–148):

| Enumerator | Value |
|---|---|
| `MaintNormal` | `0x00` |
| `MaintIdle` | `0xea` |
| `MaintCriticalQuestion` | `0xfb` |
| `MaintRedImpact` | `0xfd` |
| `MaintSurveyTimeout` | `0xfe` |

**Implementation function line numbers (cpp):**

| Line | Function |
|---|---|
| 6 | `LockedDialog::LockedDialog(QWidget *parent)` |
| 16 | `LockedDialog::~LockedDialog()` |
| 21 | `void LockedDialog::startTimer()` |
| 30 | `void LockedDialog::stopTimer()` |
| 36 | `void LockedDialog::setLockedReason(CIGCONF::MaintLockedCode lockedCode)` |
| 61 | `void LockedDialog::languageChanged()` |
| 66 | `void LockedDialog::clearTimerText()` |
| 70 | `void LockedDialog::setTimeRemaining(quint32 secs)` |
| 77 | `void LockedDialog::fullLockStart()` |
| 84 | `void LockedDialog::updateFullLock()` |

---

### `ui/messagedialog.h` + `ui/messagedialog.cpp`

**Class:** `MessageDialog` (extends `QDialog`)

**Enum defined in class scope (h:18–27):**

`MessageType`:

| Enumerator | Implicit value |
|---|---|
| `NoMessage` | 0 |
| `ExpansionConnecting` | 1 |
| `WaitForAuthorised` | 2 |
| `NotAuthorised` | 3 |
| `OnDemandNotAuthorised` | 4 |
| `PowerOff` | 5 |
| `Reboot` | 6 |
| `VehicleOutOfService` | 7 |

**Public methods (header line numbers):**

| Location | Signature |
|---|---|
| h:29 | `explicit MessageDialog(QWidget *parent = 0)` — constructor |
| h:30 | `~MessageDialog()` — destructor |
| h:31 | `void openWithMessage(MessageType type)` — inline; calls `setMessageType(type); open()` |
| h:33 | `void setMessageType(MessageType type)` |
| h:34 | `MessageType messageType() const` — inline getter |

**Protected methods:**

| Location | Signature |
|---|---|
| h:37 | `void hideEvent(QHideEvent *)` |

**Private members:**

- `Ui::MessageDialog *ui` — h:40
- `QTimer *m_timer` — h:42
- `QMovie *m_movie` — h:43
- `MessageType m_messageType` — h:44

**Macro constants (cpp):**

| Name | Value | Location |
|---|---|---|
| `WAIT_AUTH_TIME` | `10000` | cpp:7 |
| `NOT_AUTH_TIME` | `5000` | cpp:8 |

**Implementation function line numbers (cpp):**

| Line | Function |
|---|---|
| 10 | `MessageDialog::MessageDialog(QWidget *parent)` |
| 30 | `MessageDialog::~MessageDialog()` |
| 35 | `void MessageDialog::hideEvent(QHideEvent *)` |
| 42 | `void MessageDialog::setMessageType(MessageType type)` |

---

### `ui/onScreenKeyboard.h` + `ui/onScreenKeyboard.cpp`

**Class:** `onScreenKeyboard` (extends `QWidget`) — note non-standard lower-camel class name

**Enums defined in class scope (h:17–19):**

`KeyToggleState`:

| Enumerator | Implicit value |
|---|---|
| `Normal` | 0 |
| `Upper` | 1 |
| `Lower` | 2 |

`CaseButton`:

| Enumerator | Implicit value |
|---|---|
| `AllButtons` | 0 |
| `CapsButton` | 1 |
| `ShiftButton` | 2 |
| `SymbolButton` | 3 |

`CtrlButton`:

| Enumerator | Implicit value |
|---|---|
| `None` | 0 |
| `Backspace` | 1 |
| `Delete` | 2 |

**Public members:**

- `QPushButton *enterButton` — h:22 (public raw pointer; never initialized in constructor; never referenced anywhere in the codebase)

**Public methods (header line numbers):**

| Location | Signature |
|---|---|
| h:20 | `explicit onScreenKeyboard(QWidget *parent = 0)` — constructor |
| h:21 | `~onScreenKeyboard()` — destructor |
| h:24 | `void setInitialText(QString str)` |
| h:25 | `void languageChanged(void)` |

**Private slots:**

| Location | Signature |
|---|---|
| h:28 | `void keyboardHandler()` |
| h:29 | `void on_btnShift_clicked(bool checked)` |
| h:30 | `void on_btnEnter_clicked()` |
| h:31 | `void on_btnBack_clicked()` |
| h:32 | `void on_btnCaps_toggled(bool checked)` |
| h:33 | `void on_btnHideKeyboard_clicked()` |
| h:34 | `void on_btnDelete_clicked()` |

**Signals:**

| Location | Signature |
|---|---|
| h:36 | `void updateText(QString str, CtrlButton ctrl)` |
| h:37 | `void onScreenKeyboardClose()` |

**Protected methods:**

| Location | Signature |
|---|---|
| h:40 | `void closeEvent(QCloseEvent *event)` |

**Private methods:**

| Location | Signature |
|---|---|
| h:43 | `void toggle()` |
| h:44 | `QString dualCharCase(QString ch, int toggleState)` |
| h:45 | `QString singleCharCase(QString ch, int toggleState)` |
| h:46 | `void setCaseButton(CaseButton btn, bool set)` |

**Private members:**

- `Ui::onScreenKeyboard *ui` — h:47
- `QString outputText` — h:48
- `QString m_capsStylesheet` — h:49
- `QString m_symbolStylesheet` — h:50
- `QString m_shiftStylesheet` — h:51

**Implementation function line numbers (cpp):**

| Line | Function |
|---|---|
| 5 | `onScreenKeyboard::onScreenKeyboard(QWidget *parent)` |
| 56 | `void onScreenKeyboard::setInitialText(QString str)` |
| 61 | `void onScreenKeyboard::keyboardHandler()` |
| 102 | `onScreenKeyboard::~onScreenKeyboard()` |
| 107 | `void onScreenKeyboard::closeEvent(QCloseEvent *event)` |
| 113 | `void onScreenKeyboard::on_btnShift_clicked(bool checked)` |
| 119 | `QString onScreenKeyboard::singleCharCase(QString ch, int toggleState)` |
| 127 | `QString onScreenKeyboard::dualCharCase(QString ch, int toggleState)` |
| 145 | `void onScreenKeyboard::toggle()` |
| 184 | `void onScreenKeyboard::on_btnEnter_clicked()` |
| 192 | `void onScreenKeyboard::on_btnBack_clicked()` |
| 197 | `void onScreenKeyboard::on_btnCaps_toggled(bool checked)` |
| 202 | `void onScreenKeyboard::on_btnHideKeyboard_clicked()` |
| 209 | `void onScreenKeyboard::setCaseButton(CaseButton btn, bool set)` |
| 243 | `void onScreenKeyboard::on_btnDelete_clicked()` |
| 248 | `void onScreenKeyboard::languageChanged()` |

---

## Findings

---

**A22-1** · HIGH · `onScreenKeyboard` class name violates Qt/C++ naming convention

**Description:** The class is named `onScreenKeyboard` with a lowercase leading letter, which violates the established Qt and C++ convention of PascalCase for class names (e.g., `OnScreenKeyboard`). This is not merely stylistic: the Qt `Q_OBJECT` macro, `moc` toolchain, and IDE tooling all assume PascalCase class names, and the inconsistency creates confusion throughout the codebase. The companion `Ui::onScreenKeyboard` namespace alias and the `.ui` file name also inherit the non-standard casing, making the inconsistency pervasive. Every other class in the codebase (`LockedDialog`, `MessageDialog`, `CommentDialog`, etc.) uses PascalCase.

**Fix:** Rename the class to `OnScreenKeyboard`, update the `.h`, `.cpp`, `.ui`, and all callers accordingly. This is a straightforward mechanical rename; no behavioral changes are required.

---

**A22-2** · HIGH · `enterButton` — uninitialized public raw pointer (undefined behavior on any dereference)

**Description:** `QPushButton *enterButton` is declared as a public data member of `onScreenKeyboard` (h:22) but is never assigned in the constructor or anywhere else in the class implementation. The UI form names the enter button `btnEnter`, accessed internally via `ui->btnEnter`. A grep across the entire source tree shows that no caller ever assigns or dereferences `enterButton`. The pointer therefore holds an indeterminate (garbage) value for the entire lifetime of any `onScreenKeyboard` instance. Any future caller who attempts to use `enterButton` (e.g., to connect a signal) will trigger undefined behavior resulting in a crash or silent data corruption.

**Fix:** Either (a) remove `enterButton` entirely if it is not needed, or (b) assign it in the constructor body: `enterButton = ui->btnEnter;` and document the intended use. If the purpose is to allow callers to connect to the enter button's signals, add a public accessor method `QPushButton* enterButtonWidget() const { return ui->btnEnter; }` and keep the member private.

---

**A22-3** · HIGH · Backslash key emits the text of `Buttonr` instead of a backslash character

**Description:** In `keyboardHandler()` (cpp:75–77), when the pressed button's text is `"\\"`, the handler sets:
```cpp
outputText = ui->Buttonr->text();
```
This emits whatever letter is currently displayed on the `r` key (either `"r"` or `"R"` depending on shift/caps state) instead of a backslash character `"\"`. This is a logic error: the backslash key will never produce a backslash in user input. The likely cause is an erroneous copy-paste from nearby code during development. The `"&&"` special case immediately above it (cpp:72–74) correctly sets `outputText = "&"`, demonstrating the intended pattern was `outputText = "\\"`.

**Fix:** Replace `outputText = ui->Buttonr->text();` with `outputText = "\\";` so that the backslash key emits a backslash character.

---

**A22-4** · MEDIUM · `dualCharCase()` is dead code — defined but never called

**Description:** `QString onScreenKeyboard::dualCharCase(QString ch, int toggleState)` is declared in the header (h:44) and fully implemented in the cpp (cpp:127–143). It contains 10 explicit branches handling the number-row dual-label keys (e.g., `"!\n0"`, `"@\n1"`, etc.). A search of the entire codebase shows it is never invoked. The `toggle()` function only calls `singleCharCase()` for alphabetic keys, and `keyboardHandler()` processes multi-character keys inline without using this helper. The function is therefore completely unreachable dead code.

**Fix:** Remove `dualCharCase()` from both the header and implementation. If the intent was to factor the multi-character key logic out of `keyboardHandler()`, refactor accordingly and connect the call sites.

---

**A22-5** · MEDIUM · `MaintLockedCode` uses arbitrary magic hex values with no documentation

**Description:** The `MaintLockedCode` enum (cigconfigs.h:142–148) assigns non-contiguous magic hexadecimal values to its enumerators (`MaintIdle = 0xea`, `MaintCriticalQuestion = 0xfb`, `MaintRedImpact = 0xfd`, `MaintSurveyTimeout = 0xfe`). These values are used as a `switch` discriminant in `LockedDialog::setLockedReason()` (cpp:38–58) and presumably as wire-protocol or storage codes elsewhere. There is no comment explaining the origin or significance of these values, making it impossible to verify correctness, add new codes safely, or catch encoding mismatches. `MaintNormal = 0x00` is also defined but never handled in the `switch` — it falls through to the `default` case.

**Fix:** Add a comment above the enum explaining the source and semantics of the assigned values (e.g., "values match the protocol byte defined in firmware spec section X"). If `MaintNormal` is a valid expected state, add an explicit `case CIGCONF::MaintNormal:` branch to `setLockedReason()`.

---

**A22-6** · MEDIUM · `SymbolButton` enumerator declared but never used

**Description:** The `CaseButton` enum in `onScreenKeyboard` (h:18) declares four values: `AllButtons`, `CapsButton`, `ShiftButton`, and `SymbolButton`. The `setCaseButton()` implementation (cpp:209–241) handles `CapsButton` and `ShiftButton` explicitly, and `AllButtons` via the `default` branch. `SymbolButton` has no corresponding `case` in the `switch` and is never passed to `setCaseButton()` anywhere in the codebase — it is an entirely dead enumerator that suggests an unimplemented feature was planned but never completed.

**Fix:** Either implement the `SymbolButton` case in `setCaseButton()` and wire up the UI symbol-toggle button, or remove the `SymbolButton` enumerator and any corresponding unused UI elements.

---

**A22-7** · MEDIUM · `PowerOff` movie file path missing `.gif` extension

**Description:** In `MessageDialog::setMessageType()` (cpp:113), the `PowerOff` case sets:
```cpp
m_movie->setFileName(":/image/icons/movie/wait-power-off");
```
Every other case that uses a `QMovie` appends `.gif` to the resource path (e.g., `":/image/icons/movie/wait-ble.gif"`, `":/image/icons/movie/wait-until-restart.gif"`). The missing extension means `QMovie` will fail to load the resource because Qt's resource system uses the exact path as specified, and the file registered in the `.qrc` almost certainly ends in `.gif`. The `PowerOff` dialog will silently display no animation.

**Fix:** Change the path to `":/image/icons/movie/wait-power-off.gif"` (verify the actual resource file name in the `.qrc` manifest and align accordingly).

---

**A22-8** · LOW · Non-standard class naming propagates into `Ui` namespace and `.ui` file

**Description:** Because the class is named `onScreenKeyboard` rather than `OnScreenKeyboard`, the Qt Designer-generated `Ui::onScreenKeyboard` namespace and the `ui_onScreenKeyboard.h` generated file inherit the non-standard casing. This makes it harder for static analysis tools and IDEs to distinguish class names from variable names, and violates the expectation that `Ui::` namespace members match PascalCase class names. (Related to A22-1 but separately observable as a build-artefact quality issue.)

**Fix:** Address as part of the A22-1 rename.

---

**A22-9** · LOW · `LockedDialog` internal timer `m_fullLockTimer` and counter `m_timeCntr` have no encapsulation boundary against misuse via `startTimer()`/`stopTimer()` public API

**Description:** `startTimer()` and `stopTimer()` are public methods (h:24–25) that directly manipulate `m_fullLockTimer`. There is no guard preventing a caller from calling `startTimer()` multiple times, which the implementation partially handles with `!m_fullLockTimer->isActive()` (cpp:26), but `stopTimer()` calls `clearTimerText()` as a side effect (cpp:32–33) which alters UI state. Callers have no way to query whether the timer is active without checking timer internals indirectly. The timer is an implementation detail that leaks into the public API.

**Fix:** Document the preconditions and side effects of `startTimer()` and `stopTimer()` in the header, or refactor the timer management into a single `setTimerActive(bool)` method with clear semantics and no hidden UI side effects.

---

**A22-10** · LOW · `updateFullLock()` post-decrement on `quint32` produces unsigned underflow on final tick

**Description:** The shutdown logic in `updateFullLock()` (cpp:87) uses:
```cpp
if (!m_timeCntr--)
```
This post-decrements `m_timeCntr` after the zero-check. When `m_timeCntr` reaches zero, the condition fires and `stopTimer()` is called — correct. However, because `quint32` is unsigned, the post-decrement on the iteration where `m_timeCntr == 0` wraps `m_timeCntr` to `0xFFFFFFFF` before `stopTimer()` is reached. If `stopTimer()` were ever not called (e.g., due to a future code change), the counter would wrap to a very large value. The comment on cpp:86 ("This will immediately close both relays if Timeout Parameter is zero") also describes a separate edge case: if `fullLockoutTimeout()` returns 0, the first tick immediately fires `fullLockoutTimerEnded`, which is the intended behavior, but the comment does not explain the wrap risk.

**Fix:** Use an explicit comparison: `if (m_timeCntr == 0) { ... } else { m_timeCntr--; setTimeRemaining(m_timeCntr); }` to avoid unsigned wrap and make the zero-timeout edge case explicit.

---

**A22-11** · LOW · `WAIT_AUTH_TIME` and `NOT_AUTH_TIME` are file-scope `#define` macros rather than typed constants

**Description:** `messagedialog.cpp` (cpp:7–8) defines:
```cpp
#define WAIT_AUTH_TIME  10000
#define NOT_AUTH_TIME   5000
```
These are untyped preprocessor macros with no scope, no type safety, and no visibility from the header. They are integer literals (milliseconds) with no documenting comment. Any future inclusion of this translation unit's internal constants in a unit test or via copy-paste will silently use the wrong type (e.g., 32-bit int rather than the `int` expected by `QTimer::start()`).

**Fix:** Replace with `static constexpr int kWaitAuthTimeMs = 10000;` and `static constexpr int kNotAuthTimeMs = 5000;` as private static members of `MessageDialog`, or at minimum as `constexpr` file-scope variables with a `// ms` comment.

---

**A22-12** · LOW · `keyboardHandler()` uses a C-style cast instead of `qobject_cast`

**Description:** `keyboardHandler()` (cpp:63) casts `sender()` using a C-style cast:
```cpp
QPushButton *button = (QPushButton *)sender();
```
All buttons connected to this slot are `QPushButton` instances, so the cast is safe in practice. However, C-style casts bypass Qt's object model and will silently return a corrupt pointer if the slot is ever accidentally connected to a non-`QPushButton` signal source. The Qt-correct pattern is `qobject_cast<QPushButton *>(sender())` which returns `nullptr` on type mismatch and allows a null check.

**Fix:** Replace with:
```cpp
QPushButton *button = qobject_cast<QPushButton *>(sender());
if (!button) return;
```

---

**A22-13** · INFO · `m_symbolStylesheet` member is declared but never read or written in a meaningful way

**Description:** `m_symbolStylesheet` (h:50) is declared as a private `QString` member of `onScreenKeyboard`. It is never assigned and never read anywhere in the implementation. The `SymbolButton` case of `setCaseButton()` is also absent (see A22-6), confirming this field was part of an unimplemented symbol-mode feature. The field adds dead state to every instance.

**Fix:** Remove `m_symbolStylesheet` along with `SymbolButton` as part of the A22-6 cleanup, or implement the symbol mode fully.

---

**A22-14** · INFO · `onScreenKeyboard` constructor has a blank line inside the initializer block (cpp:21–22)

**Description:** Lines 21–22 of `onScreenKeyboard.cpp` contain a blank line in the middle of the `connect()` call sequence inside the constructor body. While harmless, it inconsistently separates the `p` key connection from the rest of the top row (lines 11–20), which may mislead a reader into thinking the blank line has significance. The rest of the constructor groups rows with single blank lines between rows, which is the correct intent.

**Fix:** Remove the extra blank line between the `Buttonp` connection (line 20) and the start of the home-row connections (line 23), or keep one blank line consistently between keyboard rows.

---

## Summary Table

| ID | Severity | Title |
|---|---|---|
| A22-1 | HIGH | `onScreenKeyboard` class name violates Qt/C++ PascalCase convention |
| A22-2 | HIGH | `enterButton` — uninitialized public raw pointer (UB on any dereference) |
| A22-3 | HIGH | Backslash key emits `Buttonr` text instead of `"\\"` — logic error |
| A22-4 | MEDIUM | `dualCharCase()` defined but never called — dead code |
| A22-5 | MEDIUM | `MaintLockedCode` uses undocumented magic hex values |
| A22-6 | MEDIUM | `SymbolButton` enumerator declared but never implemented or used |
| A22-7 | MEDIUM | `PowerOff` movie resource path missing `.gif` extension |
| A22-8 | LOW | Non-standard class casing propagates into `Ui` namespace and generated files |
| A22-9 | LOW | Public `startTimer()`/`stopTimer()` API leaks timer implementation details |
| A22-10 | LOW | `quint32` post-decrement in `updateFullLock()` wraps to `0xFFFFFFFF` on zero tick |
| A22-11 | LOW | `WAIT_AUTH_TIME` / `NOT_AUTH_TIME` are untyped `#define` macros |
| A22-12 | LOW | C-style cast in `keyboardHandler()` should be `qobject_cast` |
| A22-13 | INFO | `m_symbolStylesheet` member is dead state — never assigned or read |
| A22-14 | INFO | Spurious blank line in `onScreenKeyboard` constructor body |

**Totals:** 3 HIGH, 4 MEDIUM, 5 LOW, 2 INFO
# Pass 4 Agent A23 — Code Quality

**Audit run:** 2026-02-28-01
**Branch:** master
**Repo root:** C:/Projects/cig-audit/repos/mark3-pvd
**Assigned files:**
- `ui/ondemanddialog.h` + `ui/ondemanddialog.cpp`
- `ui/optionalcheckconfirmationdialog.h` + `ui/optionalcheckconfirmationdialog.cpp`
- `ui/pindialog.h` + `ui/pindialog.cpp`

---

## Reading Evidence

### `ui/ondemanddialog.h`

**Class:** `OnDemandDialog` (extends `QDialog`)

**Methods / line numbers:**

| Line | Signature | Notes |
|------|-----------|-------|
| 20 | `explicit OnDemandDialog(QWidget *parent = 0)` | Constructor |
| 21 | `~OnDemandDialog()` | Destructor |
| 23 | `void setSuperMasterId(quint64 id)` | Inline setter |
| 24 | `void reset()` | Public reset |
| 25 | `void setTimeRemaining(quint32 secs)` | Public updater |
| 26 | `QString showCustomTimeFormat(quint32 time)` | Public utility |
| 29 | `void onDemandStarted(quint32, quint32, quint64, CIGCONF::OnDemandCmdSrc)` | Signal |
| 30 | `void onDemandExtended(quint32, quint32, quint64, CIGCONF::OnDemandCmdSrc)` | Signal |
| 31 | `void onDemandEnded(quint32, quint64, CIGCONF::OnDemandCmdSrc)` | Signal |
| 34 | `void showEvent(QShowEvent *event = 0)` | Protected override |
| 36 | `void onStart()` | Protected slot |
| 37 | `void onExtend()` | Protected slot |
| 38 | `void onEnd()` | Protected slot |
| 41 | `bool debounce()` | Private helper |

**Members:**

| Line | Name | Type |
|------|------|------|
| 42 | `ui` | `Ui::OnDemandDialog *` |
| 44 | `m_timer` | `QTimer *` |
| 45 | `m_lastPress` | `quint32` |
| 46 | `m_smId` | `quint64` |

**Types / constants defined:** None directly; uses `CIGCONF::OnDemandCmdSrc` from `app/cigconfigs.h`.

---

### `ui/ondemanddialog.cpp`

**Methods / line numbers:**

| Line | Signature |
|------|-----------|
| 9 | `OnDemandDialog::OnDemandDialog(QWidget *parent)` |
| 26 | `OnDemandDialog::~OnDemandDialog()` |
| 31 | `void OnDemandDialog::showEvent(QShowEvent *event)` |
| 57 | `void OnDemandDialog::onStart()` |
| 74 | `void OnDemandDialog::onExtend()` |
| 91 | `void OnDemandDialog::onEnd()` |
| 106 | `bool OnDemandDialog::debounce()` |
| 117 | `void OnDemandDialog::reset()` |
| 123 | `QString OnDemandDialog::showCustomTimeFormat(quint32 time)` |
| 131 | `void OnDemandDialog::setTimeRemaining(quint32 secs)` |

**Constants defined:**

| Line | Name | Value |
|------|------|-------|
| 7 | `NO_ACTIVITY_TIME` | `10000` (ms) |

---

### `ui/optionalcheckconfirmationdialog.h`

**Class:** `OptionalCheckConfirmationDialog` (extends `QDialog`)

**Methods / line numbers:**

| Line | Signature | Notes |
|------|-----------|-------|
| 15 | `explicit OptionalCheckConfirmationDialog(QWidget *parent = 0)` | Constructor |
| 16 | `~OptionalCheckConfirmationDialog()` | Destructor |
| 17 | `void onRefreshLanguage(void)` | Public language refresh |
| 24 | `void hideEvent(QHideEvent *)` | Protected override |
| 25 | `void showEvent(QShowEvent *event = 0)` | Protected override |

**Members:**

| Line | Name | Type |
|------|------|------|
| 20 | `ui` | `Ui::OptionalCheckConfirmationDialog *` |
| 21 | `m_timer` | `QTimer *` |

**Types / constants defined:** None.

---

### `ui/optionalcheckconfirmationdialog.cpp`

**Methods / line numbers:**

| Line | Signature |
|------|-----------|
| 6 | `OptionalCheckConfirmationDialog::OptionalCheckConfirmationDialog(QWidget *parent)` |
| 19 | `void OptionalCheckConfirmationDialog::showEvent(QShowEvent *event)` |
| 31 | `void OptionalCheckConfirmationDialog::hideEvent(QHideEvent *)` |
| 36 | `OptionalCheckConfirmationDialog::~OptionalCheckConfirmationDialog()` |
| 41 | `void OptionalCheckConfirmationDialog::onRefreshLanguage(void)` |

**Constants / magic numbers:**

| Line | Value | Meaning |
|------|-------|---------|
| 28 | `5000` | Dialog auto-dismiss timeout (ms), bare literal in `m_timer->start(5000)` |

---

### `ui/pindialog.h`

**Class:** `PinDialog` (extends `QDialog`)

**Methods / line numbers:**

| Line | Signature | Notes |
|------|-----------|-------|
| 17 | `explicit PinDialog(QWidget *parent = 0)` | Constructor |
| 18 | `~PinDialog()` | Destructor |
| 20 | `quint32 pinCode() const` | Public — returns raw PIN digits as integer |
| 21 | `void clearPinCode()` | Public |
| 22 | `void languageChanged()` | Public |
| 25 | `void showEvent(QShowEvent *)` | Protected override |
| 26 | `void hideEvent(QHideEvent *)` | Protected override |
| 29 | `void keyPressed()` | Private slot |

**Members:**

| Line | Name | Type |
|------|------|------|
| 31 | `ui` | `Ui::PinDialog *` |
| 32 | `m_timer` | `QTimer *` |

**Types / constants defined:** None in header.

---

### `ui/pindialog.cpp`

**Methods / line numbers:**

| Line | Signature |
|------|-----------|
| 12 | `PinDialog::PinDialog(QWidget *parent)` |
| 42 | `PinDialog::~PinDialog()` |
| 47 | `void PinDialog::keyPressed()` |
| 87 | `void PinDialog::hideEvent(QHideEvent *)` |
| 92 | `void PinDialog::showEvent(QShowEvent *)` |
| 97 | `quint32 PinDialog::pinCode() const` |
| 112 | `void PinDialog::clearPinCode()` |
| 118 | `void PinDialog::languageChanged()` |

**Constants defined:**

| Line | Name | Value |
|------|------|-------|
| 9 | `PIN_MAX_LENGTH` | `5` |
| 10 | `ACTIVITY_TIME` | `30000` (ms) |

---

## Findings

---

**A23-1** · MEDIUM · `onEnd()` updates `m_lastPress` redundantly after `debounce()` already did so

**Description:** In `ondemanddialog.cpp`, the `debounce()` helper (line 106–115) already assigns `m_lastPress = now` before returning `true`. However, `onEnd()` (line 103) then assigns `m_lastPress = gCfg->clockTime()` a second time unconditionally, after the timer restart. This redundant write is absent in `onStart()` (line 57–72) and `onExtend()` (line 74–89), making the three handlers inconsistent. The double-write is harmless in isolation but indicates a copy-paste omission during `onEnd()` authoring and could confuse future maintainers about the debounce contract.

**Fix:** Remove the redundant `m_lastPress = gCfg->clockTime();` assignment at `ondemanddialog.cpp:103`. The debounce pattern for all three action handlers should be identical: call `debounce()`, act on button state, restart `m_timer`.

---

**A23-2** · MEDIUM · `onStart()` and `onExtend()` omit the post-action `m_lastPress` update, while `onEnd()` has it — asymmetric debounce state

**Description:** As a direct consequence of A23-1, `onStart()` and `onExtend()` do not explicitly refresh `m_lastPress` after completing their action, whereas `onEnd()` does. Because `debounce()` already updates `m_lastPress`, the behaviour is identical in practice for all three handlers. The asymmetry creates a false implication that `onEnd()` requires special cooldown handling that `onStart()`/`onExtend()` do not, which is misleading to anyone reading the code.

**Fix:** Adopt a single, consistent style: either rely entirely on `debounce()` to maintain `m_lastPress` (recommended — remove the stray line in `onEnd()`) or have all three handlers refresh it explicitly after the action block. The former matches the pattern used by `AuthorisedDialog`, `SupervisorDialog`, and `CommentDialog` in the same codebase.

---

**A23-3** · MEDIUM · `reset()` calls `showEvent()` directly, bypassing the Qt event system

**Description:** `ondemanddialog.cpp:120` calls `showEvent()` directly as a regular C++ function call rather than allowing Qt to emit the event naturally. `showEvent()` is documented in Qt as a virtual event handler that Qt dispatches; calling it directly couples `reset()` to the current implementation of `showEvent()` and will silently bypass any base-class behaviour in `QDialog::showEvent()`. While the immediate `showEvent()` body does not call `QDialog::showEvent(event)` itself (and so passes `nullptr`/`0` for the default-argument `event = 0`), the pattern is fragile: if `showEvent()` is ever updated to call `event->accept()` or similar, the null pointer will cause undefined behaviour.

**Fix:** Replace the direct call with the intended side-effects: extract the state-reset logic in `showEvent()` into a private `refreshUi()` helper and call that helper from both `showEvent()` and `reset()`. This is the pattern used elsewhere (e.g., `languageChanged()` / `onRefreshLanguage()`).

---

**A23-4** · MEDIUM · `onStart()` and `onExtend()` action handlers are `protected`, not `private`

**Description:** `ondemanddialog.h` (lines 36–38) declares `onStart()`, `onExtend()`, and `onEnd()` in the `protected` section. These three methods are pure internal slot handlers connected to button clicks in the constructor; they are not intended to be overridden or called by subclasses. Across the rest of the UI layer, comparable button-click slots (`rstLogout`, `onLogoutRequest` in `AuthorisedDialog`; language selection slots in `LanguageDialog`; confirm-action slots in `SupervisorDialog`) are uniformly placed in `private` or `private slots`. Declaring them `protected` widens the interface unnecessarily and exposes authentication-sensitive actions (start/extend/end an on-demand session) to subclass override.

**Fix:** Move `onStart()`, `onExtend()`, and `onEnd()` into the `private` section (or a `private slots:` subsection) of `OnDemandDialog`. No callers outside the class exist.

---

**A23-5** · MEDIUM · `PIN_MAX_LENGTH` defined in `.cpp` is not used; actual limit comes from the UI designer's `maxLength` property

**Description:** `pindialog.cpp:9` defines `#define PIN_MAX_LENGTH 5`, but `keyPressed()` (line 64) reads the PIN length limit from `ui->lineEdit->maxLength()` — a value set in the Qt Designer `.ui` file — and stores it in a local variable `maxLength`. The `PIN_MAX_LENGTH` macro is never referenced anywhere in `pindialog.cpp` or anywhere else in the codebase. This means the true maximum PIN length is controlled by a property embedded in a binary `.ui` resource, invisible in code review and not enforced by the named constant. If a developer changes `PIN_MAX_LENGTH` expecting the dialog to enforce a different length, nothing changes at runtime.

**Fix:** Either (a) remove `#define PIN_MAX_LENGTH 5` entirely and document in a comment that `ui->lineEdit->maxLength()` is the authoritative source set in the `.ui` designer file, or (b) enforce `PIN_MAX_LENGTH` at runtime by calling `ui->lineEdit->setMaxLength(PIN_MAX_LENGTH)` in the constructor and removing the reliance on the designer property for this security-relevant limit. Option (b) is strongly preferred because it makes the PIN length constraint visible and auditable in code.

---

**A23-6** · LOW · `static` local variable used for debounce in `PinDialog::keyPressed()` instead of a member variable

**Description:** `pindialog.cpp:51` uses `static quint64 last = 0;` for debouncing key presses. Using function-level `static` variables means the debounce state is shared across all instances of `PinDialog` (if more than one were ever created) and is never reset when a `PinDialog` instance is destroyed and recreated. Every other dialog in the codebase that implements debouncing (`OnDemandDialog`, `AuthorisedDialog`, `SupervisorDialog`, `CommentDialog`, `LanguageDialog`) uses an instance-level member variable `m_lastPress`. The inconsistency also means the debounce state persists across separate invocations of the same `PinDialog` instance, potentially causing the very first key press of a new session to be silently dropped if the dialog is shown shortly after the previous dismissal.

**Fix:** Replace the `static` local with a member variable `quint64 m_lastPress` (consistent with the rest of the codebase), initialise it to `0` in the constructor, and reset it in `clearPinCode()` or `showEvent()`. Change the type from `quint64` to `quint32` for consistency with `m_lastPress` elsewhere, or confirm that `clockTime()` returns a value requiring 64-bit range.

---

**A23-7** · LOW · `showCustomTimeFormat()` is public but is only a display-formatting helper

**Description:** `ondemanddialog.h:26` declares `showCustomTimeFormat(quint32 time)` as `public`. The method is a pure formatting utility that converts a second-count to `HH:MM:SS` string. It is only called from within `OnDemandDialog::setTimeRemaining()` (cpp:136) and from `Dialog::showCustomTimeFormat()` (a separately defined duplicate in `dialog.cpp:1249`). Making it `public` unnecessarily enlarges the class API surface and duplicates a utility that already exists in `Dialog`. The name itself is also misleading: the verb "show" implies a side-effecting display operation, whereas the method is a pure computation returning a `QString`.

**Fix:** Change the visibility to `private` (it has no external callers on `OnDemandDialog` objects). Rename to `formatDuration()` or `secondsToTimeString()` to accurately reflect its pure-function nature. Consider whether the duplicate in `Dialog` should be unified into a shared static helper.

---

**A23-8** · LOW · `onRefreshLanguage()` in `OptionalCheckConfirmationDialog` duplicates `showEvent()` body verbatim

**Description:** `optionalcheckconfirmationdialog.cpp:41–48` (`onRefreshLanguage()`) is a character-for-character copy of the UI text-setting block in `showEvent()` (lines 22–28). Any future change to the dialog's display strings must be made in two places. The `showEvent()` body does not call `onRefreshLanguage()`, so the two copies can drift. This is a classic DRY violation. The corresponding pattern in other dialogs (e.g., `LockedDialog::languageChanged()`, `PinDialog::languageChanged()`) correctly calls into a single update method.

**Fix:** In `showEvent()`, replace the text-setting block with a call to `onRefreshLanguage()`, leaving only `m_timer->start(5000)` as the additional line in `showEvent()`. This ensures a single source of truth for the display strings.

---

**A23-9** · LOW · Magic number `5000` in `OptionalCheckConfirmationDialog::showEvent()`

**Description:** `optionalcheckconfirmationdialog.cpp:28` calls `m_timer->start(5000)` with an unexplained bare integer. The inline comment (`// wait 5 second before closing the dialog`) partially explains the intent, but the value is not given a named constant. Every other dialog in the same directory that uses a similar auto-dismiss timer defines a named macro (`NO_ACTIVITY_TIME`, `ACTIVITY_TIME`, `RESET_TIMEOUT`, `WAIT_AUTH_TIME`). The magic number is inconsistent with established style and makes future adjustment of the timeout harder to locate.

**Fix:** Add `#define ACTIVITY_TIME 5000` (or an appropriately named constant) at the top of the `.cpp` file and replace the literal with the constant, consistent with the style of `ondemanddialog.cpp`, `pindialog.cpp`, and `supervisordialog.cpp`.

---

**A23-10** · LOW · Unused `#include <QDebug>` in `optionalcheckconfirmationdialog.cpp`

**Description:** `optionalcheckconfirmationdialog.cpp:4` includes `<QDebug>`, but no `qDebug()` call or `QDebug` usage appears anywhere in the file. This is a leftover from a development or debugging session. Unnecessary includes slow incremental builds and signal to auditors and maintainers that debug instrumentation may have been removed without cleanup.

**Fix:** Remove `#include <QDebug>` from `optionalcheckconfirmationdialog.cpp`.

---

**A23-11** · LOW · Unused `#include <QThread>` in `pindialog.cpp`

**Description:** `pindialog.cpp:6` includes `<QThread>`, but no `QThread` symbol is used anywhere in the file. Like the `QDebug` issue above, this is dead include residue, likely left over from an earlier implementation attempt. The comment at line 49–51 mentions an application-wide event filter was considered ("Tried application wide event filter") — the `QThread` include may be a remnant of that approach.

**Fix:** Remove `#include <QThread>` from `pindialog.cpp`.

---

**A23-12** · LOW · Unused `#include <QDebug>` in `pindialog.cpp`

**Description:** `pindialog.cpp:4` includes `<QDebug>`, but no `qDebug()` or `QDebug` reference exists anywhere in the file.

**Fix:** Remove `#include <QDebug>` from `pindialog.cpp`.

---

**A23-13** · LOW · `showCustomTimeFormat()` uses signed `qint32` for hour/minute/second decomposition of `quint32` input

**Description:** `ondemanddialog.cpp:124–126` declares `h`, `m`, and `s` as `qint32` while computing from a `quint32` input. For very large values of `time` (near `UINT32_MAX`, approximately 4.29 billion seconds / ~136 years), the division `time/3600` yields a value of up to ~1,193,046 — well within `qint32` range — so no actual overflow occurs in practice. However, the intermediate computation `time - (3600*h)` on line 125 passes a `qint32` value (`h`) back into arithmetic with `quint32` (`time`), which involves an implicit signed/unsigned conversion. Additionally, `3600*h` with a `qint32` `h` is evaluated as signed multiplication where `3600 * 1193046` = ~4.295 billion, which overflows `qint32` (max ~2.147 billion). This causes undefined behaviour for the intermediate expression when `time` is near `UINT32_MAX`. While such values are operationally implausible for a remaining-session timer, the type mismatch is a latent code quality defect.

**Fix:** Declare `h`, `m`, and `s` as `quint32` to match the input type and eliminate implicit signed/unsigned conversion warnings:
```cpp
quint32 h = time / 3600;
quint32 m = (time - (3600 * h)) / 60;
quint32 s = time - (3600 * h) - (m * 60);
```

---

**A23-14** · INFO · `QApplication::processEvents()` call in `PinDialog::keyPressed()` is a code smell

**Description:** `pindialog.cpp:82` calls `QApplication::processEvents()` before `accept()` when the PIN reaches maximum length. The comment (lines 75–78) explains that this is needed to repaint the asterisk mask label before the dialog closes. Calling `processEvents()` from within a slot is generally considered a code smell in Qt: it can cause re-entrant event delivery, unexpected signal emission, and unpredictable widget state during the interim event processing. The correct Qt idiom is to use a zero-delay `QTimer::singleShot(0, this, &PinDialog::accept)` instead, which defers `accept()` to the next event loop iteration after the current event processing completes, ensuring the repaint happens naturally.

**Fix:** Replace:
```cpp
QApplication::processEvents();
accept();
```
with:
```cpp
QTimer::singleShot(0, this, &PinDialog::accept);
```
This allows Qt to process the pending repaint event before triggering the dialog close, without the risks of synchronous re-entrant event dispatch.

---

**A23-15** · INFO · `showEvent(QShowEvent *event = 0)` default-argument pattern inconsistent with newer Qt style

**Description:** `ondemanddialog.h:34` and `optionalcheckconfirmationdialog.h:25` declare `showEvent` with a default argument `= 0`. This is an older Qt4-era style. Other dialogs in the same directory (`pindialog.h:25`, `authoriseddialog.h:33`) correctly declare `showEvent(QShowEvent *)` without a default argument, matching the base class signature. The default-argument form is not wrong — Qt will dispatch the event correctly — but it is inconsistent and can mislead readers into thinking the function can legitimately be called with no argument (which is what `reset()` in `ondemanddialog.cpp:120` exploits, passing a null pointer to `event`). This connects back to A23-3.

**Fix:** Remove the `= 0` default argument from all `showEvent` and `hideEvent` declarations in the assigned files to match the Qt base-class signature and codebase majority style.

---

## Summary Table

| ID | Severity | File | Line(s) | Title |
|----|----------|------|---------|-------|
| A23-1 | MEDIUM | `ondemanddialog.cpp` | 103 | Redundant `m_lastPress` update in `onEnd()` after `debounce()` already wrote it |
| A23-2 | MEDIUM | `ondemanddialog.cpp` | 57–104 | Asymmetric debounce state: `onEnd()` extra update absent in `onStart()`/`onExtend()` |
| A23-3 | MEDIUM | `ondemanddialog.cpp` | 120 | `reset()` calls `showEvent()` directly, passing implicit null event pointer |
| A23-4 | MEDIUM | `ondemanddialog.h` | 36–38 | Action handlers `onStart/onExtend/onEnd` declared `protected` instead of `private` |
| A23-5 | MEDIUM | `pindialog.cpp` | 9, 64 | `PIN_MAX_LENGTH` defined but never used; actual limit is the UI designer property |
| A23-6 | LOW | `pindialog.cpp` | 51 | `static` local for debounce instead of instance member — inconsistent with all other dialogs |
| A23-7 | LOW | `ondemanddialog.h` | 26 | `showCustomTimeFormat()` is `public` but is a private formatting utility |
| A23-8 | LOW | `optionalcheckconfirmationdialog.cpp` | 22–28, 43–48 | `onRefreshLanguage()` duplicates `showEvent()` body verbatim — DRY violation |
| A23-9 | LOW | `optionalcheckconfirmationdialog.cpp` | 28 | Magic number `5000` instead of named constant for auto-dismiss timeout |
| A23-10 | LOW | `optionalcheckconfirmationdialog.cpp` | 4 | Unused `#include <QDebug>` |
| A23-11 | LOW | `pindialog.cpp` | 6 | Unused `#include <QThread>` |
| A23-12 | LOW | `pindialog.cpp` | 4 | Unused `#include <QDebug>` |
| A23-13 | LOW | `ondemanddialog.cpp` | 124–126 | Signed `qint32` used for `quint32` decomposition; potential UB for extreme inputs |
| A23-14 | INFO | `pindialog.cpp` | 82–83 | `QApplication::processEvents()` in slot is a re-entrancy code smell |
| A23-15 | INFO | `ondemanddialog.h`, `optionalcheckconfirmationdialog.h` | 34, 25 | `showEvent(QShowEvent *event = 0)` default-argument inconsistent with Qt style and base class |
# Pass 4 Agent A24 — Code Quality

**Audit run:** 2026-02-28-01
**Branch:** master
**Assigned files:**
- `ui/preopscreenoverlay.h` + `ui/preopscreenoverlay.cpp`
- `ui/supervisordialog.h` + `ui/supervisordialog.cpp`
- `ui/unlockeddialog.h` + `ui/unlockeddialog.cpp`

---

## Reading Evidence

### `ui/preopscreenoverlay.h`

**Class:** `PreopScreenOverlay` (extends `QDialog`)

| Method / Member | Line | Notes |
|---|---|---|
| `explicit PreopScreenOverlay(QWidget *parent = 0)` | 15 | Constructor |
| `~PreopScreenOverlay()` | 16 | Destructor |
| `void onUpdatePreopTimer(QString time)` | 18 | Public slot-like updater |
| `Ui::PreopScreenOverlay *ui` | 21 | Private UI pointer |

**Types/Enums/Constants defined:** None.

---

### `ui/preopscreenoverlay.cpp`

| Method | Line | Notes |
|---|---|---|
| `PreopScreenOverlay::PreopScreenOverlay(QWidget *parent)` | 4 | Constructor — calls `setupUi` |
| `PreopScreenOverlay::onUpdatePreopTimer(QString time)` | 11 | Sets label text with `tr("Time Remaining")` |
| `PreopScreenOverlay::~PreopScreenOverlay()` | 16 | Destructor — deletes `ui` |

**Types/Enums/Constants defined:** None.

---

### `ui/supervisordialog.h`

**Class:** `SupervisorDialog` (extends `QDialog`)

| Member / Method | Line | Notes |
|---|---|---|
| `explicit SupervisorDialog(QWidget *parent = nullptr)` | 20 | Constructor |
| `~SupervisorDialog()` | 21 | Destructor |
| `void setMasterOptions(CIGCONF::MasterId m)` | 23 | Takes `MasterId` struct by value |
| `void setTransportOptions()` | 24 | Configures transport-mode button visibility |
| `void startMasterSession()` (signal) | 31 | Emitted to trigger master login |
| `void startMaintenanceSession()` (signal) | 32 | Emitted to trigger maintenance login |
| `void onVORUpdate()` (signal) | 33 | Signal with `on` prefix (non-standard) |
| `bool debounce()` | 37 | Private — debounce guard |
| `void reset()` | 38 | Private — resets button text and timer |
| `void showEvent(QShowEvent *event = 0)` | 49 | Protected virtual override with default arg |
| `void onUnlkVehicle()` | 52 | Private slot |
| `void onNormalDriverAccess()` | 53 | Private slot |
| `void onActivateVOR()` | 54 | Private slot |
| `void openConfirmationDialog()` | 55 | Private slot |
| `void on_btnMaintenanceMode_clicked()` | 56 | Auto-connected private slot |

**Private data members:**
- `Ui::SupervisorDialog *ui` (line 36)
- `QTimer *m_timer` (line 40)
- `QTimer *m_resetTimer` (line 41)
- `quint32 m_lastPress` (line 42)
- `CIGCONF::MasterId m_master` (line 43)
- `VORConfirmationDialog *m_vorConfirmationDialog` (line 44)
- `WarningDialog *m_maintWarningDialog` (line 45)
- `WarningDialog *m_warningDialog` (line 46)

**Macro constants defined (in .cpp):**
- `NO_ACTIVITY_TIME` = 10000 (line 7)
- `RESET_TIME` = 2000 (line 8)

---

### `ui/supervisordialog.cpp`

| Method | Line | Notes |
|---|---|---|
| `SupervisorDialog::SupervisorDialog(QWidget *parent)` | 10 | Constructor — wires all connects |
| `SupervisorDialog::~SupervisorDialog()` | 47 | Destructor |
| `SupervisorDialog::showEvent(QShowEvent *event)` | 52 | Populates UI text and starts inactivity timer |
| `SupervisorDialog::onUnlkVehicle()` | 88 | Two-tap confirm; emits `startMasterSession` |
| `SupervisorDialog::onNormalDriverAccess()` | 106 | Two-tap confirm; opens warning dialog AND emits `startMasterSession` directly |
| `SupervisorDialog::openConfirmationDialog()` | 126 | Two-tap confirm; opens VOR confirmation dialog |
| `SupervisorDialog::onActivateVOR()` | 144 | Toggles VOR state |
| `SupervisorDialog::debounce()` | 155 | Returns false if < 200 ms since last press |
| `SupervisorDialog::reset()` | 166 | Resets `m_lastPress` and calls `showEvent` |
| `SupervisorDialog::setMasterOptions(CIGCONF::MasterId m)` | 172 | Logs options and sets button visibility via bitmask |
| `SupervisorDialog::setTransportOptions()` | 202 | Hard-codes transport button visibility |
| `SupervisorDialog::on_btnMaintenanceMode_clicked()` | 211 | Two-tap confirm; opens maintenance warning dialog |

---

### `ui/unlockeddialog.h`

**Class:** `UnlockedDialog` (extends `QDialog`)

| Member / Method | Line | Notes |
|---|---|---|
| `enum Mode { UnlockNoChecklist, UnlockChecklist, UnlockOnly }` | 15 | Public enum |
| `explicit UnlockedDialog(QWidget *parent = 0)` | 17 | Constructor |
| `~UnlockedDialog()` | 18 | Destructor |
| `void setMode(Mode m)` | 20 | Configures label visibility per mode |
| `void languageChanged()` | 21 | Refreshes translated strings |
| `Ui::UnlockedDialog *ui` | 28 | Private UI pointer |

**Types/Enums/Constants defined:**
- `enum Mode { UnlockNoChecklist, UnlockChecklist, UnlockOnly }` (line 15)

---

### `ui/unlockeddialog.cpp`

| Method | Line | Notes |
|---|---|---|
| `UnlockedDialog::UnlockedDialog(QWidget *parent)` | 5 | Constructor — sets icon, connects btnOk |
| `UnlockedDialog::~UnlockedDialog()` | 18 | Destructor |
| `UnlockedDialog::setMode(Mode m)` | 23 | Switches on `Mode` enum |
| `UnlockedDialog::languageChanged()` | 42 | Sets `label_3` text to `tr("OK")` |

---

## Findings

---

**A24-1** · HIGH · `startMasterSession` emitted twice in `onNormalDriverAccess`

**Description:** In `supervisordialog.cpp` lines 113–115, `onNormalDriverAccess()` calls `m_warningDialog->open()` and then immediately emits `startMasterSession()` and calls `accept()` — all in the same code path. The `m_warningDialog` (a `Transport`-type `WarningDialog`) is connected in the constructor (lines 33–36) to also `emit startMasterSession()` and `accept()` when its `accepted` signal fires. Because `open()` is used (non-blocking modal), the warning dialog's `accepted` path can complete after the dialog closes, meaning `startMasterSession` is emitted once from the slot directly and then potentially a second time from the `m_warningDialog::accepted` connection. This results in `postLogin()` being invoked twice in the parent `Dialog`, causing double-session initiation.

```cpp
// supervisordialog.cpp:111-115
if (ui->btnNormalDriver->text() == tr("Confirm?")) {
    qDebug() << "current driver id " << gCfg->currentDriverId();
    m_warningDialog->open();       // opens non-blocking; accepted also fires startMasterSession
    emit startMasterSession();     // also fires immediately — duplicate
    accept();
}
// constructor lines 33-36:
connect(m_warningDialog, &WarningDialog::accepted, this, [this](){
    emit startMasterSession();
    accept();
});
```

**Fix:** Remove the direct `emit startMasterSession(); accept();` lines from `onNormalDriverAccess()` and rely solely on the `m_warningDialog::accepted` connection. The pattern used for `on_btnMaintenanceMode_clicked()` (which only calls `m_maintWarningDialog->open()` and lets the `accepted` connection do the work) is the correct model.

---

**A24-2** · HIGH · `m_warningDialog->open()` called but dialog is never confirmed — session starts unconditionally

**Description:** As a consequence of A24-1, the Normal Driver Access path at lines 113–115 calls `emit startMasterSession()` and `accept()` unconditionally, without waiting for the user to confirm or dismiss the `WarningDialog`. The warning dialog is shown as a visual notification, but the session has already started before the user has had a chance to read and acknowledge it. This defeats the purpose of the warning confirmation step.

**Fix:** Remove the immediate `emit startMasterSession(); accept();` from `onNormalDriverAccess()`. Let the `m_warningDialog::accepted` handler (constructor lines 33–36) be the sole path that progresses the session, consistent with the maintenance mode pattern.

---

**A24-3** · MEDIUM · `MasterMenuOptions` enum used as bitmask without `Q_DECLARE_FLAGS`

**Description:** `cigconfigs.h` line 83 defines `MasterMenuOptions` as a plain `enum` with power-of-two values intended for bitwise combination (`UnlockVehicle=1`, `NormalDriverAccess=2`, `ActivateVOR=4`, `MaintenanceMode=8`). `supervisordialog.cpp` lines 180–198 apply bitwise AND (`&`) directly against these enumerators and against `m.option` (typed `quint8`). Qt provides `Q_DECLARE_FLAGS` and `Q_DECLARE_OPERATORS_FOR_FLAGS` to create a type-safe `QFlags<>` wrapper for exactly this pattern. Without it, the compiler will emit warnings on some Qt/C++ configurations ("result of OR on enum values is not an enum value"), and the flag combination is not type-safe — an arbitrary `quint8` value is accepted without error.

```cpp
// cigconfigs.h:83-84
enum MasterMenuOptions {UnlockVehicle=1, NormalDriverAccess=2, ActivateVOR=4,
                        MaintenanceMode=8, DefaultMasterMenu=7, UnassignedMasterMenu=255};

// supervisordialog.cpp:180
if (m.option & CIGCONF::ActivateVOR)   // m.option is quint8, not MasterMenuOptions
```

**Fix:** Declare a `QFlags` type in `cigconfigs.h`:
```cpp
Q_DECLARE_FLAGS(MasterMenuFlags, MasterMenuOptions)
Q_DECLARE_OPERATORS_FOR_FLAGS(CIGCONF::MasterMenuFlags)
```
Change `MasterId::option` from `quint8` to `CIGCONF::MasterMenuFlags`, and update `setMasterOptions` to accept the flag type.

---

**A24-4** · MEDIUM · `MasterId` struct passed by value into `setMasterOptions` — tight coupling to internal layout

**Description:** `SupervisorDialog::setMasterOptions(CIGCONF::MasterId m)` (supervisordialog.h line 23, supervisordialog.cpp line 172) accepts the full `MasterId` struct by value. `SupervisorDialog` only needs two fields: `m.option` (for button visibility) and `m.id` (for VOR activation in `onActivateVOR`). Passing the entire struct couples the dialog tightly to the internal layout of `MasterId`, meaning any future change to that struct (e.g., adding a `QString name` field that becomes expensive to copy, or restructuring `id`) directly affects the dialog API. The name member of `MasterId` is never used within `SupervisorDialog`.

**Fix:** Either pass the two needed values separately (`quint64 masterId, quint8 options`) or pass by const reference (`const CIGCONF::MasterId &m`). Passing by const reference is the minimal change and avoids the unnecessary copy of the `QString name` member on every call.

---

**A24-5** · MEDIUM · `showEvent` overrides a virtual function but declares a default argument

**Description:** `supervisordialog.h` line 49 and `warningdialog.h` line 30 declare `showEvent(QShowEvent *event = 0)`. Adding a default argument to an override of a virtual function is legal C++ but is a recognised anti-pattern: the default is resolved statically based on the pointer type, not the dynamic type. When called through a `QWidget*` or `QDialog*` pointer, the base class default (which has no default) is used; when called directly as `showEvent()` (as done in `supervisordialog.cpp` lines 97, 117, 135, 169), the derived-class default of `nullptr` is silently passed. This creates inconsistent and confusing call semantics, and is the root cause of `Q_UNUSED(event)` being needed at line 54 to suppress the warning.

**Fix:** Remove the `= 0` default from the `showEvent` override in the header. Extract the body of `showEvent` into a private helper (e.g., `void refreshUI()`) and call that helper directly in the places that currently call `showEvent()` without an argument.

---

**A24-6** · MEDIUM · `onVORUpdate` signal uses `on` prefix — naming convention violation

**Description:** `supervisordialog.h` line 33 declares the signal `void onVORUpdate()`. Qt's convention, and the convention used throughout this codebase, is that `on`-prefixed methods are slots (responses to signals), not signals themselves. Using `on` as a signal name creates readability confusion: a reader seeing `connect(..., &SupervisorDialog::onVORUpdate, ...)` is likely to mistake the signal for a slot. The other two signals in the same class (`startMasterSession`, `startMaintenanceSession`) correctly follow the verb-phrase convention.

**Fix:** Rename the signal to `vorStatusChanged()` or `vorUpdated()` and update the connection in `dialog.cpp` line 182 accordingly.

---

**A24-7** · LOW · `PreopScreenOverlay` and `UnlockedDialog` constructors use `= 0` instead of `= nullptr`

**Description:** `preopscreenoverlay.h` line 15 and `unlockeddialog.h` line 17 declare constructors with `QWidget *parent = 0`. `supervisordialog.h` line 20 correctly uses `= nullptr`. Using `0` as a null pointer constant is a C++03 idiom; `nullptr` (C++11) is the correct form for modern Qt/C++ projects and avoids potential ambiguity in overload resolution. The inconsistency also indicates these headers have not been updated alongside the rest of the codebase.

**Fix:** Replace `= 0` with `= nullptr` in the constructor declarations of `PreopScreenOverlay` and `UnlockedDialog`.

---

**A24-8** · LOW · `NO_ACTIVITY_TIME` and `RESET_TIME` defined as bare `#define` macros

**Description:** `supervisordialog.cpp` lines 7–8 define `NO_ACTIVITY_TIME 10000` and `RESET_TIME 2000` as preprocessor macros. These are file-scoped constants with no namespace, no type information, and no debugger visibility. They should be typed constants.

```cpp
#define NO_ACTIVITY_TIME    10000
#define RESET_TIME          2000
```

**Fix:** Replace with typed constants inside the class or as `static constexpr int` in the translation unit:
```cpp
static constexpr int NO_ACTIVITY_TIME = 10000;
static constexpr int RESET_TIME       = 2000;
```

---

**A24-9** · LOW · Mixed tabs and spaces indentation in `supervisordialog.cpp` and `supervisordialog.h`

**Description:** `supervisordialog.cpp` uses 4-space indentation throughout most of the file, but lines 17–18 (constructor initialiser list), line 8 (`RESET_TIME` macro), and several lines in `showEvent`, `onUnlkVehicle`, `onNormalDriverAccess`, `openConfirmationDialog`, `onActivateVOR`, `debounce`, `reset`, and `on_btnMaintenanceMode_clicked` use hard tab characters. `supervisordialog.h` line 49 (`void showEvent`) uses a hard tab while all surrounding lines use 4 spaces. All files also contain Windows-style `\r\n` line endings (`^M` in the raw file). The three other assigned files (`preopscreenoverlay.cpp/h`, `unlockeddialog.cpp/h`) are consistently 4-space indented.

**Fix:** Normalise `supervisordialog.cpp` and `supervisordialog.h` to 4-space indentation throughout and convert line endings to LF-only to match the rest of the UI source files. An `.editorconfig` rule would prevent recurrence.

---

**A24-10** · LOW · `UnlockedDialog::languageChanged` updates `label_3` (auto-generated name) instead of `btnOk`

**Description:** `unlockeddialog.cpp` line 44 sets `ui->label_3->setText(tr("OK"))`. The widget `label_3` is an automatically-generated Qt Designer name with no semantic meaning. The constructor at line 12 sets the icon on `ui->btnOk`, which is the actual OK button. Setting the text of an opaquely-named `label_3` rather than the button itself means that: (a) `label_3` and `btnOk` can display different text, and (b) any redesign of the `.ui` file that renumbers or renames the auto-generated label will silently break the `languageChanged()` call at runtime with no compile-time error.

**Fix:** Rename `label_3` in `unlockeddialog.ui` to `lblOkText` (or remove it if it overlaps visually with `btnOk`), and reference it by the semantic name. Alternatively, if the label is the visible text companion of `btnOk`, update `languageChanged()` to also set `ui->btnOk->setText(tr("OK"))` to keep them in sync.

---

**A24-11** · LOW · `qDebug()` left in production path of `onNormalDriverAccess` and `setMasterOptions`

**Description:** `supervisordialog.cpp` line 112 contains `qDebug() << "current driver id " << gCfg->currentDriverId();` inside the confirmed-second-tap branch of `onNormalDriverAccess()`. Lines 174–176 contain a `qDebug()` call in `setMasterOptions()` that logs the master ID and option bits in hex. These debug statements log security-relevant information (driver identifiers, supervisor credential option bitmasks) to the application debug output on every supervisor action, which may surface in production logs or serial consoles.

**Fix:** Remove the `qDebug()` at line 112. For `setMasterOptions`, replace the debug log with a conditional `qCDebug(categoryName)` that is compiled out in release builds, or remove it entirely.

---

**A24-12** · INFO · `#endif` guard label mismatch in `supervisordialog.h`

**Description:** `supervisordialog.h` line 59 has `#endif // SUPERVISOR_H` but the include guard is defined as `SUPERVISORDIALOG_H` (line 2). The comment is purely informational and has no effect on compilation, but it creates confusion for anyone scanning include guard names and does not match the `_H` suffix pattern used in the rest of the codebase.

**Fix:** Change line 59 to `#endif // SUPERVISORDIALOG_H`.

---

## Summary Table

| ID | Severity | Title |
|---|---|---|
| A24-1 | HIGH | `startMasterSession` emitted twice in `onNormalDriverAccess` |
| A24-2 | HIGH | Warning dialog shown but session starts without waiting for user confirmation |
| A24-3 | MEDIUM | `MasterMenuOptions` bitmask used without `Q_DECLARE_FLAGS` |
| A24-4 | MEDIUM | `MasterId` struct passed by value — leaky abstraction / unnecessary coupling |
| A24-5 | MEDIUM | `showEvent` virtual override declares default argument |
| A24-6 | MEDIUM | Signal `onVORUpdate` uses reserved `on` prefix |
| A24-7 | LOW | `= 0` null pointer in constructors instead of `= nullptr` |
| A24-8 | LOW | `NO_ACTIVITY_TIME` / `RESET_TIME` as untyped `#define` macros |
| A24-9 | LOW | Mixed tabs/spaces and CRLF line endings in `supervisordialog` files |
| A24-10 | LOW | `languageChanged()` targets auto-named `label_3` instead of semantic widget name |
| A24-11 | LOW | `qDebug()` logs security-relevant IDs in production path |
| A24-12 | INFO | `#endif` guard label mismatch in `supervisordialog.h` |
# Pass 4 Agent A25 — Code Quality

**Audit run:** 2026-02-28-01
**Branch:** master
**Auditor:** Agent A25
**Pass:** 4 — Code Quality

---

## 1. Reading Evidence

### 1.1 `ui/unlockreasondialog.h`

**Class:** `UnlockReasonDialog` (inherits `QDialog`)

| Element | Kind | Line |
|---------|------|------|
| `UnlockReasonDialog(QWidget *parent = 0)` | Constructor (public) | 16 |
| `~UnlockReasonDialog()` | Destructor (public) | 17 |
| `QString getReason()` | Public method | 18 |
| `void languageChanged(void)` | Public method | 19 |
| `Ui::UnlockReasonDialog *ui` | Private member | 22 |
| `void setReason()` | Private slot | 23 |
| `QString m_reason` | Private member | 24 |

Types/enums/constants defined: none.

Header guard macro: `UNLOCKREASONDIALOG_H` (guard comment at line 27 incorrectly reads `UNLOCKEDDIALOG_H`).

---

### 1.2 `ui/unlockreasondialog.cpp`

| Element | Kind | Lines |
|---------|------|-------|
| `UnlockReasonDialog::UnlockReasonDialog(QWidget *parent)` | Constructor | 5–32 |
| `UnlockReasonDialog::~UnlockReasonDialog()` | Destructor | 34–37 |
| `void UnlockReasonDialog::setReason()` | Private slot | 39–43 |
| `QString UnlockReasonDialog::getReason()` | Public method | 45–48 |
| `void UnlockReasonDialog::languageChanged(void)` | Public method | 50–71 |

Constants/magic values: none.

---

### 1.3 `ui/vorconfirmationdialog.h`

**Class:** `VORConfirmationDialog` (inherits `QDialog`)

| Element | Kind | Line |
|---------|------|------|
| `VORConfirmationDialog(QWidget *parent = 0)` | Constructor (public) | 15 |
| `~VORConfirmationDialog()` | Destructor (public) | 16 |
| `void isBeingTurnOn(bool on)` | Public method | 18 |
| `Ui::VORConfirmationDialog *ui` | Private member | 21 |
| `QTimer *m_timer` | Private member | 22 |
| `void hideEvent(QHideEvent *)` | Protected override | 25 |
| `void showEvent(QShowEvent *event = 0)` | Protected override | 26 |

Types/enums/constants defined: none.

---

### 1.4 `ui/vorconfirmationdialog.cpp`

| Element | Kind | Lines |
|---------|------|-------|
| `VORConfirmationDialog::VORConfirmationDialog(QWidget *parent)` | Constructor | 6–17 |
| `VORConfirmationDialog::showEvent(QShowEvent *event)` | Protected override | 19–23 |
| `VORConfirmationDialog::hideEvent(QHideEvent *)` | Protected override | 25–28 |
| `VORConfirmationDialog::~VORConfirmationDialog()` | Destructor | 30–33 |
| `void VORConfirmationDialog::isBeingTurnOn(bool on)` | Public method | 35–58 |

Magic numbers: `10000` (line 22 — 10-second timer).

---

### 1.5 `ui/vorwarningdialog.h`

**Class:** `VORWarningDialog` (inherits `QDialog`)

| Element | Kind | Line |
|---------|------|------|
| `VORWarningDialog(QWidget *parent = 0)` | Constructor (public) | 15 |
| `~VORWarningDialog()` | Destructor (public) | 16 |
| `Ui::VORWarningDialog *ui` | Private member | 19 |
| `QTimer *m_timer` | Private member | 20 |
| `void hideEvent(QHideEvent *)` | Protected override | 23 |
| `void showEvent(QShowEvent *event = 0)` | Protected override | 24 |

Types/enums/constants defined: none.

---

### 1.6 `ui/vorwarningdialog.cpp`

| Element | Kind | Lines |
|---------|------|-------|
| `VORWarningDialog::VORWarningDialog(QWidget *parent)` | Constructor | 5–15 |
| `VORWarningDialog::showEvent(QShowEvent *event)` | Protected override | 17–59 |
| `VORWarningDialog::hideEvent(QHideEvent *)` | Protected override | 61–64 |
| `VORWarningDialog::~VORWarningDialog()` | Destructor | 66–69 |

Magic numbers: `30000` (line 57 — 30-second timer).

---

## 2. Findings

---

**A25-1** · HIGH · Inverted boolean semantics in `isBeingTurnOn(bool on)`

**Description:** The public method `VORConfirmationDialog::isBeingTurnOn(bool on)` has inverted boolean semantics. The parameter name `isBeingTurnOn` reads as "is VOR being turned on", yet the implementation tests `if (!on)` to show the "turn ON" UI and `else` (i.e., `on == true`) to show the "turn OFF" UI. In plain terms: passing `true` produces the "turn OFF" confirmation and passing `false` produces the "turn ON" confirmation — the opposite of what the name implies.

The sole call site in `supervisordialog.cpp:132` passes `gCfg->convorStatus()`, which is non-zero when VOR is already active. Passing `1` (VOR currently on) therefore invokes the "turn OFF" branch, which happens to be the operationally correct flow (the user wants to toggle it off), but only because the inversion at the call site and the inversion in the implementation cancel each other out. Any future caller reading the method name and signature will expect `true` = "turning on" and will wire it correctly — but then get the wrong UI.

This is a logic-error / dead semantic: the method is named as a predicate query (`isBeing...`) but acts as a command setter, with its boolean parameter silently inverted relative to its name.

**Fix:** Rename the method to `setVORBeingTurnedOn(bool turningOn)` and correct the body so that `turningOn == true` shows the "turn ON" UI and `turningOn == false` shows the "turn OFF" UI. Update `supervisordialog.cpp:132` accordingly — the call should pass `!gCfg->convorStatus()` (i.e., VOR is currently off, so it is being turned on) to match the corrected semantics.

---

**A25-2** · MEDIUM · Method named as boolean predicate but used as a setter (misnaming / leaky abstraction)

**Description:** `isBeingTurnOn` (line 18 of `vorconfirmationdialog.h`) follows the `is...` naming convention that in C++ and Qt is reserved for boolean query functions returning `bool`. This method returns `void` and configures internal UI state. Callers reading the header cannot determine from the signature alone whether this is a getter or a setter. This constitutes a leaky abstraction: the public interface exposes the VOR on/off state as a raw bool rather than an enum or a named intent, and uses a misleading predicate name.

**Fix:** Replace the raw `bool` parameter with a scoped enum, e.g.:

```cpp
enum class VORAction { TurnOn, TurnOff };
void configureForAction(VORAction action);
```

This makes call sites self-documenting and removes the naming confusion entirely.

---

**A25-3** · MEDIUM · Deprecated Qt4 default constructor argument syntax (`QWidget *parent = 0`)

**Description:** All three dialog header files declare constructors with `QWidget *parent = 0` (null integer literal as a pointer default):

- `unlockreasondialog.h:16`
- `vorconfirmationdialog.h:15`
- `vorwarningdialog.h:15`

Similarly, `showEvent(QShowEvent *event = 0)` uses `= 0` in:

- `vorconfirmationdialog.h:26`
- `vorwarningdialog.h:24`

Using integer `0` as a null pointer constant is deprecated in C++11 and later and produces compiler warnings under `-Wzero-as-null-pointer-constant`. The correct idiom is `nullptr`.

**Fix:** Replace all `= 0` default pointer arguments with `= nullptr` across the three headers. The `showEvent` default argument is additionally questionable (see A25-4 below).

---

**A25-4** · MEDIUM · Default argument on `showEvent` overrides creates dead parameter path

**Description:** Both `VORConfirmationDialog::showEvent(QShowEvent *event = 0)` (h:26) and `VORWarningDialog::showEvent(QShowEvent *event = 0)` (h:24) declare a default argument on an override of a Qt protected virtual. Qt's event system always supplies a non-null `QShowEvent *` when it calls `showEvent`. The default argument `= 0` means a caller could invoke `dialog->showEvent()` directly (without an event object), which would produce undefined behaviour inside Qt's event dispatching chain and is never the intended usage. The matching `Q_UNUSED(event)` in `VORConfirmationDialog::showEvent` (cpp:21) makes this even clearer — the parameter is unused, so there is no legitimate reason to expose a default.

**Fix:** Remove the default argument from both `showEvent` overrides. The correct signature is `void showEvent(QShowEvent *event) override;`. Mark both overrides with `override` to catch future base-class signature changes.

---

**A25-5** · MEDIUM · Magic numbers for timer durations

**Description:** Timer start values are embedded as bare integer literals with no named constant:

- `vorconfirmationdialog.cpp:22` — `m_timer->start(10000)` (10-second auto-reject)
- `vorwarningdialog.cpp:57` — `m_timer->start(30000)` (30-second auto-reject, with an inline comment)

These magic numbers make it impossible to find or change all timeout values from a single location. The 10-second timeout in the confirmation dialog has no comment at all; a maintainer must derive its significance. The VOR confirmation dialog auto-rejects after 10 seconds, which is a safety-relevant timeout that could be accidentally changed.

**Fix:** Define named constants, either as `static constexpr int` members or in a shared constants header:

```cpp
static constexpr int kVORConfirmTimeoutMs  = 10'000;   // vorconfirmationdialog
static constexpr int kVORWarningTimeoutMs  = 30'000;   // vorwarningdialog
```

Replace the bare literals with the named constants and add a comment on `kVORConfirmTimeoutMs` explaining its safety rationale.

---

**A25-6** · LOW · Inconsistent `#include` of `QTimer` — missing from `vorconfirmationdialog.h`

**Description:** Both `VORConfirmationDialog` and `VORWarningDialog` hold a `QTimer *m_timer` private member. `vorwarningdialog.h` does not include `<QTimer>` directly (it is included only in the `.cpp`), and neither does `vorconfirmationdialog.h`. Both headers depend on a forward declaration being satisfied by a transitive include. If the include order in any translation unit changes, the headers will fail to compile in isolation. This is a fragility, not an immediate defect, but it violates the rule that each header should compile standalone.

**Fix:** Add `#include <QTimer>` (or at minimum `QT_FORWARD_DECLARE_CLASS(QTimer)`) to both `vorconfirmationdialog.h` and `vorwarningdialog.h`.

---

**A25-7** · LOW · Incorrect header guard comment in `unlockreasondialog.h`

**Description:** The closing `#endif` comment at line 27 of `unlockreasondialog.h` reads:

```cpp
#endif // UNLOCKEDDIALOG_H
```

but the guard macro defined at line 1 is `UNLOCKREASONDIALOG_H`. The comment is a copy-paste artefact and does not match the actual guard name.

**Fix:** Change line 27 to `#endif // UNLOCKREASONDIALOG_H`.

---

**A25-8** · LOW · Inline HTML template string hard-coded in `showEvent` — maintainability hazard

**Description:** `VORWarningDialog::showEvent` (cpp:25–53) constructs a multi-paragraph HTML string by concatenating six raw `QString` fragment literals, each containing full HTML 4.0 boilerplate including a `<!DOCTYPE>` declaration, inline `<style>`, and per-paragraph `<span>` wrappers. This HTML is hard-coded in an event handler that fires every time the dialog is shown, meaning the string allocation and construction happen on every show event. The content also hard-codes the font family `'MS Shell Dlg 2'` (Windows-specific shell font), which is inconsistent with the Ubuntu font specified inside the same snippet.

Additionally, the HTML construction is entirely separate from the translatable text strings (`text1`, `text2`, `text3`), but the HTML wrapper cannot itself be translated — if the UI ever needs different formatting per language, the function would require structural changes.

**Fix:** Move the static HTML wrapper text into the `.ui` file as the default rich-text content of `textEdit`, and replace the `showEvent` body with only the three `setText` calls for the translatable strings. Alternatively, use a `QTextDocument` with proper `setHtml` only once at construction and update only the translatable segments on language change.

---

**A25-9** · LOW · `setReason()` uses `sender()` cast without type guard

**Description:** `UnlockReasonDialog::setReason()` (cpp:41) casts `sender()` directly to `QPushButton *` without any runtime type check:

```cpp
m_reason = ((QPushButton *)sender())->text();
```

`QObject::sender()` returns `QObject *`. A C-style cast to `QPushButton *` bypasses Qt's type system. If the slot were ever accidentally connected to a non-`QPushButton` signal emitter, this would be undefined behaviour. The correct Qt idiom is `qobject_cast<QPushButton *>(sender())` with a null guard.

**Fix:** Replace with:

```cpp
QPushButton *btn = qobject_cast<QPushButton *>(sender());
if (btn) {
    m_reason = btn->text();
    emit accept();
}
```

---

**A25-10** · LOW · `override` keyword absent on all virtual overrides

**Description:** None of the overriding virtual methods in the three classes use the `override` specifier:

- `VORConfirmationDialog::hideEvent`, `showEvent` (h:25–26)
- `VORWarningDialog::hideEvent`, `showEvent` (h:23–24)

Without `override`, a typo in the method signature (e.g., wrong parameter type) silently creates a new virtual function rather than overriding the base class, and the base-class version is called instead. This is a standard C++11 best-practice violation.

**Fix:** Add `override` to all four method declarations in both headers.

---

**A25-11** · INFO · Style inconsistency: mixed indentation in `vorconfirmationdialog.cpp`

**Description:** `vorconfirmationdialog.cpp` mixes space-indentation (4 spaces, lines 35–57) with tab-indentation (lines 48 and 57 close-brace lines). The `isBeingTurnOn` function body at line 48 (`} else {`) and line 57 (`}`) uses a tab character while the surrounding code uses spaces. This is a minor style inconsistency indicating two different authors or editors touched this function.

**Fix:** Normalise the file to use 4-space indentation throughout, consistent with the rest of the `.cpp` files in the `ui/` directory.

---

**A25-12** · INFO · Typo in UI label name: `lblCornfirm` (missing 'f' in "confirm")

**Description:** `vorconfirmationdialog.cpp` references `ui->lblCornfirm` (lines 38, 41, 43, 50, 52) — the widget name in the `.ui` file is misspelled as `Cornfirm` instead of `Confirm`. This is a cosmetic defect in the form designer but it propagates into the C++ identifier, making the code harder to search and review.

**Fix:** Rename the widget in `vorconfirmationdialog.ui` from `lblCornfirm` to `lblConfirm` and update all references in the `.cpp` file. This requires a regeneration of the `ui_vorconfirmationdialog.h` auto-generated header.

---

## 3. Summary Table

| ID | Severity | Title | Location |
|----|----------|-------|----------|
| A25-1 | HIGH | Inverted boolean semantics in `isBeingTurnOn(bool on)` | `vorconfirmationdialog.h:18`, `vorconfirmationdialog.cpp:35–58` |
| A25-2 | MEDIUM | Method named as boolean predicate but used as a setter | `vorconfirmationdialog.h:18` |
| A25-3 | MEDIUM | Deprecated `= 0` null pointer default arguments | `unlockreasondialog.h:16`, `vorconfirmationdialog.h:15,26`, `vorwarningdialog.h:15,24` |
| A25-4 | MEDIUM | Default argument on `showEvent` override enables undefined-behaviour call path | `vorconfirmationdialog.h:26`, `vorwarningdialog.h:24` |
| A25-5 | MEDIUM | Magic numbers for safety-relevant timer durations | `vorconfirmationdialog.cpp:22`, `vorwarningdialog.cpp:57` |
| A25-6 | LOW | `<QTimer>` not included in headers that declare `QTimer *` members | `vorconfirmationdialog.h`, `vorwarningdialog.h` |
| A25-7 | LOW | Incorrect `#endif` guard comment | `unlockreasondialog.h:27` |
| A25-8 | LOW | Hard-coded inline HTML template built in `showEvent` on every show | `vorwarningdialog.cpp:25–53` |
| A25-9 | LOW | C-style cast of `sender()` without type guard | `unlockreasondialog.cpp:41` |
| A25-10 | LOW | `override` specifier absent on all virtual overrides | `vorconfirmationdialog.h:25–26`, `vorwarningdialog.h:23–24` |
| A25-11 | INFO | Mixed tab/space indentation in `vorconfirmationdialog.cpp` | `vorconfirmationdialog.cpp:48,57` |
| A25-12 | INFO | Typo `lblCornfirm` in widget name | `vorconfirmationdialog.cpp:38,41,43,50,52` |
# Pass 4 Agent A26 — Code Quality

**Audit run:** 2026-02-28-01
**Branch:** master
**Repo root:** C:/Projects/cig-audit/repos/mark3-pvd
**Agent scope:** ui/warningdialog, utils/barcode128, utils/bytearray, utils/logger, utils/zconf (3P), utils/zlib (3P)

---

## 1. Reading Evidence

### `ui/warningdialog.h`

**Class:** `WarningDialog` (extends `QDialog`)

**Enum defined:**
- `WarningDialogType` — values: `VOR`, `Transport`, `Maintenance` (line 10, file-scope, not inside the class)

**Member variables:**
- `Ui::WarningDialog *ui` (line 21)
- `QTimer *m_timer` (line 22)
- `WarningDialogType m_type` (line 23)

**Methods declared:**

| Line | Signature |
|------|-----------|
| 17 | `explicit WarningDialog(WarningDialogType type, QWidget *parent = 0)` |
| 18 | `~WarningDialog()` |
| 24 | `QString showVorWarning()` (private) |
| 25 | `QString showTransportWarning()` (private) |
| 26 | `QString showMaintenanceWarning()` (private) |
| 29 | `void hideEvent(QHideEvent *)` (protected override) |
| 30 | `void showEvent(QShowEvent *event = 0)` (protected override) |

---

### `ui/warningdialog.cpp`

**Functions / methods defined:**

| Line | Signature |
|------|-----------|
| 5  | `WarningDialog::WarningDialog(WarningDialogType type, QWidget *parent)` — constructor |
| 18 | `void WarningDialog::showEvent(QShowEvent *event)` |
| 47 | `QString WarningDialog::showTransportWarning()` |
| 84 | `QString WarningDialog::showVorWarning()` |
| 120 | `QString WarningDialog::showMaintenanceWarning()` |
| 156 | `void WarningDialog::hideEvent(QHideEvent *)` |
| 161 | `WarningDialog::~WarningDialog()` |

No types, enums, or constants defined in the `.cpp` file.

---

### `utils/barcode128.h`

**Classes defined:**

**`BarcodeChar`**

| Line | Signature |
|------|-----------|
| 10 | `BarcodeChar()` — default constructor |
| 17 | `BarcodeChar(const BarcodeChar &other)` — copy constructor |
| 24 | `BarcodeChar(int value, QString name, QString pattern)` — value constructor |
| 31 | `BarcodeChar &operator=(const BarcodeChar &other)` |

Private members: `int m_value`, `QString m_name`, `QString m_pattern`
Friend: `class Barcode128`

**`Barcode128`**

| Line | Signature |
|------|-----------|
| 50 | `Barcode128(const QString &info, int height = 100, int sizeMult = 2)` — constructor |
| 51 | `~Barcode128()` |
| 52 | `static int width(const QString &info, int sizeMult)` |
| 54 | `QPixmap pixmap()` |
| 57 | `void initChar(int value, const QString &name, const QString &pattern)` (private) |
| 58 | `void initChars()` (private) |
| 59 | `void encodeChar(const BarcodeChar &ch)` (private) |
| 60 | `void drawBlackVerticalLineAtPos()` (private) |
| 61 | `void drawEmptyVerticalLineAtPos()` (private) |

Private members: `QMap<int, BarcodeChar> m_valueToChar`, `QMap<QString, BarcodeChar> m_nameToChar`, `QImage *m_image`, `int m_pos`, `int m_sizeMult`

---

### `utils/barcode128.cpp`

**Macros / constants defined:**

| Line | Name | Value |
|------|------|-------|
| 5 | `START_CODE` | `104` |
| 6 | `END_CODE` | `106` |
| 7 | `MODULO_VAL` | `103` |

**Functions / methods defined:**

| Line | Signature |
|------|-----------|
| 9  | `Barcode128::Barcode128(const QString &info, int height, int sizeMult)` |
| 39 | `Barcode128::~Barcode128()` |
| 45 | `QPixmap Barcode128::pixmap()` |
| 53 | `void Barcode128::initChar(int value, const QString &name, const QString &pattern)` |
| 61 | `void Barcode128::initChars()` — contains `#if START_CODE == 103` / `#elif START_CODE == 104` / `#else // todo type c` branches |
| 283 | `void Barcode128::encodeChar(const BarcodeChar &ch)` |
| 298 | `void Barcode128::drawBlackVerticalLineAtPos()` |
| 309 | `void Barcode128::drawEmptyVerticalLineAtPos()` |
| 320 | `int Barcode128::width(const QString &info, int sizeMult)` |

**Duplicate key in `initChars()` (Code B / `START_CODE == 104` branch):**
- Line 184: `initChar(12, "0", "10110011100")` — inserts key `"0"` into `m_nameToChar`
- Line 188: `initChar(16, "0", "10011101100")` — immediately overwrites key `"0"` in `m_nameToChar`

The same duplicate appears in the `START_CODE == 103` branch (lines 76 and 80).

---

### `utils/bytearray.h` (header-only)

**Macros defined:**

| Line | Macro |
|------|-------|
| 6 | `LE_INT(c1, c2, c3, c4)` |
| 7 | `BE_INT(c1, c2, c3, c4)` |
| 8 | `LE_SHORT(c1, c2)` |
| 9 | `BE_SHORT(c1, c2)` |
| 11 | `BE_LONG(c1, c2, c3, c4, c5, c6, c7, c8)` |

**Class:** `ByteArray`

| Line | Signature |
|------|-----------|
| 16 | `static QByteArray asprintf(const char *cformat, ...)` |
| 30 | `static int sscanf(const QByteArray &ba, const char *cformat, ...)` |

No enums or constants defined in the class body.

---

### `utils/logger.h`

**Enum defined:**
- `LogLevel` (file-scope, line 8): `LogDebug`, `LogInfo`, `LogWarning`, `LogCritical`, `LogFatal`, `LogNone`

**Class:** `Logger`

Static members: `Logger *m_instance`, `QMutex m_mutex`

Instance members: `QFile m_file`, `QTextStream m_outStream`, `LogLevel m_logThreshold`, `QtMessageHandler m_oldHandler`

| Line | Signature |
|------|-----------|
| 13 | `static Logger* instance()` |
| 14 | `void close()` |
| 15 | `void setLogThreshold(LogLevel level)` |
| 16 | `LogLevel logThreshold() const` |
| 17 | `void log(LogLevel level, const QString &message)` |
| 20 | `Logger()` (protected constructor) |
| 21 | `virtual ~Logger()` |
| 22 | `static void logMessageHandler(QtMsgType type, const QMessageLogContext &context, const QString &msg)` (protected) |

---

### `utils/logger.cpp`

**Macro / constant defined:**

| Line | Name | Value |
|------|------|-------|
| 8 | `LOG_FILE_DIR` | `"/mnt/sd"` |

**Functions / methods defined:**

| Line | Signature |
|------|-----------|
| 13 | `Logger::Logger()` — constructor |
| 46 | `Logger::~Logger()` |
| 54 | `Logger *Logger::instance()` |
| 62 | `void Logger::close()` |
| 70 | `void Logger::setLogThreshold(LogLevel level)` |
| 75 | `LogLevel Logger::logThreshold() const` |
| 80 | `void Logger::log(LogLevel level, const QString &msg)` |
| 117 | `void Logger::logMessageHandler(QtMsgType type, const QMessageLogContext &context, const QString &msg)` |

---

### `utils/zconf.h` and `utils/zlib.h`

Both are upstream zlib 1.3.1 (January 22nd, 2024). No project-specific additions, modifications, or extra symbols were found. No findings generated for these files.

---

## 2. Findings

---

**A26-1** · CRITICAL · `ByteArray::asprintf` uses `va_list` after `va_end` — undefined behaviour

**Description:**
In `utils/bytearray.h` lines 16–27, `asprintf` calls `va_start(ap, cformat)` to measure the required buffer size with `vsnprintf(..., 0, ...)`, then calls `va_end(ap)`. After `va_end`, the `va_list` object `ap` is indeterminate. The subsequent call to `vsprintf(ba.data(), cformat, ap)` on line 25 reuses the already-ended `va_list`, which is undefined behaviour per C99/C++11 §7.16. On ARM targets (the deployment platform) the ABI passes arguments in registers that `va_end` may trash or zero; the resulting `vsprintf` may produce garbage output, read unmapped memory, or crash. This function is called in at least 30 production `.cpp` files throughout the codebase.

**Fix:** Declare a second `va_list ap2`, call `va_copy(ap2, ap)` before `va_end(ap)`, then use `ap2` for the second format call, ending with `va_end(ap2)`. Alternatively, replace the entire function with `QByteArray::asprintf()` (available since Qt 5.5) which is safe and removes the custom variadic wrapper entirely.

---

**A26-2** · HIGH · `ByteArray::asprintf` allocates buffer without space for NUL terminator

**Description:**
In `utils/bytearray.h` line 24, `ba.resize(size)` allocates exactly `size` bytes, where `size` is the return value of `vsnprintf(nullptr, 0, ...)`. The POSIX specification for `vsnprintf` states that the return value is the number of characters that would have been written *excluding* the terminating NUL byte. `QByteArray::resize(n)` allocates `n` bytes; `vsprintf` on line 25 then writes `size` characters plus a NUL terminator, writing one byte past the end of the allocated buffer. This is a one-byte heap overflow on every call. Even if the downstream Qt code never reads past `size` bytes, the heap corruption is real and exploitable.

**Fix:** Change `ba.resize(size)` to `ba.resize(size + 1)`, then after the `vsprintf` call truncate the trailing NUL with `ba.resize(size)` if a NUL-free `QByteArray` is required. Or, as above, replace with `QByteArray::asprintf()`.

---

**A26-3** · HIGH · `Logger::instance()` is not thread-safe — double-checked locking missing

**Description:**
In `utils/logger.cpp` lines 54–60, `Logger::instance()` checks `m_instance == nullptr` and, if so, constructs a new `Logger`. There is no mutex guard around this check-and-assign sequence. If two threads call `instance()` simultaneously before the singleton is constructed, both may observe `m_instance == nullptr` and both construct a `Logger`, leaking one instance, installing two `qInstallMessageHandler` callbacks in sequence, and overwriting `m_oldHandler`. The static `m_mutex` is used correctly inside `log()`, but the singleton initialisation itself is unprotected. The `close()` function (lines 62–68) has the same problem in reverse: it deletes and nullifies `m_instance` without holding the mutex, racing with concurrent `log()` calls that have already loaded the pointer but not yet entered their own `QMutexLocker`.

**Fix:** Protect the `instance()` body with a `QMutexLocker locker(&m_mutex)` guard. Alternatively, replace the manual singleton with a function-local static (`static Logger inst; return &inst;`), which is guaranteed to be initialised once under C++11's magic-statics rules without any explicit locking. Apply the same mutex guard to `close()`.

---

**A26-4** · MEDIUM · Duplicate key `"0"` in `Barcode128::initChars()` makes one barcode character unreachable

**Description:**
In `utils/barcode128.cpp` inside both the `#if START_CODE == 103` branch (lines 76 and 80) and the active `#elif START_CODE == 104` branch (lines 184 and 188), `initChar` is called twice with the name `"0"`. The second call (`value=16, name="0"`) silently overwrites the first (`value=12, name="0"`) in `m_nameToChar` because `QMap::insert` replaces existing keys. Value 12 in Code B is the comma `,`; value 16 is the digit `0`. The net effect is that the digit `0` encodes correctly (value 16 is the right barcode-128 Code B mapping for `'0'`), but value 12 (`,`) can never be looked up by character name from `m_nameToChar`. If any caller ever attempts to encode a comma by name lookup it will silently get the `"0"` entry instead. Additionally, value 12 in Code A is the comma but the Code A table mistakenly uses `"0"` as well, suggesting a copy-paste error during table transcription.

**Fix:** Replace the second `initChar(12, "0", ...)` call with the correct character name. In Code B the character with value 12 is `,` (ASCII 44). Change line 184 of the Code B branch to `initChar(12, ",", "10110011100")`. Apply the equivalent correction to the Code A branch.

---

**A26-5** · MEDIUM · `WarningDialog` HTML generation is massively duplicated — single-character change risk

**Description:**
In `ui/warningdialog.cpp`, the three private methods `showTransportWarning()` (lines 47–82), `showVorWarning()` (lines 84–118), and `showMaintenanceWarning()` (lines 120–154) are structurally identical. Each reconstructs all six HTML fragment strings (`html1_start`, `html1_end`, `html2_start`, `html2_end`, `html3_start`, `html3_end`) in full, then builds the combined message using the same `reserve` + eight `append` calls. The only variation between the three methods is the content of `text1` (the vehicle-mode description). This is a textbook duplication risk: any change to the HTML template (e.g. a font name, CSS rule, or structure change) must be applied in three separate places consistently. It also inflates the binary and translation surface unnecessarily.

**Fix:** Refactor to a single private helper, e.g. `QString buildWarningHtml(const QString &text1, const QString &text2, const QString &text3)`, and have each of the three public-facing methods call it with the appropriate `text1`. `text2` and `text3` are already identical across all three variants and need only be defined once.

---

**A26-6** · MEDIUM · `WarningDialogType` enum is file-scope, not class-scope

**Description:**
In `ui/warningdialog.h` line 10, `enum WarningDialogType {VOR, Transport, Maintenance}` is declared at global namespace scope, not inside `WarningDialog`. The enumerator names `VOR`, `Transport`, and `Maintenance` are injected into the global namespace. `Transport` and `Maintenance` are common English words with a high collision risk in any future global symbol or platform SDK inclusion. `VOR` is the ICAO aviation acronym for VHF Omnidirectional Range and may conflict with third-party aviation or avionics libraries.

**Fix:** Move the enum inside the `WarningDialog` class body (or use `enum class WarningDialogType` as a scoped enum in C++11), and update the three call sites in `warningdialog.cpp`'s `switch` statement to use the qualified form `WarningDialog::VOR`, etc.

---

**A26-7** · LOW · `showEvent` override uses deprecated `QWidget *parent = 0` default parameter style

**Description:**
In `ui/warningdialog.h` line 30, the protected override `void showEvent(QShowEvent *event = 0)` declares a default argument of `0` (implicit null pointer) for the event parameter. The same pattern appears on line 17 for the constructor's `parent` parameter. Using integer literal `0` instead of `nullptr` is pre-C++11 style; the Qt documentation recommends `nullptr` from Qt 5 onward. The default-argument on `showEvent` is also misleading because Qt's event system always passes a valid, non-null `QShowEvent *` to overridden `showEvent`; a default argument implies the override can be called with no event, which it should not be.

**Fix:** Replace `= 0` with `= nullptr` on the constructor parameter (line 17) and remove the default argument entirely from the `showEvent` declaration (line 30), since overrides should match the base class signature exactly.

---

**A26-8** · LOW · `BeepType` enum defined but none of its values are used anywhere in the codebase

**Description:**
`platform/pwmbeeper.h` (line 15) defines a nested enum `PwmBeeper::BeepType` with values `BeepOn`, `BeepSilent`, and `BeepOff`. A grep across all `.cpp` files in the repository finds zero references to any of these enum values. The enum is not used internally within `PwmBeeper` itself — the beeper state is tracked via `bool m_beeping` and `void setBeep(bool on)`. This is dead code that adds confusion about the intended control API and may indicate an abandoned refactoring.

**Fix:** Remove the `BeepType` enum declaration from `platform/pwmbeeper.h`. If a future multi-state beep API is intended, implement and use it before committing.

---

**A26-9** · LOW · `Barcode128::initChars()` has an unimplemented Type C branch left with a comment

**Description:**
In `utils/barcode128.cpp` line 279, the preprocessor branch `#else // todo type c` is empty. If `START_CODE` were ever set to `105` (Code C mode), `initChars()` would run without inserting any characters, leaving both `QMap`s empty. Encoding would silently produce an all-zeros-value barcode rather than an error. The comment `// todo type c` documents a known incomplete implementation with no associated issue or deadline.

**Fix:** Add either a `static_assert` or a `#error` directive inside the `#else` branch to produce a compile-time failure if `START_CODE` is set to an unsupported value. This converts the silent runtime failure into a build-time error.

---

**A26-10** · LOW · `ByteArray::asprintf` comment documents unsafety but does not prevent use

**Description:**
`utils/bytearray.h` lines 15 and 29 contain comments stating "actually, do not recommend as not type safe" and "not recommend too". These comments acknowledge known problems (also found as CRITICAL and HIGH issues above) but do not discourage use at the call site and do not carry a deprecation marker. The function is called in over 30 production `.cpp` files. Self-deprecating comments without enforced deprecation provide no protection.

**Fix:** Add `[[deprecated("Use QByteArray::asprintf() instead")]]` or the Qt equivalent `Q_DECL_DEPRECATED_X(...)` to the function signatures. This produces a compiler warning at every call site, driving migration. Remove the functions once all call sites are updated.

---

**A26-11** · INFO · Mixed indentation (tabs vs spaces) in `warningdialog.h`

**Description:**
`ui/warningdialog.h` mixes tab characters (lines 22, 29, 30) with four-space indentation (lines 17–18, 21, 24–26). This is a minor style inconsistency that does not affect correctness but reduces readability and may cause diff noise.

**Fix:** Normalise to the project's chosen style (four spaces, as used in the majority of the codebase) using an editor formatter or `expand`.

---

## 3. Summary Table

| ID | Severity | File(s) | Short Title |
|----|----------|---------|-------------|
| A26-1 | CRITICAL | `utils/bytearray.h:25` | `asprintf` reuses `va_list` after `va_end` — UB |
| A26-2 | HIGH | `utils/bytearray.h:24` | Buffer allocation off by one — heap overflow on every call |
| A26-3 | HIGH | `utils/logger.cpp:54-68` | `Logger::instance()` / `close()` not thread-safe |
| A26-4 | MEDIUM | `utils/barcode128.cpp:184,188` | Duplicate key `"0"` in `initChars()` — one entry unreachable |
| A26-5 | MEDIUM | `ui/warningdialog.cpp:47-154` | Three-way HTML generation duplication — maintenance hazard |
| A26-6 | MEDIUM | `ui/warningdialog.h:10` | `WarningDialogType` enum in global namespace — name pollution |
| A26-7 | LOW | `ui/warningdialog.h:17,30` | Deprecated `= 0` null pointer style; misleading default on `showEvent` |
| A26-8 | LOW | `platform/pwmbeeper.h:15` | `BeepType` enum entirely unused — dead code |
| A26-9 | LOW | `utils/barcode128.cpp:279` | Unimplemented Type C branch — silent empty-map failure |
| A26-10 | LOW | `utils/bytearray.h:15,29` | Unsafety comment without deprecation attribute |
| A26-11 | INFO | `ui/warningdialog.h` | Mixed tab/space indentation |
