# Pass 2 – Test Coverage Audit: A07

**Agent:** A07
**Audit Run:** 2026-02-28-01
**Pass:** 2 – Test Coverage
**Branch Confirmed:** master (verified via `git branch --show-current`)

---

## Files Audited

| File | Lines |
|------|-------|
| `comm/bleinputhandler.h` | 64 |
| `comm/bleinputhandler.cpp` | 354 |
| `comm/canexpansion.h` | 131 |
| `comm/canexpansion.cpp` | 670 |

---

## Reading Evidence

### bleinputhandler.h

**Class:** `BleInputHandler : public QObject`

**Enum:**
- `DigitalFormat` { `SessionFormat`, `UsageFormat`, `OnDemandFormat` } (line 18)

**Public Methods:**

| Method | Line |
|--------|------|
| `BleInputHandler(CanExpansion *canExpansion)` (constructor) | 20 |
| `void updateIgnition(CIGCONF::PowerState state)` | 22 |
| `void updateBleInput(CIGCONF::BleExpansionDI input, bool state)` | 23 |
| `void changeBleState(bool connected)` | 24 |
| `void updateIdleTimer()` | 26 |
| `QByteArray digitalInputs(DigitalFormat format, bool autoReset)` | 28 |

**Signals:**

| Signal | Line |
|--------|------|
| `void idleTimeout()` | 31 |
| `void sendGmtpMessage(CIGCONF::GmtpMessage msg, const QByteArray &extra)` | 32 |

**Private Methods (slots/helpers):**

| Method | Line |
|--------|------|
| `void resetStates()` | 36 |
| `void onTimerEvent()` | 37 |
| `void sendSeenSafeReport(bool state)` | 38 |

**Private Members:**
- `CanExpansion *m_canExpansion` (line 50)
- `QTimer *m_timer` (line 51) — idle timer, nullable
- `QTimer *m_digInputModeTimer` (line 52) — single-shot debounce timer
- `InputState m_ignition` (line 54)
- `InputState m_bleInputs[4]` (line 55) — fixed-size array, indices 0-3
- `bool m_bypassReset` (line 56)
- `bool m_bleConnected` (line 57)
- `bool m_seenState` (line 58) — **not initialized in constructor**
- `quint64 m_lastSeenReport` (line 59)
- `bool m_seenSecond` (line 60)
- `quint32 m_seenTimestamp` (line 61)

**Includes:** `app/cigconfigs.h`, `<QObject>`

---

### bleinputhandler.cpp

**Includes:** `bleinputhandler.h`, `comm/canexpansion.h`, `app/globalconfigs.h`, `platform/seriallogger.h`, `<QTimer>`

**Constructor (line 7-23):**
- `m_seenState` is not in member-initialization list (indeterminate value)
- Connects `CanExpansion::inputStateChanged` to `updateBleInput`
- Connects `CanExpansion::accessible` to `changeBleState`
- Connects `m_digInputModeTimer::timeout` to `onTimerEvent`

**`resetStates()` (line 25-38):**
- Uses `memset` on `m_ignition` and `m_bleInputs[4]` — safe for fixed-size structs
- `m_seenState` is NOT reset here either

**`updateIgnition()` (line 40-79):**
- `delta = (clock - m_ignition.clock) / 100` — no backward-clock guard; unsigned wraparound corrupts accumulators
- quint32 accumulation fields susceptible to overflow on long-running deployments
- Calls `resetStates()` which calls `updateIdleTimer()` — no infinite loop but indirect re-entry

**`updateBleInput()` (line 115-176):**
- `index = input - CIGCONF::BleExpDI1` — no bounds check before `m_bleInputs[index]` access
- `m_digInputModeTimer->start()` called only when `index == 2` and SeenSafety mode

**`digitalInputs()` (line 257-353):**
- `OnDemandFormat` branch returns early (line 296), skipping BLE input accumulation entirely
- When `!m_bleConnected`, BLE input loop breaks at line 276 but stale values are still emitted in format output
- Hardcoded ` 5: 0 0 0` and ` 10: 0 0 0` sentinels (lines 328, 350)

---

### canexpansion.h

**Class:** `CanExpansion : public QObject`

**Public Struct:** `ShockEvent` (line 25-40) — 13 fields

**Public Methods:**

| Method | Line |
|--------|------|
| `CanExpansion(EM070::CanBus*, EM070::PowerSupply*)` (constructor) | 42 |
| `void setEnabled(bool enable)` | 44 |
| `const QByteArray &deviceName() const` | 46 |
| `const QByteArray &bleVersion() const` | 47 |
| `const QByteArray &mainVersion() const` | 48 |
| `const QByteArray &manufacture() const` | 49 |
| `const QByteArray &modelNumber() const` | 50 |
| `bool relayOutput(CIGCONF::BleExpansionRelay relay) const` | 52 |
| `void setRelayOutput(CIGCONF::BleExpansionRelay relay, bool state)` | 55 |
| `quint16 relayTimeout(CIGCONF::BleExpansionRelay relay) const` | 57 |
| `void setRelayTimeout(CIGCONF::BleExpansionRelay relay, quint16 timeout_in_sec)` | 60 |
| `void setCurrentTime(quint32 time)` | 62 |
| `bool digitalInput(CIGCONF::BleExpansionDI di) const` | 64 |
| `void setShockThreshold(quint32 threshold)` | 66 |
| `void setShockPeriod(quint32 period)` | 67 |
| `bool isShockQueueEmpty()` | 69 |
| `ShockEvent shockEvent()` | 70 |
| `bool generateShockMessage(bool force)` | 72 |
| `void setGnssReceiver(EM070::GnssReceiver* gnss)` | 74 |

**Signals:**

| Signal | Line |
|--------|------|
| `void inputStateChanged(CIGCONF::BleExpansionDI input, bool state)` | 77 |
| `void shockOccurred()` | 78 |
| `void amberImpactOccurred()` | 79 |
| `void redImpactOccurred()` | 80 |
| `void accessible(bool yes)` | 81 |
| `void expModInfo(QByteArray mainVersion)` | 82 |
| `void inactiveNotification(bool inactive, quint32 secs)` | 83 |
| `void relayStateChanged(bool relay1, bool relay2)` | 84 |

**Private Methods:**

| Method | Line |
|--------|------|
| `void initialise()` | 87 |
| `void updateBusConfig()` | 88 |
| `void readCanFrame(quint32 id, const QByteArray &ba)` | 89 |
| `void packetHandler()` | 90 |
| `void writeFrame()` | 91 |
| `void timeout()` | 92 |
| `void sendPacket(uint16_t cmd, const QByteArray &ba)` | 94 |
| `void initRelays()` | 96 |
| `void clearShockEvent()` | 97 |
| `void popShockEvent(const QByteArray &ba)` | 98 |

**Includes:** `app/cigconfigs.h`, `<QObject>`, `<QFile>`, `<QMap>`, `<QVector>`, `<QByteArray>`, `<QQueue>`, `<QTimer>`

---

### canexpansion.cpp

**Includes:** `canexpansion.h`, `platform/canbus.h`, `app/globalconfigs.h`, `platform/seriallogger.h`, `platform/gnssreceiver.h`, `platform/powersupply.h`, `<QApplication>`, `<QTimer>`, `<QDateTime>`, `<QFile>`, `<QDebug>`, `<QDataStream>`

**`readCanFrame()` (line 128-160):**
- `static bool esc = false` — static local persists across all calls and reconnections; not reset on disconnect
- Buffer overflow protection at line 158 truncates `m_rx` to last 256 bytes — discards framing context, may corrupt reassembly

**`packetHandler()` (line 249-467):**
- `static quint16 sm = 0` and `static quint16 shocks_read = 0` — static locals persist across reconnections
- State machine is never reset when `setEnabled(false)` + `setEnabled(true)` cycle occurs
- Minimum size check `m_rx.size() < 3` (line 257) guards header; CMD_DIGIN_STATE* cases check `< 12` (lines 353, 369, 385, 401)
- CMD_SHOCK_PEEK checks `< 11` (line 440); `popShockEvent` independently checks `>= 8`
- Unknown CMD values fall through with no default case or logging

**`sendPacket()` (line 202-229):**
- `m_tx` truncated to last 256 bytes when exceeded — can silently discard partially-encoded SLIP packets

**`popShockEvent()` (line 608-665):**
- `m_gnssReceiver` null-check present at line 621 — safe
- `m_powerSupply` used without null-check at line 633

**`generateShockMessage()` (line 572-597):**
- Line 592: explicit `ts < m_shockTimestamp` time-wrap guard — partial mitigation

---

## Test Coverage Search Results

**Test directory:** `C:/Projects/cig-audit/repos/mark3-pvd/test/`

**Files present:**
- `test_backgroundworker.cpp` / `.h`
- `test_canbus.cpp` / `.h`
- `test_dialog.cpp` / `.h`
- `test_ota.cpp` / `.h`

**Grep results — all class names and every public method searched:**

| Search Term | Matches in test/ |
|-------------|------------------|
| `BleInputHandler` | 0 |
| `CanExpansion` | 0 |
| `updateIgnition` | 0 |
| `updateBleInput` | 0 |
| `changeBleState` | 0 |
| `updateIdleTimer` | 0 |
| `digitalInputs` | 0 |
| `readCanFrame` | 0 |
| `packetHandler` | 0 |
| `sendPacket` | 0 |
| `writeFrame` | 0 |
| `setRelayOutput` | 0 |
| `setRelayTimeout` | 0 |
| `setCurrentTime` | 0 |
| `setShockThreshold` | 0 |
| `setShockPeriod` | 0 |
| `generateShockMessage` | 0 |
| `clearShockEvent` | 0 |
| `popShockEvent` | 0 |
| `setGnssReceiver` | 0 |
| `setEnabled` | 0 |
| `isShockQueueEmpty` | 0 |
| `shockEvent` (method) | 0 |
| `BleExpansionDI` | 4 (only `qRegisterMetaType` boilerplate in unrelated tests) |

**Conclusion:** Zero test coverage. Neither `BleInputHandler` nor `CanExpansion` is instantiated, exercised, or referenced in any test. The `BleExpansionDI` meta-type registrations appear only as boilerplate for signal/slot cross-thread use in unrelated tests.

---

## Findings

---

**A07-1** · CRITICAL · Missing Test Coverage — Both Classes
**File:** `comm/bleinputhandler.cpp`, `comm/canexpansion.cpp`
**Description:** Neither `BleInputHandler` nor `CanExpansion` has any unit or integration test. Zero test files instantiate these classes, invoke any method, or assert any output or signal. These two classes are responsible for CAN bus communication, BLE expansion module state, shock event handling, relay control, and idle timeout — all safety-relevant and security-relevant subsystems. The complete absence of test coverage means no regression protection exists for any of this logic.
**Fix:** Create `test/test_ble_can_expansion.cpp` with a dedicated test class. Use mock or stub implementations of `CanBus`, `PowerSupply`, and `GnssReceiver`. Cover at minimum: constructor initialization state, all three `DigitalFormat` branches of `digitalInputs()`, `updateIgnition()` with all `PowerState` values, `updateBleInput()` for each of the four DI indices, `changeBleState()` connected/disconnected transitions, `generateShockMessage()` with and without a pending event, and `popShockEvent()` with valid and undersized payloads.

---

**A07-2** · HIGH · Uninitialized Member — `m_seenState`
**File:** `comm/bleinputhandler.h`:58, `comm/bleinputhandler.cpp`:7-23
**Description:** `m_seenState` is declared at line 58 and used in `onTimerEvent()` at line 85 as a state comparison (`if (m_seenState == newState) return;`), but it is never initialized in the constructor member-initialization list and is not set in `resetStates()`. The comparison with `m_bleInputs[2].state` (zero-initialized by `memset`) may produce an incorrect equality on the first timer fire, suppressing the first SeenSafe report that should be emitted.
**Fix:** Add `m_seenState(false)` to the constructor member-initialization list and add `m_seenState = false;` to `resetStates()`. Add a unit test asserting that the first `onTimerEvent()` invocation after a state change on input 3 always emits the `sendGmtpMessage` signal.

---

**A07-3** · HIGH · Out-of-Bounds Array Access — `updateBleInput()`
**File:** `comm/bleinputhandler.cpp`:117-119
**Description:** `index = input - CIGCONF::BleExpDI1` is computed without any bounds validation before it is used to index `m_bleInputs[4]` (a fixed-size four-element array). If the `CIGCONF::BleExpansionDI` enum value passed in is less than `BleExpDI1` or greater than `BleExpDI4`, the subtraction yields a negative signed result (silently cast to a large positive size on array access) or a value >= 4, causing undefined behavior. This value arrives from a CAN-frame-decoded signal in `CanExpansion::packetHandler()`, meaning a malformed incoming CAN frame can trigger this path.
**Fix:** Insert a bounds check immediately after computing `index`:
```cpp
if (index < 0 || index >= 4) {
    SerialLogger::log("[BLE:DIG] Invalid DI index\r\n");
    return;
}
```
Add a test case that calls `updateBleInput()` with an out-of-range enum value and verifies no crash and no state change occurs.

---

**A07-4** · HIGH · Static Local State Never Reset on Reconnection — `packetHandler()`
**File:** `comm/canexpansion.cpp`:251-252
**Description:** `static quint16 sm = 0` (state machine cursor) and `static quint16 shocks_read = 0` (shock read counter) are function-local statics that persist for the entire process lifetime. When the BLE expansion module disconnects and reconnects — whether via `setEnabled(false)/setEnabled(true)` or a `timeout()` re-initialisation cycle — these variables retain previous values. The handshake can resume from an arbitrary mid-sequence state, silently skipping the device-name → firmware-version → model-number chain, leaving version fields empty and relay/shock configuration unapplied.
**Fix:** Promote `sm` and `shocks_read` to member variables (`m_packetSm` and `m_shocksRead`) initialized to 0 in the constructor, and reset them in `setEnabled(false)` and at the start of `initialise()`. Add integration tests simulating a disconnect/reconnect cycle and verifying the full handshake re-executes.

---

**A07-5** · HIGH · Static Local SLIP Escape Flag Never Reset on Reconnection — `readCanFrame()`
**File:** `comm/canexpansion.cpp`:130
**Description:** `static bool esc = false` persists across reconnection events. If the BLE expansion module disconnects mid-SLIP-escape sequence (after sending `SLIP_ESC` but before the continuation byte), `esc` remains `true`. On reconnection, the first byte of the new device-name response will be misinterpreted as an escape continuation, corrupting `m_rx` and causing `packetHandler()` to discard or misparse the response header.
**Fix:** Promote `esc` to a member variable `m_slipEsc` initialized to `false` in the constructor, and reset it in `setEnabled(false)`, `initialise()`, and wherever `m_rx` is cleared. Add a unit test that feeds a partial SLIP frame ending in `SLIP_ESC` followed by a valid complete frame after a simulated reconnect, and verifies the second frame is parsed correctly.

---

**A07-6** · MEDIUM · Silent Buffer Truncation Corrupts Protocol State — `readCanFrame()` and `sendPacket()`
**File:** `comm/canexpansion.cpp`:158-159, 225-226
**Description:** Both `m_rx` (receive) and `m_tx` (transmit) buffers are silently truncated to the last 256 bytes when they exceed `MAX_BUFFER_SIZE`. For `m_rx`, truncation discards the beginning of the accumulated SLIP frame, leaving a fragment that will fail the `packetHandler()` header check but still consume processing time with no log entry. For `m_tx`, truncation discards the oldest queued data, potentially cutting a SLIP-encoded CAN frame mid-stream. Neither path logs a warning or increments an error counter.
**Fix:** Log a `SerialLogger` warning when either buffer is truncated. For `m_rx`, clear the buffer entirely on overflow (partial frames are invalid anyway) rather than keeping an arbitrary suffix. For `m_tx`, evaluate whether the queue should be cleared entirely. Add test cases that inject more than 256 bytes into `readCanFrame()` and verify the buffer is handled deterministically.

---

**A07-7** · MEDIUM · Integer Overflow in Time Accumulation Fields — Backward Clock Not Guarded
**File:** `comm/bleinputhandler.cpp`:50, 65-66, 130-133, 135-136, 184-191, 263-287
**Description:** All delta computations (`delta = (clock - is.clock) / 100`) use unsigned arithmetic. If `gCfg->clockTime()` returns a value smaller than `is.clock` due to a clock synchronization event, NTP adjustment, or device restart without counter reset, the subtraction wraps around to a very large quint64, which after division by 100 still produces a huge quint32 delta, corrupting all accumulated time values. No guard is present in `BleInputHandler` — compare to the partial guard in `generateShockMessage()` at line 592 of `canexpansion.cpp`.
**Fix:** Add a backward-clock guard in all delta computations:
```cpp
quint32 delta = (clock >= is.clock) ? (quint32)((clock - is.clock) / 100) : 0;
```
Add unit tests with a simulated clock that goes backward and verify counters do not corrupt.

---

**A07-8** · MEDIUM · BLE Input Stats Silently Under-Counted When Disconnected — `digitalInputs()`
**File:** `comm/bleinputhandler.cpp`:274-288, 320-325
**Description:** When `m_bleConnected` is `false`, the time-accumulation loop for `m_bleInputs` breaks immediately at line 276, so the elapsed time since the last `digitalInputs()` call is not applied to the BLE input time fields. The formatting loop at lines 320-325 still emits the four BLE input entries with their stale (under-counted) `sessionOnTime`/`sessionOffTime` values. Callers requesting `SessionFormat` or `UsageFormat` data while the module is disconnected receive under-counted values proportional to the gap between the last `digitalInputs()` call and the disconnect event.
**Fix:** Document this behavior explicitly with a comment, or apply the remaining elapsed delta within `digitalInputs()` similarly to what `changeBleState()` does at disconnect time. Add a test that calls `digitalInputs()` after `changeBleState(false)` and verifies the returned byte array does not contain stale-gap values.

---

**A07-9** · MEDIUM · `m_powerSupply` Used Without Null Guard — `popShockEvent()`
**File:** `comm/canexpansion.cpp`:633
**Description:** `m_powerSupply->isIgnitionOn()` is called unconditionally at line 633. While the constructor requires a non-null `PowerSupply*`, there is no null guard at the call site, unlike `m_gnssReceiver` which is checked at line 621. If future refactoring or a test harness passes a null `ps`, this produces an immediate null-pointer dereference. The asymmetry with `m_gnssReceiver` indicates inconsistent null-safety convention.
**Fix:** Add a null guard: `if (m_powerSupply) event.isIgnitionOn = m_powerSupply->isIgnitionOn();` — or enforce non-null via `Q_ASSERT(ps)` in the constructor. Add a unit test with a null `PowerSupply` stub verifying no crash occurs.

---

**A07-10** · MEDIUM · SLIP Framing Edge Cases Untested — `readCanFrame()`
**File:** `comm/canexpansion.cpp`:128-160
**Description:** The SLIP decoder has several untested edge cases: (1) back-to-back `SLIP_END` bytes (zero-length payload) — the `m_rx.size() > 0` guard at line 146 correctly skips dispatch but is untested; (2) `SLIP_ESC` split across two `readCanFrame()` calls at the 8-byte CAN frame boundary — the static `esc` persists correctly but this cross-call behavior has no test; (3) `SLIP_ESC` followed by a byte that is neither `SLIP_ESC_ESC` nor `SLIP_ESC_END` — the current code falls into neither branch in lines 137-142 but still appends `b` to `m_rx` unmodified via the `else` on line 153, silently corrupting the decoded payload.
**Fix:** Add tests for: (a) zero-length SLIP frames, (b) `SLIP_ESC` split across two calls, and (c) `SLIP_ESC` followed by an invalid continuation byte. For case (c), log an error and reset escape state without appending the invalid byte.

---

**A07-11** · MEDIUM · `shocks_read` Counter Can Stall Shock Queue Drainage
**File:** `comm/canexpansion.cpp`:423-432
**Description:** The static `shocks_read` counter (see also A07-4) is only reset when `count == 0` or `shocks_read >= 3`, limiting peek/pop cycles to three per `timeout()` interval. If the firmware shock queue contains more than three events and the counter is not reset between reconnections, remaining shock events are never dequeued until the next disconnect/reconnect cycle. The queue silently stalls, and unprocessed shock events may be lost when the firmware discards them.
**Fix:** As part of the A07-4 fix, ensure `m_shocksRead` is reset to 0 both on reconnection and whenever `sm` transitions back to `CMD_DIGIN_STATE0`. Add a test that simulates a `CMD_SHOCK_COUNT` response indicating 5 pending shocks and verifies all are eventually dequeued across multiple timer cycles.

---

**A07-12** · LOW · `OnDemandFormat` Returns Only Ignition Data — Undocumented
**File:** `comm/bleinputhandler.cpp`:290-296
**Description:** The `OnDemandFormat` branch returns a single string containing only `m_ignition.sessionOnTime` and exits immediately. BLE input data is not included. There is no documentation at the method declaration, the enum definition, or the branch itself to communicate this restriction. A caller requesting `OnDemandFormat` while expecting a full digital input report will silently receive an incomplete result.
**Fix:** Add a comment block above `digitalInputs()` documenting that `OnDemandFormat` returns only ignition data. Consider whether BLE DI data should be included. Add a test asserting the format and field count of each of the three `DigitalFormat` variant outputs.

---

**A07-13** · LOW · Integer Overflow in Inactive Notification Duration — `timeout()`
**File:** `comm/canexpansion.cpp`:187-190
**Description:** At line 188, `m_inactiveCount * TIMER / 1000` computes the inactive duration in seconds. `m_inactiveCount` is `quint32` and `TIMER` is a plain `int` literal (2000). The intermediate product `m_inactiveCount * TIMER` is evaluated as a 32-bit multiplication before the division, and can overflow when `m_inactiveCount` exceeds approximately 2,147,483 (roughly 49 days of 500 ms timer ticks). The overflow produces a truncated or negative duration value passed to `inactiveNotification()`.
**Fix:** Cast before multiplication: `(quint64)m_inactiveCount * TIMER / 1000` and update the signal parameter type if necessary, or cap `m_inactiveCount` at a reasonable maximum. Add a test with a large inactive count value verifying the emitted duration is correct.

---

## Summary Table

| ID | Severity | Category | File | Line | Tested? |
|----|----------|----------|------|------|---------|
| A07-1 | CRITICAL | Missing Test Coverage | bleinputhandler.cpp, canexpansion.cpp | — | No — zero coverage |
| A07-2 | HIGH | Uninitialized Member | bleinputhandler.h:58, bleinputhandler.cpp:7 | 58 / 7 | No |
| A07-3 | HIGH | Out-of-Bounds Array Access | bleinputhandler.cpp | 117 | No |
| A07-4 | HIGH | Static State Not Reset on Reconnect | canexpansion.cpp | 251 | No |
| A07-5 | HIGH | Static SLIP Escape Flag Not Reset | canexpansion.cpp | 130 | No |
| A07-6 | MEDIUM | Silent Buffer Truncation | canexpansion.cpp | 158, 225 | No |
| A07-7 | MEDIUM | Backward Clock Overwrites Accumulators | bleinputhandler.cpp | 50, 65, 130, 184 | No |
| A07-8 | MEDIUM | BLE Stats Under-Counted When Disconnected | bleinputhandler.cpp | 274 | No |
| A07-9 | MEDIUM | Null Dereference Risk — m_powerSupply | canexpansion.cpp | 633 | No |
| A07-10 | MEDIUM | SLIP Framing Edge Cases Untested | canexpansion.cpp | 128 | No |
| A07-11 | MEDIUM | Shock Queue Stalls After 3 Events Per Cycle | canexpansion.cpp | 423 | No |
| A07-12 | LOW | OnDemandFormat Undocumented Partial Return | bleinputhandler.cpp | 290 | No |
| A07-13 | LOW | Inactive Duration Multiplication Overflow | canexpansion.cpp | 187 | No |

**Total findings:** 13 (1 Critical, 4 High, 6 Medium, 2 Low)

**Overall coverage verdict:** ZERO. No test file references either class. No method, signal, or edge case has any automated test.
