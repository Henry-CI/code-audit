# Pass 2 Audit — Test Coverage — A26
**Repository:** mark3-pvd
**Branch:** master (confirmed — `git branch --show-current` returned `master`)
**Auditor:** A26
**Audit Run:** 2026-02-28-01
**Pass:** 2 (Test Coverage)
**Date:** 2026-02-28
**Status:** COMPLETE — all assigned files read; test directory fully searched

---

## Assigned Files

| File | Role |
|---|---|
| `ui/warningdialog.cpp` | WarningDialog implementation |
| `ui/warningdialog.h` | WarningDialog header |
| `utils/barcode128.cpp` | Barcode128 / BarcodeChar implementation |
| `utils/barcode128.h` | Barcode128 / BarcodeChar header |
| `utils/bytearray.h` | ByteArray header-only utility class |
| `utils/logger.cpp` | Logger singleton implementation |
| `utils/logger.h` | Logger header |
| `utils/zconf.h` | Third-party zlib configuration header (v1.3.1) |
| `utils/zlib.h` | Third-party zlib public API header (v1.3.1) |

---

## Reading Evidence

### `ui/warningdialog.h` — Class and Public Interface

**Class:** `WarningDialog` — inherits `QDialog`

**Enum defined at file scope:**
- `WarningDialogType { VOR, Transport, Maintenance }` — line 10

**Public methods:**
- `explicit WarningDialog(WarningDialogType type, QWidget *parent = 0)` — line 17 (constructor)
- `~WarningDialog()` — line 18 (destructor)

**Protected methods (event overrides):**
- `void hideEvent(QHideEvent *)` — line 29
- `void showEvent(QShowEvent *event = 0)` — line 30

**Private methods (internal HTML builders):**
- `QString showVorWarning()` — line 24
- `QString showTransportWarning()` — line 25
- `QString showMaintenanceWarning()` — line 26

**Private members:**
- `Ui::WarningDialog *ui` — line 21
- `QTimer *m_timer` — line 22
- `WarningDialogType m_type` — line 23

---

### `ui/warningdialog.cpp` — Implementation

- Constructor (lines 5–16): wires `btnACK` clicked → `accept()`, timer `timeout` → `reject()`, sets timer single-shot.
- `showEvent` (lines 18–45): dispatches to one of three private HTML-builder methods based on `m_type`, sets `textEdit` HTML, starts 45-second auto-close timer.
- `showTransportWarning` (lines 47–82): builds and returns HTML string for Transport warning (three paragraphs).
- `showVorWarning` (lines 84–118): builds and returns HTML string for VOR warning.
- `showMaintenanceWarning` (lines 120–154): builds and returns HTML string for Maintenance warning.
- `hideEvent` (lines 156–159): stops the timer.
- Destructor (lines 161–164): deletes `ui`.

No WarningDialog constructor is invoked from Dialog::Dialog() in `ui/dialog.cpp`. The production code instead uses a `VORWarningDialog` (line 75 of dialog.cpp). `WarningDialog` has no visible instantiation in the tested dialog infrastructure.

---

### `utils/barcode128.h` — Classes and Public Interface

**Class `BarcodeChar`:**
- Default constructor (line 10–15): initialises to INVALID sentinel
- Copy constructor (line 17–22)
- Parameterised constructor `BarcodeChar(int value, QString name, QString pattern)` (line 24–29)
- `operator=` (line 31–37)
- Private members: `m_value`, `m_name`, `m_pattern` (lines 40–42); `friend class Barcode128`

**Class `Barcode128`:**
- Public:
  - `Barcode128(const QString &info, int height = 100, int sizeMult = 2)` — line 50 (constructor)
  - `~Barcode128()` — line 51
  - `static int width(const QString &info, int sizeMult)` — line 52
  - `QPixmap pixmap()` — line 54
- Private methods: `initChar`, `initChars`, `encodeChar`, `drawBlackVerticalLineAtPos`, `drawEmptyVerticalLineAtPos`
- Private members: `m_valueToChar` (QMap<int, BarcodeChar>), `m_nameToChar` (QMap<QString, BarcodeChar>), `m_image` (QImage*), `m_pos` (int), `m_sizeMult` (int)

---

### `utils/barcode128.cpp` — Implementation

**Preprocessor constants:**
- `#define START_CODE 104` — line 5 (Code B — upper/lower case + digits; active branch)
- `#define END_CODE 106` — line 6
- `#define MODULO_VAL 103` — line 7

**Constructor** (lines 9–37):
- Allocates QImage of size `width(info, sizeMult)` × `height` (line 16)
- Draws 15 leading quiet-zone pixels (lines 18–19)
- Encodes START_CODE (104), iterates characters, accumulates weighted checksum, encodes checksum and STOP code (lines 21–33)
- Draws 15 trailing quiet-zone pixels (lines 35–36)

**`width()` static method** (lines 320–323):
- Returns `(info.length() * 11 + 13 + 11 + 11) * sizeMult + 30`
- Note: formula counts start+stop+checksum patterns (35 modules) plus data (11 modules/char) plus 30 pixels of quiet zone.

**`initChars()`** (lines 61–281):
- Active branch: `#elif START_CODE == 104` — initialises Code B character table (values 0–106), covering ASCII 0x20–0x7E plus special function/control codes.
- Duplicate name keys for value 12 and value 16 (both mapped to "0") — only the second `insert` for name "0" will survive in `m_nameToChar`. This means character with barcode value 12 (pattern "10110011100") is unreachable by name lookup.

**`encodeChar()`** (lines 283–296): iterates pattern string, draws black or white vertical lines per pixel.

**`drawBlackVerticalLineAtPos()` / `drawEmptyVerticalLineAtPos()`** (lines 298–318): bounds-check `m_pos` before writing, increment `m_pos`.

---

### `utils/bytearray.h` — Class and Methods

**Class `ByteArray`:** header-only static utility class.

**Macros defined:**
- `LE_INT(c1,c2,c3,c4)` — line 6: little-endian 32-bit assembly
- `BE_INT(c1,c2,c3,c4)` — line 7: big-endian 32-bit assembly
- `LE_SHORT(c1,c2)` — line 8: little-endian 16-bit assembly
- `BE_SHORT(c1,c2)` — line 9: big-endian 16-bit assembly
- `BE_LONG(c1,c2,c3,c4,c5,c6,c7,c8)` — line 11: big-endian 64-bit assembly

**Public static methods:**
- `static QByteArray asprintf(const char *cformat, ...)` — lines 16–27
- `static int sscanf(const QByteArray &ba, const char *cformat, ...)` — lines 30–37

**Critical defect in `asprintf` (confirmed from Pass 1):**
- Line 19: `va_start(ap, cformat)` — opens va_list
- Line 20: `size = vsnprintf(nullptr, 0, cformat, ap)` — consumes va_list to measure size
- Line 21: `va_end(ap)` — closes and invalidates va_list
- Line 24: `ba.resize(size)` — note: does NOT add 1 for NUL terminator; `vsnprintf` returns count excluding NUL, so `vsprintf` at line 25 will write one byte past the end of the QByteArray buffer
- Line 25: `vsprintf(ba.data(), cformat, ap)` — **CRITICAL**: `ap` was already consumed and closed; reusing it after `va_end` is undefined behaviour per C99/C++11 §7.15/§18.10. Additionally, `vsprintf` writes NUL to `ba.data()[size]`, one byte past the allocated buffer.

---

### `utils/logger.h` and `utils/logger.cpp` — Summary (Cross-reference from Pass 1)

**Class `Logger`:** singleton, no Q_OBJECT.

**Enum:** `LogLevel { LogDebug, LogInfo, LogWarning, LogCritical, LogFatal, LogNone }` — logger.h:8

**Public methods:**
- `static Logger* instance()` — logger.h:13 / logger.cpp:54
- `void close()` — logger.h:14 / logger.cpp:62
- `void setLogThreshold(LogLevel level)` — logger.h:15 / logger.cpp:70
- `LogLevel logThreshold() const` — logger.h:16 / logger.cpp:75
- `void log(LogLevel level, const QString &message)` — logger.h:17 / logger.cpp:80

**Protected:**
- `Logger()` — logger.h:20 / logger.cpp:13
- `virtual ~Logger()` — logger.h:21 / logger.cpp:46
- `static void logMessageHandler(...)` — logger.h:22 / logger.cpp:117

---

### `utils/zconf.h` and `utils/zlib.h` — Third-Party Headers

Both are the zlib 1.3.1 distribution headers (released 2024-01-22). No project-written code is present. They are included by `app/backgroundworker.cpp` (line 37: `#include "utils/zlib.h"`) which uses `inflate` / `inflateInit` / `inflateEnd` for OTA firmware decompression (the `streamUncompress` function, backgroundworker.cpp lines 49–123).

---

## Test File Survey

**Primary test files examined:**
- `test/test_dialog.cpp` + `test/test_dialog.h` — 684 lines
- `test/test_backgroundworker.cpp` + `test/test_backgroundworker.h`
- `test/test_canbus.cpp` + `test/test_canbus.h`
- `test/test_ota.cpp` + `test/test_ota.h`

**Grep results for assigned classes/symbols in `test/`:**

| Symbol | Matches in test/ |
|---|---|
| `Barcode128`, `barcode128`, `BarcodeChar` | **0** |
| `ByteArray`, `bytearray`, `asprintf`, `sscanf`, `LE_INT`, `BE_INT`, `LE_SHORT`, `BE_SHORT`, `BE_LONG` | **0** |
| `Logger`, `logger`, `LogLevel`, `LogDebug`, `LogInfo`, `LogWarning`, `LogCritical`, `LogFatal` | **0** |
| `WarningDialog`, `warningdialog` | **0** |

**QByteArray** (Qt class, not ByteArray) appears extensively in test files as signal spy argument comparisons — these are unrelated to `utils/bytearray.h`.

**Zlib / inflate / compress** in test files: `test/test_ota.cpp` line 65 comment mentions "compressed file"; the `TestOta::test_unpack()` test calls `m_worker->updateSelf()` which exercises the `streamUncompress` inflate path in backgroundworker.cpp. This provides indirect, integration-level coverage of the zlib inflate API.

---

## Findings

**A26-N1** · CRITICAL · Missing Test Coverage — ByteArray::asprintf Undefined Behaviour
**File:** `utils/bytearray.h:25`
**Description:** Pass 1 identified two compounding defects in `ByteArray::asprintf`: (1) `va_list ap` is consumed by `vsnprintf` on line 20, then closed by `va_end` on line 21, then passed to `vsprintf` on line 25 — reusing a va_list after `va_end` is undefined behaviour per the C++ standard; (2) `ba.resize(size)` allocates exactly `size` bytes but `vsprintf` writes `size+1` bytes (including the NUL terminator), causing a one-byte heap buffer overwrite. No test in `test/` exercises `ByteArray::asprintf` at all. Because `asprintf` is a variadic function with undefined behaviour triggered on every call, only a test that calls the function with a format string and arguments would expose the crash or memory corruption. The complete absence of any test means this critical defect has never been caught by the test suite, is invisible to CI, and remains latent in production code that calls it (e.g. `platform/gnssreceiver.cpp` lines 178, 187, 238, 260, 303, 320, 411).
**Fix:** Add unit tests that call `ByteArray::asprintf` with representative format strings and verify the returned `QByteArray` content and length. After adding tests and observing the failure, fix the implementation: (a) use a second `va_start`/`va_end` pair for the `vsprintf` call, and (b) resize the buffer to `size + 1` and then trim the trailing NUL with `ba.resize(size)` after the `vsprintf`.

---

**A26-N2** · HIGH · No Tests for Barcode128 Encoding Correctness
**File:** `utils/barcode128.cpp:9`
**Description:** The `Barcode128` class encodes strings as Code 128 barcodes and is used in the production application (via `ui/informationdialog.cpp`). The encoding process — character lookup, checksum accumulation, pixel drawing — has zero test coverage. There are no known-value tests verifying that a given input string produces the correct barcode pixel pattern, no test for an empty string input, no test for the maximum practical input length, and no test for characters outside the Code B character set. An encoding error in the checksum logic (e.g. the weighted modulo-103 calculation) or in the character lookup (e.g. the duplicate "0" key mapping that silently discards value 12) would go undetected. In a safety-critical fleet management system where barcodes may be used for driver identification or asset tracking, a silently wrong barcode is a functional correctness defect.
**Fix:** Add a test class (e.g. `TestBarcode128`) that: (a) constructs `Barcode128` with a known string, extracts the QPixmap/QImage, and verifies specific pixel columns correspond to the expected bar pattern for the START, data characters, checksum, and STOP codes; (b) tests with an empty string; (c) tests with a string containing a character whose Code B value produces a known checksum; (d) tests `Barcode128::width()` static method output against the formula for a known input length.

---

**A26-N3** · HIGH · No Tests for Barcode128 Empty String / Boundary Inputs
**File:** `utils/barcode128.cpp:16`
**Description:** When `info` is an empty string, `width(info, sizeMult)` returns `(0 * 11 + 13 + 11 + 11) * sizeMult + 30 = 35 * sizeMult + 30` pixels, which is positive, so a QImage is allocated and only the start code, a zero-value checksum (START_CODE % MODULO_VAL = 104 % 103 = 1), and STOP code are encoded. This has never been tested. When `info` contains a character not present in the Code B table, `m_nameToChar[QString(qc)]` returns a default-constructed `BarcodeChar` with pattern `"1111111"` (7 chars) instead of the standard 11-char pattern. The constructor then draws only 7 pixels for that character instead of 11, causing every subsequent character, checksum, and stop code to be drawn at the wrong horizontal position. This produces a barcode that cannot be decoded by any reader — silently. No test exercises non-ASCII or unmapped input characters.
**Fix:** Add tests for: (a) empty string input — verify pixmap dimensions and that no crash occurs; (b) a character not in the Code B table (e.g. a Unicode character or ASCII DEL) — verify the resulting pixmap has a deterministic width and that the function does not crash or overwrite memory.

---

**A26-N4** · HIGH · No Tests for Logger — Any Method
**File:** `utils/logger.cpp:80`
**Description:** `Logger::instance()`, `Logger::log()`, `Logger::setLogThreshold()`, `Logger::logThreshold()`, and `Logger::close()` have zero test coverage. Specifically: (a) log level filtering — the guard `if (level < m_logThreshold) return` at line 87 is never tested to confirm that messages below the threshold are suppressed; (b) log writes — no test verifies that calling `log()` with a valid level actually writes a line to the output file; (c) null/empty message — `log()` is never called with an empty `QString` to confirm no crash or spurious output; (d) very long message — no test verifies behaviour when `msg` is thousands of characters long; (e) `logMessageHandler` — the Qt message handler integration (qDebug/qWarning passthrough) is untested. The Logger is used in production by at least 15 source files (comm/, platform/, app/ layers). If the threshold filter is inverted or the stream flush is missing, log data would silently disappear.
**Fix:** Add a `TestLogger` test class that: (a) instantiates a Logger writing to a known temporary file path; (b) verifies that `log(LogDebug, "msg")` with threshold `LogDebug` writes the message; (c) verifies that `log(LogDebug, "msg")` with threshold `LogWarning` does not write the message; (d) verifies that `log()` with an empty string does not crash; (e) verifies that `logThreshold()` returns the value set by `setLogThreshold()`; (f) verifies that `close()` and re-instantiation via `instance()` work correctly.

---

**A26-N5** · MEDIUM · No Tests for WarningDialog
**File:** `ui/warningdialog.cpp:5`
**Description:** `WarningDialog` is a safety-critical UI component: it displays mandatory warnings for Transport, VOR (Vehicle Off Road), and Maintenance operating modes — modes where "UNAUTHORISED OPERATION MAY LEAD TO SERIOUS INJURY" is displayed. The dialog has a 45-second auto-close timer (`m_timer->start(45000)` at line 43). None of the following are tested: (a) that the correct HTML body is shown for each `WarningDialogType`; (b) that the ACK button triggers `accept()`; (c) that the timer fires after ~45 seconds and triggers `reject()`; (d) that `hideEvent` stops the timer (preventing spurious rejection after hide); (e) that the `WarningDialogType` enum values `VOR`, `Transport`, and `Maintenance` map to the correct text bodies. `test/test_dialog.cpp` does not include `warningdialog.h` and does not create any `WarningDialog` instance. Note: `ui/dialog.cpp` uses a `VORWarningDialog` (a distinct class), not `WarningDialog` directly — so integration tests of `Dialog` do not exercise `WarningDialog` either.
**Fix:** Add test cases to `test/test_dialog.cpp` (or a dedicated `TestWarningDialog` class) that: (a) construct `WarningDialog(Transport)` and verify `showEvent` sets the text edit to HTML containing the transport warning text; (b) construct `WarningDialog(VOR)` and verify VOR warning text; (c) construct `WarningDialog(Maintenance)` and verify maintenance warning text; (d) simulate the ACK button click and verify `accepted()` signal is emitted; (e) verify that the timer causes automatic rejection after the timeout period (using QSignalSpy on `rejected()`).

---

**A26-N6** · MEDIUM · ByteArray::sscanf va_list Reuse After va_end
**File:** `utils/bytearray.h:34`
**Description:** `ByteArray::sscanf` has the same structural defect as `asprintf` in the va_list lifecycle, though less severe: `va_start(ap, cformat)` at line 33, `vsscanf(ba.constData(), cformat, ap)` at line 34, `va_end(ap)` at line 35. In this case the single `vsscanf` call does consume `ap` only once, so there is no double-use UB. However, the function is not tested at all. A test is needed to confirm correct field parsing and to serve as a regression baseline if the implementation is ever modified.
**Fix:** Add tests that call `ByteArray::sscanf` with a known `QByteArray` and format string, verify the number of fields parsed, and verify the values of the parsed output variables.

---

**A26-N7** · LOW · Zlib Inflate Path Has Only Integration-Level Coverage
**File:** `app/backgroundworker.cpp:49` (uses `utils/zlib.h`)
**Description:** The zlib inflate path (`streamUncompress` in backgroundworker.cpp) is exercised only through `TestOta::test_unpack()`, which is a full end-to-end test that writes a real compressed firmware binary to `/mnt/sd/FleetIQ360App`, calls `m_worker->updateSelf()`, waits for an OTA worker thread, and checks for the existence of `/home/FleetFocusOTA` and its MD5 hash. While this test does cover the happy path (Test 1) and a truncated/corrupted file (Test 2), it provides no unit-level coverage of the inflate stream logic itself: there are no tests for: (a) a stream that requires multiple inflate calls to complete (chunked input); (b) a stream with the Z_DATA_ERROR or Z_MEM_ERROR error codes; (c) the Qt 4-byte header skip logic at lines 79–85 of backgroundworker.cpp. The tests are also environment-dependent (require `/mnt/sd` mount point and `/home/` path), making them unlikely to run in CI on a development host.
**Fix:** Extract `streamUncompress` into a testable free function or a class method. Add unit tests that supply small, synthetically constructed zlib-compressed buffers directly to the function and verify the output, independently of the filesystem and the OTA worker thread.

---

## Summary Table

| ID | Severity | Category | File | Issue |
|---|---|---|---|---|
| A26-N1 | CRITICAL | Missing Test — UB Coverage | `utils/bytearray.h:25` | `ByteArray::asprintf` va_list UB + heap overflow never tested |
| A26-N2 | HIGH | Missing Test — Correctness | `utils/barcode128.cpp:9` | No known-value encoding tests for Barcode128 |
| A26-N3 | HIGH | Missing Test — Boundary | `utils/barcode128.cpp:16` | No empty string or unmapped character tests for Barcode128 |
| A26-N4 | HIGH | Missing Test — Logger | `utils/logger.cpp:80` | Logger: zero test coverage for any method |
| A26-N5 | MEDIUM | Missing Test — Safety UI | `ui/warningdialog.cpp:5` | WarningDialog: zero test coverage; safety-critical component untested |
| A26-N6 | MEDIUM | Missing Test — ByteArray | `utils/bytearray.h:34` | `ByteArray::sscanf` entirely untested |
| A26-N7 | LOW | Partial Test — Zlib | `app/backgroundworker.cpp:49` | Zlib inflate covered only by environment-dependent OTA integration test |

---

## Coverage Summary by Component

| Component | Test Coverage | Notes |
|---|---|---|
| `WarningDialog` | **None** | Not referenced in any test file; not exercised indirectly via Dialog tests |
| `Barcode128` / `BarcodeChar` | **None** | No reference in any test file |
| `ByteArray::asprintf` | **None** | Called in production (15+ call sites); never tested; contains CRITICAL UB |
| `ByteArray::sscanf` | **None** | No test coverage |
| `ByteArray` macros (`LE_INT`, etc.) | **None** | No test coverage |
| `Logger::log` | **None** | No test coverage |
| `Logger::setLogThreshold` | **None** | No test coverage |
| `Logger::logThreshold` | **None** | No test coverage |
| `Logger::instance` | **None** | No test coverage |
| `Logger::close` | **None** | No test coverage |
| `Logger::logMessageHandler` | **None** | No test coverage |
| `zlib` inflate (via backgroundworker) | **Partial** | Integration test in `test_ota.cpp`; no unit-level coverage |
