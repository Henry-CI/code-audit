# Audit Report — Agent A13 — Pass 2: Test Coverage
**Audit Run:** 2026-02-28-01
**Agent:** A13
**Pass:** 2 — Test Coverage
**Date:** 2026-02-28

---

## 1. Branch Confirmation

```
Branch verified: master
Command: git branch --show-current → "master"
```

---

## 2. Assigned Files

| # | Source File | Header File |
|---|-------------|-------------|
| 1 | `platform/canbus.cpp` | `platform/canbus.h` |
| 2 | `platform/gnssreceiver.cpp` | `platform/gnssreceiver.h` |

---

## 3. Reading Evidence

### 3.1 `platform/canbus.h` — Includes

| Line | Include |
|------|---------|
| 4 | `<QObject>` |
| 5 | `<QCanBusDevice>` |
| 6 | `<QCanBusFrame>` |
| 7 | `<QQueue>` |
| 8 | `<QTimer>` |

### 3.2 `platform/canbus.cpp` — Includes

| Line | Include |
|------|---------|
| 1 | `"canbus.h"` |
| 2 | `"platform/seriallogger.h"` |
| 3 | `<QCanBus>` |
| 4 | `<QMetaObject>` |
| 5 | `<QProcess>` |
| 6 | `<QTimerEvent>` |
| 7 | `<QTimer>` |
| 8 | `<QDebug>` |
| 9 | `<QFile>` |
| 10 | `<QDateTime>` |

### 3.3 `EM070::CanBus` — Public Methods

| Line (header) | Signature | Type |
|---------------|-----------|------|
| 25 | `CanBus(CanDeviceId id = CAN1, QObject *parent = nullptr)` | Constructor |
| 28 | `~CanBus()` | Destructor |
| 30 | `void initialize()` | Public method |
| 32 | `void setXferEnabled(bool enable)` | Public method |
| 33 | `bool isXferEnabled() const` | Public method (inline) |
| 35 | `void setPower(bool on)` | Public method |
| 36 | `bool isEnabled() const` | Public method (inline) |
| 38 | `bool setBaudRate(int baudRate)` | Public method |
| 39 | `int baudRate() const` | Public method (inline) |
| 41 | `void addRequest(quint32 id, const QByteArray &ba, quint32 interval)` | Public method |
| 42 | `QList<Request> getRequests()` | Public method (inline) |
| 43 | `void clearRequests()` | Public method |
| 45 | `void addFilter(quint32 identifier)` | Public method |
| 46 | `void clearFilters()` | Public method |
| 47 | `void applyFilters()` | Public method |
| 49 | `void writeFrameDirect(quint32 id, const QByteArray &ba)` | Public method |
| 51 | `void removeRequests(quint32 id)` | Public method |

### 3.4 `EM070::CanBus` — Signals

| Line (header) | Signature |
|---------------|-----------|
| 54 | `void error(QCanBusDevice::CanBusError canBusError)` |
| 55 | `void read(quint32 identifier, const QByteArray &ba)` |

### 3.5 `EM070::CanBus` — Protected / Private Methods

| Line (cpp) | Signature | Visibility |
|------------|-----------|------------|
| 51 | `void sendRequest()` | Protected |
| 264 | `void readFrame()` | Private |
| 274 | `void handleError(QCanBusDevice::CanBusError error)` | Private |

---

### 3.6 `platform/gnssreceiver.h` — Includes

| Line | Include |
|------|---------|
| 4 | `"app/cigconfigs.h"` |
| 5 | `<QObject>` |
| 9 | `class QSerialPort` (forward declaration) |

### 3.7 `platform/gnssreceiver.cpp` — Includes

| Line | Include |
|------|---------|
| 1 | `"gnssreceiver.h"` |
| 2 | `"app/globalconfigs.h"` |
| 3 | `"platform/seriallogger.h"` |
| 4 | `<QFile>` |
| 5 | `<QSerialPort>` |
| 6 | `<QTimerEvent>` |
| 7 | `<QDebug>` |
| 8 | `<QtMath>` |
| 9 | `<math.h>` |

### 3.8 `EM070::GnssReceiver` — Public Methods

| Line (header) | Signature | Type |
|---------------|-----------|------|
| 17 | `GnssReceiver(QObject *parent = nullptr)` | Constructor |
| 18 | `void portStateChanged(bool open)` | Public method |
| 19 | `void reset()` | Public method |
| 20 | `void changeUpdateTime()` | Public method |
| 22 | `quint8 satelliteCount() const` | Public accessor (inline) |
| 23 | `qint32 latitude() const` | Public accessor (inline) |
| 24 | `qint32 longitude() const` | Public accessor (inline) |
| 25 | `qint32 lastLatitude() const` | Public accessor (inline) |
| 26 | `qint32 lastLongitude() const` | Public accessor (inline) |
| 27 | `qint16 speed() const` | Public accessor (inline) |
| 28 | `qint16 course() const` | Public accessor (inline) |
| 29 | `quint32 distance() const` | Public accessor (inline) |
| 30 | `quint32 sumOfDistance() const` | Public accessor (inline) |
| 31 | `quint32 altitude() const` | Public accessor (inline) |
| 32 | `bool locked() const` | Public accessor (inline) |
| 33 | `quint32 hpe() const` | Public accessor (inline) |
| 34 | `quint32 hdop() const` | Public accessor (inline) |
| 35 | `qint64 age()` | Public method |
| 36 | `quint8 warn() const` | Public accessor (inline) |
| 37 | `void setWarn(quint8 n)` | Public setter (inline) |
| 38 | `quint8 quality() const` | Public accessor (inline) |
| 39 | `void setQuality(quint8 n)` | Public setter (inline) |
| 40 | `quint16 markerCnt() const` | Public accessor (inline) |
| 41 | `void setMarkerCnt(quint16 n)` | Public setter (inline) |
| 42 | `quint32 pathLatitude(int n)` | Public method |
| 43 | `void setPathLatitude(int n, quint32 lat)` | Public method |
| 44 | `quint32 pathLongitude(int n)` | Public method |
| 45 | `void setPathLongitude(int n, quint32 lon)` | Public method |
| 46 | `void gpsDebugPrint()` | Public method |
| 47 | `bool inPoly2(const CIGCONF::gpsPosStruct *gpsPos, const CIGCONF::polygonStruct *polygon)` | Public method — **declared but NEVER DEFINED** |
| 48 | `bool pointInPolygon(int polyCorners, CIGCONF::position me, CIGCONF::position *points)` | Public method |
| 49 | `double degrees2radians(double degrees)` | Public method |

### 3.9 `EM070::GnssReceiver` — Signals

| Line (header) | Signature |
|---------------|-----------|
| 54 | `void sendGmtpMessage(CIGCONF::GmtpMessage msg, const QByteArray &extra = QByteArray())` |

### 3.10 `EM070::GnssReceiver` — Protected / Private Methods

| Line (cpp) | Signature | Visibility |
|------------|-----------|------------|
| 44 | `void timerEvent(QTimerEvent *)` | Protected override |
| 57 | `void readData()` | Private slot |
| 58 | `void parseData(const QByteArray &ba)` | Private |
| 59 | `void cumulateDistance()` | Private |
| 60 | `static quint32 calculateDistance(qint32, qint32, qint32, qint32)` | Private static |

---

## 4. Test File Survey

### 4.1 Primary CAN bus test file: `test/test_canbus.h` + `test/test_canbus.cpp`

The `TestCanbus` class contains exactly **one test slot**:

- `test_vdiMode()` — exercises `BackgroundWorker::initialiseCanbus1()`, `initialiseCanbus2()`, and `getRequests()` indirectly via the `CanMonitor` subsystem. It verifies that the VDI-mode hard-coded CAN rules produce the correct frame IDs and payloads in `m_canBus1->getRequests()`.

**Coverage via `test_vdiMode()`:**

| CanBus Method | Called in Test? | Notes |
|---------------|-----------------|-------|
| `CanBus()` constructor | Indirectly (via `initialiseCanbus1/2`) | Not directly tested |
| `initialize()` | Indirectly | No assertion on device-creation failure |
| `setXferEnabled()` | No | Never invoked in test |
| `isXferEnabled()` | No | Never asserted |
| `setPower()` | No | Never invoked in test |
| `isEnabled()` | No | Never asserted |
| `setBaudRate()` | No | Never invoked in test |
| `baudRate()` | No | Never asserted |
| `addRequest()` | No (called internally by `CanMonitor`) | Not tested directly |
| `getRequests()` | Yes | Asserted on frame ID and payload |
| `clearRequests()` | No | Not exercised directly |
| `addFilter()` | No | Not tested |
| `clearFilters()` | No | Not tested |
| `applyFilters()` | No | Not tested |
| `writeFrameDirect()` | No | Not tested |
| `removeRequests()` | No | Not tested |
| `sendRequest()` (protected) | No | Not triggered |
| `readFrame()` (private) | No | No frame injection |
| `handleError()` (private) | No | No error injection |
| Signal `error` | No | Never spied on |
| Signal `read` | No | Never spied on |

### 4.2 GnssReceiver test coverage

Grep search across the entire repository confirms: **no test file references `GnssReceiver`, `gnssreceiver`, `parseData`, `GPRMC`, `GPGGA`, or any NMEA-related term in a test context.** There are zero test cases for `GnssReceiver`.

---

## 5. Findings

---

**A13-01** · HIGH · Missing Test Coverage — CanBus Error Paths
**File:** `platform/canbus.cpp:274`
**Description:** `handleError()` emits the `error` signal and rate-limits its own logging using a 10-second cooldown (`m_lastReportedError`). No test exercises any `QCanBusDevice::CanBusError` variant — including `BusOffError`, `WriteError`, `ReadError`, or `ConnectionError`. The cooldown logic (which suppresses repeated error signals) is also untested, meaning a regression where the guard is inverted or the window is changed would go undetected. The `error` signal is never captured by a `QSignalSpy` anywhere in the test suite.
**Fix:** Add unit tests that inject `QCanBusDevice::CanBusError` values via a mock or stub `QCanBusDevice`. Assert (a) that the `error` signal fires once on first error, (b) that a second error within 10 seconds does not emit a second signal, and (c) that an error after >10 seconds does re-emit. Cover at least `BusOffError`, `WriteError`, and `ConnectionError`.

---

**A13-02** · HIGH · Missing Test Coverage — CanBus Socket / Device Initialization Failure
**File:** `platform/canbus.cpp:34`
**Description:** `initialize()` calls `QCanBus::instance()->createDevice(...)`. On failure it logs a critical message and returns silently, leaving `m_canBusDevice` as `nullptr`. All subsequent methods guard against `nullptr` (`sendRequest`, `applyFilters`, `writeFrameDirect`, etc.), but none of this failure-path behavior is tested. In particular, the interaction between a `nullptr` device and `setXferEnabled(true)` or `addRequest()` being called subsequently is untested.
**Fix:** Stub or mock `QCanBus::instance()` to simulate a creation failure. Assert that `initialize()` does not crash, that the device remains `nullptr`, and that subsequently calling `setXferEnabled(true)` and `writeFrameDirect()` does not crash or produce unexpected behaviour.

---

**A13-03** · HIGH · Zero Test Coverage — GnssReceiver (Entire Class)
**File:** `platform/gnssreceiver.cpp`, `platform/gnssreceiver.h`
**Description:** There are no test files, no test cases, and no test references to `GnssReceiver` anywhere in the repository. The class implements NMEA sentence parsing, fix-validity state management, cumulative distance tracking, geofence evaluation, and path waypoint storage — all safety- and location-relevant logic. Not a single line is covered by automated tests.
**Fix:** Create a dedicated test file (`test/test_gnssreceiver.cpp`). At minimum, write tests for: (a) valid `GPRMC` sentence parsing — verify latitude/longitude/speed/course fields, (b) valid `GPGGA` sentence parsing — verify satellite count, quality, HDOP, altitude fields, (c) fix-lost scenario — send `GPRMC` with validity field `'V'` and assert `locked()` becomes false, (d) fix-gained scenario — send a sequence of `GPGGA` then `GPRMC` with valid data and assert `locked()` becomes true, (e) checksum/malformed sentence — send truncated or invalid sentences and assert no crash and no state mutation, (f) zero-satellite / high-HDOP inhibit — assert that `m_locked` is forced false when `m_satelliteCount == 0` or `m_hdop >= 5000`.

---

**A13-04** · HIGH · NMEA Checksum Not Validated — No Test Possible Until Code Is Added
**File:** `platform/gnssreceiver.cpp:101`
**Description:** `parseData()` splits the raw NMEA byte array by comma and immediately trusts the field values. Standard NMEA 0183 sentences include a `*HH` checksum suffix at the end of the last field; this implementation performs no checksum extraction or verification. Corrupted serial data (bit errors, serial port framing errors, partial DMA reads) will silently produce wrong latitude/longitude/speed values that propagate into distance accumulation and geofence evaluations. Because there is no checksum validation, a test for "checksum failure is rejected" cannot be written without first adding the validation logic.
**Fix:** Before splitting on commas, extract and validate the XOR checksum from the `*HH` suffix. If the checksum does not match, discard the sentence. Then add a test that supplies a sentence with an intentionally wrong checksum and asserts that no state fields change.

---

**A13-05** · MEDIUM · Missing Test Coverage — `parseData()` Buffer Handling and `readData()` Fragmentation
**File:** `platform/gnssreceiver.cpp:72`
**Description:** `readData()` implements a custom state machine that accumulates NMEA sentence bytes across multiple serial reads using `m_receiver` as a carry buffer. The logic for handling a `'$'` mid-buffer (resetting `size` to 0), partial sentences split across two reads, and the `m_receiver.isEmpty()` branch versus the non-empty branch is complex and completely untested. A regression in this logic could cause sentences to be parsed from stale buffer contents or silently dropped.
**Fix:** Add unit tests that feed raw byte arrays in fragments to a testable variant of `readData()` (or expose `parseData()` for direct testing) and verify: (a) a sentence split at an arbitrary boundary is reassembled correctly, (b) a `'$'` that appears mid-stream discards the prior incomplete sentence, (c) back-to-back complete sentences in a single read are both parsed.

---

**A13-06** · MEDIUM · Missing Test Coverage — `calculateDistance()` Edge Cases
**File:** `platform/gnssreceiver.cpp:339`
**Description:** `calculateDistance()` is a simplified Haversine implementation that operates on fixed-point coordinates scaled by 10,000,000. It has three early-exit paths: returning `UINT_MAX` if `|dx| > 256,000,000` (>1000 km in x), returning `UINT_MAX` if `|dy| > 256,000,000` (>1000 km in y), and a calling-site check in `cumulateDistance()` rejecting distances > 1,000,000 m. The function is also used across the equator and across the anti-meridian. None of these conditions are tested, meaning the overflow-guard code paths and the anti-meridian wrap case have no test evidence of correctness.
**Fix:** Add parameterised unit tests: (a) two nearby points — assert expected distance within ±5%; (b) points separated by more than 1000 km in longitude — assert `UINT_MAX` is returned; (c) points separated by more than 1000 km in latitude — assert `UINT_MAX` is returned; (d) coordinates that straddle the equator; (e) verify that `cumulateDistance()` drops the computed value when it exceeds the 1,000 km guard.

---

**A13-07** · MEDIUM · Missing Test Coverage — `inPoly2()` Declared But Never Defined
**File:** `platform/gnssreceiver.h:47`
**Description:** `bool inPoly2(const CIGCONF::gpsPosStruct *gpsPos, const CIGCONF::polygonStruct *polygon)` is declared as a public method in the header but has no corresponding implementation anywhere in the repository (`grep` across all `.cpp` files confirms no definition). This is a dead or abandoned API. If any code path were to call it at runtime, it would produce an undefined symbol linker error (or, in a shared-library scenario, a runtime crash). The absence of tests means this dangling declaration has never been caught.
**Fix:** Either provide a correct implementation and test it, or remove the declaration from the header to prevent accidental future use.

---

**A13-08** · MEDIUM · Missing Test Coverage — `pointInPolygon()` Correctness
**File:** `platform/gnssreceiver.cpp:428`
**Description:** `pointInPolygon()` implements a ray-casting algorithm using radians-converted coordinates. Edge cases for this algorithm are well-known: a point exactly on an edge, a point at a vertex, a degenerate polygon (fewer than 3 corners), and a concave polygon can all produce incorrect results depending on the implementation. The algorithm uses `latrad` / `lonrad` fields but assumes they have been populated by the caller; there is no guard for uninitialised `points` entries. No tests exist for this method.
**Fix:** Add unit tests covering: (a) a point clearly inside a triangle, (b) a point clearly outside, (c) a point on the boundary edge, (d) a degenerate polygon with 0–2 corners, (e) a concave polygon where the ray-casting result is verified against a known reference.

---

**A13-09** · MEDIUM · Missing Test Coverage — `CanBus::applyFilters()` Extended-Frame Bit Stripping
**File:** `platform/canbus.cpp:224`
**Description:** `applyFilters()` inspects bit 29 of each filter identifier to determine whether to apply an extended-frame mask (`0x3ffff00`) or a base-frame mask (`0x3ff`). It also strips bit 29 from the `id` before writing to `filter.frameId`. This logic is not tested. An off-by-one in the bit position or an incorrect mask value would cause frames to be silently admitted or silently dropped on the bus.
**Fix:** Add tests that add a mix of standard (≤0x7FF) and extended (bit-29 set) identifiers, call `applyFilters()`, and inspect the resulting `QCanBusDevice` configuration parameter for correct `frameId`, `frameIdMask`, and `format` values. Also test the duplicate-suppression (`id == last`) path.

---

**A13-10** · MEDIUM · Missing Test Coverage — `CanBus::sendRequest()` Duplicate Suppression and Queue Draining
**File:** `platform/canbus.cpp:51`
**Description:** `sendRequest()` dequeues one frame per timer tick and re-enqueues periodic requests only when their countdown expires. It also contains a duplicate-suppression loop that prevents the same `(frameId, payload)` pair from being enqueued twice. None of this scheduling logic is tested: there is no test that starts the timer, verifies frame ordering, confirms that duplicate frames are suppressed, or confirms that a request with `interval == 0` is never enqueued.
**Fix:** Add tests that: (a) add two requests with different intervals and verify only the correct one is enqueued after each simulated tick, (b) add a request with `interval == 0` and verify it is never queued, (c) add the same `(id, payload)` twice rapidly and verify only one copy appears in the queue.

---

**A13-11** · LOW · Missing Test Coverage — `CanBus::setPower()` GPIO and Process Failure Paths
**File:** `platform/canbus.cpp:105`
**Description:** `setPower()` opens two GPIO sysfs files and spawns `ifconfig` / `ip link set` processes via `QProcess`. Failures to open the GPIO files are logged but execution continues (the `return` statements are commented out). The `ip link set` process timeout path logs a warning but also continues. None of these hardware-interaction failure paths are tested; the commented-out `return` statements suggest intentional silent continuation that has never been verified by test.
**Fix:** Stub filesystem and process interactions to simulate: (a) GPIO file open failure — assert that `m_powerOn` is still updated correctly and no crash occurs, (b) `ip link set` process timeout — assert the warning is emitted and the device connection attempt still proceeds.

---

**A13-12** · LOW · Missing Test Coverage — `GnssReceiver::portStateChanged()` Serial Port Open Failure
**File:** `platform/gnssreceiver.cpp:51`
**Description:** `portStateChanged(true)` calls `m_serialPort->open(QIODevice::ReadOnly)` and silently returns if it fails (`if (!m_serialPort->open(...)) return`). In the failure case, `m_timerId` is not started and `m_receiver` is not cleared, meaning the object remains in a partially-initialized state with no indication to the caller that the port failed to open. This path is not tested.
**Fix:** Add a test that simulates a serial port open failure and verifies: (a) no timer is started, (b) `m_receiver` is not cleared (state is preserved), (c) a subsequent call to `portStateChanged(false)` does not crash.

---

## 6. Summary Table

| ID | Severity | Category | File | Method / Area |
|----|----------|----------|------|---------------|
| A13-01 | HIGH | Missing Test — Error Path | `platform/canbus.cpp:274` | `handleError()` — no error injection, no signal spy |
| A13-02 | HIGH | Missing Test — Init Failure | `platform/canbus.cpp:34` | `initialize()` — device creation failure path |
| A13-03 | HIGH | Zero Test Coverage | `platform/gnssreceiver.cpp` / `.h` | Entire `GnssReceiver` class |
| A13-04 | HIGH | Missing Validation + Test | `platform/gnssreceiver.cpp:101` | `parseData()` — no NMEA checksum validation |
| A13-05 | MEDIUM | Missing Test — Logic | `platform/gnssreceiver.cpp:72` | `readData()` — fragmented input and carry buffer |
| A13-06 | MEDIUM | Missing Test — Edge Case | `platform/gnssreceiver.cpp:339` | `calculateDistance()` — overflow guards, anti-meridian |
| A13-07 | MEDIUM | Dangling Declaration | `platform/gnssreceiver.h:47` | `inPoly2()` declared, never defined |
| A13-08 | MEDIUM | Missing Test — Logic | `platform/gnssreceiver.cpp:428` | `pointInPolygon()` — boundary and edge cases |
| A13-09 | MEDIUM | Missing Test — Logic | `platform/canbus.cpp:224` | `applyFilters()` — extended-frame bit mask |
| A13-10 | MEDIUM | Missing Test — Logic | `platform/canbus.cpp:51` | `sendRequest()` — queue scheduling and duplicate suppression |
| A13-11 | LOW | Missing Test — Error Path | `platform/canbus.cpp:105` | `setPower()` — GPIO/process failure continuation |
| A13-12 | LOW | Missing Test — Error Path | `platform/gnssreceiver.cpp:51` | `portStateChanged()` — serial port open failure |

---

## 7. Overall Assessment

**CanBus (`platform/canbus.cpp`):** The single existing test (`test_vdiMode`) exercises `getRequests()` indirectly through the `CanMonitor` subsystem and verifies that VDI-mode configuration produces the expected frame structures. This covers approximately 10–15% of the class's logic. No direct-unit-level tests exist for any CanBus method. All error paths (bus-off, error-passive, write error, connection error, socket open failure, GPIO failure) are entirely untested.

**GnssReceiver (`platform/gnssreceiver.cpp`):** Test coverage is **0%**. The class processes raw NMEA serial data and maintains position, speed, course, distance, geofence state, and path waypoints — all of which are safety-relevant in a fleet vehicle telematics context. The complete absence of tests, combined with the missing NMEA checksum validation (A13-04) and the dangling `inPoly2()` declaration (A13-07), represent a significant quality and reliability risk.
