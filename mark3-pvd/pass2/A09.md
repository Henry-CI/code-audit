# Audit Report — Agent A09 — Pass 2: Test Coverage
**Audit run:** 2026-02-28-01
**Agent:** A09
**Branch confirmed:** master (verified via `git branch --show-current` → `master`)
**Date:** 2026-02-28

---

## Files Under Review

| File | Lines |
|------|-------|
| `comm/ftpclient.h` | 51 |
| `comm/ftpclient.cpp` | 281 |
| `comm/gmtpchat.h` | 83 |
| `comm/gmtpchat.cpp` | 533 |

**Primary test file checked:** `test/test_ota.cpp` + `test/test_ota.h`
**All test files read:** `test/test_ota.cpp`, `test/test_ota.h`, `test/test_backgroundworker.cpp`, `test/test_backgroundworker.h`, `test/test_canbus.cpp`, `test/test_canbus.h`, `test/test_dialog.cpp`, `test/test_dialog.h`

---

## Reading Evidence

### FtpClient (`comm/ftpclient.h` + `comm/ftpclient.cpp`)

**Class:** `FtpClient : public QObject` (h:13)

**Public methods:**
| Method | Header line | Impl line |
|--------|-------------|-----------|
| `FtpClient(BackgroundWorker *parent)` | h:17 | cpp:18 |
| `void download(const QUrl &url)` | h:18 | cpp:31 |
| `void startTransfer()` | h:19 | cpp:46 |
| `void writeQueue()` | h:21 | cpp:119 |
| `void readQueue()` | h:22 | cpp:144 |
| `void setPowerState(CIGCONF::PowerState state)` | h:24 | cpp:109 |

**Signals:**
| Signal | Header line |
|--------|-------------|
| `void fileUpdated(const QString &fileName)` | h:27 |
| `void sendGmtpMessage(CIGCONF::GmtpMessage msg, const QByteArray &extra)` | h:28 |
| `void nextTransfer()` | h:29 |

**Private methods (tested only if exercised indirectly):**
| Method | Impl line |
|--------|-----------|
| `void readData()` | cpp:173 |
| `void downloadFinished()` | cpp:197 |
| `void setReport(CIGCONF::FtpErrorCode errorCode)` | cpp:273 |
| `void popQueue()` | cpp:166 |

**Includes (ftpclient.h):** `"app/cigconfigs.h"`, `<QObject>`, `<QUrl>`, `<QSaveFile>`, `<QQueue>`
**Includes (ftpclient.cpp):** `"ftpclient.h"`, `"app/backgroundworker.h"`, `"app/globalconfigs.h"`, `"platform/seriallogger.h"`, `<QNetworkAccessManager>`, `<QNetworkReply>`, `<QFile>`, `<QFileInfo>`, `<unistd.h>` (ARM-only)

**Key preprocessor constants:**
- `MAX_FILE_SIZE (16 * 1024 * 1024)` — cpp:14
- `FTP_QUEUE_FILE "/home/ftpqueue.txt"` — cpp:15
- `FTP_RETRIES 5` — cpp:16

---

### GmtpChat (`comm/gmtpchat.h` + `comm/gmtpchat.cpp`)

**Class:** `GmtpChat : public QObject` (h:14)

**Enumerations:**
- `enum Priority { NormalPriority, HighPriority }` — h:18
- `enum PduType { PduId=1, PduData=2, PduIdExt=3, PduDataExt=4, PduAck=5 }` — h:19

**Public methods:**
| Method | Header line | Impl line |
|--------|-------------|-----------|
| `GmtpChat(ModemChat *parent)` | h:21 | cpp:22 |
| `void setPowerState(CIGCONF::PowerState state)` | h:22 | cpp:70 |
| `void connectServer()` | h:23 | cpp:85 |
| `void sendMessage(const QByteArray &msgData, Priority priority)` | h:24 | cpp:195 |
| `void sendAck(quint16 msgId)` | h:25 | cpp:225 |
| `void clearGMTPMsgQueue()` | h:26 | cpp:489 |
| `bool sleeping()` | h:27 | h:27 (inline) |
| `void setEthernetState(bool up)` | h:28 | h:28 (inline) |
| `bool acksRemaining()` | h:29 | h:29 (inline) |

**Signals:**
| Signal | Header line |
|--------|-------------|
| `void cmdReceived(const QByteArray &ba)` | h:32 |
| `void socketStateChanged(bool state)` | h:33 |
| `void allMessagesSent()` | h:34 |
| `void allAcksSent()` | h:35 |
| `void gmtpHotStartReconnect()` | h:36 |
| `void disconnectSocket()` | h:37 |

**Private methods:**
| Method | Impl line |
|--------|-----------|
| `void readToQueue()` | cpp:405 |
| `void writeQueue(bool recent)` | cpp:434 |
| `void onConnected()` | cpp:144 |
| `void onDisconnected()` | cpp:173 |
| `void reconnectServer()` | cpp:112 |
| `void readSocket()` | cpp:323 |
| `void writeSocket()` | cpp:242 |
| `void bytesWritten(qint64 bytes)` | cpp:308 |
| `void ackTimeout()` | cpp:496 |
| `QByteArray packedMessage(...)` | cpp:380 |
| `void setOnIgnitionOffDisconnect(bool state)` | cpp:516 |
| `void disconnectFromHost()` | cpp:525 |

**Includes (gmtpchat.h):** `"app/cigconfigs.h"`, `<QObject>`, `<QQueue>`, `<QTcpSocket>`, `<QFile>`, `<QMutex>`
**Includes (gmtpchat.cpp):** `"gmtpchat.h"`, `"app/globalconfigs.h"`, `"comm/modemchat.h"`, `"platform/seriallogger.h"`, `<QFile>`, `<QDir>`, `<QTimer>`, `<QDebug>`, `<QProcess>`, `<QMutex>`, `<unistd.h>` (ARM-only)

**Key preprocessor constants:**
- `MAX_MESSAGE_CNT 1000` — cpp:16
- `MAX_RETRIES 3` — cpp:17
- `DEF_MSOCKET_TIMEOUT (10000)` — cpp:18 (10 seconds)
- `MAX_GMTP_RECONNECT_CNT (20)` — cpp:19

---

## Coverage Analysis

### FtpClient — Test Coverage Summary

**Test file examination findings:**

Grep across all files in `test/` for every FtpClient method name (`download`, `startTransfer`, `writeQueue`, `readQueue`, `setPowerState`, `setReport`, `popQueue`, `readData`, `downloadFinished`) returned **zero matches**. Grep for `FtpClient`, `ftpclient`, and `m_ftpClient` in the test directory also returned **zero matches**.

The `test/test_ota.cpp` file does test OTA-related logic (`updateSelf()`, decompression, MD5 verification) but exercises the `BackgroundWorker::updateSelf()` / `OtaWorker` path, not `FtpClient`. The `FtpClient` is instantiated in `BackgroundWorker::initialise()` (backgroundworker.cpp:2704), but none of the test harnesses call that initialise path — they assign `m_gmtpChat` directly but never assign `m_ftpClient`.

**Result: FtpClient has zero test coverage. Not one method, signal, or code path is exercised by any test in the suite.**

---

### GmtpChat — Test Coverage Summary

**Test file examination findings:**

Grep for all GmtpChat method names (`sendMessage`, `sendAck`, `clearGMTPMsgQueue`, `connectServer`, `reconnectServer`, `readSocket`, `writeSocket`, `bytesWritten`, `ackTimeout`, `packedMessage`, `readToQueue`, `disconnectFromHost`, `onConnected`, `onDisconnected`) returned **zero matches** in any test file.

`GmtpChat` is instantiated in four test harnesses (`test_ota.cpp:33`, `test_backgroundworker.cpp:34`, `test_canbus.cpp:38`, `test_dialog.cpp:53`) purely as a stub to satisfy the `BackgroundWorker` dependency. No test calls any method on the resulting object, inspects any signal it emits, or injects any data into its TCP socket or message queues.

**Result: GmtpChat has zero functional test coverage. The class is instantiated as a dependency stub only; no behaviour is verified.**

---

## Findings

---

**A09-1** · CRITICAL · Missing Test Coverage — FtpClient: No Connection Setup Test
**File:** `comm/ftpclient.cpp:18` (constructor) / `comm/ftpclient.cpp:31` (`download`) / `comm/ftpclient.cpp:46` (`startTransfer`)
**Description:** There are no tests that exercise the FtpClient constructor, the `download()` method, or the `startTransfer()` method. The constructor calls `readQueue()` at startup (cpp:28) and connects the `nextTransfer` signal (cpp:26–27). Neither the happy-path (queue empty at start, network available, transfer begins) nor any variant (queue pre-populated from file, network unavailable) is tested. For a component that performs OTA firmware delivery to embedded devices this is a critical reliability and security gap.
**Fix:** Add a unit test that constructs `FtpClient` with a mock `BackgroundWorker`, calls `download()` with a controlled URL, and uses `QSignalSpy` on `nextTransfer` and `sendGmtpMessage` to verify the queuing and handoff logic. Use `QNetworkAccessManager` mock or intercept at the `QNetworkReply` level to avoid real network I/O.

---

**A09-2** · CRITICAL · Missing Test Coverage — FtpClient: Download Success Path
**File:** `comm/ftpclient.cpp:197` (`downloadFinished`) / `comm/ftpclient.cpp:247–252`
**Description:** The success path inside `downloadFinished()` — `QNetworkReply::NoError`, file size matches `m_fileSize`, `m_file.commit()` succeeds, `fileUpdated` signal emitted — is never tested. This is the primary function of the component: delivering a file and signalling completion to the rest of the system. An untested success path means there is no regression protection should the commit/signal logic be accidentally broken.
**Fix:** Add an integration test that uses a local HTTP server (e.g., `QTcpServer` serving a fixed binary) to satisfy the `QNetworkAccessManager` request, then verifies that `fileUpdated` is emitted with the correct filename and that the target file exists on disk with the expected content.

---

**A09-3** · CRITICAL · Missing Test Coverage — FtpClient: Download Failure Paths
**File:** `comm/ftpclient.cpp:210–260` (`downloadFinished` error switch)
**Description:** All download failure branches are completely untested:
- Network errors (`ConnectionRefusedError`, `HostNotFoundError`, `TimeoutError`) → `FtpSaveFileError` / `FtpServerError`
- File-not-found (`ContentNotFoundError`, `ContentGoneError`) → `FtpNoFileError`
- Oversized file detected in `readData()` causing `OperationCanceledError` → `FtpGenericError`
- Incomplete file (size mismatch) → `FtpIncompleteFileError`
- Local save failure (`m_file.commit()` returns false) → `FtpSaveFileError`

Without tests for these paths there is no assurance that: (a) error codes are reported correctly via `sendGmtpMessage`; (b) `m_file` is properly discarded (cancelWriting + commit) on each failure; (c) the retry counter increments correctly and stops at `FTP_RETRIES` (5).
**Fix:** Add parameterised tests for each error code branch, injecting the appropriate `QNetworkReply::NetworkError` via a mock reply. Verify that `setReport` emits `sendGmtpMessage(GMTP_FTPF, ...)` with the expected error code, that the file is not committed on the filesystem, and that retries exhaust before queue pop.

---

**A09-4** · HIGH · Missing Test Coverage — FtpClient: Retry and Queue Persistence Logic
**File:** `comm/ftpclient.cpp:119–163` (`writeQueue`, `readQueue`) / `comm/ftpclient.cpp:253–260`
**Description:** The retry mechanism (up to `FTP_RETRIES = 5` attempts before popping the queue) and the queue persistence path (`writeQueue` to `/home/ftpqueue.txt` on sleep, `readQueue` on resume) are untested. These two behaviours are critical for device correctness: if the retry counter is not properly reset (`popQueue` at cpp:170 resets to 0) or if the persistent queue file becomes corrupt or is only partially written, downloads may silently stall. The double-semicolon typo at cpp:124 (`QFile file(FTP_QUEUE_FILE);;`) does not cause a bug but indicates the queue code has had minimal scrutiny.
**Fix:** Add tests that: (a) simulate repeated failures up to FTP_RETRIES and confirm the URL is eventually removed from the queue; (b) call `setPowerState(SleepState)` with a populated queue and verify `/home/ftpqueue.txt` is written with the correct URLs; (c) construct a new `FtpClient` after writing that file and verify the queue is restored in `readQueue()`.

---

**A09-5** · HIGH · Missing Test Coverage — FtpClient: File Size Limit Enforcement
**File:** `comm/ftpclient.cpp:173–194` (`readData`) / `comm/ftpclient.cpp:220–224` (`downloadFinished`)
**Description:** The `MAX_FILE_SIZE` guard (16 MiB) is checked in two places: once against the `Content-Length` header (cpp:180) and once against the accumulated size during streaming (cpp:191). Neither check is tested. If the header check is bypassed by a server that omits `Content-Length` (which the comment at cpp:33 explicitly acknowledges: "length in header depends on ftp server setting, might be 0"), the streaming check becomes the sole defence. The streaming check closes the reply but `m_fileSize` remains 0, which causes `downloadFinished` at cpp:212 to accept the file via the `!m_fileSize` bypass. This interaction — no Content-Length header + file > 16 MiB — is a security-relevant edge case with no test.
**Fix:** Add tests for: (a) server sends `Content-Length > MAX_FILE_SIZE` → reply is closed, no file committed; (b) server sends no `Content-Length` header and streams more than 16 MiB of data → reply is closed via the size check in `readData`, and `downloadFinished` correctly classifies the result as `FtpGenericError` (not a silent accept due to `!m_fileSize`).

---

**A09-6** · CRITICAL · Missing Test Coverage — GmtpChat: Message Send Path
**File:** `comm/gmtpchat.cpp:195` (`sendMessage`) / `comm/gmtpchat.cpp:242` (`writeSocket`)
**Description:** `sendMessage()` — the primary public API used by the rest of the system to upload telemetry and control messages — is not tested at all. This covers both `NormalPriority` (enqueue to `m_uploadMessages`) and `HighPriority` (prepend). The spill-over path to `m_recentMessages` and subsequent `writeQueue(true)` when the queue reaches `MAX_MESSAGE_CNT` (1000) is also untested. No test verifies that `packedMessage()` produces a correctly framed PDU (big-endian type, 2-byte msgId, 2-byte length, payload), that `m_msgId` wraps from 65535 to 1 (skipping 0), or that the upload timer is started.
**Fix:** Add unit tests for `sendMessage()` covering: normal priority enqueue, high priority prepend, the 1000-message spill-over to file, and the `SleepState` guard that silently drops messages. Use `QSignalSpy` on `allMessagesSent` and inspect queue state. Test `packedMessage()` output format directly for both `PduDataExt` and `PduAck` types.

---

**A09-7** · CRITICAL · Missing Test Coverage — GmtpChat: Message Receive and Framing
**File:** `comm/gmtpchat.cpp:323` (`readSocket`)
**Description:** `readSocket()` is the inbound data parser. It handles: multi-message batches in a single TCP segment, partial frames stored in `m_downloadMessage`, `PduDataExt` data frames (→ emit `cmdReceived` + send ACK), `PduAck` frames (→ clear `m_ackId`, stop ack timer), and unknown type bytes (→ advance by 1 byte). None of these paths are tested. The partial-frame reassembly path (cpp:342–345) is especially critical: if a 6-byte header arrives split across two `readyRead` calls, `m_downloadMessage` stores the incomplete buffer and the loop resumes on the next call. A framing defect here could cause command injection (emitting a `cmdReceived` with wrong data) or silent message loss.
**Fix:** Add tests that feed raw byte arrays directly to `readSocket()` via a loopback `QTcpSocket` or by calling the slot directly. Cover: complete single frame, two frames in one call, frame split at header boundary, frame split within payload, unknown type byte, zero-length payload (`PduAck`), maximum-size payload (65535 bytes per `quint16` dataSize field).

---

**A09-8** · HIGH · Missing Test Coverage — GmtpChat: ACK Timeout and Reconnection
**File:** `comm/gmtpchat.cpp:496` (`ackTimeout`) / `comm/gmtpchat.cpp:112` (`reconnectServer`)
**Description:** The ACK timeout handler at cpp:496 re-queues `m_sendingMessage` and increments `m_retryCount`. After `MAX_RETRIES` (3) exhausted retries it calls `onDisconnected()`, which in turn calls `connectServer()`. The reconnect logic at cpp:129–141 rotates through server indexes and after `MAX_GMTP_RECONNECT_CNT` (20) failures calls `m_modemChat->requestDetach()` to reset the modem. This entire retry-reconnect chain is untested. A fault in the retry counter reset (e.g., `m_retryCount` not zeroed on `onConnected`, cpp:155) could cause premature modem detach or a stuck-connected state that never retries.
**Fix:** Add tests that: (a) trigger `ackTimeout` fewer than `MAX_RETRIES` times and confirm `m_sendingMessage` is re-prepended; (b) trigger it `MAX_RETRIES + 1` times and confirm `onDisconnected` is called (via spy on `socketStateChanged`); (c) trigger `reconnectServer` more than `MAX_GMTP_RECONNECT_CNT` times and confirm `requestDetach` is invoked on the modem chat mock.

---

**A09-9** · HIGH · Missing Test Coverage — GmtpChat: Connection Drop During Message Send
**File:** `comm/gmtpchat.cpp:173` (`onDisconnected`)
**Description:** `onDisconnected()` re-queues `m_sendingMessage` at the head of `m_uploadMessages` (cpp:178–179) so the in-flight message is not lost. This is correct logic but it is not tested. If the prepend is omitted or the condition is wrong, a message could be silently dropped during a TCP connection loss, which for a vehicle control/compliance system could result in missing safety events. Additionally, `onDisconnected` always calls `connectServer()` (cpp:192) regardless of power state, which contradicts the commented-out guard (cpp:187–190) — this behaviour is also untested.
**Fix:** Add a test that: establishes a connected state, calls `writeSocket()` to populate `m_sendingMessage`, then calls `onDisconnected()` directly, and verifies that `m_uploadMessages.head()` contains the originally sent message. Also verify `socketStateChanged(false)` is emitted and `connectServer()` is called.

---

**A09-10** · HIGH · Missing Test Coverage — GmtpChat: Empty and Maximum Payload
**File:** `comm/gmtpchat.cpp:380` (`packedMessage`) / `comm/gmtpchat.cpp:323` (`readSocket`)
**Description:** `packedMessage()` encodes payload length as a big-endian `quint16` at bytes 4–5 of the header. For `PduAck` the payload is empty (`""`, size 0). For a `PduDataExt` message the maximum representable payload is 65535 bytes; however `readSocket()` uses `dataSize = BE_SHORT(ba[4], ba[5])` to determine how many bytes to consume, and the `sendMessage()` guard only limits the queue count (1000 entries), not individual message size. No test verifies: (a) that a zero-length ACK frame is correctly round-tripped; (b) that a near-maximum-size payload (e.g., 65534 bytes) is correctly framed and parsed; (c) that a message whose payload contains a null byte or a newline (which is used as the delimiter in the persistent queue file at cpp:468–470) is correctly stored and restored.
**Fix:** Add tests for zero-length ACK frames, large payloads up to the `quint16` limit, and payloads containing `\n` bytes to verify the file-persistence round-trip does not corrupt message boundaries.

---

**A09-11** · MEDIUM · Missing Test Coverage — GmtpChat: Queue Persistence on Sleep
**File:** `comm/gmtpchat.cpp:70` (`setPowerState`) / `comm/gmtpchat.cpp:434` (`writeQueue`)
**Description:** When `setPowerState(SleepState)` is called, `writeQueue(false)` and `writeQueue(true)` are called in sequence to flush both `m_uploadMessages` and `m_recentMessages` to numbered files in `DIR_GMTP_MSG`. The file index tracking logic in `m_gmtpFileIndexes` (prepend 0 for upload, append last+1 for recent) is non-trivial and completely untested. If the index sequence overflows or the file is not written atomically (the `fsync` at cpp:484 is ARM-only so it is skipped on PC), messages could be silently lost across a power cycle.
**Fix:** Add tests for `setPowerState(SleepState)` with pre-populated queues, verifying that the correct files are created in the GMTP message directory and that a subsequent `readToQueue()` call recovers the messages in order.

---

**A09-12** · MEDIUM · Missing Test Coverage — GmtpChat: Duplicate PduId Suppression
**File:** `comm/gmtpchat.cpp:278–287` (`writeSocket`)
**Description:** If `m_idSent` is true and the head of `m_uploadMessages` is a `PduId` or `PduIdExt` frame, the message is silently discarded (cpp:281–287). This guard prevents the server from terminating the session on a duplicate registration PDU. It is not tested, so there is no assurance that: (a) the dequeue happens correctly; (b) the upload timer restarts; (c) a legitimately queued `PduId` frame following a reconnect (before `m_idSent` is cleared) is dropped but the next normal data frame is sent.
**Fix:** Add a test that pre-populates `m_uploadMessages` with a `PduIdExt` frame, sets `m_idSent = true`, calls `writeSocket()`, and verifies the queue is drained without writing to the socket, and that the next non-identity frame is then sent normally.

---

**A09-13** · LOW · GmtpChat Instantiated with Null Parent in All Tests
**File:** `test/test_ota.cpp:33`, `test/test_backgroundworker.cpp:34`, `test/test_canbus.cpp:38`, `test/test_dialog.cpp:53`
**Description:** All four test harnesses instantiate `GmtpChat(nullptr)` rather than a proper `ModemChat` parent. The constructor stores the pointer as `m_modemChat` (cpp:23) and calls `m_modemChat->requestDetach()` inside `reconnectServer()` (cpp:137) when the reconnect count exceeds the maximum. Since no test exercises reconnection, this null dereference has not been triggered, but it represents a latent crash in any test that would exercise the reconnection limit.
**Fix:** Provide a mock `ModemChat` object with at least `requestDetach()` stubbed out for all test harnesses, or construct `GmtpChat` with a valid (but inactive) `ModemChat` instance.

---

## Summary Table

| ID | Severity | Category | Location | Description |
|----|----------|----------|----------|-------------|
| A09-1 | CRITICAL | Missing Coverage | `comm/ftpclient.cpp:18,31,46` | FtpClient: no test for constructor, download(), or startTransfer() |
| A09-2 | CRITICAL | Missing Coverage | `comm/ftpclient.cpp:197,247–252` | FtpClient: download success path (fileUpdated signal, file commit) never tested |
| A09-3 | CRITICAL | Missing Coverage | `comm/ftpclient.cpp:210–260` | FtpClient: all download failure branches (network error, server error, incomplete file, save error) untested |
| A09-4 | HIGH | Missing Coverage | `comm/ftpclient.cpp:119–163,253–260` | FtpClient: retry exhaustion and queue persistence (writeQueue/readQueue) untested |
| A09-5 | HIGH | Missing Coverage | `comm/ftpclient.cpp:173–194,220–224` | FtpClient: MAX_FILE_SIZE enforcement and the Content-Length=0 bypass interaction untested |
| A09-6 | CRITICAL | Missing Coverage | `comm/gmtpchat.cpp:195,242` | GmtpChat: sendMessage() (normal, high priority, spill-over, sleep guard) never tested |
| A09-7 | CRITICAL | Missing Coverage | `comm/gmtpchat.cpp:323` | GmtpChat: readSocket() framing, partial-frame reassembly, PduAck handling never tested |
| A09-8 | HIGH | Missing Coverage | `comm/gmtpchat.cpp:496,112` | GmtpChat: ACK timeout, retry exhaustion, modem detach trigger untested |
| A09-9 | HIGH | Missing Coverage | `comm/gmtpchat.cpp:173` | GmtpChat: in-flight message re-queue on connection drop untested |
| A09-10 | HIGH | Missing Coverage | `comm/gmtpchat.cpp:380,323` | GmtpChat: empty payload, maximum payload, payload with newline character untested |
| A09-11 | MEDIUM | Missing Coverage | `comm/gmtpchat.cpp:70,434` | GmtpChat: queue persistence to file on sleep/wake cycle untested |
| A09-12 | MEDIUM | Missing Coverage | `comm/gmtpchat.cpp:278–287` | GmtpChat: duplicate PduId suppression logic (m_idSent guard) untested |
| A09-13 | LOW | Test Quality | `test/test_ota.cpp:33` et al. | GmtpChat instantiated with null ModemChat parent; latent null-dereference in reconnect path |

---

## Overall Assessment

**FtpClient test coverage: 0%**
**GmtpChat test coverage: 0% (functional)**

Both components are compiled into the test binary and `GmtpChat` is instantiated as a stub in four test harnesses, but no test exercises any behaviour of either class. The test suite (`test_ota.cpp`) focuses entirely on the OTA decompression/MD5 path in `BackgroundWorker`, which is orthogonal to the FTP and GMTP communications layers.

Given that `FtpClient` is the delivery mechanism for firmware updates and configuration files on an embedded safety device, and `GmtpChat` is the sole uplink for telemetry and command receipt, the absence of any test coverage is a high-severity finding from a software quality and security assurance standpoint. Four findings are rated CRITICAL specifically because the untested code paths include: firmware file delivery success/failure, inbound command parsing, and outbound message queuing — all of which are directly relevant to the safety and integrity of the deployed device.
