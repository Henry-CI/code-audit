# Pass 2 Audit — A10 (Test Coverage)
**Agent:** A10
**Pass:** 2 — Test Coverage
**Date:** 2026-02-28
**Audit Run:** 2026-02-28-01
**Branch:** master (confirmed by `git branch --show-current`)
**Repo:** C:/Projects/cig-audit/repos/mark3-pvd

---

## Step 1 — Branch Confirmation

```
$ git branch --show-current
master
```

Branch is **master**. Confirmed.

---

## Step 2 & 4 — Reading Evidence

### File: `comm/modemchat.h`

**Class:** `ModemChat` extends `QObject`

**Enums:**
- `NetworkState { NetworkStopped, NetworkHome, NetworkSearching, NetworkDenied, NetworkUnknown, NetworkRoaming }` — line 22

**Public Methods (with line numbers):**
| Line | Signature |
|------|-----------|
| 24 | `explicit ModemChat(EM070::ModemPort *modemPort)` |
| 25 | `void portStateChanged(bool open)` |
| 26 | `void setGnssEnabled(bool enable)` |
| 27 | `void rssiRefresh()` |
| 28 | `void qmiCheck()` |
| 29 | `void networkCheck()` |
| 30 | `void updateApn()` |
| 31 | `void detach(bool send = true)` |
| 32 | `void requestDetach()` |
| 34 | `const QByteArray &cgmi() const` |
| 35 | `const QByteArray &cgmm() const` |
| 36 | `const QByteArray &cgmr() const` |
| 37 | `const QByteArray &cgsn() const` |
| 38 | `const QByteArray &iccid() const` |
| 39 | `const QByteArray &rssi() const` |
| 40 | `const QByteArray &mobileOperator() const` |
| 41 | `const QByteArray &moni() const` |
| 42 | `NetworkState networkState() const` |
| 43 | `bool isEthernetReady() const` |

**Signals:**
| Line | Signature |
|------|-----------|
| 46 | `void simError()` |
| 47 | `void ethernetStateChanged(bool ready)` |

**Private Methods:**
| Line | Signature |
|------|-----------|
| 56 | `void sendChat(bool timeout = false)` |
| 57 | `void popChat()` |
| 58 | `void pushChat(const QByteArray &chat)` |
| 59 | `void noResponse()` |
| 60 | `void parseResponse(bool result, const QByteArrayList &content)` |
| 61 | `void selectAPN()` |
| 62 | `void updateEthernetState(bool connected)` |
| 63 | `void reconnectNetwork()` |
| 64 | `void onUqmiProcessComplete(int exitCode, QProcess::ExitStatus exitStatus)` |
| 65 | `void onProcessTimeout()` |
| 66 | `void resetReconnectFlag()` |
| 69 | `int args(const QByteArrayList &content, QGenericArgument val1, ...)` |

**Includes:**
- `<QProcess>` — line 8
- `<QObject>` — line 9
- `<QQueue>` — line 10
- Forward declarations: `EM070::ModemPort`, `QTimer`

---

### File: `comm/modemchat.cpp`

**Includes:**
- `"modemchat.h"` — line 1
- `"platform/modemport.h"` — line 2
- `"platform/seriallogger.h"` — line 3
- `"app/globalconfigs.h"` — line 4
- `<QTimer>` — line 5
- `<QDebug>` — line 6
- `<QProcess>` — line 7
- `<QStringList>` — line 8

**Key Macros:**
- `RETRY_WAIT 500` — line 10
- `RETRIES_PER_SEC (1000 / RETRY_WAIT)` — line 11 (= 2)
- `ACK_TIMEOUT 3000` — line 12
- `RSSI_INTERVAL 10000` — line 13
- `QMI_INTERVAL 2000` — line 14
- `NETWORK_INTERVAL 2000` — line 15
- `NETWORK_TIMEOUT 90` — line 16 (90 × 2s = 180 s total)
- `MAX_QMI_FAILURE_COUNT 7` — line 18 (defined but not used)
- `PROCESS_MAX_WAIT_TIMEOUT 10000` — line 19
- `MAX_CGDCONT 5` — line 20

**AT command sequence enqueued at `portStateChanged(true)` (lines 65–80):**
`AT`, `AT+CGMI`, `AT+CGMM`, `AT+CGMR`, `AT+CGSN`, `AT+ICCID`, `AT+CMEE=0`, `AT#USBCFG?`, `AT#RXDIV?`, `AT+CGEREP=1,0`, `AT+COPS=2`, `AT+CGDCONT=2`, `AT+CGDCONT=3`, `AT+COPS=0`; optionally `AT$GPSP=1`, `AT$GPSNMUN=2,1,1,1,1,1,1`.

**`noResponse()` (lines 260–268):** resets modem after `RETRIES_PER_SEC * 60` = 120 retries (60 seconds).

**`parseResponse()` (lines 363–693):** Central dispatch handler; handles all AT command responses, emits `simError()` and `ethernetStateChanged()` as appropriate.

---

### File: `comm/ntpsync.h`

**Class:** `NtpSync` extends `QObject`

**Public Methods:**
| Line | Signature |
|------|-----------|
| 14 | `explicit NtpSync(ModemChat *parent)` |
| 15 | `void connectServer()` |
| 16 | `void abortConnection()` |

**Signals:**
| Line | Signature |
|------|-----------|
| 19 | `void synchronized(bool yes)` |

**Private Methods (slots):**
| Line | Signature |
|------|-----------|
| 22 | `void writeSocket()` |
| 23 | `void readSocket()` |

**Includes:**
- `<QObject>` — line 4
- `<QUdpSocket>` — line 5

---

### File: `comm/ntpsync.cpp`

**Includes:**
- `"ntpsync.h"` — line 1
- `"platform/internalrtc.h"` — line 2
- `"platform/seriallogger.h"` — line 3
- `"comm/modemchat.h"` — line 4
- `"app/globalconfigs.h"` — line 5
- `<QTimer>` — line 6
- `<QDateTime>` — line 7

**Key Macro:**
- `EPOCH_DIFF 0x83aa7e80UL` — line 9 (NTP-to-Unix epoch offset: 2208988800 seconds)

**NTP retry logic (`connectServer()`, lines 29–51):** Aborts after 3 failed attempts and emits `synchronized(false)`.

**`readSocket()` validation (lines 70–106):** Minimum packet size 48 bytes; `ts2 - ts1 > 300` filter; EPOCH_DIFF subtraction; year >= 2019 floor check; emits `synchronized(true)` on success.

---

## Step 3 — Test Coverage Search

**Grep executed across `C:/Projects/cig-audit/repos/mark3-pvd/test/` for:**
- Class names: `ModemChat`, `NtpSync`, `modemchat`, `ntpsync`
- Method names: `portStateChanged`, `setGnssEnabled`, `rssiRefresh`, `qmiCheck`, `networkCheck`, `updateApn`, `detach`, `requestDetach`, `parseResponse`, `selectAPN`, `connectServer`, `abortConnection`, `writeSocket`, `readSocket`, `synchronized`

**Result: Zero matches across all `.cpp` and `.h` files in the test directory.**

**Test files present in `test/`:**
- `test_backgroundworker.cpp` / `.h` — tests `BackgroundWorker` GMTP command handling
- `test_canbus.cpp` / `.h` — tests CAN bus
- `test_dialog.cpp` / `.h` — tests dialog UI
- `test_ota.cpp` / `.h` — tests OTA update

**Test project (`mk3-test.pro`):** `comm/modemchat.cpp` (line 79) and `comm/ntpsync.cpp` (line 83) are compiled into the test binary, but no test class exercises either of them. They are present only as transitive compilation dependencies.

**Conclusion: Neither `ModemChat` nor `NtpSync` has any automated test coverage whatsoever.**

---

## Step 5 — Findings

---

**A10-TC-1** · HIGH · Test Coverage — Missing
**File:** `comm/modemchat.cpp` + `comm/modemchat.h`
**Description:** The entire `ModemChat` class — including the AT command sequencing engine, APN auto-selection logic, network state machine, QMI reconnection flow, `parseResponse()` dispatch, modem reset path, and both signals (`simError`, `ethernetStateChanged`) — has zero unit or integration test coverage. `parseResponse()` alone is 330 lines of branching AT response logic. The lack of any test means regressions in modem initialization, SIM detection failure handling, network re-attachment, or GPRS detach sequencing are undetectable until runtime on hardware. This has direct bearing on vehicle connectivity reliability and safety-critical event transmission.
**Fix:** Write a `TestModemChat` Qt test class using a mock `EM070::ModemPort` that exposes a controllable `response` signal. At minimum, test cases should cover: (1) the full `portStateChanged(true)` AT sequence completing successfully; (2) `AT+ICCID` failure after `RETRIES_PER_SEC * 5` retries emitting `simError()`; (3) `noResponse()` triggering `resetModem()` after 120 retries; (4) `parseResponse()` handling `AT+CGMM` for WWX vs non-WWX modem type selection; (5) `selectAPN()` auto-APN mapping for each known ICCID prefix; (6) `networkCheck()` decrementing the counter and calling `detach()` at timeout; (7) `updateEthernetState()` emitting `ethernetStateChanged()`.

---

**A10-TC-2** · HIGH · Test Coverage — Missing
**File:** `comm/ntpsync.cpp` + `comm/ntpsync.h`
**Description:** `NtpSync` has zero unit or integration test coverage. The class is responsible for setting the device hardware RTC from a network-sourced UDP packet. Its `readSocket()` method applies several validation heuristics (`ba.size() < 48`, the `ts2 - ts1 > 300` gap check, the year >= 2019 floor) that were identified in Pass 1 as containing logical defects (unsigned wraparound, no upper-bound check). Without tests these defects cannot be confirmed or regression-protected. The `connectServer()` retry/abort logic (three attempts, then `synchronized(false)`) is also untested. Any regression in NTP handling directly affects the accuracy of all timestamped audit records.
**Fix:** Write a `TestNtpSync` Qt test class using a `QUdpSocket`-based mock NTP server or by directly calling `readSocket()` with crafted `QByteArray` payloads. At minimum, test cases should cover: (1) a well-formed 48-byte NTP response sets the RTC and emits `synchronized(true)`; (2) a packet shorter than 48 bytes is silently discarded; (3) `ts2 - ts1 > 300` causes the packet to be discarded (note: also test the unsigned-wraparound edge case where `ts2 < ts1`); (4) a `ts2` yielding year < 2019 after EPOCH_DIFF subtraction is discarded; (5) a `ts2` yielding year > 2100 is not discarded by current code (demonstrating the missing upper-bound check); (6) after three `connectServer()` calls without a response, `synchronized(false)` is emitted; (7) `abortConnection()` stops the retry timer and resets `m_syncTimes`.

---

**A10-TC-3** · MEDIUM · Test Coverage — Specific Logic Gap
**File:** `comm/modemchat.cpp:277–313`
**Description:** `selectAPN()` contains a chain of ICCID-prefix comparisons covering nine different carriers (Vodafone AU, Telstra, Optus, Kore, Monogoto, Hologram, UK "stream.co.uk" on three different ICCID prefixes). This logic uses `m_iccid.left(6)` string comparisons and is invoked from `parseResponse()` on every `AT+CGDCONT?` response. There are no tests for any of these ICCID branches. A typo or prefix transposition would silently configure the wrong APN, preventing network connectivity on affected SIMs. The Monogoto branch uses `left(5)` (line 303) rather than `left(6)`, diverging from the pattern used by all other carriers — this inconsistency is untested and may be intentional (the prefix `89999` is five digits) or may reflect a copy-paste error.
**Fix:** Add parameterised test cases for `selectAPN()` covering each ICCID prefix (including the five-digit Monogoto prefix), an unrecognised prefix in auto mode (resulting in an empty APN), and manual APN override mode. Consider extracting the ICCID-to-APN table into a data structure to make it directly testable without full `ModemChat` construction.

---

**A10-TC-4** · MEDIUM · Test Coverage — Specific Logic Gap
**File:** `comm/modemchat.cpp:228–245`
**Description:** `sendChat()` implements retry gating: if `m_ackTimer` is active (waiting for a previous response) or the queue is empty, it returns immediately. If `m_tryTimes` is non-zero and this is not a timeout-driven call, it starts `m_tryTimer` to delay the retry by `RETRY_WAIT` (500 ms). This prevents flooding the modem. If `m_modemPort->sendCmd()` fails (returns false), the entire queue is cleared. This queue-clearing behaviour on send failure — which effectively abandons all pending AT commands — is a significant operational behaviour with no test. A test could inject a `sendCmd()` failure and verify the queue is cleared and the system reaches a recoverable state (waiting for `portStateChanged`).
**Fix:** Mock `ModemPort::sendCmd()` to return false and verify that `m_chatCmds` is cleared after a `sendChat()` call. Also verify that `sendChat()` is a no-op when `m_ackTimer` is active.

---

**A10-TC-5** · MEDIUM · Test Coverage — Specific Logic Gap
**File:** `comm/modemchat.cpp:765–811`
**Description:** `onUqmiProcessComplete()` handles three distinct outcomes from the `uqmi` process: abnormal exit (kills the process and restarts the QMI timer), "disconnected"/"incompatible" output (calls `updateEthernetState(false)`), "connected" output (calls `updateEthernetState(true)`), and any other output (logs a warning). The reconnect path (`m_startReconnect == true`) skips state parsing entirely and just calls `resetReconnectFlag()`. None of these branches are tested. The "unexpected output" path in particular has no handling beyond a warning log, meaning unknown `uqmi` output silently leaves ethernet state unchanged. Additionally, the macro `MAX_QMI_FAILURE_COUNT` (line 18, value 7) is defined but is never referenced anywhere in the code — it has no effect. This suggests dead code or a missing guard that was intended to limit successive QMI failures.
**Fix:** Write tests that mock `QProcess` output and verify: (1) "connected" triggers `ethernetStateChanged(true)`; (2) "disconnected" triggers `ethernetStateChanged(false)`; (3) crash exit (`QProcess::CrashExit`) triggers timer restart without state change; (4) unrecognised output leaves state unchanged. Investigate the intended use of `MAX_QMI_FAILURE_COUNT` and either implement the guard or remove the dead macro.

---

**A10-TC-6** · MEDIUM · Test Coverage — Specific Logic Gap
**File:** `comm/modemchat.cpp:170–196`
**Description:** `networkCheck()` is called every `NETWORK_INTERVAL` (2000 ms) by `m_networkTimer`. It implements two distinct behaviours: (a) decrement `m_networkCounter` when ethernet is not connected, and force-detach when it reaches zero (representing a 180-second connectivity timeout); and (b) if `m_detachRequested` is true, immediately call `detach()` when ethernet is connected but wait out the 180-second timeout otherwise. Both behaviours are safety-critical: the timeout detach is the mechanism for recovering from a permanently failed connection. Neither behaviour has any test. There is also a subtle interaction: `m_detachRequested` is reset to `false` unconditionally within the block regardless of whether the detach was executed, meaning a detach request made while ethernet is disconnected will be lost.
**Fix:** Test `networkCheck()` by: (1) calling it 90 times with `m_ethernetState == false` and verifying `detach()` is invoked on the 90th call; (2) calling it with `m_detachRequested == true` and `m_ethernetState == true` and verifying `detach()` is invoked immediately; (3) calling it with `m_detachRequested == true` and `m_ethernetState == false` and verifying `detach()` is NOT invoked and `m_detachRequested` is reset (documenting the existing behaviour of silently dropping the request).

---

**A10-TC-7** · LOW · Test Coverage — Specific Logic Gap
**File:** `comm/modemchat.cpp:696–757`
**Description:** The `args()` helper method parses comma-separated AT response fields into typed C++ values via `QGenericArgument`. It handles `QByteArray`, `QString`, `int`, and `bool` types. The `bool` branch (lines 748–752) contains a logical defect: the condition `if (val >= 0 || val <= 1)` is a tautology — it is always true for any integer value, since every integer is either >= 0 or <= 1. The intent was almost certainly `if (val >= 0 && val <= 1)` (i.e., only accept 0 or 1). As written, a value like `-5` or `99` will be silently assigned to the `bool` output as a non-zero value (true), when the AT response format only specifies 0 or 1. This defect in `args()` propagates into every AT command response that extracts a boolean (e.g., `AT+CGATT?`, `AT#ECMC?`, `AT#ECM?`, `AT$GPSP?`, `AT+CGREG?`). No tests exist to catch this.
**Fix:** Add unit tests for `args()` covering each type, including edge cases for `bool`: verify that `"0"` maps to `false`, `"1"` maps to `true`, `"2"` is rejected (should return before the bool position under correct semantics), and `"-1"` is rejected. Fix the tautological condition to `val >= 0 && val <= 1`.

---

**A10-TC-8** · LOW · Test Coverage — Specific Logic Gap
**File:** `comm/modemchat.cpp:260–268`
**Description:** `noResponse()` resets the modem (`m_modemPort->resetModem()`) when `m_tryTimes > RETRIES_PER_SEC * 60` (i.e., after 120 retry attempts at 500 ms each = 60 seconds). This is the only modem self-recovery mechanism for a stuck AT command. There is no test verifying that the threshold is correct or that `resetModem()` is called at exactly the right count. A regression that increments `m_tryTimes` at a different rate, or changes `RETRIES_PER_SEC`, would silently change the reset threshold without any test failure.
**Fix:** Add a test that drives `noResponse()` 120 times via repeated `m_ackTimer` timeout signals and verifies `resetModem()` is called on the 121st invocation. Also verify `resetModem()` is not called before that threshold.

---

**A10-TC-9** · LOW · Test Coverage — Specific Logic Gap
**File:** `comm/ntpsync.cpp:29–51`
**Description:** `connectServer()` uses `m_syncTimes` as both a retry counter and a "synced" sentinel (`m_syncTimes < 0` means already synced). The increment (`++m_syncTimes > 3`) on line 41 causes the method to emit `synchronized(false)` after the fourth call (syncTimes values 1, 2, 3, then 4 > 3). The pre-increment means the method processes `syncTimes == 1` on the first call (not zero), which is mildly confusing. More importantly, `abortConnection()` (line 53) resets `m_syncTimes` to 0 only if it is currently > 0 — if `m_syncTimes` is already 0 (i.e., `connectServer()` has never been called), the reset is skipped. This means calling `abortConnection()` before any sync attempt leaves `m_syncTimes` at 0, and the next `connectServer()` call will not see a synced sentinel. This is the correct behaviour but it is subtle and untested.
**Fix:** Add tests for `abortConnection()` called: (1) before any `connectServer()` call; (2) mid-sequence (after 1-2 retries); (3) after successful sync (`m_syncTimes == -1`). Verify that after `abortConnection()`, the next `connectServer()` call restarts cleanly without prematurely emitting `synchronized(false)`.

---

## Summary Table

| ID | Severity | Category | File | Description |
|----|----------|----------|------|-------------|
| A10-TC-1 | HIGH | Test Coverage — Missing | `comm/modemchat.cpp` + `.h` | Entire `ModemChat` class has zero test coverage |
| A10-TC-2 | HIGH | Test Coverage — Missing | `comm/ntpsync.cpp` + `.h` | Entire `NtpSync` class has zero test coverage |
| A10-TC-3 | MEDIUM | Test Coverage — Specific Logic Gap | `comm/modemchat.cpp:277–313` | `selectAPN()` ICCID-to-APN mapping untested; Monogoto uses `left(5)` vs `left(6)` elsewhere |
| A10-TC-4 | MEDIUM | Test Coverage — Specific Logic Gap | `comm/modemchat.cpp:228–245` | `sendChat()` queue-clearing on `sendCmd()` failure untested |
| A10-TC-5 | MEDIUM | Test Coverage — Specific Logic Gap | `comm/modemchat.cpp:765–811` | `onUqmiProcessComplete()` branches untested; `MAX_QMI_FAILURE_COUNT` defined but never used |
| A10-TC-6 | MEDIUM | Test Coverage — Specific Logic Gap | `comm/modemchat.cpp:170–196` | `networkCheck()` 180-second timeout detach and `requestDetach()` flow untested |
| A10-TC-7 | LOW | Test Coverage — Specific Logic Gap | `comm/modemchat.cpp:748–752` | `args()` bool branch has tautological condition (`>=0 \|\| <=1`); defect propagates to all bool AT responses |
| A10-TC-8 | LOW | Test Coverage — Specific Logic Gap | `comm/modemchat.cpp:260–268` | `noResponse()` modem reset threshold untested |
| A10-TC-9 | LOW | Test Coverage — Specific Logic Gap | `comm/ntpsync.cpp:29–51` | `connectServer()` retry counter / sentinel semantics and `abortConnection()` edge cases untested |

---

## Coverage Summary

| Question | ModemChat | NtpSync |
|----------|-----------|---------|
| AT command sequence tested? | **No** | N/A |
| Timeout handling tested? | **No** | **No** |
| Unexpected modem response tested? | **No** | N/A |
| Connection failure recovery tested? | **No** | **No** |
| Time sync success tested? | N/A | **No** |
| Server unreachable (retry/abort) tested? | N/A | **No** |
| Malformed NTP response tested? | N/A | **No** |
| Large time delta handling tested? | N/A | **No** |

Overall test coverage for both assigned files: **0%**. Both classes are compiled into the test binary (`mk3-test.pro` lines 79, 83) but no test class exercises any of their methods.
