# Security Audit – Pass 2: Test Coverage
**Agent:** A12
**Audit Run:** 2026-02-28-01
**Branch confirmed:** master (verified via `git branch --show-current`)
**Date:** 2026-02-28

---

## Files Audited

| # | Source file | Header |
|---|-------------|--------|
| 1 | `platform/aescrypto.cpp` | `platform/aescrypto.h` |
| 2 | `platform/blecentral.cpp` | `platform/blecentral.h` |

---

## Reading Evidence

### AesCrypto (`platform/aescrypto.h` + `platform/aescrypto.cpp`)

**Class:** `EM070::AesCrypto`

**Includes:**
- `aescrypto.h`
- `<unistd.h>` (ARM only)
- `<linux/if_alg.h>` (ARM only)
- `<sys/socket.h>` (ARM only)
- `<QDebug>`
- `<QByteArray>` (via header)

**Public methods:**

| Method | Location | Notes |
|--------|----------|-------|
| `static QByteArray encrypt(const QByteArray &in)` | `aescrypto.h:16`, impl `aescrypto.cpp:150` | Public static entry point for encryption |
| `static QByteArray descrypt(const QByteArray &in)` | `aescrypto.h:17`, impl `aescrypto.cpp:156` | Public static entry point for decryption (note: misspelled — "descrypt" not "decrypt") |

**Private methods:**

| Method | Location |
|--------|----------|
| `bool enableMtp()` | `aescrypto.cpp:20` |
| `QByteArray aes(const QByteArray &in, bool encrypt)` | `aescrypto.cpp:63` |

**Signals/Slots:** None declared.

**Static data member:** `static bool m_mtpEnabled` (`aescrypto.h:22`, initialised `aescrypto.cpp:18`)

**Key implementation notes:**
- All real crypto work is inside `#ifdef __arm__` guards; on non-ARM builds every method returns an empty `QByteArray`.
- IV is hardcoded at `aescrypto.cpp:124`: `"\x3d\xaf\xba\x42\x9d\x9e\xb4\x30\xb4\x22\xda\x80\x2c\x9f\xac\x41"`.
- CBC-AES via Linux kernel AF_ALG socket interface; key comes from MTP hardware (not from the caller).
- Chunk loop at `aescrypto.cpp:131` may call `sendmsg`/`read` with a zero-length final chunk when `in.size()` is an exact multiple of 1024.

---

### BleCentral (`platform/blecentral.h` + `platform/blecentral.cpp`)

**Classes:**
- `EM070::CharacteristicInfo` (helper, `blecentral.h:13`)
- `EM070::DescriptorInfo` (helper, `blecentral.h:30`)
- `EM070::BleCentral` (main class, `blecentral.h:45`)

**Includes:**
- `blecentral.h`
- `seriallogger.h`
- `<QTimer>`
- `<QDebug>`
- `<QLowEnergyConnectionParameters>`
- `<QObject>`, `<QBluetoothDeviceDiscoveryAgent>`, `<QBluetoothDeviceInfo>`, `<QLowEnergyController>` (via header)

**Public methods of `BleCentral`:**

| Method | Location |
|--------|----------|
| `explicit BleCentral(QObject *parent = nullptr)` | `blecentral.h:51`, impl `blecentral.cpp:14` |
| `~BleCentral()` | `blecentral.h:52`, impl `blecentral.cpp:42` |
| `void setEnabled(bool enable)` | `blecentral.h:54`, impl `blecentral.cpp:74` |
| `void setPeripheralAddress(const quint64 &address)` | `blecentral.h:56`, impl `blecentral.cpp:54` |
| `void setAuthorizationCode(const quint128 &uuid, const QByteArray &code)` | `blecentral.h:57`, impl `blecentral.cpp:68` |
| `State state() const` | `blecentral.h:59` (inline) |
| `QByteArrayList servicesUuid() const` | `blecentral.h:61`, impl `blecentral.cpp:303` |
| `QByteArrayList characteristicsUuid() const` | `blecentral.h:62`, impl `blecentral.cpp:312` |
| `QByteArrayList descriptionsUuid() const` | `blecentral.h:63`, impl `blecentral.cpp:321` |
| `bool readCharacteristic(const quint128 &uuid)` | `blecentral.h:65`, impl `blecentral.cpp:350` |
| `bool writeCharacteristic(const quint128 &uuid, const QByteArray &ba)` | `blecentral.h:66`, impl `blecentral.cpp:364` |
| `bool readDescriptor(const quint128 &uuid)` | `blecentral.h:67`, impl `blecentral.cpp:378` |
| `bool writeDescriptor(const quint128 &uuid, const QByteArray &ba)` | `blecentral.h:68`, impl `blecentral.cpp:396` |

**Signals of `BleCentral`:**

| Signal | Location |
|--------|----------|
| `void accessible(bool yes)` | `blecentral.h:71` |
| `void error(QBluetoothDeviceDiscoveryAgent::Error newError)` | `blecentral.h:74` |
| `void error(QLowEnergyController::Error newError)` | `blecentral.h:77` |
| `void error(QLowEnergyService::ServiceError newError)` | `blecentral.h:80` |
| `void characteristicChanged(const quint128 &uuid, const QByteArray &newValue)` | `blecentral.h:81` |
| `void characteristicRead(const quint128 &uuid, const QByteArray &value)` | `blecentral.h:82` |
| `void characteristicWritten(const quint128 &uuid, const QByteArray &newValue)` | `blecentral.h:83` |
| `void descriptorRead(const quint128 &uuid, const QByteArray &value)` | `blecentral.h:84` |
| `void descriptorWritten(const quint128 &uuid, const QByteArray &newValue)` | `blecentral.h:85` |

**Private slots / internal handlers (connected via signal-slot):**

| Slot | Location |
|------|----------|
| `void startDeviceDiscovery()` | `blecentral.cpp:101` |
| `void connectToDevice()` | `blecentral.cpp:143` |
| `void addDevice(const QBluetoothDeviceInfo &)` | `blecentral.cpp:110` |
| `void deviceDiscoveryFinished()` | `blecentral.cpp:125` |
| `void deviceDiscoveryError(QBluetoothDeviceDiscoveryAgent::Error)` | `blecentral.cpp:136` |
| `void deviceConnected()` | `blecentral.cpp:181` |
| `void deviceDisconnected()` | `blecentral.cpp:196` |
| `void addService(const QBluetoothUuid &newService)` | `blecentral.cpp:205` |
| `void serviceDiscoveryFinished()` | `blecentral.cpp:246` |
| `void serviceStateChanged(QLowEnergyService::ServiceState newState)` | `blecentral.cpp:257` |

---

## Test Coverage Search Results

**Test directory contents (`test/`):**
- `test_backgroundworker.cpp/.h`
- `test_canbus.cpp/.h`
- `test_dialog.cpp/.h`
- `test_ota.cpp/.h`
- `FleetIQ360App_5.2.2F.h`

**Search results for `AesCrypto`, `encrypt`, `descrypt`, `enableMtp`, `aescrypto` (case-insensitive) across all files in `test/`:** NO MATCHES FOUND.

**Search results for `BleCentral`, `blecentral`, `setEnabled`, `setPeripheralAddress`, `setAuthorizationCode`, `readCharacteristic`, `writeCharacteristic`, `readDescriptor`, `writeDescriptor`, `servicesUuid`, `characteristicsUuid`, `descriptionsUuid` across all files in `test/`:** NO MATCHES FOUND.

Neither `AesCrypto` nor `BleCentral` is referenced anywhere in the test directory. There are no test files dedicated to either class.

---

## Findings

---

**A12-1** · CRITICAL · Missing Test Coverage – Cryptographic Component
**File:** `platform/aescrypto.cpp:150-160`
**Description:** The `AesCrypto` class, which provides the sole encryption and decryption interface for the product (`encrypt()` and `descrypt()`), has zero test coverage in the test suite. No test file includes the header, instantiates the class, or calls either public method. This means there is no automated verification that the cipher produces correct output, that encrypt followed by decrypt returns the original plaintext, or that the implementation behaves correctly across input sizes.
**Fix:** Create `test/test_aescrypto.cpp`. Because the ARM-only `#ifdef __arm__` guard makes the underlying kernel socket path unavailable on a host build system, introduce a thin seam (e.g., a virtual or function-pointer-based `aes()` backend) so unit tests can supply a stub. At minimum, on an ARM target or in an integration CI environment, add Known-Answer Tests (KATs) using NIST CAVP CBC-AES test vectors: supply a known plaintext and key, verify the ciphertext matches the expected value, then decrypt and verify round-trip equality.

---

**A12-2** · CRITICAL · No Known-Answer Tests (KAT) for AES Implementation
**File:** `platform/aescrypto.cpp:63-148`
**Description:** No KAT vectors are present anywhere in the test suite for the AES-CBC implementation. A KAT feeds a fixed, published plaintext/key/IV tuple into the cipher and asserts the resulting ciphertext matches a reference value from a standards body (e.g., NIST SP 800-38A). Without KATs, a regression in the underlying crypto driver or a misconfiguration of the IV (which is hardcoded at line 124) would go undetected.
**Fix:** Add NIST SP 800-38A CBC test vectors as static test cases. Run them as part of a `QTest`-based test function that directly calls `AesCrypto::encrypt()` and compares the output to the published expected ciphertext. These tests should be gated to run on the ARM target (or a compatible emulator) where the AF_ALG path is available.

---

**A12-3** · HIGH · No Boundary / Edge-Case Tests for AesCrypto
**File:** `platform/aescrypto.cpp:126-141`
**Description:** The following boundary conditions are entirely untested:
1. **Empty input** (`in.size() == 0`): The loop at line 131 (`i < in.size() - 1024`) evaluates to `0 < -1024` which, because `in.size()` returns a signed `int`, results in a large positive value due to unsigned wrap-around. The loop body would then execute with an out-of-range pointer, causing undefined behaviour or a crash.
2. **Input size not a multiple of AES block size (16 bytes)**: CBC-AES requires plaintext to be padded to a multiple of the block size. The code performs no padding and does not document or enforce this requirement. Calling `encrypt()` with, for example, a 15-byte or 17-byte input will silently pass a non-block-aligned length to the kernel, producing an implementation-defined result or an error that is silently swallowed.
3. **Input exactly 1024 bytes (loop boundary)**: When `in.size() == 1024`, the loop condition `i < in.size() - 1024` equals `0 < 0` and the loop body is skipped; the tail path then sends 1024 bytes via `sendmsg(tfd, &msg, 0)`. This path is the one normally taken for the last (or only) segment, so 1024 bytes should be handled correctly, but it is untested.
**Fix:** Add unit/integration test cases for empty input (assert that an empty `QByteArray` is returned without crashing), for inputs of sizes 1, 15, 16, 17, 1023, 1024, 1025, and 2048 bytes. Fix the signed-integer underflow bug in the loop guard before adding tests.

---

**A12-4** · CRITICAL · Missing Test Coverage – BleCentral Component
**File:** `platform/blecentral.cpp`, `platform/blecentral.h`
**Description:** The `BleCentral` class, which manages all BLE device discovery, connection lifecycle, service and characteristic enumeration, and data read/write operations, has zero test coverage. Not one test file references it. The following observable behaviours are completely untested:
- Device discovery start/stop and retry on failure.
- Correct state machine transitions (`Disabled` → `Discovering` → `Ready` and back).
- Connection timeout and reconnect logic (the `m_reconnectTimer` path).
- Service and characteristic enumeration (the `addService` / `serviceStateChanged` chain).
- Authorization code write (`serviceStateChanged:274-275`).
- `readCharacteristic`, `writeCharacteristic`, `readDescriptor`, `writeDescriptor` return values for missing UUID, non-readable characteristic, and missing parent service.
- Emission of `accessible(true/false)` and `error()` signals at correct lifecycle points.
**Fix:** Create `test/test_blecentral.cpp`. Use Qt's `QSignalSpy` to observe signals. Provide mock/stub implementations of `QBluetoothDeviceDiscoveryAgent` and `QLowEnergyController` (or use dependency injection to replace them) so that tests can simulate device-found, connected, disconnected, and error events without requiring real hardware.

---

**A12-5** · HIGH · Disconnection Handling Not Tested
**File:** `platform/blecentral.cpp:196-202`
**Description:** `deviceDisconnected()` sets state to `Discovering`, emits `accessible(false)`, and starts `m_reconnectTimer` with `RECONNECT_RETRY_WAIT` (2000 ms). The reconnect path fires a lambda that calls `setEnabled(false)` then `setEnabled(true)`, which tears down the controller and restarts discovery. This entire reconnect loop is untested. A regression here — such as the state guard at line 76 preventing re-enable — would cause the device to silently stop attempting to reconnect after a drop, with no automated detection.
**Fix:** In the `BleCentral` test suite, simulate a disconnection event (by calling `deviceDisconnected()` directly or through a mock controller signal) and use `QSignalSpy` to assert that `accessible(false)` is emitted and that the reconnect timer fires within the expected window, ultimately transitioning back to `Discovering` state.

---

**A12-6** · HIGH · Service Enumeration with Empty Service List Not Tested
**File:** `platform/blecentral.cpp:246-255`
**Description:** `serviceDiscoveryFinished()` guards against an empty `m_services` list at line 248 and returns early without emitting any signal. This means a connected device that advertises no services silently leaves `BleCentral` in a non-`Ready` state indefinitely (the reconnect timer from `deviceConnected()` is still running and will eventually reset the connection). This failure mode and its recovery are untested.
**Fix:** Add a test case that simulates a successful connection followed by `serviceDiscoveryFinished()` with an empty service list. Assert that `accessible(true)` is never emitted, that the reconnect timer eventually fires, and that the state machine returns to `Discovering`.

---

## Summary Table

| ID | Severity | Category | Component | One-line description |
|----|----------|----------|-----------|----------------------|
| A12-1 | CRITICAL | Missing Test Coverage | AesCrypto | No tests exist for `encrypt()` or `descrypt()` |
| A12-2 | CRITICAL | Missing KAT | AesCrypto | No NIST Known-Answer Tests for AES-CBC implementation |
| A12-3 | HIGH | Boundary Cases | AesCrypto | Empty input, non-block-aligned input, and chunk-boundary sizes are untested and trigger UB |
| A12-4 | CRITICAL | Missing Test Coverage | BleCentral | No tests exist for any BleCentral method or signal |
| A12-5 | HIGH | Disconnection Handling | BleCentral | Reconnect-after-disconnect path is entirely untested |
| A12-6 | HIGH | Edge Case | BleCentral | Empty service list after connection leaves state machine stalled; untested |

**Overall assessment:** Both `AesCrypto` and `BleCentral` have 0% test coverage. `AesCrypto` is a security-critical component whose correctness cannot be verified without Known-Answer Tests; additionally the implementation contains a potential integer underflow in its loop guard for empty inputs. `BleCentral` is a complex stateful component whose reconnect and service-enumeration paths contain subtle failure modes that are entirely undetected by the current suite.
