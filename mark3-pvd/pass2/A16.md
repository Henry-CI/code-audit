# Audit Report – Agent A16 (Pass 2: Test Coverage)

**Audit run:** 2026-02-28-01
**Agent:** A16
**Pass:** 2 – Test Coverage
**Branch confirmed:** master (verified via `git branch --show-current`)

---

## Files Under Review

| # | File |
|---|------|
| 1 | `platform/pwmbacklight.h` |
| 2 | `platform/pwmbacklight.cpp` |
| 3 | `platform/pwmbeeper.h` |
| 4 | `platform/pwmbeeper.cpp` |
| 5 | `platform/seriallogger.h` |
| 6 | `platform/seriallogger.cpp` |

---

## Reading Evidence

### platform/pwmbacklight.h

**Includes:** `<QObject>`, `<QFile>`, `<QQueue>`, `<QMap>`

**Note:** Header guard mismatch — `#ifndef PWMBACKLIGHT_H` on line 1 but `#define BRIGHTNESS_H` on line 2 (macro name is `BRIGHTNESS_H`, not `PWMBACKLIGHT_H`). This means double-include protection is broken.

**Enum:**
- `State {NoChange, Brighter, Darker}` (line 15)

**Public methods:**
| Line | Signature |
|------|-----------|
| 16 | `explicit PwmBacklight(QObject *parent = nullptr)` |
| 17 | `~PwmBacklight()` |
| 18 | `void setAutoBrightness(bool enable)` |
| 19 | `bool isAutoBrightness() const` (inline) |
| 21 | `static quint8 brightness()` |
| 22 | `static void setBrightness(quint8 val)` |

**Signals:**
| Line | Signature |
|------|-----------|
| 25 | `void luxRead(int lux)` |

**Protected:**
| Line | Signature |
|------|-----------|
| 28 | `void timerEvent(QTimerEvent *)` |

**Private methods:**
| Line | Signature |
|------|-----------|
| 31 | `void parse(int lux)` |
| 32 | `void adjust(int lux)` |
| 33 | `int readLux()` |

---

### platform/pwmbacklight.cpp

**Includes:** `"pwmbacklight.h"`, `<QTimerEvent>`, `<QFile>`, `<QDebug>`

**Sysfs paths used:**
- `FILE_BRIGHTNESS` = `/sys/devices/platform/pwm-backlight.0/backlight/pwm-backlight.0/brightness` (line 6)
- `FILE_ALS_POWER`  = `/sys/devices/platform/nuc970-i2c0/i2c-0/0-0044/power_state` (line 7)
- `FILE_ALS_RANGE`  = `/sys/devices/platform/nuc970-i2c0/i2c-0/0-0044/range` (line 8)
- `FILE_ALS_LUX`    = `/sys/devices/platform/nuc970-i2c0/i2c-0/0-0044/lux` (line 9)

**Notable logic:**
- `brightness()` (line 179): opens `FILE_BRIGHTNESS` read-only; returns `255` on open failure instead of an error sentinel (line 184).
- `setBrightness(quint8 val)` (line 191): opens `FILE_BRIGHTNESS` write-only; silently returns (no error propagation) on failure (line 196); does not flush after write (line 200).
- `adjust(int lux)` (line 173): calls `m_brightnessMap.upperBound(lux).value()` (line 175). When `lux` exceeds all keys the iterator is `end()` and `.value()` is undefined behaviour.
- `readLux()` returns `0` for negative values (line 80), valid for hardware but silently masks sensor errors.
- `parse()` macro `X1P1` / `X1P2` use `333 >> 8 = 1.30` not `1.1` / `1.2` — commented-out correct constants indicate deliberate deviation but no test verifies threshold behaviour.

---

### platform/pwmbeeper.h

**Includes:** `<QObject>`, `<QFile>`; forward-declares `QTimer`

**Enum:**
- `BeepType {BeepOn, BeepSilent, BeepOff}` (line 15) — declared but never used anywhere in the file or implementation.

**Public methods:**
| Line | Signature |
|------|-----------|
| 18 | `explicit PwmBeeper(bool autoDelete = false, QObject *parent = nullptr)` |
| 19 | `~PwmBeeper()` |
| 20 | `void setFrequency(quint16 frequency)` (inline) |
| 21 | `void beep(quint16 milliseconds)` |
| 22 | `void beep(quint16 frequency, quint16 milliseconds)` |
| 23 | `void beep(qint16 count, quint16 msecOn, quint16 msecOff)` |
| 24 | `void stop()` |

**Private methods:**
| Line | Signature |
|------|-----------|
| 27 | `void timeout()` |
| 28 | `void setBeep(bool on)` |

---

### platform/pwmbeeper.cpp

**Includes:** `"pwmbeeper.h"`, conditionally `<linux/input.h>` (ARM only), `<QTimer>`, `<QDebug>`

**Device path:** `FILE_BEEPER` = `/dev/input/event3` (line 8); overridable via `QT_BUZZER_EVENT` env var (lines 19–23).

**Notable logic:**
- `setBeep(bool on)` (lines 60–82): hardware write is conditionally compiled under `#ifdef __arm__` (lines 65–79). On non-ARM platforms the function only flips `m_beeping` without any I/O.
- `m_file.write()` result is discarded on line 77; flush is called but write error is never checked.
- `beep(qint16 count, ...)` (line 95): `count = 0` is accepted and stored; `m_count` is decremented in `timeout()` (line 53) reaching −1, at which point `if (--m_count > 0)` is false and `deleteLater()` may be called prematurely. Negative `count` wraps `qint16` down through 32 768 repetitions.
- Constructor fails silently if `m_file.open` fails (lines 25–28); callers receive no indication.

---

### platform/seriallogger.h

**Includes:** `"userport.h"`

**Public methods:**
| Line | Signature |
|------|-----------|
| 9  | `static void log(const QByteArray &message)` |
| 10 | `static void setSerialPort(EM070::UserPort *serial)` |

**Private static member:**
- `static EM070::UserPort *m_serial` (line 13)

---

### platform/seriallogger.cpp

**Includes:** `"seriallogger.h"`, `<QDateTime>`, `<QFile>`

**Preprocessor:**
- `ENABLE_SL_FILE 0` (line 5) — file-based logging is **permanently compiled out**.
- `SERIAL_LOG_FILE` = `/mnt/sd/sl.log` (line 6) — dead constant.

**Notable logic:**
- `log()` (line 15): if `m_serial` is null, silently returns without logging (lines 32–33).
- File logging block (lines 18–29) is guarded by `#if ENABLE_SL_FILE` which evaluates to `0`; the static `QFile` inside the block is never constructed, rotation and flush logic are permanently disabled.
- `m_serial->response(ba)` (line 35): return value is discarded; no error path if the serial port write fails.
- No thread-safety mechanism on the static `m_serial` pointer; simultaneous calls from multiple threads could read a torn pointer.

---

## Test Coverage Search Results

**Search performed:** grep for `PwmBacklight`, `PwmBeeper`, `SerialLogger`, `setBrightness`, `brightness`, `setAutoBrightness`, `readLux`, `setBeep`, `beep`, `setFrequency`, `seriallogger`, `pwmbacklight`, `pwmbeeper` (case-insensitive) across the entire `test/` directory.

**Result: zero matches.**

Test files present in `test/`:
- `test_backgroundworker.cpp` / `.h`
- `test_canbus.cpp` / `.h`
- `test_dialog.cpp` / `.h`
- `test_ota.cpp` / `.h`

All four test suites target `BackgroundWorker`, CAN bus, dialog UI, and OTA. None include or reference any of the three platform modules under review. `Makefile.test` confirms the source files are compiled into the test binary but no `QTEST_*` or manual test function references any symbol from these modules.

**Test coverage: 0% for all three classes.**

---

## Findings

---

**A16-1** · HIGH · Missing Test Coverage – Hardware Write Path (PwmBacklight)
**File:** `platform/pwmbacklight.cpp:191-201`
**Description:** `setBrightness()` writes directly to the sysfs brightness node. There is no test that verifies the correct value is written, that the file is opened with the expected flags, or that the function handles an open failure gracefully. On the target hardware this controls display backlight; a silent failure leaves the display in an unknown state.
**Fix:** Add a unit test using a QTemporaryFile or a mock QFile to inject a fake brightness sysfs path (via a settable path variable or dependency injection). Assert that the byte representation of the supplied `quint8` value is written, and verify the no-open path does not crash or write stale data.

---

**A16-2** · HIGH · Missing Test Coverage – Undefined Behaviour on Lux Exceeding Map Maximum (PwmBacklight)
**File:** `platform/pwmbacklight.cpp:175`
**Description:** `adjust(int lux)` calls `m_brightnessMap.upperBound(lux).value()`. The brightness map contains exactly two entries (`100 → 1`, `4000 → 255`). If `lux` is greater than `4000`, `upperBound` returns `end()` and calling `.value()` on `end()` is undefined behaviour in Qt's QMap. This can corrupt the brightness register or crash the process. No test verifies behaviour at or above the maximum lux value.
**Fix:** Add a guard in `adjust()` to clamp the iterator before dereferencing (e.g., use `--it` when `it == end()`), or use the last value explicitly. Add unit tests for `lux = 4001` and `lux = INT_MAX` to confirm safe clamping.

---

**A16-3** · HIGH · Missing Test Coverage – Hardware Write Path (PwmBeeper)
**File:** `platform/pwmbeeper.cpp:60-82`
**Description:** `setBeep()` performs a raw `m_file.write()` of a `struct input_event` to `/dev/input/event3`. No test verifies the structure is correctly populated (type, code, value), the write reaches the device, or that a write failure is detected. The return value of `write()` is unconditionally discarded.
**Fix:** Extract the device path to a configurable member (it already uses `QT_BUZZER_EVENT` env var). Add tests that set that env var to a temporary file, invoke `beep()`, and assert the binary content written matches the expected `input_event` layout for both on and off transitions.

---

**A16-4** · MEDIUM · Missing Test Coverage – Zero and Negative Beep Count Edge Cases (PwmBeeper)
**File:** `platform/pwmbeeper.cpp:95-110` and `platform/pwmbeeper.cpp:44-57`
**Description:** `beep(qint16 count, ...)` accepts `count = 0`: the beeper is switched on immediately and `m_timerOn` fires, decrementing `m_count` to `−1`, which is not `> 0`, so the beep cycle ends but no incorrect sequence is observable. However, a negative `count` is accepted without validation; the signed decrement will cycle through the full `qint16` range (32 767 additional iterations), holding the beeper on far longer than intended. No test exercises these edge cases.
**Fix:** Add a guard in `beep(qint16 count, ...)` that treats `count <= 0` as a no-op (or documents and enforces minimum `count = 1`). Add unit tests for `count = 0`, `count = -1`, and `count = 1` to assert correct on/off timing and `deleteLater` invocation with `autoDelete = true`.

---

**A16-5** · MEDIUM · Missing Test Coverage – SerialLogger Write and Null Port Handling
**File:** `platform/seriallogger.cpp:15-36`
**Description:** `SerialLogger::log()` silently discards the message when `m_serial` is null. No test verifies that: (a) messages are forwarded when a port is set, (b) messages are silently dropped when no port is set, or (c) the timestamp prefix is correctly formatted. The return value of `m_serial->response()` is also discarded with no error path tested.
**Fix:** Add unit tests that (1) call `log()` with `m_serial = nullptr` and verify no crash, (2) set a mock `UserPort`, call `log()`, and assert the captured output contains the expected millisecond timestamp prefix and the supplied message bytes.

---

**A16-6** · MEDIUM · Missing Test Coverage – File-Based Log Path is Dead Code (SerialLogger)
**File:** `platform/seriallogger.cpp:5-6` and `platform/seriallogger.cpp:18-29`
**Description:** `ENABLE_SL_FILE` is hardcoded to `0`. The entire file-based logging block — including the static `QFile` open, write, flush, and implicitly any rotation that would be needed — is permanently compiled out. The dead constant `SERIAL_LOG_FILE = "/mnt/sd/sl.log"` remains in the source. If file logging is ever re-enabled there is no test to verify the file is created, written correctly, flushed, or handled when the SD card path is unavailable.
**Fix:** Either remove the dead block and the constant entirely (if file logging is permanently abandoned), or re-enable it under a runtime flag and add tests covering: successful write to a temp path, write when the path does not exist, and verification that `flush()` is called after each write.

---

**A16-7** · MEDIUM · Missing Test Coverage – sysfs Open Failure Return Sentinel (PwmBacklight)
**File:** `platform/pwmbacklight.cpp:179-188`
**Description:** `brightness()` returns `255` when the sysfs brightness file cannot be opened. `255` is also a valid maximum brightness value. A caller cannot distinguish "hardware at maximum brightness" from "file open failed." No test exercises the failure path or asserts the return value.
**Fix:** Change the failure sentinel to a value outside the valid range (e.g., return a `std::optional<quint8>` or use a separate error output parameter), and add a unit test that supplies a non-existent file path and asserts the expected error indicator is returned.

---

**A16-8** · MEDIUM · Missing Test Coverage – PwmBacklight Constructor Sysfs Failures
**File:** `platform/pwmbacklight.cpp:22-64`
**Description:** The constructor opens four sysfs paths in sequence. If any of the first three (`FILE_ALS_RANGE`, `FILE_ALS_POWER`, `FILE_ALS_LUX`) fail to open, the constructor returns early with the object partially initialised. Subsequent calls to `setAutoBrightness(true)` guard on `m_alsLuxFile.isOpen()` and silently do nothing, but no test verifies this partial-init behaviour or asserts that the object remains safe to destroy.
**Fix:** Add tests that supply a non-existent `FILE_ALS_LUX` path, construct a `PwmBacklight`, call `setAutoBrightness(true)`, and verify the call is a no-op without crash. Also verify that the destructor on a partially-initialised object does not double-close files.

---

**A16-9** · MEDIUM · Missing Test Coverage – PwmBeeper Constructor File Open Failure
**File:** `platform/pwmbeeper.cpp:25-28`
**Description:** If `m_file.open(QIODevice::ReadWrite)` fails, the constructor logs a critical message and returns, leaving `m_file` closed. All subsequent `beep()` calls check `m_file.isOpen()` and silently return. However, `autoDelete` logic in the failed `beep()` path (line 98–99) calls `deleteLater()` on the object from within its own `beep()` call which may surprise callers who hold the pointer. No test exercises this code path.
**Fix:** Test construction with an invalid device path (e.g., `QT_BUZZER_EVENT=/nonexistent`), call `beep()`, and assert no crash; also assert that if `autoDelete = true` the object schedules deletion rather than calling it synchronously.

---

**A16-10** · LOW · Broken Header Include Guard (PwmBacklight)
**File:** `platform/pwmbacklight.h:1-2`
**Description:** The header guard opens with `#ifndef PWMBACKLIGHT_H` but defines `BRIGHTNESS_H`. The guard never actually fires: a second inclusion of `pwmbacklight.h` in a translation unit will pass the `#ifndef PWMBACKLIGHT_H` check (since that macro was never defined) and re-declare the class, causing a compiler error. No test exercises multi-inclusion scenarios.
**Fix:** Change line 2 to `#define PWMBACKLIGHT_H` to match the guard name on line 1. Add a compile-time test (or a CI step) that includes the header twice in the same translation unit to confirm idempotency.

---

**A16-11** · LOW · Unused Enum `BeepType` (PwmBeeper)
**File:** `platform/pwmbeeper.h:15`
**Description:** The public enum `BeepType {BeepOn, BeepSilent, BeepOff}` is declared but never referenced anywhere in the implementation, tests, or call sites found in the repository. Dead public API in a hardware driver creates confusion about intended interface.
**Fix:** Either implement `BeepType` as the parameter type for the `beep()` overloads (replacing the raw boolean `setBeep()` parameter), or remove the enum. Add a test that verifies `BeepSilent` maps to the expected hardware behaviour if the enum is kept.

---

**A16-12** · LOW · Missing Test Coverage – `luxRead` Signal Emission (PwmBacklight)
**File:** `platform/pwmbacklight.cpp:101`
**Description:** `timerEvent()` emits `luxRead(lux)` on every polling interval. No test uses `QSignalSpy` to verify the signal is emitted with the correct lux value, or that it is not emitted when auto-brightness is disabled.
**Fix:** Add a `QSignalSpy` test that enables auto-brightness, processes a timer event (or advances the timer in a test event loop), and asserts `luxRead` is emitted with the expected value.

---

## Summary Table

| ID | Severity | Category | File | Description |
|----|----------|----------|------|-------------|
| A16-1 | HIGH | Missing Test – Hardware Write | `pwmbacklight.cpp:191` | `setBrightness()` sysfs write never tested |
| A16-2 | HIGH | Missing Test – UB / Edge Case | `pwmbacklight.cpp:175` | `upperBound` past-end dereference on lux > 4000 |
| A16-3 | HIGH | Missing Test – Hardware Write | `pwmbeeper.cpp:77` | `input_event` sysfs write never tested |
| A16-4 | MEDIUM | Missing Test – Edge Case | `pwmbeeper.cpp:95` | Zero/negative beep count causes runaway loop |
| A16-5 | MEDIUM | Missing Test – Null Guard | `seriallogger.cpp:32` | Null serial port silent drop never tested |
| A16-6 | MEDIUM | Missing Test – Dead Code | `seriallogger.cpp:18` | File logging permanently disabled, never tested |
| A16-7 | MEDIUM | Missing Test – Sentinel Ambiguity | `pwmbacklight.cpp:184` | `brightness()` failure returns `255` (valid value) |
| A16-8 | MEDIUM | Missing Test – Partial Init | `pwmbacklight.cpp:22` | Partial constructor init on sysfs open failures |
| A16-9 | MEDIUM | Missing Test – File Open Failure | `pwmbeeper.cpp:25` | Constructor open failure + `autoDelete` path untested |
| A16-10 | LOW | Defect – Header Guard | `pwmbacklight.h:2` | Guard macro name mismatch breaks double-include protection |
| A16-11 | LOW | Dead Code | `pwmbeeper.h:15` | Unused `BeepType` enum in public API |
| A16-12 | LOW | Missing Test – Signal | `pwmbacklight.cpp:101` | `luxRead` signal emission never verified with spy |

**Total findings: 12**
- HIGH: 3
- MEDIUM: 6
- LOW: 3
