# Security Audit – Pass 2: Test Coverage
**Agent:** A08
**Audit Run:** 2026-02-28-01
**Branch Confirmed:** master (verified via `git branch --show-current`)
**Date:** 2026-02-28

---

## Files Under Review

| File | Lines |
|------|-------|
| `comm/canmonitor.h` | 150 |
| `comm/canmonitor.cpp` | 1656 |
| `comm/canstatehandler.h` | 53 |
| `comm/canstatehandler.cpp` | 207 |

---

## Reading Evidence

### canmonitor.h – Class: `CanMonitor` (inherits QObject)

**Includes:**
- `app/cigconfigs.h`
- `<QObject>`, `<QFile>`, `<QMap>`, `<QVector>`
- Forward declarations: `EM070::CanBus`, `QTimer`

**Public Methods:**

| Line | Method | Signature |
|------|--------|-----------|
| 20 | Constructor | `explicit CanMonitor(EM070::CanBus *canBus)` |
| 22 | `readCanConfig` | `bool readCanConfig()` |
| 23 | `readOldCanConfig` | `bool readOldCanConfig()` |
| 24 | `saveCanConfig` | `void saveCanConfig()` |
| 25 | `calculateCanCrc` | `void calculateCanCrc()` |
| 28 | `canCrc32` | `quint32 canCrc32() const` (inline) |
| 30 | `setEnabled` | `void setEnabled(bool enable)` |
| 32 | `clearCanConfig` | `void clearCanConfig()` |
| 33 | `canBusConfig` | `QByteArray canBusConfig() const` |
| 34 | `setCanBusConfig` | `bool setCanBusConfig(const QByteArray &config)` |
| 35 | `canPgnConfig` | `QByteArray canPgnConfig() const` |
| 36 | `setCanPgnConfig` | `bool setCanPgnConfig(const QByteArray &config)` |
| 37 | `canSpnConfig` | `QByteArray canSpnConfig() const` |
| 38 | `setCanSpnConfig` | `bool setCanSpnConfig(const QByteArray &config)` |
| 39 | `canAttConfig` | `QByteArray canAttConfig() const` |
| 40 | `setCanAttConfig` | `bool setCanAttConfig(const QByteArray &config)` |
| 41 | `canLinConfig` | `QByteArray canLinConfig() const` |
| 42 | `setCanLinConfig` | `bool setCanLinConfig(const QByteArray &config)` |
| 43 | `canBydConfig` | `QByteArray canBydConfig() const` |
| 44 | `setCanBydConfig` | `bool setCanBydConfig(const QByteArray &config)` |
| 45 | `canLin2Config` | `QByteArray canLin2Config() const` |
| 46 | `setCanLin2Config` | `bool setCanLin2Config(const QByteArray &config)` |
| 48 | `isXferEnabled` | `bool isXferEnabled() const` (inline) |
| 49 | `attributeName` | `QByteArray attributeName(quint8 index) const` (inline) |
| 50 | `attributeType` | `CIGCONF::CanAttributeType attributeType(quint8 index) const` (inline) |
| 52 | `setVdiAccess` | `void setVdiAccess(bool access, bool inhibit)` |
| 53 | `enableVdi` | `void enableVdi(bool enable)` |

**Signals:**

| Line | Signal |
|------|--------|
| 60 | `void resetCanStates(bool resetLast)` |
| 61 | `void stateUpdated(quint8 index, quint32 state)` |

**Private Methods (referenced in test scope via `friend class TestCanbus`):**

| Line | Method |
|------|--------|
| 101 | `perfTimer()` |
| 107 | `readCanConfig()` |
| 418 | `findPgnIndex(quint32 rspId, quint32 reqId)` |
| 437 | `newPgnIndex()` |
| 447 | `childSpnIndexes(quint8 pgnIndex)` |
| 1193 | `attributePollingRate(quint32 namePattern)` |
| 1231 | `createRequest(quint8 spnIndex, quint32 pollingRate)` |
| 1301 | `updateBusConfig()` |
| 1313 | `updateRequests()` |
| 1369 | `readCanFrame(quint32 id, const QByteArray &ba)` |
| 1474 | `updateState(quint8 spnIndex, quint64 data)` |
| 1526 | `updateSpnState(quint8 spnIndex, quint64 data)` |
| 1600 | `initVdi()` |
| 1627 | `configureVdiAccessRequest()` |

---

### canstatehandler.h – Class: `CanStateHandler` (inherits QObject)

**Includes:**
- `app/cigconfigs.h`
- `<QObject>`
- Forward declarations: `CanMonitor`, `QTimer`

**Public Methods:**

| Line | Method |
|------|--------|
| 14 | `enum DigitalFormat {SessionFormat, UsageFormat, OnDemandFormat}` |
| 16 | `explicit CanStateHandler(CanMonitor *canMonitor)` |
| 17 | `void updateIdleTimer()` |
| 18 | `QByteArray canStates(DigitalFormat format, bool autoReset)` |
| 19 | `void resetStates(bool resetLast)` |

**Signals:**

| Line | Signal |
|------|--------|
| 22 | `void idleTimeout()` |

**Private Methods:**

| Line | Method |
|------|--------|
| 45 | `void updateState(quint8 index, quint32 state)` (private slot, connected from `CanMonitor::stateUpdated`) |

---

## Test Coverage Analysis

### Test Infrastructure

- Test project file: `mk3-test.pro` – defines `UNIT_TEST`, compiles both `comm/canmonitor.cpp` and `comm/canstatehandler.cpp`
- Test class: `TestCanbus` (declared friend of `CanMonitor` via `#ifdef UNIT_TEST` at `canmonitor.h:55–57`)
- Test file: `test/test_canbus.cpp` – contains a single test method: `test_vdiMode()`
- Test framework: Qt Test (`QTest`)

### Coverage Table – CanMonitor Public Methods

| Method | Tested | Test Name | Notes |
|--------|--------|-----------|-------|
| `CanMonitor()` constructor | Indirect | `initTestCase` | Via `BackgroundWorker::initialiseCanbus1()` |
| `readCanConfig()` | No | – | No direct test; only invoked implicitly at construction |
| `readOldCanConfig()` | No | – | Not tested at all |
| `saveCanConfig()` | No | – | Not tested |
| `calculateCanCrc()` | No | – | Not tested |
| `canCrc32()` | No | – | Not tested |
| `setEnabled()` | No | – | Not tested |
| `clearCanConfig()` | Indirect | `test_vdiMode` | Via `at^clrcan` AT command |
| `canBusConfig()` | Partial | `test_vdiMode` | Only VDI mode path checked |
| `setCanBusConfig()` | Partial | `test_vdiMode` | Only via VDI init path |
| `canPgnConfig()` | No | – | Not tested |
| `setCanPgnConfig()` | No | – | Not tested |
| `canSpnConfig()` | No | – | Not tested |
| `setCanSpnConfig()` | No | – | Not tested |
| `canAttConfig()` | Partial | `test_vdiMode` | Only VDI mode values checked |
| `setCanAttConfig()` | Partial | `test_vdiMode` | Only via VDI init path |
| `canLinConfig()` | Partial | `test_vdiMode` | Only VDI mode values checked |
| `setCanLinConfig()` | Partial | `test_vdiMode` | Only via VDI init path |
| `canBydConfig()` | No | – | Not tested |
| `setCanBydConfig()` | No | – | Not tested |
| `canLin2Config()` | No | – | Not tested |
| `setCanLin2Config()` | No | – | Not tested |
| `isXferEnabled()` | No | – | Not tested |
| `attributeName()` | No | – | Not tested directly |
| `attributeType()` | No | – | Not tested directly |
| `setVdiAccess()` | Partial | `test_vdiMode` | Signal pathway tested, but not non-VDI guard |
| `enableVdi()` | Indirect | `test_vdiMode` | enable=true path only |

### Coverage Table – CanMonitor Private Methods

| Method | Tested | Notes |
|--------|--------|-------|
| `readCanFrame()` | No | Core CAN frame processing; never exercised in tests |
| `updateState()` | No | Never exercised in tests |
| `updateSpnState()` | No | Never exercised in tests |
| `findPgnIndex()` | No | Not tested |
| `newPgnIndex()` | No | Not tested |
| `childSpnIndexes()` | No | Not tested |
| `attributePollingRate()` | No | Not tested |
| `createRequest()` | Indirect | Exercised through VDI init only; LindeExtended/J1939/BydCan/Linde1202 paths untested |
| `updateBusConfig()` | Partial | Called in `forceCanbusUpdate()` helper, but only checks VDI state |
| `updateRequests()` | Partial | Called in `forceCanbusUpdate()` helper, but only checks VDI state |
| `initVdi()` | Indirect | Called through `enableVdi(true)` path |
| `configureVdiAccessRequest()` | Partial | Three states tested (access+inhibit, access+no-inhibit, no access) |
| `perfTimer()` | No | Not tested (disabled by `PERF_MON=0`) |
| `calculateCanCrc()` | No | Not tested |

### Coverage Table – CanStateHandler

| Method | Tested | Notes |
|--------|--------|-------|
| `CanStateHandler()` constructor | No | Not directly tested; constructed as part of BackgroundWorker but no assertions made |
| `updateIdleTimer()` | No | No test covers idle timer configuration or triggering |
| `canStates()` | No | No test calls this method directly or verifies its output |
| `resetStates()` | No | Connected via signal; not directly verified in any test |
| `updateState()` (private slot) | No | No test injects `stateUpdated` signals to verify state machine transitions |
| `idleTimeout` signal | No | Never verified to fire in tests |

---

## Findings

**A08-1** · CRITICAL · Missing Test Coverage – Core CAN Frame Processing
**File:** `comm/canmonitor.cpp:1369`
**Description:** `readCanFrame()` is the primary entry point for all inbound CAN bus data. It dispatches across four protocol branches (J1939, LindeExtended, BydCan, Linde1202), each with distinct bit-extraction and frame-matching logic. Zero tests exercise this method. Malformed, undersized, or adversarially crafted CAN frames are never validated under test. The `LindeExtended` branch pads short frames silently (`b.append(8-b.size(), (char)0)`) – padding behaviour is untested. The `BydCan` branch returns early for frames shorter than 8 bytes but this guard is untested. The Linde1202 branch applies a response mask (`spnResponseMask`) to filter frames – this filtering is untested.
**Fix:** Add unit tests that inject synthetic CAN frames via a mock `CanBus::read` signal for each protocol variant. Include: correct frames, frames shorter than 8 bytes, frames with PGN not in the config table, frames where the mask filter should suppress processing, and maximum-length edge cases.

---

**A08-2** · CRITICAL · Missing Test Coverage – SPN State Update and Bit Extraction
**File:** `comm/canmonitor.cpp:1526`
**Description:** `updateSpnState()` implements a custom MSB-first bit extraction algorithm at lines 1546–1558. It computes `bitA` and `bitR` from `spnConfig.offset`, then extracts bits. An arithmetic edge case exists at line 1538: `spnMask = (1U << spnConfig.width) - 1`. If `spnConfig.width` is 32, this expression causes undefined behaviour in C++ (left-shifting a 32-bit value by its full width). The width field is validated to be in range 1–255 by `setCanSpnConfig()`, but is read directly from file in `readCanConfig()` / `readOldCanConfig()` without re-validation. No tests exercise any opcode path ('>', '=', '-', 'b') nor the BCD decoder at lines 1574–1587.
**Fix:** Add unit tests for each opcode ('>', '=', '-', 'b') with known input data and expected state output. Add a test for width=32 and width=0. Add a test where data read from a corrupted config file contains width=32 to confirm the UB path cannot be reached via file input without validation.

---

**A08-3** · HIGH · Missing Test Coverage – Config File Parsing (readCanConfig / readOldCanConfig)
**File:** `comm/canmonitor.cpp:107`, `comm/canmonitor.cpp:209`
**Description:** `readCanConfig()` and `readOldCanConfig()` perform `memcpy` of fixed-size binary structs from a file into internal arrays. The file size is checked before reading, but the CRC covers the entire blob: no per-field range validation is performed after the `memcpy`. Fields such as `SpnConfig.pgnIndex` (used as an array index at line 1234), `AttConfig.spnIndex` (used as an array index at line 1331), and `AttConfig.spnIndex2` (used at line 1337) could contain out-of-bounds values if the file is corrupt or tampered with. No test exercises reading a file with a valid CRC but out-of-range index fields, nor reading a file where the version field is unexpected (e.g., ver=0 or ver=3).
**Fix:** Add tests for: (1) missing config file returns false; (2) file with invalid CRC returns false; (3) file with valid CRC but unsupported version returns false; (4) file with valid CRC and a `pgnIndex` value of `CAN_MAX_PGN_IDX` or greater in an SPN entry; (5) old-format (ver=0 / SpnConfig0) versus new-format (ver=2) config loading.

---

**A08-4** · HIGH · Missing Test Coverage – CanStateHandler State Machine
**File:** `comm/canstatehandler.cpp:24`
**Description:** `CanStateHandler::updateState()` maintains time and count accumulators (`sessionOnTime`, `sessionOffTime`, `usageOnTime`, `usageOffTime`, and the rising/falling edge counters). It also controls the idle timer based on `m_canStates[0]`. No test exercises this method. Specifically: the delta time calculation at line 44 (`(clock - cs.clock) / 100`) is never verified; the idle timer start/stop at lines 64–70 is never verified; and the `DEPENDS_ON_TRIGGER` conditional compilation path (currently disabled) is never checked. The `canStates()` serialisation method, which is the output of all accumulated state, is also entirely untested.
**Fix:** Add tests that: (1) emit `stateUpdated(0, value)` with a controlled clock and verify delta time accumulation; (2) verify idle timer starts when state matches `idleInputPolarity` and stops when state changes; (3) call `canStates()` in each of the three `DigitalFormat` modes and verify the serialised output; (4) call `canStates()` with `autoReset=true` and verify that session counters are zeroed while usage counters are not.

---

**A08-5** · HIGH · Missing Test Coverage – resetStates Partial Reset Logic
**File:** `comm/canstatehandler.cpp:73`
**Description:** `resetStates(bool resetLast)` selectively zeroes state entries based on attribute type: when `resetLast=false`, entries of type `CanAttributeLast`, `CanAttributeLast2`, and `CanAttributeTime` are preserved. No test verifies this conditional behaviour. An incorrect implementation that always zero-fills would pass the existing (non-existent) tests. Furthermore, after the selective zero-fill, all clocks are reset unconditionally when `DEPENDS_ON_TRIGGER` is not defined (line 83–85), which could cause time accumulation to restart incorrectly. No test validates the interaction between partial reset and subsequent `canStates()` output.
**Fix:** Add tests that populate state for `CanAttributeLast` and `CanAttributeTime` entries, call `resetStates(false)`, and verify that `CanAttributeLast` entries are NOT zeroed while `CanAttributeCount` entries ARE zeroed. Also verify `resetStates(true)` zeroes all entries.

---

**A08-6** · HIGH · Missing Test Coverage – updateIdleTimer Edge Cases
**File:** `comm/canstatehandler.cpp:91`
**Description:** `updateIdleTimer()` creates, starts, or destroys a `QTimer` based on three conditions: `gCfg->idleTimeout()`, `gCfg->currentDriverId()`, and `gCfg->idleInputSource() == 64`. The timer teardown path (deleting and nulling `m_timer`) is not tested. The path where all conditions are met and the timer is created is not tested. The interaction between `updateIdleTimer()` being called from `resetStates()` and concurrent `updateState()` calls is untested.
**Fix:** Add tests that configure `idleTimeout`, `currentDriverId`, and `idleInputSource` to trigger timer creation; verify `idleTimeout` signal fires after the timeout; verify timer is destroyed when `idleTimeout()` is set to 0; verify timer is destroyed when `currentDriverId()` is 0 (driver logs out).

---

**A08-7** · MEDIUM · Missing Test Coverage – Protocol-Gated Config Setters
**File:** `comm/canmonitor.cpp:498`, `566`, `642`, `752`, `857`, `976`, `1097`
**Description:** Each `setCanXxxConfig()` method validates the input string, but several also gate on `m_busConfig.protocol`. For example, `setCanPgnConfig()` (line 569) returns false if protocol is not `J1939` or `LindeExtended`; `setCanLinConfig()` (line 860) only accepts `LindeExtended`; `setCanBydConfig()` (line 979) only accepts `BydCan`; `setCanLin2Config()` (line 1100) only accepts `Linde1202`. No test verifies that calling a config setter with an incompatible protocol returns false and leaves state unchanged. No test verifies input validation rejection paths (e.g., `setCanBusConfig` with `baudRate > 1000000`, or `setCanAttConfig` with `name.size() >= CAN_ATT_NAME_LEN`).
**Fix:** Add tests for each setter with: (1) incorrect protocol returning false; (2) each validation field at its boundary (too few fields, field out of range); (3) correct input returning true and observable state change.

---

**A08-8** · MEDIUM · Missing Test Coverage – J1939 and Linde1202 createRequest Paths
**File:** `comm/canmonitor.cpp:1231`
**Description:** `createRequest()` constructs and queues CAN request frames with protocol-specific byte layouts. The test suite only exercises the `LindeExtended` path via VDI mode. The J1939 path (extended ID, 3-byte PGN payload), the BydCan path (4-byte big-endian address), and the Linde1202 path (8-byte big-endian address) are never tested. An incorrect byte ordering in any of these paths would produce silent data corruption on the CAN bus with no test failure.
**Fix:** Add tests that configure each protocol, call `updateRequests()`, and verify the request frames enqueued on the mock `CanBus` match the expected byte layout for each protocol.

---

**A08-9** · MEDIUM · Incomplete VDI Mode Test Coverage
**File:** `test/test_canbus.cpp:73`
**Description:** The single existing test (`test_vdiMode`) covers the VDI mode configuration path. However it does not test: (1) what happens when `enableVdi(false)` is called directly (it calls `clearCanConfig()` but this is not asserted); (2) `setVdiAccess()` when `vdiMode()` returns false – the early-return guard is not tested; (3) `configureVdiAccessRequest()` when `vdiMode()` returns false; (4) the `access=true, inhibit=true` state where byte[0] should be `0x05` – the test emits `setRelayOut(true, false)` first, which is access+inhibit, but the parameter naming in the test comment reads "access, inhibit" while the signal is `setRelayOut(bool relay, bool inhibit)` creating potential confusion.
**Fix:** Add dedicated sub-cases for the VDI guard paths. Clarify or add assertions for the `access=false` with `inhibit=true` combination. Verify `enableVdi(false)` results in zero requests.

---

**A08-10** · LOW · No Test for saveCanConfig File I/O Failure
**File:** `comm/canmonitor.cpp:265`
**Description:** `saveCanConfig()` logs a critical error if the config file cannot be opened but does not return a success indicator (returns void). No test verifies the error-logging behaviour or the file-write path. A failed write would silently discard configuration without notification to callers.
**Fix:** Add a test that mocks a read-only or non-existent file path and verifies the critical log output. Consider changing the return type to `bool` to allow callers to detect write failures.

---

**A08-11** · LOW · Friend Class Access Bypasses Encapsulation But Is Insufficiently Used
**File:** `comm/canmonitor.h:55–57`
**Description:** `CanMonitor` declares `friend class TestCanbus` under `#ifdef UNIT_TEST`, granting full access to all private members and methods. However the test class only uses this access for `updateBusConfig()` and `updateRequests()` via `forceCanbusUpdate()` at `test/test_canbus.cpp:262–267`. The private methods `readCanFrame`, `updateState`, `updateSpnState`, `findPgnIndex`, `childSpnIndexes`, and `updateBusConfig` are all accessible for direct unit testing but none are tested. The friend declaration provides a testing surface that is almost entirely unused.
**Fix:** Write direct unit tests that call the private methods through the friend relationship. This is particularly important for `readCanFrame()` and `updateSpnState()` which contain the most complex logic and the highest risk of silent data-corruption bugs.

---

## Summary Table

| ID | Severity | Category | File | Tested? |
|----|----------|----------|------|---------|
| A08-1 | CRITICAL | Missing Coverage – readCanFrame | `canmonitor.cpp:1369` | No |
| A08-2 | CRITICAL | Missing Coverage – updateSpnState / UB risk | `canmonitor.cpp:1526` | No |
| A08-3 | HIGH | Missing Coverage – Config file parsing | `canmonitor.cpp:107,209` | No |
| A08-4 | HIGH | Missing Coverage – CanStateHandler state machine | `canstatehandler.cpp:24` | No |
| A08-5 | HIGH | Missing Coverage – resetStates partial reset | `canstatehandler.cpp:73` | No |
| A08-6 | HIGH | Missing Coverage – updateIdleTimer | `canstatehandler.cpp:91` | No |
| A08-7 | MEDIUM | Missing Coverage – protocol-gated config setters | `canmonitor.cpp:498–1097` | No |
| A08-8 | MEDIUM | Missing Coverage – J1939/BydCan/Linde1202 createRequest | `canmonitor.cpp:1231` | No |
| A08-9 | MEDIUM | Incomplete VDI mode test | `test/test_canbus.cpp:73` | Partial |
| A08-10 | LOW | saveCanConfig I/O failure not tested | `canmonitor.cpp:265` | No |
| A08-11 | LOW | Friend access granted but almost unused | `canmonitor.h:55` | N/A |

---

## Overall Assessment

The test suite for `CanMonitor` and `CanStateHandler` is severely deficient. A single test method (`test_vdiMode`) covers only the VDI mode initialisation path, which is a minor side-feature of the CAN subsystem. The core responsibilities of both classes – receiving and parsing CAN frames, extracting SPN values via bit manipulation, accumulating time and edge-count state, serialising state for upload, and managing the idle timer – have zero test coverage. Two critical findings (A08-1, A08-2) involve logic that processes externally-sourced data (CAN bus frames and config files) without any test validation of error or edge-case paths, making silent data corruption and undefined behaviour plausible failure modes in production.
