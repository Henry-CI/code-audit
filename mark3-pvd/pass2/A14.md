# Audit Report – Agent A14
**Audit Run:** 2026-02-28-01
**Pass:** 2 – Test Coverage
**Agent:** A14
**Branch Confirmed:** master (verified via `git branch --show-current`)

---

## Files Under Review

| File | Lines |
|------|-------|
| `platform/internalrfid.cpp` | 113 |
| `platform/internalrfid.h` | 33 |
| `platform/internalrtc.cpp` | 41 |
| `platform/internalrtc.h` | 19 |

---

## Reading Evidence

### internalrfid.h – Class: `EM070::InternalRfid` (inherits QObject)

**Includes:**
- `<QObject>` (line 4)

**Public Methods:**
| Line | Method |
|------|--------|
| 14 | `explicit InternalRfid(QObject *parent = 0)` (constructor) |
| 15 | `void setEnabled(bool enabled)` |

**Signals:**
| Line | Signal |
|------|--------|
| 18 | `void response()` |
| 19 | `void cardData(quint64 wiegand, quint16 facility, quint32 number, QByteArray &readerOutput)` |
| 20 | `void error(const QString &text)` |

**Private Methods:**
| Line | Method |
|------|--------|
| 23 | `void readData()` |
| 24 | `void parseData()` |

---

### internalrfid.cpp – Implementation Detail

**Includes:**
- `internalrfid.h` (line 1)
- `wiegandrfid.h` (line 2)
- `<QSerialPort>` (line 3)
- `<QDebug>` (line 4)
- `seriallogger.h` (line 5)

**Key constants:**
- `FILE_SERIAL_PORT` = `"/dev/ttyS2"` (line 7); overridable via env var `QT_RFID_SERIAL_PORT`
- `RECEIVER_MAX_SIZE` = `128` (line 8)

**parseData logic (lines 67–111):**
- Format `#6:FFNN` → 26-bit Wiegand (facility 1 byte hex, card number 2 bytes hex)
- Format `#8:FFFFNNNN` → 34-bit Wiegand (facility 2 bytes hex, card number 2 bytes hex)
- Format `#R:<hex64>` → raw 64-bit Wiegand pass-through
- Fallback: any `ba.size() > 3` → emits `cardData(0, 0, 0, log)` (line 109)

---

### internalrtc.h – Class: `EM070::InternalRtc` (plain class, no QObject)

**Includes:**
- `<QDateTime>` (line 4)

**Public Static Methods:**
| Line | Method |
|------|--------|
| 11 | `static void setRtcTime(QDateTime dateTime = QDateTime())` |
| 12 | `static void setSystemTime()` |
| 13 | `static quint64 euiAddress()` |

---

### internalrtc.cpp – Implementation Detail

**Includes:**
- `internalrtc.h` (line 1)
- `<QFile>` (line 2)
- `<QProcess>` (line 3)

**Key constants:**
- `FILE_RTC_DEVICE` = `"/dev/rtc1"` (line 5)
- `FILE_RTC_EUI` = `"/sys/devices/platform/nuc970-i2c0/i2c-0/0-006f/eui"` (line 6)

**setRtcTime logic (lines 10–22):**
- Validates `dateTime.isValid()` before calling `::stime()` (ARM only)
- Always runs `hwclock -w -f /dev/rtc1` unconditionally via `QProcess::execute()`, regardless of validity
- `QProcess::execute()` return value is not checked

**euiAddress logic (lines 31–41):**
- Returns `0` on file-open failure with no error signal or log

---

## Test Coverage Search Results

### Search locations examined:
- `test/test_backgroundworker.cpp`
- `test/test_backgroundworker.h`
- `test/test_canbus.cpp`
- `test/test_canbus.h`
- `test/test_dialog.cpp`
- `test/test_dialog.h`
- `test/test_ota.cpp`
- `test/test_ota.h`
- `test/FleetIQ360App_5.2.2F.h`

### Search patterns used:
- `InternalRfid`, `internalrfid`, `InternalRtc`, `internalrtc`
- `setEnabled`, `parseData`, `readData`, `cardData`, `wiegand`, `WiegandRfid`
- `setRtcTime`, `setSystemTime`, `euiAddress`, `hwclock`, `rtc`
- `#6:`, `#8:`, `#R`, `AT+LFID`, `ttyS2`, `RECEIVER_MAX`
- `stime`, `hwclock`, `rtc1`, `FILE_RTC`

**Result: Zero matches found in any test file for any method, class name, signal, or constant from either file.**

---

## Findings

---

**A14-1** · CRITICAL · Missing Test Coverage – InternalRfid (Complete Absence)
**File:** `platform/internalrfid.cpp`
**Description:** The class `EM070::InternalRfid` has zero unit test coverage. No test file in `test/` references the class, any of its methods (`setEnabled`, `readData`, `parseData`), its signals (`cardData`, `error`, `response`), or any of the serial data format constants. This is a hardware-interfacing access control component: it parses raw RFID card reads and emits the card credential (`wiegand`, `facility`, `number`) that drives driver authentication. A defect in parsing logic is a direct authentication bypass risk. The complete lack of tests means regressions cannot be detected.
**Fix:** Create a `test_internalrfid.cpp` test suite that stubs `QSerialPort` (or uses the `QT_RFID_SERIAL_PORT` env-var override) and exercises `parseData()` directly, covering: valid `#6:` frame, valid `#8:` frame, valid `#R:` frame, malformed frames that should emit `error()`, the overflow guard (>128 bytes), and the zero-facility/zero-number guard.

---

**A14-2** · HIGH · No Test for Valid Card Read (cardData signal)
**File:** `platform/internalrfid.cpp`:83–94
**Description:** The primary success path – receiving a properly formatted `#6:` or `#8:` RFID frame and emitting `cardData` – is completely untested. The parsing extracts `facility` and `number` as hex substrings with hardcoded offsets and sizes (`ba.mid(3,2)`, `ba.mid(5,4)`, `ba.mid(3,4)`, `ba.mid(7,4)`). An off-by-one in these offsets would silently produce wrong credential values. Without a test verifying the emitted `wiegand`, `facility`, and `number` values, such defects are undetectable.
**Fix:** Add parameterised test cases feeding known byte arrays (e.g., `"#6:0A1234"`) into `parseData()` via a `QSignalSpy` on `cardData` and assert the decoded values match expected Wiegand output.

---

**A14-3** · HIGH · No Test for Invalid Card Format / Error Signal
**File:** `platform/internalrfid.cpp`:86–107
**Description:** The `error()` signal is emitted when `facility == 0`, `number == 0`, when `#R:` hex parse fails, or when the split produces fewer than two parts. None of these error paths are tested. Additionally, line 108–109 shows a catch-all: any `ba.size() > 3` that does not match a known prefix emits `cardData(0, 0, 0, log)` – this silently fabricates a zero-wiegand card-present event rather than emitting `error()`. This behavioural ambiguity (unknown data treated as a card swipe) is a logic defect that is invisible without tests.
**Fix:** Test that: (a) `#6:0000xx` emits `error()` not `cardData()`; (b) `#R:ZZZZ` (invalid hex) emits `error()`; (c) arbitrary garbage longer than 3 bytes emits `cardData(0,0,0,...)` and confirm this is the intended behaviour or change to `error()`.

---

**A14-4** · HIGH · No Test for Buffer Overflow Guard
**File:** `platform/internalrfid.cpp`:55–58
**Description:** The `readData()` method clears `m_receiver` when it exceeds `RECEIVER_MAX_SIZE` (128 bytes). This is the only defence against an unbounded accumulation of serial bytes. It is untested. If the guard fails or has an off-by-one, `m_receiver` will grow without bound, causing potential memory exhaustion on an embedded device. The guard also discards partial data silently without emitting `error()`.
**Fix:** Test by simulating incremental `readyRead` signals delivering 129+ bytes without a newline terminator and asserting `m_receiver` is cleared and no `cardData` is emitted.

---

**A14-5** · MEDIUM · No Test for No-Card / Empty Frame Conditions
**File:** `platform/internalrfid.cpp`:67–110
**Description:** The behaviour when the serial port delivers only `"OK\n"`, an empty line, or a line shorter than 4 bytes is untested. Lines containing only whitespace, after `trimmed()`, will be 0 bytes and fall through all conditions silently. The intent (suppress noise vs. signal an error) is not validated by any test.
**Fix:** Add tests for: `"OK\n"` (should emit only `response()`), `"\n"` (empty line, should emit nothing), `"XX\n"` (3 bytes or fewer, should emit nothing based on the `> 3` guard).

---

**A14-6** · MEDIUM · No Test for Simultaneous / Multi-Line Card Frames
**File:** `platform/internalrfid.cpp`:69
**Description:** `parseData()` splits `m_receiver` on `'\n'` and iterates all lines, meaning multiple RFID card records delivered in one serial read burst will all be processed. This multi-card-in-one-buffer path is untested. An interleaved delivery (e.g., last part of card A and first part of card B in one chunk) could produce malformed lines. Since `readData()` only calls `parseData()` when `m_receiver` ends with `'\n'`, partial frames from a prior card could precede the next card's frame without separator hygiene.
**Fix:** Test delivery of two complete `#6:` frames in a single `readAll()` burst and assert two `cardData` emissions with correct distinct values.

---

**A14-7** · CRITICAL · Missing Test Coverage – InternalRtc (Complete Absence)
**File:** `platform/internalrtc.cpp`
**Description:** The class `EM070::InternalRtc` has zero unit test coverage. No test file references the class or any of its three static methods (`setRtcTime`, `setSystemTime`, `euiAddress`). `setRtcTime` calls the POSIX `::stime()` syscall on ARM to set the system clock – a privileged, irreversible operation with real-time consequences. `euiAddress` reads a hardware EUI that is used to generate the device's MQTT client ID (`globalconfigs.cpp:162`). Defects in any of these functions have operational and identity-management impact that cannot be caught without tests.
**Fix:** Create `test_internalrtc.cpp`. Mock `QProcess::execute` and the EUI file path (use a temporary file) to make the tests host-runnable. Cover: valid datetime, invalid datetime (null default), `euiAddress` with a known hex file, and `euiAddress` with a missing file.

---

**A14-8** · HIGH · No Test for Invalid DateTime in setRtcTime
**File:** `platform/internalrtc.cpp`:10–22
**Description:** `setRtcTime()` accepts any `QDateTime`, and the only validation is `dateTime.isValid()`. There is no test confirming that an invalid `QDateTime` (month=0, day=32, null default, negative epoch, etc.) skips the `::stime()` call but still proceeds to execute `hwclock -w`. Because `hwclock -w` runs unconditionally regardless of `dateTime.isValid()`, passing an invalid datetime still writes whatever the current system time is to the RTC. This silent behaviour – writing on invalid input – is unintentional-looking and untested.
**Fix:** Add tests that: (a) pass `QDateTime()` (null/invalid) and assert `::stime()` is not called; (b) assert that `hwclock -w` is still invoked in that case and confirm this is intentional; (c) test boundary datetimes (epoch=0, far-future dates).

---

**A14-9** · HIGH · No Test for hwclock Return Value / Failure Path
**File:** `platform/internalrtc.cpp`:19–21, 24–28
**Description:** Both `setRtcTime()` and `setSystemTime()` call `QProcess::execute()` and completely ignore the return value. `QProcess::execute()` returns -2 if the process cannot start, -1 if it crashes, or the exit code of the process. A failure of `hwclock` (e.g., device `/dev/rtc1` not present, permissions error) is silently swallowed. No `error()` signal, no log, no return value. There is no test that simulates `hwclock` failure and verifies the caller is informed.
**Fix:** Check the return value of `QProcess::execute()` and log or signal on non-zero. Add a test that stubs the command to fail and verifies the failure is surfaced.

---

**A14-10** · MEDIUM · No Test for euiAddress File-Not-Found / Return Zero
**File:** `platform/internalrtc.cpp`:31–41
**Description:** When `/sys/devices/platform/nuc970-i2c0/i2c-0/0-006f/eui` cannot be opened, `euiAddress()` silently returns `0`. The caller in `globalconfigs.cpp:162` builds the string `"cii_0"` as the device MQTT client ID when EUI is unavailable. No test verifies this fallback, and no test verifies that a valid EUI hex file produces the correct `quint64` value. A parsing failure (e.g., file contains non-hex whitespace) would also return `0` silently because `toULongLong(nullptr, 16)` returns `0` on failure.
**Fix:** Create a temporary file with a known hex EUI string in the test, override the file path (via a refactor to accept the path or use a compile-time hook), and assert the returned value. Also test empty file and non-hex content.

---

**A14-11** · LOW · setEnabled Writes to Port Without Confirming Port Open State in Tests
**File:** `platform/internalrfid.cpp`:38–49
**Description:** `setEnabled()` guards against `!m_serialPort->isOpen()` but this guard is untested. If the constructor fails to open the serial port (e.g., `/dev/ttyS2` absent on a host test environment), `setEnabled()` silently does nothing. No test verifies that the early-return path is taken, and no test verifies that the `AT+LFID=ON/OFF` command is actually written when the port is open.
**Fix:** Test `setEnabled(true)` and `setEnabled(false)` with a mocked or loopback serial port and verify the written bytes. Test the no-op path when port is closed.

---

## Summary Table

| ID | Severity | Category | File | Covered in Tests? |
|----|----------|----------|------|-------------------|
| A14-1 | CRITICAL | Missing Coverage – InternalRfid | `platform/internalrfid.cpp` | No |
| A14-2 | HIGH | Valid Card Read (cardData signal) | `platform/internalrfid.cpp`:83–94 | No |
| A14-3 | HIGH | Invalid Card Format / Error Signal | `platform/internalrfid.cpp`:86–109 | No |
| A14-4 | HIGH | Buffer Overflow Guard | `platform/internalrfid.cpp`:55–58 | No |
| A14-5 | MEDIUM | No-Card / Empty Frame Conditions | `platform/internalrfid.cpp`:67–110 | No |
| A14-6 | MEDIUM | Multi-Line / Simultaneous Card Frames | `platform/internalrfid.cpp`:69 | No |
| A14-7 | CRITICAL | Missing Coverage – InternalRtc | `platform/internalrtc.cpp` | No |
| A14-8 | HIGH | Invalid DateTime in setRtcTime | `platform/internalrtc.cpp`:10–22 | No |
| A14-9 | HIGH | hwclock Return Value / Failure Path | `platform/internalrtc.cpp`:19–28 | No |
| A14-10 | MEDIUM | euiAddress File-Not-Found / Zero Return | `platform/internalrtc.cpp`:31–41 | No |
| A14-11 | LOW | setEnabled Without Port Open Confirmation | `platform/internalrfid.cpp`:38–49 | No |

**Total findings: 11**
**Critical: 2 | High: 5 | Medium: 3 | Low: 1**

---

## Overall Assessment

Both `InternalRfid` and `InternalRtc` have **zero test coverage**. These are not peripheral utility classes: `InternalRfid` is the internal card reader parser whose output directly drives driver authentication decisions, and `InternalRtc` manages the hardware real-time clock and generates the device's unique network identity (EUI). The complete absence of tests means:

1. Any regression in RFID card parsing (wrong byte offsets, wrong hex base, off-by-one in size checks) will silently produce wrong credentials or silent failures with no automated detection.
2. The `parseData()` catch-all at line 109 (`cardData(0,0,0,log)` for unrecognised frames) is a logic defect that masquerades unknown serial noise as a card-present event – only discoverable through tests.
3. `setRtcTime()` calls the privileged `::stime()` syscall with no boundary validation beyond `isValid()`, and then unconditionally runs `hwclock -w` even on invalid input, with no test catching this asymmetric behaviour.
4. `euiAddress()` returning `0` on file failure silently corrupts the device MQTT client ID to `"cii_0"`, which may cause identity collisions in a fleet context.

Recommended immediate action: introduce a `test_internalrfid.cpp` and `test_internalrtc.cpp` with full coverage of all paths described in findings A14-1 through A14-11.
