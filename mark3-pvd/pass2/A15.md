# Audit Report – Agent A15 (Pass 2: Test Coverage)

**Agent ID:** A15
**Audit Run:** 2026-02-28-01
**Branch Confirmed:** master (verified via `git branch --show-current`)
**Pass:** 2 – Test Coverage

---

## Files Audited

| File | Path |
|------|------|
| ModemPort header | `platform/modemport.h` |
| ModemPort implementation | `platform/modemport.cpp` |
| PowerSupply header | `platform/powersupply.h` |
| PowerSupply implementation | `platform/powersupply.cpp` |

---

## Reading Evidence

### platform/modemport.h

**Includes:**
- `<QObject>` (line 4)
- `<QSerialPort>` (line 5)
- `<QTimer>` (line 6)

**Class:** `EM070::ModemPort` (line 10), inherits `QObject`

**Public methods:**
| Method | Line |
|--------|------|
| `explicit ModemPort(QObject *parent = nullptr)` | 14 |
| `bool sendCmd(const QByteArray &cmd)` | 15 |
| `void resetModem()` | 16 |
| `void setEnabled(bool enable)` | 17 |
| `void setEcho(bool enable)` | 18 (inline) |
| `bool isWwx()` | 19 (inline) |
| `void setWwx(bool isWwx)` | 20 (inline) |

**Signals:**
| Signal | Line |
|--------|------|
| `void portStateChanged(bool open)` | 23 |
| `void response(bool ok, const QByteArrayList &content)` | 24 |

**Private methods:**
| Method | Line |
|--------|------|
| `void openPort()` | 27 |
| `void portError()` | 28 |
| `void readData()` | 29 |
| `void parseData(const QByteArray &line)` | 30 |

**Private members:**
- `QSerialPort *m_serialPort` (line 32)
- `QTimer *m_timer` (line 33)
- `int m_tryTimes` (line 34)
- `QByteArray m_receiver` (line 35)
- `QByteArrayList m_response` (line 36)
- `QByteArray m_cmdLine` (line 37)
- `bool m_echo` (line 38)
- `bool m_wwx` (line 39)

---

### platform/modemport.cpp

**Includes:**
- `"modemport.h"` (line 1)
- `"seriallogger.h"` (line 2)
- `<QProcess>` (line 3)
- `<QDebug>` (line 4)
- `<QFile>` (line 5)

**Port name macros:**
- `FILE_MODEM_PORT_WWX` = `/dev/ttyUSB2` (line 7)
- `FILE_MODEM_PORT` = `/dev/ttyUSB3` (line 8)

**Key implementation notes:**
- Constructor reserves 256 bytes for `m_receiver` (line 19); no upper-bound enforcement on accumulation.
- Baud rate hard-coded to 115200 (line 35); not configurable via public API.
- `resetModem()` calls `QProcess::startDetached("/etc/pvd/mobile -r")` with no return-value check (line 61).
- `openPort()` increments `m_tryTimes` and calls `resetModem()` after 20 failures (line 93); no cap on total resets.
- `sendCmd()` returns `false` if port is closed (line 128) but does not check `QSerialPort::write()` return value (line 135).
- `readData()` parses line-by-line; partial lines accumulated in `m_receiver` with no size cap (line 165).
- `parseData()` emits `response(false, bal)` for unsolicited `+CGEV:` events (line 186); `response(result, m_response)` for all other terminal lines (line 208).

---

### platform/powersupply.h

**Includes:**
- `<QObject>` (line 4)
- `<QFile>` (line 5)
- Forward declarations: `QSocketNotifier`, `QTimer` (lines 7–8)

**Class:** `EM070::PowerSupply` (line 12), inherits `QObject`

**Enums:**
- `BlankMode`: `UnBlank`, `BlankPowerDown = 4` (line 16)
- `ChargeState`: `NotCharging`, `PreCharging`, `FastCharging`, `ChargeDone` (line 17)
- `ChargeFault`: `NoFault`, `InputFault`, `ThermalShutdown`, `ChargeTimerExpired` (line 18)

**Public methods:**
| Method | Line |
|--------|------|
| `explicit PowerSupply(QObject *parent = nullptr)` | 19 |
| `bool isIgnitionOn() const` | 21 (inline) |
| `bool isPowerGood() const` | 23 (inline) |
| `bool isBatteryAvailable() const` | 24 (inline) |
| `ChargeState chargeState() const` | 25 (inline) |
| `ChargeFault chargeFault() const` | 26 (inline) |
| `quint16 voltage() const` | 27 (inline) |
| `qint16 current() const` | 28 (inline) |
| `quint16 temperature() const` | 29 (inline) |
| `quint16 remainingCapacity() const` | 30 (inline) |
| `quint16 designCapacity() const` | 31 (inline) |
| `quint16 timeToEmpty() const` | 32 (inline) |
| `quint16 timeToFull() const` | 33 (inline) |
| `static void reboot()` | 35 |
| `static void poweroff()` | 36 |
| `static void setBlankMode(BlankMode mode)` | 37 |
| `static void setTouchPower(bool on)` | 38 |
| `static void charge(bool enable)` | 39 |
| `static void setBatteryEnabled(bool enable)` | 40 |

**Signals:**
| Signal | Line |
|--------|------|
| `void ignitionStateChanged(bool on)` | 43 |
| `void batteryStatusRead(bool avail, int state, int fault, quint16 voltage, qint16 current, quint16 temp, quint16 remainingCapacity)` | 44 |

**Private methods:**
| Method | Line |
|--------|------|
| `void readIgnitionState()` | 47 |
| `void readChargerStatus()` | 48 |
| `void readGaugeStatus()` | 49 |

---

### platform/powersupply.cpp

**Includes:**
- `"powersupply.h"` (line 1)
- `<QEventLoop>` (line 2)
- `<QProcess>` (line 3)
- `<QSocketNotifier>` (line 4)
- `<QTimer>` (line 5)
- `<QDebug>` (line 6)

**Key implementation notes:**
- Constructor fails silently if ignition file cannot be opened: `m_notifier` is left uninitialised and the method returns early (lines 40–43).
- `readGaugeStatus()` calls `args[0]` through `args[6]` without checking that `args.size() >= 7` (lines 145–174). A malformed or short sysfs line causes undefined behaviour via out-of-bounds `QByteArrayList` access.
- Charge control logic in `readGaugeStatus()`: voltage threshold is < 4100 mV or remainingCapacity < 99 (line 148); upper threshold is > 4300 mV (line 150). No test validates these thresholds.
- `readIgnitionState()` inverts the GPIO active-low logic explicitly (line 57); no test verifies the polarity.
- `reboot()` and `poweroff()` both shell out to `/etc/pvd/reboot` via `QProcess::execute()` (lines 205, 211); no return value checked.
- `readGaugeStatus()` calls `m_timer->start(QUERY_INTERVAL)` (line 178) as well as `readChargerStatus()` calling it again (line 120), meaning the timer is started twice per polling cycle but this is benign since `QTimer::start` restarts the timer.

---

## Test Coverage – Findings

### Test suite inventory

The `test/` directory contains:
- `test_backgroundworker.cpp` / `.h`
- `test_canbus.cpp` / `.h`
- `test_dialog.cpp` / `.h`
- `test_ota.cpp` / `.h`

**Result of grep for `ModemPort`, `PowerSupply`, and all method names across `test/`:**
- Zero matches for `ModemPort` or any of its methods.
- Zero matches for `PowerSupply` or any of its methods.
- `BackgroundWorker` instantiates `PowerSupply` internally (confirmed in `app/backgroundworker.cpp` line 270) and constructs `ModemPort` lazily (line 2700), but no test exercises these objects' own logic or verifies their signals.

**Conclusion: Neither `ModemPort` nor `PowerSupply` has any direct or indirect unit-test coverage.**

---

## Findings

---

**A15-1** · HIGH · Missing Test Coverage – ModemPort (entire class)
**File:** `platform/modemport.cpp:1` / `platform/modemport.h:1`
**Description:** The `ModemPort` class has zero test coverage. No test in `test/` instantiates, stubs, or exercises `ModemPort`. This class manages the physical serial link to the cellular modem: it controls port open/close lifecycle, sends AT commands, handles port errors, and emits `portStateChanged` and `response` signals that drive the rest of the communication stack. None of these paths are exercised by any automated test.
**Fix:** Create a `test_modemport.cpp` test suite. Use `QT_MOBILE_SERIAL_PORT` (already honoured at constructor line 22) to redirect the port to a null device or a `QSerialPort` mock. At minimum, test: (1) constructor initialises baud rate and port name from env variable; (2) `sendCmd()` returns false when port is closed; (3) `portStateChanged(false)` is emitted on `portError()`; (4) `response(true, ...)` is emitted after a valid OK response; (5) `response(false, ...)` is emitted on ERROR/+CME ERROR.

---

**A15-2** · HIGH · Missing Test Coverage – PowerSupply (entire class)
**File:** `platform/powersupply.cpp:1` / `platform/powersupply.h:1`
**Description:** The `PowerSupply` class has zero test coverage. The class drives ignition detection, battery voltage/capacity monitoring, charge control decisions, and the `ignitionStateChanged` and `batteryStatusRead` signals. Both signals directly affect application-level power management and UI updates in `BackgroundWorker`. No test validates their emission, their content, or any of the threshold logic.
**Fix:** Create a `test_powersupply.cpp` test suite. Abstract sysfs file paths behind a configurable base directory or dependency-inject `QFile` sources so tests can provide synthetic data. At minimum, test: (1) `ignitionStateChanged(true)` emitted when GPIO file reads `0` (active-low, line 57); (2) `batteryStatusRead` emitted with correct voltage from a synthetic gauge register file; (3) charge enable/disable triggered by voltage crossing 4100 mV and 4300 mV thresholds (lines 148–151).

---

**A15-3** · HIGH · Undefined Behaviour – Unchecked Array Index in `readGaugeStatus()`
**File:** `platform/powersupply.cpp:143-174`
**Description:** After splitting the gauge register line on commas (`args = ba.split(',')`, line 143), the code directly accesses `args[0]` through `args[6]` without any bounds check. If the sysfs file `/sys/devices/platform/nuc970-i2c0/i2c-0/0-0055/show_regs` returns a line with fewer than seven comma-separated fields (e.g., due to a driver error, a race during read, or device absence), this produces an out-of-bounds `QByteArrayList` access. In Qt's `QList`, operator[] on an out-of-range index is undefined behaviour and will typically crash in a release build.
**Fix:** Add a guard immediately after line 143: `if (args.size() < 7) return;`. Add a unit test that feeds a truncated sysfs line and verifies the function returns without modifying any member state.

---

**A15-4** · MEDIUM · Missing Test – Serial Write Return Value Ignored in `sendCmd()`
**File:** `platform/modemport.cpp:135`
**Description:** `sendCmd()` calls `m_serialPort->write(cmd + "\r\n")` but discards the `qint64` return value. `QSerialPort::write()` can return -1 on error (e.g., the device was removed between the `isOpen()` check at line 127 and the write at line 135). The caller receives `true` even when no bytes were transmitted, silently losing the command. No test exercises this TOCTOU window.
**Fix:** Capture the return value of `write()` and return `false` (or emit an error signal) if it is -1. Add a test that simulates a write failure and verifies `sendCmd()` returns `false`.

---

**A15-5** · MEDIUM · Missing Test – `m_receiver` Buffer Has No Maximum Size Cap
**File:** `platform/modemport.cpp:19` / `platform/modemport.cpp:165`
**Description:** `m_receiver` is pre-reserved to 256 bytes (line 19) but `QByteArray::reserve()` does not enforce a hard limit; Qt will reallocate on demand. If the modem sends data with no newline terminator (e.g., a binary blob, a stuck transmission, or a framing error), `m_receiver` will grow without bound until the process exhausts memory or the port is closed. No test verifies behaviour under oversized input.
**Fix:** Add a guard in `readData()` before appending to `m_receiver` (line 165): if `m_receiver.size()` exceeds a safe threshold (e.g., 4096 bytes), clear `m_receiver` and log a warning. Add a test that injects a stream of data with no newlines and verifies the receiver does not grow unboundedly and that the port recovers.

---

**A15-6** · MEDIUM · Missing Test – `PowerSupply` Constructor Silent Failure
**File:** `platform/powersupply.cpp:40-43`
**Description:** If the ignition GPIO file cannot be opened, the constructor logs a critical message and returns immediately. `m_notifier` is never initialised (`new QSocketNotifier(...)` at line 45 is never reached), so the pointer is uninitialised. Callers that subsequently call `isIgnitionOn()` get the default `false` value with no indication of the failure, and `ignitionStateChanged` is never emitted. No test covers this failure path.
**Fix:** Initialise `m_notifier` to `nullptr` in the member initialiser list and add a public `bool isValid() const` accessor. Add a test that constructs `PowerSupply` when the ignition file does not exist and verifies `isValid()` returns `false` and no crash occurs.

---

**A15-7** · MEDIUM · Missing Test – Ignition GPIO Active-Low Polarity Logic
**File:** `platform/powersupply.cpp:57`
**Description:** The ignition state is derived from an active-low GPIO: `m_ignitionOn = ba.toInt() ? false : true`. This inversion means a file value of `"0"` signals ignition ON, and `"1"` signals ignition OFF. This is a non-obvious mapping that is easy to break in future maintenance. No test verifies that the correct `ignitionStateChanged` argument is emitted for each GPIO value.
**Fix:** Add parameterised tests: when the GPIO file contains `"0"`, verify `ignitionStateChanged(true)` is emitted; when it contains `"1"`, verify `ignitionStateChanged(false)` is emitted.

---

**A15-8** · LOW · Missing Test – `resetModem()` Invokes Detached Process with No Verification
**File:** `platform/modemport.cpp:61`
**Description:** `resetModem()` calls `QProcess::startDetached("/etc/pvd/mobile -r")` with no return-value check. If the binary does not exist or is not executable, the reset silently fails and the timer is restarted (line 65), which can cause repeated failed reset attempts with no observable side-effect. No test covers this path.
**Fix:** Capture the `bool` return value of `QProcess::startDetached()` and emit an appropriate signal or log a warning on failure. Add a test that simulates the absence of the reset binary and verifies the class continues to function (e.g., timer restarts).

---

**A15-9** · LOW · Missing Test – Charge Threshold Boundary Values
**File:** `platform/powersupply.cpp:148-151`
**Description:** `readGaugeStatus()` enables charging when `m_voltage < 4100` or `m_remainingCapacity < 99`, and disables it when `m_voltage > 4300` or `m_remainingCapacity == 100`. The boundary values (exactly 4100, 4300, 99, 100) are untested, leaving the hysteresis behaviour unverified. A regression in the threshold logic could cause excessive charge cycling or failure to charge.
**Fix:** Add unit tests for boundary values: voltage = 4099, 4100, 4101, 4300, 4301 and capacity = 98, 99, 100, verifying that `charge(true)` or `charge(false)` is called with the correct argument in each case.

---

## Summary Table

| ID | Severity | Category | File | Description |
|----|----------|----------|------|-------------|
| A15-1 | HIGH | Missing Test Coverage | `platform/modemport.cpp` | Entire `ModemPort` class has zero test coverage |
| A15-2 | HIGH | Missing Test Coverage | `platform/powersupply.cpp` | Entire `PowerSupply` class has zero test coverage |
| A15-3 | HIGH | Undefined Behaviour | `platform/powersupply.cpp:143-174` | `readGaugeStatus()` accesses `args[0..6]` without bounds check |
| A15-4 | MEDIUM | Missing Test / Error Handling | `platform/modemport.cpp:135` | `write()` return value ignored in `sendCmd()` |
| A15-5 | MEDIUM | Missing Test / Resource Safety | `platform/modemport.cpp:165` | `m_receiver` accumulation has no upper-bound cap |
| A15-6 | MEDIUM | Missing Test / Silent Failure | `platform/powersupply.cpp:40-43` | Constructor silently fails if ignition file cannot be opened |
| A15-7 | MEDIUM | Missing Test / Logic Correctness | `platform/powersupply.cpp:57` | Active-low ignition polarity inversion is untested |
| A15-8 | LOW | Missing Test / Error Handling | `platform/modemport.cpp:61` | `QProcess::startDetached()` return value not checked in `resetModem()` |
| A15-9 | LOW | Missing Test / Boundary | `platform/powersupply.cpp:148-151` | Charge enable/disable threshold boundary values are untested |

---

*End of Agent A15 Report*
