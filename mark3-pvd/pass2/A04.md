# Security Audit — Pass 2: Test Coverage
**Agent:** A04
**Audit Run:** 2026-02-28-01
**Branch confirmed:** master (verified via `git branch --show-current`)
**Pass:** 2 — Test Coverage

---

## Files Assigned

| File | Status |
|------|--------|
| `app/cigconfigs.h` | Read in full (header-only, 313 lines) |
| `app/crctable.cpp` | Read in full (47 lines) |
| `app/crctable.h` | Does NOT exist (no companion header) |
| `app/driverlist.cpp` | Read in full (657 lines) |
| `app/driverlist.h` | Read in full (120 lines) |

---

## Test Files Examined

| Test File | Relevant? |
|-----------|-----------|
| `test/test_backgroundworker.cpp` | Yes — exercises `CIGCONF` enums and `gCfg` (GlobalConfigs wrapper over DriverList) |
| `test/test_dialog.cpp` | Yes — exercises `CIGCONF` enums, `setDriverId`, `setMasterId`, `containsDriverId`, `containsMasterId`, `masterIdById` |
| `test/test_canbus.cpp` | No — only registers CIGCONF metatypes |
| `test/test_ota.cpp` | No — only registers CIGCONF metatypes |

---

## Reading Evidence

### app/cigconfigs.h

**Type/constant definitions (all public — header-only):**

| Kind | Name | Line(s) |
|------|------|---------|
| `#define` | `LFF_VERSION`, `SFF_VERSION`, `UFF_VERSION`, `ENG_VERSION`, `F_BUILD`, `C_BUILD` | 8–13 |
| `#define` | `BROADCASTMSG_TEXT_LEN` | 15 |
| `#define` | `GMTP_ID_LEN`, `GMTP_SERVER_CNT`, `SERVER_ADDR_LEN` | 17–19 |
| `#define` | `MODEM_DIAL_NUMBER_LEN`, `MODEM_APN_LEN`, `MODEM_APN_USER_LEN`, `MODEM_ICCID_LEN`, `MODEM_APN_PASSWORD_LEN` | 20–24 |
| `#define` | `MAX_POLY_POINTS`, `MAX_POLY` | 26–27 |
| `#define` | `CHECKLIST_TIME_SLOTS`, `CHECKLIST_MAX_IDX`, `CHECKLIST_QUESTION_LEN`, `CHECKLIST_ITEM_SIZE`, `CHECKLIST_QUESTION_LEN_100`, `CHECKLIST_ITEM_SIZE_100` | 29–34 |
| `#define` | `DRIVER_MAX_ID_IDX` (3000), `MASTER_MAX_ID_IDX` (1024), `SUPER_MAX_ID_IDX` (100), `TECH_MAX_ID_IDX` (1000) | 36–39 |
| `#define` | CAN bus limits: `CAN_MAX_HW_PGN`, `CAN_MAX_PGN_IDX`, `CAN_MAX_SPN_IDX`, `CAN_MAX_LINK_IDX`, `CAN_MAX_ATT_IDX`, `CAN_ATT_NAME_LEN`, `CAN_MSG_TYPE`, `CAN_MSG_DLC`, `CAN_SIG_STATUS` | 42–50 |
| `#define` | `ON_DEMAND_DURATION` | 53 |
| `#define` | `WIFI_MAX_NETWORKS`, `WIFI_CONF_FILE` | 56–57 |
| `#define` | File paths: `FILE_DRIVER_IDS`, `FILE_MASTER_IDS`, `FILE_SUPER_IDS`, `FILE_TECH_IDS`, `FILE_CHECKLIST`, `FILE_CHECKLIST_100`, `FILE_FLEETMS_FW`, `FILE_FLEETMS_FW_RD`, `FILE_LOGIN_SCREEN`, `FILE_LOGIN_SCREEN_RD`, `FILE_ONCEPERDAY_PREOP_IDS` | 64–74 |
| `#define` | `DIR_GMTP_MSG` | 76 |
| `enum` | `MasterMenuOptions` | 83–84 |
| `enum` | `PowerState` | 86 |
| `enum` | `ConfigErrorCode` | 88 |
| `enum` | `FtpErrorCode` | 90–91 |
| `enum` | `LeaderCmdType` | 93 |
| `enum` | `UnlockReasonScreen` | 95 |
| `enum` | `RealImpact` | 97 |
| `enum` | `DigitalInputMode` | 99 |
| `enum` | `LeaderCmd` (large; ~80 values) | 101–126 |
| `enum` | `GmtpMessage` | 128–133 |
| `enum` | `CheckReason` | 135 |
| `enum` | `CheckResponses` | 136 |
| `enum` | `ChecklistType` | 137 |
| `enum` | `OnDemandCmdType` | 139 |
| `enum` | `OnDemandCmdSrc` | 140 |
| `enum` | `MaintLockedCode` | 142–148 |
| `enum` | `ShowTimeFormat` | 150–154 |
| `enum` | `BleExpansionDI`, `BleExpansionRelay`, `BleExpansionConnectionStatus` | 156–158 |
| `enum` | `CanProtocol` | 160 |
| `enum` | `CanAttributeType` | 162–169 |
| `enum` | `WifiPosSource` | 171 |
| `enum` | `CameraMode` | 173 |
| `struct` | `CanMsgLink` | 175–178 |
| `struct` | `CanSigPara` | 188–193 |
| `struct` | `CigCanConfig` | 195–243 |
| `struct` | `BroadcastMessage` | 245–252 |
| `struct` | `WifiNetwork` | 254–258 |
| `struct` | `PreopDriverId` | 260–263 |
| `struct` | `DriverId` | 265–268 |
| `struct` | `MasterId` | 270–274 |
| `struct` | `gpsPosStruct` | 276–279 |
| `struct` | `polygonStruct` | 281–285 |
| `struct` | `position` | 287–293 |
| `struct` | `AccessPoint` | 295–302 |
| `struct` | `CheckResponse` | 304–309 |

No functions are defined in this header. All content is types, constants, and enums.

---

### app/crctable.cpp

**No companion header (`app/crctable.h` does not exist).**

| Kind | Name | Line |
|------|------|------|
| `extern` declaration | `crc32Table[]` (quint32) | 3 |
| `extern` declaration | `crc16Table[]` (quint16) | 4 |
| `const quint32[256]` | `crc32Table` — standard CRC-32/ISO-HDLC lookup table | 6–39 |
| `const quint16[16]` | `crc16Table` — 16-entry CRC-16/CCITT nibble lookup table | 41–46 |

No functions. The file is purely a data table. The tables are consumed by:
- `app/globalconfigs.cpp` line 46: CRC32 used in `GlobalConfigs::crc32()` to integrity-check configuration data
- `app/backgroundworker.cpp` lines 136–138: CRC16 used inline (appears to be CCITT/X.25 variant for modem/comms framing)

---

### app/driverlist.cpp + app/driverlist.h

**Class:** `DriverList`

| Method | Line (cpp) | Visibility |
|--------|-----------|------------|
| `DriverList()` constructor | 8 | public |
| `void readDriverIds()` | 16 | public |
| `void saveDriverIds()` | 45 | public |
| `void readMasterIds()` | 66 | public |
| `void saveMasterIds()` | 97 | public |
| `void readSuperIds()` | 120 | public |
| `void saveSuperIds()` | 136 | public |
| `void readTechIds()` | 155 | public |
| `void saveTechIds()` | 184 | public |
| `void readPreopDriverIds()` | 205 | public |
| `void savePreopDriverIds()` | 233 | public |
| `bool setDriverId(int, quint64, QString)` | 267 | public |
| `bool setMasterId(int, quint64, quint8, QString)` | 285 | public |
| `bool setSuperId(int, quint64)` | 304 | public |
| `bool setTechId(int, quint64, QString)` | 317 | public |
| `int getDriverIdIndex(quint64)` | 335 | public |
| `bool addDriverId(quint64, QString)` | 344 | public |
| `int getMasterIdIndex(quint64)` | 370 | public |
| `bool addSuperId(quint64)` | 379 | public |
| `int getTechIdIndex(quint64)` | 395 | public |
| `bool addTechId(quint64, QString)` | 404 | public |
| `int getPreopDriverIdIndex(quint64)` | 430 | public |
| `CIGCONF::PreopDriverId getPreopDriverId(quint64)` | 445 | public |
| `bool addPreopDriverId(quint64, quint32)` | 455 | public |
| `bool removeDriverId(quint64)` | 489 | public |
| `bool removeMasterId(quint64)` | 511 | public |
| `bool removeSuperId(quint64)` | 529 | public |
| `bool removeTechId(quint64)` | 543 | public |
| `void clearDriverIds()` | 560 | public |
| `void clearMasterIds()` | 566 | public |
| `void clearSuperIds()` | 572 | public |
| `void clearTechIds()` | 578 | public |
| `void clearPreopDriverIds()` | 584 | public |
| `quint32 driverChecksum() const` | 590 | public |
| `quint32 masterChecksum() const` | 601 | public |
| `quint32 superChecksum() const` | 613 | public |
| `quint32 techChecksum() const` | 624 | public |
| `bool superIsEmpty()` | 635 | public |
| `CIGCONF::MasterId masterIdById(quint64) const` | 645 | public |
| Inline accessors (header): `driverIds()`, `masterIds()`, `superIds()`, `techIds()`, `preopDriverIds()`, `driverId(int)`, `masterId(int)`, `superId(int)`, `techId(int)` | h:25–35 | public |
| Inline predicates (header): `containsDriverId(quint64)`, `containsMasterId(quint64, quint8)`, `containsSuperId(quint64)`, `containsTechId(quint64)` | h:42–75 | public |

**Note:** `addMasterId` is absent — there is no such method in either `.cpp` or `.h`. Callers use `setMasterId` to add masters by index.

---

## Test Coverage Analysis

### app/cigconfigs.h

Tests only exercise a small subset of the constants and enums defined here. The CIGCONF namespace types are mostly used as type tokens in `qRegisterMetaType` calls and as values in assertions. Specifically:

- **Tested (enum values verified):** `MaintLockedCode` (all 5 values), `ShowTimeFormat` (all 3 values), `CameraMode` (all 3 values), `ChecklistType` (NotCritical, CriticalByYes, CriticalByNo), `CheckResponses` (CheckResponsedYes, CheckResponsedNo), `UnlockReasonScreen` (Disabled), `MasterMenuOptions` (NormalDriverAccess)
- **Not tested:** `PowerState`, `ConfigErrorCode`, `FtpErrorCode`, `LeaderCmdType`, `RealImpact`, `DigitalInputMode`, `LeaderCmd` enum values, `GmtpMessage` enum values, `CheckReason` enum values, `OnDemandCmdType`, `OnDemandCmdSrc`, `BleExpansionDI/Relay/ConnectionStatus`, `CanProtocol`, `CanAttributeType`, `WifiPosSource`
- **Not tested:** All struct layouts (`CigCanConfig`, `CanMsgLink`, `CanSigPara`, `BroadcastMessage`, `WifiNetwork`, `PreopDriverId`, `DriverId`, `MasterId`, `gpsPosStruct`, `polygonStruct`, `position`, `AccessPoint`, `CheckResponse`)
- **Not tested:** All `#define` constants (boundary values, buffer sizes)

### app/crctable.cpp

- There are **zero tests** for the CRC tables themselves.
- `GlobalConfigs::crc32()` (which uses `crc32Table`) is not directly tested.
- The CRC-16 inline routine in `backgroundworker.cpp` (which uses `crc16Table`) is not tested.
- No known-good vector test exists (e.g., CRC32("") == 0x00000000, CRC32("123456789") == 0xCBF43926).

### app/driverlist.cpp

Tests are conducted entirely through the `GlobalConfigs` facade (`gCfg`), which wraps a `DriverList` instance. Direct `DriverList` unit tests do not exist.

| Method | Tested? | Notes |
|--------|---------|-------|
| `readDriverIds()` | Indirectly (via `gCfg->readConfigs()`) | No isolation — file parsing not tested directly |
| `saveDriverIds()` | Indirectly (via `gCfg->saveConfigs()`) | No isolation |
| `readMasterIds()` | Indirectly | No isolation |
| `saveMasterIds()` | Indirectly | No isolation |
| `readSuperIds()` | Indirectly | No isolation |
| `saveSuperIds()` | Indirectly | No isolation |
| `readTechIds()` | Not tested | No test invokes readTechIds path directly |
| `saveTechIds()` | Not tested | No test exercises tech ID save |
| `readPreopDriverIds()` | Not tested | — |
| `savePreopDriverIds()` | Not tested | — |
| `setDriverId()` | Yes (indirectly via `gCfg->setDriverId`) | Bounds not tested |
| `setMasterId()` | Yes (indirectly) | Bounds not tested |
| `setSuperId()` | Not tested | — |
| `setTechId()` | Not tested | — |
| `addDriverId()` | Not tested directly | |
| `addSuperId()` | Not tested | |
| `addTechId()` | Not tested | |
| `addPreopDriverId()` | Not tested | |
| `removeDriverId()` | Not tested | |
| `removeMasterId()` | Not tested | |
| `removeSuperId()` | Not tested | |
| `removeTechId()` | Not tested | |
| `clearDriverIds()` | Not tested | |
| `clearMasterIds()` | Not tested | |
| `clearSuperIds()` | Not tested | |
| `clearTechIds()` | Not tested | |
| `clearPreopDriverIds()` | Not tested | |
| `driverChecksum()` | Not tested | |
| `masterChecksum()` | Not tested | |
| `superChecksum()` | Not tested | |
| `techChecksum()` | Not tested | |
| `superIsEmpty()` | Not tested | |
| `masterIdById()` | Yes (test_backgroundworker.cpp:109) | Only one scenario |
| `containsDriverId()` | Yes (test_backgroundworker.cpp:74–107) | id==1 edge case not tested |
| `containsMasterId()` | Yes | id==1 edge case not tested |
| `containsSuperId()` | Not tested | |
| `containsTechId()` | Not tested | |
| `getDriverIdIndex()` | Not tested directly | |
| `getMasterIdIndex()` | Not tested directly | |
| `getTechIdIndex()` | Not tested directly | |
| `getPreopDriverIdIndex()` | Not tested | |
| `getPreopDriverId()` | Not tested | |

---

## Findings

**A04-1** · CRITICAL · Missing Test Coverage — CRC Table Correctness
**File:** app/crctable.cpp:6
**Description:** The CRC32 and CRC16 lookup tables in `crctable.cpp` have no unit tests whatsoever. `crc32Table` is used by `GlobalConfigs::crc32()` to protect configuration integrity, and `crc16Table` is used in the modem communications framing in `backgroundworker.cpp`. A single corrupted or incorrectly indexed table entry would silently produce wrong CRC values, potentially allowing corrupt configuration data to pass integrity checks or causing communications to fail unpredictably. No known-input/known-output test vectors (e.g., RFC 3720 CRC32 standard vector "123456789" -> 0xCBF43926) exist anywhere in the test suite.
**Fix:** Add a dedicated test case (e.g., `test_crctable.cpp`) that: (1) tests `GlobalConfigs::crc32()` against at least two standard RFC vectors for CRC32 (empty string, "123456789"), (2) tests the CRC16 routine in `backgroundworker.cpp` against CCITT/X.25 vectors, and (3) spot-checks at least the first, last, and a middle table entry of each table against independently computed values.

---

**A04-2** · HIGH · No Tests for DriverList File Parsing — Normal or Malformed Input
**File:** app/driverlist.cpp:16
**Description:** All eight file-parsing methods (`readDriverIds`, `readMasterIds`, `readSuperIds`, `readTechIds`, `readPreopDriverIds`, and their corresponding save methods) are exercised only indirectly through the `GlobalConfigs` facade with real files on disk. There are no isolated unit tests for: (1) malformed lines (non-hex ID, wrong column count, embedded nulls), (2) empty files, (3) files with only blank lines, (4) files that exceed the maximum index limits (`DRIVER_MAX_ID_IDX` = 3000, etc.), or (5) duplicate ID entries. In `readMasterIds()`, if the `option` field parse fails (`!ok`), the entry is still appended because the `ok` check on line 92 only reflects the last conversion. This logic defect and other edge cases are untested.
**Fix:** Add direct `DriverList` unit tests (instantiate a `DriverList` object, write a temporary file, call the read method, assert the list contents) for: empty file, single valid entry, entry with no name field, entry with extra commas, entry with invalid hex ID, entry with id == 0, and a file exceeding the max entry count. Test round-trip (save then read) for all four list types.

---

**A04-3** · HIGH · Logic Defect in readMasterIds() — Failed Option Parse Does Not Skip Entry
**File:** app/driverlist.cpp:85
**Description:** In `readMasterIds()`, when `args.size() >= 2`, the `option` field is parsed and sets `ok`. However, when `args.size() == 3`, the name is then read without resetting or re-checking `ok`. The final `if (ok)` on line 92 will fail if the `option` field was invalid, discarding the entry — but if `args.size() == 2` and the option field is invalid, the entry is still silently discarded even though the name wasn't read. More critically, if `args.size() == 1` (only an ID), `ok` retains the value from the ID parse (true), so the entry is always added with the default `UnassignedMasterMenu` option — but the code at line 85 never enters the option-parse branch, meaning `ok` is still `true` from the ID parse. This is accidentally correct for size==1, but the `ok` variable is being repurposed across unrelated parse steps, making the logic fragile and untested. No test exercises a master list file entry with a bad option value.
**Fix:** Separate `ok` variables for each parsed field, with explicit `continue` on failure. Add a unit test for a master list file with a non-numeric option field to confirm the entry is skipped.

---

**A04-4** · HIGH · No Tests for DriverList Mutation Methods
**File:** app/driverlist.cpp:344
**Description:** The following public methods have zero test coverage: `addDriverId`, `addSuperId`, `addTechId`, `addPreopDriverId`, `removeDriverId`, `removeMasterId`, `removeSuperId`, `removeTechId`, `clearDriverIds`, `clearMasterIds`, `clearSuperIds`, `clearTechIds`, `clearPreopDriverIds`, `setSuperId`, `setTechId`. These methods manage access control lists for drivers, masters, supervisors, technicians, and the once-per-day pre-op list. Undetected defects in add/remove logic could allow unauthorized access or deny authorized users. For example, `addDriverId` contains a slot-reuse strategy (replaces slot with id==0) that is entirely untested.
**Fix:** Add unit tests for each mutation method covering: add to empty list, add duplicate (should update in place), add when list is full (should return false), remove existing entry, remove non-existent entry (should return false), remove id==0 (should return false), and clear operations.

---

**A04-5** · HIGH · No Tests for Checksum Functions
**File:** app/driverlist.cpp:590
**Description:** `driverChecksum()`, `masterChecksum()`, `superChecksum()`, and `techChecksum()` are not tested. These checksums use XOR over all IDs and, for masters, XOR the `option` byte. XOR-based checksums have well-known weaknesses (they cannot detect swapped even-count duplicates, and XOR of a value with itself cancels out). If the checksum functions produce incorrect results, the system may incorrectly flag list corruption or fail to detect actual corruption. Additionally, because the empty-list checksum is 0, an empty list and a list of two identical entries will both produce checksum 0 — an untested collision.
**Fix:** Add unit tests for each checksum function with known inputs and expected XOR-derived outputs. Include a test for the empty list (expected 0), a single-entry list, and the collision case (two identical IDs should produce checksum 0).

---

**A04-6** · MEDIUM · No Test for superIsEmpty() with Mixed Zero and Non-Zero Entries
**File:** app/driverlist.cpp:635
**Description:** `superIsEmpty()` is not tested. The method correctly iterates backwards and returns false if any non-zero entry exists, and true for an all-zero or empty list. However, no test confirms behaviour for a list that has been partially cleared (some entries zeroed via `removeSuperId`), or for an empty list. The delete-by-zeroing pattern used by `removeSuperId` means `m_superIds` always grows and never shrinks; `superIsEmpty()` must handle a list of all-zero values.
**Fix:** Add unit tests: (1) empty list returns true, (2) list with one non-zero entry returns false, (3) list where all entries were removed via `removeSuperId` returns true.

---

**A04-7** · MEDIUM · containsDriverId/containsMasterId/containsSuperId/containsTechId — id==1 Edge Case Untested
**File:** app/driverlist.h:42
**Description:** All four `contains*` inline methods include the guard `return id != 1 ? true : false`, which means ID value 1 is always treated as not present, even if it exists in the list. This is presumably an intentional reserved-ID convention, but it is entirely undocumented and untested. No test inserts id==1 and then calls `containsDriverId(1)` to verify the expected false return. If the convention is ever violated (e.g., a device legitimately gets assigned id==1), authentication could silently fail.
**Fix:** Add explicit test cases: insert id==1 into each list type, then assert that `contains*Id(1)` returns false. Document the reserved-ID convention in a code comment.

---

**A04-8** · MEDIUM · No Tests for Preop Driver ID Subsystem
**File:** app/driverlist.cpp:205
**Description:** The entire once-per-day pre-op subsystem — `readPreopDriverIds`, `savePreopDriverIds`, `addPreopDriverId`, `getPreopDriverId`, `getPreopDriverIdIndex`, `clearPreopDriverIds`, and the `preopDriverIds()` accessor — has no test coverage. `savePreopDriverIds` contains date-filtering logic (only entries whose `lastPreopTimestamp` date matches today are written back), which is a non-trivial stateful computation involving `gCfg->localTime()`. A bug here could either fail to persist valid pre-op records (causing drivers to be re-prompted unnecessarily) or retain stale records (skipping required pre-op checks).
**Fix:** Add unit tests for: `addPreopDriverId` with id==0 (should fail), add a valid id/timestamp, add same id again (should update timestamp), `getPreopDriverId` for existing and non-existing id, `readPreopDriverIds` with a malformed file, and `savePreopDriverIds` date-filtering (write two entries with different dates, call save, confirm only today's entry is retained).

---

**A04-9** · MEDIUM · cigconfigs.h Constants Not Tested for Correct Values or Sizing
**File:** app/cigconfigs.h:26
**Description:** Critical buffer-size and limit constants such as `MODEM_APN_PASSWORD_LEN` (66, comment says must be >= 64), `CHECKLIST_ITEM_SIZE` (computed as `5 + CHECKLIST_QUESTION_LEN`), `CHECKLIST_ITEM_SIZE_100` (computed as `7 + CHECKLIST_QUESTION_LEN_100`), and `CAN_MAX_*` family are never verified by any test. If a refactoring changes `CHECKLIST_QUESTION_LEN` without updating `CHECKLIST_ITEM_SIZE`, serialization bugs would go undetected. No test asserts sizeof any struct against an expected wire-format size.
**Fix:** Add static_assert or test-time assertions for: `CHECKLIST_ITEM_SIZE == 55`, `CHECKLIST_ITEM_SIZE_100 == 107`, `MODEM_APN_PASSWORD_LEN >= 64`, and `sizeof(CigCanConfig)` against a reference value to catch accidental ABI breakage.

---

**A04-10** · MEDIUM · Large Majority of CIGCONF Enum Values Untested
**File:** app/cigconfigs.h:83
**Description:** Of the approximately 17 enums defined in the CIGCONF namespace, only three (`MaintLockedCode`, `ShowTimeFormat`, `CameraMode`) have their numerical values explicitly verified in `test_dialog.cpp::test_enums()`. The remaining 14 enums — including `LeaderCmd` (~80 values), `GmtpMessage` (~24 values), `ConfigErrorCode`, `FtpErrorCode`, `CanProtocol`, `CanAttributeType`, etc. — are never value-checked. If any enum value is reordered without corresponding protocol-level awareness, serialized messages could be misinterpreted by remote systems.
**Fix:** Extend `test_enums()` to verify at minimum the first and last value of each enum that is serialized over a wire protocol or stored to disk. Priority: `GmtpMessage`, `LeaderCmd` sentinels, `CheckReason`, `OnDemandCmdType`.

---

**A04-11** · LOW · crctable.cpp Has No Companion Header
**File:** app/crctable.cpp:3
**Description:** `crctable.cpp` declares its tables with `extern` at the top of the same file, then defines them. Consumers (`globalconfigs.cpp`, `backgroundworker.cpp`) also declare their own local `extern` references. There is no shared header (`crctable.h` does not exist), so nothing prevents a consumer from declaring the array with a wrong type or wrong size. This is a minor architectural issue but can mask type errors at compile time.
**Fix:** Create `app/crctable.h` exposing `extern const quint32 crc32Table[256];` and `extern const quint16 crc16Table[16];` and include it in all consumers and in `crctable.cpp`. This gives the compiler one authoritative declaration to check against.

---

**A04-12** · LOW · savePreopDriverIds Uses QFile Instead of QSaveFile
**File:** app/driverlist.cpp:244
**Description:** `savePreopDriverIds()` opens the pre-op driver ID file using `QFile` with `WriteOnly`, unlike the other four save methods (`saveDriverIds`, `saveMasterIds`, `saveSuperIds`, `saveTechIds`) which all use `QSaveFile` for atomic write-then-commit. If the process is interrupted or power is lost mid-write with `QFile`, the file can be left partially written or truncated, potentially losing all pre-op history for the day. This inconsistency is untested because `savePreopDriverIds` has no test coverage.
**Fix:** Refactor `savePreopDriverIds()` to use `QSaveFile` and `commit()` for atomic write semantics, consistent with all other save methods. Add a test that simulates the save and verifies the file contents.

---

## Summary Table

| ID | Severity | Category | File | Tested? |
|----|----------|----------|------|---------|
| A04-1 | CRITICAL | Missing CRC test coverage | app/crctable.cpp:6 | No |
| A04-2 | HIGH | No file-parsing tests (normal/malformed) | app/driverlist.cpp:16 | No |
| A04-3 | HIGH | Logic defect in readMasterIds — bad option parse | app/driverlist.cpp:85 | No |
| A04-4 | HIGH | No tests for add/remove/clear mutations | app/driverlist.cpp:344 | No |
| A04-5 | HIGH | No tests for checksum functions | app/driverlist.cpp:590 | No |
| A04-6 | MEDIUM | superIsEmpty() not tested | app/driverlist.cpp:635 | No |
| A04-7 | MEDIUM | id==1 reserved-ID guard untested | app/driverlist.h:42 | No |
| A04-8 | MEDIUM | Preop driver ID subsystem entirely untested | app/driverlist.cpp:205 | No |
| A04-9 | MEDIUM | cigconfigs.h constants not verified | app/cigconfigs.h:26 | No |
| A04-10 | MEDIUM | Most CIGCONF enum values not tested | app/cigconfigs.h:83 | No |
| A04-11 | LOW | No crctable.h header | app/crctable.cpp:3 | N/A |
| A04-12 | LOW | savePreopDriverIds uses QFile not QSaveFile | app/driverlist.cpp:244 | No |

**Total findings:** 12 (1 CRITICAL, 4 HIGH, 5 MEDIUM, 2 LOW)
