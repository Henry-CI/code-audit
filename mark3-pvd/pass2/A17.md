# Audit Report — Agent A17 (Pass 2: Test Coverage)

**Audit run:** 2026-02-28-01
**Agent:** A17
**Pass:** 2 — Test Coverage
**Branch confirmed:** master (verified via `git branch --show-current`)

---

## Assigned Files

| File | Lines |
|------|-------|
| `platform/userport.h` | 32 |
| `platform/userport.cpp` | 91 |
| `platform/wiegandrfid.h` | 32 |
| `platform/wiegandrfid.cpp` | 167 |
| `platform/wifi.h` | 74 |
| `platform/wifi.cpp` | 300 |

---

## Reading Evidence

### platform/userport.h

**Class:** `EM070::UserPort` (inherits `QObject`)

| Symbol | Kind | Line |
|--------|------|------|
| `UserPort(QObject *parent = nullptr)` | public constructor | 15 |
| `response(const QByteArray &ba)` | public method | 16 |
| `setBaudRate(QSerialPort::BaudRate baudRate)` | public method | 18 |
| `cmdReceived(const QByteArray &ba)` | signal | 21 |
| `readData()` | private slot (connected via `readyRead`) | 24 |

**Includes:** `<QObject>`, `<QSerialPort>`

**Behaviour notes:**
- Constructor opens `/dev/ttyS1` (ARM) or `COM2` (non-ARM) via `QSerialPort::open(ReadWrite)`.
- On open failure (line 34-37): logs `qCritical`, returns silently — port is left closed, no signal emitted.
- `readData()` (line 54-76): accumulates characters; emits `cmdReceived` on CR/LF; handles backspace; echoes characters back to serial port when RS-232 accessory is not active.
- `response()` (line 78-86): writes only if port `isOpen()` — safe guard present, but no error signal on write-to-closed-port.
- `setBaudRate()` (line 88-91): forwards directly to `QSerialPort` with no open-check guard.
- `TEST_MODE == 1` wires stdin as a substitute data source.

---

### platform/wiegandrfid.h

**Class:** `EM070::WiegandRfid` (inherits `QObject`)

| Symbol | Kind | Line |
|--------|------|------|
| `WiegandRfid(QObject *parent = 0)` | public constructor | 14 |
| `setEnabled(bool enable)` | public method | 15 |
| `wiegandData(quint8 facility, quint32 number)` | public static method | 17 |
| `cardData(quint64, quint16, quint32, QByteArray&)` | signal | 20 |
| `error(const QString &text)` | signal | 21 |
| `activated()` | private slot | 24 |

**Includes:** `<QFile>`, forward decl `QSocketNotifier`

**Behaviour notes (wiegandrfid.cpp):**
- Reads three sysfs files: `card_ready`, `card_data`, `raw_data`.
- `activated()` (line 24-104): full dispatch pipeline.
  - Reads `card_data` as `"facility,number"` CSV; if both non-zero emits `cardData` (Wiegand-26/42 path).
  - Falls through to `raw_data` as `"bits,wiegand"` CSV.
  - 34-bit path (lines 67-80): strips outer parity bit, right-shifts, extracts facility (bits 16-23) and number (bits 0-15).
  - 37-bit path (lines 83-96): fully commented out — no runtime support.
  - Falls through to `bits >= 26` path (lines 98-101): emits `cardData(wiegand, 0, 0, ba)` with zero facility/number.
  - Always emits `error(ba)` after the `>= 26` path (line 103) — even when a card was successfully processed by that block.
- `wiegandData()` (lines 111-166): encodes Wiegand-26 or Wiegand-42 with parity.
  - For `number > 99999`: emits `qCritical` and returns 0 without an `error` signal.
- Constructor: on `card_ready` open failure (line 15-18): logs `qCritical`, returns — `m_notifier` is never initialised; `setEnabled()` will then dereference a null pointer (UB).

---

### platform/wifi.h

**Class:** `EM070::Wifi` (inherits `QObject`)

| Symbol | Kind | Line |
|--------|------|------|
| `Wifi(EM070::UserPort *userPort)` | public constructor | 26 |
| `~Wifi()` | public destructor (empty) | 27 |
| `writeConf()` | public method | 29 |
| `restart()` | public method | 31 |
| `status()` | public method (inline) | 33 |
| `startPositioning()` | public method | 34 |
| `parseResponse(const QByteArray &ba)` | public method | 36 |
| `accessPoints()` | public method (inline) | 38 |
| `setCellularState(bool state)` | public method | 40 |
| `setPowerState(CIGCONF::PowerState state)` | public method | 42 |
| `ethernetStateChanged(bool ready)` | signal | 46 |
| `wifiReconnectionFailed()` | signal | 47 |
| `wifiScanFinished(QList<CIGCONF::AccessPoint>)` | signal | 48 |
| `attemptReconnectToWifi()` | private method | 51 |
| `checkStatus()` | private method | 52 |
| `scanAccessPoints()` | private method | 53 |
| `scanFinished(int, QProcess::ExitStatus)` | private method | 54 |

**Includes:** `../app/cigconfigs.h`, `<QObject>`, `<QByteArray>`, `<QList>` (duplicated at lines 7 and 11), `<QProcess>`, `<QNetworkConfigurationManager>`, `<QTimer>`

**Behaviour notes (wifi.cpp):**
- `writeConf()` (lines 46-80): writes `wpa_supplicant.conf`; passphrase < 8 chars or > 63 chars causes `key_mgmt=NONE` (open network) — silently degrades security.
- `checkStatus()` (lines 96-144): skips all processing if `m_powerState != NormalPowerState`; iterates `QNetworkConfigurationManager`; emits `ethernetStateChanged`.
- `attemptReconnectToWifi()` (lines 153-189): actual nmcli reconnect block is entirely commented out (lines 174-188); `wifiReconnectionFailed` signal is therefore never emitted.
- `scanFinished()` (lines 266-295): parses `iw wlan0 scan` output in fixed 4-line groups without bounds checking; `wifiScanFinished` signal is never emitted.
- `parseResponse()` (line 218): accesses `ba.at(0)` without checking `ba.isEmpty()`.

---

## Test Coverage Search Results

**Test directory searched:** `C:/Projects/cig-audit/repos/mark3-pvd/test/`

**Test files found:**
- `test_backgroundworker.cpp` / `.h`
- `test_canbus.cpp` / `.h`
- `test_dialog.cpp` / `.h`
- `test_ota.cpp` / `.h`

**Search terms used:** `UserPort`, `WiegandRfid`, `Wifi`, `wiegandrfid`, `wifi`, `response`, `setBaudRate`, `readData`, `cmdReceived`, `wiegandData`, `cardData`, `setEnabled`, `activated`, `writeConf`, `restart`, `checkStatus`, `scanAccessPoints`, `parseResponse`, `startPositioning`, `scanFinished`, `attemptReconnect`, `setCellularState`, `setPowerState`, `ethernetStateChanged`, `wifiReconnectionFailed`, `wifiScanFinished`

**Results:**

| Class | Usage in tests | Behavioural tests |
|-------|---------------|-------------------|
| `UserPort` | Instantiated as fixture dependency in all 4 test files (lines 30, 29, 34, 49 of respective files) | None — object created and injected into `BackgroundWorker`; no public methods called directly, no signals observed |
| `WiegandRfid` | Not referenced at all | None |
| `Wifi` | Not referenced at all | None |

All three classes have **zero behavioural test coverage**.

---

## Findings

---

**A17-1** · CRITICAL · Missing Test Coverage — UserPort Serial Port Open Failure
**File:** `platform/userport.cpp:34-37`
**Description:** When the serial port cannot be opened (device absent, permission denied, port busy), the constructor logs a `qCritical` message and returns silently. `m_serialPort` is left closed. No signal is emitted to inform callers. Subsequent `response()` calls silently discard data (guarded by `isOpen()` at line 80). Calls to `setBaudRate()` (lines 88-91) reach the underlying `QSerialPort` without any open-check guard. There is no test exercising this failure path — neither for graceful degradation, caller notification, nor safety of post-failure method calls.
**Fix:** Add a unit test that instantiates `UserPort` with an invalid port name (using the `QT_USER_SERIAL_PORT` environment variable override at line 18-20), then verifies: (a) `m_serialPort->isOpen()` is false; (b) subsequent `response()` calls do not crash; (c) subsequent `setBaudRate()` calls do not crash. Add a dedicated `error` signal or `isValid()` accessor to `UserPort` to allow callers to detect the open failure.

---

**A17-2** · CRITICAL · Missing Test Coverage — UserPort readData Character State Machine
**File:** `platform/userport.cpp:54-76`
**Description:** `readData()` contains a non-trivial character-by-character state machine: CR/LF triggers `cmdReceived`, backspace removes the last buffered character and conditionally writes an erase sequence, all other characters accumulate. None of this logic is tested. Untested cases include: (a) multi-character commands ending with CR emitting `cmdReceived`; (b) backspace on an empty buffer (no crash, no array underrun); (c) the echo-back path when `gCfg->isRs232AccessoryActive()` is false; (d) multiple bytes arriving in a single `readAll()` call containing a mix of normal chars, backspace, and CR.
**Fix:** Refactor `readData()` to accept a `QByteArray` parameter directly (or extract its logic into a pure function) to enable unit testing without a live serial port. Add tests for each of the cases listed above and confirm `cmdReceived` carries the correct payload.

---

**A17-3** · HIGH · Missing Test Coverage — WiegandRfid Null Pointer on Constructor Failure
**File:** `platform/wiegandrfid.cpp:14-22`, `106-108`
**Description:** If `m_cardReadyFile.open()` fails (sysfs file absent, hardware not present), the constructor returns without initialising `m_notifier`. The member is declared as a raw pointer (`QSocketNotifier *m_notifier`) with no in-class initialiser and is not set in the member initialiser list, leaving it uninitialised. A subsequent call to `setEnabled()` dereferences this pointer, causing undefined behaviour (likely a crash in production). No test exercises the constructor failure path or `setEnabled()` in any state.
**Fix:** Initialise `m_notifier` to `nullptr` in the member initialiser list. Add a null-check guard in `setEnabled()` before dereferencing. Add a unit test that simulates a missing sysfs file (via a configurable file-path parameter or environment variable) and verifies that `setEnabled(true)` and `setEnabled(false)` do not crash.

---

**A17-4** · HIGH · Missing Test Coverage — WiegandRfid Wiegand-26 Parity Encoding
**File:** `platform/wiegandrfid.cpp:141-163`
**Description:** `wiegandData()` encodes a Wiegand-26 frame. The parity calculation iterates 12 bits for even leading parity (lines 145-151) and a further 12-bit window for odd trailing parity (lines 154-162). Whether these two windows correctly cover the intended bit ranges of the Wiegand-26 standard (12 MSBs of the 24-bit card body for even parity, 12 LSBs for odd parity) is unverified. The Wiegand-42 branch (number 65536-99999, lines 132-140) is also untested. The case `number > 99999` (line 127-129) returns 0 with only a `qCritical` log and no `error` signal.
**Fix:** Add unit tests for `WiegandRfid::wiegandData()` using known Wiegand-26 test vectors with precomputed expected 26-bit output (including parity bits). Cover: (a) facility 0, number 0; (b) facility 255, number 65535; (c) Wiegand-42 path (number 65536-99999); (d) number > 99999 (verify return 0 and no crash). Test vectors should be independently derived from the Wiegand standard specification.

---

**A17-5** · HIGH · Missing Test Coverage — WiegandRfid 34-bit Decode and Dual Signal Emission
**File:** `platform/wiegandrfid.cpp:67-80`, `98-103`
**Description:** The 34-bit path strips the MSB parity bit via `& ~((quint64)1<<33)`, right-shifts by 1, then extracts facility from bits 16-23 and number from bits 0-15. This decode is never tested. Additionally, when facility and number are both zero after 34-bit decode, the condition at line 76 fails and execution falls through to the `bits >= 26` block at line 98 which emits `cardData(wiegand, 0, 0, ba)` and then unconditionally emits `error(ba)` at line 103 — producing two signals simultaneously for the same read event, which may confuse or double-process the event in consumers.
**Fix:** Add unit tests for the 34-bit decode path using precomputed raw values. Specifically test the zero-facility/zero-number edge case and assert that only the expected signals (not both) are emitted. Investigate and fix the dual-emission logic.

---

**A17-6** · HIGH · Missing Test Coverage — WiegandRfid Silent Error Paths and Unconditional error Emission
**File:** `platform/wiegandrfid.cpp:31-32`, `35-37`, `54-57`, `103`
**Description:** Multiple error paths in `activated()` return silently without emitting `error`: (a) `card_ready` reads a value that is zero or non-numeric (line 31-32); (b) `card_data` file open failure (line 35-37); (c) `raw_data` file open failure (line 54-57). None of these silent returns are tested. Additionally, `error(ba)` at line 103 is emitted unconditionally even after a `cardData` signal was emitted at line 100 (the `bits >= 26` path), meaning successful partial reads generate a spurious `error`.
**Fix:** Audit the intended semantics of each return path with respect to the `error` signal. Add tests simulating each failure path and assert the expected signal behaviour (silent return vs. `error` emission). Fix line 103 to only fire when no valid card data was found in the `>= 26` fallback path.

---

**A17-7** · HIGH · Missing Test Coverage — WiegandRfid 37-bit Decode Commented Out
**File:** `platform/wiegandrfid.cpp:83-96`
**Description:** The 37-bit HID format decode block is entirely commented out with no explanation. Sites using 37-bit HID readers will have their cards fall through to the `bits >= 26` block, emitting `cardData` with zero facility and number, which is likely not the intended behaviour. There is no test for this fallback, no documentation of why the code is disabled, and no indication of whether re-enabling it is planned.
**Fix:** Either re-enable the 37-bit decode with associated unit tests using known 37-bit test vectors, or add an explicit code comment citing the specific defect or hardware incompatibility that caused it to be disabled. Add a test asserting the current (fallback) behaviour for a 37-bit input so any future change is caught.

---

**A17-8** · HIGH · Missing Test Coverage — Wifi writeConf Passphrase and SSID Boundary Conditions
**File:** `platform/wifi.cpp:60-74`
**Description:** `writeConf()` silently degrades a configured WPA network to an open network (`key_mgmt=NONE`) when the passphrase is empty, shorter than 8 characters, or longer than 63 characters. It silently skips networks with SSID longer than 32 characters. These are security-critical code paths. No test verifies any of these conditions or the content of the written `wpa_supplicant.conf` file.
**Fix:** Add unit tests for `writeConf()` using a writable temporary file (inject the output path). Cover: (a) 0-char passphrase → `key_mgmt=NONE`; (b) 7-char passphrase → `key_mgmt=NONE`; (c) 8-char passphrase → PSK stanza; (d) 63-char passphrase → PSK stanza; (e) 64-char passphrase → `key_mgmt=NONE`; (f) SSID of 32 chars → included; (g) SSID of 33 chars → skipped; (h) empty SSID → skipped. Assert the exact file content in each case.

---

**A17-9** · HIGH · Missing Test Coverage — Wifi connect/disconnect State Machine and ethernetStateChanged Signal
**File:** `platform/wifi.cpp:96-144`
**Description:** `checkStatus()` is the core WiFi state machine, transitioning `m_wifiStatus` and emitting `ethernetStateChanged`. Neither the connect nor disconnect transition is tested. Specific untested scenarios: (a) initial connect emitting `ethernetStateChanged(true)`; (b) disconnect emitting `ethernetStateChanged(false)` and triggering reconnect; (c) the `NormalPowerState` guard suppressing all processing; (d) `m_reconnectTimer` interaction during disconnect.
**Fix:** Add unit tests that mock or stub `QNetworkConfigurationManager` (via a thin wrapper or subclass) to simulate configuration state changes. Assert `ethernetStateChanged` signal emissions and `m_wifiStatus` transitions for each scenario.

---

**A17-10** · HIGH · Missing Test Coverage — Wifi Reconnection Logic Dead Code and wifiReconnectionFailed Never Emitted
**File:** `platform/wifi.cpp:153-189`
**Description:** `attemptReconnectToWifi()` contains an entirely commented-out nmcli reconnect block (lines 174-188). This was the only code path that could emit `wifiReconnectionFailed`. As implemented today, `wifiReconnectionFailed` is declared but never emitted anywhere in the codebase — it is a dead signal. The active code only issues DHCP process signals (USR2/USR1) without confirming reconnection success. Association failure, DHCP failure, and wrong-passphrase scenarios all have no runtime handling and no tests.
**Fix:** Restore the reconnect mechanism (nmcli or equivalent) and emit `wifiReconnectionFailed` on confirmed repeated failure. Add tests asserting: (a) `wifiReconnectionFailed` emitted after association failure; (b) `ethernetStateChanged(true)` emitted on subsequent success; (c) timer-based retry behaviour.

---

**A17-11** · MEDIUM · Missing Test Coverage — Wifi parseResponse Empty Buffer Access
**File:** `platform/wifi.cpp:218`
**Description:** `parseResponse()` calls `ba.at(0)` without first verifying that `ba` is non-empty. `QByteArray::at()` on an empty array has undefined behaviour (returns garbage or crashes depending on Qt build and platform). An empty byte array can arrive as a line-split artefact from the serial port or from a caller passing an empty response. No test exercises this path.
**Fix:** Add a guard `if (ba.isEmpty()) return;` immediately before line 218. Add a unit test passing an empty `QByteArray` to `parseResponse()` and verifying the method returns without crashing.

---

**A17-12** · MEDIUM · Missing Test Coverage — Wifi wifiScanFinished Signal Never Emitted and Parser Bounds Risk
**File:** `platform/wifi.cpp:266-295`
**Description:** `scanFinished()` populates `m_accessPoints` but never emits `wifiScanFinished`. The signal is declared (header line 48) but is a dead signal. The parser assumes `iw wlan0 scan` output arrives in exact 4-line groups per access point; if the output does not divide evenly by 4, `n = results.size() / 4` truncates silently, discarding the trailing partial entry — but does not cause an out-of-bounds read because the loop bound is `n`. However, the implicit assumption of exactly 4 lines per BSS entry is fragile and entirely untested. The accessor `accessPoints()` requires polling by consumers instead of an event-driven notification.
**Fix:** Emit `wifiScanFinished(m_accessPoints)` at the end of `scanFinished()`. Add unit tests that supply known `iw scan` output strings (via mock or parse-function extraction) and assert correct `m_accessPoints` content. Test inputs that do not divide evenly by 4.

---

**A17-13** · LOW · Duplicate Include in wifi.h
**File:** `platform/wifi.h:7`, `11`
**Description:** `<QList>` is included twice (lines 7 and 11). Harmless due to include guards but indicates inattentive maintenance.
**Fix:** Remove the duplicate `#include <QList>` at line 11.

---

## Summary Table

| ID | Severity | Category | File | Line(s) | Coverage Gap |
|----|----------|----------|------|---------|--------------|
| A17-1 | CRITICAL | Test Coverage / Error Handling | `platform/userport.cpp` | 34-37 | Serial port open failure path entirely untested |
| A17-2 | CRITICAL | Test Coverage / Logic | `platform/userport.cpp` | 54-76 | `readData()` character state machine entirely untested |
| A17-3 | HIGH | Test Coverage / Null Pointer UB | `platform/wiegandrfid.cpp` | 14-22, 106-108 | Constructor failure leaves `m_notifier` uninitialised; crash on `setEnabled()` untested |
| A17-4 | HIGH | Test Coverage / Logic | `platform/wiegandrfid.cpp` | 141-163 | Wiegand-26 and Wiegand-42 parity encoding logic untested |
| A17-5 | HIGH | Test Coverage / Logic | `platform/wiegandrfid.cpp` | 67-80, 98-103 | 34-bit decode untested; dual signal emission on zero facility/number |
| A17-6 | HIGH | Test Coverage / Error Handling | `platform/wiegandrfid.cpp` | 31-32, 35-37, 54-57, 103 | Silent-return error paths and unconditional `error` emission untested |
| A17-7 | HIGH | Test Coverage / Dead Code | `platform/wiegandrfid.cpp` | 83-96 | 37-bit decode commented out; no test, no rationale, no fallback test |
| A17-8 | HIGH | Test Coverage / Security | `platform/wifi.cpp` | 60-74 | `writeConf()` passphrase and SSID boundary conditions untested |
| A17-9 | HIGH | Test Coverage / Logic | `platform/wifi.cpp` | 96-144 | WiFi connect/disconnect state machine and `ethernetStateChanged` signal untested |
| A17-10 | HIGH | Test Coverage / Dead Code | `platform/wifi.cpp` | 153-189 | Reconnect logic commented out; `wifiReconnectionFailed` dead signal, never tested |
| A17-11 | MEDIUM | Test Coverage / Crash Risk | `platform/wifi.cpp` | 218 | `ba.at(0)` without empty-check; no test for empty input |
| A17-12 | MEDIUM | Test Coverage / Dead Signal | `platform/wifi.cpp` | 266-295 | `wifiScanFinished` never emitted; scan parser untested |
| A17-13 | LOW | Code Quality | `platform/wifi.h` | 7, 11 | Duplicate `#include <QList>` |

---

## Overall Assessment

All three classes (`UserPort`, `WiegandRfid`, `Wifi`) have **zero behavioural test coverage**. Across 4 test suite files, `UserPort` is instantiated only as a fixture dependency for `BackgroundWorker`; no public method is called on it directly and no signal is observed. `WiegandRfid` and `Wifi` are not referenced in the test suite at all.

The following production code paths are entirely unverified:

- Serial port lifecycle (open, read, write, close, error)
- Wiegand card decode logic for all bit-widths (26, 34, and 37-bit which is dead code)
- Wiegand parity bit generation
- WiFi configuration file generation including security-critical passphrase handling
- WiFi connect/disconnect state machine
- WiFi reconnection logic (which is also dead code)
- All `error` signals and error return paths across all three classes

Two findings (A17-1, A17-2) are rated CRITICAL because `UserPort` represents core hardware I/O whose correctness cannot be verified without tests, and both contain known untested edge cases (open failure with post-failure method calls, backspace on empty buffer). A17-3 is rated HIGH rather than CRITICAL only because the null-pointer UB in `WiegandRfid` requires a hardware-absence scenario to trigger at runtime, but it is a certain crash if triggered.
