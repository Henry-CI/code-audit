# Audit Report — Agent A22 (Pass 2: Test Coverage)

**Audit Run:** 2026-02-28-01
**Agent:** A22
**Branch confirmed:** master (verified via `git branch --show-current`)
**Date:** 2026-02-28

---

## Assigned Files

| File | Role |
|---|---|
| `ui/lockeddialog.h` | Lock-screen dialog header |
| `ui/lockeddialog.cpp` | Lock-screen dialog implementation |
| `ui/messagedialog.h` | Status/auth message dialog header |
| `ui/messagedialog.cpp` | Status/auth message dialog implementation |
| `ui/onScreenKeyboard.h` | On-screen keyboard widget header |
| `ui/onScreenKeyboard.cpp` | On-screen keyboard widget implementation |

Primary test file examined: `test/test_dialog.cpp` + `test/test_dialog.h`
Additional test files scanned: `test/test_backgroundworker.cpp`, `test/test_canbus.cpp`, `test/test_ota.cpp`

---

## Reading Evidence

### LockedDialog (`ui/lockeddialog.h` + `ui/lockeddialog.cpp`)

**Class:** `LockedDialog : public QDialog`

**Includes:**
- `lockeddialog.h` (self)
- `ui_lockeddialog.h` (generated)
- `platform/pwmbeeper.h`
- `platform/seriallogger.h`
- `app/globalconfigs.h`
- `app/cigconfigs.h`
- `<QDialog>`, `<QTimer>`

**Public methods (with line numbers):**

| Line | Method |
|---|---|
| h:18 | `explicit LockedDialog(QWidget *parent = 0)` — constructor |
| h:19 | `~LockedDialog()` — destructor |
| h:20 | `void setLockedReason(CIGCONF::MaintLockedCode lockedCode)` |
| h:21 | `void languageChanged(void)` |
| h:22 | `void setTimeRemaining(quint32 secs)` |
| h:23 | `void clearTimerText()` |
| h:24 | `void stopTimer()` |
| h:25 | `void startTimer()` |

**Signals (with line numbers):**

| Line | Signal |
|---|---|
| h:32 | `void fullLockoutTimerEnded(bool on1, bool on2)` |
| h:33 | `void beeperOn()` |

**Protected method (critical):**

| Line | Method |
|---|---|
| h:36 | `void mouseReleaseEvent(QMouseEvent *) {accept();}` |

**Private methods:**

| Line | Method |
|---|---|
| cpp:77 | `void fullLockStart()` |
| cpp:84 | `void updateFullLock()` (slot, private) |

**UNIT_TEST friend:** `friend class TestDialog;` at h:28 (conditionally compiled under `#ifdef UNIT_TEST`), granting access to `ui` member.

**`setLockedReason` switch cases:** `MaintCriticalQuestion`, `MaintRedImpact`, `MaintSurveyTimeout`, `MaintIdle`, `default`.

---

### MessageDialog (`ui/messagedialog.h` + `ui/messagedialog.cpp`)

**Class:** `MessageDialog : public QDialog`

**Includes:**
- `messagedialog.h` (self)
- `ui_messagedialog.h` (generated)
- `<QMovie>`, `<QTimer>`, `<QDebug>`
- `<QDialog>`

**Defines:** `WAIT_AUTH_TIME 10000`, `NOT_AUTH_TIME 5000`

**Public enum `MessageType`** (h:18-27):
`NoMessage`, `ExpansionConnecting`, `WaitForAuthorised`, `NotAuthorised`, `OnDemandNotAuthorised`, `PowerOff`, `Reboot`, `VehicleOutOfService`

**Public methods (with line numbers):**

| Line | Method |
|---|---|
| h:29 | `explicit MessageDialog(QWidget *parent = 0)` — constructor |
| h:30 | `~MessageDialog()` — destructor |
| h:31 | `void openWithMessage(MessageType type)` — inline; calls `setMessageType(type); open()` |
| h:33 | `void setMessageType(MessageType type)` |
| h:34 | `MessageType messageType() const` — inline getter |

**Protected method:**

| Line | Method |
|---|---|
| h:37 / cpp:35 | `void hideEvent(QHideEvent *)` — stops timer and movie, resets `m_messageType` to `NoMessage` |

**UNIT_TEST friend:** None declared.

**Timer behaviour:** `WaitForAuthorised` starts a 10-second single-shot timer; on timeout transitions to `NotAuthorised`. `NotAuthorised`, `OnDemandNotAuthorised`, and `VehicleOutOfService` start a 5-second single-shot timer; on timeout calls `reject()`.

---

### onScreenKeyboard (`ui/onScreenKeyboard.h` + `ui/onScreenKeyboard.cpp`)

**Class:** `onScreenKeyboard : public QWidget`

**Includes:**
- `onScreenKeyboard.h` (self)
- `ui_onScreenKeyboard.h` (generated)
- `<QtGui>`, `<QWidget>`, `<QPushButton>`

**Public enums:**
- `KeyToggleState { Normal, Upper, Lower }` (h:17)
- `CaseButton { AllButtons, CapsButton, ShiftButton, SymbolButton }` (h:18)
- `CtrlButton { None, Backspace, Delete }` (h:19)

**Public methods (with line numbers):**

| Line | Method |
|---|---|
| h:20 | `explicit onScreenKeyboard(QWidget *parent = 0)` — constructor |
| h:21 | `~onScreenKeyboard()` — destructor |
| h:22 | `QPushButton *enterButton` — public data member |
| h:24 | `void setInitialText(QString str)` |
| h:25 | `void languageChanged(void)` |

**Signals (with line numbers):**

| Line | Signal |
|---|---|
| h:36 | `void updateText(QString str, CtrlButton ctrl)` |
| h:37 | `void onScreenKeyboardClose()` |

**Private slots (with line numbers):**

| Line | Slot |
|---|---|
| h:28 / cpp:61 | `void keyboardHandler()` — dispatches character key presses |
| h:29 / cpp:113 | `void on_btnShift_clicked(bool checked)` |
| h:30 / cpp:184 | `void on_btnEnter_clicked()` — clears `outputText`, resets case buttons, calls `close()` |
| h:31 / cpp:192 | `void on_btnBack_clicked()` — emits `updateText("", Backspace)` |
| h:32 / cpp:197 | `void on_btnCaps_toggled(bool checked)` |
| h:33 / cpp:202 | `void on_btnHideKeyboard_clicked()` — resets case, calls `close()` |
| h:34 / cpp:243 | `void on_btnDelete_clicked()` — emits `updateText("", Delete)` |

**Protected method:**

| Line | Method |
|---|---|
| h:40 / cpp:107 | `void closeEvent(QCloseEvent *event)` — emits `onScreenKeyboardClose()`, accepts event |

**Private methods (with line numbers):**

| Line | Method |
|---|---|
| h:43 / cpp:145 | `void toggle()` — updates all button labels based on Caps/Shift state |
| h:44 / cpp:127 | `QString dualCharCase(QString ch, int toggleState)` |
| h:45 / cpp:119 | `QString singleCharCase(QString ch, int toggleState)` |
| h:46 / cpp:209 | `void setCaseButton(CaseButton btn, bool set)` |

**Key behaviours of note:**
- `keyboardHandler()` reads `button->text()`, splits on `"\n"` for dual-character keys, applies caps/shift logic, then emits `updateText(outputText, None)`. There is no maximum input length guard.
- `on_btnBack_clicked()` emits `updateText("", Backspace)` — backspace is delegated to the receiver.
- `on_btnDelete_clicked()` emits `updateText("", Delete)` — delete (clear) is also delegated.
- `setInitialText()` sets `outputText` but does not pre-fill the display widget; no truncation.
- The SPACE button sets `outputText = " "` (a single space), not appending.
- The `"\\"` case at cpp:75-77 retrieves `ui->Buttonr->text()` rather than a literal backslash — this is a logic error with no test to catch it.

**UNIT_TEST friend:** None declared.

---

## Test Coverage Analysis

### Search results across the entire `test/` directory

**`LockedDialog` symbol hits:**
- `test_dialog.cpp:386` — `QVERIFY(!m_dialog->m_lockedDialog->isVisible())` — negative visibility check only
- `test_dialog.cpp:399` — `QVERIFY(m_dialog->m_lockedDialog->isVisible())` — positive visibility check
- `test_dialog.cpp:400` — `QVERIFY(m_dialog->m_lockedDialog->ui->labelReason->text().contains("Idle"))` — reason text, MaintIdle only

**`MessageDialog` symbol hits:** Zero matches in any test file.

**`onScreenKeyboard` symbol hits:** Zero matches in any test file.

**LockedDialog methods with any test coverage:**
- `startTimer()` — indirectly exercised when `lockScreen()` is called in `test_idleLockout()` and `test_unlockMode1()`, but only as a side-effect with no assertions on timer state.
- `setLockedReason()` — called indirectly via `lockScreen()`; the Idle reason label is checked once at line 400; no other codes are asserted.
- `stopTimer()` — no test assertions.
- `clearTimerText()` — no test assertions.
- `setTimeRemaining()` — no test assertions.
- `languageChanged()` — no test assertions.
- `fullLockStart()` / `updateFullLock()` — no test assertions.
- `fullLockoutTimerEnded` signal — no test assertions.
- `beeperOn` signal — no test assertions.
- `mouseReleaseEvent` — zero tests.

**MessageDialog methods with zero test coverage:** All — constructor, `openWithMessage`, `setMessageType` (all 7 enum paths), `messageType`, `hideEvent`.

**onScreenKeyboard methods with zero test coverage:** All — constructor, `setInitialText`, `languageChanged`, `keyboardHandler`, all button slots, `closeEvent`, all private helpers.

---

## Findings

---

**A22-1** · CRITICAL · Missing Security Test — Lock Bypass via Touch

**File:** `ui/lockeddialog.h:36`

**Description:** The `mouseReleaseEvent` override unconditionally calls `accept()` on any touch anywhere on the lock screen. This causes `LockedDialog::accepted` to fire, which is connected at `ui/dialog.cpp:112` to `Dialog::onPinCode()` — opening the PIN entry dialog. A prior security audit identified this as a touch-bypass vulnerability. Not a single test in the suite verifies that the lock screen enforces any authentication gate before the PIN dialog is opened. There is no test that simulates a raw touch or click event on `LockedDialog` and confirms the expected flow (PIN prompt required) versus an unexpected flow (immediate unlock). The `TestDialog` friend declaration (`h:28`) is conditionally compiled under `#ifdef UNIT_TEST`, meaning the test harness already has the access required to write such a test, yet none exists.

**Fix:** Add a dedicated test (e.g., `test_lockScreenBypass`) that:
1. Calls `m_dialog->lockScreen(CIGCONF::MaintRedImpact, true)` and verifies `m_lockedDialog->isVisible()` is true.
2. Uses `QTest::mouseClick(m_dialog->m_lockedDialog, Qt::LeftButton)` to simulate a tap on the locked dialog.
3. Asserts that `gCfg->maintCode()` remains `MaintRedImpact` and `m_dialog->m_authorisedDialog->isVisible()` is false — confirming that a PIN prompt (not an immediate unlock) is the result of the touch.
4. Verifies that submitting an incorrect PIN keeps the lock active and that `m_lockedDialog` is re-shown.
Additionally, consider whether `mouseReleaseEvent` should be guarded by `m_bleReady` or another precondition matching the guard already present in `Dialog::onPinCode()` at `ui/dialog.cpp:271`.

---

**A22-2** · HIGH · No Tests for Lock Reason Label (Non-Idle Codes)

**File:** `ui/lockeddialog.cpp:36–58`

**Description:** `setLockedReason()` has five distinct branches (`MaintCriticalQuestion`, `MaintRedImpact`, `MaintSurveyTimeout`, `MaintIdle`, and `default`). Only the `MaintIdle` branch is incidentally checked via a `.contains("Idle")` assertion at `test_dialog.cpp:400`. The remaining four branches — including the safety-critical `MaintRedImpact` and `MaintCriticalQuestion` codes — have zero test coverage. A regression could silently corrupt the label text shown to the operator for any non-idle lock reason without the test suite catching it.

**Fix:** Add parameterised test cases that directly call `m_dialog->m_lockedDialog->setLockedReason(code)` for each `MaintLockedCode` enum value and assert the exact `ui->labelReason->text()` string. The `friend class TestDialog` declaration in the header (h:28, compiled under `#ifdef UNIT_TEST`) grants access to the `ui` pointer, so no additional access mechanism is required.

---

**A22-3** · HIGH · No Tests for Full Lock Countdown Timer

**File:** `ui/lockeddialog.cpp:77–95`

**Description:** `fullLockStart()` and `updateFullLock()` implement a countdown that ultimately emits `fullLockoutTimerEnded(false, false)` — a signal connected in `ui/dialog.cpp:113–115` that closes vehicle relays and physically shuts down the machine. This safety-critical path has zero test coverage. No test verifies: that the timer fires with the correct 1-second interval; that `setTimeRemaining()` updates `lblLockOutTime` correctly; that the countdown decrements `m_timeCntr` to zero; that `fullLockoutTimerEnded` is emitted with `(false, false)` at expiry; or that `stopTimer()` halts the countdown. The `beeperOn` signal emitted from `startTimer()` is also never captured by any `QSignalSpy`.

**Fix:** Add a `test_fullLockTimer()` test that:
1. Sets `gCfg->fullLockoutEnable()` to true and `gCfg->fullLockoutTimeout()` to a small value (e.g., 2 seconds).
2. Calls `m_dialog->m_lockedDialog->startTimer()`.
3. Uses `QSignalSpy` on `beeperOn` to assert it fires exactly once.
4. Uses `QSignalSpy` on `fullLockoutTimerEnded` combined with `QTest::qWait(3000)` to assert the signal fires with arguments `(false, false)`.
5. Verifies intermediate `lblLockOutTime` label text during the countdown.
6. In a separate sub-test, calls `stopTimer()` mid-count and asserts `fullLockoutTimerEnded` does not fire.

---

**A22-4** · HIGH · MessageDialog Has Zero Test Coverage

**File:** `ui/messagedialog.cpp` (entire file), `ui/messagedialog.h` (entire file)

**Description:** `MessageDialog` is used in at least two security-relevant flows: showing `WaitForAuthorised` while the system connects to the server to validate a driver (cpp:62–75), and showing `NotAuthorised` after a failed authorisation attempt (cpp:77–88). The 10-second `WaitForAuthorised` → `NotAuthorised` auto-transition and the 5-second `NotAuthorised` auto-reject are entirely untested. No test verifies: that any message type sets the correct label text; that timers fire within expected windows; that `hideEvent` stops the timer and resets `m_messageType` to `NoMessage`; that `openWithMessage` invokes `open()`; or that `messageType()` returns the correct enum after `setMessageType()`. `MessageDialog` has no `UNIT_TEST` friend declaration, complicating white-box testing.

**Fix:** Create a `test_messageDialog()` test suite covering:
- Each `MessageType` variant: assert `messageType()` returns the expected value and the message label text matches the expected string.
- Timer auto-transitions: set `WaitForAuthorised`, use `QTest::qWait(11000)` (or a mocked timer interval) and assert `messageType() == NotAuthorised`.
- Auto-reject: set `NotAuthorised`, wait past `NOT_AUTH_TIME`, assert the dialog is no longer visible.
- `hideEvent`: call `hide()`, assert `messageType() == NoMessage`.
- Add `friend class TestDialog;` under `#ifdef UNIT_TEST` in `messagedialog.h` to allow inspection of private members.

---

**A22-5** · HIGH · onScreenKeyboard Has Zero Test Coverage

**File:** `ui/onScreenKeyboard.cpp` (entire file), `ui/onScreenKeyboard.h` (entire file)

**Description:** The on-screen keyboard is the primary text-input mechanism for PIN and driver-ID entry in the application. It has zero test coverage across all test files. Untested behaviours include: character key output; Shift toggle producing uppercase; Caps Lock toggle and its interaction with Shift (Caps+Shift = lowercase); number-row dual-character mode (e.g., `!` vs `1`); the `&&` special-character encoding at cpp:72 and cpp:80; the backslash edge case at cpp:75-77 that incorrectly returns `ui->Buttonr->text()` instead of a literal backslash; Backspace emitting `updateText("", Backspace)`; Delete emitting `updateText("", Delete)`; Enter resetting state and closing; Hide Keyboard resetting state and closing; `closeEvent` emitting `onScreenKeyboardClose`; and `setInitialText`.

**Fix:** Add a `test_onScreenKeyboard()` test suite with `QSignalSpy` on the `updateText` and `onScreenKeyboardClose` signals, covering:
1. Standard key press: click a letter button, assert `updateText("a", None)` is emitted.
2. Shift toggle: click Shift then a letter, assert uppercase output.
3. Caps Lock: toggle Caps on, assert uppercase; toggle Caps+Shift together, assert lowercase.
4. Numeric dual-char: click a number button without Shift, assert digit; with Shift, assert symbol (e.g., `!` for key `0`).
5. Backspace: click the back button, assert `updateText("", Backspace)` is emitted.
6. Delete: click the delete button, assert `updateText("", Delete)` is emitted.
7. Enter: spy on close, click Enter, assert `onScreenKeyboardClose` is emitted and `outputText` is reset.
8. `setInitialText`: call with a known string, verify `outputText` is set (requires `UNIT_TEST` friend or an accessor).
9. Maximum input length: verify behaviour when called with an oversized string (see A22-6).

---

**A22-6** · MEDIUM · No Maximum Input Length Enforcement or Test in onScreenKeyboard

**File:** `ui/onScreenKeyboard.cpp:56–59`, `ui/onScreenKeyboard.h:48`

**Description:** `setInitialText(QString str)` assigns `outputText = str` without any length limit. The class also has no guard in `keyboardHandler()` preventing emission when the accumulated text exceeds a sensible bound. No test exercises large-input behaviour. This could cause UI rendering anomalies or interact poorly with fixed-length backend fields (e.g., PIN codes or driver IDs that have maximum lengths defined elsewhere in the system).

**Fix:** Define a maximum length constant (e.g., `MAX_INPUT_LENGTH`) appropriate to the field type (e.g., 20 characters for a driver name, 8 for a PIN). Enforce it in `setInitialText()` by truncating the input and in `keyboardHandler()` by suppressing `updateText` emission when the current length is at the maximum. Add a test that calls `setInitialText()` with a string exceeding the limit, asserts the stored value is truncated, and confirms that additional key presses at the limit do not emit `updateText`.

---

**A22-7** · MEDIUM · No Test for Lock Screen Visibility Across All Lock Codes

**File:** `ui/lockeddialog.cpp:36–58`, `test/test_dialog.cpp`

**Description:** `test_idleLockout` only exercises the `MaintIdle` lock code (test_dialog.cpp:398). `test_unlockMode1` only exercises `MaintRedImpact` (test_dialog.cpp:474, 492). The codes `MaintCriticalQuestion` and `MaintSurveyTimeout` are never passed to `lockScreen()` in any test, meaning no test confirms that calling `lockScreen()` with these codes shows the lock screen, sets the correct `maintCode`, and displays the correct reason string.

**Fix:** Extend `test_unlockMode1` or add a new `test_lockScreenAllCodes` that calls `m_dialog->lockScreen(code, false)` for each `MaintLockedCode` value, asserts `m_dialog->m_lockedDialog->isVisible()` is true, and asserts `m_dialog->m_lockedDialog->ui->labelReason->text()` matches the expected string for that code.

---

**A22-8** · LOW · onScreenKeyboard Backslash Key Logic Error Is Untested

**File:** `ui/onScreenKeyboard.cpp:75–77`

**Description:** The branch `else if (inputText == "\\") { outputText = ui->Buttonr->text(); }` produces the current text label of the `r`/`R` button rather than a literal backslash character. This is almost certainly a logic error — a button labelled `\\` should emit `"\"`, not whatever `Buttonr` currently displays (which varies with Caps/Shift state). This defect goes undetected because no test routes a backslash button click through `keyboardHandler`.

**Fix:** Add a test that directly invokes the keyboard handler for the backslash button (or sets `sender()` equivalent via the button's `clicked()` signal) and asserts the emitted `updateText` signal carries the string `"\\"` (a single backslash character). Additionally, correct the production code: `outputText = "\\";` is the correct assignment, replacing the `ui->Buttonr->text()` reference.

---

## Summary Table

| Finding | Severity | Category | File:Line | Area |
|---|---|---|---|---|
| A22-1 | CRITICAL | Missing Security Test — Lock Bypass | `ui/lockeddialog.h:36` | `mouseReleaseEvent` unconditional `accept()`, zero tests |
| A22-2 | HIGH | Insufficient Coverage — Lock Reason Labels | `ui/lockeddialog.cpp:36–58` | `setLockedReason()` — 4 of 5 branches untested |
| A22-3 | HIGH | Missing Safety Test — Full Lock Countdown | `ui/lockeddialog.cpp:77–95` | `fullLockStart`, `updateFullLock`, `fullLockoutTimerEnded` signal |
| A22-4 | HIGH | Zero Coverage — MessageDialog | `ui/messagedialog.cpp` (entire) | All methods, all `MessageType` paths, timer transitions |
| A22-5 | HIGH | Zero Coverage — onScreenKeyboard | `ui/onScreenKeyboard.cpp` (entire) | All key handlers, signals, case/shift logic |
| A22-6 | MEDIUM | No Input Length Enforcement or Test | `ui/onScreenKeyboard.cpp:56–59` | `setInitialText`, `keyboardHandler` — no max-length guard |
| A22-7 | MEDIUM | Incomplete Lock Code Coverage | `test/test_dialog.cpp:474,492` | `MaintCriticalQuestion`, `MaintSurveyTimeout` never exercised |
| A22-8 | LOW | Logic Error Untested — Backslash Key | `ui/onScreenKeyboard.cpp:75–77` | Backslash branch emits `Buttonr->text()` not `"\\"` |

---

## Coverage Estimate by Class

| Class | Public Methods | Methods With Any Coverage | Estimated Coverage |
|---|---|---|---|
| `LockedDialog` | 6 public + 2 private | 1 partially (`startTimer` side-effect only) | ~5% |
| `MessageDialog` | 4 public + 1 protected | 0 | 0% |
| `onScreenKeyboard` | 4 public + 7 private slots + 1 protected | 0 | 0% |

**Overall assessment:** The three classes collectively have 0–5% meaningful test coverage. The most critical gap is the complete absence of any test validating that the unconditional `mouseReleaseEvent -> accept()` pathway in `LockedDialog` does not permit unauthenticated bypass of the lock screen — a vulnerability already identified by a prior security audit. The `fullLockoutTimerEnded` signal that triggers physical relay shutdown is likewise untested. `MessageDialog` and `onScreenKeyboard` are entirely uncovered. Immediate action is warranted on findings A22-1 through A22-5.
