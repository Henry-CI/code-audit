# Pass 4 Agent A08 — Code Quality

**Audit run:** 2026-02-28-01
**Branch:** master
**Files reviewed:**
- `comm/canmonitor.h`
- `comm/canmonitor.cpp`
- `comm/canstatehandler.h`
- `comm/canstatehandler.cpp`

---

## 1. Reading Evidence

### 1.1 `comm/canmonitor.h`

**Class:** `CanMonitor` (inherits `QObject`)

| Function / Method | Line |
|---|---|
| `CanMonitor(EM070::CanBus *canBus)` (constructor) | 20 |
| `readCanConfig()` | 22 |
| `readOldCanConfig()` | 23 |
| `saveCanConfig()` | 24 |
| `calculateCanCrc()` | 25 |
| `canCrc32() const` (inline) | 28 |
| `setEnabled(bool enable)` | 30 |
| `clearCanConfig()` | 32 |
| `canBusConfig() const` | 33 |
| `setCanBusConfig(const QByteArray &config)` | 34 |
| `canPgnConfig() const` | 35 |
| `setCanPgnConfig(const QByteArray &config)` | 36 |
| `canSpnConfig() const` | 37 |
| `setCanSpnConfig(const QByteArray &config)` | 38 |
| `canAttConfig() const` | 39 |
| `setCanAttConfig(const QByteArray &config)` | 40 |
| `canLinConfig() const` | 41 |
| `setCanLinConfig(const QByteArray &config)` | 42 |
| `canBydConfig() const` | 43 |
| `setCanBydConfig(const QByteArray &config)` | 44 |
| `canLin2Config() const` | 45 |
| `setCanLin2Config(const QByteArray &config)` | 46 |
| `isXferEnabled() const` (inline) | 48 |
| `attributeName(quint8 index) const` (inline) | 49 |
| `attributeType(quint8 index) const` (inline) | 50 |
| `setVdiAccess(bool access, bool inhibit)` | 52 |
| `enableVdi(bool enable)` | 53 |
| **signals:** `resetCanStates(bool resetLast)` | 60 |
| **signals:** `stateUpdated(quint8 index, quint32 state)` | 61 |
| `isValidPgnConfig(const PgnConfig &config) const` (inline private) | 108 |
| `isValidSpnConfig(const SpnConfig &config) const` (inline private) | 109 |
| `isValidAttribute(const AttConfig &config) const` (inline private) | 110 |
| `childSpnIndexes(quint8 pgnIndex) const` | 111 |
| `findPgnIndex(quint32 rspId, quint32 reqId = 0) const` | 112 |
| `newPgnIndex() const` | 113 |
| `attributePollingRate(quint32 namePattern) const` | 114 |
| `createRequest(quint8 spnIndex, quint32 pollingRate)` | 115 |
| `updateBusConfig()` | 117 |
| `updateRequests()` | 118 |
| `readCanFrame(quint32 id, const QByteArray &ba)` | 120 |
| `updateState(quint8 spnIndex, quint64 data)` | 121 |
| `updateSpnState(quint8 spnIndex, quint64 data)` | 122 |
| `initVdi()` | 124 |
| `configureVdiAccessRequest()` | 125 |
| `perfTimer()` | 147 |

**Private structs defined in header:**

| Struct | Lines |
|---|---|
| `BusConfig` | 64–69 |
| `PgnConfig` | 71–79 |
| `SpnConfig` | 81–92 |
| `AttConfig` | 94–106 |

**Private data members:**

| Member | Type |
|---|---|
| `m_canBus` | `EM070::CanBus *` |
| `m_timer` | `QTimer *` |
| `m_file` | `QFile` |
| `m_canCrc32` | `quint32` |
| `m_enabled` | `bool` |
| `m_busConfig` | `BusConfig` |
| `m_pgnConfigs[CAN_MAX_PGN_IDX]` | `PgnConfig[]` |
| `m_spnConfigs[CAN_MAX_SPN_IDX]` | `SpnConfig[]` |
| `m_attConfigs[CAN_MAX_ATT_IDX]` | `AttConfig[]` |
| `m_attrToSpn` | `QMap<quint8, quint8>` |
| `m_spnState[CAN_MAX_SPN_IDX]` | `quint32[]` |
| `m_perfCounter` | `quint32` |
| `m_perfTimer` | `QTimer *` |
| `m_vdiAccess` | `bool` |
| `m_vdiInhibit` | `bool` |

---

### 1.2 `comm/canmonitor.cpp`

**File-scope structs (migration helpers):**

| Struct | Lines | Purpose |
|---|---|---|
| `SpnConfig0` | 53–61 | Original `cancfg.dat` SPN layout (quint16 spn) |
| `SpnConfig1` | 64–72 | Version 1 `cancfgnew.dat` SPN layout (quint32 spn) |

**File-scope `#define` macros:**

| Macro | Line | Value |
|---|---|---|
| `PERF_MON` | 13 | `0` |
| `CAN_CONF_FILE_OLD` | 15 | `"cancfg.dat"` |
| `CAN_CONF_FILE` | 16 | `"cancfgnew.dat"` |
| `RULE_SEAT_U/L` | 18–19 | `LE_INT` patterns |
| `RULE_TRAC_U/L` | 20–21 | `LE_INT` patterns |
| `RULE_HYDR_U/L` | 22–23 | `LE_INT` patterns |
| `RULE_HYDL_U/L` | 24–25 | `LE_INT` patterns |
| `RULE_HRS_U/L` | 26–27 | `LE_INT` patterns |
| `RULE_BACD_U/L` | 28–29 | `LE_INT` patterns |
| `RULE_BLAN_U/L` | 30–31 | `LE_INT` patterns |
| `RULE_SEAT_RATE` | 33 | `(2 * 1000)` |
| `RULE_TRAC_RATE` | 34 | `(2 * 1000)` |
| `RULE_HYDR_RATE` | 35 | `(2 * 1000)` |
| `RULE_HYDL_RATE` | 36 | `(2 * 1000)` |
| `RULE_BLAN_RATE` | 37 | `(2 * 1000)` |
| `RULE_HRS_RATE` | 38 | `(1*60*1000)` |
| `RULE_BACD_RATE` | 39 | `(1*60*1000)` |
| `LIN_CANID_OFFSET` | 41 | `0x10` |
| `LIN_ADDR_OFFSET` | 42 | `0x4000` |
| `BYD_CANID_XOR` | 44 | `0x380` |
| `BYD_ADDR_OFFSET` | 45 | `0x0B000000` |
| `UPDATE_DEFER` | 47 | `3000` |

**Functions defined in canmonitor.cpp:**

| Function | Line |
|---|---|
| `CanMonitor::CanMonitor(CanBus *canbus)` | 74 |
| `CanMonitor::perfTimer()` | 101 |
| `CanMonitor::readCanConfig()` | 107 |
| `CanMonitor::readOldCanConfig()` | 209 |
| `CanMonitor::saveCanConfig()` | 265 |
| `CanMonitor::setEnabled(bool enable)` | 295 |
| `CanMonitor::calculateCanCrc()` | 310 |
| `CanMonitor::findPgnIndex(quint32 rspId, quint32 reqId) const` | 418 |
| `CanMonitor::newPgnIndex() const` | 437 |
| `CanMonitor::childSpnIndexes(quint8 pgnIndex) const` | 447 |
| `CanMonitor::clearCanConfig()` | 469 |
| `CanMonitor::canBusConfig() const` | 488 |
| `CanMonitor::setCanBusConfig(const QByteArray &config)` | 498 |
| `CanMonitor::canPgnConfig() const` | 531 |
| `CanMonitor::setCanPgnConfig(const QByteArray &config)` | 566 |
| `CanMonitor::canSpnConfig() const` | 615 |
| `CanMonitor::setCanSpnConfig(const QByteArray &config)` | 642 |
| `CanMonitor::canAttConfig() const` | 705 |
| `CanMonitor::setCanAttConfig(const QByteArray &config)` | 752 |
| `CanMonitor::canLinConfig() const` | 828 |
| `CanMonitor::setCanLinConfig(const QByteArray &config)` | 857 |
| `CanMonitor::canBydConfig() const` | 947 |
| `CanMonitor::setCanBydConfig(const QByteArray &config)` | 976 |
| `CanMonitor::canLin2Config() const` | 1064 |
| `CanMonitor::setCanLin2Config(const QByteArray &config)` | 1097 |
| `CanMonitor::attributePollingRate(quint32 namePattern) const` | 1193 |
| `CanMonitor::createRequest(quint8 spnIndex, quint32 pollingRate)` | 1231 |
| `CanMonitor::updateBusConfig()` | 1301 |
| `CanMonitor::updateRequests()` | 1313 |
| `CanMonitor::readCanFrame(quint32 id, const QByteArray &ba)` | 1369 |
| `CanMonitor::updateState(quint8 spnIndex, quint64 data)` | 1474 |
| `CanMonitor::updateSpnState(quint8 spnIndex, quint64 data)` | 1526 |
| `CanMonitor::initVdi()` | 1600 |
| `CanMonitor::setVdiAccess(bool access, bool inhibit)` | 1616 |
| `CanMonitor::configureVdiAccessRequest()` | 1627 |
| `CanMonitor::enableVdi(bool enable)` | 1648 |

---

### 1.3 `comm/canstatehandler.h`

**Class:** `CanStateHandler` (inherits `QObject`)

**Enum defined:**

| Enum | Values | Line |
|---|---|---|
| `DigitalFormat` | `SessionFormat`, `UsageFormat`, `OnDemandFormat` | 14 |

**Methods:**

| Function / Method | Line |
|---|---|
| `CanStateHandler(CanMonitor *canMonitor)` (constructor) | 16 |
| `updateIdleTimer()` | 17 |
| `canStates(DigitalFormat format, bool autoReset)` | 18 |
| `resetStates(bool resetLast)` | 19 |
| **signals:** `idleTimeout()` | 22 |
| `updateState(quint8 index, quint32 state)` (private) | 45 |

**Private struct defined in header:**

| Struct | Lines |
|---|---|
| `CanState` | 25–43 |

**Private data members:**

| Member | Type |
|---|---|
| `m_canStates[CAN_MAX_ATT_IDX]` | `CanState[]` |
| `m_canMonitor` | `CanMonitor *` |
| `m_timer` | `QTimer *` |

---

### 1.4 `comm/canstatehandler.cpp`

**Functions defined:**

| Function | Line |
|---|---|
| `CanStateHandler::CanStateHandler(CanMonitor *monitor)` | 14 |
| `CanStateHandler::updateState(quint8 index, quint32 state)` | 24 |
| `CanStateHandler::resetStates(bool resetLast)` | 73 |
| `CanStateHandler::updateIdleTimer()` | 91 |
| `CanStateHandler::canStates(DigitalFormat format, bool autoReset)` | 117 |

---

## 2. Findings

---

**A08-1** · MEDIUM · Large block of commented-out debug code inside `calculateCanCrc()`

**Description:** Lines 312–336 of `canmonitor.cpp` contain a commented-out struct definition and seven commented-out `memcpy`/`SerialLogger` lines inside the `calculateCanCrc()` function body. These were apparently left over from a debugging session that explored an alternative CRC computation strategy. The volume of dead comment noise obscures the active code path and makes the function difficult to read at a glance.

```cpp
// canmonitor.cpp lines 312–336
        /*struct {
            BusConfig busConfig;
            ...
        } config;*/

        //memset(&config, 0, sizeof(config));
        //memcpy(&config.busConfig, ...);
        ...
        //m_canCrc32 = GlobalConfigs::crc32(&config, sizeof(config));
```

**Fix:** Delete all commented-out code between lines 312 and 336. If the alternative code path is ever needed, version control history preserves it.

---

**A08-2** · LOW · Commented-out code in `setEnabled()` and `updateState()`

**Description:**
- `canmonitor.cpp` line 304: `//emit resetCanStates();` — a signal emission is silenced inside `setEnabled()`.
- `canmonitor.cpp` line 1476: `//qDebug() << "updateState(..."` — diagnostic log left commented out.
- `canmonitor.cpp` line 1528: `//qDebug() << "updateSpnState(..."` — same pattern.

These are individually minor but create confusion about whether the emit on line 304 was intentionally removed or accidentally silenced.

**Fix:** Remove the commented-out `qDebug` lines. For the silenced signal emission, add a code comment explaining the deliberate omission or restore it if it was accidentally removed.

---

**A08-3** · LOW · Commented-out code in `canstatehandler.cpp` (`memset` call, line 80)

**Description:** `canstatehandler.cpp` line 80 contains `//memset(m_canStates, 0, sizeof(m_canStates));` immediately after the selective-reset loop. The active code was refactored to be selective but the original bulk `memset` was never deleted.

```cpp
// canstatehandler.cpp line 80
    //memset(m_canStates, 0, sizeof(m_canStates));
```

**Fix:** Delete the commented-out line.

---

**A08-4** · MEDIUM · Disabled feature macro `DEPENDS_ON_TRIGGER` left as a comment block

**Description:** `canstatehandler.cpp` lines 8–12 contain a `TODO` comment followed by `//#define DEPENDS_ON_TRIGGER`. The macro is referenced at three more points in the file (lines 30–33, 80–86, 129–135) via `#ifdef`/`#ifndef` guards. The feature is unconditionally disabled at compile time — the disabled path is never compiled — yet the entire conditional framework is retained. This inflates cognitive complexity with code that is always dead in production builds.

**Fix:** Either commit to removing `DEPENDS_ON_TRIGGER` and its guarded blocks, or restore the macro and the TODO to an issue tracker and remove the comment block. Do not leave permanently-disabled conditional compilation blocks in production source.

---

**A08-5** · MEDIUM · Dead `#if 0` block in `updateSpnState()` — unreachable alternative algorithm

**Description:** `canmonitor.cpp` lines 1540–1545 wrap an alternative bit-extraction algorithm in `#if 0`:

```cpp
#if 0
    // LSB first for offset
    spnData = data >> spnConfig.offset;
    spnData &= spnMask;
#else
    // MSB first for offset
    ...
#endif
```

The `#if 0` block will never be compiled. Its presence suggests an experimental change was never cleaned up.

**Fix:** Delete the `#if 0` block and the surrounding `#if 0 / #else / #endif` scaffolding, leaving only the active `#else` branch. The comment "MSB first for offset" should be retained inline.

---

**A08-6** · LOW · Dead `#if 1` block in `clearCanConfig()` — always-active conditional

**Description:** `canmonitor.cpp` lines 478–482 contain:

```cpp
#if 1   // default setting to do
    m_busConfig.protocol = LindeExtended;
    m_busConfig.baudRate = 250000;
    m_busConfig.enabled  = true;
#endif
```

An `#if 1` block is always compiled. The comment "default setting to do" implies this was meant to be temporary. The conditional wrapper is misleading because it implies the block could be disabled.

**Fix:** Remove the `#if 1` / `#endif` wrapper and leave the three assignment statements as unconditional code, or promote the literals to named constants.

---

**A08-7** · MEDIUM · Magic number `64` for idle input source embedded in `updateIdleTimer()`

**Description:** `canstatehandler.cpp` line 99 compares `gCfg->idleInputSource()` against the literal `64`. The comment on lines 93–96 explains the meaning: "64 means input is CAN SEAT state." This is a protocol/specification constant that should be named.

```cpp
if (!gCfg->idleTimeout() || !gCfg->currentDriverId() ||
        gCfg->idleInputSource() != 64) {
```

**Fix:** Define `constexpr int CAN_IDLE_INPUT_SOURCE_SEAT = 64;` (or equivalent) in `cigconfigs.h` and replace the literal.

---

**A08-8** · MEDIUM · Magic numbers for VDI CAN IDs and byte payloads in `updateRequests()` and `configureVdiAccessRequest()`

**Description:** Several raw CAN identifiers and payload bytes appear as bare integer literals with no named constant:

- `canmonitor.cpp` line 1361: `m_canBus->addRequest(0x000, ba, 1000)` — VDI enable node message to ID `0x000`.
- `canmonitor.cpp` lines 1638–1643: payload bytes `0x05`, `0x01`, `0x00` representing access-mode states sent to ID `0x215` (line 1635, also a magic number).
- `canmonitor.cpp` line 1242: `6 << 26 | 234 << 16 | 255 << 8` — J1939 request PGN components with raw field values.

These are protocol-specific constants that are impossible to understand without the specification. Their repetition across encode and decode paths also risks inconsistency if the values ever change.

**Fix:** Define named constants (e.g., `VDI_ENABLE_NODE_ID`, `VDI_ACCESS_REQUEST_ID`, `VDI_ACCESS_INHIBIT_BYTE`, `J1939_REQUEST_PRIORITY`, `J1939_REQUEST_PF`, `J1939_REQUEST_PS`) and replace all occurrences.

---

**A08-9** · MEDIUM · Unreachable `return 0` statement at end of `attributePollingRate()`

**Description:** `canmonitor.cpp` lines 1224–1228:

```cpp
    default:
        return 0;
    }

    return 0;   // <-- unreachable
```

The `switch` covers every path including `default: return 0`. The statement after the closing brace of the switch is never reached. Compilers with `-Wunreachable-code` will warn on this.

**Fix:** Delete the trailing `return 0;` on line 1228.

---

**A08-10** · LOW · Commented-out `RULE_HRS_RATE` and `RULE_BACD_RATE` commented-out alternative values

**Description:** `canmonitor.cpp` lines 38–39:

```cpp
#define RULE_HRS_RATE       (1*60*1000)//(10 * 60 * 1000)
#define RULE_BACD_RATE      (1*60*1000)//(10 * 60 * 1000)
```

The original 10-minute values are retained as inline comments after the active 1-minute values. This implies a recent tuning change where the old value was never cleaned up. The inline comment is adjacent to the macro value in a way that risks misreading the effective value.

**Fix:** Delete the `// (10 * 60 * 1000)` suffixes. If the reasoning for the change is important, record it in a commit message or a separate code comment on the next line.

---

**A08-11** · HIGH · Private wire-protocol structs exposed in public header, creating tight coupling

**Description:** `canmonitor.h` defines four private structs — `BusConfig`, `PgnConfig`, `SpnConfig`, and `AttConfig` — in the `private:` section of the class header. These structs encode the exact on-disk binary layout of the CAN configuration file (field widths, alignment attributes, protocol-specific overlap via unions). Because these struct definitions live in the header, any translation unit that `#include`s `canmonitor.h` is compiled with knowledge of the full binary format.

`canstatehandler.h` similarly declares its private `CanState` struct (with its `time`/`count` union) in the header rather than in an implementation-local file.

This is a leaky abstraction: the internal serialisation layout becomes an implicit part of the public interface. Any change to a struct field (e.g., widening `SpnConfig::spn` from `quint32` to `quint64` in version 2) forces recompilation of every dependent TU even if the public API is unchanged, and risks ABI surprises if the struct is ever passed across a library boundary.

**Fix:** Move `BusConfig`, `PgnConfig`, `SpnConfig`, `AttConfig` (and `CanState`) to an anonymous namespace or a forward-declared private implementation struct (`Pimpl`) inside the `.cpp` files. The public header should expose only opaque handles or typed enumerations. At minimum, document with a prominent comment that these structs are serialised to disk and must not be changed without a format-version bump.

---

**A08-12** · LOW · Naming inconsistency: constructor parameter `canbus` vs. member `m_canBus`

**Description:** In `canmonitor.cpp` line 74, the constructor parameter is spelled `canbus` (lower camel, no separator), while the stored member is `m_canBus` (camel with capital B). The Qt-style convention used throughout the rest of the codebase spells multi-word identifiers with an upper-case word boundary. The constructor parameter should follow the same convention for readability.

**Fix:** Rename the constructor parameter from `canbus` to `canBus` to match the member naming convention.

---

**A08-13** · LOW · Inconsistent brace style for single-statement `if` bodies in `enableVdi()`

**Description:** `canmonitor.cpp` lines 1650–1656:

```cpp
void CanMonitor::enableVdi(bool enable)
{
    if (enable)
    {
        initVdi();
    } else {
        clearCanConfig();
    }
}
```

The `if` body uses Allman style (opening brace on its own line) while the `else` body uses K&R style (opening brace on same line). The rest of the file consistently uses K&R for class methods. This is purely a style inconsistency.

**Fix:** Normalise to K&R style: `if (enable) {` on the same line as the condition.

---

**A08-14** · LOW · Typo in comment: "idenitifer" (twice) and "consistant"

**Description:**
- `canmonitor.h` line 84: `// SPN idenitifer` (should be "identifier").
- `canmonitor.cpp` line 56: `// SPN idenitifer` (same typo in `SpnConfig0`).
- `canmonitor.cpp` line 1020: `// but address 0 is an exception which is consistant` (should be "consistent").

**Fix:** Correct the three spelling errors.

---

**A08-15** · MEDIUM · Signed/unsigned comparison and implicit narrowing in `readCanFrame()` loop index

**Description:** `canmonitor.cpp` lines 1375–1385:

```cpp
int pgnIndex;
for (pgnIndex = 0; pgnIndex < CAN_MAX_PGN_IDX; ++pgnIndex) {
```

`pgnIndex` is declared as `int` (signed), but `CAN_MAX_PGN_IDX` is a preprocessor integer constant (effectively `int`-typed in this context). Immediately after the loop, the same `pgnIndex` (now possibly equal to `CAN_MAX_PGN_IDX`) is compared with `CAN_MAX_PGN_IDX` and then used to index `m_pgnConfigs[]` (line 1377), which accepts `int`. However, in `childSpnIndexes()` and related helpers the index type is `quint8`, and `findPgnIndex()` returns `quint8`. The inconsistency — some helpers return/accept `quint8` and some use `int` — means index values are silently narrowed at call sites. With `CAN_MAX_PGN_IDX = 10` and `CAN_MAX_SPN_IDX = 20` the narrowing is safe today, but this is fragile.

**Fix:** Standardise on a single index type for all PGN/SPN index variables. Using `int` for loop variables and explicit `static_cast<quint8>` at boundaries is acceptable; the important fix is consistency. Consider a `using PgnIndex = quint8;` type alias to make intent explicit.

---

**A08-16** · LOW · `qDebug()` left active in hot receive path (`updateState()`, line 1522)

**Description:** `canmonitor.cpp` line 1522:

```cpp
qDebug() << "CAN Name/State:" << attr.name << attState;
```

This `qDebug()` call is in the `updateState()` method that is invoked on every received CAN frame that triggers an attribute change. In a production build without `QT_NO_DEBUG_OUTPUT`, this will emit to stderr (or a debug sink) on every state change, potentially flooding logs and degrading performance. The companion lines at 1476 and 1528 were at least commented out; this one was not.

**Fix:** Either wrap the call in `#ifdef QT_DEBUG` or remove it. If it is intentionally left for field diagnosis, route it through `SerialLogger` (already used elsewhere in this file) so it can be gated by a runtime flag.

---

## 3. Summary Table

| ID | Severity | Title |
|---|---|---|
| A08-1 | MEDIUM | Large commented-out struct and memcpy block in `calculateCanCrc()` |
| A08-2 | LOW | Commented-out signal emit and qDebug lines in `setEnabled()`/`updateState()` |
| A08-3 | LOW | Commented-out bulk `memset` in `resetStates()` |
| A08-4 | MEDIUM | Permanently-disabled `DEPENDS_ON_TRIGGER` conditional compilation |
| A08-5 | MEDIUM | Dead `#if 0` alternative algorithm in `updateSpnState()` |
| A08-6 | LOW | Misleading `#if 1` wrapper in `clearCanConfig()` |
| A08-7 | MEDIUM | Magic number `64` for CAN SEAT idle-input source |
| A08-8 | MEDIUM | Magic numbers for VDI CAN IDs and J1939 request frame components |
| A08-9 | MEDIUM | Unreachable `return 0` after switch in `attributePollingRate()` |
| A08-10 | LOW | Commented-out alternative rate values inline on `#define` lines |
| A08-11 | HIGH | Private wire-protocol structs exposed in public headers (leaky abstraction) |
| A08-12 | LOW | Naming inconsistency: constructor parameter `canbus` vs member `m_canBus` |
| A08-13 | LOW | Inconsistent brace style in `enableVdi()` |
| A08-14 | LOW | Typos in comments: "idenitifer" and "consistant" |
| A08-15 | MEDIUM | Signed/unsigned index-type inconsistency across PGN/SPN helpers |
| A08-16 | LOW | Active `qDebug()` in hot CAN-frame receive path (`updateState()`) |

**Totals:** 1 HIGH, 6 MEDIUM, 9 LOW
