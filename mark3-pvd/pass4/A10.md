# Pass 4 Agent A10 — Code Quality

**Audit run:** 2026-02-28-01
**Branch:** master
**Files reviewed:**
- `comm/modemchat.h`
- `comm/modemchat.cpp`
- `comm/ntpsync.h`
- `comm/ntpsync.cpp`

---

## Reading Evidence

### `comm/modemchat.h`

**Class:** `ModemChat` (inherits `QObject`)

**Enum defined:**
| Enum | Values |
|------|--------|
| `NetworkState` | `NetworkStopped(0)`, `NetworkHome(1)`, `NetworkSearching(2)`, `NetworkDenied(3)`, `NetworkUnknown(4)`, `NetworkRoaming(5)` |

**Struct defined (private):**
| Struct | Fields |
|--------|--------|
| `apnData` | `QString apn`, `QString apnUser`, `QString apnPassword` |

**Public methods / accessors:**
| Line | Name |
|------|------|
| 24 | `ModemChat(EM070::ModemPort *modemPort)` (constructor) |
| 25 | `void portStateChanged(bool open)` |
| 26 | `void setGnssEnabled(bool enable)` |
| 27 | `void rssiRefresh()` |
| 28 | `void qmiCheck()` |
| 29 | `void networkCheck()` |
| 30 | `void updateApn()` |
| 31 | `void detach(bool send = true)` |
| 32 | `void requestDetach()` |
| 34 | `const QByteArray &cgmi() const` |
| 35 | `const QByteArray &cgmm() const` |
| 36 | `const QByteArray &cgmr() const` |
| 37 | `const QByteArray &cgsn() const` |
| 38 | `const QByteArray &iccid() const` |
| 39 | `const QByteArray &rssi() const` |
| 40 | `const QByteArray &mobileOperator() const` |
| 41 | `const QByteArray &moni() const` |
| 42 | `NetworkState networkState() const` |
| 43 | `bool isEthernetReady() const` |

**Private methods:**
| Line | Name |
|------|------|
| 56 | `void sendChat(bool timeout = false)` |
| 57 | `void popChat()` |
| 58 | `void pushChat(const QByteArray &chat)` |
| 59 | `void noResponse()` |
| 60 | `void parseResponse(bool result, const QByteArrayList &content)` |
| 61 | `void selectAPN()` |
| 62 | `void updateEthernetState(bool connected)` |
| 63 | `void reconnectNetwork()` |
| 64 | `void onUqmiProcessComplete(int exitCode, QProcess::ExitStatus exitStatus)` |
| 65 | `void onProcessTimeout()` |
| 66 | `void resetReconnectFlag()` |
| 69 | `int args(const QByteArrayList &content, QGenericArgument val1, QGenericArgument val2, QGenericArgument val3, QGenericArgument val4)` |

**Constants (macros in modemchat.cpp):**
| Macro | Value | Meaning |
|-------|-------|---------|
| `RETRY_WAIT` | 500 | ms between retries |
| `RETRIES_PER_SEC` | 1000/500 = 2 | retries per second |
| `ACK_TIMEOUT` | 3000 | ms to wait for AT response |
| `RSSI_INTERVAL` | 10000 | ms between RSSI polls |
| `QMI_INTERVAL` | 2000 | ms between QMI polls |
| `NETWORK_INTERVAL` | 2000 | ms between network checks |
| `NETWORK_TIMEOUT` | 90 | ticks (= 180 s) before detach |
| `MONOGOTO_PREFIX_SIZE` | 5 | ICCID prefix length for Monogoto |
| `MAX_QMI_FAILURE_COUNT` | 7 | max successive QMI failures |
| `PROCESS_MAX_WAIT_TIMEOUT` | 10000 | ms to wait for uqmi process start |
| `MAX_CGDCONT` | 5 | max APN-set retries |

---

### `comm/ntpsync.h`

**Class:** `NtpSync` (inherits `QObject`)

**Public methods:**
| Line | Name |
|------|------|
| 14 | `NtpSync(ModemChat *parent)` (constructor) |
| 15 | `void connectServer()` |
| 16 | `void abortConnection()` |

**Signals:**
| Line | Name |
|------|------|
| 19 | `void synchronized(bool yes)` |

**Private methods:**
| Line | Name |
|------|------|
| 22 | `void writeSocket()` |
| 23 | `void readSocket()` |

**Constants (macros in ntpsync.cpp):**
| Macro | Value | Meaning |
|-------|-------|---------|
| `EPOCH_DIFF` | `0x83aa7e80UL` | Seconds between NTP epoch (1900) and Unix epoch (1970) |

---

## Findings

---

**A10-1** · HIGH · Large commented-out block in `portStateChanged` obscures active code path selection

**Description:** Lines 85-101 in `modemchat.cpp` contain a multi-line commented-out `if/else` block that was apparently the predecessor to the current runtime branch selected in `parseResponse` after `AT+CGMM` is received. The commented block mixes initialization commands that now appear elsewhere with subtly different ordering. Its continued presence creates confusion about intent: it is unclear whether the dead block is aspirational, superseded, or a rollback option. It also misrepresents the actual startup sequence to any reader.

```cpp
// comm/modemchat.cpp lines 85-101
// if (m_modemPort->isWwx()) {
//     m_chatCmds << "AT+CGDCONT?"
//                << "AT#MONI"
//                << "AT+CSQ";
// } else {
//     m_chatCmds << "AT+CSQ"
//             << "AT+CGCONTRDP="
//            << "AT+CGDCONT?"
//            << "AT#PDPAUTH?"
//            << "AT+COPS?"
//            << "AT+CGATT?"
//            << "AT+CGREG?"
//            << "AT#MONI"
//            << "AT+CSQ"
//            << "AT#ECM?"
//            << "AT#ECMC?";
//}
```

**Fix:** Remove the commented-out block entirely. If needed for reference, it is preserved in version control history.

---

**A10-2** · MEDIUM · Additional scattered commented-out code throughout `modemchat.cpp`

**Description:** Multiple other commented-out lines are spread throughout the file and create noise:

- Line 110-111: `// m_ethernetState = false;` / `// emit ethernetStateChanged(false);` — superseded by `updateEthernetState(false)` on line 112 but left in place.
- Lines 320, 342-344: `//QProcess::execute(...)` and `//m_qmiTimer->start(...)` / `//m_rssiTimer->start(...)` inside `updateApn()` and `detach()`.
- Lines 503-504: `// selectAPN();` / `// QProcess::execute(...)` inside `parseResponse` for `AT+CGDCONT?`.
- Lines 609-610: `// m_ethernetState = true;` / `// emit ethernetStateChanged(true);` in `AT#ECMC?` handler.
- Lines 615: `// m_ethernetState = false;` in same handler.
- Lines 674-685: Commented-out `pushChat` calls inside the `+CGEV:` handler.
- Line 224-225: Commented-out `m_chatCmds << "AT#MONI"` / `sendChat()` in `updateEthernetState`.

**Fix:** Purge all commented-out statements. Where genuinely uncertain code is being held in reserve, move it to a named helper or document the reason it is retained with a TODO/FIXME tag with a ticket reference.

---

**A10-3** · MEDIUM · AT-command strings and modem vendor mnemonics leak into the public interface

**Description:** The public methods `detach()`, `requestDetach()`, `updateApn()`, `rssiRefresh()`, and `qmiCheck()` are named after modem operations or internal AT-command concepts. The public accessors `cgmi()`, `cgmm()`, `cgmr()`, `cgsn()`, `iccid()`, and `moni()` directly expose AT-command names (CGMI, CGMM, CGMR, CGSN, ICCID, MONI) as the public API of the class. Callers are required to know what `cgmr` or `moni` mean, which are raw modem AT-command names. This is a leaky abstraction: the hardware-protocol layer bleeds through to any consumer of `ModemChat`.

**Fix:** Rename public accessors and methods to domain-meaningful names. Examples: `cgmi()` -> `manufacturerId()`, `cgmm()` -> `modelId()`, `cgmr()` -> `revisionId()`, `cgsn()` -> `imei()`, `moni()` -> `cellInfo()`. Rename `detach()` / `requestDetach()` to `disconnectNetwork()` / `requestNetworkDisconnect()`.

---

**A10-4** · MEDIUM · `args()` uses `QGenericArgument` / `Q_ARG` for a purely internal parsing helper — inappropriate API

**Description:** `ModemChat::args()` (header line 69, impl line 696) uses the Qt meta-object `QGenericArgument` mechanism (`Q_ARG`, `val.name()`, `val.data()`) to pass typed output parameters. This mechanism is designed for `QMetaObject::invokeMethod` dynamic dispatch and is explicitly noted in the Qt docs as not type-safe. The class's own header comment (`// to save the parsing time, only QByteArray/QString/int/bool are supported`) acknowledges the limitation. A plain overload set or a small `struct` would be safer and clearer.

**Fix:** Replace the `args()` helper with either (a) a set of typed overloads, (b) a `struct ParseResult` return type, or (c) a small template helper that avoids `QGenericArgument` entirely. At minimum, document the constraint more prominently and add a `static_assert` or runtime check that rejects unsupported types rather than silently misinterpreting them.

---

**A10-5** · MEDIUM · Shadow variable `isWwx` declared inside `AT#USBCFG?` branch obscures outer declaration

**Description:** In `parseResponse()`, `isWwx` is declared at line 371 for use throughout the function. Inside the `AT#USBCFG?` handler at line 440, a second `bool isWwx = m_modemPort->isWwx();` is declared, shadowing the outer variable. The inner re-declaration is redundant (same value) and on a compiler with `-Wshadow` this produces a warning.

```cpp
// Line 371 (outer):
bool isWwx = m_modemPort->isWwx();
// ...
// Line 440 (inner shadow, inside if-block for AT#USBCFG?):
bool isWwx = m_modemPort->isWwx();
```

**Fix:** Remove the inner `bool isWwx` declaration at line 440; the outer `isWwx` is already in scope and holds the same value.

---

**A10-6** · MEDIUM · Logic bug: `bool` validation in `args()` uses `||` instead of `&&` — always true

**Description:** In `modemchat.cpp` at line 749:

```cpp
if (val >= 0 || val <= 1)
    * (bool *) valDatas[i] = val;
else
    return i;
```

The condition `val >= 0 || val <= 1` is a tautology — it is always true for any integer (every integer is either >= 0 or <= 1). The intent is clearly to accept only values 0 or 1, which requires `val >= 0 && val <= 1`. The `else` branch that rejects out-of-range values is therefore dead/unreachable code.

**Fix:** Change `||` to `&&`:
```cpp
if (val >= 0 && val <= 1)
    * (bool *) valDatas[i] = val;
else
    return i;
```

---

**A10-7** · MEDIUM · `updateApn()` has inconsistent indentation — `else` branch body not indented

**Description:** The `else` branch of `updateApn()` at lines 321-333 is not indented relative to the enclosing `if/else`, making the code's structure misleading:

```cpp
void ModemChat::updateApn()
{
    if (m_modemPort->isWwx()) {
        pushChat("AT+CGDCONT?");
        //QProcess::execute(...);
    } else {
    pushChat("AT#ECMC?");   // <- should be indented
    pushChat("AT#ECM?");
    ...
    sendChat();
}
}
```

The closing brace alignment is also wrong: the function's closing `}` appears on a line by itself at column 0 after the `else` block's `}`, which compiles correctly but is highly misleading.

**Fix:** Re-indent the `else` block body consistently. Both branches should use 4-space (or one tab) indentation. Run the file through `clang-format` with the project's style settings.

---

**A10-8** · LOW · Magic number `0x0b` in `writeSocket()` with no named constant or comment

**Description:** In `ntpsync.cpp` line 65:

```cpp
ba[0] = 0x0b;
```

This byte encodes the NTP packet LI/VN/Mode field: LI=0 (no warning), VN=1 (version 1), Mode=3 (client). The value `0x0b` is opaque and non-obvious. Any reader maintaining the code must know NTP packet structure to understand it.

**Fix:** Replace with a named constant and comment:
```cpp
// NTP packet: LI=0 (no leap warning), VN=1, Mode=3 (client)
static const quint8 NTP_LI_VN_MODE = 0x0b;
ba[0] = NTP_LI_VN_MODE;
```
Also note that NTP version 1 is ancient; NTP version 4 (`0x1b`) is standard. Consider whether the server supports v1.

---

**A10-9** · LOW · Magic number `123` (NTP port) used inline without a named constant

**Description:** In `ntpsync.cpp` line 50 and referenced in the log message at line 62:

```cpp
m_udpSocket->connectToHost(gCfg->timeServerAddress(), 123);
```

Port 123 is the well-known NTP port, but it should be a named constant for readability and maintainability.

**Fix:** Define `static const quint16 NTP_PORT = 123;` and use it in both the `connectToHost` call and the log message.

---

**A10-10** · LOW · Magic number `48` (NTP packet size) used without a named constant

**Description:** In `ntpsync.cpp` lines 64 and 75:

```cpp
QByteArray ba(48, 0);  // line 64
if (ba.size() < 48)    // line 75
```

48 bytes is the fixed NTP packet size. Having it as a bare literal in two places risks a discrepancy if one is ever changed.

**Fix:** Define `static const int NTP_PACKET_SIZE = 48;` and use it consistently.

---

**A10-11** · LOW · Comment in `connectServer()` has incorrect polarity — `// -1 means time has in sync yet`

**Description:** In `ntpsync.cpp` line 31:

```cpp
// -1 means time has in sync yet
if (m_syncTimes < 0) {
```

The comment appears to be a garbled version of "time has already synced" or "time is in sync". The word "yet" makes the sentence ambiguous/incorrect. The sentinel value -1 meaning "already synced" is a non-obvious convention.

**Fix:** Correct the comment: `// m_syncTimes == -1 means synchronisation already completed`. Consider replacing the sentinel `-1` with a named constant `static const int SYNC_COMPLETE = -1;` or a separate `bool m_synced` flag for clarity.

---

**A10-12** · LOW · `abortConnection()` silently resets `m_syncTimes` to 0 only when positive — inconsistent reset

**Description:** In `ntpsync.cpp` lines 54-58:

```cpp
void NtpSync::abortConnection()
{
    if (m_syncTimes > 0)
        m_syncTimes = 0;
    m_timer->stop();
}
```

If `m_syncTimes` is already 0 (never started) or -1 (already synced), the reset is skipped or suppressed. An abort when `m_syncTimes == -1` leaves the "already synced" sentinel in place; the next call to `connectServer()` would immediately re-emit `synchronized(true)` without actually connecting. Whether this is the desired behaviour is not documented.

**Fix:** Document the intended post-conditions of `abortConnection()` explicitly. If a full reset is desired (i.e., allow re-synchronisation after abort), set `m_syncTimes = 0` unconditionally. If re-sync after abort should be inhibited once already synced, add an explanatory comment.

---

**A10-13** · LOW · `MAX_QMI_FAILURE_COUNT` defined but never used

**Description:** In `modemchat.cpp` line 18:

```cpp
#define MAX_QMI_FAILURE_COUNT (7) //Approximately n x 2s timeout = n*2s successive failure
```

A search of the file shows this constant is never referenced anywhere in `modemchat.cpp` or `modemchat.h`. It appears to be dead configuration left from a previous implementation of QMI failure counting that was removed.

**Fix:** Remove the unused macro, or implement the failure counter logic it was intended to support.

---

**A10-14** · LOW · `m_networkState` member is never initialised in the constructor

**Description:** In `modemchat.h` the member `NetworkState m_networkState` is declared at line 94. The constructor initialiser list in `modemchat.cpp` (lines 24-40) does not initialise `m_networkState`. Because `NetworkState` is a plain `enum` (not `enum class`), it defaults to an indeterminate integer value if the object is allocated on the heap or in uninitialized storage. Any call to `networkState()` before `parseResponse` processes a `+CGREG?` response returns an undefined value.

**Fix:** Add `m_networkState(NetworkUnknown)` to the constructor initialiser list.

---

**A10-15** · LOW · `BE_INT` macro in `ntpsync.cpp` — first argument is a signed `char` used in a left-shift

**Description:** `ntpsync.cpp` line 78-79 uses `BE_INT(ba[32], ...)`. `ba` is a `QByteArray`; its `operator[]` returns `char`, which is signed on most platforms. The macro definition (`utils/bytearray.h` line 7) performs `(c1) << 24` — left-shifting a potentially negative signed `char` by 24 is undefined behaviour in C++ if `c1` is negative (i.e., byte value > 127). Only `c2`, `c3`, `c4` are cast to `uchar` inside the macro; `c1` is not.

```cpp
#define BE_INT(c1, c2, c3, c4)  ((c1) << 24 | (uchar)(c2) << 16 | (uchar)(c3) << 8 | (uchar)(c4))
```

**Fix:** Cast `c1` to `uchar` (or `quint8`) inside the macro before the shift:
```cpp
#define BE_INT(c1, c2, c3, c4)  ((uchar)(c1) << 24 | (uchar)(c2) << 16 | (uchar)(c3) << 8 | (uchar)(c4))
```

---

**A10-16** · LOW · `rssiRefresh()` enqueues commands but only calls `sendChat()` when queue size is exactly 2

**Description:** In `modemchat.cpp` lines 132-137:

```cpp
void ModemChat::rssiRefresh()
{
    m_chatCmds << "AT+CSQ";
    m_chatCmds << "AT#MONI";

    if (m_chatCmds.size() == 2)
        sendChat();
}
```

`sendChat()` is only called if the queue contained exactly zero commands before this function ran (i.e., size becomes exactly 2). If the queue already had any pending commands, the new commands are appended silently and `sendChat()` is not called from here. While `sendChat()` is called from `parseResponse()` after each command completes, the check `== 2` is fragile: if `rssiRefresh()` were ever modified to enqueue a third command, the `sendChat()` trigger would silently stop working.

**Fix:** Replace `m_chatCmds.size() == 2` with `m_chatCmds.size() == 2` being replaced by a named pre-count check:
```cpp
bool wasEmpty = m_chatCmds.isEmpty();
m_chatCmds << "AT+CSQ" << "AT#MONI";
if (wasEmpty)
    sendChat();
```

---

**A10-17** · INFO · Struct `apnData` uses lowercase name, inconsistent with Qt/project PascalCase convention

**Description:** In `modemchat.h` line 50, the private struct is named `apnData` (camelCase starting with lowercase), while all other types in the codebase use PascalCase (e.g., `ModemChat`, `NetworkState`, `NtpSync`). Qt coding style recommends PascalCase for all type names.

**Fix:** Rename to `ApnData` to match the surrounding naming convention.

---

**A10-18** · INFO · `vsprintf` call in `ByteArray::asprintf` (used by `modemchat.cpp`) uses a recycled `va_list` after `va_end`

**Description:** `utils/bytearray.h` lines 19-25 (used by `modemchat.cpp` via `ByteArray::asprintf`):

```cpp
va_start(ap, cformat);
size = vsnprintf(nullptr, 0, cformat, ap);
va_end(ap);

QByteArray ba;
ba.resize(size);
vsprintf(ba.data(), cformat, ap);  // ap was already va_end'd
```

After `va_end(ap)`, the `va_list` `ap` is indeterminate; passing it to `vsprintf` is undefined behaviour. A second `va_start` / `va_end` pair is required. This is a pre-existing issue in a utility used by this module.

**Fix:** Add a second `va_start(ap, cformat)` before the `vsprintf` call and a matching `va_end(ap)` after it.

---

## Summary Table

| ID | Severity | Title |
|----|----------|-------|
| A10-1 | HIGH | Large commented-out block in `portStateChanged` obscures code path |
| A10-2 | MEDIUM | Additional scattered commented-out code throughout modemchat.cpp |
| A10-3 | MEDIUM | AT-command names leak into public interface (leaky abstraction) |
| A10-4 | MEDIUM | `args()` uses `QGenericArgument` inappropriately for internal parsing |
| A10-5 | MEDIUM | Shadow variable `isWwx` redeclared inside AT#USBCFG? handler |
| A10-6 | MEDIUM | Logic bug in `args()`: tautological OR makes bool validation dead code |
| A10-7 | MEDIUM | `updateApn()` has incorrect indentation in `else` branch |
| A10-8 | LOW | Magic number `0x0b` NTP LI/VN/Mode byte with no named constant |
| A10-9 | LOW | Magic number `123` (NTP port) used inline |
| A10-10 | LOW | Magic number `48` (NTP packet size) repeated without named constant |
| A10-11 | LOW | Incorrect/garbled comment for sentinel value in `connectServer()` |
| A10-12 | LOW | `abortConnection()` inconsistently resets `m_syncTimes` |
| A10-13 | LOW | `MAX_QMI_FAILURE_COUNT` defined but never used (dead macro) |
| A10-14 | LOW | `m_networkState` not initialised in constructor |
| A10-15 | LOW | `BE_INT` macro shifts signed `char` — undefined behaviour for bytes > 127 |
| A10-16 | LOW | `rssiRefresh()` uses fragile queue-size check instead of was-empty check |
| A10-17 | INFO | Struct `apnData` uses non-PascalCase name |
| A10-18 | INFO | `ByteArray::asprintf` uses `va_list` after `va_end` (UB in shared utility) |
