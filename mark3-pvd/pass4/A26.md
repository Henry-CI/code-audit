# Pass 4 Agent A26 — Code Quality

**Audit run:** 2026-02-28-01
**Branch:** master
**Repo root:** C:/Projects/cig-audit/repos/mark3-pvd
**Agent scope:** ui/warningdialog, utils/barcode128, utils/bytearray, utils/logger, utils/zconf (3P), utils/zlib (3P)

---

## 1. Reading Evidence

### `ui/warningdialog.h`

**Class:** `WarningDialog` (extends `QDialog`)

**Enum defined:**
- `WarningDialogType` — values: `VOR`, `Transport`, `Maintenance` (line 10, file-scope, not inside the class)

**Member variables:**
- `Ui::WarningDialog *ui` (line 21)
- `QTimer *m_timer` (line 22)
- `WarningDialogType m_type` (line 23)

**Methods declared:**

| Line | Signature |
|------|-----------|
| 17 | `explicit WarningDialog(WarningDialogType type, QWidget *parent = 0)` |
| 18 | `~WarningDialog()` |
| 24 | `QString showVorWarning()` (private) |
| 25 | `QString showTransportWarning()` (private) |
| 26 | `QString showMaintenanceWarning()` (private) |
| 29 | `void hideEvent(QHideEvent *)` (protected override) |
| 30 | `void showEvent(QShowEvent *event = 0)` (protected override) |

---

### `ui/warningdialog.cpp`

**Functions / methods defined:**

| Line | Signature |
|------|-----------|
| 5  | `WarningDialog::WarningDialog(WarningDialogType type, QWidget *parent)` — constructor |
| 18 | `void WarningDialog::showEvent(QShowEvent *event)` |
| 47 | `QString WarningDialog::showTransportWarning()` |
| 84 | `QString WarningDialog::showVorWarning()` |
| 120 | `QString WarningDialog::showMaintenanceWarning()` |
| 156 | `void WarningDialog::hideEvent(QHideEvent *)` |
| 161 | `WarningDialog::~WarningDialog()` |

No types, enums, or constants defined in the `.cpp` file.

---

### `utils/barcode128.h`

**Classes defined:**

**`BarcodeChar`**

| Line | Signature |
|------|-----------|
| 10 | `BarcodeChar()` — default constructor |
| 17 | `BarcodeChar(const BarcodeChar &other)` — copy constructor |
| 24 | `BarcodeChar(int value, QString name, QString pattern)` — value constructor |
| 31 | `BarcodeChar &operator=(const BarcodeChar &other)` |

Private members: `int m_value`, `QString m_name`, `QString m_pattern`
Friend: `class Barcode128`

**`Barcode128`**

| Line | Signature |
|------|-----------|
| 50 | `Barcode128(const QString &info, int height = 100, int sizeMult = 2)` — constructor |
| 51 | `~Barcode128()` |
| 52 | `static int width(const QString &info, int sizeMult)` |
| 54 | `QPixmap pixmap()` |
| 57 | `void initChar(int value, const QString &name, const QString &pattern)` (private) |
| 58 | `void initChars()` (private) |
| 59 | `void encodeChar(const BarcodeChar &ch)` (private) |
| 60 | `void drawBlackVerticalLineAtPos()` (private) |
| 61 | `void drawEmptyVerticalLineAtPos()` (private) |

Private members: `QMap<int, BarcodeChar> m_valueToChar`, `QMap<QString, BarcodeChar> m_nameToChar`, `QImage *m_image`, `int m_pos`, `int m_sizeMult`

---

### `utils/barcode128.cpp`

**Macros / constants defined:**

| Line | Name | Value |
|------|------|-------|
| 5 | `START_CODE` | `104` |
| 6 | `END_CODE` | `106` |
| 7 | `MODULO_VAL` | `103` |

**Functions / methods defined:**

| Line | Signature |
|------|-----------|
| 9  | `Barcode128::Barcode128(const QString &info, int height, int sizeMult)` |
| 39 | `Barcode128::~Barcode128()` |
| 45 | `QPixmap Barcode128::pixmap()` |
| 53 | `void Barcode128::initChar(int value, const QString &name, const QString &pattern)` |
| 61 | `void Barcode128::initChars()` — contains `#if START_CODE == 103` / `#elif START_CODE == 104` / `#else // todo type c` branches |
| 283 | `void Barcode128::encodeChar(const BarcodeChar &ch)` |
| 298 | `void Barcode128::drawBlackVerticalLineAtPos()` |
| 309 | `void Barcode128::drawEmptyVerticalLineAtPos()` |
| 320 | `int Barcode128::width(const QString &info, int sizeMult)` |

**Duplicate key in `initChars()` (Code B / `START_CODE == 104` branch):**
- Line 184: `initChar(12, "0", "10110011100")` — inserts key `"0"` into `m_nameToChar`
- Line 188: `initChar(16, "0", "10011101100")` — immediately overwrites key `"0"` in `m_nameToChar`

The same duplicate appears in the `START_CODE == 103` branch (lines 76 and 80).

---

### `utils/bytearray.h` (header-only)

**Macros defined:**

| Line | Macro |
|------|-------|
| 6 | `LE_INT(c1, c2, c3, c4)` |
| 7 | `BE_INT(c1, c2, c3, c4)` |
| 8 | `LE_SHORT(c1, c2)` |
| 9 | `BE_SHORT(c1, c2)` |
| 11 | `BE_LONG(c1, c2, c3, c4, c5, c6, c7, c8)` |

**Class:** `ByteArray`

| Line | Signature |
|------|-----------|
| 16 | `static QByteArray asprintf(const char *cformat, ...)` |
| 30 | `static int sscanf(const QByteArray &ba, const char *cformat, ...)` |

No enums or constants defined in the class body.

---

### `utils/logger.h`

**Enum defined:**
- `LogLevel` (file-scope, line 8): `LogDebug`, `LogInfo`, `LogWarning`, `LogCritical`, `LogFatal`, `LogNone`

**Class:** `Logger`

Static members: `Logger *m_instance`, `QMutex m_mutex`

Instance members: `QFile m_file`, `QTextStream m_outStream`, `LogLevel m_logThreshold`, `QtMessageHandler m_oldHandler`

| Line | Signature |
|------|-----------|
| 13 | `static Logger* instance()` |
| 14 | `void close()` |
| 15 | `void setLogThreshold(LogLevel level)` |
| 16 | `LogLevel logThreshold() const` |
| 17 | `void log(LogLevel level, const QString &message)` |
| 20 | `Logger()` (protected constructor) |
| 21 | `virtual ~Logger()` |
| 22 | `static void logMessageHandler(QtMsgType type, const QMessageLogContext &context, const QString &msg)` (protected) |

---

### `utils/logger.cpp`

**Macro / constant defined:**

| Line | Name | Value |
|------|------|-------|
| 8 | `LOG_FILE_DIR` | `"/mnt/sd"` |

**Functions / methods defined:**

| Line | Signature |
|------|-----------|
| 13 | `Logger::Logger()` — constructor |
| 46 | `Logger::~Logger()` |
| 54 | `Logger *Logger::instance()` |
| 62 | `void Logger::close()` |
| 70 | `void Logger::setLogThreshold(LogLevel level)` |
| 75 | `LogLevel Logger::logThreshold() const` |
| 80 | `void Logger::log(LogLevel level, const QString &msg)` |
| 117 | `void Logger::logMessageHandler(QtMsgType type, const QMessageLogContext &context, const QString &msg)` |

---

### `utils/zconf.h` and `utils/zlib.h`

Both are upstream zlib 1.3.1 (January 22nd, 2024). No project-specific additions, modifications, or extra symbols were found. No findings generated for these files.

---

## 2. Findings

---

**A26-1** · CRITICAL · `ByteArray::asprintf` uses `va_list` after `va_end` — undefined behaviour

**Description:**
In `utils/bytearray.h` lines 16–27, `asprintf` calls `va_start(ap, cformat)` to measure the required buffer size with `vsnprintf(..., 0, ...)`, then calls `va_end(ap)`. After `va_end`, the `va_list` object `ap` is indeterminate. The subsequent call to `vsprintf(ba.data(), cformat, ap)` on line 25 reuses the already-ended `va_list`, which is undefined behaviour per C99/C++11 §7.16. On ARM targets (the deployment platform) the ABI passes arguments in registers that `va_end` may trash or zero; the resulting `vsprintf` may produce garbage output, read unmapped memory, or crash. This function is called in at least 30 production `.cpp` files throughout the codebase.

**Fix:** Declare a second `va_list ap2`, call `va_copy(ap2, ap)` before `va_end(ap)`, then use `ap2` for the second format call, ending with `va_end(ap2)`. Alternatively, replace the entire function with `QByteArray::asprintf()` (available since Qt 5.5) which is safe and removes the custom variadic wrapper entirely.

---

**A26-2** · HIGH · `ByteArray::asprintf` allocates buffer without space for NUL terminator

**Description:**
In `utils/bytearray.h` line 24, `ba.resize(size)` allocates exactly `size` bytes, where `size` is the return value of `vsnprintf(nullptr, 0, ...)`. The POSIX specification for `vsnprintf` states that the return value is the number of characters that would have been written *excluding* the terminating NUL byte. `QByteArray::resize(n)` allocates `n` bytes; `vsprintf` on line 25 then writes `size` characters plus a NUL terminator, writing one byte past the end of the allocated buffer. This is a one-byte heap overflow on every call. Even if the downstream Qt code never reads past `size` bytes, the heap corruption is real and exploitable.

**Fix:** Change `ba.resize(size)` to `ba.resize(size + 1)`, then after the `vsprintf` call truncate the trailing NUL with `ba.resize(size)` if a NUL-free `QByteArray` is required. Or, as above, replace with `QByteArray::asprintf()`.

---

**A26-3** · HIGH · `Logger::instance()` is not thread-safe — double-checked locking missing

**Description:**
In `utils/logger.cpp` lines 54–60, `Logger::instance()` checks `m_instance == nullptr` and, if so, constructs a new `Logger`. There is no mutex guard around this check-and-assign sequence. If two threads call `instance()` simultaneously before the singleton is constructed, both may observe `m_instance == nullptr` and both construct a `Logger`, leaking one instance, installing two `qInstallMessageHandler` callbacks in sequence, and overwriting `m_oldHandler`. The static `m_mutex` is used correctly inside `log()`, but the singleton initialisation itself is unprotected. The `close()` function (lines 62–68) has the same problem in reverse: it deletes and nullifies `m_instance` without holding the mutex, racing with concurrent `log()` calls that have already loaded the pointer but not yet entered their own `QMutexLocker`.

**Fix:** Protect the `instance()` body with a `QMutexLocker locker(&m_mutex)` guard. Alternatively, replace the manual singleton with a function-local static (`static Logger inst; return &inst;`), which is guaranteed to be initialised once under C++11's magic-statics rules without any explicit locking. Apply the same mutex guard to `close()`.

---

**A26-4** · MEDIUM · Duplicate key `"0"` in `Barcode128::initChars()` makes one barcode character unreachable

**Description:**
In `utils/barcode128.cpp` inside both the `#if START_CODE == 103` branch (lines 76 and 80) and the active `#elif START_CODE == 104` branch (lines 184 and 188), `initChar` is called twice with the name `"0"`. The second call (`value=16, name="0"`) silently overwrites the first (`value=12, name="0"`) in `m_nameToChar` because `QMap::insert` replaces existing keys. Value 12 in Code B is the comma `,`; value 16 is the digit `0`. The net effect is that the digit `0` encodes correctly (value 16 is the right barcode-128 Code B mapping for `'0'`), but value 12 (`,`) can never be looked up by character name from `m_nameToChar`. If any caller ever attempts to encode a comma by name lookup it will silently get the `"0"` entry instead. Additionally, value 12 in Code A is the comma but the Code A table mistakenly uses `"0"` as well, suggesting a copy-paste error during table transcription.

**Fix:** Replace the second `initChar(12, "0", ...)` call with the correct character name. In Code B the character with value 12 is `,` (ASCII 44). Change line 184 of the Code B branch to `initChar(12, ",", "10110011100")`. Apply the equivalent correction to the Code A branch.

---

**A26-5** · MEDIUM · `WarningDialog` HTML generation is massively duplicated — single-character change risk

**Description:**
In `ui/warningdialog.cpp`, the three private methods `showTransportWarning()` (lines 47–82), `showVorWarning()` (lines 84–118), and `showMaintenanceWarning()` (lines 120–154) are structurally identical. Each reconstructs all six HTML fragment strings (`html1_start`, `html1_end`, `html2_start`, `html2_end`, `html3_start`, `html3_end`) in full, then builds the combined message using the same `reserve` + eight `append` calls. The only variation between the three methods is the content of `text1` (the vehicle-mode description). This is a textbook duplication risk: any change to the HTML template (e.g. a font name, CSS rule, or structure change) must be applied in three separate places consistently. It also inflates the binary and translation surface unnecessarily.

**Fix:** Refactor to a single private helper, e.g. `QString buildWarningHtml(const QString &text1, const QString &text2, const QString &text3)`, and have each of the three public-facing methods call it with the appropriate `text1`. `text2` and `text3` are already identical across all three variants and need only be defined once.

---

**A26-6** · MEDIUM · `WarningDialogType` enum is file-scope, not class-scope

**Description:**
In `ui/warningdialog.h` line 10, `enum WarningDialogType {VOR, Transport, Maintenance}` is declared at global namespace scope, not inside `WarningDialog`. The enumerator names `VOR`, `Transport`, and `Maintenance` are injected into the global namespace. `Transport` and `Maintenance` are common English words with a high collision risk in any future global symbol or platform SDK inclusion. `VOR` is the ICAO aviation acronym for VHF Omnidirectional Range and may conflict with third-party aviation or avionics libraries.

**Fix:** Move the enum inside the `WarningDialog` class body (or use `enum class WarningDialogType` as a scoped enum in C++11), and update the three call sites in `warningdialog.cpp`'s `switch` statement to use the qualified form `WarningDialog::VOR`, etc.

---

**A26-7** · LOW · `showEvent` override uses deprecated `QWidget *parent = 0` default parameter style

**Description:**
In `ui/warningdialog.h` line 30, the protected override `void showEvent(QShowEvent *event = 0)` declares a default argument of `0` (implicit null pointer) for the event parameter. The same pattern appears on line 17 for the constructor's `parent` parameter. Using integer literal `0` instead of `nullptr` is pre-C++11 style; the Qt documentation recommends `nullptr` from Qt 5 onward. The default-argument on `showEvent` is also misleading because Qt's event system always passes a valid, non-null `QShowEvent *` to overridden `showEvent`; a default argument implies the override can be called with no event, which it should not be.

**Fix:** Replace `= 0` with `= nullptr` on the constructor parameter (line 17) and remove the default argument entirely from the `showEvent` declaration (line 30), since overrides should match the base class signature exactly.

---

**A26-8** · LOW · `BeepType` enum defined but none of its values are used anywhere in the codebase

**Description:**
`platform/pwmbeeper.h` (line 15) defines a nested enum `PwmBeeper::BeepType` with values `BeepOn`, `BeepSilent`, and `BeepOff`. A grep across all `.cpp` files in the repository finds zero references to any of these enum values. The enum is not used internally within `PwmBeeper` itself — the beeper state is tracked via `bool m_beeping` and `void setBeep(bool on)`. This is dead code that adds confusion about the intended control API and may indicate an abandoned refactoring.

**Fix:** Remove the `BeepType` enum declaration from `platform/pwmbeeper.h`. If a future multi-state beep API is intended, implement and use it before committing.

---

**A26-9** · LOW · `Barcode128::initChars()` has an unimplemented Type C branch left with a comment

**Description:**
In `utils/barcode128.cpp` line 279, the preprocessor branch `#else // todo type c` is empty. If `START_CODE` were ever set to `105` (Code C mode), `initChars()` would run without inserting any characters, leaving both `QMap`s empty. Encoding would silently produce an all-zeros-value barcode rather than an error. The comment `// todo type c` documents a known incomplete implementation with no associated issue or deadline.

**Fix:** Add either a `static_assert` or a `#error` directive inside the `#else` branch to produce a compile-time failure if `START_CODE` is set to an unsupported value. This converts the silent runtime failure into a build-time error.

---

**A26-10** · LOW · `ByteArray::asprintf` comment documents unsafety but does not prevent use

**Description:**
`utils/bytearray.h` lines 15 and 29 contain comments stating "actually, do not recommend as not type safe" and "not recommend too". These comments acknowledge known problems (also found as CRITICAL and HIGH issues above) but do not discourage use at the call site and do not carry a deprecation marker. The function is called in over 30 production `.cpp` files. Self-deprecating comments without enforced deprecation provide no protection.

**Fix:** Add `[[deprecated("Use QByteArray::asprintf() instead")]]` or the Qt equivalent `Q_DECL_DEPRECATED_X(...)` to the function signatures. This produces a compiler warning at every call site, driving migration. Remove the functions once all call sites are updated.

---

**A26-11** · INFO · Mixed indentation (tabs vs spaces) in `warningdialog.h`

**Description:**
`ui/warningdialog.h` mixes tab characters (lines 22, 29, 30) with four-space indentation (lines 17–18, 21, 24–26). This is a minor style inconsistency that does not affect correctness but reduces readability and may cause diff noise.

**Fix:** Normalise to the project's chosen style (four spaces, as used in the majority of the codebase) using an editor formatter or `expand`.

---

## 3. Summary Table

| ID | Severity | File(s) | Short Title |
|----|----------|---------|-------------|
| A26-1 | CRITICAL | `utils/bytearray.h:25` | `asprintf` reuses `va_list` after `va_end` — UB |
| A26-2 | HIGH | `utils/bytearray.h:24` | Buffer allocation off by one — heap overflow on every call |
| A26-3 | HIGH | `utils/logger.cpp:54-68` | `Logger::instance()` / `close()` not thread-safe |
| A26-4 | MEDIUM | `utils/barcode128.cpp:184,188` | Duplicate key `"0"` in `initChars()` — one entry unreachable |
| A26-5 | MEDIUM | `ui/warningdialog.cpp:47-154` | Three-way HTML generation duplication — maintenance hazard |
| A26-6 | MEDIUM | `ui/warningdialog.h:10` | `WarningDialogType` enum in global namespace — name pollution |
| A26-7 | LOW | `ui/warningdialog.h:17,30` | Deprecated `= 0` null pointer style; misleading default on `showEvent` |
| A26-8 | LOW | `platform/pwmbeeper.h:15` | `BeepType` enum entirely unused — dead code |
| A26-9 | LOW | `utils/barcode128.cpp:279` | Unimplemented Type C branch — silent empty-map failure |
| A26-10 | LOW | `utils/bytearray.h:15,29` | Unsafety comment without deprecation attribute |
| A26-11 | INFO | `ui/warningdialog.h` | Mixed tab/space indentation |
