# Pass 4 Agent A14 — Code Quality

**Audit run:** 2026-02-28-01
**Branch:** master
**Assigned files:**
- `platform/internalrfid.h`
- `platform/internalrfid.cpp`
- `platform/internalrtc.h`
- `platform/internalrtc.cpp`

---

## Reading Evidence

### `platform/internalrfid.h`

**Class:** `EM070::InternalRfid` (inherits `QObject`)

| Function / Method | Line |
|---|---|
| `InternalRfid(QObject *parent = 0)` | 14 |
| `void setEnabled(bool enabled)` | 15 |
| `void response()` (signal) | 18 |
| `void cardData(quint64, quint16, quint32, QByteArray &)` (signal) | 19 |
| `void error(const QString &text)` (signal) | 20 |
| `void readData()` (private) | 23 |
| `void parseData()` (private) | 24 |

**Members:** `QSerialPort *m_serialPort`, `QByteArray m_receiver`

**Types / Constants / Enums defined:** none (all macros are in the `.cpp`)

---

### `platform/internalrfid.cpp`

**Macros defined:**

| Name | Value | Line |
|---|---|---|
| `FILE_SERIAL_PORT` | `"/dev/ttyS2"` | 7 |
| `RECEIVER_MAX_SIZE` | `128` | 8 |

**Functions implemented:**

| Function | Line |
|---|---|
| `InternalRfid::InternalRfid(QObject *parent)` | 12 |
| `InternalRfid::setEnabled(bool enabled)` | 38 |
| `InternalRfid::readData()` | 51 |
| `InternalRfid::parseData()` | 67 |

---

### `platform/internalrtc.h`

**Class:** `EM070::InternalRtc` (no base class; purely static interface)

| Function / Method | Line |
|---|---|
| `static void setRtcTime(QDateTime dateTime = QDateTime())` | 11 |
| `static void setSystemTime()` | 12 |
| `static quint64 euiAddress()` | 13 |

**Types / Constants / Enums defined:** none

---

### `platform/internalrtc.cpp`

**Macros defined:**

| Name | Value | Line |
|---|---|---|
| `FILE_RTC_DEVICE` | `"/dev/rtc1"` | 5 |
| `FILE_RTC_EUI` | `"/sys/devices/platform/nuc970-i2c0/i2c-0/0-006f/eui"` | 6 |

**Functions implemented:**

| Function | Line |
|---|---|
| `InternalRtc::setRtcTime(QDateTime dateTime)` | 10 |
| `InternalRtc::setSystemTime()` | 24 |
| `InternalRtc::euiAddress()` | 31 |

---

## Findings

---

**A14-1** · HIGH · `::stime()` is a deprecated/removed POSIX syscall

**Description:** `internalrtc.cpp` line 15 calls `::stime(&sec)`, guarded by `#ifdef __arm__`. `stime()` was removed from POSIX.1-2008 and is absent from glibc 2.31+ (Linux kernel 5.1+). On a modern toolchain this call will fail to compile or silently link against an unavailable symbol. It also requires the process to run as root (CAP_SYS_TIME), raising privilege concerns. The correct replacement is `clock_settime(CLOCK_REALTIME, ...)`.

**Fix:** Replace `::stime(&sec)` with a `clock_settime` call:
```cpp
struct timespec ts { static_cast<time_t>(sec), 0 };
::clock_settime(CLOCK_REALTIME, &ts);
```
Include `<time.h>` / `<ctime>` and remove the `stime` dependency. Verify the process holds `CAP_SYS_TIME` rather than running as root.

---

**A14-2** · HIGH · Device paths hard-coded as `#define` macros leak into binary and are not configurable at runtime for `internalrtc.cpp`

**Description:** `internalrtc.cpp` defines `FILE_RTC_DEVICE` (`/dev/rtc1`) and `FILE_RTC_EUI` (`/sys/devices/platform/nuc970-i2c0/i2c-0/0-006f/eui`) as plain `#define` macros (lines 5-6). Unlike `internalrfid.cpp` which at least provides a `QT_RFID_SERIAL_PORT` environment-variable override, the RTC paths have no override mechanism. The `sysfs` path embeds the exact hardware bus topology (`nuc970-i2c0`, bus address `0-006f`), making the binary non-portable and impossible to test on a development host without modifying source. This is a leaky abstraction: implementation detail of hardware topology is baked into the compiled artifact.

**Fix:** Promote both paths to `static constexpr QLatin1String` constants (or `QStringLiteral`) and add environment-variable overrides mirroring the pattern already used in `InternalRfid`. For the `sysfs` EUI path, consider reading the path from a platform configuration file rather than hard-coding bus topology.

---

**A14-3** · MEDIUM · Device path `FILE_SERIAL_PORT` hard-coded as `#define` macro in `internalrfid.cpp`

**Description:** `internalrfid.cpp` line 7 defines `FILE_SERIAL_PORT` as `"/dev/ttyS2"` via a C preprocessor macro. Although an environment variable override exists (`QT_RFID_SERIAL_PORT`), the macro itself is a raw `#define` rather than a typed constant, providing no type safety. The macro name is misleading because `FILE_` prefix suggests a file-system path constant, whereas Qt serial port APIs take a port name string.

**Fix:** Replace the `#define` with a `static constexpr QLatin1String` or `static const QString` in the translation unit, keeping the env-var override logic. Rename to reflect its purpose, e.g., `DefaultRfidPortName`.

---

**A14-4** · MEDIUM · `RECEIVER_MAX_SIZE` defined as untyped `#define` macro

**Description:** `internalrfid.cpp` line 8 defines `RECEIVER_MAX_SIZE 128` as a plain `#define`. This provides no type information (it could be used as `int`, `size_t`, or any numeric type without warning) and pollutes the preprocessor namespace.

**Fix:** Replace with `static constexpr int ReceiverMaxSize = 128;` (or `qsizetype`) so the constant has an explicit type and respects C++ scoping rules.

---

**A14-5** · MEDIUM · `QProcess::execute()` used with a concatenated string command — injection risk and deprecated API pattern

**Description:** `internalrtc.cpp` lines 21 and 27 construct a shell command by string concatenation (`QString cmd("hwclock -w -f "); cmd += QStringLiteral(FILE_RTC_DEVICE);`) and pass it to `QProcess::execute(QString)`. The single-argument overload of `QProcess::execute` is deprecated since Qt 5.15 in favour of `QProcess::execute(const QString &program, const QStringList &arguments)`. Additionally, passing a single concatenated string relies on the Qt implementation splitting arguments, which can mishandle paths containing spaces. While `FILE_RTC_DEVICE` is a compile-time constant here, the pattern is fragile and generates deprecation warnings on Qt 5.15+.

**Fix:** Refactor to:
```cpp
QProcess::execute(QStringLiteral("hwclock"), { QStringLiteral("-w"), QStringLiteral("-f"), QStringLiteral(FILE_RTC_DEVICE) });
```
This eliminates the deprecation warning and makes argument boundaries explicit.

---

**A14-6** · MEDIUM · `qDebug()` production log in `parseData()` emits raw card data on every read

**Description:** `internalrfid.cpp` line 79 unconditionally calls `qDebug() << "Read internal card data: " << ba;` inside `parseData()`, which fires on every RFID card presentation. In a production build where `QT_NO_DEBUG_OUTPUT` is not defined, this writes potentially sensitive card data (facility code, card number in hex) to the application log, creating an uncontrolled information disclosure path.

**Fix:** Wrap the statement in a `#ifdef QT_DEBUG` guard, or replace it with a conditional `qCDebug` category that can be toggled at runtime without a rebuild:
```cpp
qCDebug(lcRfid) << "Read internal card data:" << ba;
```
Ensure that card data logging is explicitly disabled in the production build configuration.

---

**A14-7** · MEDIUM · Signal `cardData` passes `QByteArray &` (non-const reference) — unsafe across queued connections

**Description:** Both `InternalRfid` (header line 19) and `WiegandRfid` (`wiegandrfid.h` line 20) declare the `cardData` signal with a `QByteArray &readerOutput` parameter (non-const lvalue reference). Qt signals delivered over a queued connection (across threads) cannot marshal non-const references — the value is silently treated as a copy but the API promises a reference. This is a latent bug: if the connection type is ever changed to `Qt::QueuedConnection` or the objects are moved to separate threads, the reference semantics silently break. It also violates Qt signal best-practice (signals should use `const T &` or pass by value).

**Fix:** Change the signal signature to `const QByteArray &readerOutput` (const reference) or `QByteArray readerOutput` (by value) in both `InternalRfid` and `WiegandRfid`, and update all `emit` call sites accordingly.

---

**A14-8** · LOW · Constructor default argument uses `= 0` instead of `= nullptr`

**Description:** `internalrfid.h` line 14 declares `explicit InternalRfid(QObject *parent = 0)`. Using the integer literal `0` as a null pointer constant is valid C++ but considered poor style since C++11; `nullptr` is the correct typed null-pointer constant and is already used pervasively in the rest of the codebase.

**Fix:** Change `= 0` to `= nullptr` in `InternalRfid`'s constructor declaration and definition.

---

**A14-9** · LOW · Stale `#include <QDebug>` with unconditional use — should be conditional

**Description:** `internalrfid.cpp` line 4 includes `<QDebug>` unconditionally. Given that the only use is the `qDebug()` call at line 79 (see A14-6), if that call is wrapped in a `#ifdef QT_DEBUG` guard, the include must also be guarded or moved to a debug-only block to avoid the header being pulled into release builds unnecessarily.

**Fix:** Resolve A14-6 first; then guard or remove the `<QDebug>` include to match the guarded call site.

---

**A14-10** · LOW · `setSystemTime()` has misleading comment implying it should never be called

**Description:** `internalrtc.h` line 12 contains the comment `// no need to call this as which will be done on OS booting`. The grammar is broken ("as which will be done") and the statement contradicts the function's public visibility — if callers truly should never call it, the function should be `private` or removed. Exposing it publicly while commenting that it should not be called is a documentation inconsistency and an invitation for misuse.

**Fix:** If the function is genuinely only called by OS boot scripts (not by application code), remove it from the public header or mark it `private`. If it is legitimately callable at runtime, rewrite the comment to explain when it is appropriate to call it.

---

**A14-11** · LOW · Inconsistent alignment of `#R` branch local variable declarations in `parseData()`

**Description:** `internalrfid.cpp` lines 98-107: the `#R` branch declares `QList<QByteArray> bas` inside the `else if` block, while other branches use only inline expressions. The variable name `bas` (plural of `ba`) is cryptic. This is a minor style inconsistency but reduces readability in an already dense parsing function.

**Fix:** Rename `bas` to `parts` or `fields` for clarity. Consider extracting the entire parsing of each card-format variant into named private helper methods.

---

**A14-12** · LOW · Missing `long` cast for `::stime` argument type mismatch on 64-bit ARM

**Description:** `internalrtc.cpp` line 14 stores `dateTime.toSecsSinceEpoch()` (returns `qint64`) into `long sec`. On LP64 platforms (64-bit Linux), `long` and `qint64` are both 64-bit, so this is fine. However, on ILP32 (32-bit ARM — the guarded `#ifdef __arm__` target), `long` is 32-bit and will overflow after 2038-01-19 (the Year-2038 problem). `::stime` takes `const time_t *`; on 32-bit ARM with a modern kernel and `time_t` defined as 64-bit (`CONFIG_COMPAT_32BIT_TIME`), using `long` rather than `time_t` is the wrong type.

**Fix:** Declare `time_t sec = static_cast<time_t>(dateTime.toSecsSinceEpoch());` to use the correct type regardless of platform word size. This also becomes moot if `stime` is replaced per A14-1.

---

## Summary Table

| ID | Severity | Title |
|---|---|---|
| A14-1 | HIGH | `::stime()` is a deprecated/removed POSIX syscall |
| A14-2 | HIGH | RTC device paths hard-coded with no runtime override |
| A14-3 | MEDIUM | Serial port path defined as untyped `#define` macro |
| A14-4 | MEDIUM | `RECEIVER_MAX_SIZE` defined as untyped `#define` macro |
| A14-5 | MEDIUM | `QProcess::execute(QString)` deprecated single-argument form used |
| A14-6 | MEDIUM | Unconditional `qDebug()` emits raw card data in production |
| A14-7 | MEDIUM | Signal `cardData` passes non-const `QByteArray &` — unsafe for queued connections |
| A14-8 | LOW | Constructor default argument uses `= 0` instead of `= nullptr` |
| A14-9 | LOW | `<QDebug>` included unconditionally; should match guarded call site |
| A14-10 | LOW | `setSystemTime()` has misleading and grammatically broken comment |
| A14-11 | LOW | Cryptic variable name `bas` and style inconsistency in `parseData()` |
| A14-12 | LOW | `long sec` type is wrong on 32-bit ARM — Year-2038 exposure |

**Total findings: 12** (2 HIGH, 5 MEDIUM, 5 LOW)
