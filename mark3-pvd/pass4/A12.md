# Pass 4 Agent A12 — Code Quality

**Audit run:** 2026-02-28-01
**Branch:** master
**Assigned files:**
- `platform/aescrypto.h`
- `platform/aescrypto.cpp`
- `platform/blecentral.h`
- `platform/blecentral.cpp`

---

## Reading Evidence

### `platform/aescrypto.h`

**Class:** `EM070::AesCrypto`

| Method / Member | Line | Notes |
|---|---|---|
| `static QByteArray encrypt(const QByteArray &in)` | 16 | Public static |
| `static QByteArray descrypt(const QByteArray &in)` | 17 | Public static (note: typo — should be `decrypt`) |
| `bool enableMtp()` | 20 | Private instance method |
| `QByteArray aes(const QByteArray &in, bool encrypt)` | 21 | Private instance method |
| `static bool m_mtpEnabled` | 22 | Private static member |

**Types / Enums / Constants:** none defined in the header.

**Namespace:** `EM070`

---

### `platform/aescrypto.cpp`

| Method | Line |
|---|---|
| `AesCrypto::enableMtp()` | 20 |
| `AesCrypto::aes(const QByteArray &in, bool encrypt)` | 63 |
| `AesCrypto::encrypt(const QByteArray &in)` | 150 |
| `AesCrypto::descrypt(const QByteArray &in)` | 156 |

**Constants / macros defined:**

| Symbol | Line | Value |
|---|---|---|
| `AF_ALG` | 10 | `38` (fallback `#ifndef` guard) |
| `SOL_ALG` | 13 | `279` (fallback `#ifndef` guard) |

**Platform guards:** all ARM-specific socket/crypto code wrapped in `#ifdef __arm__` (lines 2–6, 24–58, 67–145).

**Notable literals:**
- Hardcoded AES CBC IV at line 124: `"\x3d\xaf\xba\x42\x9d\x9e\xb4\x30\xb4\x22\xda\x80\x2c\x9f\xac\x41"` (16 bytes, fixed for all calls)
- Magic status bitmask at line 49: `0x1000014`, `0x3`

---

### `platform/blecentral.h`

**Classes (all in namespace `EM070`):**

1. **`CharacteristicInfo`** (inherits `QObject`) — lines 13–28
2. **`DescriptorInfo`** (inherits `QObject`) — lines 30–43
3. **`BleCentral`** (inherits `QObject`) — lines 45–126

**`CharacteristicInfo` methods:**

| Method | Line |
|---|---|
| Constructor `CharacteristicInfo(const QLowEnergyCharacteristic &, QLowEnergyService *)` | 17 |
| `QBluetoothUuid uuid() const` | 20 |
| `bool isReadable() const` | 21 |
| `bool isWritable() const` | 22 |
| `const QLowEnergyCharacteristic &characteristic() const` | 23 |
| `QLowEnergyService *parentService() const` | 24 |

**`DescriptorInfo` methods:**

| Method | Line |
|---|---|
| Constructor `DescriptorInfo(const QLowEnergyDescriptor &, CharacteristicInfo *)` | 34 |
| `QBluetoothUuid uuid() const` | 37 |
| `const QLowEnergyDescriptor &descriptor() const` | 38 |
| `const CharacteristicInfo *parentInfo() const` | 39 |

**`BleCentral` methods:**

| Method | Line | Type |
|---|---|---|
| Constructor `BleCentral(QObject *parent = nullptr)` | 51 | Public |
| `~BleCentral()` | 52 | Public |
| `void setEnabled(bool enable)` | 54 | Public |
| `void setPeripheralAddress(const quint64 &address)` | 56 | Public |
| `void setAuthorizationCode(const quint128 &uuid, const QByteArray &code)` | 57 | Public |
| `State state() const` | 59 | Public |
| `QByteArrayList servicesUuid() const` | 61 | Public |
| `QByteArrayList characteristicsUuid() const` | 62 | Public |
| `QByteArrayList descriptionsUuid() const` | 63 | Public |
| `bool readCharacteristic(const quint128 &uuid)` | 65 | Public |
| `bool writeCharacteristic(const quint128 &uuid, const QByteArray &ba)` | 66 | Public |
| `bool readDescriptor(const quint128 &uuid)` | 67 | Public |
| `bool writeDescriptor(const quint128 &uuid, const QByteArray &ba)` | 68 | Public |
| `const DescriptorInfo *descriptionInfo(const quint128 &uuid)` | 88 | Private |
| `const CharacteristicInfo *characteristicInfo(const quint128 &uuid)` | 89 | Private |
| `void startDeviceDiscovery()` | 91 | Private |
| `void connectToDevice()` | 92 | Private |
| `void addDevice(const QBluetoothDeviceInfo &)` | 95 | Private |
| `void deviceDiscoveryFinished()` | 96 | Private |
| `void deviceDiscoveryError(QBluetoothDeviceDiscoveryAgent::Error)` | 97 | Private |
| `void deviceConnected()` | 100 | Private |
| `void deviceDisconnected()` | 101 | Private |
| `void addService(const QBluetoothUuid &newService)` | 102 | Private |
| `void serviceDiscoveryFinished()` | 103 | Private |
| `void serviceStateChanged(QLowEnergyService::ServiceState newState)` | 106 | Private |

**Signals:**

| Signal | Line |
|---|---|
| `void accessible(bool yes)` | 71 |
| `void error(QBluetoothDeviceDiscoveryAgent::Error newError)` | 74 |
| `void error(QLowEnergyController::Error newError)` | 77 |
| `void error(QLowEnergyService::ServiceError newError)` | 80 |
| `void characteristicChanged(const quint128 &uuid, const QByteArray &newValue)` | 81 |
| `void characteristicRead(const quint128 &uuid, const QByteArray &value)` | 82 |
| `void characteristicWritten(const quint128 &uuid, const QByteArray &newValue)` | 83 |
| `void descriptorRead(const quint128 &uuid, const QByteArray &value)` | 84 |
| `void descriptorWritten(const quint128 &uuid, const QByteArray &newValue)` | 85 |

**Enum:**

| Enum | Values | Line |
|---|---|---|
| `BleCentral::State` | `Disabled, Discovering, Ready` | 49 |

**`#define` constants (`blecentral.cpp`):**

| Symbol | Line | Value |
|---|---|---|
| `DISCOVERY_RETRY_WAIT` | 7 | `3000` |
| `RECONNECT_RETRY_WAIT` | 8 | `2000` |
| `WAIT_FOR_CONNECTED` | 9 | `10000` |
| `WAIT_FOR_READY` | 10 | `30000` |

---

## Findings

---

**A12-1** · HIGH · Hardcoded AES IV — fixed IV destroys CBC security

**Description:** `aescrypto.cpp` line 124 embeds a literal 16-byte IV directly in the source:
```cpp
memcpy(iv->iv, "\x3d\xaf\xba\x42\x9d\x9e\xb4\x30\xb4\x22\xda\x80\x2c\x9f\xac\x41", 16);
```
CBC mode requires a unique, unpredictable IV for every encryption operation. Using the same IV for every call means that two identical plaintexts will always produce identical ciphertexts, and an adversary who observes multiple messages can detect repeated content. It also facilitates chosen-plaintext attacks. Even though the key is hardware-derived (MTP), the fixed IV leaks structural information. This is a well-known cryptographic misuse classified under CWE-329 (Not Using a Random IV with CBC Mode).

**Fix:** Generate a cryptographically random 16-byte IV per encryption call (e.g., via `/dev/urandom` or `RAND_bytes`), prepend it to the ciphertext, and read it back before decryption. Do not store or reuse the IV across calls.

---

**A12-2** · HIGH · Typo in public API: `descrypt` instead of `decrypt`

**Description:** `aescrypto.h` line 17 declares `static QByteArray descrypt(const QByteArray &in)`. This is a misspelling of `decrypt`. Although functionally minor, this identifier is part of the public API surface. Any caller already written against this name will silently continue with the misspelled symbol, and no compiler warning is raised. This also makes the API confusing to every future reader who must determine whether `descrypt` is intentional or erroneous.

**Fix:** Rename to `decrypt` throughout (`aescrypto.h` line 17 and `aescrypto.cpp` line 156). Update all call sites. If backward compatibility matters, add a deprecated alias.

---

**A12-3** · HIGH · `AesCrypto::aes()` silently returns empty `QByteArray` on non-ARM builds

**Description:** The entire implementation body of `AesCrypto::aes()` (lines 67–145) and `AesCrypto::enableMtp()` (lines 24–58) is guarded by `#ifdef __arm__`. On any non-ARM host (desktop build, CI, unit-test environment) both `encrypt()` and `descrypt()` silently return an empty `QByteArray`. There is no compile-time or run-time indication to the caller that the operation produced no output. This means data silently passes through as empty bytes on non-target builds, which could mask correctness defects in higher-level code.

**Fix:** Add a `static_assert` or `#error` for unsupported architectures, or emit a `qWarning()` / `Q_UNREACHABLE()` at the non-ARM fallback return so callers can detect the no-op at runtime. If a desktop stub is intentional, document it explicitly and have it return an error indicator rather than empty data.

---

**A12-4** · MEDIUM · C-style casts in `aescrypto.cpp`

**Description:** Lines 32–33 and 78–79 use C-style casts to strip `const` from string literals for `::strcpy`:
```cpp
::strcpy((char *) sa.salg_type, "skcipher");
::strcpy((char *) sa.salg_name, "mtp");
```
Line 116 uses a C-style cast to dereference control message data:
```cpp
* (__u32 *) CMSG_DATA(cmsg) = encrypt ? ALG_OP_ENCRYPT : ALG_OP_DECRYPT;
```
Line 122 similarly casts `CMSG_DATA(cmsg)` to `struct af_alg_iv *`. C-style casts bypass type-safety checks and hide the intent of the conversion (const-cast vs. reinterpret-cast vs. static-cast). They are a known source of subtle bugs and are flagged by `-Wold-style-cast`.

**Fix:** Replace C-style casts with explicit C++ casts (`reinterpret_cast`, `const_cast`, `static_cast`) appropriate to each context. For the `strcpy` calls, use `strncpy` (or safer Qt equivalents) with the correctly-typed buffer.

---

**A12-5** · MEDIUM · `strcpy` into fixed-size `sockaddr_alg` fields without bounds check

**Description:** Lines 32–33 and 78–79 use `::strcpy` to write into `sa.salg_type` and `sa.salg_name`, which are fixed-size character arrays (14 and 64 bytes respectively per `linux/if_alg.h`). While the literal strings used here (`"skcipher"`, `"mtp"`, `"cbc(aes)"`) are safely short, the pattern is dangerous and fragile: there is no bounds enforcement. A future developer who changes the algorithm name string to something longer will introduce a stack buffer overflow with no warning.

**Fix:** Replace `::strcpy` with `::strncpy` (or `std::memcpy`) paired with an explicit size limit equal to the field capacity, or use a safe wrapper that asserts the length at compile time.

---

**A12-6** · MEDIUM · Return value of `sendmsg()` and `read()` ignored in `aescrypto.cpp`

**Description:** Lines 134–135 and lines 140–141 call `sendmsg()` and `read()` without checking the return value:
```cpp
sendmsg(tfd, &msg, MSG_MORE);
read(tfd, ba.data() + i, 1024);
```
A failure of either call would silently produce a `QByteArray` containing uninitialised or stale data, which would then be passed back to the caller as if encryption had succeeded. This is a correctness and potential security issue: the caller cannot distinguish a successful encryption from a partial or failed one.

**Fix:** Check the return values of `sendmsg()` and `read()`. On error or short read/write, close the file descriptors, log an appropriate message, and return an empty or error-signalling `QByteArray`.

---

**A12-7** · MEDIUM · `AesCrypto` mixes static public API with instance state (`m_mtpEnabled`)

**Description:** `AesCrypto::encrypt()` and `AesCrypto::descrypt()` are public `static` methods, yet they internally construct a temporary `AesCrypto` instance (`AesCrypto aesCrypto`) to call the non-static `aes()` method. Meanwhile, `m_mtpEnabled` is a `static` member shared across all instances. This design is incoherent: the class simultaneously acts as a stateless utility (`static` public interface) and a stateful singleton (`static bool m_mtpEnabled`). The inconsistency makes the ownership and initialization semantics unclear and makes the class non-testable.

**Fix:** Decide on one design. If the class is meant to be a stateless utility, make `aes()`, `enableMtp()`, and `m_mtpEnabled` all static and remove the unnecessary instance creation. If it is meant to be a stateful object, remove `static` from the public interface and require callers to manage the object lifetime.

---

**A12-8** · MEDIUM · Commented-out code blocks in `blecentral.cpp`

**Description:** Multiple commented-out code blocks remain in production source:

- Line 30: `//connect(m_reconnectTimer, &QTimer::timeout, this, &BleCentral::connectToDevice);` — original reconnect logic replaced by a lambda, old connection left as a comment.
- Line 37: `);//&BleCentral::startDeviceDiscovery);` — inline comment fragment at the end of the lambda lambda block, residue of a previous refactor.
- Line 85: `//SerialLogger::log("[BLE:STATE] Starting device discovery\r\n");` — disabled logging statement.
- Lines 158, 161: `//if (m_previousAddress != m_device.address()) {` and `//}` — address-change guard removed but left commented.
- Lines 266, 272: Two `SerialLogger::log` calls disabled.

Commented-out code is a maintenance liability: it obscures intent, confuses reviewers, and can mislead static analysis tools.

**Fix:** Remove all commented-out code. If the address-change optimisation (lines 158/161) is intentionally deferred, document it with a `// TODO:` comment referencing a ticket. Use version control history rather than source comments to preserve old logic.

---

**A12-9** · MEDIUM · `SerialLogger::log()` called unconditionally at constructor time

**Description:** `blecentral.cpp` line 31 calls `SerialLogger::log("Reconnect timeout\r\n")` in the constructor body, immediately after a commented-out `connect()` call. This log statement appears to be debugging residue from the refactor that replaced `connectToDevice` with the inline lambda. It fires every time a `BleCentral` object is constructed, polluting the serial log with a message that has no associated event.

**Fix:** Remove the orphaned `SerialLogger::log("Reconnect timeout\r\n")` statement on line 31. If the intent is to log when the reconnect timer fires, move the log call inside the lambda body.

---

**A12-10** · MEDIUM · Duplicate `SerialLogger::log` call in `addDevice()`

**Description:** `blecentral.cpp` lines 115 and 121 both call `SerialLogger::log("[BLE:STATE] Device found MAC=...")` with identical content. Line 115 runs for every BLE device found (before the address filter), and line 121 runs again immediately after confirming the device address matches. This means the matching device address is logged twice with the same message, potentially causing confusion during log analysis.

**Fix:** Remove the duplicate on line 121 or differentiate the two messages (e.g., line 115: `"Device seen"`, line 121: `"Target device matched"`).

---

**A12-11** · MEDIUM · `requestConnectionUpdate()` called twice with identical parameters

**Description:** Identical `QLowEnergyConnectionParameters` blocks are set up and applied at both `deviceConnected()` (lines 185–189) and `serviceStateChanged()` when all services are discovered (lines 295–299):
```cpp
QLowEnergyConnectionParameters p;
p.setIntervalRange(15, 15);
p.setLatency(5);
p.setSupervisionTimeout(5000);
m_controller->requestConnectionUpdate(p);
```
This is a verbatim code duplication. The rationale for requesting the same parameters at two different lifecycle points is not documented. If the parameters ever need to change, they must be updated in two places.

**Fix:** Extract the connection parameters into a private helper method (e.g., `applyConnectionParameters()`) and call it from both locations. Optionally document why the update is repeated after service discovery.

---

**A12-12** · LOW · Magic number bitmasks in `enableMtp()` undocumented

**Description:** `aescrypto.cpp` lines 49 and 54 use magic integer constants with no explanatory comment:
```cpp
if (status == 0xffff || (status & 0x1000014)) { ... }
if ((status & 0x3) == 0x3) { ... }
```
The meaning of these bitmask values cannot be determined without reading the referenced kernel driver source (`nuc970-crypto.c`). Only a partial comment (lines 43–47) points to the driver, but the actual bit-field semantics are not explained.

**Fix:** Define named constants or enumerators for each bitmask (e.g., `MTP_STATUS_ERROR_MASK`, `MTP_STATUS_ENABLED_MASK`) and add a brief comment explaining what each bit represents per the kernel driver documentation.

---

**A12-13** · LOW · `AesCrypto` public header exposes no platform guard or capability check

**Description:** `aescrypto.h` presents a clean platform-neutral interface, but the implementation silently no-ops on non-ARM builds (see A12-3). There is no `#ifdef`, `Q_OS_LINUX`, or capability-query method in the header to signal to callers whether AES operations will actually work. A caller on a non-ARM host has no compile-time indication of this limitation.

**Fix:** Add a `static bool isSupported()` method (or equivalent `#if` guard) to the header so callers can detect at compile time or runtime whether the crypto subsystem is operational on the current platform.

---

**A12-14** · LOW · `BleCentral` `#define` timing constants should be `static constexpr`

**Description:** `blecentral.cpp` lines 7–10 define four timing constants using the C preprocessor:
```cpp
#define DISCOVERY_RETRY_WAIT    3000
#define RECONNECT_RETRY_WAIT    2000
#define WAIT_FOR_CONNECTED      10000
#define WAIT_FOR_READY          30000
```
Preprocessor macros have no type, no scope, and bypass the C++ type system. They cannot be inspected in a debugger and are replaced everywhere without regard to context.

**Fix:** Replace with `static constexpr int` (or `static constexpr std::chrono::milliseconds`) defined at the top of the `.cpp` file or in the class definition if they need to be accessed from tests.

---

**A12-15** · LOW · `m_serviceIndex` is uninitialized in the constructor member-initialization list

**Description:** `blecentral.h` declares `int m_serviceIndex` at line 125. The constructor in `blecentral.cpp` (lines 14–40) initializes `m_discoveryTimer`, `m_reconnectTimer`, `m_discoveryAgent`, `m_controller`, and `m_state` in its member-initialization list, but `m_serviceIndex` is not listed. It is first assigned at line 253 inside `serviceDiscoveryFinished()`. On compilers that do not zero-initialize plain members, `m_serviceIndex` holds an indeterminate value between object construction and the first call to `serviceDiscoveryFinished()`, which is a latent defect.

**Fix:** Add `m_serviceIndex(0)` to the constructor's member-initialization list.

---

**A12-16** · INFO · `cbuf` size calculation assumes `af_alg_iv.iv` overhead is exactly 4 bytes

**Description:** `aescrypto.cpp` line 99 allocates the control message buffer as:
```cpp
char cbuf[CMSG_SPACE(4) + CMSG_SPACE(20)];
```
The value `20` is `sizeof(struct af_alg_iv) + 16` = `4 + 16`. This relies on the implicit assumption that `struct af_alg_iv` (which contains `__u32 ivlen` and a flexible array `__u8 iv[]`) has exactly 4 bytes of overhead. This is true on current Linux ARM targets, but the calculation is fragile: it could silently break if the kernel struct layout changes or if compiled for a target with different alignment rules.

**Fix:** Replace `20` with `sizeof(struct af_alg_iv) + 16` to express the intent explicitly.

---

## Summary Table

| ID | Severity | Title |
|---|---|---|
| A12-1 | HIGH | Hardcoded AES IV — fixed IV destroys CBC security |
| A12-2 | HIGH | Typo in public API: `descrypt` instead of `decrypt` |
| A12-3 | HIGH | `AesCrypto::aes()` silently returns empty `QByteArray` on non-ARM builds |
| A12-4 | MEDIUM | C-style casts in `aescrypto.cpp` |
| A12-5 | MEDIUM | `strcpy` into fixed-size `sockaddr_alg` fields without bounds check |
| A12-6 | MEDIUM | Return values of `sendmsg()` and `read()` ignored |
| A12-7 | MEDIUM | `AesCrypto` mixes static public API with instance state (`m_mtpEnabled`) |
| A12-8 | MEDIUM | Commented-out code blocks in `blecentral.cpp` |
| A12-9 | MEDIUM | Orphaned `SerialLogger::log()` call in `BleCentral` constructor |
| A12-10 | MEDIUM | Duplicate `SerialLogger::log` call in `addDevice()` |
| A12-11 | MEDIUM | `requestConnectionUpdate()` duplicated verbatim at two lifecycle points |
| A12-12 | LOW | Magic number bitmasks in `enableMtp()` undocumented |
| A12-13 | LOW | `AesCrypto` public header exposes no platform guard or capability check |
| A12-14 | LOW | `BleCentral` timing `#define` constants should be `static constexpr` |
| A12-15 | LOW | `m_serviceIndex` uninitialized in constructor member-initialization list |
| A12-16 | INFO | `cbuf` size calculation uses implicit `af_alg_iv` overhead assumption |

**Totals:** 3 HIGH, 8 MEDIUM, 4 LOW, 1 INFO
